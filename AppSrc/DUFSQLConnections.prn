Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFSQLConnections.src
Memory Available: 2147483646
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.1\Pkg\dfallent.pkd)
67438>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardCommandBarSystem.pkg)
67438>>>// these are all the packages used in a standard MDI menubar/toolbar system
67438>>>
67438>>>Use cCJCommandBarSystem.pkg
67438>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardMenuItemClasses.pkg)
67438>>>>>Use Dfpanel.pkg
67438>>>>>Use cCJCommandBarSystem.pkg
67438>>>>>Use LanguageText.pkg
67438>>>>>
67438>>>>>
67438>>>>>Class cCJUndoMenuItem is a cCJMenuItem
67439>>>>>    
67439>>>>>    Procedure Construct_Object
67441>>>>>        Forward Send Construct_Object
67443>>>>>        Set psCaption   to C_$CaptionUndo
67444>>>>>        Set psToolTip to C_$ToolTipUndo
67445>>>>>        Set psDescription to C_$DescUndo
67446>>>>>        Set psImage to "ActionUndo.ico"
67447>>>>>        Set pbActiveUpdate to True
67448>>>>>        Set psCategory to C_$CategoryEdit
67449>>>>>        Set psShortcut to C_$Key_Ctrl_Z
67450>>>>>    End_Procedure
67451>>>>>    
67451>>>>>    Procedure OnExecute Variant vCommandBarControl
67453>>>>>        Send Undo of (focus(Self))
67454>>>>>    End_Procedure
67455>>>>>    
67455>>>>>    Function IsEnabled Returns Boolean
67457>>>>>        Boolean bEnabled
67457>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
67458>>>>>        Function_Return bEnabled
67459>>>>>    End_Function
67460>>>>>    
67460>>>>>End_Class
67461>>>>>
67461>>>>>
67461>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
67462>>>>>    
67462>>>>>    Procedure Construct_Object
67464>>>>>        Forward Send Construct_Object
67466>>>>>        Set psCaption   to C_$CaptionDelete
67467>>>>>        Set psToolTip to C_$ToolTipDelete
67468>>>>>        Set psDescription to C_$DescDelete
67469>>>>>        Set psImage to "actionDelete.ico"
67470>>>>>        Set psShortcut to C_$Key_Delete
67471>>>>>        Set pbActiveUpdate to True
67472>>>>>        Set psCategory to C_$CategoryEdit
67473>>>>>    End_Procedure
67474>>>>>    
67474>>>>>    
67474>>>>>    Procedure OnExecute Variant vCommandBarControl
67476>>>>>        Send Delete of (focus(Self))
67477>>>>>    End_Procedure
67478>>>>>    
67478>>>>>    Function IsEnabled Returns Boolean
67480>>>>>        Boolean bEnabled
67480>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
67481>>>>>        Function_Return bEnabled
67482>>>>>    End_Function
67483>>>>>    
67483>>>>>End_Class
67484>>>>>
67484>>>>>
67484>>>>>Class cCJCutMenuItem is a cCJMenuItem
67485>>>>>    
67485>>>>>    Procedure Construct_Object
67487>>>>>        Forward Send Construct_Object
67489>>>>>        Set psCaption   to C_$CaptionCut
67490>>>>>        Set psToolTip to C_$TooltipCut
67491>>>>>        Set psDescription to C_$DescCut
67492>>>>>        Set psImage to "actionCut.ico"
67493>>>>>        Set psShortcut to C_$Key_Ctrl_X
67494>>>>>        Set pbActiveUpdate to True
67495>>>>>        Set psCategory to C_$CategoryEdit
67496>>>>>    End_Procedure
67497>>>>>    
67497>>>>>    
67497>>>>>    Procedure OnExecute Variant vCommandBarControl
67499>>>>>        Send Cut of (focus(Self))
67500>>>>>    End_Procedure
67501>>>>>    
67501>>>>>    Function IsEnabled Returns Boolean
67503>>>>>        Boolean bEnabled
67503>>>>>        Get CanCut of (Focus(Self)) to bEnabled
67504>>>>>        Function_Return bEnabled
67505>>>>>    End_Function
67506>>>>>    
67506>>>>>End_Class
67507>>>>>
67507>>>>>
67507>>>>>Class cCJCopyMenuItem is a cCJMenuItem
67508>>>>>    
67508>>>>>    Procedure Construct_Object
67510>>>>>        Forward Send Construct_Object
67512>>>>>        Set psCaption   to C_$CaptionCopy
67513>>>>>        Set psToolTip to C_$ToolTipCopy
67514>>>>>        Set psDescription to C_$DescCopy
67515>>>>>        Set psImage to "actionCopy.ico"
67516>>>>>        Set psShortcut to C_$Key_Ctrl_C
67517>>>>>        Set pbActiveUpdate to True
67518>>>>>        Set psCategory to C_$CategoryEdit
67519>>>>>    End_Procedure
67520>>>>>    
67520>>>>>    
67520>>>>>    Procedure OnExecute Variant vCommandBarControl
67522>>>>>        Send Copy of (focus(Self))
67523>>>>>    End_Procedure
67524>>>>>    
67524>>>>>    Function IsEnabled Returns Boolean
67526>>>>>        Boolean bEnabled
67526>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
67527>>>>>        Function_Return bEnabled
67528>>>>>    End_Function
67529>>>>>    
67529>>>>>End_Class
67530>>>>>
67530>>>>>
67530>>>>>Class cCJPasteMenuItem is a cCJMenuItem
67531>>>>>    
67531>>>>>    Procedure Construct_Object
67533>>>>>        Forward Send Construct_Object
67535>>>>>        Set psCaption   to C_$CaptionPaste
67536>>>>>        Set psToolTip to C_$ToolTipPaste
67537>>>>>        Set psDescription to C_$DescPaste
67538>>>>>        Set psImage to "actionPaste.ico"
67539>>>>>        Set pbActiveUpdate to True
67540>>>>>        Set psShortcut to C_$Key_Ctrl_V
67541>>>>>        Set psCategory to C_$CategoryEdit
67542>>>>>    End_Procedure
67543>>>>>    
67543>>>>>    
67543>>>>>    Procedure OnExecute Variant vCommandBarControl
67545>>>>>        Send Paste of (focus(Self))
67546>>>>>    End_Procedure
67547>>>>>    
67547>>>>>    Function IsEnabled Returns Boolean
67549>>>>>        Boolean bEnabled
67549>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
67550>>>>>        Function_Return bEnabled
67551>>>>>    End_Function
67552>>>>>    
67552>>>>>End_Class
67553>>>>>
67553>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
67554>>>>>    
67554>>>>>    Procedure Construct_Object
67556>>>>>        Forward Send Construct_Object
67558>>>>>        Set psCaption   to C_$CaptionSelectAll
67559>>>>>        Set psToolTip to C_$ToolTipSelectAll
67560>>>>>        Set psDescription to C_$DescSelectAll
67561>>>>>        Set pbActiveUpdate to True
67562>>>>>        Set psShortcut to C_$Key_Ctrl_A
67563>>>>>        Set psCategory to C_$CategoryEdit
67564>>>>>    End_Procedure
67565>>>>>    
67565>>>>>    
67565>>>>>    Procedure OnExecute Variant vCommandBarControl
67567>>>>>        Send Select_All of (focus(Self))
67568>>>>>    End_Procedure
67569>>>>>    
67569>>>>>    Function IsEnabled Returns Boolean
67571>>>>>        Boolean bEnabled
67571>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
67572>>>>>        Function_Return bEnabled
67573>>>>>    End_Function
67574>>>>>    
67574>>>>>End_Class
67575>>>>>
67575>>>>>
67575>>>>>Class cCJExitMenuItem is a cCJMenuItem
67576>>>>>    
67576>>>>>    Procedure Construct_Object
67578>>>>>        Forward Send Construct_Object
67580>>>>>        Set psCaption to C_$CaptionExit
67581>>>>>        Set psToolTip to C_$ToolTipExit
67582>>>>>        Set psDescription to C_$ToolTipExit
67583>>>>>        Set psShortcut to C_$Key_Alt_F4
67584>>>>>        Set psCategory to C_$CategoryFile
67585>>>>>    End_Procedure
67586>>>>>    
67586>>>>>    Procedure OnExecute Variant vCommandBarControl
67588>>>>>        Send Exit_Application of Desktop
67589>>>>>    End_Procedure
67590>>>>>    
67590>>>>>End_Class
67591>>>>>
67591>>>>>Class cCJHelpMenuItem is a cCJMenuItem
67592>>>>>    
67592>>>>>    Procedure Construct_Object
67594>>>>>        Forward Send Construct_Object
67596>>>>>        Set psCaption to C_$CaptionHelp
67597>>>>>        Set psDescription to C_$ToolTipHelp
67598>>>>>        Set psToolTip to C_$DescHelp
67599>>>>>        Set psImage to "ActionHelp.ico"
67600>>>>>        Set psShortcut to "F1"
67601>>>>>        Set psCategory to C_$CategoryHelp
67602>>>>>    End_Procedure
67603>>>>>    
67603>>>>>    Procedure OnExecute Variant vCommandBarControl
67605>>>>>        Send Help of (Focus(Self))
67606>>>>>    End_Procedure
67607>>>>>    
67607>>>>>End_Class
67608>>>>>
67608>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
67609>>>>>    
67609>>>>>    Procedure Construct_Object
67611>>>>>        Forward Send Construct_Object
67613>>>>>        Set psCaption to C_$CaptionAddStatusbar
67614>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
67615>>>>>        Set psDescription to  C_$DescAddStatusbar
67616>>>>>        Set psCategory to C_$CategoryWindow
67617>>>>>    End_Procedure
67618>>>>>    
67618>>>>>    Procedure OnExecute Variant vCommandBarControl
67620>>>>>        Handle hoCommandBars hoClientArea
67620>>>>>        Get CommandBarSystemObject to hoCommandBars
67621>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67622>>>>>        If hoClientArea Begin
67624>>>>>            // the clientarea's parent panel has message
67624>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
67625>>>>>        End
67625>>>>>>
67625>>>>>    End_Procedure
67626>>>>>    
67626>>>>>    Function IsChecked Returns Boolean
67628>>>>>        Boolean bOn
67628>>>>>        Handle hoCommandBars hoClientArea
67628>>>>>        Get CommandBarSystemObject to hoCommandBars
67629>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67630>>>>>        If hoClientArea Begin
67632>>>>>            // the clientarea's parent panel has message
67632>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
67633>>>>>        End
67633>>>>>>
67633>>>>>        Function_Return bOn
67634>>>>>    End_Function
67635>>>>>End_Class
67636>>>>>
67636>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
67637>>>>>    
67637>>>>>    Procedure Construct_Object
67639>>>>>        Forward Send Construct_Object
67641>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
67642>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
67643>>>>>        Set psDescription to C_$DescAutoArrangeIcons
67644>>>>>        Set psCategory to C_$CategoryWindow
67645>>>>>    End_Procedure
67646>>>>>    
67646>>>>>    Procedure OnExecute Variant vCommandBarControl
67648>>>>>        Handle hoCommandBars hoClientArea
67648>>>>>        Get CommandBarSystemObject to hoCommandBars
67649>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67650>>>>>        If hoClientArea Begin
67652>>>>>            // the clientarea's parent panel has message
67652>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
67653>>>>>        End
67653>>>>>>
67653>>>>>    End_Procedure
67654>>>>>    
67654>>>>>    Function IsChecked Returns Boolean
67656>>>>>        Boolean bOn
67656>>>>>        Handle hoCommandBars hoClientArea
67656>>>>>        Get CommandBarSystemObject to hoCommandBars
67657>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67658>>>>>        If hoClientArea Begin
67660>>>>>            // the clientarea's parent panel has message
67660>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
67661>>>>>        End
67661>>>>>>
67661>>>>>        Function_Return bOn
67662>>>>>    End_Function
67663>>>>>End_Class
67664>>>>>
67664>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
67665>>>>>    
67665>>>>>    Procedure Construct_Object
67667>>>>>        Forward Send Construct_Object
67669>>>>>        Set psCaption to C_$CaptionRestoreMenus
67670>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
67671>>>>>        Set psDescription to C_$DescRestoreMenus
67672>>>>>        Set psCategory to C_$CategoryWindow
67673>>>>>    End_Procedure
67674>>>>>    
67674>>>>>    Procedure OnExecute Variant vCommandBarControl
67676>>>>>        Handle hoCommandBars
67676>>>>>        Get CommandBarSystemObject to hoCommandBars
67677>>>>>        Send RestoreLayout of hoCommandBars
67678>>>>>    End_Procedure
67679>>>>>    
67679>>>>>End_Class
67680>>>>>
67680>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
67681>>>>>    
67681>>>>>    Procedure Construct_Object
67683>>>>>        Forward Send Construct_Object
67685>>>>>        Set psCaption to C_$CaptionCascade
67686>>>>>        Set psToolTip to C_$ToolTipCascade
67687>>>>>        Set psDescription to  C_$DescCascade
67688>>>>>        Set psImage to "ActionCascade.ico"
67689>>>>>        Set psCategory to C_$CategoryWindow
67690>>>>>    End_Procedure
67691>>>>>    
67691>>>>>    Procedure OnExecute Variant vCommandBarControl
67693>>>>>        Handle hoCommandBars hoClientArea
67693>>>>>        Get CommandBarSystemObject to hoCommandBars
67694>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67695>>>>>        If hoClientArea Begin
67697>>>>>            Send Cascade_Windows of hoClientArea
67698>>>>>        End
67698>>>>>>
67698>>>>>    End_Procedure
67699>>>>>End_Class
67700>>>>>
67700>>>>>Class cCJTileHorizontally is a cCJMenuItem
67701>>>>>    
67701>>>>>    Procedure Construct_Object
67703>>>>>        Forward Send Construct_Object
67705>>>>>        Set psCaption to C_$CaptionTileHorizontally
67706>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
67707>>>>>        Set psDescription to  C_$DescTileHorizontally
67708>>>>>        Set psImage to "ActionTileHorizontally.ico"
67709>>>>>        Set psCategory to C_$CategoryWindow
67710>>>>>    End_Procedure
67711>>>>>    
67711>>>>>    Procedure OnExecute Variant vCommandBarControl
67713>>>>>        Handle hoCommandBars hoClientArea
67713>>>>>        Get CommandBarSystemObject to hoCommandBars
67714>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67715>>>>>        If hoClientArea Begin
67717>>>>>            Send Tile_Windows_Horizontal of hoClientArea
67718>>>>>        End
67718>>>>>>
67718>>>>>    End_Procedure
67719>>>>>End_Class
67720>>>>>
67720>>>>>Class cCJTileVertically is a cCJMenuItem
67721>>>>>    
67721>>>>>    Procedure Construct_Object
67723>>>>>        Forward Send Construct_Object
67725>>>>>        Set psCaption to C_$CaptionTileVertically
67726>>>>>        Set psToolTip to C_$ToolTipTileVertically
67727>>>>>        Set psDescription to  C_$DescTileVertically
67728>>>>>        Set psImage to "ActionTileVertically.ico"
67729>>>>>        Set psCategory to C_$CategoryWindow
67730>>>>>    End_Procedure
67731>>>>>    
67731>>>>>    Procedure OnExecute Variant vCommandBarControl
67733>>>>>        Handle hoCommandBars hoClientArea
67733>>>>>        Get CommandBarSystemObject to hoCommandBars
67734>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67735>>>>>        If hoClientArea Begin
67737>>>>>            Send Tile_Windows_Vertical of hoClientArea
67738>>>>>        End
67738>>>>>>
67738>>>>>    End_Procedure
67739>>>>>End_Class
67740>>>>>
67740>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
67741>>>>>    
67741>>>>>    Procedure Construct_Object
67743>>>>>        Forward Send Construct_Object
67745>>>>>        Set psCaption to C_$CaptionMinimizeWindows
67746>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
67747>>>>>        Set psDescription to  C_$DescMinimizeWindows
67748>>>>>        Set psCategory to C_$CategoryWindow
67749>>>>>    End_Procedure
67750>>>>>    
67750>>>>>    Procedure OnExecute Variant vCommandBarControl
67752>>>>>        Handle hoCommandBars hoClientArea
67752>>>>>        Get CommandBarSystemObject to hoCommandBars
67753>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67754>>>>>        If hoClientArea Begin
67756>>>>>            // the clientarea's parent panel has message
67756>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
67757>>>>>        End
67757>>>>>>
67757>>>>>    End_Procedure
67758>>>>>End_Class
67759>>>>>
67759>>>>>
67759>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
67760>>>>>    
67760>>>>>    Procedure Construct_Object
67762>>>>>        Forward Send Construct_Object
67764>>>>>        Set psCaption to C_$CaptionRestoreWindows
67765>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
67766>>>>>        Set psDescription to  C_$DescRestoreWindows
67767>>>>>        Set psCategory to C_$CategoryWindow
67768>>>>>    End_Procedure
67769>>>>>    
67769>>>>>    Procedure OnExecute Variant vCommandBarControl
67771>>>>>        Handle hoCommandBars hoClientArea
67771>>>>>        Get CommandBarSystemObject to hoCommandBars
67772>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67773>>>>>        If hoClientArea Begin
67775>>>>>            // the clientarea's parent panel has message
67775>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
67776>>>>>        End
67776>>>>>>
67776>>>>>    End_Procedure
67777>>>>>End_Class
67778>>>>>
67778>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
67779>>>>>    
67779>>>>>    Procedure Construct_Object
67781>>>>>        Forward Send Construct_Object
67783>>>>>        Set psCaption to C_$CaptionArrangeIcons
67784>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
67785>>>>>        Set psDescription to  C_$DescArrangeIcons
67786>>>>>        Set psCategory to C_$CategoryWindow
67787>>>>>    End_Procedure
67788>>>>>    
67788>>>>>    Procedure OnExecute Variant vCommandBarControl
67790>>>>>        Handle hoCommandBars hoClientArea
67790>>>>>        Get CommandBarSystemObject to hoCommandBars
67791>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67792>>>>>        If hoClientArea Begin
67794>>>>>            Send Arrange_Icons of hoClientArea
67795>>>>>        End
67795>>>>>>
67795>>>>>    End_Procedure
67796>>>>>    
67796>>>>>End_Class
67797>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJAboutMenuItem.pkg)
67797>>>>>Use cCJCommandBarSystem.pkg
67797>>>>>Use LanguageText.pkg
67797>>>>>
67797>>>>>// It is expected that if you use this class that you provide an about object that is
67797>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
67797>>>>>// because you may wish to create your own custom about package.
67797>>>>>
67797>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
67798>>>>>
67798>>>>>    Procedure Construct_Object
67800>>>>>        Forward Send Construct_Object
67802>>>>>        Set psCaption to C_$CaptionAbout
67803>>>>>        Set psDescription to C_$ToolTipAbout
67804>>>>>        Set psToolTip to C_$DescAbout
67805>>>>>        Set psImage to "ActionAbout.ico"
67806>>>>>        Set psCategory to C_$CategoryHelp
67807>>>>>    End_Procedure
67808>>>>>    
67808>>>>>    Procedure OnExecute Variant vCommandBarControl
67810>>>>>        Handle hoCommandBars hoClientArea
67810>>>>>        Get CommandBarSystemObject to hoCommandBars
67811>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67812>>>>>        If hoClientArea Begin
67814>>>>>            Send Activate_About of hoClientArea
67815>>>>>        End
67815>>>>>>
67815>>>>>    End_Procedure
67816>>>>>
67816>>>>>End_Class
67817>>>>>
67817>>>>>
67817>>>Use cCJDeoMenuItemClasses.pkg
67817>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJMDIWindowsMenuItem.pkg)
67817>>>>>Use cCJCommandBarSystem.pkg
67817>>>>>
67817>>>>>Register_Function Client_ID Returns Integer
67817>>>>>
67817>>>>>// only used by cCJMDIWIndowsMenuItem
67817>>>>>Class cCJMDIWindowItem is a cCJMenuItem
67818>>>>>    
67818>>>>>    Procedure Construct_Object
67820>>>>>        Forward Send Construct_Object
67822>>>>>        Property Handle phWindow 0 // object id of view
67823>>>>>        Set pbControlFlagNoMovable to True
67824>>>>>        Set pbActiveUpdate to True
67825>>>>>    End_Procedure
67826>>>>>    
67826>>>>>    Procedure OnExecute Variant vCommandBarControl
67828>>>>>        Handle hWindow
67828>>>>>        Get phWindow to hWindow
67829>>>>>        Send Activate_View of hWindow
67830>>>>>    End_Procedure
67831>>>>>    
67831>>>>>End_Class
67832>>>>>
67832>>>>>
67832>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
67833>>>>>    
67833>>>>>    Procedure Construct_Object
67835>>>>>        Forward Send Construct_Object
67837>>>>>        Property Handle[] phArrayOfWindows
67838>>>>>        Set peControlType to xtpControlPopup
67839>>>>>        Set psCategory to C_$CategoryWindow
67840>>>>>    End_Procedure
67841>>>>>    
67841>>>>>    // This adds MDI windows to the existing menu items.
67841>>>>>    // This removes any existing windows menus and always adds a new set to the end
67841>>>>>    
67841>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
67843>>>>>        Handle  hClientArea hView
67843>>>>>        String  sLabel
67843>>>>>        Integer i iWindows
67843>>>>>        Handle[] hArrayOfWindows
67844>>>>>        Variant vItem
67844>>>>>        
67844>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
67844>>>>>        // also assume that destroying an action removes all menu instances of that action
67844>>>>>        Get phArrayOfWindows to hArrayOfWindows
67845>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
67846>>>>>        For i from 0 to (iWindows-1)
67852>>>>>>
67852>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
67853>>>>>        Loop
67854>>>>>>
67854>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
67855>>>>>        
67855>>>>>        // Add all views to this menu. Create the action and add the item
67855>>>>>        Move 0 to i
67856>>>>>        Get Client_Id to hClientArea // object id of client area
67857>>>>>        If (hClientArea > 0) Begin
67859>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
67860>>>>>            While (hView <> 0)
67864>>>>>                If (Active_State(hView)) Begin
67866>>>>>                    // create the action
67866>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
67867>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
67868>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
67869>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
67870>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
67872>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
67873>>>>>                    End
67873>>>>>>
67873>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
67874>>>>>                    If (i=0) Begin
67876>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
67877>>>>>                    End
67877>>>>>>
67877>>>>>                    // Create a menu item for this action
67877>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
67878>>>>>                    Increment i
67879>>>>>                End
67879>>>>>>
67879>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
67880>>>>>            Loop
67881>>>>>>
67881>>>>>        End
67881>>>>>>
67881>>>>>        
67881>>>>>        Set phArrayOfWindows to hArrayOfWindows
67882>>>>>        
67882>>>>>    End_Procedure
67883>>>>>    
67883>>>>>End_Class
67884>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vWin32fh.pkg)
67884>>>// This code is part of VDF GUIdance
67884>>>// Visit us @ http://www.vdf-guidance.com
67884>>>// e-Mail us @ info@vdf-guidance.com
67884>>>// VDF GUIdance is a mutual project of
67884>>>// Frank Vandervelpen - Vandervelpen Systems and
67884>>>// Wil van Antwerpen  - Antwise Solutions
67884>>>// All software source code should be used <<AS IS>> without any warranty.
67884>>>//
67884>>>//
67884>>>// *** Windows 32bit file handling wrapper class ***
67884>>>//
67884>>>
67884>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
67884>>>//                   This may be painfull for some of you, but it was really needed as it was
67884>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
67884>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
67884>>>//
67884>>>// The used naming-convention is:
67884>>>//     - a prefix of "vWin32_" for every external function declaration
67884>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
67884>>>//
67884>>>// By using this we are guarding ourselves for conflicts with variable declarations
67884>>>// of DataAccess in the future.
67884>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
67884>>>//
67884>>>// mm-dd-yyyy Author Description
67884>>>//
67884>>>//                   vSHGetFolderPath added to retrieve the new shell folders
67884>>>//                   vGetWindowsDirectory
67884>>>//
67884>>>//                   vGetTempFileName
67884>>>//                   vGetTempPath
67884>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
67884>>>//                   This is an absolute need for WebApp. We expect you to handle the
67884>>>//                   error in your application anyways. Changed this for:
67884>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
67884>>>// 03-02-2002 **WvA: vRemoveDirectory added
67884>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
67884>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
67884>>>//                   It is renamed too avoid this.
67884>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
67884>>>//                   function vSelectedFileName is now just SelectedFileName
67884>>>//                   Removed the local keyword in the variable declarations
67884>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
67884>>>//                   created file-open dialog
67884>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
67884>>>//                   in that it didn't exactly return the correct filename of the file created.
67884>>>//                   This has now been taken care of.
67884>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
67884>>>//                   These declarations are now included from the vWin32fh header file.
67884>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
67884>>>//                   Before today one could always undo the operation, as of now you cannot as
67884>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
67884>>>//                   Since i don't really expect someone to use that feature it has been removed.
67884>>>//                   One can however restore to the old way of handling by simply calling the
67884>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
67884>>>//                   filehandling operations
67884>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
67884>>>//                   as well as the StringFromRightOfChar function.
67884>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
67884>>>//                   DISABLED now as testing shows that it does not work as advertised...
67884>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
67884>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
67884>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
67884>>>//                   extended characters are treated ok too.
67884>>>//                   Reported by Flemming from
67884>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
67884>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
67884>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
67884>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
67884>>>//                   Added vSelectSavefile function to create a file save dialog
67884>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
67884>>>//                   Added vParentPath function to retrieve the parent "node" of a path
67884>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
67884>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
67884>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
67884>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
67884>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
67884>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
67884>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
67884>>>
67884>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
67884>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\cvFileDialogs.pkg)
67884>>>>>//***************************************************************************
67884>>>>>//*
67884>>>>>//* Class:        cvSaveAsDialog
67884>>>>>//* Package Name: cvFileDialogs.pkg
67884>>>>>//*
67884>>>>>//***************************************************************************
67884>>>>>
67884>>>>>Use File_dlg.pkg
67884>>>>>
67884>>>>>// *WvA: 13-01-1999 Created
67884>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
67884>>>>>// This function opens the Windows standard file open dialog and returns the selected
67884>>>>>// file_name.
67884>>>>>Class cvSelectFile_Dialog is an OpenDialog
67885>>>>>
67885>>>>>    Procedure Construct_Object Integer iImage_Id
67887>>>>>        Forward Send Construct_Object iImage_Id
67889>>>>>        Set HideReadOnly_State to True
67890>>>>>    End_Procedure
67891>>>>>
67891>>>>>    Function SelectedFileName Returns String
67893>>>>>        String sFileName
67893>>>>>        Move "" to sFileName
67894>>>>>        If (Show_Dialog(Self)) Begin
67896>>>>>            Move (RTrim(File_Name(Self))) to sFileName
67897>>>>>        End
67897>>>>>>
67897>>>>>        Function_Return sFileName
67898>>>>>    End_Function
67899>>>>>End_Class
67900>>>>>
67900>>>>>// *WvA: 13-01-1999 Created
67900>>>>>// This function opens the Windows standard file open dialog and returns the selected
67900>>>>>// file_name. Returns '' if the user didn't make a selection.
67900>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
67900>>>>>//                   file-open dialog
67900>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
67902>>>>>    String sSelectedFile
67902>>>>>    Integer hoOpenFileDialog
67902>>>>>
67902>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
67904>>>>>
67904>>>>>        Set Dialog_Caption    to sCaptionText
67905>>>>>        Set Filter_String     to sSupportedFileTypes
67906>>>>>        Set Initial_Folder    to sInitialFolder
67907>>>>>
67907>>>>>        Move Self       to hoOpenFileDialog
67908>>>>>    End_Object
67909>>>>>
67909>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
67910>>>>>    Send Destroy_Object to hoOpenFileDialog
67911>>>>>    Function_Return sSelectedFile
67912>>>>>End_Function
67913>>>>>
67913>>>>>Class cvSaveAsDialog is a SaveAsDialog
67914>>>>>
67914>>>>>    Procedure Construct_Object
67916>>>>>        Forward Send Construct_Object
67918>>>>>        Set HideReadOnly_State to True
67919>>>>>    End_Procedure
67920>>>>>
67920>>>>>    Function SelectedFileName Returns String
67922>>>>>        String sFileName
67922>>>>>        Move "" to sFileName
67923>>>>>        If (Show_Dialog(Self)) Begin
67925>>>>>            Move (RTrim(File_Name(Self))) to sFileName
67926>>>>>        End
67926>>>>>>
67926>>>>>        Function_Return sFileName
67927>>>>>    End_Function
67928>>>>>
67928>>>>>End_Class
67929>>>>>
67929>>>>>// Added optional default filename as suggested by Nils
67929>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
67931>>>>>    String sSelectedFile
67931>>>>>    Integer hoDialog
67931>>>>>
67931>>>>>    Move "" to sSelectedFile
67932>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
67933>>>>>    If (hoDialog) Begin
67935>>>>>    //Set NoChangeDir_State Of hoDialog To True
67935>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
67936>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
67937>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
67938>>>>>        If (Num_Arguments = 4) Begin
67940>>>>>            Set File_Title        of hoDialog to sDefaultFileName
67941>>>>>        End
67941>>>>>>
67941>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
67942>>>>>        Send Destroy of hoDialog
67943>>>>>    End
67943>>>>>>
67943>>>>>    Function_Return sSelectedFile
67944>>>>>End_Function
67945>>>Use Seq_chnl.pkg
67945>>>
67945>>>Use windows.pkg
67945>>>Use Dll.pkg
67945>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fh.h)
67945>>>>>//TH-Header
67945>>>>>//*****************************************************************************************
67945>>>>>// Copyright (c)  2004 KURANT Project
67945>>>>>// All rights reserved.
67945>>>>>//
67945>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
67945>>>>>// $ProjectName : Windows 32 bits file handling
67945>>>>>// $Authors     : Wil van Antwerpen
67945>>>>>// $Created     : 19.02.2004  19:25
67945>>>>>// $Type        : BSD (as in do with it whatever you like)
67945>>>>>//
67945>>>>>// Contents:
67945>>>>>//  This file contains the Windows API external function call definitions and
67945>>>>>//  constants as they are used in the vWin32fh package.
67945>>>>>//*****************************************************************************************
67945>>>>>//TH-RevisionStart
67945>>>>>//TH-RevisionEnd
67945>>>>>
67945>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
67945>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
67945>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
67945>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
67945>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
67945>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
67945>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
67945>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
67945>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
67945>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
67945>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
67945>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
67945>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
67945>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
67945>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
67945>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
67945>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
67945>>>>>
67945>>>>>
67945>>>>>Define vMax_Path     For |CI260
67945>>>>>Define vMinChar      For |CI$80
67945>>>>>Define vMaxChar      For |CI$7F
67945>>>>>Define vMinShort     For |CI$8000
67945>>>>>Define vMaxShort     For |CI$7FFF
67945>>>>>Define vMinLong      For |CI$80000000
67945>>>>>Define vMaxLong      For |CI$7FFFFFFF
67945>>>>>Define vMaxByte      For |CI$FF
67945>>>>>Define vMaxWord      For |CI$FFFF
67945>>>>>Define vMaxDword     For |CI$FFFFFFFF
67945>>>>>
67945>>>>>
67945>>>>>
67945>>>>>// For FindFirstFile
67945>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
67945>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
67945>>>>>Define vERROR_NO_MORE_FILES    For |CI18
67945>>>>>
67945>>>>>// The defines below can be used to find out what kind of error has occurred if
67945>>>>>// the API-call ShellExecute is used.
67945>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
67945>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
67945>>>>>Define vERROR_BAD_FORMAT       For |CI0011
67945>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
67945>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
67945>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
67945>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
67945>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
67945>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
67945>>>>>Define vSE_ERR_FNF             For |CI0002
67945>>>>>Define vSE_ERR_NOASSOC         For |CI0031
67945>>>>>Define vSE_ERR_OOM             For |CI0008
67945>>>>>Define vSE_ERR_PNF             For |CI0003
67945>>>>>Define vSE_ERR_SHARE           For |CI0026
67945>>>>>
67945>>>>>
67945>>>>>// C-Structure
67945>>>>>//typedef struct _browseinfo {
67945>>>>>//    HWND hwndOwner;
67945>>>>>//    LPCITEMIDLIST pidlRoot;
67945>>>>>//    LPSTR pszDisplayName;
67945>>>>>//    LPCSTR lpszTitle;
67945>>>>>//    UINT ulFlags;
67945>>>>>//    BFFCALLBACK lpfn;
67945>>>>>//    LPARAM lParam;
67945>>>>>//    int iImage;
67945>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
67945>>>>>
67945>>>>>//declare C structure struct_browseinfo
67945>>>>>//as documented in MSDN under Windows Shell API
67945>>>>>Struct tvBrowseInfo
67945>>>>>  Handle    hWndOwner
67945>>>>>  Pointer   pIDLRoot
67945>>>>>  Pointer   pszDisplayName
67945>>>>>  Pointer   lpszTitle
67945>>>>>  dWord     ulFlags
67945>>>>>  Pointer   lpfnCallback
67945>>>>>  dWord     lParam
67945>>>>>  DWord     iImage
67945>>>>>End_Struct // tvBrowseInfo
67945>>>>>
67945>>>>>// Browsing for directory.
67945>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
67945>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
67945>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
67945>>>>>                                            // The callback function can set the status text by
67945>>>>>                                            // sending messages to the dialog box.
67945>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
67945>>>>>
67945>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
67945>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
67945>>>>>
67945>>>>>// message from browser
67945>>>>>//Define BFFM_INITIALIZED        1
67945>>>>>//Define BFFM_SELCHANGED         2
67945>>>>>
67945>>>>>// messages to browser
67945>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
67945>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
67945>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
67945>>>>>
67945>>>>>
67945>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
67946>>>>>
67946>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
67947>>>>>
67947>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
67948>>>>>
67948>>>>>
67948>>>>>
67948>>>>>
67948>>>>>Struct tvSecurity_attributes
67948>>>>>  DWord   nLength
67948>>>>>  Pointer lpDescriptor
67948>>>>>  Integer bInheritHandle
67948>>>>>End_Struct // tvSecurity_attributes
67948>>>>>
67948>>>>>//nLength:
67948>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
67948>>>>>// SECURITY_ATTRIBUTES structure.
67948>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
67948>>>>>// value of the nLength member. However, an application should still set it properly.
67948>>>>>// That ensures current, future, and cross-platform compatibility.
67948>>>>>//
67948>>>>>//lpSecurityDescriptor:
67948>>>>>// Points to a security descriptor for the object that controls the sharing of it.
67948>>>>>// If NULL is specified for this member, the object may be assigned the default security
67948>>>>>// descriptor of the calling process.
67948>>>>>//
67948>>>>>//bInheritHandle:
67948>>>>>// Specifies whether the returned handle is inherited when a new process is created.
67948>>>>>// If this member is TRUE, the new process inherits the handle.
67948>>>>>
67948>>>>>
67948>>>>>// BOOL CreateDirectory(
67948>>>>>//    LPCTSTR lpPathName,
67948>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
67948>>>>>//   );
67948>>>>>//
67948>>>>>// lpPathName
67948>>>>>//  Points to a null-terminated string that specifies the path of the directory
67948>>>>>//  to be created.
67948>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
67948>>>>>//  This limit is related to how the CreateDirectory function parses paths.
67948>>>>>// lpSecurityAttributes
67948>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
67948>>>>>//  determines whether the returned handle can be inherited by child processes.
67948>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
67948>>>>>// Returns:
67948>>>>>//  If the function succeeds, the return value is nonzero.
67948>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
67948>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
67949>>>>>
67949>>>>>
67949>>>>>// lpPathName
67949>>>>>//  Points to a null-terminated string that specifies the path of the directory
67949>>>>>//  to be removed.
67949>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
67949>>>>>// Returns:
67949>>>>>//  If the function succeeds, the return value is nonzero.
67949>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
67949>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
67950>>>>>
67950>>>>>
67950>>>>>
67950>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
67950>>>>>// executable file or a document file.
67950>>>>>//
67950>>>>>// Operation can be one of the following:
67950>>>>>//    "OPEN"  The function opens the file specified by lpFile.
67950>>>>>//            The file can be an executable file or a document file.
67950>>>>>//            The file can be a folder to open.
67950>>>>>//    "PRINT" The function prints the file specified by lpFile.
67950>>>>>//            The file should be a document file. If the file is an executable file,
67950>>>>>//            the function opens the file, as if "open" had been specified.
67950>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
67950>>>>>//
67950>>>>>// Return Values:
67950>>>>>//
67950>>>>>// If the function succeeds, the return value is the instance handle of the application that
67950>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
67950>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
67950>>>>>//
67950>>>>>// The following table lists these error values:
67950>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
67950>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
67950>>>>>// Public Const ERROR_BAD_FORMAT = 11&
67950>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
67950>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
67950>>>>>// Public Const SE_ERR_DDEBUSY = 30
67950>>>>>// Public Const SE_ERR_DDEFAIL = 29
67950>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
67950>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
67950>>>>>// Public Const SE_ERR_FNF = 2
67950>>>>>// Public Const SE_ERR_NOASSOC = 31
67950>>>>>// Public Const SE_ERR_OOM = 8
67950>>>>>// Public Const SE_ERR_PNF = 3
67950>>>>>// Public Const SE_ERR_SHARE = 26
67950>>>>>
67950>>>>>
67950>>>>>
67950>>>>>// Code to open the program that is associated with the selected file.
67950>>>>>//
67950>>>>>// External function call used in Procedure DoStartDocument
67950>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
67951>>>>>
67951>>>>>
67951>>>>>
67951>>>>>
67951>>>>>Define vFO_MOVE                For |CI$0001
67951>>>>>Define vFO_COPY                For |CI$0002
67951>>>>>Define vFO_DELETE              For |CI$0003
67951>>>>>Define vFO_RENAME              For |CI$0004
67951>>>>>
67951>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
67951>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
67951>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
67951>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
67951>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
67951>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
67951>>>>>                                          // Must be freed using SHFreeNameMappings
67951>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
67951>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
67951>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
67951>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
67951>>>>>
67951>>>>>Struct tvShFileOpStruct
67951>>>>>  Handle  hWnd
67951>>>>>  Integer wFunc
67951>>>>>  Pointer pFrom
67951>>>>>  Pointer pTo
67951>>>>>  Short   fFlags
67951>>>>>  Short   fAnyOperationsAborted
67951>>>>>  Pointer hNameMappings
67951>>>>>  Pointer lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
67951>>>>>End_Struct // tvShFileOpStruct
67951>>>>>
67951>>>>>// hwnd
67951>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
67951>>>>>
67951>>>>>// wFunc
67951>>>>>//   Operation to perform. This member can be one of the following values:
67951>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
67951>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
67951>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
67951>>>>>//     FO_RENAME   Renames the files specified by pFrom.
67951>>>>>
67951>>>>>// pFrom
67951>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
67951>>>>>//   be null-separated. The list of names must be double null-terminated.
67951>>>>>
67951>>>>>// pTo
67951>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
67951>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
67951>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
67951>>>>>//   double null-terminated.
67951>>>>>
67951>>>>>// fAnyOperationsAborted
67951>>>>>//   Value that receives TRUE if the user aborted any file operations before they
67951>>>>>//   were completed or FALSE otherwise.
67951>>>>>
67951>>>>>
67951>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
67951>>>>>// This can be a file or a folder.
67951>>>>>// With thanks to Andrew S Kaplan
67951>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
67952>>>>>
67952>>>>>
67952>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
67952>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
67953>>>>>
67953>>>>>
67953>>>>>
67953>>>>>// Courtesy Of Vincent Oorsprong
67953>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
67953>>>>>//   Pointer lpPathName ;
67953>>>>>//   Pointer lpPrefixString ;
67953>>>>>//   Integer uUnique ;
67953>>>>>//   Pointer lpTempFileName ;
67953>>>>>//   Returns Integer
67953>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
67953>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
67954>>>>>
67954>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
67955>>>>>
67955>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
67956>>>>>
67956>>>>>// from:
67956>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
67956>>>>>//
67956>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
67956>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
67956>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
67956>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
67956>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
67956>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
67956>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
67956>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
67956>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
67956>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
67956>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
67956>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
67956>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
67956>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
67956>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
67956>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
67956>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
67956>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
67956>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
67956>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
67956>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
67956>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
67956>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
67956>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
67956>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
67956>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
67956>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
67956>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
67956>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
67956>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
67956>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
67956>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
67956>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
67956>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
67956>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
67956>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
67956>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
67956>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
67956>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
67956>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
67956>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
67956>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
67956>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
67956>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
67956>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
67956>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
67956>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
67956>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
67956>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
67956>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
67956>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
67956>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
67956>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
67956>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
67956>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
67956>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
67956>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
67956>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
67956>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
67956>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
67956>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
67956>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
67956>>>>>
67956>>>>>
67956>>>>>//HRESULT SHGetFolderPath(
67956>>>>>//    HWND hwndOwner,
67956>>>>>//    int nFolder,
67956>>>>>//    HANDLE hToken,
67956>>>>>//    DWORD dwFlags,
67956>>>>>//    LPTSTR pszPath
67956>>>>>//);
67956>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
67956>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
67956>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
67956>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
67956>>>>>// If that fails, it will try to simulate the appropriate behavior.
67956>>>>>//
67956>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
67957>>>>>
67957>>>>>
67957>>>>>
67957>>>>>Struct tvWin32FindData
67957>>>>> Dword            dwFileAttributes
67957>>>>> Dword            ftCreationLowDateTime
67957>>>>> Dword            ftCreationHighDateTime
67957>>>>> dword            ftLastAccessLowDateTime
67957>>>>> Dword            ftLastAccessHighDateTime
67957>>>>> Dword            ftLastWriteLowDateTime
67957>>>>> Dword            ftLastWriteHighDateTime
67957>>>>> Dword            nFileSizeHigh
67957>>>>> Dword            nFileSizeLow
67957>>>>> Dword            dwReserved0
67957>>>>> Dword            dwReserved1
67957>>>>> UChar[vMax_Path] cFileName
67957>>>>> UChar[14]        cAlternateFileName
67957>>>>>End_Struct
67957>>>>>
67957>>>>>// Courtesy Of Vincent Oorsprong
67957>>>>>// lpFileName      : address of name of file to search for
67957>>>>>// lpFindFileData  : address of returned information
67957>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
67958>>>>>
67958>>>>>// Courtesy Of Vincent Oorsprong
67958>>>>>// hFindFile       : handle of search
67958>>>>>// lpFindFileData  : address of structure for data on found file
67958>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
67959>>>>>
67959>>>>>//
67959>>>>>// Unicode equivalents
67959>>>>>//
67959>>>>>// lpFileName      : address of name of file to search for
67959>>>>>// lpFindFileData  : address of returned information
67959>>>>>External_function vWin32W_FindFirstFile "FindFirstFileW"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
67960>>>>>
67960>>>>>// hFindFile       : handle of search
67960>>>>>// lpFindFileData  : address of structure for data on found file
67960>>>>>External_function vWin32W_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
67961>>>>>
67961>>>>>
67961>>>>>// Courtesy Of Vincent Oorsprong
67961>>>>>//  hFindFile      : file search handle
67961>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
67962>>>>>
67962>>>>>
67962>>>>>
67962>>>>>Struct tvFileTime
67962>>>>>  DWord dwLowDateTime
67962>>>>>  DWord dwHighDateTime
67962>>>>>End_Struct
67962>>>>>
67962>>>>>
67962>>>>>Struct tvSystemTime
67962>>>>>  UShort wYear
67962>>>>>  UShort wMonth
67962>>>>>  UShort wDayOfWeek
67962>>>>>  UShort wDay
67962>>>>>  UShort wHour
67962>>>>>  UShort wMinute
67962>>>>>  UShort wSecond
67962>>>>>  UShort wMilliSeconds
67962>>>>>End_Struct
67962>>>>>
67962>>>>>
67962>>>>>// Courtesy Of Vincent Oorsprong
67962>>>>>//  lpFileTime     : pointer to file time to convert
67962>>>>>//  lpSystemTime   : pointer to structure to receive system time
67962>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
67963>>>>>
67963>>>>>// Courtesy Of Vincent Oorsprong
67963>>>>>// This function formats the time in a picture-string passed
67963>>>>>//
67963>>>>>// Picture      Meaning
67963>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
67963>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
67963>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
67963>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
67963>>>>>//    m         Minutes with no leading zero for single-digit minutes
67963>>>>>//    mm        Minutes with leading zero for single-digit minutes
67963>>>>>//    s         Seconds with no leading zero for single-digit seconds
67963>>>>>//    ss        Seconds with leading zero for single-digit seconds
67963>>>>>//    t         One character time marker string, such as A or P
67963>>>>>//    tt        Multicharacter time marker string, such as AM or PM
67963>>>>>//
67963>>>>>// For example, to get the time string  "11:29:40 PM"
67963>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
67963>>>>>
67963>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
67964>>>>>
67964>>>>>
67964>>>>>// Courtesy Of Vincent Oorsprong
67964>>>>>// This function formats the date in a picture-string passed
67964>>>>>//
67964>>>>>// Picture      Meaning
67964>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
67964>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
67964>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
67964>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
67964>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
67964>>>>>//              value associated with the specified locale.
67964>>>>>//    M         Month as digits with no leading zero for single-digit months.
67964>>>>>//    MM        Month as digits with leading zero for single-digit months.
67964>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
67964>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
67964>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
67964>>>>>//              associated with the specified locale.
67964>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
67964>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
67964>>>>>//    yyyy      Year represented hy full four digits.
67964>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
67964>>>>>//              with the specified locale. This element is ignored if the date to be formatted
67964>>>>>//              does not have an associated era or period string.
67964>>>>>// For example, to get the date string  "Wed, Aug 31 94"
67964>>>>>// use the following picture string:    "ddd","MMM dd yy"
67964>>>>>
67964>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
67965>>>>>
67965>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
67965>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
67965>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
67965>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
67965>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
67965>>>>>
67965>>>>>//  Date Flags for GetDateFormatW.
67965>>>>>//
67965>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
67965>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
67965>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
67965>>>>>
67965>>>>>
67965>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
67966>>>>>
67966>>>>>
67966>>>>>// **WvA: 20-02-2004
67966>>>>>// While i was testing the format capabilities i stumbled over a very
67966>>>>>// weird problem where it looks like that the integer value gets somehow translated
67966>>>>>// incorrectly into an unsigned integer.
67966>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
67966>>>>>// It does smell a bit fishy though
67966>>>>>// Tested it with the same results on both VDF7 and VDF9.1
67966>>>>>
67966>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
67966>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
67966>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
67966>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
67966>>>>>
67966>>>>>// Possible errors that can be returned by the shellformat function
67966>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
67966>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
67966>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
67966>>>>>
67966>>>>>
67966>>>>> // Courtesy Of Steve Walter,
67966>>>>> // USA Software, Inc
67966>>>>> // Format a disk
67966>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
67966>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
67967>>>>>
67967>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
67967>>>>>
67967>>>>>// SHCreateDirectoryEx
67967>>>>>
67967>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
67967>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
67967>>>>>//
67967>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
67967>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
67967>>>>>//    the files are visible. If they are not visible, expect one of the following:
67967>>>>>//
67967>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
67967>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
67967>>>>>//        ERROR_CANCELLED.
67967>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
67967>>>>>
67967>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
67967>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
67967>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
67967>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
67967>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
67967>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
67967>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
67967>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
67967>>>>>
67967>>>>>//        int SHCreateDirectoryEx(
67967>>>>>//            HWND hwnd,
67967>>>>>//            LPCTSTR pszPath,
67967>>>>>//            const SECURITY_ATTRIBUTES *psa
67967>>>>>//        );
67967>>>>>
67967>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
67968>>>>>
67968>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryA" SHLWAPI.DLL Pointer lpszPath Returns Integer
67969>>>
67969>>>
67969>>>//
67969>>>// Gets the string from the right of the last sStopChar in sFrom
67969>>>// If sStopChar has no occurences in the string an empty string is
67969>>>// returned.
67969>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
67971>>>    String  sRetVal
67971>>>    String  sChar
67971>>>    Integer iLength
67971>>>    Integer iPos
67971>>>    Boolean bStopChar
67971>>>    Move "" to sRetval
67972>>>    Move (Length(sFrom)) to iLength
67973>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
67975>>>        Move iLength   to iPos
67976>>>        Move (False)   to bStopChar
67977>>>        While Not bStopChar
67981>>>            Move (Mid(sFrom,1,iPos)) to sChar
67982>>>            Decrement iPos
67983>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
67985>>>                Move (True) to bStopChar
67986>>>            End
67986>>>>
67986>>>            Else Begin
67987>>>                Move (sChar+sRetVal) to sRetVal
67988>>>            End
67988>>>>
67988>>>        Loop
67989>>>>
67989>>>    End
67989>>>>
67989>>>    Function_Return sRetVal
67990>>>End_Function
67991>>>
67991>>>// Pre:  sFileName contains the complete path of the file.
67991>>>// Post: returns the complete path of the file.
67991>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
67991>>>Function ParseFolderName Global String sFileName Returns String
67993>>>    String sFile
67993>>>    String sFolderName
67993>>>    String sDirSep // this is "\" for windows, or "/" for unix
67993>>>
67993>>>    Move "" to sFolderName
67994>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
67995>>>    If sDirSep In sFileName Begin
67997>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
67998>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
67999>>>    End
67999>>>>
67999>>>    Else If ":" In sFileName Begin
68002>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
68003>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
68004>>>    End
68004>>>>
68004>>>    Function_Return sFolderName
68005>>>End_Function
68006>>>
68006>>>// Pre:  sFileName contains the complete path of the file.
68006>>>// post: The returned filename has it's path removed, but will have a extension
68006>>>Function ParseFileName Global String sFileName Returns String
68008>>>    String sFolderName
68008>>>    String sDirSep // this is "\" for windows, or "/" for unix
68008>>>
68008>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
68009>>>    Get ParseFolderName sFileName to sFolderName
68010>>>    If (sFolderName <> "") Begin
68012>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
68013>>>    End
68013>>>>
68013>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
68014>>>    Function_Return sFilename
68015>>>End_Function
68016>>>
68016>>>// Pre:  sFileName may contain the complete path of the file.
68016>>>//       or contain multiple dots in the filename, so temp.gif.bak will
68016>>>//       return "bak" as the extension and not "gif"
68016>>>// Post: returns the extension only, this extension can be a valid unixlike extension
68016>>>//       such as "html" or "java"
68016>>>Function ParseFileExtension Global String sFileName Returns String
68018>>>    String  sFileExtension
68018>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
68019>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
68020>>>    Function_Return sFileExtension
68021>>>End_Function
68022>>>
68022>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
68022>>>
68022>>>Function DDE_Error_To_String Integer iErrorID Returns String
68024>>>    String sMessage
68024>>>    Case Begin
68024>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
68026>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
68027>>>            Case Break
68028>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
68031>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
68032>>>            Case Break
68033>>>        Case (iErrorID = vERROR_BAD_FORMAT)
68036>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
68037>>>            Case Break
68038>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
68041>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
68042>>>            Case Break
68043>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
68046>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
68047>>>            Case Break
68048>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
68051>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
68052>>>            Case Break
68053>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
68056>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
68057>>>            Case Break
68058>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
68061>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
68062>>>            Case Break
68063>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
68066>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
68067>>>            Case Break
68068>>>        Case (iErrorID = vSE_ERR_NOASSOC)
68071>>>            Move CS_DDE_ERR_NOASSOC to sMessage
68072>>>            Case Break
68073>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
68076>>>            Move CS_DDE_ERR_OOM to sMessage
68077>>>            Case Break
68078>>>        Case (iErrorID = vSE_ERR_PNF)
68081>>>            Move CS_DDE_ERR_PNF to sMessage
68082>>>            Case Break
68083>>>        Case (iErrorID = vSE_ERR_SHARE)
68086>>>            Move CS_DDE_ERR_SHARE to sMessage
68087>>>            Case Break
68088>>>        Case Else
68088>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
68089>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
68090>>>            Case Break
68091>>>    Case End
68091>>>    Function_Return sMessage
68092>>>End_Function
68093>>>
68093>>>Procedure vDDE_Error_Handler Integer iErrorID
68095>>>    String sMessage
68095>>>    Get DDE_Error_To_String iErrorID to sMessage
68096>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
68097>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
68098>>>End_Procedure
68099>>>
68099>>>// Does the directory exist? - No = false, Yes = True
68099>>>// This also works with UNC path encoding and wildcards
68099>>>Function vFolderExists Global String sFolderName Returns Boolean
68101>>>    Boolean bFolderExists
68101>>>    Boolean bStop
68101>>>    String  sFolder sTmp
68101>>>    Integer iCh
68101>>>
68101>>>    // 2013-09-29 NGS Check for empty folder name and convert to ANSI
68101>>>    Move (ToAnsi(Trim(sFolderName))) to sFolderName
68102>>>    If (sFolderName = "") Begin
68104>>>        Function_Return False
68105>>>    End
68105>>>>
68105>>>
68105>>>    Move True  to bFolderExists
68106>>>    Move False to bStop
68107>>>    Move "dir:" to sFolder
68108>>>    Append sFolder sFolderName
68109>>>    Get Seq_New_Channel to iCh  // get free channel for input
68110>>>    Direct_Input channel iCh sFolder
68112>>>    Repeat
68112>>>>
68112>>>        Readln channel iCh sTmp
68114>>>        Move (SeqEof) to bStop
68115>>>        If (Trim(sTmp)="") Begin
68117>>>            Move False to bFolderExists
68118>>>        End
68118>>>>
68118>>>        Else Begin
68119>>>            Move True to bFolderExists
68120>>>            Move True to bStop
68121>>>        End
68121>>>>
68121>>>    Until (bStop)
68123>>>    Close_Input channel iCh
68125>>>    Send Seq_Release_Channel iCh
68126>>>    Function_Return bFolderExists
68127>>>End_Function
68128>>>
68128>>>// returns folder name if a folder was selected, otherwise returns ""
68128>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
68130>>>    String sFolder sTitle sPath
68130>>>    Pointer lpItemIdList
68130>>>    Integer iFolderSelected iRetval
68130>>>    tvBrowseInfo BrowseInfo
68130>>>    tvBrowseInfo BrowseInfo
68130>>>
68130>>>    Move "" to sPath
68131>>>    If (sDialogTitle<>"") Begin
68133>>>        Move sDialogTitle to sTitle
68134>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
68134>>>        // disables showing some commonly used ascii characters like ascii 137 ()
68134>>>        // These chars are correctly shown if no toansi is used.
68134>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
68134>>>        // selected it will always be valid.
68134>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
68135>>>    End
68135>>>>
68135>>>
68135>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
68136>>>
68136>>>    // Torben Lund added line below. Move handle of focus object to structure before
68136>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
68136>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
68137>>>
68137>>>    // null 128 chars into var (make space)
68137>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
68138>>>
68138>>>    // select folder
68138>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
68139>>>    // get selected folder name
68139>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
68140>>>
68140>>>    // release memory resources that are used by the ItemIdList
68140>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
68141>>>
68141>>>    If (iFolderSelected<>0) Begin
68143>>>        Move (CString(sFolder)) to sPath
68144>>>    End
68144>>>>
68144>>>    Function_Return  sPath
68145>>>End_Function
68146>>>
68146>>>// returns 0 if the folder is created.
68146>>>//         1 if the API-call returned an error.
68146>>>Function vCreateDirectory Global String sNewFolder Returns Integer
68148>>>    String  sFolder
68148>>>    Integer iRetval bFolderCreated
68148>>>    tvSecurity_attributes SA
68148>>>    tvSecurity_attributes SA
68148>>>
68148>>>    Move False to bFolderCreated
68149>>>
68149>>>    // null MAX_PATH chars into var (make space)
68149>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
68150>>>
68150>>>    If (sNewFolder <> "") Begin
68152>>>
68152>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
68153>>>        Move  0  to SA.lpDescriptor
68154>>>        Move  1  to SA.bInheritHandle
68155>>>
68155>>>        //
68155>>>        Move (sNewFolder+"") to sFolder
68156>>>        Move (vWin32_CreateDirectory(AddressOf(sFolder), AddressOf(SA))) to bFolderCreated
68157>>>    End
68157>>>>
68157>>>
68157>>>    If (bFolderCreated=false) Begin
68159>>>        Move 1 to iRetVal
68160>>>    End
68160>>>>
68160>>>    Function_Return iRetVal
68161>>>End_Function
68162>>>
68162>>>// **WvA: 03-02-2002 Function created.
68162>>>// With this function one can remove a directory.
68162>>>// returns 0 if the folder is removed.
68162>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
68162>>>//         2 if the folder did not exist
68162>>>//         3 if the sFolder parameter passed is equal to ""
68162>>>Function vRemoveDirectory Global String sFolder Returns Integer
68164>>>    Boolean bRemoved
68164>>>    String  sPath
68164>>>    Integer iRetval
68164>>>
68164>>>    Move 0     to iRetVal
68165>>>    Move False to bRemoved
68166>>>    Move (Trim(sFolder)) to sFolder
68167>>>    If (sFolder="") Begin
68169>>>        Move 3 to iRetVal
68170>>>    End
68170>>>>
68170>>>    If (vFolderExists(sFolder)=False) Begin
68172>>>        Move 2 to iRetVal
68173>>>    End
68173>>>>
68173>>>    If (iRetVal=0) Begin
68175>>>    // null MAX_PATH chars into var (make space)
68175>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
68176>>>        //
68176>>>        Move (Insert(sFolder,sPath,1)) to sPath
68177>>>        Move (vWin32_RemoveDirectory(AddressOf(sPath))) to bRemoved
68178>>>    End
68178>>>>
68178>>>
68178>>>    If (iRetVal=0 And bRemoved=False) Begin
68180>>>        Move 1 to iRetVal
68181>>>    End
68181>>>>
68181>>>    Function_Return iRetVal
68182>>>End_Function
68183>>>
68183>>>// This function informs the user that he entered a yet unknown folder and
68183>>>// asks if he/she wants to create the folder (Yes/No)
68183>>>// Choice: "Yes" - this creates the folder
68183>>>//                 if successful, the function returns false
68183>>>//                 else it will be true.
68183>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
68183>>>//                 For example: to stop a save
68183>>>// Precondition: A foldername must be entered. We do not check for empty paths
68183>>>// This function returns a non-zero value if the folder isn't created afterwards
68183>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
68185>>>    Integer bIsNotValid
68185>>>    Integer iUsers_Choice
68185>>>    String  sMessage
68185>>>
68185>>>    If (vFolderExists(sFolderName) Eq 0) Begin
68187>>>        Move "The folder '" to sMessage
68188>>>        Append sMessage sFolderName
68189>>>        Append sMessage "' does not yet exist,\n"
68190>>>        Append sMessage "Do you want to create it now?"
68191>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
68192>>>        Case Begin
68192>>>            Case (iUsers_Choice = MBR_Yes)
68194>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
68195>>>                If bIsNotValid Begin
68197>>>                    Move "An error occurred while trying to create folder '" to sMessage
68198>>>                    Append sMessage sFolderName "'.\n\n"
68200>>>                    Send Info_Box sMessage "Info"
68201>>>                End
68201>>>>
68201>>>                Case Break
68202>>>            Case (iUsers_Choice = MBR_No)
68205>>>                Move dfTrue to bIsNotValid // Cancel the save
68206>>>                Case Break
68207>>>        Case End
68207>>>    End
68207>>>>
68207>>>    Function_Return bIsNotValid
68208>>>End_Function
68209>>>
68209>>>// This will perform an operation on a file (e.g. open) with the application
68209>>>// registered in the Windows Registry to open that type of file (via its extension)
68209>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
68209>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
68211>>>    Handle  hInstance hWnd
68211>>>    // remove any leading/trailing spaces in the string
68211>>>    Move (Trim(sDocument)) to sDocument
68212>>>    Move (Trim(sPath))     to sPath
68213>>>    // Make the strings readable for windows API, by converting them to null-terminated
68213>>>    Append sOperation   (Character(0))
68214>>>    Append sDocument    (Character(0))
68215>>>    Append sParameters  (Character(0))
68216>>>    Append sPath        (Character(0))
68217>>>
68217>>>    Get Window_Handle to hWnd
68218>>>    Move (vWin32_ShellExecute (hWnd, AddressOf(sOperation), AddressOf(sDocument), AddressOf(sParameters), AddressOf(sPath), 1)) to hInstance
68219>>>    If (hInstance <= 32) Begin
68221>>>        Send vDDE_Error_Handler hInstance
68222>>>    End
68222>>>>
68222>>>End_Procedure
68223>>>
68223>>>Class cShellFileOperations is a Array
68224>>>
68224>>>    Procedure Construct_Object
68226>>>        Forward Send Construct_Object
68228>>>        Property Integer piDeleteFlags        0
68229>>>        Property Integer piCopyFlags          0
68230>>>        Property Integer piMoveFlags          0
68231>>>        Property Integer piRenameFlags        0
68232>>>
68232>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
68233>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
68234>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
68235>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
68236>>>    End_Procedure
68237>>>
68237>>>    // This function uses the shell API to perform a file operation on the
68237>>>    // files supplied.
68237>>>    //
68237>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
68239>>>        Integer  iRetVal
68239>>>        Integer  iUserAbort
68239>>>        tvShFileOpStruct FOS
68239>>>        tvShFileOpStruct FOS
68239>>>
68239>>>        Move (ToAnsi(sSource)+Character(0)+Character(0))      to sSource
68240>>>        Move (ToAnsi(sDestination)+Character(0)+Character(0)) to sDestination
68241>>>        If (eOperation <> vFO_DELETE) Begin
68243>>>            Move (AddressOf(sDestination)) to FOS.pTo
68244>>>        End
68244>>>>
68244>>>
68244>>>        Move eOperation           to FOS.wFunc
68245>>>        Move (AddressOf(sSource)) to FOS.pFrom
68246>>>        Move iFlags               to FOS.fFlags
68247>>>
68247>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
68248>>>        Move FOS.fAnyOperationsAborted to iUserAbort
68249>>>        If (iUserAbort <> 0) Begin
68251>>>            Move 80 to iRetVal  // file Operation Aborted by USER
68252>>>        End
68252>>>>
68252>>>        Function_Return (iRetVal)
68253>>>    End_Function
68254>>>
68254>>>    Function sfoDeleteFile String sFileName Returns Integer
68256>>>        Integer  iRetVal
68256>>>        Integer  iFlags
68256>>>
68256>>>        Get piDeleteFlags to iFlags
68257>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
68258>>>        Function_Return iRetVal
68259>>>    End_Function
68260>>>
68260>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
68262>>>        Integer  iRetVal
68262>>>        Integer  iFlags
68262>>>
68262>>>        Get piCopyFlags to iFlags
68263>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
68264>>>        Function_Return iRetVal
68265>>>    End_Function
68266>>>
68266>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
68268>>>        Integer  iRetVal
68268>>>        Integer  iFlags
68268>>>
68268>>>        Get piMoveFlags to iFlags
68269>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
68270>>>        Function_Return iRetVal
68271>>>    End_Function
68272>>>
68272>>>    // Rename a file or folder
68272>>>    // Returns a nonzero value if the operation failed.
68272>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
68274>>>        Integer  iRetVal
68274>>>        Integer  iFlags
68274>>>
68274>>>        Get piRenameFlags to iFlags
68275>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
68276>>>        Function_Return iRetVal
68277>>>    End_Function
68278>>>
68278>>>    // Courtesy Of Steve Walter
68278>>>    // Requires Windows 2000 and up according to msdn but it was
68278>>>    //  in fact available before that as an unpublished API call
68278>>>    //  a little google search shows that this was already available
68278>>>    //  in windows 95 and NT
68278>>>    //
68278>>>    // The format is controlled by the dialog interface.
68278>>>    // That is, the user must click the OK button To actually Begin the format
68278>>>    // the format cannot be started programmatically.
68278>>>    // An alternative to this functionality would be to use a controlpanel
68278>>>    //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
68278>>>    //
68278>>>    // hWnd = The windows handle of the object from which the format Function
68278>>>    //        is called.
68278>>>    // To Get this,
68278>>>    //          use:  Get Window_Handle Of <object>
68278>>>    //          For instance, in this app, we're going to use the Report_Panel:
68278>>>    //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
68278>>>    //
68278>>>    // sDrive = The drive letter. At this moment only A and B are valid
68278>>>    //
68278>>>    // iOptions = Format options.
68278>>>    //  SHFMT_OPT_DEFAULT = Quick format
68278>>>    //  SHFMT_OPT_FULL    = Full Format
68278>>>    //  SHFMT_OPT_SYSONLY = System only
68278>>>    //  3                 = Full format with system. (unsupported)
68278>>>    //
68278>>>    // Return Values:
68278>>>    //  SHFMT_ERROR    = Error on format or no drive specified.
68278>>>    //  SHFMT_CANCEL   = Format cancelled by user.
68278>>>    //  SHFMT_NOFORMAT = Drive is not formatable.
68278>>>    //
68278>>>    //
68278>>>    // *** ATTENTION: This function has been disabled as it doesn't
68278>>>    //                seem to work, i must have made a silly mistake
68278>>>    //                somewhere.
68278>>>    //
68278>>>    Function sfoFormatDisk String sDrive Integer iOptions Returns DWord
68280>>>        Handle   hWnd
68280>>>        Integer  iObj
68280>>>        DWord    dwReturnVal
68280>>>        Integer iDrive
68280>>>
68280>>>        Function_Return 1 // STOP HERE
68281>>>
68281>>>        Move (Trim(sDrive)) to sDrive
68282>>>        If ( sDrive <> '' ) Begin
68284>>>            If ( sDrive Contains ':' ) Begin
68286>>>                Move (Replace(':',sDrive,'')) to sDrive
68287>>>            End
68287>>>>
68287>>>            If (Not( 'AB' Contains sDrive )) Begin
68289>>>                Function_Return (SHFMT_NOFORMAT)
68290>>>            End
68290>>>>
68290>>>            If ( sDrive = 'A' ) Begin
68292>>>                Move 0 to iDrive
68293>>>            End
68293>>>>
68293>>>            Else If ( sDrive = 'B' ) Begin
68296>>>                Move 1 to iDrive
68297>>>            End
68297>>>>
68297>>>            // Window_Handle Of Desktop equals to 0
68297>>>
68297>>>            Get focus of desktop to iObj
68298>>>            If (iObj>desktop) Begin
68300>>>                Get Container_Handle of iObj to hWnd
68301>>>            End
68301>>>>
68301>>>            While (hWnd=0 And iObj<>Desktop)
68305>>>                Get Parent of iObj to iObj
68306>>>                Get Container_Handle of iObj to hWnd
68307>>>            Loop
68308>>>>
68308>>>
68308>>>            //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
68308>>>            Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) to dwReturnVal
68309>>>        End
68309>>>>
68309>>>        Else Begin
68310>>>            Move (SHFMT_ERROR) to dwReturnVal
68311>>>        End
68311>>>>
68311>>>        Function_Return dwReturnVal
68312>>>    End_Function
68313>>>
68313>>>    //Example:
68313>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
68313>>>    //                                          mode.
68313>>>
68313>>>End_Class
68314>>>
68314>>>Object oShellFileOperations is a cShellFileOperations
68316>>>End_Object
68317>>>
68317>>>// Restore to the old way of working with the shell file operations.
68317>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
68317>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
68317>>>Procedure vWin32fhCompatibilityMode
68319>>>    Integer hoSFO
68319>>>    Integer iFlags
68319>>>
68319>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
68320>>>    Move (oShellFileOperations(Self)) to hoSFO
68321>>>
68321>>>    Set piDeleteFlags of hoSFO to iFlags
68322>>>    Set piCopyFlags   of hoSFO to iFlags
68323>>>    Set piMoveFlags   of hoSFO to iFlags
68324>>>    Set piRenameFlags of hoSFO to iFlags
68325>>>End_Procedure
68326>>>
68326>>>// Delete a file or folder
68326>>>// Returns a nonzero value if the operation failed.
68326>>>Function vDeleteFile Global String sFileName Returns Integer
68328>>>    Integer  iRetVal
68328>>>
68328>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
68329>>>    Function_Return iRetVal
68330>>>End_Function
68331>>>
68331>>>// Copy a file or folder
68331>>>// Returns a nonzero value if the operation failed.
68331>>>Function vCopyFile Global String sSource String sDestination Returns Integer
68333>>>    Integer  iRetVal
68333>>>
68333>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
68334>>>    Function_Return iRetVal
68335>>>End_Function
68336>>>
68336>>>// Move a file or folder
68336>>>// Returns a nonzero value if the operation failed.
68336>>>Function vMoveFile Global String sSource String sDestination Returns Integer
68338>>>    Integer  iRetVal
68338>>>
68338>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
68339>>>    Function_Return iRetVal
68340>>>End_Function
68341>>>
68341>>>// Rename a file or folder
68341>>>// Returns a nonzero value if the operation failed.
68341>>>Function vRenameFile Global String sSource String sDestination Returns Integer
68343>>>    Integer  iRetVal
68343>>>
68343>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
68344>>>    Function_Return iRetVal
68345>>>End_Function
68346>>>
68346>>>Function vGetWindowsDirectory Returns String
68348>>>    String  sDirectory
68348>>>    Integer iVoid
68348>>>
68348>>>    Move (ZeroString(vMAX_PATH)) to sDirectory
68349>>>    Move (vWin32_GetWindowsDirectory(AddressOf(sDirectory), vMAX_PATH)) to iVoid
68350>>>    Function_Return (CString(sDirectory))
68351>>>End_Function
68352>>>
68352>>>Function vGetTempPath Returns String
68354>>>    Integer iRetval
68354>>>    String  sTempPath
68354>>>
68354>>>    Move (ZeroString(vMAX_PATH)) to sTempPath
68355>>>    Move (vWin32_GetTempPath (vMAX_PATH, AddressOf(sTempPath))) to iRetVal
68356>>>    Function_Return (Cstring(sTempPath))
68357>>>End_Function
68358>>>
68358>>>// Courtesy of Marco Kuipers
68358>>>Function vMakeTempFile Returns String
68360>>>    Integer iRetval
68360>>>    String  sTempPath
68360>>>    String  sTempFileName
68360>>>    String  sPrefixString
68360>>>
68360>>>    Get vGetTempPath to sTempPath
68361>>>    If (sTempPath = "") Begin
68363>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
68364>>>        If (sTempPath<>"") Begin
68366>>>            Move (sTempPath+"\Temp\") to sTempPath
68367>>>        End
68367>>>>
68367>>>    End
68367>>>>
68367>>>
68367>>>    If (sTempPath = "") Begin
68369>>>    // second fallback we really do not want to get here as to be fair using current folder as temp
68369>>>    // makes little sense. Leaving this in as it was old behavior.
68369>>>        Get_Current_Directory to sTempPath
68370>>>    End
68370>>>>
68370>>>
68370>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
68371>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
68373>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
68374>>>>
68374>>>    End
68374>>>>
68374>>>
68374>>>    Move (ZeroString(vMax_Path)) to sTempFileName
68375>>>    Move ("tmp"+Character(0)) to sPrefixString // **WvA: 28-04-2005 Added a null
68376>>>    Move (vWin32_GetTempFileName (AddressOf(sTempPath), AddressOf(sPrefixString), 0, AddressOf(sTempFileName))) to iRetval
68377>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
68379>>>    //Get ShowLastError to iRetval
68379>>>        Move "" to sTempFileName
68380>>>    End
68380>>>>
68380>>>
68380>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
68381>>>End_Function
68382>>>
68382>>>// This function creates a uniquely named temporary file in folder sPath
68382>>>// The file created will have a prefix based on the first 3 characters in sPrefix
68382>>>// Note that you will have to cleanup the tempfile yourself as the function
68382>>>// does not take care of that.
68382>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
68384>>>    Integer iRetVal
68384>>>    String sTempFileName
68384>>>
68384>>>    Move (ToAnsi(sPath)+Character(0))   to sPath
68385>>>    Move (ToAnsi(sPrefix)+Character(0)) to sPrefix
68386>>>    Move (Pad("", vMAX_PATH)) to sTempFileName
68387>>>
68387>>>    Move (vWin32_GetTempFileName(AddressOf(sPath), AddressOf(sPrefix), 0, AddressOf(sTempFileName))) to iRetVal
68388>>>    Move (Trim(Cstring(sTempFileName))) to sTempFileName
68389>>>    Function_Return sTempFileName
68390>>>End_Function
68391>>>
68391>>>//
68391>>>// Get a specific shell folder for example to get the desktop folder
68391>>>// simply call this function and pass it vCSIDL_DESKTOP
68391>>>//
68391>>>Function vSHGetFolderPath Integer eFolder Returns String
68393>>>    String  sFolder
68393>>>    Integer iVoid
68393>>>    Handle  hWnd
68393>>>
68393>>>    Move (Window_Handle(focus(desktop))) to hWnd
68394>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
68395>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(sFolder))) to iVoid
68396>>>    Function_Return (CString(sFolder))
68397>>>End_Function
68398>>>
68398>>>// Courtesy Of Vincent Oorsprong
68398>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
68400>>>    String  sFormattedTime sFormattedDate
68400>>>    String  sFileDateTime
68400>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
68400>>>    tvFileTime   FileTime
68400>>>    tvFileTime   FileTime
68400>>>    tvSystemTime SystemTime
68400>>>    tvSystemTime SystemTime
68400>>>
68400>>>    Move "" to sFileDateTime
68401>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
68402>>>    Move dwHighDateTime to FileTime.dwHighDateTime
68403>>>
68403>>>    Move 0 to SystemTime.wYear
68404>>>
68404>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
68405>>>    If (iSuccess = 1) Begin
68407>>>        Move (ZeroString(255))        to sFormattedTime
68408>>>        Move (Length(sFormattedTime)) to iLenCcTime
68409>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedTime), iLenCcTime)) to iDataLength
68410>>>        Move (ZeroString(255))        to sFormattedDate
68411>>>        Move (Length(sFormattedDate)) to iLenCcDate
68412>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedDate), iLenCcDate)) to iDataLength
68413>>>        Move (Cstring (sFormattedDate)  * Cstring (sFormattedTime)) to sFileDateTime
68414>>>    End
68414>>>>
68414>>>    Function_Return sFileDateTime
68415>>>End_Function
68416>>>
68416>>>// **WvA:
68416>>>// A windows replacement for the standard function FileExists.
68416>>>// This version will also return (true) for a file when it is open by an application.
68416>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
68416>>>// Example: Get vFilePathExists "C:\config.sy?"
68416>>>// This will return true if you have a file matching these conditions. (aka config.sys)
68416>>>Function vFilePathExists Global String sFilePathMask Returns Integer
68418>>>    String  sDirSep
68418>>>    Handle  hFindFile
68418>>>    Integer iVoid
68418>>>    tvWin32FindData FindData
68418>>>    tvWin32FindData FindData
68418>>>
68418>>>    Move vINVALID_HANDLE_VALUE to hFindFile
68419>>>    Move (ToAnsi(Trim(sFilePathMask))) to sFilePathMask
68420>>>    If (Length(sFilePathMask)>0) Begin
68422>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
68422>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
68423>>>        While (Right(sFilePathMask, 1) = sDirSep)
68427>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
68428>>>        Loop
68429>>>>
68429>>>
68429>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
68430>>>        Move (vWin32_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
68431>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
68432>>>    End
68432>>>>
68432>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
68433>>>End_Function
68434>>>
68434>>>//
68434>>>// WideChar version of the function, do not use, it's an experiment
68434>>>//
68434>>>Function vWFilePathExists Global String sFilePathMask Returns Integer
68436>>>    Handle  hFindFile
68436>>>    Integer iVoid
68436>>>    tvWin32FindData FindData
68436>>>    tvWin32FindData FindData
68436>>>
68436>>>    Move vINVALID_HANDLE_VALUE to hFindFile
68437>>>
68437>>>    If (Length(sFilePathMask)>0) Begin
68439>>>
68439>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
68440>>>        Move (vWin32W_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
68441>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
68442>>>    End
68442>>>>
68442>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
68443>>>End_Function
68444>>>
68444>>>// **WvA
68444>>>// Formats a foldername by first trimming it and after that by sticking a
68444>>>// directory separator (/\) to the end if it doesn't have one there already.
68444>>>// The folder may contain a drive letter or UNC encoding.
68444>>>Function vFolderFormat Global String sFolderName Returns String
68446>>>    String sDirSep
68446>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
68447>>>    Move (Trim(sFolderName)) to sFolderName
68448>>>    If (Right(sFolderName,1)<>sDirSep) Begin
68450>>>        Move (sFolderName+sDirSep) to sFolderName
68451>>>    End
68451>>>>
68451>>>    Function_Return sFolderName
68452>>>End_Function
68453>>>
68453>>>//
68453>>>// Returns the amount of files in the folder (if it exists)
68453>>>// Returns -1 if folder doesn't exist.
68453>>>// The files "." and ".." are not counted.
68453>>>//
68453>>>Function vFolderFileCount Global String sFolderName Returns Integer
68455>>>    Boolean bFound
68455>>>    Handle  hFindFile
68455>>>    Integer iCount  iVoid
68455>>>    Integer iSuccess
68455>>>    String  sFileName
68455>>>    tvWin32FindData FindData
68455>>>    tvWin32FindData FindData
68455>>>
68455>>>    Move -1 to iCount
68456>>>    Get vFolderFormat sFolderName to sFolderName
68457>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
68458>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
68459>>>    Move (vWin32_FindFirstFile (AddressOf(sFolderName), AddressOf(FindData))) to hFindFile
68460>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
68461>>>    If (bFound) Begin
68463>>>        Move 0 to iCount
68464>>>    End
68464>>>>
68464>>>    While (bFound)
68468>>>        Increment iCount
68469>>>        Move (UCharArrayToString(FindData.cFileName)) to sFileName
68470>>>        If (sFileName="." or sFileName="..") Begin
68472>>>            Decrement iCount
68473>>>        End
68473>>>>
68473>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
68474>>>        Move (iSuccess<>0) to bFound
68475>>>    Loop
68476>>>>
68476>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
68477>>>    Function_Return iCount
68478>>>End_Function
68479>>>
68479>>>//
68479>>>// Gets the parent path of the currently supplied path
68479>>>// Returns "" when we are at the root folder.
68479>>>//
68479>>>Function vParentPath Global String sPath Returns String
68481>>>    String sStrip sDirSep
68481>>>
68481>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
68482>>>    Move (Trim(sPath)) to sPath
68483>>>    If (Right(sPath,1) = sDirSep) Begin
68485>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
68486>>>    End
68486>>>>
68486>>>    If (Pos(sDirSep, sPath)) Begin
68488>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
68489>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
68490>>>    End
68490>>>>
68490>>>    Else Begin
68491>>>        Move "" to sPath
68492>>>    End
68492>>>>
68492>>>    Function_Return sPath
68493>>>End_Function
68494>>>
68494>>>// Create the folder, including intermediate directories.
68494>>>// Don't panic if the folder already exists.
68494>>>// Michael Mullan June 2009.
68494>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
68496>>>    String  sFolder
68496>>>    Integer iRetval iFolderCreated
68496>>>    tvSecurity_attributes SA
68496>>>    tvSecurity_attributes SA
68496>>>
68496>>>    Move 0 to iFolderCreated
68497>>>
68497>>>    // null MAX_PATH chars into var (make space)
68497>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
68498>>>    If (sNewFolder <> "") Begin
68500>>>
68500>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
68501>>>        Move  0  to SA.lpDescriptor
68502>>>        Move  1  to SA.bInheritHandle
68503>>>
68503>>>        //
68503>>>        Move (sNewFolder+"") to sFolder
68504>>>        Move (vWin32_SHCreateDirectoryEx(0,AddressOf(sFolder), AddressOf(SA))) to iFolderCreated
68505>>>    End
68505>>>>
68505>>>
68505>>>    If (iFolderCreated <> 0) Begin
68507>>>        Move 1 to iRetVal
68508>>>        Case Begin
68508>>>            Case (iFolderCreated = 161)
68510>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
68511>>>>
68511>>>                Case Break
68512>>>            Case (iFolderCreated = 206)
68515>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
68516>>>>
68516>>>                Case Break
68517>>>            Case (iFolderCreated = 3)
68520>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
68521>>>>
68521>>>                Case Break
68522>>>            Case (iFolderCreated = 80)
68525>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
68526>>>                Case Break
68527>>>            Case (iFolderCreated = 183)
68530>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
68531>>>                Case Break
68532>>>            Case (iFolderCreated = 1223)
68535>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
68536>>>>
68536>>>                Case Break
68537>>>            Case Else
68537>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
68538>>>>
68538>>>        Case End
68538>>>    End
68538>>>>
68538>>>    Function_Return iRetVal
68539>>>End_Function
68540>>>
68540>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
68542>>>    DWord   dwFileSizeHigh dwFileSizeLow
68542>>>    Integer iFileSize iVoid
68542>>>    Handle  hFindFile
68542>>>    tvWin32FindData FindData
68542>>>    tvWin32FindData FindData
68542>>>
68542>>>    Move (sFileName+"") to sFileName
68543>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
68544>>>    Move (vWin32_FindFirstFile (AddressOf(sFileName), AddressOf(FindData))) to hFindFile
68545>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
68547>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
68548>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
68549>>>    End
68549>>>>
68549>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
68550>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
68551>>>
68551>>>    Function_Return iFileSize
68552>>>End_Function
68553>>>
68553>>>//
68553>>>// Based on code in Peter Crook's Browse folder workspace
68553>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
68553>>>//
68553>>>//=============================================================================
68553>>>// Verifies that a path is a valid directory.
68553>>>//
68553>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
68553>>>//
68553>>>// Parameters:
68553>>>//      sPath - Address of the path to verify.
68553>>>//=============================================================================
68553>>>Function vPathIsDirectory Global String sPath Returns Boolean
68555>>>    Integer iResult
68555>>>    Boolean bRetVal
68555>>>
68555>>>    Move false to bRetVal
68556>>>    Move (ToAnsi(sPath) - Character (0)) to sPath
68557>>>    Move (vWin32_PathIsDirectory (AddressOf (sPath))) to iResult
68558>>>    If (iResult<>0) Begin
68560>>>        Move True to bRetVal
68561>>>    End
68561>>>>
68561>>>
68561>>>    Function_Return bRetVal
68562>>>End_Function
68563>>>
68563>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJSkinFramework.pkg)
68563>>>Use windows.pkg
68563>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJComSkinFramework.pkg)
68563>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v18.3.0\Bin\Codejock.SkinFramework.v18.3.0.ocx
68563>>>>>Use FlexCom20.pkg
68563>>>>>
68563>>>>>// Changes to Imported package
68563>>>>>//     OLEXTPxx to XTPxx
68563>>>>>//     OLExtpxx to xtpxx
68563>>>>>//     OLESkinFramework to SkinFramework
68563>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
68563>>>>>//     cCom classes to cCJ
68563>>>>>//     cCJAutomationObject back to cComAutomationObject
68563>>>>>//     cCJActiveXControl back to cComActiveXControl
68563>>>>>//     cCJSkinFramework to cCJComSkinFramework
68563>>>>>//     Use statements as noted below (classes moved to these files)
68563>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
68563>>>>>
68563>>>>>// These have been extracted from this class and moved into seperate packages
68563>>>>>// because other Codejock classes use these.
68563>>>>>Use cCJColorManager.pkg     // cCJColorManager
68563>>>>>
68563>>>>>Define SkinFrameworkApplyOptions for Integer
68563>>>>>    Define xtpSkinApplyMetrics for 1
68563>>>>>    Define xtpSkinApplyFrame for 2
68563>>>>>    Define xtpSkinApplyColors for 4
68563>>>>>    Define xtpSkinApplyMenus for 8
68563>>>>>
68563>>>>>// CLSID: {C0DE1830-28D7-4F2C-87A7-7266367B4655}
68563>>>>>// Dispatch interface for SkinFramework Control
68563>>>>>Class cCJ_DSkinFramework is a Mixin
68564>>>>>
68564>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
68566>>>>>        SkinFrameworkApplyOptions retVal
68566>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
68567>>>>>        Function_Return retVal
68568>>>>>    End_Function
68569>>>>>
68569>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
68571>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
68572>>>>>    End_Procedure
68573>>>>>
68573>>>>>    Function ComAutoApplyNewWindows Returns Boolean
68575>>>>>        Boolean retVal
68575>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
68576>>>>>        Function_Return retVal
68577>>>>>    End_Function
68578>>>>>
68578>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
68580>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
68581>>>>>    End_Procedure
68582>>>>>
68582>>>>>    Function ComAutoApplyNewThreads Returns Boolean
68584>>>>>        Boolean retVal
68584>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
68585>>>>>        Function_Return retVal
68586>>>>>    End_Function
68587>>>>>
68587>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
68589>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
68590>>>>>    End_Procedure
68591>>>>>
68591>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
68593>>>>>        Handle hDispatchDriver
68593>>>>>        Boolean retVal
68593>>>>>        Get phDispatchDriver to hDispatchDriver
68594>>>>>        Send PrepareParams to hDispatchDriver 2
68595>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
68596>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
68597>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
68598>>>>>        Function_Return retVal
68599>>>>>    End_Function
68600>>>>>
68600>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
68602>>>>>        Handle hDispatchDriver
68602>>>>>        Get phDispatchDriver to hDispatchDriver
68603>>>>>        Send PrepareParams to hDispatchDriver 1
68604>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
68605>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
68606>>>>>    End_Procedure
68607>>>>>
68607>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
68609>>>>>        Handle hDispatchDriver
68609>>>>>        Get phDispatchDriver to hDispatchDriver
68610>>>>>        Send PrepareParams to hDispatchDriver 2
68611>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
68612>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
68613>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
68614>>>>>    End_Procedure
68615>>>>>
68615>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
68617>>>>>        Handle hDispatchDriver
68617>>>>>        Get phDispatchDriver to hDispatchDriver
68618>>>>>        Send PrepareParams to hDispatchDriver 1
68619>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
68620>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
68621>>>>>    End_Procedure
68622>>>>>
68622>>>>>    Procedure ComRemoveAllWindows
68624>>>>>        Handle hDispatchDriver
68624>>>>>        Get phDispatchDriver to hDispatchDriver
68625>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
68626>>>>>    End_Procedure
68627>>>>>
68627>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
68629>>>>>        Handle hDispatchDriver
68629>>>>>        Get phDispatchDriver to hDispatchDriver
68630>>>>>        Send PrepareParams to hDispatchDriver 2
68631>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
68632>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
68633>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
68634>>>>>    End_Procedure
68635>>>>>
68635>>>>>    Procedure ComRemoveWindowClass String llClassName
68637>>>>>        Handle hDispatchDriver
68637>>>>>        Get phDispatchDriver to hDispatchDriver
68638>>>>>        Send PrepareParams to hDispatchDriver 1
68639>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
68640>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
68641>>>>>    End_Procedure
68642>>>>>
68642>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
68644>>>>>        Handle hDispatchDriver
68644>>>>>        Variant retVal
68644>>>>>        Get phDispatchDriver to hDispatchDriver
68645>>>>>        Send PrepareParams to hDispatchDriver 2
68646>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
68647>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
68648>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
68649>>>>>        Function_Return retVal
68650>>>>>    End_Function
68651>>>>>
68651>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
68653>>>>>        Handle hDispatchDriver
68653>>>>>        Variant retVal
68653>>>>>        Get phDispatchDriver to hDispatchDriver
68654>>>>>        Send PrepareParams to hDispatchDriver 1
68655>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
68656>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
68657>>>>>        Function_Return retVal
68658>>>>>    End_Function
68659>>>>>
68659>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
68661>>>>>        Handle hDispatchDriver
68661>>>>>        OLE_COLOR retVal
68661>>>>>        Get phDispatchDriver to hDispatchDriver
68662>>>>>        Send PrepareParams to hDispatchDriver 1
68663>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
68664>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
68665>>>>>        Function_Return retVal
68666>>>>>    End_Function
68667>>>>>
68667>>>>>    Procedure ComExcludeModule String llModuleName
68669>>>>>        Handle hDispatchDriver
68669>>>>>        Get phDispatchDriver to hDispatchDriver
68670>>>>>        Send PrepareParams to hDispatchDriver 1
68671>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
68672>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
68673>>>>>    End_Procedure
68674>>>>>
68674>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
68676>>>>>        Handle hDispatchDriver
68676>>>>>        Variant retVal
68676>>>>>        Get phDispatchDriver to hDispatchDriver
68677>>>>>        Send PrepareParams to hDispatchDriver 2
68678>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
68679>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
68680>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
68681>>>>>        Function_Return retVal
68682>>>>>    End_Function
68683>>>>>
68683>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
68685>>>>>        Handle hDispatchDriver
68685>>>>>        Get phDispatchDriver to hDispatchDriver
68686>>>>>        Send PrepareParams to hDispatchDriver 2
68687>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
68688>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
68689>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
68690>>>>>    End_Procedure
68691>>>>>
68691>>>>>    Procedure ComAboutBox
68693>>>>>        Handle hDispatchDriver
68693>>>>>        Get phDispatchDriver to hDispatchDriver
68694>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
68695>>>>>    End_Procedure
68696>>>>>End_Class
68697>>>>>
68697>>>>>// CLSID: {C0DE1830-4463-4030-B324-AC6A8075FEC8}
68697>>>>>// Event interface for SkinFramework Control
68697>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
68698>>>>>
68698>>>>>    Procedure RegisterComEvents
68700>>>>>    End_Procedure
68701>>>>>End_Class
68702>>>>>
68702>>>>>// CoClass
68702>>>>>// ProgID: Codejock.SkinFramework.18.3.0
68702>>>>>// CLSID: {C0DE1830-2217-42EE-B1B0-82C890431F17}
68702>>>>>// SkinFramework Control
68702>>>>>Class cCJComSkinFramework is a cComActiveXControl
68703>>>>>    Import_Class_Protocol cCJ_DSkinFramework
68704>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
68705>>>>>
68705>>>>>    Procedure Construct_Object
68707>>>>>        Forward Send Construct_Object
68709>>>>>        Set psProgID to "{C0DE1830-2217-42EE-B1B0-82C890431F17}"
68710>>>>>        Set psEventId to "{C0DE1830-4463-4030-B324-AC6A8075FEC8}"
68711>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2018 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v18.3"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
68712>>>>>        Set peAutoCreate to acAutoCreate
68713>>>>>    End_Procedure
68714>>>>>End_Class
68715>>>>>
68715>>>>>// CLSID: {C0DE1830-CA9A-4AA9-8601-0AB7F551AA3D}
68715>>>>>// SkinFramework Global Settings
68715>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
68716>>>>>
68716>>>>>    Function ComLicense Returns String
68718>>>>>        String retVal
68718>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
68719>>>>>        Function_Return retVal
68720>>>>>    End_Function
68721>>>>>
68721>>>>>    Procedure Set ComLicense String value
68723>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
68724>>>>>    End_Procedure
68725>>>>>
68725>>>>>    Function ComTitle Returns String
68727>>>>>        String retVal
68727>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
68728>>>>>        Function_Return retVal
68729>>>>>    End_Function
68730>>>>>
68730>>>>>    Procedure Set ComTitle String value
68732>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
68733>>>>>    End_Procedure
68734>>>>>
68734>>>>>    Function ComVersion Returns String
68736>>>>>        Handle hDispatchDriver
68736>>>>>        String retVal
68736>>>>>        Get phDispatchDriver to hDispatchDriver
68737>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
68738>>>>>        Function_Return retVal
68739>>>>>    End_Function
68740>>>>>
68740>>>>>    Function ComUnicode Returns Boolean
68742>>>>>        Handle hDispatchDriver
68742>>>>>        Boolean retVal
68742>>>>>        Get phDispatchDriver to hDispatchDriver
68743>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
68744>>>>>        Function_Return retVal
68745>>>>>    End_Function
68746>>>>>
68746>>>>>    Function ComOcxPath Returns String
68748>>>>>        Handle hDispatchDriver
68748>>>>>        String retVal
68748>>>>>        Get phDispatchDriver to hDispatchDriver
68749>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
68750>>>>>        Function_Return retVal
68751>>>>>    End_Function
68752>>>>>End_Class
68753>>>>>
68753>>>>>// CoClass
68753>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.18.3.0
68753>>>>>// CLSID: {C0DE1830-F744-4373-B38D-29CE83EF0EE5}
68753>>>>>// SkinFramework Global Settings
68753>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
68754>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
68755>>>>>
68755>>>>>    Procedure Construct_Object
68757>>>>>        Forward Send Construct_Object
68759>>>>>        Set psProgID to "{C0DE1830-F744-4373-B38D-29CE83EF0EE5}"
68760>>>>>        Set peAutoCreate to acNoAutoCreate
68761>>>>>    End_Procedure
68762>>>>>End_Class
68763>>>>>
68763>>>>>// CLSID: {C0DE1830-1038-498E-A936-361F08B4C4AA}
68763>>>>>Class cCJSkinIniFile is a cComAutomationObject
68764>>>>>
68764>>>>>    Function ComColorScheme Returns String
68766>>>>>        String retVal
68766>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
68767>>>>>        Function_Return retVal
68768>>>>>    End_Function
68769>>>>>
68769>>>>>    Procedure Set ComColorScheme String value
68771>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
68772>>>>>    End_Procedure
68773>>>>>
68773>>>>>    Function ComFontSize Returns String
68775>>>>>        String retVal
68775>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
68776>>>>>        Function_Return retVal
68777>>>>>    End_Function
68778>>>>>
68778>>>>>    Procedure Set ComFontSize String value
68780>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
68781>>>>>    End_Procedure
68782>>>>>
68782>>>>>    Function ComIniFileName Returns String
68784>>>>>        String retVal
68784>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
68785>>>>>        Function_Return retVal
68786>>>>>    End_Function
68787>>>>>
68787>>>>>    Procedure Set ComIniFileName String value
68789>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
68790>>>>>    End_Procedure
68791>>>>>End_Class
68792>>>>>
68792>>>>>// CLSID: {C0DE1830-4834-499E-95B4-30E0C3F43A10}
68792>>>>>Class cCJSkinDescription is a cComAutomationObject
68793>>>>>
68793>>>>>    Function ComName Returns String
68795>>>>>        String retVal
68795>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
68796>>>>>        Function_Return retVal
68797>>>>>    End_Function
68798>>>>>
68798>>>>>    Procedure Set ComName String value
68800>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
68801>>>>>    End_Procedure
68802>>>>>
68802>>>>>    Function ComPath Returns String
68804>>>>>        String retVal
68804>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
68805>>>>>        Function_Return retVal
68806>>>>>    End_Function
68807>>>>>
68807>>>>>    Procedure Set ComPath String value
68809>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
68810>>>>>    End_Procedure
68811>>>>>
68811>>>>>    Function ComCount Returns Integer
68813>>>>>        Handle hDispatchDriver
68813>>>>>        Integer retVal
68813>>>>>        Get phDispatchDriver to hDispatchDriver
68814>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
68815>>>>>        Function_Return retVal
68816>>>>>    End_Function
68817>>>>>
68817>>>>>    Function ComIniFile Integer llIndex Returns Variant
68819>>>>>        Handle hDispatchDriver
68819>>>>>        Variant retVal
68819>>>>>        Get phDispatchDriver to hDispatchDriver
68820>>>>>        Send PrepareParams to hDispatchDriver 1
68821>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
68822>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
68823>>>>>        Function_Return retVal
68824>>>>>    End_Function
68825>>>>>
68825>>>>>    Function Com_NewEnum Returns Variant
68827>>>>>        Handle hDispatchDriver
68827>>>>>        Variant retVal
68827>>>>>        Get phDispatchDriver to hDispatchDriver
68828>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
68829>>>>>        Function_Return retVal
68830>>>>>    End_Function
68831>>>>>End_Class
68832>>>>>
68832>>>>>// CLSID: {C0DE1830-FB37-4B08-A2B9-F6F8B253D697}
68832>>>>>Class cCJSkinDescriptions is a cComAutomationObject
68833>>>>>
68833>>>>>    Function ComCount Returns Integer
68835>>>>>        Handle hDispatchDriver
68835>>>>>        Integer retVal
68835>>>>>        Get phDispatchDriver to hDispatchDriver
68836>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
68837>>>>>        Function_Return retVal
68838>>>>>    End_Function
68839>>>>>
68839>>>>>    Function ComSkin Integer llIndex Returns Variant
68841>>>>>        Handle hDispatchDriver
68841>>>>>        Variant retVal
68841>>>>>        Get phDispatchDriver to hDispatchDriver
68842>>>>>        Send PrepareParams to hDispatchDriver 1
68843>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
68844>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
68845>>>>>        Function_Return retVal
68846>>>>>    End_Function
68847>>>>>
68847>>>>>    Function Com_NewEnum Returns Variant
68849>>>>>        Handle hDispatchDriver
68849>>>>>        Variant retVal
68849>>>>>        Get phDispatchDriver to hDispatchDriver
68850>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
68851>>>>>        Function_Return retVal
68852>>>>>    End_Function
68853>>>>>End_Class
68854>>>>>
68854>>>>>// CLSID: {C0DE1830-C56F-43C0-BCF1-8193B35FE4C4}
68854>>>>>Class cCJSkinSchema is a cComAutomationObject
68855>>>>>
68855>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
68857>>>>>        Handle hDispatchDriver
68857>>>>>        OLE_COLOR retVal
68857>>>>>        Get phDispatchDriver to hDispatchDriver
68858>>>>>        Send PrepareParams to hDispatchDriver 1
68859>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
68860>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
68861>>>>>        Function_Return retVal
68862>>>>>    End_Function
68863>>>>>End_Class
68864>>>Use cApplication.pkg
68864>>>
68864>>>Struct tSkinInformation
68864>>>    String sName     // description of the skin
68864>>>    String sSkinfile // file path. Can be relative or full
68864>>>    String sSkinIni  // section name
68864>>>End_Struct
68864>>>
68864>>>
68864>>>Class cCJSkinFramework is a cCJComSkinFramework
68865>>>    
68865>>>    Procedure Construct_Object
68867>>>        Forward Send Construct_Object
68869>>>        
68869>>>        Property String psSkinFile ""
68870>>>        Property String psSkinIni ""
68871>>>        Property Boolean pbLoadPreference False
68872>>>        
68872>>>        Set peAutoCreate to acAutoCreate
68873>>>        
68873>>>        Move Self to ghoSkinFramework
68874>>>    End_Procedure
68875>>>    
68875>>>    // return the default skin path, which is the programs directory.
68875>>>    // This requires an application object.
68875>>>    // If you want to different skin path, override this.
68875>>>    Function SkinPath Returns String
68877>>>        String sPath sPaths
68877>>>        Handle hoWorkspace
68877>>>        If ghoApplication Begin
68879>>>            Get phoWorkspace of ghoApplication to hoWorkspace
68880>>>            Get psProgramPath of hoWorkspace to sPaths
68881>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
68882>>>        End
68882>>>>
68882>>>        Else Begin
68883>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
68884>>>>
68884>>>        End
68884>>>>
68884>>>        Function_Return sPath
68885>>>    End_Function
68886>>>    
68886>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
68886>>>    // returns itself. If it is not, it uses SkinPath to get the path.
68886>>>    Function SkinQFile Returns String
68888>>>        String sFile sPath sSep
68888>>>        Boolean bQualified
68888>>>        Get psSkinFile to sFile
68889>>>        If not (IsFileNameQualified(sFile)) Begin
68891>>>            Get SkinPath to sPath
68892>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
68893>>>            Move (sPath - sSep - sFile) to sFile
68894>>>        End
68894>>>>
68894>>>        Function_Return sFile
68895>>>    End_Function
68896>>>    
68896>>>    // defines the default VDF window class mapping.
68896>>>    Procedure OnAddVDFWindowClasses
68898>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
68899>>>        Send ComAddWindowClass "DFentry"                 "Edit"
68900>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
68901>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
68902>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
68903>>>        Send ComAddWindowClass "DFformlist"              "Edit"
68904>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
68905>>>        Send ComAddWindowClass "DFbutton"                "Button"
68906>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
68907>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
68908>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
68909>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
68910>>>        Send ComAddWindowClass "DFedit"                  "edit"
68911>>>        Send ComAddWindowClass "DFlistedit"              "edit"
68912>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
68913>>>        Send ComAddWindowClass "DFgroup"                 "Button"
68914>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
68915>>>        // External class
68915>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
68916>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
68917>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
68918>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
68919>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
68920>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
68921>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
68922>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
68923>>>    End_Procedure
68924>>>    
68924>>>    // Used to support developer designed class mappings (e.g. COM controls)
68924>>>    Procedure OnAddCustomWindowClasses
68926>>>    End_Procedure
68927>>>    
68927>>>    // called when object is created during end_construct_object.
68927>>>    Procedure OnCreate
68929>>>        Integer iOpts
68929>>>        Boolean bUseWindowsFont
68929>>>        Forward Send OnCreate
68931>>>        
68931>>>        // if we are using the windows fonts we will disable the apply metrics which
68931>>>        // never really looked good anyway. This test only exists or legacy purposes
68931>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
68932>>>        If bUseWindowsFont Begin
68934>>>            Get ComApplyOptions to iOpts
68935>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
68936>>>        End
68936>>>>
68936>>>        
68936>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
68936>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
68936>>>        // and this was the suggested workaround.
68936>>>        Set ComAutoApplyNewThreads to False
68937>>>        
68937>>>        Send OnAddVDFWindowClasses
68938>>>        Send OnAddCustomWindowClasses
68939>>>        
68939>>>        // if preferences are used, it will set psSkinFile and psSkinIni
68939>>>        If (pbLoadPreference(Self)) Begin
68941>>>            Send LoadSkinPreference
68942>>>        End
68942>>>>
68942>>>        // if a skin file name exists, we apply the skin.
68942>>>        If (psSkinFile(Self)<>"") Begin
68944>>>            Send ApplySkin
68945>>>        End
68945>>>>
68945>>>    End_Procedure
68946>>>    
68946>>>    // called by framework as part of application exit.
68946>>>    Procedure Broadcast_Notify_Exit_Application
68948>>>        Send Notify_Exit_Application
68949>>>    End_Procedure
68950>>>    
68950>>>    Procedure Notify_Exit_Application
68952>>>        If (pbLoadPreference(Self)) Begin
68954>>>            Send SaveSkinPreference
68955>>>        End
68955>>>>
68955>>>    End_Procedure
68956>>>    
68956>>>    Procedure NotifyPreApplySkin
68958>>>        Broadcast Send OnPreApplySkin of Desktop True
68960>>>    End_Procedure
68961>>>    
68961>>>    Procedure NotifyPostApplySkin
68963>>>        Broadcast Send OnPostApplySkin of Desktop True
68965>>>    End_Procedure
68966>>>    
68966>>>    // returns an array of all skins in the path. If path is "", use the default path.
68966>>>    // If the default path is used, returns the file names as relative names, else use full path.
68966>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
68968>>>        tSkinInformation[] Skins
68968>>>        tSkinInformation[] Skins
68969>>>        String sSkinName sSkinFile sDefaultPath sSep
68969>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
68969>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
68969>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
68969>>>        Integer iPos iDfltLen
68969>>>        Boolean bUseRelativePath
68969>>>        
68969>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
68970>>>        
68970>>>        Get SkinPath to sDefaultPath
68971>>>        If (sPath="") Begin
68973>>>            Move sDefaultPath to sPath
68974>>>        End
68974>>>>
68974>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
68975>>>        Move (Length(sDefaultPath)) to iDfltLen
68976>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
68977>>>        
68977>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
68978>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
68980>>>            
68980>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
68981>>>            Get Create U_cCJSkinDescription to hSkinDescription
68982>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
68983>>>            
68983>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
68984>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
68985>>>            
68985>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
68991>>>>
68991>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
68992>>>                Set pvComObject of hSkinDescription to vSkinDescription
68993>>>                
68993>>>                Get ComCount of hSkinDescription to iNumSkins
68994>>>                
68994>>>                For iSkinsCount from 0 to (iNumSkins-1)
69000>>>>
69000>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
69001>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
69002>>>                    
69002>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
69003>>>                    Get ComPath of hSkinDescription to sSkinFile
69004>>>                    If bUseRelativePath Begin
69006>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
69007>>>                        If iPos Begin
69009>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
69010>>>                            While (Left(sSkinFile,1)=sSep)
69014>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
69015>>>                            Loop
69016>>>>
69016>>>                        End
69016>>>>
69016>>>                    End
69016>>>>
69016>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
69017>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
69018>>>                    
69018>>>                    Increment iArrayItem
69019>>>                Loop
69020>>>>
69020>>>            Loop
69021>>>>
69021>>>            
69021>>>            Send Destroy of hSkinDescriptions
69022>>>            Send Destroy of hSkinDescription
69023>>>            Send Destroy of hSkinIniFile
69024>>>            
69024>>>        End
69024>>>>
69024>>>        Function_Return Skins
69025>>>    End_Function
69026>>>    
69026>>>    // Save the skin preference. This requires an application object.
69026>>>    // Only do this if the application object allows it.
69026>>>    // This is called during startup if pbLoadPreference is True
69026>>>    // Suitable for override
69026>>>    Procedure SaveSkinPreference
69028>>>        String sSkin sIni
69028>>>        If ghoApplication Begin
69030>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
69032>>>                Get psSkinFile to sSkin
69033>>>                Get psSkinIni to sIni
69034>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
69035>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
69036>>>            End
69036>>>>
69036>>>        End
69036>>>>
69036>>>        Else Begin
69037>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
69038>>>>
69038>>>        End
69038>>>>
69038>>>    End_Procedure
69039>>>    
69039>>>    // Load the skin preference. This requires an application object.
69039>>>    // Only do this if the application object allows it.
69039>>>    // This is called during startup if pbLoadPreference is True
69039>>>    // Suitable for override
69039>>>    Procedure LoadSkinPreference
69041>>>        String sSkin sIni
69041>>>        Boolean bExists
69041>>>        If ghoApplication Begin
69043>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
69045>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
69046>>>                If bExists Begin
69048>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
69049>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
69050>>>                    Set psSkinFile to sSkin
69051>>>                    Set psSkinIni to sIni
69052>>>                End
69052>>>>
69052>>>            End
69052>>>>
69052>>>        End
69052>>>>
69052>>>        Else Begin
69053>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
69054>>>>
69054>>>        End
69054>>>>
69054>>>    End_Procedure
69055>>>    
69055>>>    // Can be called to apply the current skin.
69055>>>    Procedure ApplySkin
69057>>>        Boolean bOk
69057>>>        String sSkin sIni
69057>>>        If (IsComObjectCreated(Self)) Begin
69059>>>            Get SkinQFile to sSkin
69060>>>            Get psSkinIni to sIni
69061>>>            
69061>>>            Send NotifyPreApplySkin
69062>>>            // when skins are used we don't want to use built in Visual Styles
69062>>>            Send EnableVisualStyles of Desktop (sSkin="")
69063>>>            Get ComLoadSkin sSkin sIni to bOK
69064>>>            If (sSkin<>"" and not(bOk)) Begin
69066>>>                // if not ok, no skin was appied. Enable visual styles
69066>>>                Send EnableVisualStyles of Desktop True
69067>>>            End
69067>>>>
69067>>>            Send NotifyPostApplySkin
69068>>>        End
69068>>>>
69068>>>    End_Procedure
69069>>>    
69069>>>    
69069>>>End_Class
69070>Use cCJCommandBarSystem.pkg                      
69070>// Unmark this Define statement if using Mertech drivers!
69070>Define DUF_Use_Mertech_Drivers
69070>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
69070>>>//****************************************************************************
69070>>>// $Module type: Class
69070>>>// $Module name: cSQLConnectionIniFile.pkg
69070>>>//
69070>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
69070>>>// Copyright (c) 2012 RDC Tools International
69070>>>// E-mail      : support@rdctools.com
69070>>>// Web-site    : http://www.rdctools.com
69070>>>//
69070>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
69070>>>//
69070>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
69070>>>//               properties of that object.
69070>>>//
69070>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
69070>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
69070>>>// This is free software; you can redistribute it and/or modify it under the terms of the
69070>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
69070>>>// in the help folder for more details.
69070>>>//
69070>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
69070>>>>>//****************************************************************************
69070>>>>>// $Module type: Include file
69070>>>>>// $Module name: cSQLConnectionIniFile.inc
69070>>>>>//
69070>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
69070>>>>>// Copyright (c) 2012 RDC Tools International
69070>>>>>// E-mail      : support@rdctools.com
69070>>>>>// Web-site    : http://www.rdctools.com
69070>>>>>//
69070>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
69070>>>>>//
69070>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
69070>>>>>//
69070>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
69070>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
69070>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
69070>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
69070>>>>>// in the help folder for more details.
69070>>>>>//
69070>>>>>Use Winkern.pkg
69070>>>>>Use cIniFile.pkg
69070>>>>>    Use cCryptographer.pkg
Including file: cCryptographer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCryptographer.pkg)
69070>>>>>>>Use VdfBase.pkg
69070>>>>>>>
69070>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\CryptographerConstants.pkg)
69070>>>>>>>>>//   Author  : Ulbe Stellema
69070>>>>>>>>>// Algorithm classes
69070>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
69070>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
69070>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
69070>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
69070>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
69070>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
69070>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
69070>>>>>>>>>
69070>>>>>>>>>// Algorithm types
69070>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
69070>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
69070>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
69070>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
69070>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
69070>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
69070>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
69070>>>>>>>>>
69070>>>>>>>>>// Generic sub-ids
69070>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
69070>>>>>>>>>
69070>>>>>>>>>// RSA sub-ids
69070>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
69070>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
69070>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
69070>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
69070>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
69070>>>>>>>>>
69070>>>>>>>>>// DSS sub-ids
69070>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
69070>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
69070>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
69070>>>>>>>>>
69070>>>>>>>>>// DES sub_ids
69070>>>>>>>>>Define ALG_SID_DES                      for 1
69070>>>>>>>>>Define ALG_SID_3DES                     for 3
69070>>>>>>>>>Define ALG_SID_DESX                     for 4
69070>>>>>>>>>Define ALG_SID_IDEA                     for 5
69070>>>>>>>>>Define ALG_SID_CAST                     for 6
69070>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
69070>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
69070>>>>>>>>>Define ALG_SID_3DES_112                 for 9
69070>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
69070>>>>>>>>>Define ALG_SID_RC5                      for 13
69070>>>>>>>>>Define ALG_SID_AES_128                  for 14
69070>>>>>>>>>Define ALG_SID_AES_192                  for 15
69070>>>>>>>>>Define ALG_SID_AES_256                  for 16
69070>>>>>>>>>Define ALG_SID_AES                      for 17
69070>>>>>>>>>
69070>>>>>>>>>// Fortezza sub-ids
69070>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
69070>>>>>>>>>Define ALG_SID_TEK                      for 11
69070>>>>>>>>>
69070>>>>>>>>>// RC2 sub-ids
69070>>>>>>>>>Define ALG_SID_RC2                      for 2
69070>>>>>>>>>
69070>>>>>>>>>// Stream cipher sub-ids
69070>>>>>>>>>Define ALG_SID_RC4                      for 1
69070>>>>>>>>>Define ALG_SID_SEAL                     for 2
69070>>>>>>>>>
69070>>>>>>>>>// Diffie-Hellman sub-ids
69070>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
69070>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
69070>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
69070>>>>>>>>>Define ALG_SID_KEA                      for 4
69070>>>>>>>>>
69070>>>>>>>>>// Hash sub ids
69070>>>>>>>>>Define ALG_SID_MD2                      for 1
69070>>>>>>>>>Define ALG_SID_MD4                      for 2
69070>>>>>>>>>Define ALG_SID_MD5                      for 3
69070>>>>>>>>>Define ALG_SID_SHA                      for 4
69070>>>>>>>>>Define ALG_SID_SHA1                     for 4
69070>>>>>>>>>Define ALG_SID_MAC                      for 5
69070>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
69070>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
69070>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
69070>>>>>>>>>Define ALG_SID_HMAC                     for 9
69070>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
69070>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
69070>>>>>>>>>Define ALG_SID_SHA_256                  for 12
69070>>>>>>>>>Define ALG_SID_SHA_384                  for 13
69070>>>>>>>>>Define ALG_SID_SHA_512                  for 14
69070>>>>>>>>>
69070>>>>>>>>>// secure channel sub ids
69070>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
69070>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
69070>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
69070>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
69070>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
69070>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
69070>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
69070>>>>>>>>>
69070>>>>>>>>>// algorithm identifier definitions
69070>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
69070>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
69070>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
69070>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
69070>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
69070>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
69070>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
69070>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
69070>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
69070>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
69070>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
69070>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
69070>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
69070>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
69070>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
69070>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
69070>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
69070>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
69070>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
69070>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
69070>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
69070>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
69070>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
69070>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
69070>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
69070>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
69070>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
69070>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
69070>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
69070>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
69070>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
69070>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
69070>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
69070>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
69070>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
69070>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
69070>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
69070>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
69070>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
69070>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
69070>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
69070>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
69070>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
69070>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
69070>>>>>>>>>
69070>>>>>>>>>// Providers
69070>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
69070>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
69070>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
69070>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
69070>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
69070>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
69070>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
69070>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
69070>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
69070>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
69070>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
69070>>>>>>>>>
69070>>>>>>>>>// dwFlags definitions for CryptAcquireContext
69070>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
69070>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
69070>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
69070>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
69070>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
69070>>>>>>>>>
69070>>>>>>>>>// dwFlag definitions for CryptGenKey
69070>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
69070>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
69070>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
69070>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
69070>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
69070>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
69070>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
69070>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
69070>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
69070>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
69070>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
69070>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
69070>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
69070>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
69070>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
69070>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
69070>>>>>>>>>
69070>>>>>>>>>// Provider types
69070>>>>>>>>>Define PROV_RSA_FULL                    for 1
69070>>>>>>>>>Define PROV_RSA_SIG                     for 2
69070>>>>>>>>>Define PROV_DSS                         for 3
69070>>>>>>>>>Define PROV_FORTEZZA                    for 4
69070>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
69070>>>>>>>>>Define PROV_SSL                         for 6
69070>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
69070>>>>>>>>>Define PROV_DSS_DH                      for 13
69070>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
69070>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
69070>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
69070>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
69070>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
69070>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
69070>>>>>>>>>Define PROV_RNG                         for 21
69070>>>>>>>>>Define PROV_INTEL_SEC                   for 22
69070>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
69070>>>>>>>>>Define PROV_RSA_AES                     for 24
69070>>>>>>>>>
69070>>>>>>>>>// KP_MODE
69070>>>>>>>>>// KP_MODE
69070>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
69070>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
69070>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
69070>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
69070>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
69070>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
69070>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
69070>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
69070>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
69070>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
69070>>>>>>>>>
69070>>>>>>>>>// dwParam definitions for CryptGetKeyParam
69070>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
69070>>>>>>>>>Define KP_SALT                          for 2       // Salt value
69070>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
69070>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
69070>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
69070>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
69070>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
69070>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
69070>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
69070>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
69070>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
69070>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
69070>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
69070>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
69070>>>>>>>>>Define KP_Y                             for 15      // Y value
69070>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
69070>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
69070>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
69070>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
69070>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
69070>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
69070>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
69070>>>>>>>>>Define KP_RP                            for 23
69070>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
69070>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
69070>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
69070>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
69070>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
69070>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
69070>>>>>>>>>Define KP_KEYVAL                        for 30
69070>>>>>>>>>Define KP_ADMIN_PIN                     for 31
69070>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
69070>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
69070>>>>>>>>>Define KP_PREHASH                       for 34
69070>>>>>>>>>Define KP_ROUNDS                        for 35
69070>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
69070>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
69070>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
69070>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
69070>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
69070>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
69070>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
69070>>>>>>>>>
69070>>>>>>>>>// dwParam definitions for CryptGetHashParam
69070>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
69070>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
69070>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
69070>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
69070>>>>>>>>>
69070>>>>>>>>>// key BLOB types
69070>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
69070>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
69070>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
69070>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
69070>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
69070>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
69070>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
69070>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
69070>>>>>>>>>
69070>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
69070>>>>>>>>>
69070>>>>>>>>>//  Structure cryptimportkey
69070>>>>>>>>>Struct PUBLICKEYSTRUC
69070>>>>>>>>>    UChar    bType
69070>>>>>>>>>    UChar    bVersion
69070>>>>>>>>>    UShort   reserved
69070>>>>>>>>>    UInteger aiKeyAlg
69070>>>>>>>>>End_Struct
69070>>>>>>>>>
69070>>>>>>>>>Struct tPLAINTEXTKEYBLOB
69070>>>>>>>>>    PUBLICKEYSTRUC hdr
69070>>>>>>>>>    PUBLICKEYSTRUC hdr
69070>>>>>>>>>    UInteger       dwKeySize
69070>>>>>>>>>//    UChar[]        rgbKeyData
69070>>>>>>>>>End_Struct
69070>>>>>>>>>
69070>>>>>>>>>
69070>>>>>>>>>
69070>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
69070>>>>>>>>>Struct HMAC_INFO
69070>>>>>>>>>    UInteger HashAlgid
69070>>>>>>>>>    Pointer pbInnerString
69070>>>>>>>>>    DWord cbInnerString
69070>>>>>>>>>    Pointer pbOuterString
69070>>>>>>>>>    DWord cbOuterString
69070>>>>>>>>>End_Struct
69070>>>>>>>>>
69070>>>>>>>>>
69070>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
69071>>>>>>>>>
69071>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
69072>>>>>>>>>
69072>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
69073>>>>>>>>>
69073>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
69074>>>>>>>>>
69074>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
69075>>>>>>>>>
69075>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
69076>>>>>>>>>
69076>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
69077>>>>>>>>>
69077>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
69078>>>>>>>>>
69078>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
69079>>>>>>>>>
69079>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
69080>>>>>>>>>    
69080>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
69081>>>>>>>>>
69081>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
69082>>>>>>>>>
69082>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
69083>>>>>>>>>
69083>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
69084>>>>>>>>>    
69084>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
69085>>>>>>>>>    
69085>>>>>>>
69085>>>>>>>Class cCryptographer is a cObject
69086>>>>>>>    
69086>>>>>>>    Procedure Construct_Object
69088>>>>>>>        Forward Send Construct_Object
69090>>>>>>>        
69090>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
69091>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
69092>>>>>>>        Property Integer    piCipher    CALG_RC4
69093>>>>>>>        Property Integer    piHash      CALG_MD5
69094>>>>>>>        
69094>>>>>>>        // Private properties
69094>>>>>>>        Property Handle     Private_phProv
69095>>>>>>>    End_Procedure
69096>>>>>>>    
69096>>>>>>>    
69096>>>>>>>    // Acquire key container handle
69096>>>>>>>    Function AcquireContext Returns Handle
69098>>>>>>>        Integer iProvider
69098>>>>>>>        String sProvider
69098>>>>>>>        Handle hProv
69098>>>>>>>        Boolean bOk
69098>>>>>>>        Address addrProv
69098>>>>>>>        
69098>>>>>>>        Move 0 to hProv
69099>>>>>>>        Get piProvider to iProvider
69100>>>>>>>        Get psProvider to sProvider
69101>>>>>>>        
69101>>>>>>>        //  Determine address to be passed as provider
69101>>>>>>>        If (Trim(sProvider) <> "") Begin
69103>>>>>>>            Move (AddressOf(sProvider)) to addrProv
69104>>>>>>>        End
69104>>>>>>>>
69104>>>>>>>        Else Begin
69105>>>>>>>            Move 0 to addrProv
69106>>>>>>>        End
69106>>>>>>>>
69106>>>>>>>        
69106>>>>>>>        //  Acquire Crypto Context
69106>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
69107>>>>>>>        If (not(bOk) or hProv = 0) Begin
69109>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
69110>>>>>>>        End
69110>>>>>>>>
69110>>>>>>>        
69110>>>>>>>        If (not(bOk) or hProv = 0) Begin
69112>>>>>>>            // Fallback to original
69112>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
69113>>>>>>>            
69113>>>>>>>            If (not(bOk) or hProv = 0) Begin
69115>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
69116>>>>>>>            End
69116>>>>>>>>
69116>>>>>>>        End
69116>>>>>>>>
69116>>>>>>>        Set Private_phProv to hProv
69117>>>>>>>        
69117>>>>>>>        Function_Return hProv
69118>>>>>>>    End_Function
69119>>>>>>>    
69119>>>>>>>    // Releases key container handle
69119>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
69121>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
69122>>>>>>>    End_Function
69123>>>>>>>    
69123>>>>>>>    // Creates hash object
69123>>>>>>>    Function CreateHash Handle hProv Returns Handle
69125>>>>>>>        Integer iAlgorithm
69125>>>>>>>        Handle hHash
69125>>>>>>>        Boolean bOk
69125>>>>>>>        
69125>>>>>>>        Move 0 to hHash
69126>>>>>>>        Get piHash to iAlgorithm
69127>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
69128>>>>>>>        
69128>>>>>>>        Function_Return hHash
69129>>>>>>>    End_Function
69130>>>>>>>    
69130>>>>>>>    // Destroys the hash object
69130>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
69132>>>>>>>        Function_Return (CryptDestroyHash(hHash))
69133>>>>>>>    End_Function
69134>>>>>>>    
69134>>>>>>>    // Adds data to hash object
69134>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
69136>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
69137>>>>>>>    End_Function
69138>>>>>>>    
69138>>>>>>>    // Generates session key
69138>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
69140>>>>>>>        Integer iAlgorithm
69140>>>>>>>        Handle hKey
69140>>>>>>>        Boolean bOk
69140>>>>>>>        
69140>>>>>>>        Move 0 to hKey
69141>>>>>>>        Get piCipher to iAlgorithm
69142>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
69143>>>>>>>        
69143>>>>>>>        Function_Return hKey
69144>>>>>>>    End_Function
69145>>>>>>>    
69145>>>>>>>    // Imports a plain text key
69145>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
69147>>>>>>>        tPLAINTEXTKEYBLOB blobhead
69147>>>>>>>        tPLAINTEXTKEYBLOB blobhead
69147>>>>>>>        Boolean   bSuccess
69147>>>>>>>        Handle    hKey
69147>>>>>>>        Integer   iHeadSize iKeySize
69147>>>>>>>        UChar[]   ucaKeyblob
69148>>>>>>>        Integer iVoid
69148>>>>>>>        
69148>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
69149>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
69150>>>>>>>        
69150>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
69151>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
69152>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
69153>>>>>>>        Move iKeySize           to blobhead.dwKeySize
69154>>>>>>>        
69154>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
69155>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
69156>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
69157>>>>>>>        
69157>>>>>>>        Move 0 to hKey
69158>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
69159>>>>>>>        If (not(bSuccess)) Begin
69161>>>>>>>            Move (ShowLastError()) to iVoid
69162>>>>>>>        End
69162>>>>>>>>
69162>>>>>>>        
69162>>>>>>>        Function_Return hKey
69163>>>>>>>    End_Function
69164>>>>>>>    
69164>>>>>>>    // Destroys the key
69164>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
69166>>>>>>>        Function_Return (CryptDestroyKey(hKey))
69167>>>>>>>    End_Function
69168>>>>>>>    
69168>>>>>>>    // Retrieves key data
69168>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
69170>>>>>>>        Integer iBuffer iLen
69170>>>>>>>        Boolean bOk
69170>>>>>>>        
69170>>>>>>>        Move (SizeOfType(Integer)) to iLen
69171>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
69172>>>>>>>        Function_Return iBuffer
69173>>>>>>>    End_Function
69174>>>>>>>    
69174>>>>>>>    // Retrieves a hash value
69174>>>>>>>    Function HashValue Handle lhHash Returns String
69176>>>>>>>        String  lsHash
69176>>>>>>>        Integer liResult
69176>>>>>>>        DWord   dwDataLen
69176>>>>>>>        
69176>>>>>>>        Move 0 to dwDataLen
69177>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
69178>>>>>>>        If (liResult = 0) ;            Function_Return ""
69181>>>>>>>        
69181>>>>>>>        Move (Repeat(Character(0),dwDataLen)) to lsHash
69182>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(lsHash),AddressOf(dwDataLen),0)) to liResult
69183>>>>>>>        If (liResult = 0) ;            Function_Return ""
69186>>>>>>>        
69186>>>>>>>        Function_Return lsHash
69187>>>>>>>    End_Function
69188>>>>>>>
69188>>>>>>>    // Encrypts data
69188>>>>>>>    Function Encrypt String sPassword String sData Returns String
69190>>>>>>>        Handle hProv hHash hKey
69190>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
69190>>>>>>>        Boolean bOk
69190>>>>>>>        
69190>>>>>>>        Get AcquireContext to hProv
69191>>>>>>>        If (hProv) Begin
69193>>>>>>>            Get CreateHash hProv to hHash
69194>>>>>>>            If (hHash) Begin
69196>>>>>>>                Get HashData hHash sPassword to bOk
69197>>>>>>>                If (bOk) Begin
69199>>>>>>>                    Get piCipher to iAlgorithm
69200>>>>>>>                    Get DeriveKey hProv hHash to hKey
69201>>>>>>>                End
69201>>>>>>>>
69201>>>>>>>                Get DestroyHash hHash to bOk
69202>>>>>>>            End
69202>>>>>>>>
69202>>>>>>>            
69202>>>>>>>            If (hKey) Begin
69204>>>>>>>                //  First call to determine resulting data size
69204>>>>>>>                Move (Length(sData)) to iDataLen
69205>>>>>>>                Move (Length(sData)) to iCipherLen
69206>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
69207>>>>>>>                
69207>>>>>>>                //  Reserve space in string
69207>>>>>>>                If (iDataLen < iCipherLen) Begin
69209>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
69210>>>>>>>                End
69210>>>>>>>>
69210>>>>>>>                
69210>>>>>>>                //  Call to really decrypt
69210>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
69211>>>>>>>                //If (not(bOk)) Begin
69211>>>>>>>                //Move "" to sData
69211>>>>>>>                //Move (GetLastError()) to iErr
69211>>>>>>>                //End
69211>>>>>>>                
69211>>>>>>>                Get DestroyKey hKey to bOk
69212>>>>>>>            End 
69212>>>>>>>>
69212>>>>>>>            Get ReleaseContext hProv to bOk
69213>>>>>>>        End 
69213>>>>>>>>
69213>>>>>>>        Function_Return sData
69214>>>>>>>    End_Function
69215>>>>>>>    
69215>>>>>>>    // Decrypts data
69215>>>>>>>    Function Decrypt String sPassword String sData Returns String
69217>>>>>>>        Handle hProv hHash hKey
69217>>>>>>>        Integer iAlgorithm iDataLen
69217>>>>>>>        Boolean bOk
69217>>>>>>>        
69217>>>>>>>        Get AcquireContext to hProv
69218>>>>>>>        If (hProv) Begin
69220>>>>>>>            Get CreateHash hProv to hHash
69221>>>>>>>            If (hHash) Begin
69223>>>>>>>                Get HashData hHash sPassword to bOk
69224>>>>>>>                If (bOk) Begin
69226>>>>>>>                    Get piCipher to iAlgorithm
69227>>>>>>>                    Get DeriveKey hProv hHash to hKey
69228>>>>>>>                End
69228>>>>>>>>
69228>>>>>>>                Get DestroyHash hHash to bOk
69229>>>>>>>            End
69229>>>>>>>>
69229>>>>>>>            
69229>>>>>>>            If (hKey) Begin
69231>>>>>>>                Move (Length(sData)) to iDataLen
69232>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
69233>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
69233>>>>>>>                If (Length(sData) > iDataLen) Begin
69235>>>>>>>                    Move (Left(sData, iDataLen)) to sData
69236>>>>>>>                End
69236>>>>>>>>
69236>>>>>>>                
69236>>>>>>>                Get DestroyKey hKey to bOk
69237>>>>>>>            End
69237>>>>>>>>
69237>>>>>>>            Get ReleaseContext hProv to bOk
69238>>>>>>>        End
69238>>>>>>>>
69238>>>>>>>        Function_Return sData
69239>>>>>>>    End_Function
69240>>>>>>>    
69240>>>>>>>    //  Generates random data.
69240>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
69242>>>>>>>        Handle hProv
69242>>>>>>>        UChar[] uaResult
69243>>>>>>>        Boolean bRes
69243>>>>>>>        
69243>>>>>>>        Get AcquireContext to hProv
69244>>>>>>>        
69244>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
69245>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
69246>>>>>>>        
69246>>>>>>>        Get ReleaseContext hProv to bRes
69247>>>>>>>        
69247>>>>>>>        Function_Return uaResult
69248>>>>>>>    End_Function
69249>>>>>>>    
69249>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
69249>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
69251>>>>>>>        String sResult
69251>>>>>>>        UChar[] aData
69252>>>>>>>        Address pBase64
69252>>>>>>>        Integer iVoid
69252>>>>>>>        
69252>>>>>>>        Get GenerateRandom iLenght to aData
69253>>>>>>>        
69253>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
69254>>>>>>>        Move pBase64 to sResult
69255>>>>>>>        Move (Free(pBase64)) to iVoid
69256>>>>>>>        
69256>>>>>>>        Function_Return (Left(sResult, iLenght))
69257>>>>>>>    End_Function
69258>>>>>>>    
69258>>>>>>>End_Class
69259>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
69259>>>>>>>//> This package enables base64 encoding and decoding of strings:
69259>>>>>>>//>
69259>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
69259>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
69259>>>>>>>//>
69259>>>>>>>//> Remember to set the "max argument size" if dealing with very large
69259>>>>>>>//> strings.
69259>>>>>>>//>
69259>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
69259>>>>>>>//> Base64Decode) that are built into the runtime.
69259>>>>>>>//>
69259>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
69259>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
69259>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
69259>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
69259>>>>>>>
69259>>>>>>>Use VdfBase.pkg
69259>>>>>>>
69259>>>>>>>// Functions in vdfBase64.dll
69259>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
69260>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
69261>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
69262>>>>>>>
69262>>>>>>>// Structure
69262>>>>>>>Struct txxfBase64Buffer
69262>>>>>>>    Pointer pData
69262>>>>>>>    Integer iLength
69262>>>>>>>End_Struct 
69262>>>>>>>
69262>>>>>>>Global_Variable Integer oBase64Functions
69262>>>>>>>
69262>>>>>>>Object _oBase64Functions is a cObject
69264>>>>>>>    Move Self to oBase64Functions
69265>>>>>>>
69265>>>>>>>
69265>>>>>>>    Function EncodeString String sValue Returns String
69268>>>>>>>        Address pBase64
69268>>>>>>>        String sResult
69268>>>>>>>        Integer iVoid
69268>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
69269>>>>>>>        Move pBase64 to sResult
69270>>>>>>>        Move (Free(pBase64)) to iVoid
69271>>>>>>>        Function_Return sResult
69272>>>>>>>    End_Function
69273>>>>>>>
69273>>>>>>>    Function DecodeString String sValue Returns String
69276>>>>>>>        Address pBinary
69276>>>>>>>        String sBinary
69276>>>>>>>        Integer iVoid iLen
69276>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
69277>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
69278>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
69279>>>>>>>        Move (Free(pBinary)) to iVoid
69280>>>>>>>        Function_Return sBinary
69281>>>>>>>    End_Function
69282>>>>>>>
69282>>>>>>>End_Object
69283>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\MSSqldrv.pkg)
69283>>>>>>>//     Package that declares MS SQL driver constants and functions.
69283>>>>>>>//     This package can be used by developers who want to add Data Access
69283>>>>>>>//     MS SQL Client specific code to a DataFlex application.
69283>>>>>>>
69283>>>>>>>Use Cli.pkg
69283>>>>>>>Use SQL.pkg
69283>>>>>>>
69283>>>>>>>//   Driver Indentification
69283>>>>>>>
69283>>>>>>>//   Error number constants
69283>>>>>>>
69283>>>>>>>
69283>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
69283>>>>>>>
69283>>>>>>>
69283>>>>>>>
69283>>>>>>>
69283>>>>>>>
69283>>>>>>>
69283>>>>>>>// SQL Server spcific types.
69283>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
69283>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
69283>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
69283>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
69283>>>>>>>
69283>>>>>>>// SQL Server spcific types.
69283>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
69283>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
69283>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
69283>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
69283>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
69283>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
69283>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
69283>>>>>>>
69283>>>>>>>
69283>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
69283>>>>>>>//
69283>>>>>>>//     Setup a constraint for a file.
69283>>>>>>>
69283>>>>>>>
69283>>>>>>>Class cMSSQLHandler is a cCLIHandler
69284>>>>>>>    
69284>>>>>>>    Procedure Construct_Object
69286>>>>>>>        Forward Send Construct_Object
69288>>>>>>>        
69288>>>>>>>        Set psDriverID to MSSQLDRV_ID
69289>>>>>>>    End_Procedure
69290>>>>>>>    
69290>>>>>>>    
69290>>>>>>>    
69290>>>>>>>    //   Extract the list from the out connect string.
69290>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
69292>>>>>>>        String  sItem
69292>>>>>>>        Integer iStart
69292>>>>>>>        Integer iEnd
69292>>>>>>>        
69292>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
69295>>>>>>>        
69295>>>>>>>        Send Delete_Data to hoStore
69296>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
69297>>>>>>>        While (iStart > 0)
69301>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
69302>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
69305>>>>>>>            Else Begin
69306>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
69307>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
69308>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
69311>>>>>>>                
69311>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
69314>>>>>>>                
69314>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
69317>>>>>>>            End
69317>>>>>>>>
69317>>>>>>>        Loop
69318>>>>>>>>
69318>>>>>>>        
69318>>>>>>>        Function_Return (Item_Count(hoStore))
69319>>>>>>>    End_Function
69320>>>>>>>    
69320>>>>>>>    
69320>>>>>>>    
69320>>>>>>>    //   Call the driver's browse connect function
69320>>>>>>>    Function BrowseConnect String sInConnStr Returns String
69322>>>>>>>        String  sDriver
69322>>>>>>>        String  sOutConnStr
69322>>>>>>>        Integer iArg
69322>>>>>>>        Integer iRetval
69322>>>>>>>        
69322>>>>>>>        Get psDriverID to sDriver
69323>>>>>>>        If (sDriver <> "") Begin
69325>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
69326>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
69331>>>>>>>        End
69331>>>>>>>>
69331>>>>>>>        
69331>>>>>>>        Function_Return sOutConnStr
69332>>>>>>>    End_Function// BrowseConnect
69333>>>>>>>    
69333>>>>>>>    
69333>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
69335>>>>>>>        String  sDriver
69335>>>>>>>        String  sOutConnStr
69335>>>>>>>        Integer iArg
69335>>>>>>>        Integer iRetval
69335>>>>>>>        
69335>>>>>>>        Move 1 to iArg // Browses only local
69336>>>>>>>        
69336>>>>>>>        Get psDriverID to sDriver
69337>>>>>>>        If (sDriver <> "") Begin
69339>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
69340>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
69345>>>>>>>        End
69345>>>>>>>>
69345>>>>>>>        
69345>>>>>>>        Function_Return sOutConnStr
69346>>>>>>>    End_Function// BrowseConnect
69347>>>>>>>    
69347>>>>>>>    
69347>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
69349>>>>>>>        
69349>>>>>>>        String  sServerList
69349>>>>>>>        Integer iNumServers
69349>>>>>>>        Integer iDriver
69349>>>>>>>        Integer iClientVersion
69349>>>>>>>        String  sDriver
69349>>>>>>>        
69349>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
69350>>>>>>>        
69350>>>>>>>        If (iDriver) Begin
69352>>>>>>>            
69352>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
69355>>>>>>>            
69355>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
69356>>>>>>>            
69356>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
69357>>>>>>>            If (iNetworkLocal = 0) Begin
69359>>>>>>>                Get BrowseConnect sDriver to sServerList
69360>>>>>>>            End
69360>>>>>>>>
69360>>>>>>>            Else Begin
69361>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
69362>>>>>>>            End
69362>>>>>>>>
69362>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
69363>>>>>>>        End
69363>>>>>>>>
69363>>>>>>>        
69363>>>>>>>        Function_Return iNumServers
69364>>>>>>>        
69364>>>>>>>    End_Function
69365>>>>>>>    
69365>>>>>>>    //   Enumerate the available SQL Server database servers
69365>>>>>>>    //   This function will return all SQL Server instances on the network.
69365>>>>>>>    //   This may take a long time.
69365>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
69365>>>>>>>    Function EnumerateServers Returns Integer
69367>>>>>>>        
69367>>>>>>>        Integer iNumServers
69367>>>>>>>        Integer iNetworkLocal
69367>>>>>>>        
69367>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
69368>>>>>>>        
69368>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
69369>>>>>>>        
69369>>>>>>>        Function_Return iNumServers
69370>>>>>>>        
69370>>>>>>>    End_Function
69371>>>>>>>    
69371>>>>>>>    
69371>>>>>>>    //   Enumerate the available SQL Server database servers
69371>>>>>>>    //   This function will return only return SQL Server instance on the local machine
69371>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
69371>>>>>>>    Function EnumerateServersLocal Returns Integer
69373>>>>>>>        
69373>>>>>>>        Integer iNumServers
69373>>>>>>>        Integer iNetworkLocal
69373>>>>>>>        
69373>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
69374>>>>>>>        
69374>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
69375>>>>>>>        
69375>>>>>>>        Function_Return iNumServers
69376>>>>>>>        
69376>>>>>>>    End_Function
69377>>>>>>>    
69377>>>>>>>    
69377>>>>>>>    
69377>>>>>>>    //   Enumerate database in a given server.
69377>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
69379>>>>>>>        Integer hoSQL
69379>>>>>>>        String  sConnect
69379>>>>>>>        String  sDatabase
69379>>>>>>>        Integer hdbc
69379>>>>>>>        Integer hstmt
69379>>>>>>>        Integer iFetchResult
69379>>>>>>>        
69379>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
69382>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
69385>>>>>>>        
69385>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
69388>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
69390>>>>>>>        
69390>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
69392>>>>>>>            Move Current_Object to hoSQL
69393>>>>>>>        End_Object
69394>>>>>>>        
69394>>>>>>>        If (hoSQL <> 0) Begin
69396>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
69397>>>>>>>            If (hdbc <> 0) Begin
69399>>>>>>>                Get SQLOpen of hdbc to hstmt
69400>>>>>>>                If (hstmt <> 0) Begin
69402>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
69402>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
69402>>>>>>>                    //   approach in case meta data might change, the stored procedure will
69402>>>>>>>                    //   stay the same.
69402>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
69403>>>>>>>                    Send SQLCall to hstmt
69404>>>>>>>                    Repeat
69404>>>>>>>>
69404>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
69405>>>>>>>                        If (iFetchResult <> 0) Begin
69407>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
69408>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
69409>>>>>>>                        End
69409>>>>>>>>
69409>>>>>>>                    Until (iFetchResult = 0)
69411>>>>>>>                    
69411>>>>>>>                    Send SQLClose to hstmt
69412>>>>>>>                End
69412>>>>>>>>
69412>>>>>>>                Send SQLDisconnect to hdbc
69413>>>>>>>            End
69413>>>>>>>>
69413>>>>>>>        End
69413>>>>>>>>
69413>>>>>>>        Send Destroy_Object to hoSQL
69414>>>>>>>        
69414>>>>>>>        Function_Return (Item_Count(Current_Object))
69415>>>>>>>    End_Function
69416>>>>>>>    
69416>>>>>>>    
69416>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
69418>>>>>>>        
69418>>>>>>>        String  sSqlServerClientVersionName
69418>>>>>>>        
69418>>>>>>>        
69418>>>>>>>        Case Begin
69418>>>>>>>            
69418>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
69420>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
69421>>>>>>>                Case Break
69422>>>>>>>                
69422>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
69425>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
69426>>>>>>>                Case Break
69427>>>>>>>            
69427>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
69430>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
69431>>>>>>>                Case Break
69432>>>>>>>            
69432>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
69435>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
69436>>>>>>>                Case Break
69437>>>>>>>            
69437>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
69440>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
69441>>>>>>>                Case Break
69442>>>>>>>            
69442>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
69445>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
69446>>>>>>>                Case Break
69447>>>>>>>            
69447>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
69450>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
69451>>>>>>>                Case Break
69452>>>>>>>            
69452>>>>>>>            Case Else
69452>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
69453>>>>>>>                
69453>>>>>>>        Case End
69453>>>>>>>        
69453>>>>>>>        
69453>>>>>>>        Function_Return sSqlServerClientVersionName
69454>>>>>>>        
69454>>>>>>>    End_Function
69455>>>>>>>
69455>>>>>>>
69455>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
69457>>>>>>>        
69457>>>>>>>        String  sSqlServerClientDriverName
69457>>>>>>>        
69457>>>>>>>        Case Begin
69457>>>>>>>            
69457>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
69459>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
69460>>>>>>>                Case Break
69461>>>>>>>                
69461>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
69464>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
69465>>>>>>>                Case Break
69466>>>>>>>            
69466>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
69469>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
69470>>>>>>>                Case Break
69471>>>>>>>            
69471>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
69474>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
69475>>>>>>>                Case Break
69476>>>>>>>            
69476>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
69479>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
69480>>>>>>>                Case Break
69481>>>>>>>            
69481>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
69484>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
69485>>>>>>>                Case Break
69486>>>>>>>            
69486>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
69489>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
69490>>>>>>>                Case Break
69491>>>>>>>            
69491>>>>>>>            Case Else
69491>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
69492>>>>>>>                
69492>>>>>>>        Case End
69492>>>>>>>        
69492>>>>>>>        
69492>>>>>>>        Function_Return sSqlServerClientDriverName
69493>>>>>>>        
69493>>>>>>>    End_Function
69494>>>>>>>    
69494>>>>>>>    
69494>>>>>>>End_Class
69495>>>>>>>
69495>>>>>>>
69495>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\db2_drv.pkg)
69495>>>>>>>// DB2_DRV.PKG                                                          
69495>>>>>>>//   Package that declares DB2 driver constants and functions.          
69495>>>>>>>//   This package can be used by developers who want to add DB2 driver  
69495>>>>>>>//   specific code to a DataFlex application.                           
69495>>>>>>>
69495>>>>>>>Use Cli.pkg
69495>>>>>>>
69495>>>>>>>// Driver attributes
69495>>>>>>>
69495>>>>>>>
69495>>>>>>>// Driver Indentification
69495>>>>>>>
69495>>>>>>>// Error number constants
69495>>>>>>>
69495>>>>>>>// Call driver function identifiers
69495>>>>>>>
69495>>>>>>>// DB2 specific data types
69495>>>>>>>Define SQL_CLOB           for   (-99)
69495>>>>>>>Define SQL_BLOB           for   (-98)
69495>>>>>>>Define SQL_XML            for   (-370)
69495>>>>>>>// DB2 Graphic types are Unicode types
69495>>>>>>>Define SQL_GRAPHIC        for   (-95)
69495>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
69495>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
69495>>>>>>>Define SQL_DBCLOB         for   (-350)
69495>>>>>>>
69495>>>>>>>
69495>>>>>>>// Extra DB2 commands
69495>>>>>>>
69495>>>>>>>
69495>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
69495>>>>>>>//   Setup a constraint for a file.                                     
69495>>>>>>>
69495>>>>>>>
69495>>>>>>>
69495>>>>>>>Class cDB2Handler is a cCLIHandler
69496>>>>>>>    
69496>>>>>>>    Procedure Construct_Object
69498>>>>>>>        Forward Send Construct_Object
69500>>>>>>>        
69500>>>>>>>        Set psDriverID to DB2_DRV_ID
69501>>>>>>>    End_Procedure
69502>>>>>>>    
69502>>>>>>>    
69502>>>>>>>    
69502>>>>>>>    // Reset the datasource list to the beginning
69502>>>>>>>    Procedure SeedDataSources
69504>>>>>>>        String  sDriver
69504>>>>>>>        String  sVoid
69504>>>>>>>        Integer iRetval
69504>>>>>>>        
69504>>>>>>>        Get psDriverID to sDriver
69505>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
69512>>>>>>>    End_Procedure
69513>>>>>>>    
69513>>>>>>>    
69513>>>>>>>    
69513>>>>>>>    // Call the driver's data sources function
69513>>>>>>>    Function DataSources Returns String
69515>>>>>>>        String  sDriver
69515>>>>>>>        String  sDataSource
69515>>>>>>>        String  sDescription
69515>>>>>>>        Integer iLength
69515>>>>>>>        Integer iRetval
69515>>>>>>>        
69515>>>>>>>        Get psDriverID to sDriver
69516>>>>>>>        If (sDriver <> "") Begin
69518>>>>>>>            Move 8192 to iLength
69519>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
69520>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
69521>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
69526>>>>>>>        End
69526>>>>>>>>
69526>>>>>>>        
69526>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
69529>>>>>>>        Else ;            Function_Return ""
69531>>>>>>>    End_Function
69532>>>>>>>    
69532>>>>>>>End_Class
69533>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\odbc_drv.pkg)
69533>>>>>>>//   Package that declares ODBC driver constants and functions.         
69533>>>>>>>//   This package can be used by developers who want to add Data Access 
69533>>>>>>>//   ODBC Client specific code to a DataFlex application.               
69533>>>>>>>
69533>>>>>>>Use Cli.pkg
69533>>>>>>>
69533>>>>>>>// Driver Indentification
69533>>>>>>>
69533>>>>>>>// Error number constants
69533>>>>>>>
69533>>>>>>>// Call driver function identifiers
69533>>>>>>>
69533>>>>>>>Class cODBCHandler is a cCLIHandler
69534>>>>>>>    
69534>>>>>>>    Procedure Construct_Object
69536>>>>>>>        Forward Send Construct_Object
69538>>>>>>>        
69538>>>>>>>        Set psDriverID to ODBC_DRV_ID
69539>>>>>>>    End_Procedure
69540>>>>>>>    
69540>>>>>>>    
69540>>>>>>>    
69540>>>>>>>    // Setup the type of data sources returned by the datasources function
69540>>>>>>>    Procedure Set DataSourceType Integer iNewType
69542>>>>>>>        String  sDriver
69542>>>>>>>        String  sVoid
69542>>>>>>>        Integer iRetval
69542>>>>>>>        
69542>>>>>>>        Get psDriverID to sDriver
69543>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
69550>>>>>>>    End_Procedure
69551>>>>>>>    
69551>>>>>>>    
69551>>>>>>>    // Call the driver's data sources function
69551>>>>>>>    Function DataSources Returns String
69553>>>>>>>        String  sDriver
69553>>>>>>>        String  sDataSource
69553>>>>>>>        String  sDescription
69553>>>>>>>        Integer iLength
69553>>>>>>>        Integer iRetval
69553>>>>>>>        
69553>>>>>>>        Get psDriverID to sDriver
69554>>>>>>>        If (sDriver <> "") Begin
69556>>>>>>>            Move 8192 to iLength
69557>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
69558>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
69559>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
69564>>>>>>>        End
69564>>>>>>>>
69564>>>>>>>        
69564>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
69567>>>>>>>        Else ;            Function_Return ""
69569>>>>>>>    End_Function
69570>>>>>>>    
69570>>>>>>>End_Class
69571>>>>>>>
69571>>>>>Use DFBtrDrv.pkg
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.1\Pkg\DFBTRDRV.PKG)
69571>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
69571>>>>>>>// Notice      : This package contains constants and commands, used to call
69571>>>>>>>//               specific functions in the DFBTRDRV.
69571>>>>>>>Use Ui
69571>>>>>>>//
69571>>>>>>>// Driver Indentification
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>// Driver attributes
69571>>>>>>>//
69571>>>>>>>// Call_Driver functions ID's
69571>>>>>>>//
69571>>>>>>>//
69571>>>>>>>// DFBTRFN_CONVERT_FILE options
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// DFBTRFN_SET_OWNER options
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// Command to create all vars which may be needed
69571>>>>>>>// in other commands.
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// Command to set the owner of a Btrieve file.
69571>>>>>>>// File must have been opened.
69571>>>>>>>// Filenumber needs to be passed.
69571>>>>>>>// To clear set the owner to "".
69571>>>>>>>// Examples:
69571>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
69571>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
69571>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
69571>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
69571>>>>>>>// To clear:
69571>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// Command to parse DFBTR_SET_OWNVER
69571>>>>>>>// options.
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// Command to parse for Callback
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// Command to clear the owner of a Btrieve file.
69571>>>>>>>// File must have been opened.
69571>>>>>>>// Filenumber needs to be passed.
69571>>>>>>>// Examples:
69571>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// Command to add a owner name to the internal list of ownernames
69571>>>>>>>// which will be tries when opening files.
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// Command to remove all owners from the internal list of ownernames
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// Command to set the owner name to be used when opening the DDF files.
69571>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
69571>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
69571>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// Command to change the transaction type.
69571>>>>>>>// Valid types are:
69571>>>>>>>//     DFBTRTT_NONE
69571>>>>>>>//     DFBTRTT_EXCLUSIVE
69571>>>>>>>//     DFBTRTT_CONCURRENT
69571>>>>>>>//
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// Command to get the current transaction type.
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// Command to set explicit_locking
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// Command to get explicit locking
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>//
69571>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
69571>>>>>>>//
69571>>>>>>>
69571>>>>>>>// Purpose: An instance of this class can be used as a broker object to
69571>>>>>>>//          call several Dfbtrdrv releated methods.
69571>>>>>>>
69571>>>>>>>Class cDFBtrDrvHandler is an Array
69572>>>>>>>    
69572>>>>>>>    Procedure Construct_Object Integer iImage
69574>>>>>>>        Forward Send Construct_object iImage
69576>>>>>>>        
69576>>>>>>>        Property String  psDriverID "DFBTRDRV"
69577>>>>>>>    End_Procedure
69578>>>>>>>    
69578>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
69578>>>>>>>    //
69578>>>>>>>    
69578>>>>>>>    Function CKRevision Returns String
69580>>>>>>>        String  sDriverID
69580>>>>>>>        String  sRevision
69580>>>>>>>        String  sVoid
69580>>>>>>>        Integer iRetval
69580>>>>>>>        
69580>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69580>>>>>>>        // This error would otherwise be raised when we have an older
69580>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69580>>>>>>>        Send Ignore_error to Error_object_Id 20491
69581>>>>>>>        Get psDriverID to sDriverID
69582>>>>>>>        Move (Repeat(" ", 255)) to sRevision
69583>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
69588>>>>>>>        Send Trap_Error to Error_object_Id 20491
69589>>>>>>>        If (Trim(sRevision) = "") Begin
69591>>>>>>>            // Unable to get the revision. return all zeroes.
69591>>>>>>>            Move "0.0.0.0" to sRevision
69592>>>>>>>        End
69592>>>>>>>>
69592>>>>>>>        Function_Return sRevision
69593>>>>>>>    End_Function
69594>>>>>>>    
69594>>>>>>>    Function CkUsesUri Returns Integer
69596>>>>>>>        String  sDriverID
69596>>>>>>>        String  sVoid1
69596>>>>>>>        String  sVoid2
69596>>>>>>>        Integer iRetval
69596>>>>>>>        
69596>>>>>>>        Get psDriverID to sDriverID
69597>>>>>>>        
69597>>>>>>>        Move 0 to iRetval
69598>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69598>>>>>>>        // This error would otherwise be raised when we have an older
69598>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
69598>>>>>>>        Send Ignore_error to Error_object_Id 20491
69599>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
69604>>>>>>>        Send Trap_Error to Error_object_Id 20491
69605>>>>>>>        
69605>>>>>>>        Function_Return iRetval
69606>>>>>>>    End_Function
69607>>>>>>>    
69607>>>>>>>    
69607>>>>>>>    
69607>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
69607>>>>>>>    //
69607>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
69607>>>>>>>    //
69607>>>>>>>    
69607>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
69609>>>>>>>        Integer iPartRev
69609>>>>>>>        Integer iCurrentPart
69609>>>>>>>        Integer iSeparatorPos
69609>>>>>>>        
69609>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
69612>>>>>>>        
69612>>>>>>>        Move 0 to iCurrentPart
69613>>>>>>>        Repeat
69613>>>>>>>>
69613>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
69614>>>>>>>            If (iSeparatorPos > 0) Begin
69616>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
69617>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
69618>>>>>>>                Increment iCurrentPart
69619>>>>>>>            End
69619>>>>>>>>
69619>>>>>>>            Else If (sRevision <> "") Begin
69622>>>>>>>                Move sRevision to iPartRev
69623>>>>>>>                Move "" to sRevision
69624>>>>>>>                Increment iCurrentPart
69625>>>>>>>            End
69625>>>>>>>>
69625>>>>>>>            Else ;                Move -1 to iPartRev
69627>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
69629>>>>>>>        
69629>>>>>>>        Function_Return iPartRev
69630>>>>>>>    End_Function
69631>>>>>>>    
69631>>>>>>>    
69631>>>>>>>    
69631>>>>>>>    //
69631>>>>>>>    //  Returns the major revision of the CK
69631>>>>>>>    //
69631>>>>>>>    
69631>>>>>>>    Function CKMajorRevision Returns Integer
69633>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
69634>>>>>>>    End_Function
69635>>>>>>>    
69635>>>>>>>    
69635>>>>>>>    
69635>>>>>>>    //  Returns the minor revision of the CK
69635>>>>>>>    //
69635>>>>>>>    
69635>>>>>>>    Function CKMinorRevision Returns Integer
69637>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
69638>>>>>>>    End_Function
69639>>>>>>>    
69639>>>>>>>    
69639>>>>>>>    //  Returns the release revision of the CK
69639>>>>>>>    //
69639>>>>>>>    
69639>>>>>>>    Function CKReleaseRevision Returns Integer
69641>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
69642>>>>>>>    End_Function
69643>>>>>>>    
69643>>>>>>>    
69643>>>>>>>    //  Returns the major revision of the CK
69643>>>>>>>    //
69643>>>>>>>    
69643>>>>>>>    Function CKBuildRevision Returns Integer
69645>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
69646>>>>>>>    End_Function
69647>>>>>>>    
69647>>>>>>>    
69647>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
69647>>>>>>>    //
69647>>>>>>>    
69647>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
69649>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
69652>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
69655>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
69658>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
69661>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
69664>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
69668>>>>>>>            End
69668>>>>>>>>
69668>>>>>>>        End
69668>>>>>>>>
69668>>>>>>>        
69668>>>>>>>        Function_Return (False)
69669>>>>>>>    End_Function
69670>>>>>>>    
69670>>>>>>>    //   Functions to query the Pervasive.SQL version:
69670>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
69670>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
69670>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
69670>>>>>>>    //
69670>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
69670>>>>>>>    //   in the following format:
69670>>>>>>>    //       <version>.<revision>.<type>
69670>>>>>>>    //   possible values for <type>:
69670>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
69670>>>>>>>    //         server using Workgroup authentication mode
69670>>>>>>>    //       C for client cache engine
69670>>>>>>>    //       D for DOS workstation
69670>>>>>>>    //       N for client Requester
69670>>>>>>>    //       S for NetWare server
69670>>>>>>>    //       T for 32-bit Windows server engine
69670>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
69670>>>>>>>    //
69670>>>>>>>    //   example:
69670>>>>>>>    //       8.50.T
69670>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
69670>>>>>>>    //   32-bits Windows server.
69670>>>>>>>    //
69670>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
69670>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
69670>>>>>>>    //
69670>>>>>>>    //   If the version information is not available or can not be obtained
69670>>>>>>>    //   the functions will return "0.0.0"
69670>>>>>>>    
69670>>>>>>>    //  Returns the version information of the
69670>>>>>>>    //           Pervasive.SQL Client requester.
69670>>>>>>>    
69670>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
69672>>>>>>>        
69672>>>>>>>        String  sDriverID
69672>>>>>>>        String  sVersion
69672>>>>>>>        String  sVoid
69672>>>>>>>        Integer iRetval
69672>>>>>>>        
69672>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69672>>>>>>>        // This error would otherwise be raised when we have an older
69672>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69672>>>>>>>        Send Ignore_error to Error_object_Id 20491
69673>>>>>>>        Get psDriverID to sDriverID
69674>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69675>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69680>>>>>>>        Send Trap_Error to Error_object_Id 20491
69681>>>>>>>        If (Trim(sVersion) = "") Begin
69683>>>>>>>            // Unable to get the revision. return all zeroes.
69683>>>>>>>            Move "0.0.0" to sVersion
69684>>>>>>>        End
69684>>>>>>>>
69684>>>>>>>        Function_Return sVersion
69685>>>>>>>    End_Function
69686>>>>>>>    
69686>>>>>>>    //           Pervasive.SQL Engine
69686>>>>>>>    
69686>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
69688>>>>>>>        
69688>>>>>>>        String  sDriverID
69688>>>>>>>        String  sVersion
69688>>>>>>>        String  sVoid
69688>>>>>>>        Integer iRetval
69688>>>>>>>        
69688>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69688>>>>>>>        // This error would otherwise be raised when we have an older
69688>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69688>>>>>>>        Send Ignore_error to Error_object_Id 20491
69689>>>>>>>        Get psDriverID to sDriverID
69690>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69691>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69696>>>>>>>        Send Trap_Error to Error_object_Id 20491
69697>>>>>>>        If (Trim(sVersion) = "") Begin
69699>>>>>>>            // Unable to get the revision. return all zeroes.
69699>>>>>>>            Move "0.0.0" to sVersion
69700>>>>>>>        End
69700>>>>>>>>
69700>>>>>>>        Function_Return sVersion
69701>>>>>>>    End_Function
69702>>>>>>>    
69702>>>>>>>    //  Returns the version information of the
69702>>>>>>>    //           Pervasive.SQL Server Engine
69702>>>>>>>    
69702>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
69704>>>>>>>        
69704>>>>>>>        String  sDriverID
69704>>>>>>>        String  sVersion
69704>>>>>>>        String  sVoid
69704>>>>>>>        Integer iRetval
69704>>>>>>>        
69704>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69704>>>>>>>        // This error would otherwise be raised when we have an older
69704>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69704>>>>>>>        Send Ignore_error to Error_object_Id 20491
69705>>>>>>>        Get psDriverID to sDriverID
69706>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69707>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69712>>>>>>>        Send Trap_Error to Error_object_Id 20491
69713>>>>>>>        If (Trim(sVersion) = "") Begin
69715>>>>>>>            // Unable to get the revision. return all zeroes.
69715>>>>>>>            Move "0.0.0" to sVersion
69716>>>>>>>        End
69716>>>>>>>>
69716>>>>>>>        Function_Return sVersion
69717>>>>>>>    End_Function
69718>>>>>>>    
69718>>>>>>>End_Class
69719>>>>>>>
69719>>>>>>>
69719>>>>>Use vWin32fh.pkg
69719>>>>>
69719>>>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
69719>>>>>>>// *** The Database Update Framework Include file for Languages ***
69719>>>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
69719>>>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
69719>>>>>>>//
69719>>>>>>>Use LanguageText.Pkg
69719>>>>>>>
69719>>>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
69719>>>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
69719>>>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
69719>>>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
69719>>>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
69719>>>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
69719>>>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
69719>>>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
69719>>>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
69719>>>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
69719>>>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
69719>>>>>>>    Define CS_DUF_CopyingData               for "Copying data"
69719>>>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
69719>>>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
69719>>>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
69719>>>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
69719>>>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
69719>>>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
69719>>>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
69719>>>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
69719>>>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
69719>>>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
69719>>>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
69719>>>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
69719>>>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
69719>>>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
69719>>>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
69719>>>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
69719>>>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
69719>>>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
69719>>>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
69719>>>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
69719>>>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
69719>>>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
69719>>>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
69719>>>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
69719>>>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
69719>>>>>>>
69719>>>>>>>
69719>>>>>>>
69719>>>>>>>
69719>>>>>>>
69719>>>>>>>
69719>>>>>>>
69719>>>>>>>
69719>>>>>>>
69719>>>>>>>
69719>>>>>>>
69719>>>>>>>
69719>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MertechDUF.pkg)
69719>>>>>>>//
69719>>>>>>>// Use of Mertech drivers:
69719>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
69719>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
69719>>>>>>>//Define DUF_Use_Mertech_Drivers
69719>>>>>>>//
#REM USE MERTECH.INC
69719>>>>>>>    Use Flex2SQLDUF.pkg
Including file: Flex2SQLDUF.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Flex2SQLDUF.pkg)
69719>>>>>>>>>//*************************************************************************
69719>>>>>>>>>//*                                                                       *
69719>>>>>>>>>//*  Confidential Trade Secret.                                           *
69719>>>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
69719>>>>>>>>>//*  All rights reserved.                                                 *
69719>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
69719>>>>>>>>>//*                                                                       *
69719>>>>>>>>>//*  NOTE: This version of Flex2SQL is specially adapted to be used with  *
69719>>>>>>>>>// * the Database Update Framework (DUF)                                  *
69719>>>>>>>>>// *                                                                      *
69719>>>>>>>>>//*************************************************************************
69719>>>>>>>>>Use mertech.inc
Including file: mertech.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mertech.inc)
69719>>>>>>>>>>>//*************************************************************************
69719>>>>>>>>>>>//*                                                                       *
69719>>>>>>>>>>>//*  Confidential Trade Secret.                                           *
69719>>>>>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
69719>>>>>>>>>>>//*  All rights reserved.                                                 *
69719>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
69719>>>>>>>>>>>//*                                                                       *
69719>>>>>>>>>>>//*************************************************************************
69719>>>>>>>>>>>Use UI
69719>>>>>>>>>>>Use SEQ_CHNL.PKG
69719>>>>>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - MERTECH.COM
#REM MERTECH.INC VERSION 3.3.1.5
#REM -----------------------------------------------
69719>>>>>>>>>>>
69719>>>>>>>>>>>Object oMertechInc_Work is an Array  
69721>>>>>>>>>>>    CompilerWarnings Off
69721>>>>>>>>>>>    Property String psWork Public (Repeat("                                ", 512))
69723>>>>>>>>>>>    CompilerWarnings On
69723>>>>>>>>>>>End_Object
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>// #DEFINE's
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_FILE_PRIMARY_KEY                          For (DF_FILE_RECORD_REREAD+1)
69724>>>>>>>>>>>
69724>>>>>>>>>>>// TODO: This is probably deprecated. Investigate.
69724>>>>>>>>>>>Define DF_FILE_NUMBER_INVERSE_KEYS                  For (DF_FILE_RECORD_REREAD+3)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_SET_MODE
69724>>>>>>>>>>>/// @Description Allows switching between set-oriented and record oriented fetch modes.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// If DF_FILE_SET_MODE is set to True, the driver will fetch a set of records
69724>>>>>>>>>>>/// for each find. If DF_FILE_SET_MODE is False, the driver will fetch only one
69724>>>>>>>>>>>/// record at a time. This attribute can also be specified in the .INT file during
69724>>>>>>>>>>>/// migration through Flex2SQL. This settings is normally used alongside
69724>>>>>>>>>>>/// DF_FILE_MAX_ROWS to set the number of rows to return and DF_FILE_CACHE_MODE
69724>>>>>>>>>>>/// to turn on local caching.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Note: Turning off set-mode can have a detrimental impact on performance. Unless
69724>>>>>>>>>>>/// there is a specific reason to do otherwise, this option should be left on.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Default value: True
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
69724>>>>>>>>>>>/// @See DF_FILE_MAX_ROWS DF_FILE_CACHE_MODE
69724>>>>>>>>>>>/// @INTOPT OPTIMIZE {FOR_SET | ONE_ROW}
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Mode for the FileNumber. True for set-mode, False for one-row mode.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Orderhea
69724>>>>>>>>>>>/// Set_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to True
69724>>>>>>>>>>>/// Get_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to boolVar
69724>>>>>>>>>>>///
69724>>>>>>>>>>>Define DF_FILE_SET_MODE                             For (DF_FILE_RECORD_REREAD+5)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_DATABASENAME
69724>>>>>>>>>>>/// @Description Returns a string containing the name of the database where the
69724>>>>>>>>>>>/// table referenced by the passed File Number resides. This is a READ ONLY
69724>>>>>>>>>>>/// attribute. Note that because Oracle doesn't support the concept of multiple
69724>>>>>>>>>>>/// databases on one server, this attribute is not valid for Oracle.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex, PGFlex
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Name of the Database
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Orderhea
69724>>>>>>>>>>>/// Get_Attribute DF_FILE_DATABASENAME of Orderhea.File_Number to strVal
69724>>>>>>>>>>>Define DF_FILE_DATABASENAME                         For (DF_FILE_RECORD_REREAD+6)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_MAX_ROWS
69724>>>>>>>>>>>/// @Description Controls the maximum number of rows retrieved by a Find GT/LT
69724>>>>>>>>>>>/// operation. The driver will automatically retrieve and cache this many rows
69724>>>>>>>>>>>/// for future find GT/LT operations. Setting this property to a very high
69724>>>>>>>>>>>/// value can be inefficient from a UI perspective but may be advisable for
69724>>>>>>>>>>>/// local processing of rows (such as in a batch process).
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Default value: 10
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
69724>>>>>>>>>>>/// @See DF_FILE_SET_MODE DF_FILE_CACHE_MODE
69724>>>>>>>>>>>/// @INTOPT MAX_ROWS_TO_QUERY {integer}
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Attribute Value
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Orderhea
69724>>>>>>>>>>>/// Set_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to 10
69724>>>>>>>>>>>/// Get_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to intVal
69724>>>>>>>>>>>Define DF_FILE_MAX_ROWS                             For (DF_FILE_RECORD_REREAD+7)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_TABLE_NAME
69724>>>>>>>>>>>/// @Description Use this attribute to set or get the name of the SQL table
69724>>>>>>>>>>>/// corresponding to the specified file number. In a restructure operation
69724>>>>>>>>>>>/// this attribute may be used to permanently change the table that a filelist
69724>>>>>>>>>>>/// entry is pointing to.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT DATABASE_NAME {string}
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Name of the SQL Table.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Orderhea
69724>>>>>>>>>>>/// Get_Attribute DF_FILE_TABLE_NAME of Orderhea.File_Number to strVal
69724>>>>>>>>>>>Define DF_FILE_TABLE_NAME                           For (DF_FILE_RECORD_REREAD+8)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_CACHE_MODE
69724>>>>>>>>>>>/// @Description Activates or deactivates the local cache for set-oriented searches.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Through the DF_FILE_CACHE_MODE attribute, we can activate or deactivate the
69724>>>>>>>>>>>/// local cache. When the cache is active in a set-oriented search, a fixed
69724>>>>>>>>>>>/// number of records are pre-fetched and kept in the local cache. If a record
69724>>>>>>>>>>>/// is not found in the local cache, a new set is fetched. The number of records
69724>>>>>>>>>>>/// fetched is controlled via the DF_FILE_MAX_ROWS attribute. Set-mode vs. one-row
69724>>>>>>>>>>>/// mode is controlled via the DF_FILE_SET_MODE attribute.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Note: Turning off the cache can have significant detrimental effects on performance.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Default value: True
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
69724>>>>>>>>>>>/// @See         DF_FILE_MAX_ROWS DF_FILE_SET_MODE
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Mode for FileNumber. True for active. False for inactive.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Orderhea
69724>>>>>>>>>>>/// Set_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to True
69724>>>>>>>>>>>/// Get_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to boolVal
69724>>>>>>>>>>>Define DF_FILE_CACHE_MODE                           For (DF_FILE_RECORD_REREAD+9)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_FILE_STORAGE_BASE                         For (DF_FILE_RECORD_REREAD+10)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_STATIC
69724>>>>>>>>>>>/// @Description Activates or deactivates a special table mode where all rows
69724>>>>>>>>>>>/// from the table are loaded into a local cache. When active, all searches are
69724>>>>>>>>>>>/// done in memory and the actual table is not accessed.  The driver does not allow
69724>>>>>>>>>>>/// editing of a table in static mode.  This is a very useful feature especially
69724>>>>>>>>>>>/// when a table contains configuration or static information used in
69724>>>>>>>>>>>/// calculations, (i.e., Tax Rate tables, etc.) By keeping this table locally
69724>>>>>>>>>>>/// in memory, network round trips are saved resulting in significant
69724>>>>>>>>>>>/// performance improvements. This attribute is also useful for batch
69724>>>>>>>>>>>/// processes that make extensive table IO requests for reading static information.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Note: Because the entire table is loaded into memory, it is inadvisable to use
69724>>>>>>>>>>>/// this on very large tables.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Default value: False
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_STATIC of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Static Mode for FileNumber. True for static. False for dynamic.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Orderhea
69724>>>>>>>>>>>/// Set_Attribute DF_FILE_STATIC of Orderhea.File_Number to True
69724>>>>>>>>>>>/// Get_Attribute DF_FILE_STATIC of Orderhea.File_Number to boolVal
69724>>>>>>>>>>>Define DF_FILE_STATIC                               For (DF_FILE_RECORD_REREAD+11)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_SERVER_NAME
69724>>>>>>>>>>>/// @Description Use this attribute to set or get the name of the database server
69724>>>>>>>>>>>/// corresponding to the specified file number. In a restructure operation
69724>>>>>>>>>>>/// this attribute may be used to permanently change the server that a filelist
69724>>>>>>>>>>>/// entry is pointing to.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT SERVER_NAME {string}
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Name of the database server.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Orderhea
69724>>>>>>>>>>>/// Set_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to "(localdb)\v11.0"
69724>>>>>>>>>>>/// Get_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to strVal
69724>>>>>>>>>>>Define DF_FILE_SERVER_NAME                          For (DF_FILE_RECORD_REREAD+12)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FETCH_FIELD_COUNT
69724>>>>>>>>>>>/// @Description This attribute is used to get the number of fields or columns
69724>>>>>>>>>>>/// in the given table. Note that this is referring to the columns in the SQL
69724>>>>>>>>>>>/// backend and may not necessarily reflect the number of columns in DataFlex.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// This is a readonly attribute.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     MsSQLFlex MySQLFlex
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FETCH_FIELD_COUNT of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Name of the Tablespace.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>
69724>>>>>>>>>>>/// Get_Attribute DF_FETCH_FIELD_COUNT of hFile To "INDXS"
69724>>>>>>>>>>>Define DF_FETCH_FIELD_COUNT                         For (DF_FILE_RECORD_REREAD+13)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_TABLESPACE_NAME
69724>>>>>>>>>>>/// @Description A tablespace is a container of segments (objects that have an
69724>>>>>>>>>>>/// allotted amount of space), i.e. tables and indexes. This attribute is
69724>>>>>>>>>>>/// used to get or set the name of the tablespace being used for the data tables.
69724>>>>>>>>>>>/// To set or get the tablespace name for indexes, use the DF_FILE_INDEXTABLESPACE_NAME
69724>>>>>>>>>>>/// attribute. Setting the tablespace name can only be done during a Structure_Start
69724>>>>>>>>>>>/// (during table creation).  Getting the name, however can be done at
69724>>>>>>>>>>>/// anytime.  Note that when setting the tablespace name, it must be set to an
69724>>>>>>>>>>>/// already existing tablespace, this attribute does not create the tablespace itself.
69724>>>>>>>>>>>/// Even though MYSQL uses tablespaces, this this attribute is only supported
69724>>>>>>>>>>>/// in Oracle and PostgreSQL.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     ORAFlex PGFlex
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
69724>>>>>>>>>>>/// @See         DF_FILE_INDEXTABLESPACE_NAME
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Name of the Tablespace.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>/// move 0 to hFile
69724>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
69724>>>>>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
69724>>>>>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///             // More table creation here
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
69724>>>>>>>>>>>Define DF_FILE_TABLESPACE_NAME                      For (DF_FILE_RECORD_REREAD+14)
69724>>>>>>>>>>>
69724>>>>>>>>>>>// TODO: This is probably deprecated. Investigate.
69724>>>>>>>>>>>Define DF_FETCH_FIELDNUMBER                         For (DF_FILE_RECORD_REREAD+15)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_INDEXTABLESPACE_NAME
69724>>>>>>>>>>>/// @Description This attribute is used to get or set the name of the tablespace
69724>>>>>>>>>>>/// being used for the index segment of a database. For a description of tablespaces,
69724>>>>>>>>>>>/// see the description above for DF_FILE_TABLESPACE_NAME. Similar to the Tablespace
69724>>>>>>>>>>>/// name attribute, setting the index tablespace name can only be done during creation
69724>>>>>>>>>>>/// and must use an already existing tablespace as the variable. This attribute is
69724>>>>>>>>>>>/// only available for Oracle and Postgre.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     ORAFlex PGFlex
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
69724>>>>>>>>>>>/// @See         DF_FILE_TABLESPACE_NAME
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Name of the Tablespace
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>/// move 0 to hFile
69724>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
69724>>>>>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
69724>>>>>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///             // More table creation here
69724>>>>>>>>>>>///             //
69724>>>>>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
69724>>>>>>>>>>>Define DF_FILE_INDEXTABLESPACE_NAME                 For (DF_FILE_RECORD_REREAD+16)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_RETRIEVE_RECNUM
69724>>>>>>>>>>>/// @Description When creating records on a table with RECNUM support, the
69724>>>>>>>>>>>/// record number is returned after creation. When this attribute is false, the newly
69724>>>>>>>>>>>/// created record's RECNUM is not returned from the server. This could result in a
69724>>>>>>>>>>>/// slight performance improvement when many records are being created in a loop.
69724>>>>>>>>>>>/// The optimization, however, is negligible.  Having this attribute set to false can
69724>>>>>>>>>>>/// have detrimental effects if used improperly; i.e. DD-based saves or UI-based
69724>>>>>>>>>>>/// operations. Thus, this should almost always be set to true unless there is a
69724>>>>>>>>>>>/// compelling reason to do otherwise.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Default Value: True
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-31 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Boolean variable. false to not retrieve record number, true otherwise.
69724>>>>>>>>>>>
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// open ORDERHEA
69724>>>>>>>>>>>/// Handle  hFile
69724>>>>>>>>>>>/// Boolean bRetrieve
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Set_Attribute DF_FILE_RETRIEVE_RECNUM of hFile to false
69724>>>>>>>>>>>/// Get_Attribute DF_FILE_RETRIEVE_RECNUM of hFile To bRetrieve
69724>>>>>>>>>>>Define DF_FILE_RETRIEVE_RECNUM                      For (DF_FILE_RECORD_REREAD+17)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_NAME_SPACE
69724>>>>>>>>>>>/// @Description In Postgres, schemas are objects where all the tables,views and indexes
69724>>>>>>>>>>>/// are stored. Separate schemas are used to specify relational data. This attribute is
69724>>>>>>>>>>>/// used to set the name of the schema where a table is created. Schema's do not account
69724>>>>>>>>>>>/// for any physical space but are merely used as theory to explain the order of a database.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     PGFlex
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Name of the Schema
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// open ORDERHEA
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>/// String sSchemaName
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Set_Attribute DF_FILE_NAME_SPACE of hFile to "ORDERHEA"
69724>>>>>>>>>>>/// Get_Attribute DF_FILE_NAME_SPACE of hFile To sSchemaName
69724>>>>>>>>>>>Define DF_FILE_NAME_SPACE                           For (DF_FILE_RECORD_REREAD+18)
69724>>>>>>>>>>>
69724>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
69724>>>>>>>>>>>Define DF_FILE_STORAGE_PCTFREE                      For (DF_FILE_RECORD_REREAD+19)
69724>>>>>>>>>>>
69724>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
69724>>>>>>>>>>>Define DF_FILE_STORAGE_PCTUSED                      For (DF_FILE_RECORD_REREAD+21)
69724>>>>>>>>>>>
69724>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
69724>>>>>>>>>>>Define DF_FILE_STORAGE_INITIAL                      For (DF_FILE_RECORD_REREAD+23)
69724>>>>>>>>>>>
69724>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
69724>>>>>>>>>>>Define DF_FILE_STORAGE_NEXT                         For (DF_FILE_RECORD_REREAD+25)
69724>>>>>>>>>>>
69724>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
69724>>>>>>>>>>>Define DF_FILE_ALLOW_NULL                           For (DF_FILE_RECORD_REREAD+27)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_GET_SERVERNAME_FROM_LOGIN
69724>>>>>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will
69724>>>>>>>>>>>/// be included in the INT file.  If set to True, the SERVER_NAME option will not
69724>>>>>>>>>>>/// be included in the INT file, if set to false, the SERVER_NAME option will be
69724>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
69724>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
69724>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
69724>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
69724>>>>>>>>>>>/// setting it to true will NOT include the SERVER_NAME in the INT file.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Default Value: False
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Deprecated
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
69724>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
69724>>>>>>>>>>>/// @INTOPT              SERVER_NAME
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of Customer.File_Number to True
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Close Customer
69724>>>>>>>>>>>Define DF_FILE_GET_SERVERNAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+29)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
69724>>>>>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will be included
69724>>>>>>>>>>>/// in the INT file.  If set to True, the server name will not be included in the INT file,
69724>>>>>>>>>>>/// if set to false, the server name will be included in the INT file. This has two uses.
69724>>>>>>>>>>>/// The first is during a Structure_Start i.e. table creation/modification. The other is
69724>>>>>>>>>>>/// when using the OUTPUT_INT_FILE command. Set this attribute before the OUTPUT_INT_FILE
69724>>>>>>>>>>>/// to indicate how the INT file will be written.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Default Value: False
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
69724>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
69724>>>>>>>>>>>/// @INTOPT              SERVER_NAME
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///   Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of Customer.File_Number to True
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///   OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Close Customer
69724>>>>>>>>>>>Define DF_FILE_SUPPRESS_SERVERNAME_OUTPUT                       For DF_FILE_GET_SERVERNAME_FROM_LOGIN
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_GET_DATABASENAME_FROM_LOGIN
69724>>>>>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
69724>>>>>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
69724>>>>>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
69724>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
69724>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
69724>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
69724>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
69724>>>>>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Default Value: False
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Deprecated
69724>>>>>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
69724>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
69724>>>>>>>>>>>/// @INTOPT              DATABASE_NAME
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of Customer.File_Number to True
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Close Customer
69724>>>>>>>>>>>Define DF_FILE_GET_DATABASENAME_FROM_LOGIN          For (DF_FILE_RECORD_REREAD+31)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
69724>>>>>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
69724>>>>>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
69724>>>>>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
69724>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
69724>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
69724>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
69724>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
69724>>>>>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Default Value: False
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
69724>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
69724>>>>>>>>>>>/// @INTOPT              DATABASE_NAME
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of Customer.File_Number to True
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Close Customer
69724>>>>>>>>>>>Define DF_FILE_SUPPRESS_DATABASENAME_OUTPUT                     For DF_FILE_GET_DATABASENAME_FROM_LOGIN
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_GET_SCHEMANAME_FROM_LOGIN
69724>>>>>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
69724>>>>>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
69724>>>>>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
69724>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
69724>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
69724>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
69724>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
69724>>>>>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Default Value: False
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Deprecated
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
69724>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
69724>>>>>>>>>>>/// @INTOPT              SCHEMA_NAME
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of Customer.File_Number to True
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Close Customer
69724>>>>>>>>>>>Define DF_FILE_GET_SCHEMANAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+33)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
69724>>>>>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
69724>>>>>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
69724>>>>>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
69724>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
69724>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
69724>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
69724>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
69724>>>>>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Default Value: False
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
69724>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
69724>>>>>>>>>>>/// @INTOPT              SCHEMA_NAME
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of Customer.File_Number to True
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Close Customer
69724>>>>>>>>>>>Define DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT           For DF_FILE_GET_SCHEMANAME_FROM_LOGIN
69724>>>>>>>>>>>
69724>>>>>>>>>>>//TODO
69724>>>>>>>>>>>Define DF_FILE_PRESERVE_RECNUM                      For 184
69724>>>>>>>>>>>
69724>>>>>>>>>>>// Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_FILE_NATIVE_RECORD_LENGTH                 For 194
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_OEM_TRANSLATION
69724>>>>>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
69724>>>>>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
69724>>>>>>>>>>>/// code pages. When migrating data, this attribute is used to determine whether
69724>>>>>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
69724>>>>>>>>>>>/// migrating passwords with special characters may call for different code pages.
69724>>>>>>>>>>>/// Setting this attribute to true will convert the OEM data to ANSI, setting it
69724>>>>>>>>>>>/// to false will not.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Indicates if OEM data will be converted to ANSI. True converts it, false does not.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>/// Boolean bTranslate
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Move Customer.File_Number to hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Structure_Start hFile
69724>>>>>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
69724>>>>>>>>>>>///     Get_Attribute DF_FILE_OEM_TRANSLATION of hFile to bTranslate
69724>>>>>>>>>>>/// Structure_End hFile
69724>>>>>>>>>>>Define DF_FILE_OEM_TRANSLATION                      For (DF_FILE_RECORD_REREAD+51)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_EPOCH_YEAR
69724>>>>>>>>>>>/// @Description When dealing with two-digit years, an epoch year must be used
69724>>>>>>>>>>>/// to determine which century the date is referring to. For example if the
69724>>>>>>>>>>>/// epoch year is set to 30, then any two digit year greater than 30 will be
69724>>>>>>>>>>>/// considered in the 20th Century, anything less than or equal to 30 will be
69724>>>>>>>>>>>/// considered in the 21st Century.  This attribute is used to turn on or off
69724>>>>>>>>>>>/// this feature. To use this feature, set this attribute to whatever the epoch
69724>>>>>>>>>>>/// year is expected to be. To disable this feature, set this attribute to 0
69724>>>>>>>>>>>/// or false. Note that setting this attribute must be done at table creation
69724>>>>>>>>>>>/// or inside of a Structure_Start.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT      EPOCH_YEAR
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Indicates what the epoch year is. 0 to disable
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>/// Boolean bEpoch
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Move Customer.File_Number to hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Structure_Start hFile
69724>>>>>>>>>>>///     Set_Attribute DF_FILE_EPOCH_YEAR of hFile to 30
69724>>>>>>>>>>>///     Get_Attribute DF_FILE_EPOCH_YEAR of hFile to bEpoch
69724>>>>>>>>>>>/// Structure_End hFile
69724>>>>>>>>>>>Define DF_FILE_EPOCH_YEAR                           For (DF_FILE_RECORD_REREAD+53)
69724>>>>>>>>>>>
69724>>>>>>>>>>>Define DF_FILE_USE_ROWCOUNT_IN_TRANSACTIONS         For 628
69724>>>>>>>>>>>Define DF_FILE_ICF_STATUS                           For 630
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_LOCK_RECORD_STATUS
69724>>>>>>>>>>>/// @Description Table locking is done during transactions to maintain atomicity.
69724>>>>>>>>>>>/// In DataFlex, this is usually done with the REREAD/UNLOCK commands. This
69724>>>>>>>>>>>/// attribute is used to get the status of a table lock. If a table is currently
69724>>>>>>>>>>>/// in a REREAD, or locked, then the attribute will return true. Otherwise, it
69724>>>>>>>>>>>/// returns false. It is a read-only attribute so no setting can be done.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_LOCK_RECORD_STATUS of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Indicates the status of the file lock
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// open Customer
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>/// Integer bLocked
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Move Customer.File_Number to hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Get_Attribute DF_FILE_LOCK_RECORD_STATUS of hFile to bLocked
69724>>>>>>>>>>>Define DF_FILE_LOCK_RECORD_STATUS                   For 632
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_CASING
69724>>>>>>>>>>>/// @Description Controls the filename and column name casing.
69724>>>>>>>>>>>/// You can set this to either keep the file case, force to lower case or force
69724>>>>>>>>>>>/// to uppercase.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_CASING of {FileNumber} to {FILE_CASING_KEEP|FILE_CASING_LOWER|FILE_CASING_UPPER}
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_CASING of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber          Number of the file
69724>>>>>>>>>>>/// @Param  variable              integer set to one of the above values.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// open Customer
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>/// Integer eCasing
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Move Customer.File_Number to hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
69724>>>>>>>>>>>///    Set_Attribute DF_FILE_CASING of hFile to FILE_CASING_KEEP
69724>>>>>>>>>>>/// Structure_End hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Get_Attribute DF_FILE_CASING of hFile to eCasing
69724>>>>>>>>>>>
69724>>>>>>>>>>>
69724>>>>>>>>>>>Define DF_FILE_CASING                               For 634
69724>>>>>>>>>>>
69724>>>>>>>>>>>Define DF_FIELD_INVERSE_KEY_NAME                    For (DF_FIELD_NATIVE_LENGTH+1)
69724>>>>>>>>>>>Define DF_FIELD_INVERSE_KEY_TYPE                    For (DF_FIELD_NATIVE_LENGTH+2)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//TODO
69724>>>>>>>>>>>Define DF_FIELD_TEXT_SEGMENT_NAME                   For (DF_FIELD_NATIVE_LENGTH+3)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//TODO
69724>>>>>>>>>>>Define DF_FIELD_TEXT_NUM_SEGMENTS                   For (DF_FIELD_NATIVE_LENGTH+4)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FIELD_DEFAULT_VALUE
69724>>>>>>>>>>>/// @Description Use this attribute to get or set the default value for a given column.
69724>>>>>>>>>>>/// Setting the default value can only be done during a structure_start or during table
69724>>>>>>>>>>>/// creation. If this attribute is not set, it is defaulted to the driver default.
69724>>>>>>>>>>>/// See Mertech.cfg
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  FieldNumber           Number of the field
69724>>>>>>>>>>>/// @Param  variable              Variable for the default value of the field
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// open Customer
69724>>>>>>>>>>>/// String sDefault
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>/// Integer iColumn
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Move "California" to sDefault
69724>>>>>>>>>>>/// Move Customer.File_Number to hFile
69724>>>>>>>>>>>/// Move 3 to iColumn
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
69724>>>>>>>>>>>///    Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
69724>>>>>>>>>>>/// Structure_End hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Get_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
69724>>>>>>>>>>>Define DF_FIELD_DEFAULT_VALUE                       For (DF_FIELD_NATIVE_LENGTH+5)
69724>>>>>>>>>>>
69724>>>>>>>>>>>// Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_FIELD_TEXT_LENGTH_SEGMENT                 For (DF_FIELD_NATIVE_LENGTH+6)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//TODO
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FIELD_TIME_ON
69724>>>>>>>>>>>/// @Description Assign a field to retrieve Time Stamp value from a DATETIME
69724>>>>>>>>>>>/// column in a table.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// This option was implemented because some versions of DataFlex do not support
69724>>>>>>>>>>>/// DATETIME fields normally supported by SQL databases.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// To use this: Change the type of a date field in your FD to string type,
69724>>>>>>>>>>>/// Set the attribute DF_FIELD_TIME_ON of this field to TRUE and
69724>>>>>>>>>>>/// recompile your program.
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_TIME_ON of <FileNumber|FileName FieldNumber> to DFTRUE | DFFALSE
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  FileName              Name of the file
69724>>>>>>>>>>>/// @Param  FieldNumber           Number of the field
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// #INCLUDE MERTECH.INC
69724>>>>>>>>>>>/// string sDateTime sDatabaseName
69724>>>>>>>>>>>/// open ORDERHEA
69724>>>>>>>>>>>/// Set_Attribute DF_FIELD_TIME_ON of 30 3 to dfTrue
69724>>>>>>>>>>>/// find GE ORDERHEA by recnum
69724>>>>>>>>>>>/// move ORDERHEA.ORDER_DATE to sDateTime
69724>>>>>>>>>>>/// showln "sDateTime: " sDateTime
69724>>>>>>>>>>>Define DF_FIELD_TIME_ON                             For (DF_FIELD_NATIVE_LENGTH+8)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FIELD_NATIVE_NAME
69724>>>>>>>>>>>/// @Description This attribute is used to get the name of the desired column
69724>>>>>>>>>>>/// on the SQL backend. Currently this attribute is ReadOnly and so setting
69724>>>>>>>>>>>/// or modifying a column name cannot be done using this attribute.  In most
69724>>>>>>>>>>>/// cases, the field name on the SQL backend will be the same as the Dataflex name.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// This is a ReadOnly attribute.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_NAME of {FileNumber} {FieldNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber          Number of the file
69724>>>>>>>>>>>/// @Param  FieldNumber                 Number of the Field
69724>>>>>>>>>>>/// @Param  variable                    String containing the name of the field
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// String sName
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Get_Attribute DF_FIELD_NATIVE_NAME of Customer.File_Number 3 to sName
69724>>>>>>>>>>>Define DF_FIELD_NATIVE_NAME                         For (DF_FIELD_NATIVE_LENGTH+9)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FIELD_NULL
69724>>>>>>>>>>>/// @Description Use this attribute to get or set whether a column in a table will
69724>>>>>>>>>>>/// allow null values. When set to true, the column accepts null values. Setting
69724>>>>>>>>>>>/// this attribute to false will keep it from accepting null values. Although,
69724>>>>>>>>>>>/// getting the value of this attribute can be done at anytime, setting it must
69724>>>>>>>>>>>/// be done in a Structure_Start or during table creation.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber          Number of the file
69724>>>>>>>>>>>/// @Param  FieldNumber                 Number of the Field
69724>>>>>>>>>>>/// @Param  variable                    Boolean variable
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>/// Integer iColumn
69724>>>>>>>>>>>/// Boolean bAllowNull
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Move Customer.File_Number to hFile
69724>>>>>>>>>>>/// Move 3 to iColumn
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
69724>>>>>>>>>>>///    Set_Attribute DF_FIELD_NULL of hFile iColumn to True
69724>>>>>>>>>>>/// Structure_End hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Get_Attribute DF_FIELD_NULL of hFile iColumn to bAllowNull
69724>>>>>>>>>>>Define DF_FIELD_NULL                                For (DF_FIELD_NATIVE_LENGTH+10)
69724>>>>>>>>>>>
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FIELD_NATIVE_TYPE
69724>>>>>>>>>>>/// @Description Use this attribute to get or set the Native type for a specific
69724>>>>>>>>>>>/// field in a table.  The native type refers to the data type of the field on the
69724>>>>>>>>>>>/// SQL backend. Setting this attribute can only be done during table creation or
69724>>>>>>>>>>>/// inside of a Structure_Start. When setting this attribute, it is good practice
69724>>>>>>>>>>>/// to use the constants mentioned below instead of the integers. For a list of
69724>>>>>>>>>>>/// these constants, refer to the sections: "Oracle Data Types", "MySQL Data Types",
69724>>>>>>>>>>>/// "PostgreSQL Data Types", and "SQL Server Data Types" included in this document.
69724>>>>>>>>>>>/// Note that when getting the value for this attribute, an integer will be returned
69724>>>>>>>>>>>/// so these lists of constants can again prove useful.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT      FIELD_TYPE
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber          Number of the file
69724>>>>>>>>>>>/// @Param  FieldNumber         Number of the field
69724>>>>>>>>>>>/// @Param  variable                    variable for the native data type
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Integer iColumn iType
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Move Customer.File_Number to hFile
69724>>>>>>>>>>>/// Structure_Start hFile
69724>>>>>>>>>>>///     Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to "eSQLServer_DATE"
69724>>>>>>>>>>>///     Get_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iType
69724>>>>>>>>>>>///     Structure_End hFile
69724>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE                         For (DF_FIELD_NATIVE_LENGTH+12)
69724>>>>>>>>>>>
69724>>>>>>>>>>>// Currently Unsupported Attribute (readOnly used by DataFlex 18.0 Studio)
69724>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE_NAME                    For 711
69724>>>>>>>>>>>
69724>>>>>>>>>>>// Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_FIELD_NATIVE_OFFSET                       For (DF_FIELD_NATIVE_LENGTH+14)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FIELD_AUTO_INCREMENT
69724>>>>>>>>>>>/// @Description Auto incrementing is a technique used in Dataflex usually for
69724>>>>>>>>>>>/// fields that are set as the unique identifier. Instead of generating a value
69724>>>>>>>>>>>/// or manually inserting data into the column, when a field auto increments,
69724>>>>>>>>>>>/// the value of the field increases by one (usually) with each record.  This
69724>>>>>>>>>>>/// field is used to get or set whether the field uses this technique or not.
69724>>>>>>>>>>>/// The attribute, however, can only be set inside of a Structure_Start or during
69724>>>>>>>>>>>/// table creation. Getting the attribute's value can be done at anytime. The
69724>>>>>>>>>>>/// value is stored as a boolean, either true or false.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT      FIELD_AUTOINCREMENT_TYPE
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber          Number of the file
69724>>>>>>>>>>>/// @Param  FieldNumber         Number of the field
69724>>>>>>>>>>>/// @Param  variable                    Boolean variable indicating if the field auto increments.
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Integer iColumn
69724>>>>>>>>>>>/// Boolean bIncrement
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Move Customer.File_Number to hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Structure_Start hFile
69724>>>>>>>>>>>///     Set_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to True
69724>>>>>>>>>>>///     Get_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to bIncrement
69724>>>>>>>>>>>///     Structure_End hFile
69724>>>>>>>>>>>Define DF_FIELD_AUTO_INCREMENT                      For (DF_FIELD_NATIVE_LENGTH+16)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_FIELD_GENERATE_ALWAYS                     For (DF_FIELD_NATIVE_LENGTH+18)
69724>>>>>>>>>>>
69724>>>>>>>>>>>// Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_FIELD_SEND_LONG_DATA                      For 702
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_INDEX_NATIVE_CREATED
69724>>>>>>>>>>>/// @Description Use this attribute to verify if the index that maps to the DataFlex
69724>>>>>>>>>>>/// index was created correctly at the SQL backend
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// This is a ReadOnly attribute
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Wil van Antwerpen
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NATIVE_CREATED of {FileNumber} {IndexNumber} to variable
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  IndexNumber           Number of the index
69724>>>>>>>>>>>/// @Param  variable              True if created, false if not
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Handle  hFile
69724>>>>>>>>>>>/// Integer iIndex
69724>>>>>>>>>>>/// Boolean bCreated
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Move Customer.File_Number to hFile
69724>>>>>>>>>>>/// Move 1 To iIndex
69724>>>>>>>>>>>/// Get_Attribute DF_INDEX_NATIVE_CREATED of hFile iIndex to bCreated
69724>>>>>>>>>>>Define DF_INDEX_NATIVE_CREATED                      For (DF_INDEX_KEY_LENGTH+1)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_INDEX_NAME
69724>>>>>>>>>>>/// @Description Use this attribute to get the name of the index on the SQL backend
69724>>>>>>>>>>>/// that maps to the numbered index in Dataflex.  This is because, unlike Dataflex,
69724>>>>>>>>>>>/// all indexes in SQL are stored as names, not numbers. Since this attribute is
69724>>>>>>>>>>>/// currently only a ReadOnly attribute, it can not be used to set or modify a named
69724>>>>>>>>>>>/// index.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// This is a ReadOnly attribute
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NAME of {FileNumber} {IndexNumber} to variable
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  IndexNumber           Number of the index
69724>>>>>>>>>>>/// @Param  variable              Name of the index
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Integer iFile iIndex iIndexes
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Open Orderhea
69724>>>>>>>>>>>/// Move Orderhea.File_Number to iFile
69724>>>>>>>>>>>/// Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iIndexes
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// For iIndex From 0 to iIndexes
69724>>>>>>>>>>>///     Get_Attribute DF_INDEX_NAME of iFile iIndex to sIndexName
69724>>>>>>>>>>>///     Showln "Orderhea.Index." iIndex " : " sIndexName
69724>>>>>>>>>>>/// Loop
69724>>>>>>>>>>>Define DF_INDEX_NAME                                For (DF_INDEX_KEY_LENGTH+2)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_PRIMARY_KEY
69724>>>>>>>>>>>/// @Description This attribute is used to get or set the index number
69724>>>>>>>>>>>/// being used for the primary key. Getting the index number can be
69724>>>>>>>>>>>/// done at any time, but setting the index must be during a
69724>>>>>>>>>>>/// Structure_Start or during table creation.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Deprecated
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
69724>>>>>>>>>>>/// @See                 DF_INDEX_PRIMARY_KEY
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Index number being used with primary key
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Integer iKey
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Move Customer.File_Number to hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Structure_Start hFile
69724>>>>>>>>>>>///     Set_Attribute DF_PRIMARY_KEY of hFile to 2
69724>>>>>>>>>>>///     Get_Attribute DF_PRIMARY_KEY of hFile to iKey
69724>>>>>>>>>>>/// Structure_End hFile
69724>>>>>>>>>>>Define DF_PRIMARY_KEY                               For (DF_INDEX_KEY_LENGTH+3)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_INDEX_PRIMARY_KEY
69724>>>>>>>>>>>/// @Description This attribute is used to get or set the index number
69724>>>>>>>>>>>/// being used for the primary key. Getting the index number can be
69724>>>>>>>>>>>/// done at any time, but setting the index must be during a
69724>>>>>>>>>>>/// Structure_Start or during table creation.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT              PRIMARY_KEY
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Index number being used with primary key
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Integer iKey
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Move Customer.File_Number to hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Structure_Start hFile
69724>>>>>>>>>>>///     Set_Attribute DF_INDEX_PRIMARY_KEY of hFile to 2
69724>>>>>>>>>>>///     Get_Attribute DF_INDEX_PRIMARY_KEY of hFile to iKey
69724>>>>>>>>>>>/// Structure_End hFile
69724>>>>>>>>>>>Define DF_INDEX_PRIMARY_KEY                         For (DF_INDEX_KEY_LENGTH+3)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_INDEX_STATUS
69724>>>>>>>>>>>/// @Description Oracle has an attribute for indexes called "STATUS" which indicates
69724>>>>>>>>>>>/// whether or not an index is valid for use. This attribute can only be used to get
69724>>>>>>>>>>>/// the value of the "STATUS" property in Oracle. It currently does not support setting
69724>>>>>>>>>>>/// the attribute. The two values for this attribute are "VALID" or "UNUSABLE".
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// This is a ReadOnly attribute
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     ORAFlex
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_STATUS of {FileNumber} {IndexNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  FieldNumber           Number of the index
69724>>>>>>>>>>>/// @Param  variable              String indicating validity
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// String sIndexStatus
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Get_Attribute DF_INDEX_STATUS of Customer.File_Number 1 to sIndexStatus
69724>>>>>>>>>>>Define DF_INDEX_STATUS                              For (DF_INDEX_KEY_LENGTH+4)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_INDEX_STORAGE_PCTFREE                     For (DF_INDEX_KEY_LENGTH+5)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_INDEX_UNIQUE
69724>>>>>>>>>>>/// @Description An index on a column that is unique is considered so if it
69724>>>>>>>>>>>/// does not have two equal values in that column in two different rows. This
69724>>>>>>>>>>>/// attribute is used to find out whether or not the specified index is unique.
69724>>>>>>>>>>>/// If it is, this attribute will return "U" indicating that it is indeed unique.
69724>>>>>>>>>>>/// This is important to note because when getting the value of this attribute,
69724>>>>>>>>>>>/// a string variable must be used. Since this is a ReadOnly attribute, setting
69724>>>>>>>>>>>/// an idex to unique cannot be done with this attribute.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_UNIQUE of {FileNumber} {IndexNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  FieldNumber           Number of the index
69724>>>>>>>>>>>/// @Param  variable              String indicating if unique
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// String sIndexUnique
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Get_Attribute DF_INDEX_UNIQUE of Customer.File_Number 1 to sIndexUnique
69724>>>>>>>>>>>Define DF_INDEX_UNIQUE                              For (DF_INDEX_KEY_LENGTH+6)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_INDEX_STORAGE_BASE                        For (DF_INDEX_KEY_LENGTH+7)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_INDEX_STORAGE_INITIAL                     For (DF_INDEX_KEY_LENGTH+8)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_INDEX_STORAGE_NEXT                        For (DF_INDEX_KEY_LENGTH+10)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_INDEX_NATIVE_TYPE                         For (DF_INDEX_KEY_LENGTH+13)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//TODO
69724>>>>>>>>>>>Define DF_INDEX_TABLESPACE                          For (DF_INDEX_KEY_LENGTH+14)
69724>>>>>>>>>>>
69724>>>>>>>>>>>//TODO
69724>>>>>>>>>>>Define DF_FIELD_PROGRAMMATIC_DEFAULT                For 701
69724>>>>>>>>>>>Define DF_FIELD_TIME                                For 703
69724>>>>>>>>>>>Define DF_FIELD_IS_NULL                             For 704
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FIELD_IS_LOB
69724>>>>>>>>>>>/// @Description In databases a LOB data type is any type that is considered
69724>>>>>>>>>>>/// a "Large Object" i.e. XML types, Binary types etc.  This attribute is a
69724>>>>>>>>>>>/// ReadOnly attribute used to indicate whether the given field is considered
69724>>>>>>>>>>>/// a LOB data type. Since it is ReadOnly, this attribute cannot set a field
69724>>>>>>>>>>>/// to a LOB data type.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_IS_LOB of {FileNumber} {FieldNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param      FieldNumber                       Number of the field
69724>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if LOB
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Boolean bIsLOB
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Get_Attribute DF_FIELD_IS_LOB of Customer.File_Number 6 to bIsLOB
69724>>>>>>>>>>>Define DF_FIELD_IS_LOB                              For 706
69724>>>>>>>>>>>Define DF_FIELD_DEFAULT_FUNCTION                    For 707
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_FIELD_HANDLE_AS_LOB                       For 708
69724>>>>>>>>>>>
69724>>>>>>>>>>>//TODO
69724>>>>>>>>>>>Define DF_FIELD_PARTIAL_OVERLAP                     For 710
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_NUMBER_SQL_RELATIONS
69724>>>>>>>>>>>/// @Description This attribute is used to get the number of foreign keys
69724>>>>>>>>>>>/// for a given table on the SQL backend. Foreign keys are used to specify
69724>>>>>>>>>>>/// relationships between tables. Since this attribute is ReadOnly, it cannot
69724>>>>>>>>>>>/// be used to set the number of foreign keys in a table.  Note that this
69724>>>>>>>>>>>/// attribute returns only the number of foreign keys, no other information
69724>>>>>>>>>>>/// is provided with this attribute.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// This is a ReadOnly attribute
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
69724>>>>>>>>>>>/// @See
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Integer variable showing number of relationships
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Integer iRelations
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of Customer.File_Number to iRelations
69724>>>>>>>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS                 For 626
69724>>>>>>>>>>>
69724>>>>>>>>>>>//TODO
69724>>>>>>>>>>>Define DF_SQL_RELATION_COLUMN                       For 716
69724>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA               For 717
69724>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_TABLE                For 719
69724>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_COLUMN               For 721
69724>>>>>>>>>>>Define DF_SQL_RELATION_NAME                         For 723
69724>>>>>>>>>>>Define DF_SQL_RELATION_STATUS                       For 724
69724>>>>>>>>>>>Define DF_SQL_RELATION_DELETE_REF_ACTION            For 726
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_FIELD_OVERLAP_START                       For 728
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_FIELD_OVERLAP_END                         For 730
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_START                For 732
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Currently Unsupported Attribute
69724>>>>>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_END                  For 734
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_RECNUM_TABLE
69724>>>>>>>>>>>/// @Description Dataflex's embedded database, by default, uses a Recnum column
69724>>>>>>>>>>>/// as the unique identifier for a table instead of a primary key. A table can
69724>>>>>>>>>>>/// easily be changed to use another column though and this attribute gets or
69724>>>>>>>>>>>/// sets whether the Recnum is being used for a table. Getting the value of this
69724>>>>>>>>>>>/// attribute can be done at any time for any driver. The setting of this attribute,
69724>>>>>>>>>>>/// however, can only be done in certain situations. Only if an alternative primary
69724>>>>>>>>>>>/// key is set up already can this attribute be set to false and only during a
69724>>>>>>>>>>>/// Structure_Start. Also, the attribute can only be turned off (set to false),
69724>>>>>>>>>>>/// it can not be turned back on (set to True).
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Note: In Postgres, this attribute is a ReadOnly attribute and can not be set.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public (PGFlex ReadOnly)
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
69724>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_NAME DF_FILE_PRIMARY_INDEX
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if recnum is used
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Boolean bRecnum
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Move Customer.File_Number to hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Structure_Start hFile
69724>>>>>>>>>>>///     Set_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to False
69724>>>>>>>>>>>///     Get_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to bRecnum
69724>>>>>>>>>>>/// Structure_End hFile
69724>>>>>>>>>>>Define DF_FILE_RECNUM_TABLE                         For 1401
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_PRIMARY_INDEX
69724>>>>>>>>>>>/// @Description This attribute gets or sets the index which is used as the
69724>>>>>>>>>>>/// primary key for a table. The variable used for this attribute is an integer
69724>>>>>>>>>>>/// containing the numbered index used. Getting the value of this attribute can
69724>>>>>>>>>>>/// be done at any time, whereas setting can only be done at table creation or
69724>>>>>>>>>>>/// during a Structure_Start. If a RECNUM is used as the unique identifier then
69724>>>>>>>>>>>/// 0 is returned.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Note: In Postgres this attribute is ReadOnly, so it can only be used to get
69724>>>>>>>>>>>/// the index used as the primary key.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public (PGFlex ReadOnly)
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
69724>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_NAME
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if a primary key is used
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Boolean bPrimary
69724>>>>>>>>>>>/// Handle hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Move Customer.File_Number to hFile
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Structure_Start hFile
69724>>>>>>>>>>>///     Set_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to False
69724>>>>>>>>>>>///     Get_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to bPrimary
69724>>>>>>>>>>>/// Structure_End hFile
69724>>>>>>>>>>>Define DF_FILE_PRIMARY_INDEX                        For 1402
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>/// @Name        DF_FILE_RECNUM_NAME
69724>>>>>>>>>>>/// @Description This attribute is used to get the name of the Recnum field
69724>>>>>>>>>>>/// in the table, if one exists. It is a ReadOnly attribute so it can only
69724>>>>>>>>>>>/// be used in getting the name of the recnum field to a string variable.
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Assumptions
69724>>>>>>>>>>>/// @Status      Public
69724>>>>>>>>>>>/// @Drivers     All
69724>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
69724>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_TABLE
69724>>>>>>>>>>>/// @INTOPT
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_NAME of {FileNumber} to {variable}
69724>>>>>>>>>>>/// @Param  FileNumber            Number of the file
69724>>>>>>>>>>>/// @Param  variable              String name of recnum field
69724>>>>>>>>>>>/// @Example
69724>>>>>>>>>>>/// Open Customer
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// String sRecnum
69724>>>>>>>>>>>///
69724>>>>>>>>>>>/// Get_Attribute DF_FILE_RECNUM_NAME of Customer.File_Number to sRecnum
69724>>>>>>>>>>>Define DF_FILE_RECNUM_NAME                          For 1403
69724>>>>>>>>>>>
69724>>>>>>>>>>>Define DF_FETCH_ALL                                 For -1
69724>>>>>>>>>>>Define DF_FETCH_TRUE                                For "TRUE"
69724>>>>>>>>>>>Define DF_FETCH_FALSE                               For "FALSE"
69724>>>>>>>>>>>Define DF_BIND_ALL_COLUMNS                          For -1
69724>>>>>>>>>>>
69724>>>>>>>>>>>// SQLFlex Lock Type
69724>>>>>>>>>>>Define DF_LOCK_TYPE_PAGE                            For 3
69724>>>>>>>>>>>
69724>>>>>>>>>>>// Extended Callback Types
69724>>>>>>>>>>>Define DF_MESSAGE_ERROR                             For 9
69724>>>>>>>>>>>Define DF_MESSAGE_PROGRESS_STATUS                   For 20
69724>>>>>>>>>>>Define DF_MESSAGE_PROGRESS_CONTINUE                 For 21
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Drivers
69724>>>>>>>>>>>Define ORAFLEX                                      For "ORA_DRV"
69724>>>>>>>>>>>Define SQLFLEX                                      For "SQL_DRV"
69724>>>>>>>>>>>Define MDSDB2                                       For "MDS_DB2"
69724>>>>>>>>>>>Define MDSPgSQL                                     For "MDSPGSQL"
69724>>>>>>>>>>>Define PgFlex                                       For "MDSPGSQL"
69724>>>>>>>>>>>Define MDSMySQL                                     For "MDSMYSQL"
69724>>>>>>>>>>>Define MySQLFlex                                    For "MDSMYSQL"
69724>>>>>>>>>>>
69724>>>>>>>>>>>// Delimiter for SQL ID objects
69724>>>>>>>>>>>Define DB2_ID_DELIM                                 For '"'
69724>>>>>>>>>>>Define MYSQL_ID_DELIM                               For "`"
69724>>>>>>>>>>>Define ORACLE_ID_DELIM                              For '"'
69724>>>>>>>>>>>Define PGSQL_ID_DELIM                               For '"'
69724>>>>>>>>>>>Define SQLSERVER_ID_DELIM                           For '"'
69724>>>>>>>>>>>
69724>>>>>>>>>>>// dfStructureEnd Option bits
69724>>>>>>>>>>>Define DF_STRUCTEND_OPT_INDEX_ONLY                  For 16    // Internal Use Only
69724>>>>>>>>>>>Define DF_STRUCTEND_OPT_FORCE_INVK                  For 32
69724>>>>>>>>>>>Define DF_STRUCTEND_OPT_OLD_INVK_NAME               For 64
69724>>>>>>>>>>>Define DF_STRUCTEND_OPT_FORCE_NOT_NULL              For 128
69724>>>>>>>>>>>Define DF_STRUCTEND_OPT_CREATE_ROWID_TABLE          For 256
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Additional Data Types
69724>>>>>>>>>>>Define DF_DATETIME                                  For 7
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Call_Driver Functions
69724>>>>>>>>>>>Define CALLDRV_LICENSE_ENVIRONMENT_SET              For 0
69724>>>>>>>>>>>Define CALLDRV_ORA_CURRENT_SQL_SERVER               For 6
69724>>>>>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE                    For 14
69724>>>>>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER                   for 19
69724>>>>>>>>>>>Define CALLDRV_SQL_NEXT_RESULTSET                   for ((22 * (2^16)) + 11)
69724>>>>>>>>>>>Define CALLDRV_BIND_PARAMETER                       for 23
69724>>>>>>>>>>>Define CALLDRV_SQL_MAX_CURSORS                      For 26
69724>>>>>>>>>>>Define CALLDRV_SQLLOADER_FIELDS_TERM                For 30
69724>>>>>>>>>>>Define CALLDRV_CREATE_TABLE_FROM_DAT                For 30
69724>>>>>>>>>>>Define CALLDRV_SQLLOADER_DECIMAL_SEP                For 31
69724>>>>>>>>>>>Define CALLDRV_CONVERT_DAT_FILE                     For 32
69724>>>>>>>>>>>Define CALLDRV_SQLFLEX_MAX_CURSORS                  For 37
69724>>>>>>>>>>>Define CALLDRV_NATIVE_OPTIMIZATION                  For 38
69724>>>>>>>>>>>Define CALLDRV_GET_RETURNED_COLUMNS                 For 39
69724>>>>>>>>>>>Define CALLDRV_GET_RETURNED_ROWS                    For 40
69724>>>>>>>>>>>Define CALLDRV_GET_COLUMN_ATTRIBUTE                 For 41
69724>>>>>>>>>>>Define CALLDRV_START_TXTGEN_AFTER_RECNUM            For 42
69724>>>>>>>>>>>Define CALLDRV_FINISH_TXTGEN_AFTER_RECNUM           For 43
69724>>>>>>>>>>>Define CALLDRV_SET_ISOLATION_LEVEL                  For 44
69724>>>>>>>>>>>Define CALLDRV_GET_SERVER_CFG                       For 45
69724>>>>>>>>>>>Define CALLDRV_SET_SQL_LOCK_TIMEOUT                 For 46
69724>>>>>>>>>>>Define CALLDRV_GET_SQL_LOCK_TIMEOUT                 For 47
69724>>>>>>>>>>>Define CALLDRV_GET_RESULTS                          For 48
69724>>>>>>>>>>>Define CALLDRV_GET_MORE_RESULTS                     For 49
69724>>>>>>>>>>>Define CALLDRV_GET_CURRENT_USER_NAME                For 50
69724>>>>>>>>>>>Define CALLDRV_OPEN_EMBEDDED_CURSOR                 For 51
69724>>>>>>>>>>>Define CALLDRV_CLOSE_EMBEDDED_CURSOR                For 52
69724>>>>>>>>>>>Define CALLDRV_SET_CURRENT_EMBEDDED_CURSOR          For 53
69724>>>>>>>>>>>Define CALLDRV_GET_CURRENT_EMBEDDED_CURSOR          For 54
69724>>>>>>>>>>>Define CALLDRV_SET_MAX_EMBEDDED_CURSOR              For 55
69724>>>>>>>>>>>Define CALLDRV_GET_MAX_EMBEDDED_CURSOR              For 56
69724>>>>>>>>>>>Define CALLDRV_SQL_TRANSACTION                      For 57
69724>>>>>>>>>>>Define CALLDRV_LOCAL_TD_PATH                        For 58
69724>>>>>>>>>>>Define CALLDRV_CREATE_DB                            For 59
69724>>>>>>>>>>>Define CALLDRV_ESCAPE_STRING                        For 60
69724>>>>>>>>>>>Define CALLDRV_SET_PROC_ATTRIBUTE_TYPE              For 61
69724>>>>>>>>>>>Define CALLDRV_SQL_REFRESH_CACHE                    For 62
69724>>>>>>>>>>>Define CALLDRV_GET_SQL_STMT                         For 63
69724>>>>>>>>>>>Define CALLDRV_DIRECT_PATH_LOAD                     For 64
69724>>>>>>>>>>>
69724>>>>>>>>>>>Define CALLDRV_READ_LOB                             For 65
69724>>>>>>>>>>>Define CALLDRV_WRITE_LOB                            For 66
69724>>>>>>>>>>>Define CALLDRV_APPEND_LOB                           For 67
69724>>>>>>>>>>>Define CALLDRV_LENGTH_LOB                           For 68
69724>>>>>>>>>>>Define CALLDRV_LOADFROMFILE_LOB                     For 69
69724>>>>>>>>>>>Define CALLDRV_ERASE_LOB                            For 70
69724>>>>>>>>>>>Define CALLDRV_TRUNCATE_LOB                         For 71
69724>>>>>>>>>>>Define CALLDRV_INITIALIZE_SEQUENCE                  For 72
69724>>>>>>>>>>>Define CALLDRV_CLIENT_CFG                           For 73
69724>>>>>>>>>>>Define CALLDRV_END_SAVERECORD                       For 74
69724>>>>>>>>>>>Define CALLDRV_ENABLE_RECONNECT                     For 75
69724>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER                     For 76
69724>>>>>>>>>>>Define CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS         For 77
69724>>>>>>>>>>>Define CALLDRV_USE_DFLEX_DATE_FORMAT                For 78
69724>>>>>>>>>>>Define CALLDRV_FORCE_FIELDS_NOT_NULL                For 79
69724>>>>>>>>>>>Define CALLDRV_ORA_CREATE_TABLE_FROM_DAT            For 80
69724>>>>>>>>>>>Define CALLDRV_MAX_DATA_SIZE                        For 81
69724>>>>>>>>>>>Define CALLDRV_CHUNK_SIZE                           For 82
69724>>>>>>>>>>>Define CALLDRV_GET_DATA_CHUNK                       For 83
69724>>>>>>>>>>>Define CALLDRV_MIRROR_SERVER                        For 84
69724>>>>>>>>>>>Define CALLDRV_COPY_DATA                            For 85
69724>>>>>>>>>>>Define CALLDRV_SET_SQL_CURSOR_TYPE                  For 86
69724>>>>>>>>>>>Define CALLDRV_ICF                                  For 87
69724>>>>>>>>>>>Define CALLDRV_CLEAR_INT_CACHE                      For 88
69724>>>>>>>>>>>Define CALLDRV_GET_CURRENT_USER_PASSWORD            For 89
69724>>>>>>>>>>>Define CALLDRV_FORCE_FIELDS_NULL                    For 90
69724>>>>>>>>>>>Define CALLDRV_TRANSACTIONS_ALLOWED                 For 91
69724>>>>>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE2                   For 92
69724>>>>>>>>>>>Define CALLDRV_PGSQL_NAME_SPACE                     For 93
69724>>>>>>>>>>>Define CALLDRV_EMBEDDED_SQL_TYPE                    For 94
69724>>>>>>>>>>>Define CALLDRV_CREATE_INVK_FUNCTIONS                For 95
69724>>>>>>>>>>>Define CALLDRV_DEFAULT_FILE_CASING                  For 96
69724>>>>>>>>>>>Define CALLDRV_GLOBAL_SETTING                       For 97
69724>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT                   For 98
69724>>>>>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER_CONNECTION        For 99
69724>>>>>>>>>>>Define CALLDRV_100                                  For 100
69724>>>>>>>>>>>Define CALLDRV_FILE_STRUCT_DYNAMIC_ONLINE           For 101
69724>>>>>>>>>>>Define CALLDRV_SET_FIXED_FILE_RECORDS_USED          For 102
69724>>>>>>>>>>>Define CALLDRV_GET_FIXED_FILE_RECORDS_USED          For 103
69724>>>>>>>>>>>Define CALLDRV_LOB_EX_WRITE                         For 104
69724>>>>>>>>>>>Define CALLDRV_LOB_EX_APPEND                        For 105
69724>>>>>>>>>>>Define CALLDRV_LOB_EX_READ                          For 106
69724>>>>>>>>>>>Define CALLDRV_LOB_EX_GET_LENGTH                    For 107
69724>>>>>>>>>>>Define CALLDRV_LOB_EX_SET_LENGTH                    For 108
69724>>>>>>>>>>>Define CALLDRV_LOB_EX_TEST                          For 109
69724>>>>>>>>>>>Define CALLDRV_LOB_EX_SET_NULL                      For 110
69724>>>>>>>>>>>Define CALLDRV_GET_DATA_CHUNK_EX                    for 111
69724>>>>>>>>>>>Define CALLDRV_PARAM_RETURN_TYPE                    For 112
69724>>>>>>>>>>>Define CALLDRV_CONNECTION_STRING                    for 113
69724>>>>>>>>>>>Define CALLDRV_GET_SQL_CURSOR_TYPE                  for 114
69724>>>>>>>>>>>
69724>>>>>>>>>>>// License and environment settings
69724>>>>>>>>>>>Define CALLDRV_DRIVER_REVISION                      For 0
69724>>>>>>>>>>>Define CALLDRV_COMPANY_NAME                         For 1
69724>>>>>>>>>>>Define CALLDRV_SERIAL_NUMBER                        For 2
69724>>>>>>>>>>>Define CALLDRV_LICENSED_USERS                       For 3
69724>>>>>>>>>>>Define CALLDRV_MAJOR_REVISION                       For 4
69724>>>>>>>>>>>Define CALLDRV_VERSION_COMMENTS                     For 5
69724>>>>>>>>>>>Define CALLDRV_OLEDB_OEM_TRANSLATION                For 6
69724>>>>>>>>>>>Define CALLDRV_SET_DB_PORT                          For 7
69724>>>>>>>>>>>Define CALLDRV_GET_DB_PORT                          For 8
69724>>>>>>>>>>>Define CALLDRV_SET_DB_SOCKET                        For 9
69724>>>>>>>>>>>Define CALLDRV_GET_DB_SOCKET                        For 10
69724>>>>>>>>>>>Define CALLDRV_SET_AS_SYSDBA                        For 11
69724>>>>>>>>>>>Define CALLDRV_OEM_TRANSLATION_STATE                For 12
69724>>>>>>>>>>>Define CALLDRV_TIME_TO_LIC_EXPIRATION               For 13
69724>>>>>>>>>>>Define CALLDRV_LICENSE_EXPIRATION_WARN              For 14
69724>>>>>>>>>>>Define CALLDRV_LICENSE_PATH                         For 15
69724>>>>>>>>>>>Define CALLDRV_AUTO_NUMERIC_REMAPPING               For 16
69724>>>>>>>>>>>Define CALLDRV_FORCE_DATE_FORMAT_INIT               For 17
69724>>>>>>>>>>>Define CALLDRV_STATIC_TABLE_OPT                     For 18
69724>>>>>>>>>>>Define CALLDRV_MAX_OBJECT_NAME_LENGTH               For 19
69724>>>>>>>>>>>Define CALLDRV_USE_LAZY_OPEN_MODE                   For 20
69724>>>>>>>>>>>Define CALLDRV_SET_CUSTOM_OEM_TO_ANSI               For 21
69724>>>>>>>>>>>Define CALLDRV_GET_CUSTOM_OEM_TO_ANSI               For 22
69724>>>>>>>>>>>
69724>>>>>>>>>>>//CALLDRV_ENUMERATE_SERVER_OPTION
69724>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER_COUNT               For 0
69724>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER_SERVER              For 1
69724>>>>>>>>>>>
69724>>>>>>>>>>>//CALLDRV_DEFAULT_FILE_CASING
69724>>>>>>>>>>>Define FILE_CASING_UPPER                            For 0
69724>>>>>>>>>>>Define FILE_CASING_LOWER                            For 1
69724>>>>>>>>>>>Define FILE_CASING_KEEP                             For 2
69724>>>>>>>>>>>
69724>>>>>>>>>>>// CALLDRV_GLOBAL_SETTING
69724>>>>>>>>>>>Define GLOBAL_SETTING_TABLESPACE_SET                For 0
69724>>>>>>>>>>>Define GLOBAL_SETTING_TABLESPACE_GET                For 1
69724>>>>>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_SET          For 2
69724>>>>>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_GET          For 3
69724>>>>>>>>>>>
69724>>>>>>>>>>>// CALLDRV_RESTRUCTURE_SCRIPT
69724>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_ENABLE            For 0
69724>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_DISABLE           For 1
69724>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_SQL     For 2
69724>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_INT     For 3
69724>>>>>>>>>>>
69724>>>>>>>>>>>// DF_SQL_RELATION_STATUS attributes
69724>>>>>>>>>>>Define FOREIGN_KEY_NONE                             For -1
69724>>>>>>>>>>>Define FOREIGN_KEY_CREATE                           For  0
69724>>>>>>>>>>>Define FOREIGN_KEY_ENABLE                           For  1
69724>>>>>>>>>>>Define FOREIGN_KEY_DISABLE                          For  2
69724>>>>>>>>>>>Define FOREIGN_KEY_DROP                             For  3
69724>>>>>>>>>>>
69724>>>>>>>>>>>// DF_SQL_RELATION_DELETE_REF_ACTION attributes
69724>>>>>>>>>>>Define DELETE_REF_NONE                              For 0
69724>>>>>>>>>>>Define DELETE_REF_CASCADE                           For 1
69724>>>>>>>>>>>Define DELETE_REF_SET_NULL                          For 2
69724>>>>>>>>>>>Define DELETE_REF_SET_DEFAULT                       For 3
69724>>>>>>>>>>>Define DELETE_REF_RESTRICT                          For 4
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Embedded SQL Cursor Types
69724>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_NONE           For 0
69724>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_CLIENT         For 1
69724>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_SERVER         For 2
69724>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_PARAMETERIZED  For 3
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Driver Call Direction
69724>>>>>>>>>>>Define CALLDRV_VALUE_GET                            For 0
69724>>>>>>>>>>>Define CALLDRV_VALUE_SET                            For 1
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Inverse Key types
69724>>>>>>>>>>>Define REGULAR_SEG                                  For -1
69724>>>>>>>>>>>Define INVK_CASE_SEG                                For 0
69724>>>>>>>>>>>Define INVK_DESC_SEG                                For 1
69724>>>>>>>>>>>Define INVK_DESC_AND_CASE_SEG                       For 2
69724>>>>>>>>>>>
69724>>>>>>>>>>>//DB2 Index Types
69724>>>>>>>>>>>Define REG_INDEX                                    For 0
69724>>>>>>>>>>>Define REV_INDEX                                    For 1
69724>>>>>>>>>>>Define CLUST_INDEX                                  For 2
69724>>>>>>>>>>>Define REV_CLUST_INDEX                              For 3
69724>>>>>>>>>>>
69724>>>>>>>>>>>//Oracle Procedure Arguments type
69724>>>>>>>>>>>Define IS_NONE                                      For 0
69724>>>>>>>>>>>Define IS_IN                                        For 1
69724>>>>>>>>>>>Define IS_OUT                                       For 2
69724>>>>>>>>>>>Define IS_IN_OUT                                    For 3
69724>>>>>>>>>>>Define IS_RSET                                      For 4
69724>>>>>>>>>>>
69724>>>>>>>>>>>// SQL_GET_COL Attributes
69724>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_SIZE                      For 1
69724>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DECIMALS                  For 2
69724>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_LABEL                     For 3
69724>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_COLUMN_NAME               For 4
69724>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_TABLE_NAME                For 5
69724>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_SQLTYPE                   For 6
69724>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_NULLABLE                  For 7
69724>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DFTYPE                    For 8
69724>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DATA_LENGTH               For 9
69724>>>>>>>>>>>
69724>>>>>>>>>>>// MySQL Data Types
69724>>>>>>>>>>>Define eMySQL_DECIMAL                               For 0
69724>>>>>>>>>>>Define eMySQL_TINY                                  For 1
69724>>>>>>>>>>>Define eMySQL_SHORT                                 For 2
69724>>>>>>>>>>>Define eMySQL_LONG                                  For 3
69724>>>>>>>>>>>Define eMySQL_FLOAT                                 For 4
69724>>>>>>>>>>>Define eMySQL_DOUBLE                                For 5
69724>>>>>>>>>>>Define eMySQL_NULL                                  For 6
69724>>>>>>>>>>>Define eMySQL_TIMESTAMP                             For 7
69724>>>>>>>>>>>Define eMySQL_LONGLONG                              For 8
69724>>>>>>>>>>>Define eMySQL_INT24                                 For 9
69724>>>>>>>>>>>Define eMySQL_DATE                                  For 10
69724>>>>>>>>>>>Define eMySQL_TIME                                  For 11
69724>>>>>>>>>>>Define eMySQL_DATETIME                              For 12
69724>>>>>>>>>>>Define eMySQL_YEAR                                  For 13
69724>>>>>>>>>>>Define eMySQL_NEWDATE                               For 14
69724>>>>>>>>>>>Define eMySQL_BIT                                   For 16
69724>>>>>>>>>>>Define eMySQL_NEWDECIMAL                            For 246
69724>>>>>>>>>>>Define eMySQL_ENUM                                  For 247
69724>>>>>>>>>>>Define eMySQL_SET                                   For 248
69724>>>>>>>>>>>Define eMySQL_TINY_BLOB                             For 249
69724>>>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           For 250
69724>>>>>>>>>>>Define eMySQL_LONG_BLOB                             For 251
69724>>>>>>>>>>>Define eMySQL_BLOB                                  For 252
69724>>>>>>>>>>>Define eMySQL_VAR_STRING                            For 253
69724>>>>>>>>>>>Define eMySQL_STRING                                For 254
69724>>>>>>>>>>>Define eMySQL_TINY_TEXT                             For -249
69724>>>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           For -250
69724>>>>>>>>>>>Define eMySQL_LONG_TEXT                             For -251
69724>>>>>>>>>>>Define eMySQL_TEXT                                  For -252
69724>>>>>>>>>>>
69724>>>>>>>>>>>// Oracle Data Types
69724>>>>>>>>>>>Define eOracle_VARCHAR2                             For   1
69724>>>>>>>>>>>Define eOracle_NUMBER                               For   2
69724>>>>>>>>>>>Define eOracle_INT                                  For   3
69724>>>>>>>>>>>Define eOracle_FLOAT                                For   4
69724>>>>>>>>>>>Define eOracle_STRING                               For   5
69724>>>>>>>>>>>Define eOracle_LONG                                 For   8
69724>>>>>>>>>>>Define eOracle_ROWID                                For  11
69724>>>>>>>>>>>Define eOracle_DATE                                 For  12
69724>>>>>>>>>>>Define eOracle_RAW                                  For  23
69724>>>>>>>>>>>Define eOracle_LONGRAW                              For  24
69724>>>>>>>>>>>Define eOracle_CHAR                                 For  96
69724>>>>>>>>>>>Define eOracle_MSLABEL                              For 106
69724>>>>>>>>>>>Define eOracle_CLOB                                 For 112
69724>>>>>>>>>>>Define eOracle_BLOB                                 For 113
69724>>>>>>>>>>>Define eOracle_TIMESTAMP                            For 187
69724>>>>>>>>>>>Define eOracle_TIMESTAMPTZ                          For 188
69724>>>>>>>>>>>Define eOracle_INTERVALYM                           For 189
69724>>>>>>>>>>>Define eOracle_INTERVALDS                           For 190
69724>>>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         For 232
69724>>>>>>>>>>>Define eOracle_NCHAR                                For 286
69724>>>>>>>>>>>Define eOracle_NVARCHAR2                            For 287
69724>>>>>>>>>>>Define eOracle_NCLOB                                For 288
69724>>>>>>>>>>>
69724>>>>>>>>>>>// PostgreSQL Data Types
69724>>>>>>>>>>>Define ePgSQL_CIRCLE                                For  718
69724>>>>>>>>>>>Define ePgSQL_MONEY                                 For  790
69724>>>>>>>>>>>Define ePgSQL_BOOL                                  For   16
69724>>>>>>>>>>>Define ePgSQL_BYTEA                                 For   17
69724>>>>>>>>>>>Define ePgSQL_CHAR                                  For   18
69724>>>>>>>>>>>Define ePgSQL_INT2                                  For   21
69724>>>>>>>>>>>Define ePgSQL_INT4                                  For   23
69724>>>>>>>>>>>Define ePgSQL_REGPROC                               For   24
69724>>>>>>>>>>>Define ePgSQL_REGPROCEDURE                          For 2202
69724>>>>>>>>>>>Define ePgSQL_REGOPER                               For 2203
69724>>>>>>>>>>>Define ePgSQL_REGOPERATOR                           For 2204
69724>>>>>>>>>>>Define ePgSQL_REGCLASS                              For 2205
69724>>>>>>>>>>>Define ePgSQL_REGTYPE                               For 2206
69724>>>>>>>>>>>Define ePgSQL_TEXT                                  For   25
69724>>>>>>>>>>>Define ePgSQL_CITEXT                                For  -25
69724>>>>>>>>>>>Define ePgSQL_OID                                   For   26
69724>>>>>>>>>>>Define ePgSQL_TID                                   For   27
69724>>>>>>>>>>>Define ePgSQL_XID                                   For   28
69724>>>>>>>>>>>Define ePgSQL_CID                                   For   29
69724>>>>>>>>>>>Define ePgSQL_XML                                   For  142
69724>>>>>>>>>>>Define ePgSQL_BPCHAR                                For 1042
69724>>>>>>>>>>>Define ePgSQL_VARCHAR                               For 1043
69724>>>>>>>>>>>Define ePgSQL_INT8                                  For   20
69724>>>>>>>>>>>Define ePgSQL_PATH                                  For  602
69724>>>>>>>>>>>Define ePgSQL_FLOAT4                                For  700
69724>>>>>>>>>>>Define ePgSQL_FLOAT8                                For  701
69724>>>>>>>>>>>Define ePgSQL_ABSTIME                               For  702
69724>>>>>>>>>>>Define ePgSQL_RELTIME                               For  703
69724>>>>>>>>>>>Define ePgSQL_TINTERVAL                             For  704
69724>>>>>>>>>>>Define ePgSQL_POINT                                 For  600
69724>>>>>>>>>>>Define ePgSQL_LINE                                  For  628
69724>>>>>>>>>>>Define ePgSQL_LSEG                                  For  601
69724>>>>>>>>>>>Define ePgSQL_BOX                                   For  603
69724>>>>>>>>>>>Define ePgSQL_POLYGON                               For  604
69724>>>>>>>>>>>Define ePgSQL_ACLITEM                               For 1033
69724>>>>>>>>>>>Define ePgSQL_MACADDR                               For  829
69724>>>>>>>>>>>Define ePgSQL_INET                                  For  869
69724>>>>>>>>>>>Define ePgSQL_CIDR                                  For  650
69724>>>>>>>>>>>Define ePgSQL_TIMESTAMP                             For 1114
69724>>>>>>>>>>>Define ePgSQL_DATE                                  For 1082
69724>>>>>>>>>>>Define ePgSQL_TIME                                  For 1083
69724>>>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           For 1184
69724>>>>>>>>>>>Define ePgSQL_INTERVAL                              For 1186
69724>>>>>>>>>>>Define ePgSQL_NUMERIC                               For 1700
69724>>>>>>>>>>>Define ePgSQL_TIMETZ                                For 1266
69724>>>>>>>>>>>Define ePgSQL_BIT                                   For 1560
69724>>>>>>>>>>>Define ePgSQL_VARBIT                                For 1562
69724>>>>>>>>>>>Define ePgSQL_UUID                                  For 2950
69724>>>>>>>>>>>
69724>>>>>>>>>>>// SQL Server Data Types
69724>>>>>>>>>>>Define eSQLServer_NA                                For    0
69724>>>>>>>>>>>Define eSQLServer_CHAR                              For    1
69724>>>>>>>>>>>Define eSQLServer_NUMERIC                           For    2
69724>>>>>>>>>>>Define eSQLServer_DECIMAL                           For    3
69724>>>>>>>>>>>Define eSQLServer_INT                               For    4
69724>>>>>>>>>>>Define eSQLServer_SMALLINT                          For    5
69724>>>>>>>>>>>Define eSQLServer_FLOAT                             For    6
69724>>>>>>>>>>>Define eSQLServer_REAL                              For    7
69724>>>>>>>>>>>Define eSQLServer_DOUBLE                            For    8
69724>>>>>>>>>>>Define eSQLServer_DATETIME                          For   11
69724>>>>>>>>>>>Define eSQLServer_VARCHAR                           For   12
69724>>>>>>>>>>>Define eSQLServer_DATE                              For   40
69724>>>>>>>>>>>Define eSQLServer_TIME                              For   41
69724>>>>>>>>>>>Define eSQLServer_DATETIME2                         For   42
69724>>>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    For   43
69724>>>>>>>>>>>Define eSQLServer_SMALLDATETIME                     For   58
69724>>>>>>>>>>>Define eSQLServer_TIMESTAMP                         For   93
69724>>>>>>>>>>>Define eSQLServer_HIERARCHYID                       For  128
69724>>>>>>>>>>>Define eSQLServer_GEOMETRY                          For  129
69724>>>>>>>>>>>Define eSQLServer_GEOGRAPHY                         For  130
69724>>>>>>>>>>>Define eSQLServer_TEXT                              For   -1
69724>>>>>>>>>>>Define eSQLServer_BINARY                            For   -2
69724>>>>>>>>>>>Define eSQLServer_VARBINARY                         For   -3
69724>>>>>>>>>>>Define eSQLServer_IMAGE                             For   -4
69724>>>>>>>>>>>Define eSQLServer_BIGINT                            For   -5
69724>>>>>>>>>>>Define eSQLServer_TINYINT                           For   -6
69724>>>>>>>>>>>Define eSQLServer_BIT                               For   -7
69724>>>>>>>>>>>Define eSQLServer_NCHAR                             For   -8
69724>>>>>>>>>>>Define eSQLServer_NVARCHAR                          For   -9
69724>>>>>>>>>>>Define eSQLServer_NTEXT                             For  -10
69724>>>>>>>>>>>Define eSQLServer_GUID                              For  -11
69724>>>>>>>>>>>Define eSQLServer_VARBINARYMAX                      For  -98
69724>>>>>>>>>>>Define eSQLServer_VARCHARMAX                        For  -99
69724>>>>>>>>>>>Define eSQLServer_NVARCHARMAX                       For -100
69724>>>>>>>>>>>Define eSQLServer_SQLVARIANT                        For -150
69724>>>>>>>>>>>Define eSQLServer_XML                               For -370
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>//Error Text
69724>>>>>>>>>>>//==========
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>//Define Self if needed
69724>>>>>>>>>>>//=====================
69724>>>>>>>>>>>
69724>>>>>>>>>>>
69724>>>>>>>>>>>//=============================================================================
69724>>>>>>>>>>>//Define varibles we need
69724>>>>>>>>>>>//=======================
69724>>>>>>>>>>>
69724>>>>>>>>>>>    Define MertechInc_Variables_Defined
69724>>>>>>>>>>>
69724>>>>>>>>>>>    Indicator MertechInc_bThereIsBinding
69724>>>>>>>>>>>
69724>>>>>>>>>>>    Integer MertechInc_FileNumber      //Replaces _SAVEFILENUMBER# and FILENUMBER
69724>>>>>>>>>>>    Integer MertechInc_iArg            //Replaces _LLONG#
69724>>>>>>>>>>>    Integer MertechInc_iCallBack       //Replaces _CALLBACK#
69724>>>>>>>>>>>    Integer MertechInc_iCount          //General loop limit integer
69724>>>>>>>>>>>    Integer MertechInc_iDecSep         //Holds the decimal seperator
69724>>>>>>>>>>>    Integer MertechInc_iFunction       //Replaces _FID#    ??? check is this is need when tidy is complete
69724>>>>>>>>>>>    Integer MertechInc_iLoop           //General loop integer
69724>>>>>>>>>>>    Integer Mertech_iMySQLParam        //Replaces _ALL_PAR_POS#
69724>>>>>>>>>>>    Integer MertechInc_iParamCount     //Replaces _NPAR#
69724>>>>>>>>>>>    Integer MertechInc_iRet            //Replaces _RET#
69724>>>>>>>>>>>    Integer MertechInc_iSaveCount      //Replaces _NPOS#
69724>>>>>>>>>>>    Integer MertechInc_iWork           //General work integer
69724>>>>>>>>>>>    Integer MertechInc_iWork2
69724>>>>>>>>>>>    Integer MertechInc_iWork3
69724>>>>>>>>>>>    Integer MertechInc_SizeCheckDone
69724>>>>>>>>>>>    Integer MertechInc_LastCursorNum
69724>>>>>>>>>>>    Move -2 to MertechInc_LastCursorNum // -1 means default cursor, so we're using -2 no cursor yet
69725>>>>>>>>>>>    Integer MertechInc_DefaultCursorType
69725>>>>>>>>>>>
69725>>>>>>>>>>>    Move CALLDRV_ENUMERATE_CURSOR_TYPE_NONE to MertechInc_DefaultCursorType
69726>>>>>>>>>>>
69726>>>>>>>>>>>    String MertechInc_Blank            //Replaces _BLANK#
69726>>>>>>>>>>>    String MertechInc_DriverName       //Replaces _DRIVERNAME#
69726>>>>>>>>>>>    String MertechInc_sArg1 255        //Replaces _ARG1#
69726>>>>>>>>>>>    String MertechInc_sArg2 255        //Replaces _ARG2#
69726>>>>>>>>>>>    String MertechInc_sWork 255        //General work string
69726>>>>>>>>>>>
69726>>>>>>>>>>>    String MertechInc_CurrentDriver    //Keep the current driver name
69726>>>>>>>>>>>    //Global string are created pre-filled with spaces. We need an empty string
69726>>>>>>>>>>>    Move "" to MertechInc_Blank
69727>>>>>>>>>>>    Move "" to MertechInc_CurrentDriver
69728>>>>>>>>>>>
69728>>>>>>>>>>>
69728>>>>>>>>>>>//=============================================================================
69728>>>>>>>>>>>//Use Obsolete Code
69728>>>>>>>>>>>//=================
69728>>>>>>>>>>>
69728>>>>>>>>>>>
69728>>>>>>>>>>>
69728>>>>>>>>>>>//=============================================================================
69728>>>>>>>>>>>//Comment Block Template
69728>>>>>>>>>>>//======================
69728>>>>>>>>>>>
69728>>>>>>>>>>>/// @Name {Name of the command for indexing} (used for documentation)
69728>>>>>>>>>>>/// @Description {Short Command Description} (used for documentation)
69728>>>>>>>>>>>///     The description can be multiple lines, and contain HTML tags.
69728>>>>>>>>>>>///     The other tokens will have HTML encoded so we can show stuff
69728>>>>>>>>>>>///     like <param1> properly. A blank line will automatically be
69728>>>>>>>>>>>///         translated into a paragraph break in the documentation, so
69728>>>>>>>>>>>///     no need for <br> or <p> tags.
69728>>>>>>>>>>>///
69728>>>>>>>>>>>/// @Assumptions {Assumptions made in order for the command to work}
69728>>>>>>>>>>>/// @Status {Obsolete, Internal, or Public} (used for documentation)
69728>>>>>>>>>>>/// @Drivers {DB2Flex, MySQLFlex, ORAFlex, PgFlex, SQLFlex or All} (used for documentation)
69728>>>>>>>>>>>/// @VersionNote {Date and author of the last revision}
69728>>>>>>>>>>>/// @See {list of related commands}
69728>>>>>>>>>>>///
69728>>>>>>>>>>>/// @Syntax {Syntax of use} (used for documentation)
69728>>>>>>>>>>>/// @Param {Each parameter with a brief description} (used for documentation)
69728>>>>>>>>>>>/// @DBMS {List of supported databases}
69728>>>>>>>>>>>/// @DataFlex {List of supported DataFlex versions}
69728>>>>>>>>>>>/// @Usage {Different uses command can have multiple syntaxes} (used for documentation)
69728>>>>>>>>>>>///
69728>>>>>>>>>>>/// @Example {An example of the command being used} (used for documentation)
69728>>>>>>>>>>>
69728>>>>>>>>>>>//=============================================================================
69728>>>>>>>>>>>/// @Name        DO_GETFILENUMBER_DRIVERNAME
69728>>>>>>>>>>>/// @Description Retrieves the current driver name and or the file number
69728>>>>>>>>>>>/// that will be used by the macro commands.
69728>>>>>>>>>>>///
69728>>>>>>>>>>>/// @Assumptions
69728>>>>>>>>>>>/// @Status      Internal Use Only
69728>>>>>>>>>>>/// @Drivers     All
69728>>>>>>>>>>>/// @VersionNote Last Revised: 2009-07-14 By Ian Smith
69728>>>>>>>>>>>/// @See
69728>>>>>>>>>>>//Most commands Use DO_GETFILENUMBER_DRIVERNAME so this code was being duplicated
69728>>>>>>>>>>>//all the Time. It has been moved to this method to remove that duplication.
69728>>>>>>>>>>>Procedure MertechInc_Get_Driver_name Global
69730>>>>>>>>>>>    //If we have a file number get its driver, else find first loaded Mertech driver
69730>>>>>>>>>>>    If MertechInc_FileNumber GT 0 ;        Get_Attribute DF_FILE_DRIVER of MertechInc_FileNumber to MertechInc_DriverName
69735>>>>>>>>>>>    Else Begin
69736>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to MertechInc_iCount
69739>>>>>>>>>>>        For MertechInc_iLoop from 1 to MertechInc_iCount
69745>>>>>>>>>>>>
69745>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of MertechInc_iLoop to MertechInc_DriverName
69748>>>>>>>>>>>            Move (UPPERCASE(MertechInc_DriverName)) to MertechInc_DriverName
69749>>>>>>>>>>>            If (MertechInc_DriverName EQ ORAFLEX  or MertechInc_DriverName EQ SQLFLEX or MertechInc_DriverName EQ MDSDB2 or ;                MertechInc_DriverName EQ MDSPgSQL or MertechInc_DriverName EQ MDSMySQL) Move MertechInc_iCount to MertechInc_iLoop
69752>>>>>>>>>>>            Else Move "" to MertechInc_DriverName
69754>>>>>>>>>>>        Loop
69755>>>>>>>>>>>>
69755>>>>>>>>>>>    End
69755>>>>>>>>>>>>
69755>>>>>>>>>>>
69755>>>>>>>>>>>    //Ensure that we return a valid Mertech driver.
69755>>>>>>>>>>>    If (MertechInc_DriverName NE ORAFLEX  and MertechInc_DriverName NE SQLFLEX  and ;        MertechInc_DriverName NE MDSPgSQL and MertechInc_DriverName NE MDSMySQL) Begin
69757>>>>>>>>>>>
69757>>>>>>>>>>>        //Report invalid driver
69757>>>>>>>>>>>        Error 25100 ("Mertech.inc - Not a Mertech driver. File" * String(MertechInc_FileNumber) * "Driver" * Trim(MertechInc_DriverName) )
69758>>>>>>>>>>>>
69758>>>>>>>>>>>
69758>>>>>>>>>>>        //Set MertechInc_FileNumber to MertechInc_Invalid_Driver so that the commands can
69758>>>>>>>>>>>        //determine if the driver is valid. MertechInc_FileNumber is use instead of
69758>>>>>>>>>>>        //MertechInc_DriverName as integer conparisons are quicker than string conparisons
69758>>>>>>>>>>>        Move MertechInc_Invalid_Driver to MertechInc_FileNumber
69759>>>>>>>>>>>    End
69759>>>>>>>>>>>>
69759>>>>>>>>>>>End_Procedure
69760>>>>>>>>>>>
69760>>>>>>>>>>>
69760>>>>>>>>>>>//=============================================================================
69760>>>>>>>>>>>/// @Name        MertechInc_Pre_Size_String
69760>>>>>>>>>>>/// @Description Returns a string full of spaces.
69760>>>>>>>>>>>///
69760>>>>>>>>>>>/// @Assumptions
69760>>>>>>>>>>>/// @Status      Internal
69760>>>>>>>>>>>/// @Drivers     n/a
69760>>>>>>>>>>>/// @VersionNote Last Revised: 2009-12-02 By Gandalf Hernandez
69760>>>>>>>>>>>/// @See
69760>>>>>>>>>>>Function MertechInc_Pre_Size_String Global Integer iSize Returns String
69762>>>>>>>>>>>   String sWork
69762>>>>>>>>>>>   Integer iBlocks iRemainder
69762>>>>>>>>>>>
69762>>>>>>>>>>>   If (iSize <= 1) Begin
69764>>>>>>>>>>>      // marcelo 06/28/2000 implemented logic to avoid VDF 7 crashing problems
69764>>>>>>>>>>>          If FMAC_VERSION eq 7 Move 1000 to iSize
69767>>>>>>>>>>>          Else Move 16384 to iSize
69769>>>>>>>>>>>   End
69769>>>>>>>>>>>>
69769>>>>>>>>>>>
69769>>>>>>>>>>>   // Build the string in blocks of 32, to speed things up
69769>>>>>>>>>>>   // If the string is less than 32 bytes, just fill it up regularly
69769>>>>>>>>>>>   Move (iSize / 32) to iBlocks
69770>>>>>>>>>>>   Move (Mod(iSize, 32)) to iRemainder
69771>>>>>>>>>>>
69771>>>>>>>>>>>   If (iBlocks > 0) Begin
69773>>>>>>>>>>>      Move (Repeat("                                ", iBlocks)) to sWork
69774>>>>>>>>>>>      Move (Append (sWork, (Repeat(" ", iRemainder)))) to sWork
69775>>>>>>>>>>>   End
69775>>>>>>>>>>>>
69775>>>>>>>>>>>   Else Move (Repeat(" ", iSize)) to sWork
69777>>>>>>>>>>>
69777>>>>>>>>>>>   Function_Return sWork
69778>>>>>>>>>>>End_Function
69779>>>>>>>>>>>
69779>>>>>>>>>>>//=============================================================================
69779>>>>>>>>>>>/// @Name        MertechInc_Set_DecSep
69779>>>>>>>>>>>/// @Description Saves the current decimal separator and sets the decimal
69779>>>>>>>>>>>/// separator to '.'.
69779>>>>>>>>>>>///
69779>>>>>>>>>>>/// @Assumptions
69779>>>>>>>>>>>/// @Status      Internal
69779>>>>>>>>>>>/// @Drivers     n/a
69779>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
69779>>>>>>>>>>>Procedure MertechInc_Set_DecSep Global
69781>>>>>>>>>>>    Get_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
69784>>>>>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to 46 // (.) WILL BE DECIMAL SEPARATOR
69789>>>>>>>>>>>End_Procedure
69790>>>>>>>>>>>
69790>>>>>>>>>>>//=============================================================================
69790>>>>>>>>>>>/// @Name        MertechInc_Reset_DecSep
69790>>>>>>>>>>>/// @Description Sets the decimal separator to the saved value.
69790>>>>>>>>>>>///
69790>>>>>>>>>>>/// @Status      Internal
69790>>>>>>>>>>>/// @Drivers     n/a
69790>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
69790>>>>>>>>>>>///
69790>>>>>>>>>>>Procedure MertechInc_Reset_DecSep Global
69792>>>>>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
69797>>>>>>>>>>>End_Procedure
69798>>>>>>>>>>>
69798>>>>>>>>>>>//=============================================================================
69798>>>>>>>>>>>/// @Name        FETCH_FIELD
69798>>>>>>>>>>>/// @Description Selects or de-selects the fields to be fetched during the
69798>>>>>>>>>>>/// next FIND (query).
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Status      Internal
69798>>>>>>>>>>>/// @Drivers     All
69798>>>>>>>>>>>/// @VersionNote Last Revised: 2009-07-16 By Ian Smith
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <FieldStart> THRU <FieldEnd> TO DF_FETCH_TRUE
69798>>>>>>>>>>>/// @Param  FileNum    is the File Number
69798>>>>>>>>>>>/// @Param  FieldStart is the Field Name or Number that will start the selection range
69798>>>>>>>>>>>/// @Param  FieldEnd   is the Field Name or Number that will finish the selection range
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <Field1> TO DF_FETCH_TRUE
69798>>>>>>>>>>>/// @Param  FileNum  is the File Number
69798>>>>>>>>>>>/// @Param  Field1 Fields Name or Number to be selected
69798>>>>>>>>>>>///
69798>>>>>>>>>>>
69798>>>>>>>>>>>//=============================================================================
69798>>>>>>>>>>>/// @Name        SQL_TEXT_MESSAGE
69798>>>>>>>>>>>/// @Description Use this command to manually insert a string into a trace
69798>>>>>>>>>>>/// file. This can be useful for readability within the trace file to log
69798>>>>>>>>>>>/// what is actually happening at certain points.
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Assumptions The text string is less than 80 characters long.
69798>>>>>>>>>>>/// @Status      Public
69798>>>>>>>>>>>/// @Drivers     All
69798>>>>>>>>>>>/// @VersionNote Last Revised: 20013-08-19 by Aaron Gulack
69798>>>>>>>>>>>/// @See         ENABLE_TRACE_ON DISABLE_TRACE_ON
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Syntax SQL_TEXT_MESSAGE {variable}
69798>>>>>>>>>>>/// @Param  {variable}          The string to insert into the trace file.
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Example
69798>>>>>>>>>>>/// Login "localhost" "mds" "mertech" "ora_drv"
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// ENABLE_TRACE_ON to "c:\trace.txt" DEBUG_LEVEL
69798>>>>>>>>>>>/// open Customer
69798>>>>>>>>>>>/// SQL_TEXT_MESSAGE "The table has been opened"
69798>>>>>>>>>>>
69798>>>>>>>>>>>//=============================================================================
69798>>>>>>>>>>>/// @Name       SELECT_COLUMNS_FIND
69798>>>>>>>>>>>/// @Description This command is used to fetch only a certain number of fields
69798>>>>>>>>>>>/// while doing a "find". When specifying the field number to start from and
69798>>>>>>>>>>>/// field number to end on, the find will only fetch the given fields from the
69798>>>>>>>>>>>/// record. It is important to always use this command after first deselecting
69798>>>>>>>>>>>/// all columns i.e. setting RESET_FETCH_FIELDS to DF_FETCH_FALSE. Also, after
69798>>>>>>>>>>>/// using this command, all columns need to be reselected i.e. setting
69798>>>>>>>>>>>/// RESET_FETCH_FIELDS to DF_FETCH_TRUE. Note that fields used as a part the
69798>>>>>>>>>>>/// index segment associated with the find will always be fetched regardless.
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Assumptions
69798>>>>>>>>>>>/// @Status      Public
69798>>>>>>>>>>>/// @Drivers     All
69798>>>>>>>>>>>/// @VersionNote Last Revised: 20014-04-30 by Marcello Yo
69798>>>>>>>>>>>/// @See         RESET_FETCH_FIELDS DISABLE_SELECT_COLUMNS_ERRORS
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Syntax SELECT_COLUMNS_FIND {FileNumber} {fieldStart} THRU {fieldEnd}
69798>>>>>>>>>>>/// @Param  FileNumber          The number of the file
69798>>>>>>>>>>>/// @Param  fieldStart          The field number to start the fetch from
69798>>>>>>>>>>>/// @Param  FieldEnd            The field number to end the fetch at
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Example
69798>>>>>>>>>>>/// Open Customer
69798>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
69798>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
69798>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// Clear Customer
69798>>>>>>>>>>>/// Repeat
69798>>>>>>>>>>>///    Find Gt Customer by Index.1
69798>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
69798>>>>>>>>>>>/// Until (Not(Found))
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
69798>>>>>>>>>>>
69798>>>>>>>>>>>
69798>>>>>>>>>>>//=============================================================================
69798>>>>>>>>>>>/// @Name        RESET_FETCH_FIELDS
69798>>>>>>>>>>>/// @Description This command is used to specify whether to retrieve all columns
69798>>>>>>>>>>>/// or no columns when performing a find. It is usually used with the command
69798>>>>>>>>>>>/// SELECT_COLUMNS_FIND to reset the column fetching. This command can either be
69798>>>>>>>>>>>/// set to DF_FETCH_TRUE, which will fetch all columns or set to DF_FETCH_FALSE,
69798>>>>>>>>>>>/// which will fetch no columns.
69798>>>>>>>>>>>/// @Assumptions
69798>>>>>>>>>>>/// @Status      Public
69798>>>>>>>>>>>/// @Drivers     All
69798>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Marcello Yo
69798>>>>>>>>>>>/// @See         SELECT_COLUMNS_FIND DISABLE_SELECT_COLUMNS_ERRORS
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Syntax RESET_FETCH_FIELDS {FileNumber} {DF_FETCH_TRUE/DF_FETCH_FALSE}
69798>>>>>>>>>>>/// @Param  FileNumber                  The number of the file
69798>>>>>>>>>>>/// @Param  DF_FETCH_TRUE               fetch all columns
69798>>>>>>>>>>>/// @Param  DF_FETCH_FALSE              fetch no columns
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Example
69798>>>>>>>>>>>/// Open Customer
69798>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
69798>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
69798>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// Clear Customer
69798>>>>>>>>>>>/// Repeat
69798>>>>>>>>>>>///    Find Gt Customer by Index.1
69798>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
69798>>>>>>>>>>>/// Until (Not(Found))
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
69798>>>>>>>>>>>
69798>>>>>>>>>>>//=============================================================================
69798>>>>>>>>>>>/// @Name        SQL_FOR_ONEROW
69798>>>>>>>>>>>/// @Description This command will instruct the driver to fetch one row
69798>>>>>>>>>>>/// per query
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Assumptions
69798>>>>>>>>>>>/// @Status      Deprecated
69798>>>>>>>>>>>/// @Drivers     All
69798>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
69798>>>>>>>>>>>/// @See
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Syntax SQL_FOR_ONEROW {FileNumber}
69798>>>>>>>>>>>/// @Param  FileNumber          The number of the file
69798>>>>>>>>>>>/// @Example
69798>>>>>>>>>>>///     open Customer
69798>>>>>>>>>>>///     SQL_FOR_ONEROW Customer.File_Number
69798>>>>>>>>>>>///     Repeat
69798>>>>>>>>>>>///             find gt Customer by Recnum
69798>>>>>>>>>>>///         If (Found) Begin
69798>>>>>>>>>>>///             showln "Sales name is " Customer.FirstName
69798>>>>>>>>>>>///         end
69798>>>>>>>>>>>///     until (Customer.ID = 10)
69798>>>>>>>>>>>
69798>>>>>>>>>>>//=============================================================================
69798>>>>>>>>>>>/// @Name        SQL_REFRESH_CACHE
69798>>>>>>>>>>>/// @Description For optimization during record retrieval, a set number of
69798>>>>>>>>>>>/// records are stored in a local cache. This command forces a refresh, by
69798>>>>>>>>>>>/// making the next find retrieve the record from the database instead of
69798>>>>>>>>>>>/// the cache.
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Assumptions
69798>>>>>>>>>>>/// @Status      Public
69798>>>>>>>>>>>/// @Drivers     All
69798>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
69798>>>>>>>>>>>/// @See
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Syntax SQL_REFRESH_CACHE OF {FileNumber}
69798>>>>>>>>>>>/// @Param  FileNumber          The number of the file
69798>>>>>>>>>>>/// @Example
69798>>>>>>>>>>>/// Open Customer
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// Find gt Customer by Index.1
69798>>>>>>>>>>>/// While (Found) Begin
69798>>>>>>>>>>>///     showln "Customer name is " CUSTOMER.CUSTOMER
69798>>>>>>>>>>>/// Loop
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// SQL_REFRESH_CACHE of CUSTOMER
69798>>>>>>>>>>>
69798>>>>>>>>>>>//=============================================================================
69798>>>>>>>>>>>/// @Name        SQL_FOR_SET
69798>>>>>>>>>>>/// @Description Use this command during LT or GT finds to only fetch a set
69798>>>>>>>>>>>/// number of rows. An option is also available for this command to disable
69798>>>>>>>>>>>/// the local cash by passing NOCACHE at the end of the command call. Note
69798>>>>>>>>>>>/// that if the rowcount is set low, too many round-trips to the server may
69798>>>>>>>>>>>/// result, effecting performance significantly. Also, if the rowcount is set
69798>>>>>>>>>>>/// too high a large number of records can be pre-fetched and end up not being
69798>>>>>>>>>>>/// used by the application. Because of this, the default of 10 rows and a cache
69798>>>>>>>>>>>/// will be adequate for most situations.
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Assumptions
69798>>>>>>>>>>>/// @Status      Public
69798>>>>>>>>>>>/// @Drivers     All
69798>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
69798>>>>>>>>>>>/// @See
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Syntax SQL_FOR_SET {FileNumber} MAXROWS {variable} {CACHE/NOCACHE}
69798>>>>>>>>>>>/// @Param  FileNumber          The number of the file
69798>>>>>>>>>>>/// @Param  variable            The maximum number of rows to retrieve
69798>>>>>>>>>>>/// @Param  CACHE               fetched rows will be kept at the local cache
69798>>>>>>>>>>>/// @Param  NOCACHE             fetched rows will not be kept at the local cache
69798>>>>>>>>>>>/// @Example
69798>>>>>>>>>>>/// Open Customer
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// SQL_FOR_SET Customer MAXROWS 15 CACHE
69798>>>>>>>>>>>/// find gt Customer by Index.1
69798>>>>>>>>>>>
69798>>>>>>>>>>>//=============================================================================
69798>>>>>>>>>>>/// @Name        SQL_SET
69798>>>>>>>>>>>/// @Description Initializes and sets an initial statement for embedded
69798>>>>>>>>>>>/// sql execution.
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
69798>>>>>>>>>>>/// @Status      Deprecated
69798>>>>>>>>>>>/// @Drivers     All
69798>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
69798>>>>>>>>>>>/// @See         SQL_SET_STMT
69798>>>>>>>>>>>///
69798>>>>>>>>>>>/// @Syntax SQL_SET {FileNumber}
69798>>>>>>>>>>>/// @Param  FileNumber          The number of the file
69798>>>>>>>>>>>
69798>>>>>>>>>>>Procedure MertechInc_SQL_SET Global String sStatement
69800>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 1 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
69805>>>>>>>>>>>End_Procedure
69806>>>>>>>>>>>
69806>>>>>>>>>>>//=============================================================================
69806>>>>>>>>>>>/// @Name        SQL_APPEND
69806>>>>>>>>>>>/// @Description Appends a string value to the current embedded sql statement
69806>>>>>>>>>>>/// already set.
69806>>>>>>>>>>>///
69806>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
69806>>>>>>>>>>>/// @Status      Deprecated
69806>>>>>>>>>>>/// @Drivers     All
69806>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
69806>>>>>>>>>>>/// @See                 SQL_APPEND_STMT
69806>>>>>>>>>>>
69806>>>>>>>>>>>Procedure MertechInc_SQL_APPEND Global String sStatement
69808>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 2 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
69813>>>>>>>>>>>End_Procedure
69814>>>>>>>>>>>
69814>>>>>>>>>>>//=============================================================================
69814>>>>>>>>>>>/// @Name        SQL_EXECUTE
69814>>>>>>>>>>>/// @Description Executes the current embedded SQL statement set and commits
69814>>>>>>>>>>>/// finishing any pending transaction.
69814>>>>>>>>>>>///
69814>>>>>>>>>>>/// @Assumptions
69814>>>>>>>>>>>/// @Status      Deprecated
69814>>>>>>>>>>>/// @Drivers     All
69814>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
69814>>>>>>>>>>>/// @See                 SQL_EXECUTE_STMT
69814>>>>>>>>>>>
69814>>>>>>>>>>>//=============================================================================
69814>>>>>>>>>>>/// @Name        LOCK_TABLE
69814>>>>>>>>>>>/// @Description Locks a table. This is equivalent to locking a DAT file.
69814>>>>>>>>>>>///
69814>>>>>>>>>>>/// @Assumptions
69814>>>>>>>>>>>/// @Status      Deprecated
69814>>>>>>>>>>>/// @Drivers     DB2Flex, and ORAFlex 3.x
69814>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
69814>>>>>>>>>>>/// @See
69814>>>>>>>>>>>///
69814>>>>>>>>>>>/// @Syntax LOCK_TABLE {FileName} {FileName1} {FileName2} {FileName3}...
69814>>>>>>>>>>>/// @Param  FileName            The name of file to be locked. Can be more than one
69814>>>>>>>>>>>
69814>>>>>>>>>>>//=============================================================================
69814>>>>>>>>>>>/// @Name        SQL_CHECK_TABLE
69814>>>>>>>>>>>/// @Description Use this command to verify that a given table exists on the
69814>>>>>>>>>>>/// SQL backend. This command takes three arguments, a string containing the
69814>>>>>>>>>>>/// name of the database, a string containing the name of the user and finally
69814>>>>>>>>>>>/// a string containing the name of the table being checked. If the table exists,
69814>>>>>>>>>>>/// the program proceeds normally. If the table does not exist then the flag
69814>>>>>>>>>>>/// "finderr" is set to true. Note that in order to handle the error a check must
69814>>>>>>>>>>>/// be done on the "finderr" variable.
69814>>>>>>>>>>>///
69814>>>>>>>>>>>/// @Assumptions All three parameters are less than 256 characters long.
69814>>>>>>>>>>>/// @Status      Public
69814>>>>>>>>>>>/// @Drivers     All
69814>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
69814>>>>>>>>>>>/// @See
69814>>>>>>>>>>>///
69814>>>>>>>>>>>/// @Syntax SQL_CHECK_TABLE {database} {username} {table}
69814>>>>>>>>>>>/// @Param  database            Name of the database
69814>>>>>>>>>>>/// @Param  username            Name of the user
69814>>>>>>>>>>>/// @Param  table                       Name of the table being checked
69814>>>>>>>>>>>///
69814>>>>>>>>>>>/// @Example
69814>>>>>>>>>>>/// SQL_CHECK_TABLE "testDB" "user" "Customer"
69814>>>>>>>>>>>/// If (finderr) Begin
69814>>>>>>>>>>>///     Showln "This table does not exist"
69814>>>>>>>>>>>/// End
69814>>>>>>>>>>>
69814>>>>>>>>>>>//=============================================================================
69814>>>>>>>>>>>/// @Name        SET_SQL_CONSTRAINT
69814>>>>>>>>>>>/// @Description This command allows you to put an additional constraint on
69814>>>>>>>>>>>/// your finds, moving filtering to the SQL backend. Using this command can
69814>>>>>>>>>>>/// result in significantly improved performance, since the server network traffic
69814>>>>>>>>>>>/// reduced. Note that the SQL statement passed for this command is added onto
69814>>>>>>>>>>>/// the predefined Database SQL statement so treat it as such. Because of this,
69814>>>>>>>>>>>/// it will almost always begin with "AND" followed by the desired constraint.
69814>>>>>>>>>>>///
69814>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
69814>>>>>>>>>>>/// @Status      Public
69814>>>>>>>>>>>/// @Drivers     All
69814>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
69814>>>>>>>>>>>/// @See         SQL_CONSTRAINT GET_SQL_CONSTRAINT DF_FIELD_PROGRAMMATIC_DEFAULT
69814>>>>>>>>>>>///
69814>>>>>>>>>>>/// @Syntax SET_SQL_CONSTRAINT of {file} to {variable}
69814>>>>>>>>>>>/// @Param  file                        Name or Number of the file.
69814>>>>>>>>>>>/// @Param  variable            A SQL expression that constrains the data
69814>>>>>>>>>>>///
69814>>>>>>>>>>>/// @Example
69814>>>>>>>>>>>/// Open Customer
69814>>>>>>>>>>>///
69814>>>>>>>>>>>/// SET_SQL_CONSTRAINT of 1 to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
69814>>>>>>>>>>>///
69814>>>>>>>>>>>/// For_All Customer by Index.1 do
69814>>>>>>>>>>>///     Showln Customer.FirstName
69814>>>>>>>>>>>/// End_For_All
69814>>>>>>>>>>>
69814>>>>>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT Global Integer iFunction String sConstraint
69816>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 0 RESULT MertechInc_iRet
69821>>>>>>>>>>>End_Procedure
69822>>>>>>>>>>>
69822>>>>>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT_PROGRAMMATIC Global Integer iFunction
69824>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 4 RESULT MertechInc_iRet
69829>>>>>>>>>>>End_Procedure
69830>>>>>>>>>>>
69830>>>>>>>>>>>//=============================================================================
69830>>>>>>>>>>>/// @Name        GET_SQL_CONSTRAINT
69830>>>>>>>>>>>/// @Description This command returns the current SQL constraint for the given
69830>>>>>>>>>>>/// table.  If there is no current constraint, then a blank string is returned.
69830>>>>>>>>>>>///
69830>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
69830>>>>>>>>>>>/// @Status      Public
69830>>>>>>>>>>>/// @Drivers     All
69830>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
69830>>>>>>>>>>>/// @See         SQL_CONSTRAINT SET_SQL_CONSTRAINT
69830>>>>>>>>>>>///
69830>>>>>>>>>>>/// @Syntax GET_SQL_CONSTRAINT of {File} to {variable}
69830>>>>>>>>>>>/// @Param  File                        Name or number of the file
69830>>>>>>>>>>>/// @Param  variable            The string containing the constraining SQL expression
69830>>>>>>>>>>>///
69830>>>>>>>>>>>/// @Example
69830>>>>>>>>>>>/// Open Customer
69830>>>>>>>>>>>///
69830>>>>>>>>>>>/// String sCon
69830>>>>>>>>>>>///
69830>>>>>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
69830>>>>>>>>>>>/// GET_SQL_CONSTRAINT of Customer to sCon
69830>>>>>>>>>>>///
69830>>>>>>>>>>>/// For_All Customer by Index.1 do
69830>>>>>>>>>>>///     Showln Customer.FirstName
69830>>>>>>>>>>>///     Showln sCon
69830>>>>>>>>>>>/// End_For_All
69830>>>>>>>>>>>
69830>>>>>>>>>>>Function MertechInc_GET_SQL_CONSTRAINT Global Integer iFunction Returns String
69832>>>>>>>>>>>    String sConstraint
69832>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sConstraint
69833>>>>>>>>>>>
69833>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 3 RESULT MertechInc_iRet
69838>>>>>>>>>>>    Function_Return sConstraint
69839>>>>>>>>>>>End_Function
69840>>>>>>>>>>>
69840>>>>>>>>>>>//=============================================================================
69840>>>>>>>>>>>/// @Name        SQL_CONSTRAINT
69840>>>>>>>>>>>/// @Description This command is used to toggle on or off the current SQL
69840>>>>>>>>>>>/// constraint that is set for a table. To deactivate the current constraint,
69840>>>>>>>>>>>/// pass the constant DEACTIVATE to this command. to reactivate the constraint,
69840>>>>>>>>>>>/// pass ACTIVATE to this command.
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// @Status      Public
69840>>>>>>>>>>>/// @Drivers     All
69840>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
69840>>>>>>>>>>>/// @See         SET_SQL_CONSTRAINT GET_SQL_CONSTRAINT
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// @Syntax SQL_CONSTRAINT of {File} to {Activate|Deactivate}
69840>>>>>>>>>>>/// @Param  File                        Name or Number of the file
69840>>>>>>>>>>>/// @Param  Activate            Activates the constraint
69840>>>>>>>>>>>/// @Param  Deactivate          Deactivates the constraint
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// @Example
69840>>>>>>>>>>>/// Open Customer
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "FirstName", "Aaron"))
69840>>>>>>>>>>>/// SQL_CONSTRAINT of Customer to Deactivate
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// For_All Customer by Index.1 do
69840>>>>>>>>>>>///     Showln Customer.FirstName
69840>>>>>>>>>>>/// End_For_All
69840>>>>>>>>>>>
69840>>>>>>>>>>>//=============================================================================
69840>>>>>>>>>>>/// @Name        CREATE_TD_FILE
69840>>>>>>>>>>>/// @Description A .TD file is created when the attribute is set to True.
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// @Assumptions
69840>>>>>>>>>>>/// @Status      Deprecated
69840>>>>>>>>>>>/// @Drivers     All
69840>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
69840>>>>>>>>>>>/// @See
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// @Syntax CREATE_TD_FILE {variable}
69840>>>>>>>>>>>/// @Param  variable            True to create the .TD file, false doesn't create it.
69840>>>>>>>>>>>
69840>>>>>>>>>>>//=============================================================================
69840>>>>>>>>>>>/// @Name        OPEN_INT
69840>>>>>>>>>>>/// @Description This command is used to replace the OPEN command in DataFlex.
69840>>>>>>>>>>>/// It can be useful when accessing tables that are not in the current filelist.
69840>>>>>>>>>>>/// To access these tables, the INT and FD files must be in the directory. From
69840>>>>>>>>>>>/// there, all that is needed is to open the table using this command under an
69840>>>>>>>>>>>/// alias name. If the command is executed successfully then the table can be
69840>>>>>>>>>>>/// queried normally as if it were a standard table. Note that if the desired
69840>>>>>>>>>>>/// table is already in the filelist or doesn't have an INT file then this
69840>>>>>>>>>>>/// command will act as a normal open command.
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// @Assumptions
69840>>>>>>>>>>>/// @Status      Public
69840>>>>>>>>>>>/// @Drivers     All
69840>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
69840>>>>>>>>>>>/// @See
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// @Syntax OPEN_INT {variable} as {aliasName}
69840>>>>>>>>>>>/// @Param  variable            The name of the int file without the extension.
69840>>>>>>>>>>>/// @Param  aliasName           The alias name being used to query this table.
69840>>>>>>>>>>>/// @Example
69840>>>>>>>>>>>/// OPEN_INT "customer" as Customer
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// For_All Customer by Index.1 do
69840>>>>>>>>>>>///     Showln Customer.FirstName
69840>>>>>>>>>>>/// End_For_All
69840>>>>>>>>>>>
69840>>>>>>>>>>>//=============================================================================
69840>>>>>>>>>>>/// @Name        SET_OPEN_MODE
69840>>>>>>>>>>>/// @Description This command is used to enable an option known as "Lazy Open
69840>>>>>>>>>>>/// Mode". When turned on the table's metadata i.e. table, columns, index
69840>>>>>>>>>>>/// descriptions, is deferred until a field is accessed, even if a OPEN has
69840>>>>>>>>>>>/// already been done. This can significantly improve an application's initial
69840>>>>>>>>>>>/// performance, especially when a large number of files are opened when the
69840>>>>>>>>>>>/// program is launched. By default, tables are set to open normally, but by
69840>>>>>>>>>>>/// passing the constant LAZY_MODE to this command, it can be altered to use
69840>>>>>>>>>>>/// this mode. Note that when this mode is activated, it effects all tables
69840>>>>>>>>>>>/// that are opened. To deactivate this feature, pass the constant "DEFAULT"
69840>>>>>>>>>>>/// to this command at any time. This is the preferred method to activate or
69840>>>>>>>>>>>/// deactive this feature but it can also be set globally in the .INI file.
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// Default Value: DEFAULT (Off)
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// @Assumptions
69840>>>>>>>>>>>/// @Status      Public
69840>>>>>>>>>>>/// @Drivers     All
69840>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
69840>>>>>>>>>>>/// @See
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// @Syntax SET_OPEN_MODE to {DEFAULT/LAZY_MODE}
69840>>>>>>>>>>>/// @Param  DEFAULT                     Used to turn of the lazy mode feature.
69840>>>>>>>>>>>/// @Param  LAZY_MODE           Turns on the lazy mode feature
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// @Example
69840>>>>>>>>>>>/// SET_OPEN_MODE TO LAZY_MODE
69840>>>>>>>>>>>/// Open "customer.int" as Customer
69840>>>>>>>>>>>/// ...
69840>>>>>>>>>>>/// ...
69840>>>>>>>>>>>/// Find gt Customer by Index.1
69840>>>>>>>>>>>
69840>>>>>>>>>>>//=============================================================================
69840>>>>>>>>>>>/// @Name        SQL_SET_STMT
69840>>>>>>>>>>>/// @Description Use this command to set an SQL statement to be executed on the
69840>>>>>>>>>>>/// desired table. The string passed to this command must be a valid SQL
69840>>>>>>>>>>>/// expression and must be on a table that has already been opened. Note that
69840>>>>>>>>>>>/// when using this command, the SQL_PREPARE_STMT and SQL_EXECUTE_STMT must be
69840>>>>>>>>>>>/// used in addition to carry out the expression. The option to pass the file
69840>>>>>>>>>>>/// name as an extra parameter is used in cases where the data needs to be
69840>>>>>>>>>>>/// fetched directly into the record buffer of the specified file.
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
69840>>>>>>>>>>>/// @Status      Public
69840>>>>>>>>>>>/// @Drivers     All
69840>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
69840>>>>>>>>>>>/// @See                 SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// @Syntax SQL_SET_STMT [of {file}] to {variable}
69840>>>>>>>>>>>/// @Param file                         Name or number of the file (optional)
69840>>>>>>>>>>>/// @Param variable                     String containing the SQL statement
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// @Usage SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
69840>>>>>>>>>>>/// @Usage SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// @Example
69840>>>>>>>>>>>/// Open Customer
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// String sID sFirstName sLastName sDOB
69840>>>>>>>>>>>///
69840>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
69840>>>>>>>>>>>/// SQL_PREPARE_STMT
69840>>>>>>>>>>>/// SQL_EXECUTE_STMT
69840>>>>>>>>>>>/// While (Found)
69840>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
69840>>>>>>>>>>>///     Showln sID
69840>>>>>>>>>>>///     Showln sFirstName
69840>>>>>>>>>>>///     Showln sLastName
69840>>>>>>>>>>>///     Showln sDOB
69840>>>>>>>>>>>/// Loop
69840>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
69840>>>>>>>>>>>
69840>>>>>>>>>>>Procedure MertechInc_SQL_SET_STMT Global String sStatment
69842>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatment 0 RESULT MertechInc_iRet
69847>>>>>>>>>>>End_Procedure
69848>>>>>>>>>>>
69848>>>>>>>>>>>//=============================================================================
69848>>>>>>>>>>>/// @Name        SQL_APPEND_STMT
69848>>>>>>>>>>>/// @Description This command is used to append a command string to the
69848>>>>>>>>>>>/// command buffer initialized by SQL_SET_STMT. SQL_APPEND_STMT was added
69848>>>>>>>>>>>/// so that long SQL expressions could be broken into smaller strings and
69848>>>>>>>>>>>/// appended to a dynamic command buffer, which is then passed to the server.
69848>>>>>>>>>>>/// The SQL_APPEND_STMT will concatenate a string to the command buffer
69848>>>>>>>>>>>/// initialized by the SQL_SET_STMT command. SQL_APPEND_STMT can be called as
69848>>>>>>>>>>>/// many times as necessary to complete the SQL expression. Subsequently, the
69848>>>>>>>>>>>/// SQL_EXECUTE_STMT command executes the completed command.  The option to
69848>>>>>>>>>>>/// pass the file name as an extra parameter is used in cases where the data
69848>>>>>>>>>>>/// needs to be fetched directly into the record buffer of the specified file.
69848>>>>>>>>>>>///
69848>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
69848>>>>>>>>>>>/// @Status      Public
69848>>>>>>>>>>>/// @Drivers     All
69848>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-22 by Aaron Gulack
69848>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
69848>>>>>>>>>>>///
69848>>>>>>>>>>>/// @Syntax SQL_APPEND_STMT [of {file}] to {variable}
69848>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
69848>>>>>>>>>>>/// @Param variable                     The string to be appended to the current SQL expression
69848>>>>>>>>>>>///
69848>>>>>>>>>>>/// @Usage SQL_APPEND_STMT to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
69848>>>>>>>>>>>/// @Usage SQL_APPEND_STMT of Customer to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
69848>>>>>>>>>>>///
69848>>>>>>>>>>>/// @Example
69848>>>>>>>>>>>/// Open Customer
69848>>>>>>>>>>>///
69848>>>>>>>>>>>/// String sID sFirstName sLastName sDOB
69848>>>>>>>>>>>///
69848>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
69848>>>>>>>>>>>/// SQL_PREPARE_STMT
69848>>>>>>>>>>>/// SQL_EXECUTE_STMT
69848>>>>>>>>>>>/// While (Found)
69848>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
69848>>>>>>>>>>>///     Showln sID
69848>>>>>>>>>>>///     Showln sFirstName
69848>>>>>>>>>>>///     Showln sLastName
69848>>>>>>>>>>>///     Showln sDOB
69848>>>>>>>>>>>/// Loop
69848>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
69848>>>>>>>>>>>
69848>>>>>>>>>>>Procedure MertechInc_SQL_APPEND_STMT Global String sStatement
69850>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
69855>>>>>>>>>>>End_Procedure
69856>>>>>>>>>>>
69856>>>>>>>>>>>//=============================================================================
69856>>>>>>>>>>>/// @Name        APPEND_UPDATE_COLUMN
69856>>>>>>>>>>>/// @Description Append a given string to the existing SQL statement
69856>>>>>>>>>>>/// already set.
69856>>>>>>>>>>>///
69856>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method
69856>>>>>>>>>>>/// @Status      Internal
69856>>>>>>>>>>>/// @Drivers     All
69856>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
69856>>>>>>>>>>>/// @See
69856>>>>>>>>>>>///
69856>>>>>>>>>>>/// @Syntax APPEND_UPDCOL_STMT {variable} for {fileName}.{fieldName} {fields...}
69856>>>>>>>>>>>/// @Param variable                             SQL expression to be appended
69856>>>>>>>>>>>/// @Param fileName                             Name of the file
69856>>>>>>>>>>>/// @Param fieldName                    Name of the field
69856>>>>>>>>>>>/// @Param fields...                    Any additional fields, use the file.field format
69856>>>>>>>>>>>
69856>>>>>>>>>>>Procedure MertechInc_APPEND_UPDATE_COLUMN Global String sStatement
69858>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
69863>>>>>>>>>>>End_Procedure
69864>>>>>>>>>>>
69864>>>>>>>>>>>//=============================================================================
69864>>>>>>>>>>>/// @Name        SQL_APPEND_UPDCOL_STMT
69864>>>>>>>>>>>/// @Description Used to optimize the update process of columns being loaded
69864>>>>>>>>>>>/// with the same value.
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Assumptions
69864>>>>>>>>>>>/// @Status      Deprecated
69864>>>>>>>>>>>/// @Drivers     All
69864>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
69864>>>>>>>>>>>/// @See
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Syntax SQL_APPEND_UPDCOL_STMT [of {file}] Value {variable} for {fileName}.{fieldName} {fields...}
69864>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
69864>>>>>>>>>>>/// @Param variable                     The value being uploaded
69864>>>>>>>>>>>/// @Param fileName                     The name of the file
69864>>>>>>>>>>>/// @Param fieldName            The name of the field
69864>>>>>>>>>>>/// @Param fields...            Any additional fields, use the file.field format
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Example
69864>>>>>>>>>>>/// Open Customer
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// SQL_SET_STMT    of Customer to "UPDATE CUSTOMER SET"
69864>>>>>>>>>>>/// SQL_APPEND_STMT of Customer to " ASC11='x', ASC12='y', ASC13='z'"
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// SQL_APPEND_UPDCOL_STMT of Customer value 0 ;
69864>>>>>>>>>>>///     for Customer.ID Customer.Purchases Customer.Credit ;
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// SQL_APPEND_STMT of Customer to " WHERE RECNUM=1"
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// SQL_PREPARE_STMT of Customer
69864>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
69864>>>>>>>>>>>
69864>>>>>>>>>>>//=============================================================================
69864>>>>>>>>>>>/// @Name        SQL_SET_CURSOR_TYPE
69864>>>>>>>>>>>/// @Description Specify the SQL cursor type to be used during the next
69864>>>>>>>>>>>/// embedded SQL statement execution.
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Assumptions
69864>>>>>>>>>>>/// @Status      Internal
69864>>>>>>>>>>>/// @Drivers     SQLFlex
69864>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
69864>>>>>>>>>>>/// @See
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Syntax SQL_SET_CURSOR_TYPE to {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
69864>>>>>>>>>>>/// @Param TYPE_NONE                    the default cursor type should be used
69864>>>>>>>>>>>/// @Param TYPE_CLIENT                  a client side cursor should be used
69864>>>>>>>>>>>/// @Param TYPE_SERVER                  a server side cursor should be used
69864>>>>>>>>>>>
69864>>>>>>>>>>>//=============================================================================
69864>>>>>>>>>>>/// @Name        CLEAR_INT_CACHE
69864>>>>>>>>>>>/// @Description Clears all memory-cached INT info. This is used in the
69864>>>>>>>>>>>/// test framework to force a "reload" of int info which the framework
69864>>>>>>>>>>>/// modifies for its tests. This is a different cache than the TD files
69864>>>>>>>>>>>/// which are a file based cache of the structure for use at file open.
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Assumptions
69864>>>>>>>>>>>/// @Status      Internal
69864>>>>>>>>>>>/// @Drivers     All
69864>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
69864>>>>>>>>>>>/// @See
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Syntax CLEAR_INT_CACHE
69864>>>>>>>>>>>
69864>>>>>>>>>>>//=============================================================================
69864>>>>>>>>>>>/// @Name        CREATE_INVERSE_KEY_FUNCTIONS
69864>>>>>>>>>>>/// @Description Create SQL Functions to handle Inverse Key columns.
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Assumptions
69864>>>>>>>>>>>/// @Status      Internal
69864>>>>>>>>>>>/// @Drivers     All (v10.1 and above)
69864>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
69864>>>>>>>>>>>/// @See
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Syntax CREATE_INVERSE_KEY_FUNCTIONS
69864>>>>>>>>>>>
69864>>>>>>>>>>>//=============================================================================
69864>>>>>>>>>>>/// @Name        SQL_PREPARE_STMT
69864>>>>>>>>>>>/// @Description Prepares a statement and opens a cursor to be executed by
69864>>>>>>>>>>>/// SQL_EXECUTE_STMT. This command tells the server to parse the SQL statement
69864>>>>>>>>>>>/// created by the respective SQL_SET_STMT and all subsequent SQL_APPEND_STMT
69864>>>>>>>>>>>/// statements and to allocate cursor handles to be used to fetch the data.
69864>>>>>>>>>>>/// A cursor can be thought of as a pointer to a record set. The CURSOR_TYPE
69864>>>>>>>>>>>/// argument is only supported by SQLFlex and by default SQLFLex is using a
69864>>>>>>>>>>>/// TYPE_SERVER cursor type to all embedded SQL. TYPE_CLIENT should be used only
69864>>>>>>>>>>>/// for the statements that are querying LOB columns i.e. TEXT, NVARCHAR(MAX),
69864>>>>>>>>>>>/// VARCHAR(MAX), IMAGE, VARBINARY(MAX), XML. If the cursor type is
69864>>>>>>>>>>>/// TYPE_SERVER and a LOB type column is selected, MS SQL Server will not be
69864>>>>>>>>>>>/// able to get into a transaction, either explicitly or implicitly through a
69864>>>>>>>>>>>/// REREAD, LOCK, SAVERECORD, etc.
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Assumptions
69864>>>>>>>>>>>/// @Status      Public
69864>>>>>>>>>>>/// @Drivers     All
69864>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
69864>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Syntax SQL_PREPARE_STMT [of {file}] CURSOR_TYPE {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
69864>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
69864>>>>>>>>>>>/// @Param CURSOR_TYPE          Used if the cursor type is being set, do not include otherwise
69864>>>>>>>>>>>/// @Param TYPE_NONE            Default cursor will be used
69864>>>>>>>>>>>/// @Param TYPE_CLIENT          A client side cursor should be used
69864>>>>>>>>>>>/// @Param TYPE_SERVER          A server side cursor should be used (Default)
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT
69864>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer
69864>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT CURSOR_TYPE TYPE_SERVER
69864>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer CURSOR_TYPE TYPE_CLIENT
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Example
69864>>>>>>>>>>>/// Open Customer
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// String sID sFirstName
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
69864>>>>>>>>>>>/// SQL_PREPARE_STMT
69864>>>>>>>>>>>/// SQL_EXECUTE_STMT
69864>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName
69864>>>>>>>>>>>
69864>>>>>>>>>>>//=============================================================================
69864>>>>>>>>>>>/// @Name        SQL_BIND_COLUMN
69864>>>>>>>>>>>/// @Description Clears all cached INT info. This should be merged with
69864>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT, but has to remain as a separate command for
69864>>>>>>>>>>>/// compatibility.
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Assumptions
69864>>>>>>>>>>>/// @Status      Internal
69864>>>>>>>>>>>/// @Drivers     All
69864>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
69864>>>>>>>>>>>/// @See
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Syntax SQL_BIND_COLUMN FileNumber FieldNumber | DF_BIND_ALL_COLUMNS
69864>>>>>>>>>>>/// @Param FileNumber                   The number of the file
69864>>>>>>>>>>>/// @Param FieldNumber                  The number of the field
69864>>>>>>>>>>>
69864>>>>>>>>>>>//=============================================================================
69864>>>>>>>>>>>/// @Name        SQL_BINDCOLUMNS_STMT
69864>>>>>>>>>>>/// @Description This command is used to fetch the returned data of a
69864>>>>>>>>>>>/// specified SQL expression into the given field in the record buffer. By
69864>>>>>>>>>>>/// passing any number of fields to this command, the fetched record will then
69864>>>>>>>>>>>/// be put into the subsequent fields in the record buffer. The order of the
69864>>>>>>>>>>>/// fields must be the same as the order of the columns being retrieved from
69864>>>>>>>>>>>/// the SQL expression. SQL_FETCH_NEXT_ROW can then be called to take the data
69864>>>>>>>>>>>/// retrieved from the server and place it into the corresponding fields in the
69864>>>>>>>>>>>/// buffer. Instead of specifying each field, DF_BIND_ALL_COLUMNS can be passed,
69864>>>>>>>>>>>/// which will retrieve every column in the table.
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Assumptions
69864>>>>>>>>>>>/// @Status      Public
69864>>>>>>>>>>>/// @Drivers     All
69864>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
69864>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Syntax SQL_BINDCOLUMNS_STMT of {file} to {field/DF_BIND_ALL_COLUMNS}
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Param file                 Name or number of the file
69864>>>>>>>>>>>/// @Param field                        Name or number of the field (can be multiple)
69864>>>>>>>>>>>/// @Param DF_BIND_ALL_COLUMNS  Used instead of the field to retrieve all columns in the file
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Example
69864>>>>>>>>>>>/// Open Customer
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
69864>>>>>>>>>>>/// SQL_PREPARE_STMT
69864>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
69864>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
69864>>>>>>>>>>>/// While (Found)
69864>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
69864>>>>>>>>>>>///     Showln Customer.ID
69864>>>>>>>>>>>///     Showln Customer.FirstName
69864>>>>>>>>>>>///     Showln Customer.LastName
69864>>>>>>>>>>>///     Showln Customer.DOB
69864>>>>>>>>>>>/// Loop
69864>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
69864>>>>>>>>>>>
69864>>>>>>>>>>>//=============================================================================
69864>>>>>>>>>>>/// @Name        SQL_EXECUTE_STMT
69864>>>>>>>>>>>/// @Description This command is used to execute the SQL expression created
69864>>>>>>>>>>>/// by the SQL_SET_STMT and any subsequent SQL_APPEND_STMT commands issued
69864>>>>>>>>>>>/// after a SQL_PREPARE_STMT. If the results will be sent to the record
69864>>>>>>>>>>>/// buffer directly, then the file must be specified. An optional parameter
69864>>>>>>>>>>>/// can also be passed, indicating the maximum number of rows to be sent to
69864>>>>>>>>>>>/// the local cache. This is done by adding the constant ROWCOUNT followed
69864>>>>>>>>>>>/// by the maximun number.
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Assumptions
69864>>>>>>>>>>>/// @Status      Public
69864>>>>>>>>>>>/// @Drivers     All
69864>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
69864>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Syntax SQL_EXECUTE_STMT [of {file} ROWCOUNT {variable}]
69864>>>>>>>>>>>/// @Param file                         Name or number of the file (optional)
69864>>>>>>>>>>>/// @Param variable                     Maximum number of rows to send to the local cache (optional)
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT
69864>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer
69864>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer ROWCOUNT 10
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// @Example
69864>>>>>>>>>>>/// Open Customer
69864>>>>>>>>>>>///
69864>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
69864>>>>>>>>>>>/// SQL_PREPARE_STMT
69864>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
69864>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
69864>>>>>>>>>>>/// While (Found)
69864>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
69864>>>>>>>>>>>///     Showln Customer.ID
69864>>>>>>>>>>>///     Showln Customer.FirstName
69864>>>>>>>>>>>///     Showln Customer.LastName
69864>>>>>>>>>>>///     Showln Customer.DOB
69864>>>>>>>>>>>/// Loop
69864>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
69864>>>>>>>>>>>
69864>>>>>>>>>>>
69864>>>>>>>>>>>//This alias may be redundant. Is was only called from MertechInc_SQL_FUNCTION_EXECUTE
69864>>>>>>>>>>>//which has been recoded to directly call SQL_EXECUTE_STMT - I.S. 2009-09-19
69864>>>>>>>>>>>Procedure MertechInc_SQL_PROCEDURE_EXECUTE Global
69866>>>>>>>>>>>    SQL_EXECUTE_STMT
69906>>>>>>>>>>>End_Procedure
69907>>>>>>>>>>>
69907>>>>>>>>>>>//=============================================================================
69907>>>>>>>>>>>/// @Name        SQL_START_TRANSACTION_STMT
69907>>>>>>>>>>>/// @Description Transactions in SQL are used to maintain atomicity within
69907>>>>>>>>>>>/// an process. If one procedure in the transaction fails, then they all
69907>>>>>>>>>>>/// will fail. This command is used to start an SQL transaction. Inside of
69907>>>>>>>>>>>/// a transaction, there can be any number of SQL statements, none of which
69907>>>>>>>>>>>/// will be executed until SQL_COMMIT_STMT is called. Note that transactions
69907>>>>>>>>>>>/// are generally only needed when a table is being altered.
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Assumptions
69907>>>>>>>>>>>/// @Status      Public
69907>>>>>>>>>>>/// @Drivers     All
69907>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
69907>>>>>>>>>>>/// @See         SQL_COMMIT_STMT SQL_ROLLBACK_STMT
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Syntax SQL_START_TRANSACTION_STMT
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Example
69907>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
69907>>>>>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
69907>>>>>>>>>>>/// SQL_PREPARE_STMT
69907>>>>>>>>>>>/// SQL_EXECUTE_STMT
69907>>>>>>>>>>>/// SQL_COMMIT_STMT
69907>>>>>>>>>>>
69907>>>>>>>>>>>//=============================================================================
69907>>>>>>>>>>>/// @Name        SQL_COMMIT_STMT
69907>>>>>>>>>>>/// @Description Just as the SQL_EXECUTE_STMT is used to execute the SQL
69907>>>>>>>>>>>/// statement in the block, this command is used to commit the transaction
69907>>>>>>>>>>>/// started by SQL_START_TRANSACTION_STMT. When this command is called, any
69907>>>>>>>>>>>/// preceding statements or procedures that are apart of the transaction will
69907>>>>>>>>>>>/// be committed. If one or more of these statements fail, then none of them
69907>>>>>>>>>>>/// will be successful, thus maintaining atomicity.
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Assumptions
69907>>>>>>>>>>>/// @Status      Public
69907>>>>>>>>>>>/// @Drivers     All
69907>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
69907>>>>>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_ROLLBACK_STMT
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Syntax SQL_COMMIT_STMT
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Example
69907>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
69907>>>>>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
69907>>>>>>>>>>>/// SQL_PREPARE_STMT
69907>>>>>>>>>>>/// SQL_EXECUTE_STMT
69907>>>>>>>>>>>/// SQL_COMMIT_STMT
69907>>>>>>>>>>>
69907>>>>>>>>>>>//=============================================================================
69907>>>>>>>>>>>/// @Name        SQL_ROLLBACK_STMT
69907>>>>>>>>>>>/// @Description Rolls back an SQL transaction, any data changes inside the
69907>>>>>>>>>>>/// transaction will not be committed by the server.
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Assumptions
69907>>>>>>>>>>>/// @Status      Public
69907>>>>>>>>>>>/// @Drivers     All
69907>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
69907>>>>>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_COMMIT_STMT
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Syntax SQL_ROLLBACK_STMT
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Example
69907>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
69907>>>>>>>>>>>/// SQL_SET_STMT to "DELETE FROM CUSTOMER WHERE ID = 2145"
69907>>>>>>>>>>>/// SQL_PREPARE_STMT
69907>>>>>>>>>>>/// SQL_EXECUTE_STMT
69907>>>>>>>>>>>/// If (Err) Begin
69907>>>>>>>>>>>///             SQL_ERROR_MESSAGE errorString
69907>>>>>>>>>>>///     Showln errorString
69907>>>>>>>>>>>///     SQL_ROLLBACK_STMT
69907>>>>>>>>>>>/// End
69907>>>>>>>>>>>/// Else
69907>>>>>>>>>>>///     Showln "SQL Statement successful - committing"
69907>>>>>>>>>>>///     SQL_COMMIT_STMT
69907>>>>>>>>>>>
69907>>>>>>>>>>>//=============================================================================
69907>>>>>>>>>>>/// @Name        SET_TRANSACTIONS_ALLOWED
69907>>>>>>>>>>>/// @Description This command is used to toggle on or off the ability to
69907>>>>>>>>>>>/// complete transaction to the server. Passing false to this command will
69907>>>>>>>>>>>/// not allow transactions to be made, passing true will allow the transactions.
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Assumptions
69907>>>>>>>>>>>/// @Status      Internal
69907>>>>>>>>>>>/// @Drivers     All
69907>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
69907>>>>>>>>>>>/// @See
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Syntax SET_TRANSACTIONS_ALLOWED of {server} to {variable}
69907>>>>>>>>>>>/// @Param server                               The name of the server being used
69907>>>>>>>>>>>/// @Param variable                     Boolean to enable or disable transactions
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Example
69907>>>>>>>>>>>/// SET_TRANSACTIONS_ALLOWED of "localhost" to True
69907>>>>>>>>>>>
69907>>>>>>>>>>>//=============================================================================
69907>>>>>>>>>>>/// @Name        SQL_FETCH_NEXT_ROW
69907>>>>>>>>>>>/// @Description This command is used to fetch the next row returned by the
69907>>>>>>>>>>>/// associated SQL statement. The SQL statement is created from the
69907>>>>>>>>>>>/// SQL_SET_STMT and executed with the SQL_EXECUTE_STMT. This command can be
69907>>>>>>>>>>>/// used in two ways. If the results are to be attached to variables, then no
69907>>>>>>>>>>>/// file needs to be specified, just the variables for each column in the row.
69907>>>>>>>>>>>/// If the results are to be inserted into the record buffer directly, then the
69907>>>>>>>>>>>/// file must be specified. From there, a SQL_BINDCOLUMNS_STMT can be used to
69907>>>>>>>>>>>/// bind the fetched row to the specific fields in the file. Note that the
69907>>>>>>>>>>>/// columns are fecthed in the order that the SQL statement generates them, so
69907>>>>>>>>>>>/// the variables must follow the same order. The two constants, "found" and
69907>>>>>>>>>>>/// "finderr" are set depending on whether the next row was found.
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Assumptions
69907>>>>>>>>>>>/// @Status      Public
69907>>>>>>>>>>>/// @Drivers     All
69907>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
69907>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_BINDCOLUMNS_STMT
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Syntax SQL_FETCH_NEXT_ROW [of {file}] into {variable}
69907>>>>>>>>>>>/// @Param  file                                The name or number of the file
69907>>>>>>>>>>>/// @Param  variable                    The variable that the next column in the fetched row will be put into (can be multiple)
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW of Customer
69907>>>>>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW into sRecnum sID
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Example
69907>>>>>>>>>>>/// String sID sRecnum
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER ID"
69907>>>>>>>>>>>/// SQL_APPEND_STMT to " BY NAME DESC"
69907>>>>>>>>>>>/// SQL_PREPARE_STMT
69907>>>>>>>>>>>/// SQL_EXECUTE_STMT
69907>>>>>>>>>>>/// While (found)
69907>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sRecnum sID
69907>>>>>>>>>>>///     If (found) Begin
69907>>>>>>>>>>>///             Showln sID
69907>>>>>>>>>>>///    End
69907>>>>>>>>>>>/// Loop
69907>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Example
69907>>>>>>>>>>>/// Open Customer
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
69907>>>>>>>>>>>/// SQL_PREPARE_STMT of Customer
69907>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
69907>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
69907>>>>>>>>>>>/// While (Found)
69907>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
69907>>>>>>>>>>>///     Showln Customer.ID
69907>>>>>>>>>>>///     Showln Customer.FirstName
69907>>>>>>>>>>>///             Showln Customer.LastName
69907>>>>>>>>>>>/// Loop
69907>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
69907>>>>>>>>>>>
69907>>>>>>>>>>>//=============================================================================
69907>>>>>>>>>>>/// @Name        GET_RESULT_SET
69907>>>>>>>>>>>/// @Description Fetches the next row in the result set returned by a
69907>>>>>>>>>>>/// query or stored procedure.
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Assumptions
69907>>>>>>>>>>>/// @Status      Deprecated
69907>>>>>>>>>>>/// @Drivers     All
69907>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
69907>>>>>>>>>>>/// @See
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Syntax GET_RESULT_SET into {variable}
69907>>>>>>>>>>>/// @Param variable                     The variable receiving the result (can be multiple)
69907>>>>>>>>>>>
69907>>>>>>>>>>>//=============================================================================
69907>>>>>>>>>>>/// @Name        SQL_GET_DATA_CHUNK
69907>>>>>>>>>>>/// @Description This command is used to get a chunk of data from a column
69907>>>>>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
69907>>>>>>>>>>>/// and the offset number, the chunk will be put into the specified variable.
69907>>>>>>>>>>>/// To specify how big of a chunk to get, use the SQL_SET_CHUNK_SIZE command.
69907>>>>>>>>>>>/// Otherwise the maximum length will be retrieved. An optional variable can
69907>>>>>>>>>>>/// also be passed which will store the length of the chunk. Note that unlike
69907>>>>>>>>>>>/// LOB_READ, this command works for any column type, not just LOB columns.
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Assumptions
69907>>>>>>>>>>>/// @Status      Public
69907>>>>>>>>>>>/// @Drivers     SQLFlex
69907>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
69907>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Syntax SQL_GET_DATA_CHUNK COLUMN {column} OFFSET {offset} to {variable} {length}
69907>>>>>>>>>>>/// @Param column                               Column number to get chunk from
69907>>>>>>>>>>>/// @Param offset                       Offset to start at for the chunk
69907>>>>>>>>>>>/// @Param variable                     Variable to hold the returned chunk
69907>>>>>>>>>>>/// @Param length                       Variable to hold the chunk length
69907>>>>>>>>>>>///
69907>>>>>>>>>>>/// @Example
69907>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
69907>>>>>>>>>>>/// SQL_PREPARE_STMT
69907>>>>>>>>>>>/// SQL_EXECUTE_STMT
69907>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
69907>>>>>>>>>>>/// If (Found) Begin
69907>>>>>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
69907>>>>>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
69907>>>>>>>>>>>///     Showln sChunk
69907>>>>>>>>>>>///     Showln iLength
69907>>>>>>>>>>>/// End
69907>>>>>>>>>>>
69907>>>>>>>>>>>Function MertechInc_SQL_GET_DATA_CHUNK Global Integer iColumn Integer iOffset Returns String
69909>>>>>>>>>>>    Integer iChuck_Size
69909>>>>>>>>>>>    String sChunk
69909>>>>>>>>>>>
69909>>>>>>>>>>>    //Get current Chuck size and pre size string
69909>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
69914>>>>>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
69915>>>>>>>>>>>
69915>>>>>>>>>>>    //Get data
69915>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK CALLBACK 0 PASSING iColumn sChunk iOffset RESULT MertechInc_iRet
69920>>>>>>>>>>>
69920>>>>>>>>>>>    //sArg1 (iColumn) contains the number of bytes returned, so move it to
69920>>>>>>>>>>>    //MertechInc_Arg1 to pass the value back
69920>>>>>>>>>>>    Move iColumn to MertechInc_sArg1
69921>>>>>>>>>>>
69921>>>>>>>>>>>    Function_Return sChunk
69922>>>>>>>>>>>End_Function
69923>>>>>>>>>>>
69923>>>>>>>>>>>//=============================================================================
69923>>>>>>>>>>>/// @Name        SQL_SET_CHUNK_SIZE
69923>>>>>>>>>>>/// @Description This command sets the size of the chunk to retrieve when
69923>>>>>>>>>>>/// using SQL_GET_DATA_CHUNK. Whatever number is set here will be the
69923>>>>>>>>>>>/// length of the chunk that is retrieved, as long as it does not exceed
69923>>>>>>>>>>>/// the maximum chunk size.
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Assumptions
69923>>>>>>>>>>>/// @Status      Public
69923>>>>>>>>>>>/// @Drivers     SQLFlex
69923>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
69923>>>>>>>>>>>/// @See                 SQL_GET_DATA_CHUNK SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Syntax SQL_SET_CHUNK_SIZE to {variable}
69923>>>>>>>>>>>/// @Param variable                     Length of chunk to retrive
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Example
69923>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
69923>>>>>>>>>>>/// SQL_PREPARE_STMT
69923>>>>>>>>>>>/// SQL_EXECUTE_STMT
69923>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
69923>>>>>>>>>>>/// If (Found) Begin
69923>>>>>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
69923>>>>>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
69923>>>>>>>>>>>///     Showln sChunk
69923>>>>>>>>>>>///     Showln iLength
69923>>>>>>>>>>>/// End
69923>>>>>>>>>>>
69923>>>>>>>>>>>//=============================================================================
69923>>>>>>>>>>>/// @Name        SQL_GET_CHUNK_SIZE
69923>>>>>>>>>>>/// @Description This command gets the size of the chunk being retrieved
69923>>>>>>>>>>>/// from SQL_GET_DATA_CHUNK and puts it into the specified variable.
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Assumptions
69923>>>>>>>>>>>/// @Status      Public
69923>>>>>>>>>>>/// @Drivers     SQLFlex
69923>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
69923>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Syntax SQL_GET_CHUNK_SIZE to {variable}
69923>>>>>>>>>>>/// @Param variable             Variable to hold the chunk size
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Example
69923>>>>>>>>>>>/// SQL_GET_CHUNK_SIZE to iLength
69923>>>>>>>>>>>
69923>>>>>>>>>>>//=============================================================================
69923>>>>>>>>>>>/// @Name        SQL_SET_MAX_DATA_SIZE
69923>>>>>>>>>>>/// @Description This command sets the maximum size for data chunks
69923>>>>>>>>>>>/// retrieved through SQL_GET_DATA_CHUNK. If SQL_SET_CHUNK_SIZE is higher
69923>>>>>>>>>>>/// than the maximum size set with this command, then this will override
69923>>>>>>>>>>>/// it and the chunk will be no longer than the maximum size set here.
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Assumptions
69923>>>>>>>>>>>/// @Status      Public
69923>>>>>>>>>>>/// @Drivers     SQLFlex
69923>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
69923>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_GET_MAX_DATA_SIZE
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Syntax SQL_SET_MAX_DATA_SIZE to {variable}
69923>>>>>>>>>>>/// @Param variable                     Max length to allow for chunks
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Example
69923>>>>>>>>>>>/// SQL_SET_MAX_DATA_SIZE to 1000
69923>>>>>>>>>>>
69923>>>>>>>>>>>//=============================================================================
69923>>>>>>>>>>>/// @Name        SQL_GET_MAX_DATA_SIZE
69923>>>>>>>>>>>/// @Description This command returns the maximum chunk size allowed
69923>>>>>>>>>>>/// for SQL_GET_DATA_CHUNK.
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Assumptions
69923>>>>>>>>>>>/// @Status      Public
69923>>>>>>>>>>>/// @Drivers     SQLFlex
69923>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
69923>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Syntax SQL_GET_MAX_DATA_SIZE to {variable}
69923>>>>>>>>>>>/// @Param variable             Variable to hold the maximum chunk size
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Example
69923>>>>>>>>>>>/// SQL_GET_MAX_DATA_SIZE to iLength
69923>>>>>>>>>>>
69923>>>>>>>>>>>//=============================================================================
69923>>>>>>>>>>>/// @Name        SQL_GET_NUM_COLS
69923>>>>>>>>>>>/// @Description This command is used to get the number of columns retrieved
69923>>>>>>>>>>>/// from an SQL expression result set. Since the column number is based on
69923>>>>>>>>>>>/// the result set, this command cannot be used when the results are being
69923>>>>>>>>>>>/// bound to the record buffer.  If this command is used with the record
69923>>>>>>>>>>>/// buffer or if no columns are found, -1 is returned.
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Assumptions
69923>>>>>>>>>>>/// @Status      Public
69923>>>>>>>>>>>/// @Drivers     All
69923>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
69923>>>>>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_SET_STMT
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Syntax SQL_GET_NUM_COLS to {variable}
69923>>>>>>>>>>>/// @Param variable                     Variable to hold the number of columns.
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Example
69923>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
69923>>>>>>>>>>>/// SQL_PREPARE_STMT
69923>>>>>>>>>>>/// SQL_EXECUTE_STMT
69923>>>>>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
69923>>>>>>>>>>>/// Showln iNumCols
69923>>>>>>>>>>>
69923>>>>>>>>>>>
69923>>>>>>>>>>>//=============================================================================
69923>>>>>>>>>>>/// @Name        GET_RESULT_SET_NUM_COLS
69923>>>>>>>>>>>/// @Description Returns the number of columns in the result set.
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Assumptions
69923>>>>>>>>>>>/// @Status      Deprecated
69923>>>>>>>>>>>/// @Drivers     All
69923>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
69923>>>>>>>>>>>/// @See                 SQL_GET_NUM_COLS
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Syntax GET_RESULT_SET_NUM_COLS to {variable}
69923>>>>>>>>>>>/// @Param variable                     Variable to hold the number of columns
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Example
69923>>>>>>>>>>>/// Integer iNumCols
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
69923>>>>>>>>>>>/// SQL_PREPARE_STMT
69923>>>>>>>>>>>/// SQL_EXECUTE_STMT
69923>>>>>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
69923>>>>>>>>>>>/// Showln iNumCols
69923>>>>>>>>>>>
69923>>>>>>>>>>>//=============================================================================
69923>>>>>>>>>>>/// @Name        SQL_GET_NUM_ROWS
69923>>>>>>>>>>>/// @Description This command is used to get the number of rows retrieved
69923>>>>>>>>>>>/// from a result set of an SQL expression. It cannot be used when binding
69923>>>>>>>>>>>/// the result set to the record buffer.
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// Note: The number of rows may not always be available, depending
69923>>>>>>>>>>>/// on server and cursor types.
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Assumptions
69923>>>>>>>>>>>/// @Status      Public
69923>>>>>>>>>>>/// @Drivers     All
69923>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
69923>>>>>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Syntax SQL_GET_NUM_ROWS to {variable}
69923>>>>>>>>>>>/// @Param variable                     Variable to hold the number of rows
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Example
69923>>>>>>>>>>>/// Integer iNumRows
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
69923>>>>>>>>>>>/// SQL_PREPARE_STMT
69923>>>>>>>>>>>/// SQL_EXECUTE_STMT
69923>>>>>>>>>>>/// SQL_GET_NUM_ROWS to iNumRows
69923>>>>>>>>>>>/// Showln iNumRows
69923>>>>>>>>>>>
69923>>>>>>>>>>>
69923>>>>>>>>>>>//=============================================================================
69923>>>>>>>>>>>/// @Name        SQL_GET_COL_NAME
69923>>>>>>>>>>>/// @Description This command is used to retrieve the name of a specified
69923>>>>>>>>>>>/// column within an SQL result set. An optional second variable can be used
69923>>>>>>>>>>>/// to retrieve the size of the specified column. Note that this command
69923>>>>>>>>>>>/// cannot be used when the results are being directly binded to the record
69923>>>>>>>>>>>/// buffer, it can only be used for the results of an SQL statement.
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Assumptions
69923>>>>>>>>>>>/// @Status      Public
69923>>>>>>>>>>>/// @Drivers     All
69923>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
69923>>>>>>>>>>>/// @See                 SQL_GET_NUM_COLS
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Syntax SQL_GET_COL_NAME {columnNumber} to {variable} [{length}]
69923>>>>>>>>>>>/// @Param columnNumber                 The column number being used
69923>>>>>>>>>>>/// @Param variable                             String variable for the column name
69923>>>>>>>>>>>/// @Param length                       Variable to hold the column length (optional)
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Example
69923>>>>>>>>>>>/// Open Customer
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// String sColumnName
69923>>>>>>>>>>>/// Integer iLength
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
69923>>>>>>>>>>>/// SQL_PREPARE_STMT
69923>>>>>>>>>>>/// SQL_EXECUTE_STMT
69923>>>>>>>>>>>/// SQL_GET_COL_NAME 1 to sColumnName iLength
69923>>>>>>>>>>>/// showln sColumnName
69923>>>>>>>>>>>/// showln iLength
69923>>>>>>>>>>>
69923>>>>>>>>>>>
69923>>>>>>>>>>>//=============================================================================
69923>>>>>>>>>>>/// @Name        GET_RESULT_SET_COL_NAME
69923>>>>>>>>>>>/// @Description Returns the column name being populated from the result set.
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Assumptions
69923>>>>>>>>>>>/// @Status      Deprecated
69923>>>>>>>>>>>/// @Drivers     All
69923>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
69923>>>>>>>>>>>/// @See                 SQL_GET_COL_NAME
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Syntax GET_RESULT_SET_COL_NAME {columnNumber} to {variable} [{length}]
69923>>>>>>>>>>>/// @Param columnNumber                 The column number being used
69923>>>>>>>>>>>/// @Param variable                             String variable for the column name
69923>>>>>>>>>>>/// @Param length                       Variable receiving the column length (optional)
69923>>>>>>>>>>>
69923>>>>>>>>>>>//=============================================================================
69923>>>>>>>>>>>/// @Name        SQL_GET_COL_ATTRIBUTE
69923>>>>>>>>>>>/// @Description This command is used to get specific column information from
69923>>>>>>>>>>>/// the columns in a result set of an SQL statement. By passing one of the
69923>>>>>>>>>>>/// supported attributes below, the command will return the desired information.
69923>>>>>>>>>>>/// Note that some attributes only work with specific drivers. See the list
69923>>>>>>>>>>>/// below for more information.
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// Supported attributes are:
69923>>>>>>>>>>>/// <dl>
69923>>>>>>>>>>>/// <dt>SIZE        </dt><dd>The maximum length of the column</dd>
69923>>>>>>>>>>>/// <dt>DATA_LENGTH </dt><dd>Length of data currently in the column</dd>
69923>>>>>>>>>>>/// <dt>DECIMALS    </dt><dd>If numeric, shows number of decimal places</dd>
69923>>>>>>>>>>>/// <dt>LABEL       </dt><dd>Returns the column name in ORAFlex and MySQLFlex</dd>
69923>>>>>>>>>>>/// <dt>COLUMN_NAME </dt><dd>Returns the name of the column</dd>
69923>>>>>>>>>>>/// <dt>TABLE_NAME  </dt><dd>Returns the name of the table (MySQLFlex only)</dd>
69923>>>>>>>>>>>/// <dt>SQLTYPE     </dt><dd>Returns the number representing the SQL data type</dd>
69923>>>>>>>>>>>/// <dt>NULLABLE    </dt><dd>Returns true if null is allowed, false otherwise (doesn't work in PostgreSQL)</dd>
69923>>>>>>>>>>>/// <dt>DFTYPE      </dt><dd>Dataflex type column is mapped to</dd>
69923>>>>>>>>>>>/// </dl>
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Assumptions
69923>>>>>>>>>>>/// @Status      Public
69923>>>>>>>>>>>/// @Drivers     All
69923>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
69923>>>>>>>>>>>/// @See
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Syntax SQL_GET_COL_ATTRIBUTE of {columnNumber} {attribute} to {variable}
69923>>>>>>>>>>>/// @Param columnNumber                 The number of the column that is being examined
69923>>>>>>>>>>>/// @Param attribute                    The attribute being checked (see list)
69923>>>>>>>>>>>/// @Param variable                             Variable to hold the attribute value
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Example
69923>>>>>>>>>>>/// String sFirstName sLastName sColumn1Name sColumn2Name
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// Open Customer
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
69923>>>>>>>>>>>/// SQL_PREPARE_STMT
69923>>>>>>>>>>>/// SQL_EXECUTE_STMT
69923>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
69923>>>>>>>>>>>/// If (Found) Begin
69923>>>>>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 1 COLUMN_NAME to sColumn1Name
69923>>>>>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 2 COLUMN_NAME to sColumn2Name
69923>>>>>>>>>>>///     Showln (sColumn1Name + " = " + sFirstName)
69923>>>>>>>>>>>///     Showln (sColumn2Name + " = " + sLastName)
69923>>>>>>>>>>>/// End
69923>>>>>>>>>>>
69923>>>>>>>>>>>//=============================================================================
69923>>>>>>>>>>>/// @Name        DDO_GET_BIND_RSPARAMETERS
69923>>>>>>>>>>>/// @Description Recursively calls DO_GET_BIND_RSPARAMETERS.
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Assumptions
69923>>>>>>>>>>>/// @Status      Internal
69923>>>>>>>>>>>/// @Drivers     All
69923>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
69923>>>>>>>>>>>/// @See
69923>>>>>>>>>>>
69923>>>>>>>>>>>//=============================================================================
69923>>>>>>>>>>>/// @Name        DO_GET_BIND_RSPARAMETERS
69923>>>>>>>>>>>/// @Description Gets bound parameters values for result set call.
69923>>>>>>>>>>>///
69923>>>>>>>>>>>/// @Assumptions
69923>>>>>>>>>>>/// @Status      Internal
69923>>>>>>>>>>>/// @Drivers     All
69923>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
69923>>>>>>>>>>>/// @See
69923>>>>>>>>>>>
69923>>>>>>>>>>>Function MertechInc_DO_GET_BIND_RSPARAMETERS Global Integer iWhichParam Returns String
69925>>>>>>>>>>>    String sReturnValue
69925>>>>>>>>>>>
69925>>>>>>>>>>>    Get Value of (oMertechInc_Work(Current_Object)) item iWhichParam to MertechInc_iWork
69926>>>>>>>>>>>    If MertechInc_iWork lt 16384 ;        Move (Repeat("                                ", ((MertechInc_iWork/32)+1))) to sReturnValue
69929>>>>>>>>>>>    Else Get psWork of oMertechInc_Work to sReturnValue
69931>>>>>>>>>>>
69931>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank (|CI$10000 * iWhichParam) RESULT MertechInc_iRet
69936>>>>>>>>>>>
69936>>>>>>>>>>>    Function_Return sReturnValue
69937>>>>>>>>>>>End_Function
69938>>>>>>>>>>>
69938>>>>>>>>>>>
69938>>>>>>>>>>>//=============================================================================
69938>>>>>>>>>>>/// @Name        SQL_NEXT_RESULT_SET
69938>>>>>>>>>>>/// @Description This command is used when working with SQL statements that
69938>>>>>>>>>>>/// return multiple result sets. In that scenario, calling this command will
69938>>>>>>>>>>>/// move to the next result set. That set can now be fetched or binded to
69938>>>>>>>>>>>/// columns on a table.
69938>>>>>>>>>>>///
69938>>>>>>>>>>>/// @See
69938>>>>>>>>>>>/// @Status      Public
69938>>>>>>>>>>>/// @Drivers     All
69938>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-02 by Aaron Gulack
69938>>>>>>>>>>>/// @See
69938>>>>>>>>>>>///
69938>>>>>>>>>>>/// @Syntax SQL_NEXT_RESULT_SET [of {file}]
69938>>>>>>>>>>>/// @Param file                 Name or number of the file (optional)
69938>>>>>>>>>>>///
69938>>>>>>>>>>>/// @Example
69938>>>>>>>>>>>/// SQL_SET_STMT to "SP_HELP CUSTOMER"
69938>>>>>>>>>>>/// SQL_PREPARE_STMT
69938>>>>>>>>>>>/// SQL_EXECUTE_STMT
69938>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sTable sOwner sTableType dtCreated
69938>>>>>>>>>>>/// If (Found) Begin
69938>>>>>>>>>>>///     Showln sTable
69938>>>>>>>>>>>///     Showln sOwner
69938>>>>>>>>>>>///     Showln sTableType
69938>>>>>>>>>>>///     Showln dtCreated
69938>>>>>>>>>>>/// End
69938>>>>>>>>>>>/// SQL_NEXT_RESULT_SET
69938>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sColumnName sColumnType sComputed sLength
69938>>>>>>>>>>>/// If (Found) Begin
69938>>>>>>>>>>>///     Showln sColumnName
69938>>>>>>>>>>>///     Showln sColumnType
69938>>>>>>>>>>>///     Showln sComputed
69938>>>>>>>>>>>///     Showln sLength
69938>>>>>>>>>>>/// End
69938>>>>>>>>>>>
69938>>>>>>>>>>>//=============================================================================
69938>>>>>>>>>>>/// @Name        DDO_PASS_ARGUMENTS
69938>>>>>>>>>>>/// @Description Calls DO_PASS_ARGUMENTS until the argument is "BINDING" and
69938>>>>>>>>>>>/// then stops.
69938>>>>>>>>>>>///
69938>>>>>>>>>>>/// @Assumptions
69938>>>>>>>>>>>/// @Status      Internal
69938>>>>>>>>>>>/// @Drivers     All
69938>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
69938>>>>>>>>>>>/// @See
69938>>>>>>>>>>>
69938>>>>>>>>>>>//=============================================================================
69938>>>>>>>>>>>/// @Name        DO_PASS_ARGUMENTS
69938>>>>>>>>>>>/// @Description Builds parameter statements for stored procedures and adds
69938>>>>>>>>>>>/// them to the current query.
69938>>>>>>>>>>>///
69938>>>>>>>>>>>/// @Assumptions
69938>>>>>>>>>>>/// @Status      internal
69938>>>>>>>>>>>/// @Drivers     All
69938>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
69938>>>>>>>>>>>/// @See
69938>>>>>>>>>>>
69938>>>>>>>>>>>//=============================================================================
69938>>>>>>>>>>>/// @Name        DDO_BIND_PARAMETERS
69938>>>>>>>>>>>/// @Description Recursively calls DO_BIND_PARAMETERS until the keyword
69938>>>>>>>>>>>/// "BINDING" is encountered.
69938>>>>>>>>>>>///
69938>>>>>>>>>>>/// @Assumptions
69938>>>>>>>>>>>/// @Status      Internal
69938>>>>>>>>>>>/// @Drivers     All
69938>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
69938>>>>>>>>>>>/// @See
69938>>>>>>>>>>>
69938>>>>>>>>>>>//=============================================================================
69938>>>>>>>>>>>/// @Name        DO_BIND_PARAMETERS
69938>>>>>>>>>>>/// @Description Binds parameters for a stored procedure call.
69938>>>>>>>>>>>///
69938>>>>>>>>>>>/// @Assumptions
69938>>>>>>>>>>>/// @Status      Internal
69938>>>>>>>>>>>/// @Drivers     All
69938>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
69938>>>>>>>>>>>/// @See
69938>>>>>>>>>>>
69938>>>>>>>>>>>Procedure MertechInc_DO_BIND_PARAMETERS Global String sValue String sName Integer iLength
69940>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sValue sName iLength RESULT MertechInc_iRet
69945>>>>>>>>>>>End_Procedure
69946>>>>>>>>>>>
69946>>>>>>>>>>>//=============================================================================
69946>>>>>>>>>>>/// @Name        DO_BIND_PAR_RET
69946>>>>>>>>>>>/// @Description Binds parameters for a stored procedure call.
69946>>>>>>>>>>>///
69946>>>>>>>>>>>/// @Assumptions
69946>>>>>>>>>>>/// @Status      Internal
69946>>>>>>>>>>>/// @Drivers     OraFlex
69946>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
69946>>>>>>>>>>>/// @See
69946>>>>>>>>>>>
69946>>>>>>>>>>>//=============================================================================
69946>>>>>>>>>>>/// @Name        DDO_GET_BIND_PARAMETERS
69946>>>>>>>>>>>/// @Description Recursively calls DO_GET_BIND_PARAMETERS.
69946>>>>>>>>>>>///
69946>>>>>>>>>>>/// @Assumptions
69946>>>>>>>>>>>/// @Status      Internal
69946>>>>>>>>>>>/// @Drivers     All
69946>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
69946>>>>>>>>>>>/// @See
69946>>>>>>>>>>>
69946>>>>>>>>>>>//=============================================================================
69946>>>>>>>>>>>/// @Name        DO_GET_BIND_PARAMETERS
69946>>>>>>>>>>>/// @Description Gets bound parameter values for a stored procedure call.
69946>>>>>>>>>>>///
69946>>>>>>>>>>>/// @Assumptions
69946>>>>>>>>>>>/// @Status      Internal
69946>>>>>>>>>>>/// @Drivers     All
69946>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
69946>>>>>>>>>>>/// @See
69946>>>>>>>>>>>
69946>>>>>>>>>>>Function MertechInc_DO_GET_BIND_PARAMETERS Global Integer bSQLFlex String sArg1 String sArg2 Integer iArg Returns String
69948>>>>>>>>>>>    String sReturnValue
69948>>>>>>>>>>>    Integer iSize
69948>>>>>>>>>>>
69948>>>>>>>>>>>    if (MertechInc_DriverName = SQLFLEX) ;                move (iArg+1) to iArg
69951>>>>>>>>>>>//        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
69951>>>>>>>>>>>
69951>>>>>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
69952>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
69957>>>>>>>>>>>
69957>>>>>>>>>>>    Function_Return sReturnValue
69958>>>>>>>>>>>End_Function
69959>>>>>>>>>>>
69959>>>>>>>>>>>//=============================================================================
69959>>>>>>>>>>>/// @Name        SQL_GET_OUTPUT_VALUE
69959>>>>>>>>>>>/// @Description This command is used to get the value of a specific
69959>>>>>>>>>>>/// parameter associated with a stored procedure.  Although this
69959>>>>>>>>>>>/// command will work with any parameter, it is mostly used with
69959>>>>>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
69959>>>>>>>>>>>/// once returned. When multiple values are returned, this command can be
69959>>>>>>>>>>>/// more efficient than other options. Note that the specified parameter
69959>>>>>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
69959>>>>>>>>>>>/// in order to work properly.
69959>>>>>>>>>>>///
69959>>>>>>>>>>>/// @Assumptions
69959>>>>>>>>>>>/// @Status      Deprecated
69959>>>>>>>>>>>/// @Drivers     All
69959>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
69959>>>>>>>>>>>/// @See                 SQL_GET_PROCEDURE_PARAMETER
69959>>>>>>>>>>>///
69959>>>>>>>>>>>/// @Syntax SQL_GET_OUTPUT_VALUE {parameter} to {variable}
69959>>>>>>>>>>>/// @Param parameter            Number of the parameter
69959>>>>>>>>>>>/// @Param variable                     Variable to hold the parameter's value
69959>>>>>>>>>>>///
69959>>>>>>>>>>>/// @Example
69959>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
69959>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
69959>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
69959>>>>>>>>>>>/// SQL_GET_OUTPUT_VALUE 1 to sStatus
69959>>>>>>>>>>>///
69959>>>>>>>>>>>/// Showln sStatus
69959>>>>>>>>>>>///
69959>>>>>>>>>>>/// @Example
69959>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
69959>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
69959>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
69959>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
69959>>>>>>>>>>>/// SQL_GET_OUTPUT_VALUE 2 to sStatus
69959>>>>>>>>>>>///
69959>>>>>>>>>>>/// Showln sStatus
69959>>>>>>>>>>>// OLI:
69959>>>>>>>>>>>// This function is identical in operation to SQL_GET_PROCEDURE_PARAMETER, so just do a replace
69959>>>>>>>>>>>
69959>>>>>>>>>>>//=============================================================================
69959>>>>>>>>>>>/// @Name        SQL_FETCH_COLUMN
69959>>>>>>>>>>>/// @Description This command is used to retrieve a specified column from a
69959>>>>>>>>>>>/// result set of an SQL statement. Note that this command cannot be used to
69959>>>>>>>>>>>/// replace SQL_FETCH_NEXT_ROW but is used in addition to it when only one
69959>>>>>>>>>>>/// column is needed. For most cases, SQL_FETCH_NEXT_ROW can be used alone
69959>>>>>>>>>>>/// to retrieve the columns desired so this should only be used if there is
69959>>>>>>>>>>>/// a specific reason to do so.
69959>>>>>>>>>>>///
69959>>>>>>>>>>>/// @Assumptions
69959>>>>>>>>>>>/// @Status      Public
69959>>>>>>>>>>>/// @Drivers     All
69959>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
69959>>>>>>>>>>>/// @See                 SQL_FETCH_NEXT_ROW
69959>>>>>>>>>>>///
69959>>>>>>>>>>>/// @Syntax SQL_FETCH_COLUMN {columnNumber} into {variable}
69959>>>>>>>>>>>/// @Param columnNumber    Number of the column to fetch
69959>>>>>>>>>>>/// @Param variable        Variable to hold the fetched value
69959>>>>>>>>>>>///
69959>>>>>>>>>>>/// @Example
69959>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
69959>>>>>>>>>>>/// SQL_PREPARE_STMT
69959>>>>>>>>>>>/// SQL_EXECUTE_STMT
69959>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW
69959>>>>>>>>>>>/// SQL_GET_NUM_COLS to iCols
69959>>>>>>>>>>>/// For fieldIndex from 1 to iCols
69959>>>>>>>>>>>///     SQL_FETCH_COLUMN fieldIndex into sValue
69959>>>>>>>>>>>///     Showln sValue
69959>>>>>>>>>>>/// Loop
69959>>>>>>>>>>>
69959>>>>>>>>>>>Function MertechInc_SQL_FETCH_COLUMN Global String sArg1 String sArg2 Integer iArg Returns String
69961>>>>>>>>>>>    String sReturnValue
69961>>>>>>>>>>>    Integer iSize
69961>>>>>>>>>>>
69961>>>>>>>>>>>    Move 0 to iSize
69962>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
70003>>>>>>>>>>>>
70003>>>>>>>>>>>
70003>>>>>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
70004>>>>>>>>>>>    Move (|CI$10000 * iArg) to iArg // Shift column number 16 bits to the left
70005>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
70010>>>>>>>>>>>
70010>>>>>>>>>>>    Function_Return sReturnValue
70011>>>>>>>>>>>End_Function
70012>>>>>>>>>>>
70012>>>>>>>>>>>//=============================================================================
70012>>>>>>>>>>>/// @Name        SET_SCHEMA_NAME
70012>>>>>>>>>>>/// @Description This command is used to set the schema name to be used when
70012>>>>>>>>>>>/// opening tables. Note that this command will override the schema name that
70012>>>>>>>>>>>/// is set in the INT file.  The default schema for the current user is used
70012>>>>>>>>>>>/// when no name is set.
70012>>>>>>>>>>>///
70012>>>>>>>>>>>/// @Assumptions
70012>>>>>>>>>>>/// @Status      Public
70012>>>>>>>>>>>/// @Drivers     SQLFlex and ORAFlex
70012>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
70012>>>>>>>>>>>/// @See                 GET_SCHEMA_NAME
70012>>>>>>>>>>>///
70012>>>>>>>>>>>/// @Syntax SET_SCHEMA_NAME to {schema}
70012>>>>>>>>>>>/// @Param variable                     Name of the schema
70012>>>>>>>>>>>///
70012>>>>>>>>>>>/// @Example
70012>>>>>>>>>>>/// SET_SCHEMA_NAME to 'CustomerSchema'
70012>>>>>>>>>>>/// OPEN "CUSTOMER.INT" as CUSTOMER
70012>>>>>>>>>>>/// SET_SCHEMA_NAME to 'SalesSchema'
70012>>>>>>>>>>>/// OPEN "SALESP.INT" as SALESP
70012>>>>>>>>>>>
70012>>>>>>>>>>>//=============================================================================
70012>>>>>>>>>>>/// @Name        GET_SCHEMA_NAME
70012>>>>>>>>>>>/// @Description This command is used to get the name of the schema being
70012>>>>>>>>>>>/// used to open tables.
70012>>>>>>>>>>>///
70012>>>>>>>>>>>/// @Assumptions
70012>>>>>>>>>>>/// @Status      Public
70012>>>>>>>>>>>/// @Drivers     SQLFlex and ORAFlex
70012>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
70012>>>>>>>>>>>/// @See                 SET_SCHEMA_NAME
70012>>>>>>>>>>>///
70012>>>>>>>>>>>/// @Syntax GET_SCHEMA_NAME to {variable}
70012>>>>>>>>>>>/// @Param variable                     variable to hold the schema name
70012>>>>>>>>>>>///
70012>>>>>>>>>>>/// @Example
70012>>>>>>>>>>>/// GET_SCHEMA_NAME to sName
70012>>>>>>>>>>>/// Showln sName
70012>>>>>>>>>>>
70012>>>>>>>>>>>//=============================================================================
70012>>>>>>>>>>>/// @Name        CALL_ORACLE_STORED_PROCEDURE
70012>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
70012>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
70012>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
70012>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
70012>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
70012>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
70012>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
70012>>>>>>>>>>>/// is set to true.
70012>>>>>>>>>>>///
70012>>>>>>>>>>>/// @Assumptions
70012>>>>>>>>>>>/// @Status      Deprecated
70012>>>>>>>>>>>/// @Drivers     ORAFLex
70012>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
70012>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
70012>>>>>>>>>>>///
70012>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
70012>>>>>>>>>>>/// @Param procedure            Full name of the procedure
70012>>>>>>>>>>>/// @Param variable                     Argument being passed to procedure (can be multiple)
70012>>>>>>>>>>>///
70012>>>>>>>>>>>/// @Example
70012>>>>>>>>>>>/// CALL_ORACLE_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
70012>>>>>>>>>>>
70012>>>>>>>>>>>//=============================================================================
70012>>>>>>>>>>>/// @Name        SQL_SET_PROCEDURE_NAME
70012>>>>>>>>>>>/// @Description This command is used to set the procedure to be executed.
70012>>>>>>>>>>>/// This is used when the procedure is being split up into multiple lines
70012>>>>>>>>>>>/// as shown below. When using this command, SQL_PROCEDURE_EXECUTE must be
70012>>>>>>>>>>>/// called after all parameters have been set to successfully execute the
70012>>>>>>>>>>>/// procedure. The constant "NUMPAR" is used to indicate how many parameters
70012>>>>>>>>>>>/// will be passed.
70012>>>>>>>>>>>///
70012>>>>>>>>>>>/// @Assumptions The procedure is a valid procedure in the SQL database
70012>>>>>>>>>>>/// @Status      Public
70012>>>>>>>>>>>/// @Drivers     All
70012>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
70012>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
70012>>>>>>>>>>>///
70012>>>>>>>>>>>/// @Syntax SQL_SET_PROCEDURE_NAME {procedure} NUMPAR {variable}
70012>>>>>>>>>>>/// @Param procedure            Full name of the procedure
70012>>>>>>>>>>>/// @Param variable                     Number of parameters to be passed
70012>>>>>>>>>>>///
70012>>>>>>>>>>>/// @Example
70012>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
70012>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
70012>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
70012>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
70012>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
70012>>>>>>>>>>>
70012>>>>>>>>>>>
70012>>>>>>>>>>>Procedure MertechInc_SQL_SET_ORAPROCEDURE_NAME Global String strProcName Integer iNumpar
70014>>>>>>>>>>>    Integer iParam
70014>>>>>>>>>>>
70014>>>>>>>>>>>    Move 0 to MertechInc_iParamCount       //Redundant, but left in incase called
70015>>>>>>>>>>>    INDICATE ERR False              //directly and not via SQL_SET_PROCEDURE_NAME
70016>>>>>>>>>>>    Move ORAFlex to MertechInc_DriverName  //
70017>>>>>>>>>>>
70017>>>>>>>>>>>    SQL_SET_STMT to "BEGIN "
70049>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
70081>>>>>>>>>>>    SQL_APPEND_STMT to "( "
70113>>>>>>>>>>>    For iParam from 1 to iNumpar
70119>>>>>>>>>>>>
70119>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
70198>>>>>>>>>>>    Loop
70199>>>>>>>>>>>>
70199>>>>>>>>>>>    SQL_APPEND_STMT to  " ); END;"
70231>>>>>>>>>>>    SQL_PREPARE_STMT
70280>>>>>>>>>>> End_Procedure
70281>>>>>>>>>>>
70281>>>>>>>>>>>Procedure MertechInc_SQL_SET_MYPROCEDURE_NAME Global String strProcName Integer iNumpar
70283>>>>>>>>>>>    Integer iParam
70283>>>>>>>>>>>
70283>>>>>>>>>>>    Move 0 to MertechInc_iParamCount           //Redundant, but left in incase called
70284>>>>>>>>>>>    INDICATE ERR False                  //directly and not via SQL_SET_PROCEDURE_NAME
70285>>>>>>>>>>>    Move MySQLFlex to MertechInc_DriverName    //
70286>>>>>>>>>>>
70286>>>>>>>>>>>    SQL_SET_STMT to "CALL "
70318>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
70350>>>>>>>>>>>    SQL_APPEND_STMT to "("
70382>>>>>>>>>>>    For iParam from 1 to iNumpar
70388>>>>>>>>>>>>
70388>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
70467>>>>>>>>>>>    Loop
70468>>>>>>>>>>>>
70468>>>>>>>>>>>    SQL_APPEND_STMT to ")"
70500>>>>>>>>>>>    SQL_PREPARE_STMT
70549>>>>>>>>>>>End_Procedure
70550>>>>>>>>>>>
70550>>>>>>>>>>>Procedure MertechInc_SQL_SET_MSPROCEDURE_NAME Global String strProcName Integer iNumpar
70552>>>>>>>>>>>    Integer iParam
70552>>>>>>>>>>>    String  sParam
70552>>>>>>>>>>>
70552>>>>>>>>>>>    Move SQLFlex to MertechInc_DriverName
70553>>>>>>>>>>>
70553>>>>>>>>>>>    // This calling syntax is referred to as the "ODBC CALL escape sequence".  This syntax is
70553>>>>>>>>>>>    // advised over the execute command since CALL allows for the retrieval of the return codes
70553>>>>>>>>>>>    // from the call.
70553>>>>>>>>>>>    SQL_SET_STMT to "{? = CALL "
70585>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
70617>>>>>>>>>>>
70617>>>>>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
70617>>>>>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
70617>>>>>>>>>>>    // the open and close parens ourself to make things more clear.
70617>>>>>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to " ("
70651>>>>>>>>>>>
70651>>>>>>>>>>>    For iParam from 1 to iNumpar
70657>>>>>>>>>>>>
70657>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
70736>>>>>>>>>>>    Loop
70737>>>>>>>>>>>>
70737>>>>>>>>>>>
70737>>>>>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to ")"
70771>>>>>>>>>>>    SQL_APPEND_STMT to  " };"
70803>>>>>>>>>>>
70803>>>>>>>>>>>    SQL_PREPARE_STMT CURSOR_TYPE TYPE_NONE
70859>>>>>>>>>>>
70859>>>>>>>>>>>    // This bind parameter is for the "{? = " which is technically the first parameter even though
70859>>>>>>>>>>>    // it is the return value.  The driver will bind MertechInc_iWork to it.
70859>>>>>>>>>>>    DO_BIND_PARAMETERS MertechInc_iWork
70882>>>>>>>>>>>End_Procedure
70883>>>>>>>>>>>
70883>>>>>>>>>>>Procedure MertechInc_SQL_SET_PGPROCEDURE_NAME Global String strProcName Integer iNumpar
70885>>>>>>>>>>>    Integer iParam
70885>>>>>>>>>>>    String  sParam
70885>>>>>>>>>>>
70885>>>>>>>>>>>    Move PgFlex to MertechInc_DriverName
70886>>>>>>>>>>>
70886>>>>>>>>>>>    // For Postgres, you can call a function just by passing the function name and
70886>>>>>>>>>>>    // open/close parens
70886>>>>>>>>>>>    SQL_SET_STMT to strProcName
70918>>>>>>>>>>>
70918>>>>>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
70918>>>>>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
70918>>>>>>>>>>>    // the open and close parens ourself to make things more clear.
70918>>>>>>>>>>>    SQL_APPEND_STMT to "( "
70950>>>>>>>>>>>
70950>>>>>>>>>>>    For iParam from 1 to iNumpar
70956>>>>>>>>>>>>
70956>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
71035>>>>>>>>>>>    Loop
71036>>>>>>>>>>>>
71036>>>>>>>>>>>
71036>>>>>>>>>>>    SQL_APPEND_STMT to ")"
71068>>>>>>>>>>>
71068>>>>>>>>>>>    SQL_PREPARE_STMT
71117>>>>>>>>>>>    // Indicate that a stored function will be executed - Query = 0, Procedure = 1, Function = 2
71117>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_EMBEDDED_SQL_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 1 RESULT MertechInc_iRet
71122>>>>>>>>>>>End_Procedure
71123>>>>>>>>>>>
71123>>>>>>>>>>>//=============================================================================
71123>>>>>>>>>>>/// @Name        SQL_GET_STMT
71123>>>>>>>>>>>/// @Description This command returns the last embedded SQL statement that
71123>>>>>>>>>>>/// was executed into a string. Optional parameters can be passed to specify
71123>>>>>>>>>>>/// what character to start the string at and also the maximum number of
71123>>>>>>>>>>>/// characters to allow for the string.
71123>>>>>>>>>>>///
71123>>>>>>>>>>>/// @Assumptions
71123>>>>>>>>>>>/// @Status      Public
71123>>>>>>>>>>>/// @Drivers     All
71123>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
71123>>>>>>>>>>>/// @See                 SQL_GET_STATEMENT
71123>>>>>>>>>>>///
71123>>>>>>>>>>>/// @Syntax SQL_GET_STMT to {variable} [{max} {start}]
71123>>>>>>>>>>>/// @Param variable                     SQL statement to be executed
71123>>>>>>>>>>>/// @Param max                          Indicates the maximum number of characters to get (optional)
71123>>>>>>>>>>>/// @Param start                        Indicates what character to start at for the returned string (optional)
71123>>>>>>>>>>>///
71123>>>>>>>>>>>/// @Example
71123>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
71123>>>>>>>>>>>/// SQL_PREPARE_STMT
71123>>>>>>>>>>>/// SQL_EXECUTE_STMT
71123>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
71123>>>>>>>>>>>/// If (Found) Begin
71123>>>>>>>>>>>///     Showln sFirstName
71123>>>>>>>>>>>///     Showln sLastName
71123>>>>>>>>>>>/// End
71123>>>>>>>>>>>///
71123>>>>>>>>>>>/// SQL_GET_STATEMENT to sValue
71123>>>>>>>>>>>/// Showln sValue
71123>>>>>>>>>>>
71123>>>>>>>>>>>
71123>>>>>>>>>>>Function MertechInc_SQL_GET_STATEMENT Global Integer iLength Integer iStart Returns String
71125>>>>>>>>>>>    String sStatement
71125>>>>>>>>>>>
71125>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
71151>>>>>>>>>>>>
71151>>>>>>>>>>>
71151>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
71153>>>>>>>>>>>        Get MertechInc_Pre_Size_String 0 to sStatement
71154>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SQL_STMT CALLBACK 0 PASSING sStatement iStart iLength RESULT MertechInc_iRet
71159>>>>>>>>>>>    End
71159>>>>>>>>>>>>
71159>>>>>>>>>>>    Function_Return sStatement
71160>>>>>>>>>>>End_Function
71161>>>>>>>>>>>
71161>>>>>>>>>>>//=============================================================================
71161>>>>>>>>>>>/// @Name        SQL_SET_FUNCTION_NAME
71161>>>>>>>>>>>/// @Description This command is used in the same way as SQL_SET_PROCEDURE_NAME
71161>>>>>>>>>>>/// and SQL_SET_STMT to set the name of the function to be executed. When
71161>>>>>>>>>>>/// calling SQL functions in this fashion, this command must be used along with
71161>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE (to execute the function), SQL_SET_FUNCTION_PARAMETER
71161>>>>>>>>>>>/// (to set the needed parameters) and SQL_GET_FUNCTION_RETURN (to get any
71161>>>>>>>>>>>/// returned value). The number of parameters must be set using the constant,
71161>>>>>>>>>>>/// NUMPAR, followed by the number of parameters. Note that when setting the
71161>>>>>>>>>>>/// name of the function, the user can be specified or, if left blank, the
71161>>>>>>>>>>>/// current user will be inserted before the function name.
71161>>>>>>>>>>>///
71161>>>>>>>>>>>/// @Assumptions
71161>>>>>>>>>>>/// @Status      Public
71161>>>>>>>>>>>/// @Drivers     All
71161>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
71161>>>>>>>>>>>/// @See                 SQL_FUNCTION_EXECUTE SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
71161>>>>>>>>>>>///
71161>>>>>>>>>>>/// @Syntax SQL_SET_FUNCTION_NAME {function} NUMPAR {parameters}
71161>>>>>>>>>>>/// @Param function                     Full name of the function
71161>>>>>>>>>>>/// @Param parameters           Number of parameters to pass
71161>>>>>>>>>>>///
71161>>>>>>>>>>>/// @Example
71161>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
71161>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
71161>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
71161>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
71161>>>>>>>>>>>/// Showln dDOB
71161>>>>>>>>>>>
71161>>>>>>>>>>>Procedure MertechInc_SQL_SET_ORAFUNCTION_NAME Global String strProcName Integer iNumpar
71163>>>>>>>>>>>    Integer iParam
71163>>>>>>>>>>>
71163>>>>>>>>>>>    SQL_SET_STMT to "BEGIN "
71195>>>>>>>>>>>    SQL_APPEND_STMT to ":PAR_RET := "
71227>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
71259>>>>>>>>>>>    SQL_APPEND_STMT to "( "
71291>>>>>>>>>>>    For iParam from 1 to iNumpar
71297>>>>>>>>>>>>
71297>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
71376>>>>>>>>>>>    Loop
71377>>>>>>>>>>>>
71377>>>>>>>>>>>    SQL_APPEND_STMT to  " ); END;"
71409>>>>>>>>>>>    SQL_PREPARE_STMT
71458>>>>>>>>>>>
71458>>>>>>>>>>>    Move IS_OUT to MertechInc_iArg
71459>>>>>>>>>>>    Call_Driver 0 ORAFLEX Function CALLDRV_SET_PROC_ATTRIBUTE_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank MertechInc_iArg RESULT MertechInc_iRet
71464>>>>>>>>>>>
71464>>>>>>>>>>>    Increment MertechInc_iParamCount
71465>>>>>>>>>>>    Move ":PAR_RET" to MertechInc_sArg2
71466>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING MertechInc_Blank MertechInc_sArg2 16384 RESULT MertechInc_iRet
71471>>>>>>>>>>>End_Procedure
71472>>>>>>>>>>>
71472>>>>>>>>>>>Procedure MertechInc_SQL_SET_MYFUNCTION_NAME Global String strProcName Integer iNumpar
71474>>>>>>>>>>>    Integer iParam
71474>>>>>>>>>>>
71474>>>>>>>>>>>    Move MySQLFlex to MertechInc_DriverName
71475>>>>>>>>>>>
71475>>>>>>>>>>>    SQL_SET_STMT to "SELECT "
71507>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
71539>>>>>>>>>>>    SQL_APPEND_STMT to "("
71571>>>>>>>>>>>    For iParam from 1 to iNumpar
71577>>>>>>>>>>>>
71577>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
71656>>>>>>>>>>>    Loop
71657>>>>>>>>>>>>
71657>>>>>>>>>>>    SQL_APPEND_STMT to ")"
71689>>>>>>>>>>>    SQL_PREPARE_STMT
71738>>>>>>>>>>>End_Procedure
71739>>>>>>>>>>>
71739>>>>>>>>>>>Procedure MertechInc_SQL_SET_SQLFUNCTION_NAME Global String strProcName Integer iNumpar
71741>>>>>>>>>>>    Integer iParam
71741>>>>>>>>>>>
71741>>>>>>>>>>>    Move SQLFlex to MertechInc_DriverName
71742>>>>>>>>>>>
71742>>>>>>>>>>>    If (not(strProcName contains ".")) Begin
71744>>>>>>>>>>>        String schema
71744>>>>>>>>>>>        GET_SCHEMA_NAME to schema
71790>>>>>>>>>>>        Move (schema + "." + strProcName) to strProcName
71791>>>>>>>>>>>    End
71791>>>>>>>>>>>>
71791>>>>>>>>>>>
71791>>>>>>>>>>>    SQL_SET_STMT    to "SELECT "
71823>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
71855>>>>>>>>>>>    SQL_APPEND_STMT to "("
71887>>>>>>>>>>>End_Procedure
71888>>>>>>>>>>>
71888>>>>>>>>>>>Procedure MertechInc_SQL_SET_PGFUNCTION_NAME Global String strProcName Integer iNumpar
71890>>>>>>>>>>>    Integer iParam
71890>>>>>>>>>>>
71890>>>>>>>>>>>    Move PgFlex to MertechInc_DriverName
71891>>>>>>>>>>>
71891>>>>>>>>>>>    SQL_SET_STMT    to "SELECT "
71923>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
71955>>>>>>>>>>>    SQL_APPEND_STMT to "("
71987>>>>>>>>>>>End_Procedure
71988>>>>>>>>>>>
71988>>>>>>>>>>>//=============================================================================
71988>>>>>>>>>>>/// @Name        SQL_SET_PROCEDURE_PARAMETER
71988>>>>>>>>>>>/// @Description
71988>>>>>>>>>>>/// With this command you can pass one or more parameters to predefined
71988>>>>>>>>>>>/// stored procedures on a MySQL or Oracle server. The SQL_SET_PROCEDURE_PARAMETER
71988>>>>>>>>>>>/// command enables you to add a parameter to a stored procedure which you are
71988>>>>>>>>>>>/// planning to call. You can pass multiple parameters by calling the command
71988>>>>>>>>>>>/// for each parameter.
71988>>>>>>>>>>>///
71988>>>>>>>>>>>/// When passing parameters you'll have to inform the driver which variable
71988>>>>>>>>>>>/// you are passing, starting with 1 from left-to-right in the parameter list.
71988>>>>>>>>>>>///
71988>>>>>>>>>>>/// For each parameter you'll have to indicate if the variable is to be
71988>>>>>>>>>>>/// regarded as input, output or both.
71988>>>>>>>>>>>///
71988>>>>>>>>>>>///@Assumptions
71988>>>>>>>>>>>/// @Status      Public
71988>>>>>>>>>>>/// @Drivers     All
71988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-27 by Aaron Gulack
71988>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_PROCEDURE_EXECUTE
71988>>>>>>>>>>>///
71988>>>>>>>>>>>/// @Syntax SQL_SET_PROCEDURE_PARAMETER {number} to {variable} {direction}
71988>>>>>>>>>>>/// @Param number                       Index number of the parameter being defined.
71988>>>>>>>>>>>/// @Param variable                     Variable holding the parameter to be passed.
71988>>>>>>>>>>>/// @Param direction            IN, OUT, IN_OUT, RSET, or leave blank
71988>>>>>>>>>>>///
71988>>>>>>>>>>>/// @Example
71988>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
71988>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
71988>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
71988>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
71988>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
71988>>>>>>>>>>>
71988>>>>>>>>>>>
71988>>>>>>>>>>>
71988>>>>>>>>>>>//=============================================================================
71988>>>>>>>>>>>/// @Name        SQL_SET_QUERY_PARAMETER
71988>>>>>>>>>>>/// @Description
71988>>>>>>>>>>>/// Use this command to set the value of the parameters that are defined in your
71988>>>>>>>>>>>/// SQL Query. Each backend uses a different syntax for paramterized queries,
71988>>>>>>>>>>>/// but all have the same goal of removing the risk of SQL Injection attacks.
71988>>>>>>>>>>>/// Oracle and PostgreSQL allow for named parameters which this command supports
71988>>>>>>>>>>>/// by passing the first parameter as a string containing the named parameter
71988>>>>>>>>>>>/// (without the syntactical sugar). For MS-SQL and MySQL only positional
71988>>>>>>>>>>>/// parameters are supported and the first parameter to this command should be an
71988>>>>>>>>>>>/// integer containing the ordinal position of the parameter.
71988>>>>>>>>>>>///
71988>>>>>>>>>>>///
71988>>>>>>>>>>>///@Assumptions
71988>>>>>>>>>>>/// @Status      Public
71988>>>>>>>>>>>/// @Drivers     All
71988>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
71988>>>>>>>>>>>/// @See         SQL_SET_STMT SQL_EXECUTE_STMT
71988>>>>>>>>>>>///
71988>>>>>>>>>>>/// @Syntax SQL_SET_QUERY_PARAMETER {param} to {variable}
71988>>>>>>>>>>>/// @Param param                     Either a string containing the named parameter or an integer of it's ordinal position.
71988>>>>>>>>>>>/// @Param variable/constant         Variable or constant holding the parameter to be passed.
71988>>>>>>>>>>>///
71988>>>>>>>>>>>/// @Example
71988>>>>>>>>>>>/// SQL_SET_STMT "Select name from Customer where status = ? and city = ?"
71988>>>>>>>>>>>/// SQL_SET_QUERY_PARAMETER 1 to "Y"
71988>>>>>>>>>>>/// SQL_SET_QUERY_PARAMETER 2 to "Fresno"
71988>>>>>>>>>>>/// SQL_EXECUTE_STMT
71988>>>>>>>>>>>
71988>>>>>>>>>>>Function MDS_Get_Param_Type Global Variant vVal Returns Integer
71990>>>>>>>>>>>    Local Integer vartype retval
71990>>>>>>>>>>>    Local Variant some_val
71990>>>>>>>>>>>    Move vVal to some_val
71991>>>>>>>>>>>    Move (DeRefW(AddressOf(some_val), 0)) to vartype
71992>>>>>>>>>>>
71992>>>>>>>>>>>    If (vartype = 2) Begin
71994>>>>>>>>>>>        Move ((13 * (2^24)) + 6) to retval
71995>>>>>>>>>>>    End
71995>>>>>>>>>>>>
71995>>>>>>>>>>>    Else If (vartype = 3) Begin
71998>>>>>>>>>>>        Move ((3 * (2^24)) + 11) to retval
71999>>>>>>>>>>>    End
71999>>>>>>>>>>>>
71999>>>>>>>>>>>    Else If (vartype = 4) Begin // OLE_VT_R4
72002>>>>>>>>>>>        Move ((10 * (2^24)) + 11) to retval
72003>>>>>>>>>>>    End
72003>>>>>>>>>>>>
72003>>>>>>>>>>>    Else If (vartype = 5) Begin // OLE_VT_R8
72006>>>>>>>>>>>        Move ((5 * (2^24)) + 26) to retval
72007>>>>>>>>>>>    End
72007>>>>>>>>>>>>
72007>>>>>>>>>>>    Else If (vartype = 6) Begin // OLE_VT_Currency
72010>>>>>>>>>>>        Move ((18 * (2^24)) + 21) to retval
72011>>>>>>>>>>>    End
72011>>>>>>>>>>>>
72011>>>>>>>>>>>    Else If (vartype = 7) Begin // OLE_VT_Date
72014>>>>>>>>>>>        Move ((9 * (2^24)) + 26) to retval
72015>>>>>>>>>>>    End
72015>>>>>>>>>>>>
72015>>>>>>>>>>>    Else If (vartype = 11) Begin // OLE_VT_Bool
72018>>>>>>>>>>>        Move ((16 * (2^24)) + 1) to retval
72019>>>>>>>>>>>    End
72019>>>>>>>>>>>>
72019>>>>>>>>>>>    Else If (vartype = 14) Begin // OLE_VT_Decimal
72022>>>>>>>>>>>        Move ((2 * (2^24)) + 34) to retval
72023>>>>>>>>>>>    End
72023>>>>>>>>>>>>
72023>>>>>>>>>>>    Else If (vartype = 16) Begin // OLE_VT_I1
72026>>>>>>>>>>>        Move ((11 * (2^24)) + 4) to retval
72027>>>>>>>>>>>    End
72027>>>>>>>>>>>>
72027>>>>>>>>>>>    Else If (vartype = 17) Begin // OLE_VT_Ui1
72030>>>>>>>>>>>        Move ((12 * (2^24)) + 3) to retval
72031>>>>>>>>>>>    End
72031>>>>>>>>>>>>
72031>>>>>>>>>>>    Else If (vartype = 18) Begin // OLE_VT_Ui2
72034>>>>>>>>>>>        Move ((14 * (2^24)) + 5) to retval
72035>>>>>>>>>>>    End
72035>>>>>>>>>>>>
72035>>>>>>>>>>>    Else If (vartype = 19) Begin // OLE_VT_Ui4
72038>>>>>>>>>>>        Move ((15 * (2^24)) + 10) to retval
72039>>>>>>>>>>>    End
72039>>>>>>>>>>>>
72039>>>>>>>>>>>    Else If (vartype = 17) Begin // OLE_VT_I8
72042>>>>>>>>>>>        Move ((4 * (2^24)) + 20) to retval
72043>>>>>>>>>>>    End
72043>>>>>>>>>>>>
72043>>>>>>>>>>>
72043>>>>>>>>>>>    Function_Return retval
72044>>>>>>>>>>>End_Function
72045>>>>>>>>>>>
72045>>>>>>>>>>>//=============================================================================
72045>>>>>>>>>>>/// @Name        SQL_GET_PROCEDURE_PARAMETER
72045>>>>>>>>>>>/// @Description This command is used to get the value of a specific
72045>>>>>>>>>>>/// parameter associated with a stored procedure.  Although this
72045>>>>>>>>>>>/// command will work with any parameter, it is mostly be used with
72045>>>>>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
72045>>>>>>>>>>>/// once returned. When multiple values are returned, this command can be
72045>>>>>>>>>>>/// more efficient than other options. Note that the specified parameter
72045>>>>>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
72045>>>>>>>>>>>/// in order to work properly.
72045>>>>>>>>>>>///
72045>>>>>>>>>>>/// @Assumptions
72045>>>>>>>>>>>/// @Status      Public
72045>>>>>>>>>>>/// @Drivers     All
72045>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72045>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
72045>>>>>>>>>>>///
72045>>>>>>>>>>>/// @Syntax SQL_GET_PROCEDURE_PARAMETER {parameter} to {variable}
72045>>>>>>>>>>>/// @Param parameter            Number of paramater to return
72045>>>>>>>>>>>/// @Param variable                     Variable to hold the value of the parameter
72045>>>>>>>>>>>///
72045>>>>>>>>>>>/// @Example
72045>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
72045>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
72045>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
72045>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 1 to sStatus
72045>>>>>>>>>>>///
72045>>>>>>>>>>>/// Showln sStatus
72045>>>>>>>>>>>///
72045>>>>>>>>>>>/// @Example
72045>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
72045>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
72045>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
72045>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
72045>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
72045>>>>>>>>>>>///
72045>>>>>>>>>>>/// Showln sStatus
72045>>>>>>>>>>>
72045>>>>>>>>>>>
72045>>>>>>>>>>>
72045>>>>>>>>>>>//=============================================================================
72045>>>>>>>>>>>/// @Name        SQL_GET_FUNCTION_RETURN
72045>>>>>>>>>>>/// @Description This variable is used to get the value returned from a SQL
72045>>>>>>>>>>>/// function call. After the function has been successfully called, this
72045>>>>>>>>>>>/// command takes the returned value and inserts it the given variable.
72045>>>>>>>>>>>///
72045>>>>>>>>>>>/// @Assumptions
72045>>>>>>>>>>>/// @Status      Public
72045>>>>>>>>>>>/// @Drivers     All
72045>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72045>>>>>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_FUNCTION_EXECUTE
72045>>>>>>>>>>>///
72045>>>>>>>>>>>/// @Syntax SQL_GET_FUNCTION_RETURN to {variable}
72045>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
72045>>>>>>>>>>>///
72045>>>>>>>>>>>/// @Example
72045>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
72045>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
72045>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
72045>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
72045>>>>>>>>>>>/// Showln dDOB
72045>>>>>>>>>>>
72045>>>>>>>>>>>//=============================================================================
72045>>>>>>>>>>>/// @Name        SQL_FUNCTION_EXECUTE
72045>>>>>>>>>>>/// @Description This command is used to execute the function statement
72045>>>>>>>>>>>/// that was built by the SQL_SET_FUNCTION_NAME and subsequent
72045>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER commands. This works similarly to the
72045>>>>>>>>>>>/// SQL_EXECUTE_STMT command. Note that executing the function with this
72045>>>>>>>>>>>/// command will not get any returned values but will simply execute the
72045>>>>>>>>>>>/// function.
72045>>>>>>>>>>>///
72045>>>>>>>>>>>/// @Assumptions
72045>>>>>>>>>>>/// @Status      Public
72045>>>>>>>>>>>/// @Drivers     All
72045>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72045>>>>>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
72045>>>>>>>>>>>///
72045>>>>>>>>>>>/// @Syntax SQL_FUNCTION_EXECUTE
72045>>>>>>>>>>>///
72045>>>>>>>>>>>/// @Example
72045>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
72045>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
72045>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
72045>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
72045>>>>>>>>>>>/// Showln dDOB
72045>>>>>>>>>>>
72045>>>>>>>>>>>Procedure MertechInc_SQL_FUNCTION_EXECUTE Global String sDriverName
72047>>>>>>>>>>>    Integer iParam
72047>>>>>>>>>>>    String  sParam
72047>>>>>>>>>>>
72047>>>>>>>>>>>    If (sDriverName = SQLFLEX or sDriverName = PgFlex) Begin
72049>>>>>>>>>>>       SQL_APPEND_STMT to ')'
72081>>>>>>>>>>>       SQL_PREPARE_STMT
72130>>>>>>>>>>>    End
72130>>>>>>>>>>>>
72130>>>>>>>>>>>
72130>>>>>>>>>>>    SQL_EXECUTE_STMT
72170>>>>>>>>>>>    If (sDriverName <> ORAFLEX) Begin
72172>>>>>>>>>>>        SQL_FETCH_NEXT_ROW
72222>>>>>>>>>>>    End
72222>>>>>>>>>>>>
72222>>>>>>>>>>>End_Procedure
72223>>>>>>>>>>>
72223>>>>>>>>>>>//=============================================================================
72223>>>>>>>>>>>/// @Name        REEXEC_ORACLE_STORED_PROCEDURE
72223>>>>>>>>>>>/// @Description This command is used to re-execute a stored procedure
72223>>>>>>>>>>>/// when using Oracle. Although it follows the same format as
72223>>>>>>>>>>>/// CALL_STORED_PROCEDURE, it can be useful because it does not need to
72223>>>>>>>>>>>/// prepare the procedure again before executing. This can cause speed
72223>>>>>>>>>>>/// improvements when calling a stored procedure multiple times.
72223>>>>>>>>>>>///
72223>>>>>>>>>>>/// @Assumptions A procedure has already been created through CALL_STORED_PROCEDURE
72223>>>>>>>>>>>/// @Status      Public
72223>>>>>>>>>>>/// @Drivers     ORAFLex
72223>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
72223>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
72223>>>>>>>>>>>///
72223>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
72223>>>>>>>>>>>/// @Param procedure            Full name of the procedure
72223>>>>>>>>>>>/// @Param variable                     Parameter to pass (optional and can be multiple)
72223>>>>>>>>>>>///
72223>>>>>>>>>>>/// @Example
72223>>>>>>>>>>>/// CALL_STORED_PROCEDURE "user.getCustomerStatus" Passing sCustomerID sStatus
72223>>>>>>>>>>>/// Showln sStatus
72223>>>>>>>>>>>///
72223>>>>>>>>>>>/// Move (sCustomerID + 1) to sCustomerID
72223>>>>>>>>>>>///
72223>>>>>>>>>>>/// REEXEC_ORACLE_STORED_PROCEDURE "user.getCustomerStatus" passing sCustomerID sStatus
72223>>>>>>>>>>>/// Showln sStatus
72223>>>>>>>>>>>
72223>>>>>>>>>>>
72223>>>>>>>>>>>//=============================================================================
72223>>>>>>>>>>>/// @Name        CALL_STORED_FUNCTION
72223>>>>>>>>>>>/// @Description This command is used to execute a function stored in the
72223>>>>>>>>>>>/// SQL backend. This is an alternative to building a function with the
72223>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME, SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE
72223>>>>>>>>>>>/// commands. This command builds and executes the function by setting the full
72223>>>>>>>>>>>/// function name, the parameter(s) to pass and the variable to hold the
72223>>>>>>>>>>>/// returned value. Note that this command can only return a single value
72223>>>>>>>>>>>/// so SQL_SET_FUNCTION_PARAMETER and SQL_SET_FUNCTION_NAME must be used when
72223>>>>>>>>>>>/// dealing with multiple return values.
72223>>>>>>>>>>>///
72223>>>>>>>>>>>/// Assumptions
72223>>>>>>>>>>>/// @Status      Public
72223>>>>>>>>>>>/// @Drivers     ORAFLex MySQLFlex PgFlex
72223>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72223>>>>>>>>>>>/// @See
72223>>>>>>>>>>>///
72223>>>>>>>>>>>/// @Syntax CALL_STORED_FUNCTION {function} Returns {variable} Passing {parameters}
72223>>>>>>>>>>>/// @Param function                     Full name of the function
72223>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
72223>>>>>>>>>>>/// @Param parameters           Parameter to pass to the function (can be multiple)
72223>>>>>>>>>>>///
72223>>>>>>>>>>>/// @Example
72223>>>>>>>>>>>/// Move 5 to sCustomerID
72223>>>>>>>>>>>/// CALL_STORED_FUNCTION "getCustomerStatus" Returns sStatus Passing sCustomerID
72223>>>>>>>>>>>/// Showln sStatus
72223>>>>>>>>>>>
72223>>>>>>>>>>>//=============================================================================
72223>>>>>>>>>>>/// @Name        OUTPUT_INT_FILE
72223>>>>>>>>>>>/// @Description This command is used to output the int file of an opened
72223>>>>>>>>>>>/// table. If the file to be output to does not exist, it will be created
72223>>>>>>>>>>>/// upon execution of this command. Note that the INT file can be output
72223>>>>>>>>>>>/// into multiple types of files i.e. .doc, .txt, .int.
72223>>>>>>>>>>>///
72223>>>>>>>>>>>/// @Assumptions
72223>>>>>>>>>>>/// @Status      Public
72223>>>>>>>>>>>/// @Drivers     All
72223>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72223>>>>>>>>>>>/// @See
72223>>>>>>>>>>>///
72223>>>>>>>>>>>/// @Syntax OUTPUT_INT_FILE for {FileNumber} to {variable}
72223>>>>>>>>>>>/// @Param FileNumber           The file number
72223>>>>>>>>>>>/// @Param variable                     Path of the file being output to
72223>>>>>>>>>>>///
72223>>>>>>>>>>>///@Example
72223>>>>>>>>>>>/// OUTPUT_INT_FILE for Customer.File_Number to "C:\Temp\Customer.int"
72223>>>>>>>>>>>
72223>>>>>>>>>>>//=============================================================================
72223>>>>>>>>>>>/// @Name        SQL_ERROR_MESSAGE
72223>>>>>>>>>>>/// @Description This command is used to get an error message
72223>>>>>>>>>>>/// from a given SQL statement. If the given statement is executed with
72223>>>>>>>>>>>/// no errors, the variable specified with this command will be blank.
72223>>>>>>>>>>>/// Otherwise the message will be stored in the given variable. Note that
72223>>>>>>>>>>>/// unless specified, strings have a size limit of 80 characters, so using
72223>>>>>>>>>>>/// a variant can ensure the full message is retrieved.
72223>>>>>>>>>>>///
72223>>>>>>>>>>>/// @Assumptions
72223>>>>>>>>>>>/// @Status      Public
72223>>>>>>>>>>>/// @Drivers     All
72223>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72223>>>>>>>>>>>/// @See         SQL_ERROR_MESSAGE2
72223>>>>>>>>>>>///
72223>>>>>>>>>>>/// @Syntax SQL_ERROR_MESSAGE {variable}
72223>>>>>>>>>>>/// @Param variable                     Variable to hold the error message
72223>>>>>>>>>>>///
72223>>>>>>>>>>>/// @Example
72223>>>>>>>>>>>/// SQL_ERROR_MESSAGE sError
72223>>>>>>>>>>>
72223>>>>>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE Global Returns String
72225>>>>>>>>>>>    String sMessage
72225>>>>>>>>>>>
72225>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sMessage
72226>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE CALLBACK 0 PASSING MertechInc_Blank sMessage 0 RESULT MertechInc_iRet
72231>>>>>>>>>>>
72231>>>>>>>>>>>    Function_Return sMessage
72232>>>>>>>>>>>End_Function
72233>>>>>>>>>>>
72233>>>>>>>>>>>//=============================================================================
72233>>>>>>>>>>>/// @Name        SQL_ERROR_MESSAGE2
72233>>>>>>>>>>>/// @Description This command is used to get the last error message used
72233>>>>>>>>>>>/// for the specified server. This can be useful once a transaction has
72233>>>>>>>>>>>/// already been completed and any error messages need to be retrieved.
72233>>>>>>>>>>>///
72233>>>>>>>>>>>/// @Assumptions
72233>>>>>>>>>>>/// @Status      Public
72233>>>>>>>>>>>/// @Drivers     All
72233>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72233>>>>>>>>>>>/// @See         SQL_ERROR_MESSAGE SQL_ERROR_MESSAGE2
72233>>>>>>>>>>>///
72233>>>>>>>>>>>/// @Syntax SQL_ERROR_MESSAGE2 of {server} to {variable}
72233>>>>>>>>>>>/// @Param server                       Name of the server
72233>>>>>>>>>>>/// @Param variable                     Variable to hold the error message
72233>>>>>>>>>>>///
72233>>>>>>>>>>>/// @Example
72233>>>>>>>>>>>/// SQL_ERROR_MESSAGE2 of "localhost" to sError
72233>>>>>>>>>>>
72233>>>>>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE2 Global String sServer Returns String
72235>>>>>>>>>>>    String sMessage
72235>>>>>>>>>>>
72235>>>>>>>>>>>    Get MertechInc_Pre_Size_String 800 to sMessage
72236>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE2 CALLBACK 0 PASSING sServer sMessage 0 RESULT MertechInc_iRet
72241>>>>>>>>>>>
72241>>>>>>>>>>>    Function_Return sMessage
72242>>>>>>>>>>>End_Function
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        MERTECH_WARNING_MESSAGE
72243>>>>>>>>>>>/// @Description When restructuring a table, i.e. Structure_Start, a warning
72243>>>>>>>>>>>/// message will appear to confirm the restructure before it is executed.
72243>>>>>>>>>>>/// This command is used to disable or enable that warning message. All that
72243>>>>>>>>>>>/// is passed is either the constant "Enabled" or "Disabled". By default,
72243>>>>>>>>>>>/// this message is enabled.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     All
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax MERTECH_WARNING_MESSAGE {Enabled|Disabled}
72243>>>>>>>>>>>/// @Param Enabled                      Enables the restructure warning
72243>>>>>>>>>>>/// @Param Disabled                     Disables the restructure warning
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// Move Customer.File_Number to hFile
72243>>>>>>>>>>>/// MERTECH_WARNING_MESSAGE Disabled
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// Structure_Start hFile
72243>>>>>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
72243>>>>>>>>>>>/// Structure_End hFile
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        DISABLE_SELECT_COLUMNS_ERRORS
72243>>>>>>>>>>>/// @Description When using SELECT_COLUMNS_FIND to limit the number of columns
72243>>>>>>>>>>>/// to fetch, the framework might still ask for columns that you do not need.
72243>>>>>>>>>>>/// As a result you'll end up getting runtime errors you do not want to see.
72243>>>>>>>>>>>/// This command gives you the ability to stop reporting errors for querying
72243>>>>>>>>>>>/// for data from columns that are not part of the query.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// DISABLED_SELECT_COLUMNS_ERRORS DISABLED will disable the errors, use
72243>>>>>>>>>>>/// ENABLED to turn the error messages back on.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// By default triggering error messages on unknown columns is ENABLED
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     All
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
72243>>>>>>>>>>>/// @See         SELECT_COLUMNS_FIND RESET_FETCH_FIELDS
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// Open Customer
72243>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
72243>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
72243>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// Clear Customer
72243>>>>>>>>>>>/// Repeat
72243>>>>>>>>>>>///    Find Gt Customer by Index.1
72243>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
72243>>>>>>>>>>>/// Until (Not(Found))
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax DISABLE_SELECT_COLUMNS_ERRORS {ENABLED|DISABLED}
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        SQLFlex_REVISION
72243>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
72243>>>>>>>>>>>/// of the MSSQL driver associated with the current workspace into the
72243>>>>>>>>>>>/// specified variable.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Deprecated
72243>>>>>>>>>>>/// @Drivers     SQLFlex
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72243>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax SQLFlex_REVISION {variable}
72243>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// SQLFlex_REVISION sVersion
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        SQLFlex_MAJOR_REVISION
72243>>>>>>>>>>>/// @Description This command will put the major version (no decimals) of
72243>>>>>>>>>>>/// the the MSSQL driver associated with the current workspace into the
72243>>>>>>>>>>>/// specified variable.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Deprecated
72243>>>>>>>>>>>/// @Drivers     SQLFlex
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72243>>>>>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax SQLFlex_MAJOR_REVISION {variable}
72243>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// SQLFlex_MAJOR_REVISION sVersion
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        LOGGED_USERS
72243>>>>>>>>>>>/// @Description This command returns the number of native users that are
72243>>>>>>>>>>>/// using the driver currently. This number is stored in the variable that
72243>>>>>>>>>>>/// is passed with the command.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     All
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72243>>>>>>>>>>>/// @See                 MAXIMUM_NUMBER_OF_USERS
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax LOGGED_USERS {variable}
72243>>>>>>>>>>>/// @Param variable                     Variable to hold the number of users
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example LOGGED_USERS sUsers
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        MAXIMUM_NUMBER_OF_USERS
72243>>>>>>>>>>>/// @Description This command returns the maximum number of user allowed by
72243>>>>>>>>>>>/// the current license.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     All
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72243>>>>>>>>>>>/// @See                 LOGGED_USERS
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax MAXIMUM_NUMBER_OF_USERS {variable}
72243>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum number of users
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// MAXIMUM_NUMBER_OF_USERS sMax
72243>>>>>>>>>>>
72243>>>>>>>>>>> //=============================================================================
72243>>>>>>>>>>>/// @Name        MAXIMUM_NUMBER_OF_SESSIONS
72243>>>>>>>>>>>/// @Description This command returns the maximum number of sessions allowed by
72243>>>>>>>>>>>/// the current license.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     All
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2015-06-25 by Anton
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax MAXIMUM_NUMBER_OF_SESSIONS {variable}
72243>>>>>>>>>>>/// @Param variable         Variable to hold the maximum number of sessions
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// MAXIMUM_NUMBER_OF_SESSIONS sMax
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        SET_DATABASE_NAME
72243>>>>>>>>>>>/// @Description This command overrides the database set in the INT file
72243>>>>>>>>>>>/// under DATABASE_SPACE_NAME. Any opens or finds will use the database
72243>>>>>>>>>>>/// specified here. This can be used when the database is not stated in
72243>>>>>>>>>>>/// the INT file or if the database needs to be dynamically changed for
72243>>>>>>>>>>>/// a certain query. If the database is not specified with this command
72243>>>>>>>>>>>/// or in the INT file, then the default database for the server will be
72243>>>>>>>>>>>/// used. To set the database to be used for embedded SQL statements,
72243>>>>>>>>>>>/// use SQL_USE_DATABASE.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PGFlex
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72243>>>>>>>>>>>/// @See                 GET_DATABASE_NAME SQL_USE_DATABASE
72243>>>>>>>>>>>/// @INTOPT              DATABASE_SPACE_NAME
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax SET_DATABASE_NAME to {database}
72243>>>>>>>>>>>/// @Param database                     Name of the database
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// Login "localhost" "user" "pas123" "sql_drv"
72243>>>>>>>>>>>/// SET_DATABASE_NAME to "TestDB"
72243>>>>>>>>>>>/// Open Customer
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        GET_DATABASE_NAME
72243>>>>>>>>>>>/// @Description This command is used to get the name of the database
72243>>>>>>>>>>>/// currently being used. The name of the database is returned into the
72243>>>>>>>>>>>/// specified string. Even though this command works either way, it is
72243>>>>>>>>>>>/// typically used when the INT file does not contain the DATABASE_SPACE_NAME.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PgFlex
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72243>>>>>>>>>>>/// @See SET_DATABASE_NAME SQL_USE_DATABASE
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax GET_DATABASE_NAME to {variable}
72243>>>>>>>>>>>/// @Param variable                     Variable to hold the database name
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// GET_DATABASE_NAME to sDbName
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        GET_NAME_SPACE
72243>>>>>>>>>>>/// @Description This command returns the name space, or schema, being
72243>>>>>>>>>>>/// used with the current application.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     PgFlex
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72243>>>>>>>>>>>/// @See                 SET_NAME_SPACE
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax GET_NAME_SPACE to {variable}
72243>>>>>>>>>>>/// @Param variable                     Variable to hold the returned name space.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// GET_NAME_SPACE to sNameSpace
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        SET_NAME_SPACE
72243>>>>>>>>>>>/// @Description This command sets the name space, or schema, to be used
72243>>>>>>>>>>>/// for the application. In Postgres, schemas are objects where all the
72243>>>>>>>>>>>/// tables,views and indexes are stored. Separate schemas are used to
72243>>>>>>>>>>>/// specify relational data. Note that this command will override the
72243>>>>>>>>>>>/// NAME_SPACE value in the INT file.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     PgFlex
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-14 By Ian Smith
72243>>>>>>>>>>>/// @See                 GET_NAME_SPACE
72243>>>>>>>>>>>/// @INTOPT              NAME_SPACE
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax SET_NAME_SPACE to {variable}
72243>>>>>>>>>>>/// @Param variable                     Name of the name space
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// SET_NAME_SPACE to "public"
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        SQL_USE_DATABASE
72243>>>>>>>>>>>/// @Description This command is used to specify which database is used
72243>>>>>>>>>>>/// for SQL statements only. Any normal table queries or changes will
72243>>>>>>>>>>>/// still use the default database, this only effects SQL statements.
72243>>>>>>>>>>>/// If none is specified then the default database is used. This can
72243>>>>>>>>>>>/// be useful if a certain SQL statement needs to query data from a
72243>>>>>>>>>>>/// database not currently being used. Note that this only works if
72243>>>>>>>>>>>/// the table name is not fully qualified in the SQl statement, i.e.
72243>>>>>>>>>>>/// "TestDB.Customer".
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     SQLFlex MySQLFLex PgSQL
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
72243>>>>>>>>>>>/// @See                 SET_DATABASE_NAME GET_DATABASE_NAME
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax SQL_USE_DATABASE of {server} to {database}
72243>>>>>>>>>>>/// @Param server                       Name of the server (Postgre only)
72243>>>>>>>>>>>/// @Param database                     Name of the database
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// SQL_USE_DATABASE "testDB"
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
72243>>>>>>>>>>>/// SQL_PREPARE_STMT
72243>>>>>>>>>>>/// SQL_EXECUTE_STMT
72243>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName
72243>>>>>>>>>>>/// If (Found) Begin
72243>>>>>>>>>>>///     Showln sFirstName
72243>>>>>>>>>>>///     Showln sLastName
72243>>>>>>>>>>>/// End
72243>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER
72243>>>>>>>>>>>/// @Description This command is used to set the server to be used when
72243>>>>>>>>>>>/// opening tables. It will override the SERVER_NAME token in the INT file.
72243>>>>>>>>>>>/// If the server is not specified in the INT file or with this command,
72243>>>>>>>>>>>/// then the server used during login will be used. This command is only
72243>>>>>>>>>>>/// needed when connecting to multiple SQL servers. To set the server to
72243>>>>>>>>>>>/// use for embedded SQL statements, use SET_CURRENT_SQL_SERVER_CONNECTION.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     All
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72243>>>>>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER  SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
72243>>>>>>>>>>>/// @INTOPT              SERVER_NAME
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER to {server}
72243>>>>>>>>>>>/// @Param server                       Name of the server
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// SET_CURRENT_SQL_SERVER to "localhost"
72243>>>>>>>>>>>
72243>>>>>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
72243>>>>>>>>>>>//               replace conflicts with the property SET message.
72243>>>>>>>>>>>//#Replace SET_CURRENT_SERVER SET_CURRENT_SQL_SERVER
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER
72243>>>>>>>>>>>/// @Description This command returns the name of the server to be used
72243>>>>>>>>>>>/// for opening and querying tables.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     All
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
72243>>>>>>>>>>>/// @See SET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax GET_CURRENT_SERVER to {variable}
72243>>>>>>>>>>>/// @Param variable                     Variable to hold the server name
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// GET_CURRENT_SQL_SERVER to sServer
72243>>>>>>>>>>>
72243>>>>>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
72243>>>>>>>>>>>//               replace conflicts with the property GET message.
72243>>>>>>>>>>>//#Replace GET_CURRENT_SERVER GET_CURRENT_SQL_SERVER
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER_CONNECTION
72243>>>>>>>>>>>/// @Description This command is used to specify which server to use for
72243>>>>>>>>>>>/// embedded SQL statements. By default, the last logged in server will
72243>>>>>>>>>>>/// be used. Note that in addition to setting the server, this command
72243>>>>>>>>>>>/// also sets the driver to be used. This command is only needed when
72243>>>>>>>>>>>/// connecting to multiple servers. To set the server for opening tables,
72243>>>>>>>>>>>/// use SET_CURRENT_SQL_SERVER.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     All
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72243>>>>>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {server}
72243>>>>>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
72243>>>>>>>>>>>/// @Param server               Name of the server
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to "(localdb)\v11.0"
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER_CONNECTION
72243>>>>>>>>>>>/// @Description This command returns the server currently being used for
72243>>>>>>>>>>>/// embedded SQL statements.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     All
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72243>>>>>>>>>>>/// @See                 SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax GET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {variable}
72243>>>>>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
72243>>>>>>>>>>>/// @Param variable             Variable to hold the name of the server
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// GET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        LOGIN_SQLFLEX
72243>>>>>>>>>>>/// @Description This command allows the user to login with a specified
72243>>>>>>>>>>>/// hostname. The default hostname that is passed is the path of the
72243>>>>>>>>>>>/// executable. Passing a custom hostname can be very useful for tracking
72243>>>>>>>>>>>/// a specific user for different situations. For example, if a company
72243>>>>>>>>>>>/// is using a terminal server and a whole sales team logs in under the
72243>>>>>>>>>>>/// same username and hostname, locating a specific user could otherwise
72243>>>>>>>>>>>/// be difficult. With this command, each user can pass a custom hostname,
72243>>>>>>>>>>>/// easily distinguishing themselves from other users.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     SQLFlex
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72243>>>>>>>>>>>/// @See
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax LOGIN_SQLFLEX {server} {username} {password} {hostname}
72243>>>>>>>>>>>/// @Param server               Server to use for login
72243>>>>>>>>>>>/// @Param username     Username to use for login
72243>>>>>>>>>>>/// @Param password     Password to use for login
72243>>>>>>>>>>>/// @Param hostname     Hostname to use for login
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// LOGIN_SQLFLEX "localhost" "guestUser" "pas123" "WIN-MM7PQS5CP6C"
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        SQL_CANCEL_QUERY_STMT
72243>>>>>>>>>>>/// @Description This command is used to close any open cursors related to
72243>>>>>>>>>>>/// an SQL_EXECUTE_STMT. This should be used once the SQL statement has
72243>>>>>>>>>>>/// been executed and all rows have been fetched.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     All
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-03 by Aaron Gulack
72243>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_EXECUTE_STMT SQL_FETCH_NEXT_ROW SQL_APPEND_STMT SQL_PREPARE_STMT
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax SQL_CANCEL_QUERY_STMT [of {FileName}]
72243>>>>>>>>>>>/// @Param FileName             Name of the file (optional)
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
72243>>>>>>>>>>>/// SQL_PREPARE_STMT
72243>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
72243>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
72243>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW of Customer
72243>>>>>>>>>>>/// If (Found) Begin
72243>>>>>>>>>>>///     Showln Customer.FirstName
72243>>>>>>>>>>>///     Showln Customer.LastName
72243>>>>>>>>>>>/// End
72243>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT of Customer
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        NATIVE_OPTIMIZATION
72243>>>>>>>>>>>/// @Description Allows user to turn off the use of index hints on the native
72243>>>>>>>>>>>/// server. Setting this command to DEFAULT will cause the server to use the
72243>>>>>>>>>>>/// default settings for hints. Hints are off by default in Microsoft SQL
72243>>>>>>>>>>>/// Server but are on in Oracle. Care should be taken with changing the
72243>>>>>>>>>>>/// default, and should only be used if the diagnostics tool for your server
72243>>>>>>>>>>>/// indicates performance problems with the type of queries that are being
72243>>>>>>>>>>>/// generated. Note that this can be turned off or on for the whole server
72243>>>>>>>>>>>/// or just for a specific table.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// DEFAULT             - The specified server's default settings
72243>>>>>>>>>>>/// USE_INDEXHINT       - All Index hints will be used
72243>>>>>>>>>>>/// NO_INDEXHINT        - No index hints will be used
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     SQLFlex, ORAFlex
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
72243>>>>>>>>>>>/// @See
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax NATIVE_OPTIMIZATION of {scopeLevel} {variable} to {constant}
72243>>>>>>>>>>>/// @Param scopeLevel           TABLE or SERVER. Indicates the scope of the setting
72243>>>>>>>>>>>/// @Param variable                     Either the name of the server or of the table
72243>>>>>>>>>>>/// @Param constant                     DEFAULT, USE_INDEXHINT, or NO_INDEXHINT
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// NATIVE_OPTIMIZATION of SERVER "localhost" to USE_INDEXHINT
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        SET_ISOLATION_LEVEL
72243>>>>>>>>>>>/// @Description This command sets the locking and row versioning behavior
72243>>>>>>>>>>>/// for SQL statements. See the options below for information on the various
72243>>>>>>>>>>>/// effects they can have on transactions.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// DEFAULT  - The default isolation level for the server (READ_COMMITTED
72243>>>>>>>>>>>/// for MSSQL).
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// READ_COMMITTED - This option is used to prevent dirty reads. A dirty
72243>>>>>>>>>>>/// read is when one transaction reads data from another transaction that
72243>>>>>>>>>>>/// has yet to be committed. If one transaction fails, the other now is
72243>>>>>>>>>>>/// dealing with invalid data. By setting the isolation level to
72243>>>>>>>>>>>/// READ_COMMITTED, dirty reads will be avoided by not allowing transactions
72243>>>>>>>>>>>/// to deal with any other data that has not been committed yet. However,
72243>>>>>>>>>>>/// in between statements within the current transaction, data can be changed
72243>>>>>>>>>>>/// by other transactions. This can result in phantom data or non-repeatable
72243>>>>>>>>>>>/// reads. Note that this can slow down performance speeds but is usually
72243>>>>>>>>>>>/// good practice.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// READ_UNCOMMITTED - This option is the least restrictive isolation level.
72243>>>>>>>>>>>/// With this option, dirty reads are allowed, thus no exclusive locks are
72243>>>>>>>>>>>/// honored and modified data from one uncommitted transaction can be read
72243>>>>>>>>>>>/// by other transactions.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// REPEATABLE_READ - This option is similar to the READ_COMMITTED option
72243>>>>>>>>>>>/// in that locks all placed on all transactions and uncommitted data from
72243>>>>>>>>>>>///     other transactions cannot be read, preventing dirty reads. However, unlike
72243>>>>>>>>>>>/// READ_COMMITTED, new rows that are added by other transactions can be read
72243>>>>>>>>>>>/// by the current transaction if it is retried, possibly resulting in phantom
72243>>>>>>>>>>>/// reads. This option should not be used unless there is a specific reason to
72243>>>>>>>>>>>/// do so.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// SERIALIZABLE - This option is the most restrictive isolation level. With
72243>>>>>>>>>>>/// this option, no interaction is allowed between transactions until they
72243>>>>>>>>>>>/// have been committed. Similar to READ_COMMITTED, no transaction can deal
72243>>>>>>>>>>>/// with any uncommitted data. On top of that though, range locks are placed on
72243>>>>>>>>>>>/// all rows being modified until the current transaction is complete. Because
72243>>>>>>>>>>>/// concurrency is so low with this option, performance speeds can be much lower
72243>>>>>>>>>>>/// and so this should only be used when there is a specific reason to do so.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     All
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
72243>>>>>>>>>>>/// @See
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax SET_ISOLATION_LEVEL of {server} to {constant}
72243>>>>>>>>>>>/// @Param server                       Name of the server
72243>>>>>>>>>>>/// @Param constant                     DEFAULT, READ_COMMITTED, READ_UNCOMMITTED, REPEATABLE_READ, or SERIALIZABLE
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// LOGIN "localhost" "user" "pass123" "SQL_DRV"
72243>>>>>>>>>>>/// SET_ISOLATION_LEVEL of "localhost" to READ_COMMITTED
72243>>>>>>>>>>>
72243>>>>>>>>>>>//=============================================================================
72243>>>>>>>>>>>/// @Name        SET_SESSION_PARAMETER
72243>>>>>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
72243>>>>>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
72243>>>>>>>>>>>/// code pages. When migrating data, this command is used to determine whether
72243>>>>>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
72243>>>>>>>>>>>/// migrating passwords with special characters may call for different code
72243>>>>>>>>>>>/// pages. Sending true will convert the OEM data to ANSI, sending false will
72243>>>>>>>>>>>/// not. Both OEM_TO_ANSI and OEM_TRANSLATION_STATE do essentially the same
72243>>>>>>>>>>>/// thing, however since MSSQL has the functionality built in, OEM_TO_ANSI
72243>>>>>>>>>>>/// will use MSSQL's built in translation and thus only works with SQLFlex.
72243>>>>>>>>>>>/// OEM_TRANSLATION_STATE is internal and built into the driver so it works
72243>>>>>>>>>>>/// for all drivers. Note that if using custom entries with
72243>>>>>>>>>>>/// SET_CUSTOM_OEM_TO_ANSI then OEM_TRANSLATION_STATE must be used. Also, if
72243>>>>>>>>>>>/// there are already custom entries set then turning OEM_TRANSLATION_STATE
72243>>>>>>>>>>>/// on will automatically enable those custom translations.
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Assumptions
72243>>>>>>>>>>>/// @Status      Public
72243>>>>>>>>>>>/// @Drivers     All
72243>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
72243>>>>>>>>>>>/// @See                 SET_CUSTOM_OEM_TO_ANSI GET_CUSTOM_OEM_TO_ANSI
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Syntax SET_SESSION_PARAMETER {OEM_TO_ANSI/OEM_TRANSLATION_STATE} to {variable}
72243>>>>>>>>>>>/// @Param variable                     Boolean variable enabling or disabling translation
72243>>>>>>>>>>>///
72243>>>>>>>>>>>/// @Example
72243>>>>>>>>>>>/// SET_SESSION_PARAMETER OEM_TO_ANSI to True
72243>>>>>>>>>>>
72243>>>>>>>>>>>Procedure MertechInc_SET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
72245>>>>>>>>>>>    Move iChar to MertechInc_sArg1
72246>>>>>>>>>>>    move (String(iOem) + "," + String(iAnsi)) to MertechInc_sArg2
72247>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_SET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
72252>>>>>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
72255>>>>>>>>>>>End_Procedure
72256>>>>>>>>>>>
72256>>>>>>>>>>>//=============================================================================
72256>>>>>>>>>>>/// @Name        SET_CUSTOM_OEM_TO_ANSI
72256>>>>>>>>>>>/// @Description In very rare situations, a custom OEM to ANSI translation
72256>>>>>>>>>>>/// is needed. When that is the case, this command can be used to create
72256>>>>>>>>>>>/// those custom entries. This is done by passing the character numbered
72256>>>>>>>>>>>/// position, the OEM value and the ANSI value. Note that
72256>>>>>>>>>>>/// OEM_TRANSLATION_STATE must be set to true for these custom entries to
72256>>>>>>>>>>>/// work.
72256>>>>>>>>>>>///
72256>>>>>>>>>>>/// @Assumptions
72256>>>>>>>>>>>/// @Status      Public
72256>>>>>>>>>>>/// @Drivers     All
72256>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
72256>>>>>>>>>>>/// @See                 GET_CUSTOM_OEM_TO_ANSI SET_SESSION_PARAMETER
72256>>>>>>>>>>>///
72256>>>>>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
72256>>>>>>>>>>>/// @Param character            Numbered position (0-255) of the character
72256>>>>>>>>>>>/// @Param value1                       Character number for the OEM value
72256>>>>>>>>>>>/// @Param value2                       Character number for the ANSI value
72256>>>>>>>>>>>
72256>>>>>>>>>>>Procedure MertechInc_GET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
72258>>>>>>>>>>>    Move iChar to MertechInc_sArg1
72259>>>>>>>>>>>    Move (Repeat(" ", 255)) to MertechInc_sArg2
72260>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_GET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
72265>>>>>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
72268>>>>>>>>>>>End_Function
72269>>>>>>>>>>>
72269>>>>>>>>>>>//=============================================================================
72269>>>>>>>>>>>/// @Name        GET_CUSTOM_OEM_TO_ANSI
72269>>>>>>>>>>>/// @Description This command returns the custom OEM and ANSI values
72269>>>>>>>>>>>/// respectively for a given character. If there is no custom translation
72269>>>>>>>>>>>/// for the specified character then no error will be raised, but nothing
72269>>>>>>>>>>>/// will be returned.
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Assumptions There exists a custom translation for the specified character
72269>>>>>>>>>>>/// @Status      Public
72269>>>>>>>>>>>/// @Drivers     All
72269>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
72269>>>>>>>>>>>/// @See
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
72269>>>>>>>>>>>/// @Param character            Numbered position (0-255) of the character
72269>>>>>>>>>>>/// @Param value1                       Variable to hold the OEM value
72269>>>>>>>>>>>/// @Param value2                       Variable to hold the ANSI value
72269>>>>>>>>>>>
72269>>>>>>>>>>>//=============================================================================
72269>>>>>>>>>>>/// @Name        SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING
72269>>>>>>>>>>>/// @Description This command toggles off and on the automatic numeric
72269>>>>>>>>>>>/// data type remapping built into SQLFlex. When adding or creating
72269>>>>>>>>>>>/// smaller numeric columns during a restructure, SQLFlex will change
72269>>>>>>>>>>>/// the type to a more specific data type i.e. smallint or tinyint since
72269>>>>>>>>>>>/// they are handled more efficiently by the server. Sending false to this
72269>>>>>>>>>>>/// command will force SQl to keep the column as a numeric field, preserving
72269>>>>>>>>>>>/// the length and precision. Passing true will leave the remapping up to the
72269>>>>>>>>>>>/// driver.
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Assumptions
72269>>>>>>>>>>>/// @Status      Public
72269>>>>>>>>>>>/// @Drivers     SQLFlex
72269>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
72269>>>>>>>>>>>/// @See
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Syntax SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to {variable}
72269>>>>>>>>>>>/// @Param variable                     Boolean variable enabling or disabling remapping
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Example
72269>>>>>>>>>>>/// Structure_Start hFile
72269>>>>>>>>>>>///
72269>>>>>>>>>>>///     Create_Field hFile
72269>>>>>>>>>>>///
72269>>>>>>>>>>>///     SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to False
72269>>>>>>>>>>>///
72269>>>>>>>>>>>///     Set_Attribute DF_FIELD_NAME   of hFile iColumn to "Transaction_Count"
72269>>>>>>>>>>>///     Set_Attribute DF_FIELD_TYPE   of hFile iColumn to DF_BCD
72269>>>>>>>>>>>///     Set_Attribute DF_FIELD_LENGTH of hFile iColumn to 1
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// Structure_End hFile
72269>>>>>>>>>>>
72269>>>>>>>>>>>//=============================================================================
72269>>>>>>>>>>>/// @Name        SET_FORCE_DATE_FORMAT_INIT
72269>>>>>>>>>>>/// @Description At times, a stored procedure, function or trigger may
72269>>>>>>>>>>>/// alter the default format for dates. This could cause problems because,
72269>>>>>>>>>>>/// for example, if a trigger on a table does this, then every time a save
72269>>>>>>>>>>>/// takes place on that table, the format for dates will be changed. By
72269>>>>>>>>>>>/// sending true to this command, the date formats will reset to their
72269>>>>>>>>>>>/// default format. Note that this is essentially the same thing as running
72269>>>>>>>>>>>/// the SQL statement: "ALTER SESSION SET NLS_DATE_FORMAT='MM/DD/YYYY'", so
72269>>>>>>>>>>>/// in most situations, that should be used instead of this command.
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Assumptions
72269>>>>>>>>>>>/// @Status      Deprecated
72269>>>>>>>>>>>/// @Drivers     ORAFlex
72269>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
72269>>>>>>>>>>>/// @See
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Syntax SET_FORCE_DATE_FORMAT_INIT to {variable}
72269>>>>>>>>>>>/// @Param variable             Boolean variable enabling or disabling format reset
72269>>>>>>>>>>>
72269>>>>>>>>>>>//=============================================================================
72269>>>>>>>>>>>/// @Name        SET_STATIC_TABLE_OPTIMIZATION
72269>>>>>>>>>>>/// @Description At this time, this command no longer serves any function.
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Assumptions
72269>>>>>>>>>>>/// @Status      Deprecated
72269>>>>>>>>>>>/// @Drivers     SQLFlex
72269>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
72269>>>>>>>>>>>/// @See
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Syntax SET_STATIC_TABLE_OPTIMIZATION to {ENABLED/DISABLED}
72269>>>>>>>>>>>
72269>>>>>>>>>>>//=============================================================================
72269>>>>>>>>>>>/// @Name        GET_MAX_OBJECT_NAME_LENGTH
72269>>>>>>>>>>>/// @Description This command returns the maximum length allowed for object
72269>>>>>>>>>>>/// names in the SQl backend. This includes table names, column names,
72269>>>>>>>>>>>/// database names etc. The maximum length in put into the specified variable.
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Assumptions
72269>>>>>>>>>>>/// @Status      Public
72269>>>>>>>>>>>/// @Drivers     All
72269>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
72269>>>>>>>>>>>/// @See
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Syntax GET_MAX_OBJECT_NAME_LENGTH to {variable}
72269>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum length
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Example
72269>>>>>>>>>>>/// GET_MAX_OBJECT_NAME_LENGTH to iMaxLength
72269>>>>>>>>>>>
72269>>>>>>>>>>>//=============================================================================
72269>>>>>>>>>>>/// @Name        SET_SQL_LOCK_TIMEOUT
72269>>>>>>>>>>>/// @Description This command is used to set the number of milliseconds
72269>>>>>>>>>>>/// an SQL statement waits for a database lock to be released before timing
72269>>>>>>>>>>>/// out. Locks are used with transactions to maintain atomicity. If a lock is
72269>>>>>>>>>>>/// not released before the timeout, then the statement will fail and an error
72269>>>>>>>>>>>/// will be raised. By default, the timeout is set to -1, indicating that
72269>>>>>>>>>>>/// statements will wait indefinitely before timing out.
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Assumptions
72269>>>>>>>>>>>/// @Status      Public
72269>>>>>>>>>>>/// @Drivers     SQLFlex
72269>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
72269>>>>>>>>>>>/// @See                 GET_SQL_LOCK_TIMEOUT
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Syntax SET_SQL_LOCAL_TIMEOUT of {server} to {variable}
72269>>>>>>>>>>>/// @Param server                       Name of the server
72269>>>>>>>>>>>/// @Param variable                     Number of milliseconds to wait until timeout
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Example
72269>>>>>>>>>>>/// SET_SQL_LOCK_TIMEOUT of "localhost" to 6000
72269>>>>>>>>>>>
72269>>>>>>>>>>>//=============================================================================
72269>>>>>>>>>>>/// @Name        GET_SQL_LOCK_TIMEOUT
72269>>>>>>>>>>>/// @Description This command returns the number of milliseconds an SQL
72269>>>>>>>>>>>/// statement will wait for a database lock to be released. If the lock
72269>>>>>>>>>>>/// is not released before the timeout, then the statement will fail and
72269>>>>>>>>>>>/// an error will be raised. Note that the default value is -1, indicating
72269>>>>>>>>>>>/// that the statement will wait indefinitely.
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Assumptions
72269>>>>>>>>>>>/// @Status      Public
72269>>>>>>>>>>>/// @Drivers     SQLFlex
72269>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
72269>>>>>>>>>>>/// @See                 SET_SQL_LOCK_TIMEOUT
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Syntax GET_SQL_LOCAL_TIMEOUT of {server} to {variable}
72269>>>>>>>>>>>/// @Param server                       Name of the server
72269>>>>>>>>>>>/// @Param variable                     Variable to hold the number of milliseconds
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Example
72269>>>>>>>>>>>/// GET_SQL_LOCK_TIMEOUT of "localhost" to iTimeout
72269>>>>>>>>>>>
72269>>>>>>>>>>>//=============================================================================
72269>>>>>>>>>>>/// @Name        DO_GET_SQLSERVER_PARAMETERS
72269>>>>>>>>>>>/// @Description Retrieves stored procedure parameter values.
72269>>>>>>>>>>>///
72269>>>>>>>>>>>/// @Assumptions
72269>>>>>>>>>>>/// @Status      Internal
72269>>>>>>>>>>>/// @Drivers     All
72269>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
72269>>>>>>>>>>>/// @See
72269>>>>>>>>>>>
72269>>>>>>>>>>>Function MertechInc_DO_GET_SQLSERVER_PARAMETERS Global Integer iParameter Returns String
72271>>>>>>>>>>>    String sValue
72271>>>>>>>>>>>
72271>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sValue //Need to check if Call_Driver needs pre sized strings. Until then assume it does
72272>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 24 CALLBACK 0 PASSING sValue MertechInc_Blank iParameter RESULT MertechInc_iRet
72277>>>>>>>>>>>
72277>>>>>>>>>>>    Function_Return sValue
72278>>>>>>>>>>>End_Function
72279>>>>>>>>>>>
72279>>>>>>>>>>>//=============================================================================
72279>>>>>>>>>>>/// @Name        DO_BIND_SQLSERVER_PARAMETERS
72279>>>>>>>>>>>/// @Description Binds parameters for stored procedure call.
72279>>>>>>>>>>>///
72279>>>>>>>>>>>/// @Assumptions
72279>>>>>>>>>>>/// @Status      Internal
72279>>>>>>>>>>>/// @Drivers     All
72279>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
72279>>>>>>>>>>>/// @See
72279>>>>>>>>>>>
72279>>>>>>>>>>>Procedure MertechInc_DO_BIND_SQLSERVER_PARAMETERS Global String sDirection String sParameter Integer iSize
72281>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sDirection sParameter iSize RESULT MertechInc_iRet
72286>>>>>>>>>>>End_Procedure
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        DO_CHECK_BINDING
72287>>>>>>>>>>>/// @Description Sets MertechInc_bThereIsBinding True if any of the
72287>>>>>>>>>>>/// parameters is the keyword BINDING.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Internal
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
72287>>>>>>>>>>>/// @See
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        DO_FETCH_FIRST_ROW
72287>>>>>>>>>>>/// @Description Recursive - drops first parameter until the first parameter
72287>>>>>>>>>>>/// is BINDING and then calls SQL_FETCH_NEXT_ROW passing remaining parameters.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Internal
72287>>>>>>>>>>>/// @Drivers     SQLFlex
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
72287>>>>>>>>>>>/// @See
72287>>>>>>>>>>>
72287>>>>>>>>>>>
72287>>>>>>>>>>>
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        CALL_STORED_PROCEDURE
72287>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
72287>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
72287>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
72287>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
72287>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
72287>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
72287>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
72287>>>>>>>>>>>/// is set to true.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
72287>>>>>>>>>>>/// @See
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax CALL_STORED_PROCEDURE {procedure} Passing {variable}
72287>>>>>>>>>>>/// @Param procedure            Full name of the procedure
72287>>>>>>>>>>>/// @Param variable                     Argument being passed (can be multiple)
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        CALL_SQLSERVER_PROCEDURE
72287>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
72287>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
72287>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
72287>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
72287>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
72287>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN, SQL_FETCH_NEXT_ROW or
72287>>>>>>>>>>>/// GET_PROCEDURE_RETURN can be used to get the value(s). If an error is found
72287>>>>>>>>>>>/// then the indicator "Err" is set to true.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Status      Deprecated
72287>>>>>>>>>>>/// @Drivers     SQLFlex
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax CALL_SQLSERVER_PROCEDURE {procedure} Passing {variable}
72287>>>>>>>>>>>/// @Param procedure            Full name of the procedure
72287>>>>>>>>>>>/// @Param variable                     Argument to be passed (can be multiple)
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// CALL_SQLSERVER_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        END_CALL_PROCEDURE
72287>>>>>>>>>>>/// @Description This command is used to close any open cursors created
72287>>>>>>>>>>>/// by the respective stored procedure. Cursors are used in MSSQL to make
72287>>>>>>>>>>>/// the results from one procedure temporarily available to other procedures
72287>>>>>>>>>>>/// or triggers. To avoid causing unwanted results, it is good practice to
72287>>>>>>>>>>>/// use this command once a procedure call is completed.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     SQLFlex
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax END_CALL_PROCEDURE
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_spaceused" Passing "Customer"
72287>>>>>>>>>>>/// GET_PROCEDURE_RETURN to sValue
72287>>>>>>>>>>>/// END_CALL_PROCEDURE
72287>>>>>>>>>>>/// Showln sValue
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        GET_PROCEDURE_RETURN
72287>>>>>>>>>>>/// @Description This command is used to get a returned value from a stored
72287>>>>>>>>>>>/// procedure using MSSQL. Note that this command can only handle one
72287>>>>>>>>>>>/// returned value and must be used after the procedure has already been
72287>>>>>>>>>>>/// built and executed.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     SQLFlex
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72287>>>>>>>>>>>/// @See
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax GET_PROCEDURE_RETURN to {variable}
72287>>>>>>>>>>>/// @Param variable             Variable to hold the returned value
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_spaceused" NUMPAR 1
72287>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to "Customer" IN
72287>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
72287>>>>>>>>>>>/// GET_PROCEDURE_RETURN to sSpaceUsed
72287>>>>>>>>>>>/// Showln sSpaceUsed
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        SET_MIRROR_SERVER
72287>>>>>>>>>>>/// @Description This command is used to programmatically set the mirror
72287>>>>>>>>>>>/// server for the database. This is to be used along with SQl server
72287>>>>>>>>>>>/// failover mirroring. Note that this simply sets the server and database
72287>>>>>>>>>>>/// to be used for mirroring. All set up for the servers must already be
72287>>>>>>>>>>>/// working properly through SQL Server.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions A compatible version of SQL Server is being used
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     SQLFlex v9.2 and above
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 GET_MIRROR_SERVER
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax SET_MIRROR_SERVER to {server} {database}
72287>>>>>>>>>>>/// @Param server                       The name of the mirror server
72287>>>>>>>>>>>/// @Param database                     The database acting as a mirror
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// SET_MIRROR_SERVER to "(localdb)\v11.0" "MirrorDB"
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        GET_MIRROR_SERVER
72287>>>>>>>>>>>/// @Description This command is used to get the name of the server
72287>>>>>>>>>>>/// and database being used for failover mirroring. Mirroring must
72287>>>>>>>>>>>/// be properly set up in SQL Server for this command to return the
72287>>>>>>>>>>>/// correct values.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     SQLFlex v9.2 and above
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 SET_MIRROR_SERVER
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax GET_MIRROR_SERVER to {server} {database}
72287>>>>>>>>>>>/// @Param server                       Variable to hold the name of the mirrored server
72287>>>>>>>>>>>/// @Param database                     Variable to hold the name of the mirrored database
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// GET_MIRROR_SERVER to sServer sDatabase
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        COPY_DATA
72287>>>>>>>>>>>/// @Description This command is used to copy data from a DAT file to an
72287>>>>>>>>>>>/// SQL table. Both the source and the destination files are opened, the
72287>>>>>>>>>>>/// data is copied and then the files are closed. This is usually used
72287>>>>>>>>>>>/// along with CREATE_TABLE_FROM_DAT_FILE, which creates the structure
72287>>>>>>>>>>>/// and then this command will insert the data. If needed, this command
72287>>>>>>>>>>>/// can also work backwards, copying data from an SQL table to a DAT file.
72287>>>>>>>>>>>/// This is an alternative to using the Flex2SQL Migration Tool and can
72287>>>>>>>>>>>/// improve performance when used in the right situations. Note that in
72287>>>>>>>>>>>/// order for this process to work properly the table being copied can not
72287>>>>>>>>>>>/// be opened. Because of this, a manual login must take place, using
72287>>>>>>>>>>>/// something like LOGIN_SQLFLEX or LOGIN. Since this only copies the data,
72287>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE can be used to create the table structure.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// Because COPY_DATA requires no user interaction, an optional callback
72287>>>>>>>>>>>/// function can be passed for tracing purposes. By passing the constant
72287>>>>>>>>>>>/// "CALLBACK" followed by the object name, a function can be used to set
72287>>>>>>>>>>>/// up messages for tracking and error handling. Below is more information
72287>>>>>>>>>>>/// regarding this callback object.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// This function should follow this pattern:
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// Function Callback String sText Integer iStatusID Returns Integer
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// sText - Message corresponding to the current status ID
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// iStatusID - Integer value mapping to the current status constant:
72287>>>>>>>>>>>///                     DF_MESSAGE_PROGRESS_TITLE    Sent when SQLFlex starts the
72287>>>>>>>>>>>///                                                                              process
72287>>>>>>>>>>>///
72287>>>>>>>>>>>///             DF_MESSAGE_HEADING_1         Sent when SQLFlex is about to
72287>>>>>>>>>>>///                                                                              copy the source data
72287>>>>>>>>>>>///
72287>>>>>>>>>>>///             DF_MESSAGE_ERROR             Sent when an error occurs
72287>>>>>>>>>>>///
72287>>>>>>>>>>>///             DF_MESSAGE_PROGRESS_STATUS   Sent each time an additional
72287>>>>>>>>>>>///                                                                              10% of the data is copied
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// NOTE: Returning false each time the function is called will continue
72287>>>>>>>>>>>/// copying process. Returning true will end it.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// Another optional parameter that can be used is a constrain on the data
72287>>>>>>>>>>>/// being copied. This is done by passing the constant "CONSTRAIN" followed
72287>>>>>>>>>>>/// by an SQL constrain statement. When passing a constrain but not a callback
72287>>>>>>>>>>>/// object, pass 0 for the callback before passsing the constrain.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE CONVERT_DAT_FILE
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax COPY_DATA {from} to {destination} [CALLBACK {function}] [CONSTRAIN {variable}]
72287>>>>>>>>>>>/// @Param from                         Table to copy from.
72287>>>>>>>>>>>/// @Param destination          Table to copy to.
72287>>>>>>>>>>>/// @Param function             Object with callback function (optional)
72287>>>>>>>>>>>/// @Param variable                     SQL contraint to use when copying (optional)
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// Object CallBackObj is a Array
72287>>>>>>>>>>>///     Function Callback String sText Integer iLogicalID Returns Integer
72287>>>>>>>>>>>///         If (iLogicalID = DF_MESSAGE_ERROR) Begin
72287>>>>>>>>>>>///             Showln "Error"
72287>>>>>>>>>>>///                             Showln sText
72287>>>>>>>>>>>///                             Function_Return True
72287>>>>>>>>>>>///         End
72287>>>>>>>>>>>///
72287>>>>>>>>>>>///         Else Showln sText
72287>>>>>>>>>>>///
72287>>>>>>>>>>>///                     Function_Return False
72287>>>>>>>>>>>///
72287>>>>>>>>>>>///     End_Function
72287>>>>>>>>>>>/// End_Object
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
72287>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
72287>>>>>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        ORAFlex_REVISION
72287>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
72287>>>>>>>>>>>/// of the Oracle driver associated with the current workspace into the specified
72287>>>>>>>>>>>/// variable.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Deprecated
72287>>>>>>>>>>>/// @Drivers     ORAFlex
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax ORAFlex_REVISION {variable}
72287>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// ORAFlex_REVISION sVersion
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        KEEP_FILES_OPEN
72287>>>>>>>>>>>/// @Description Keep the files, currently in use, open after the server is
72287>>>>>>>>>>>/// logged out. Sometimes an application needs to login to the same server
72287>>>>>>>>>>>/// with a different user id. When logging out, however, the drivers
72287>>>>>>>>>>>/// automatically close all opened files. The overhead of opening these files
72287>>>>>>>>>>>/// should be avoided if the user will work with the same files that were
72287>>>>>>>>>>>/// closed. KEEP_FILES_OPEN keeps all files opened after a user logs out
72287>>>>>>>>>>>/// from the server.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Status      Deprecated
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax KEEP_FILES_OPEN of {server}
72287>>>>>>>>>>>/// @Param server               Name of the server
72287>>>>>>>>>>>
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        SET_MAX_OPEN_CURSORS
72287>>>>>>>>>>>/// @Description Set the maximum number of cursors you want the driver to use.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// The driver will recycle the least used cursors if this limit is hit.
72287>>>>>>>>>>>/// The trade off is between increased resources on the server and
72287>>>>>>>>>>>/// re-preparing of cursors.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// For a program that keeps 40+ files opened at the same time, 255 is a good
72287>>>>>>>>>>>/// number for the open cursors parameter. For programs that open less than
72287>>>>>>>>>>>/// 40 files, any number between 100-255 is sufficient. These numbers can be
72287>>>>>>>>>>>/// changed based on available server resources.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// On Oracle this value should not exceed the value of open_cursors in
72287>>>>>>>>>>>/// init.ora
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// Note: Only change this setting if you are having performance issues
72287>>>>>>>>>>>/// and the server is indicating you are using up too many cursors or too
72287>>>>>>>>>>>/// much memory. GET_OPENED_CURSORS can be used to check the number of
72287>>>>>>>>>>>/// cursors the server has opened. If this number is hitting the limit,
72287>>>>>>>>>>>/// it is worth increasing the number, as long as the server has enough
72287>>>>>>>>>>>/// resources.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
72287>>>>>>>>>>>/// @See         GET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax SET_MAX_OPEN_CURSORS of {server} to {variable}
72287>>>>>>>>>>>/// @Param server                       The name of the server
72287>>>>>>>>>>>/// @Param variable                     Maximum number of cursors
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        GET_MAX_OPEN_CURSORS
72287>>>>>>>>>>>/// @Description This command will return the maximum number of open
72287>>>>>>>>>>>/// cursors allowed by the server.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
72287>>>>>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
72287>>>>>>>>>>>/// @Param server                       Name of the server
72287>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum number of open cursors
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        GET_OPENED_CURSORS
72287>>>>>>>>>>>/// @Description This command returns the number of cursors currently
72287>>>>>>>>>>>/// open on the server.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
72287>>>>>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_MAX_OPEN_CURSORS
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
72287>>>>>>>>>>>/// @Param server                       Name of the server
72287>>>>>>>>>>>/// @Param variable                     Variable to hold the number of cursors currently open
72287>>>>>>>>>>>///
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        ACTIVATE_TIME_STAMP
72287>>>>>>>>>>>/// @Description This command will specify whether or not to show the time
72287>>>>>>>>>>>/// portion of a date field. When set to ON, the time portion will be
72287>>>>>>>>>>>/// included, OFF will just show the date. This is the same as changing
72287>>>>>>>>>>>/// the date format with "ALTER SESSION SET nls_timestamp_format". Note that
72287>>>>>>>>>>>/// this will only take effect if the date is put into a string variable.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Deprecated
72287>>>>>>>>>>>/// @Drivers     OraFlex
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72287>>>>>>>>>>>/// @See
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax ACTIVATE_TIME_STAMP of {server} to {ON/OFF}
72287>>>>>>>>>>>/// @Param server                       Name of the server
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// ACTIVATE_TIME_STAMP of "localhost/orcl.localdomain" to OFF
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// SQL_SET_STMT to 'SELECT * from USER."Customer" '
72287>>>>>>>>>>>/// SQL_PREPARE_STMT
72287>>>>>>>>>>>/// SQL_EXECUTE_STMT
72287>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
72287>>>>>>>>>>>/// If (Found) Begin
72287>>>>>>>>>>>///     Showln sDOB
72287>>>>>>>>>>>/// End
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        CALL_ORACLE_STORED_FUNCTION
72287>>>>>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
72287>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
72287>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
72287>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
72287>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
72287>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
72287>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
72287>>>>>>>>>>>/// values.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Status      Deprecated
72287>>>>>>>>>>>/// @Drivers     ORAFLex
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_FUNCTION {function} Returns {variable} Passing {argument}
72287>>>>>>>>>>>/// @Param function                     Full name of the function
72287>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
72287>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// CALL_ORACLE_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
72287>>>>>>>>>>>/// Showln sStatus
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        CALL_PGSQL_STORED_FUNCTION
72287>>>>>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
72287>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
72287>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
72287>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
72287>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
72287>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
72287>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
72287>>>>>>>>>>>/// values.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Status      Deprecated
72287>>>>>>>>>>>/// @Drivers     PGFlex
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax CALL_PGSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
72287>>>>>>>>>>>/// @Param function                     Full name of the function
72287>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
72287>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// CALL_PGSQL_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
72287>>>>>>>>>>>/// Showln sStatus
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        MERTECH_LANGUAGE_SUPPORT
72287>>>>>>>>>>>/// @Description Sets the support language for the driver.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Internal
72287>>>>>>>>>>>/// @Drivers     ORAFLex
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72287>>>>>>>>>>>/// @See
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax MERTECH_LANGUAGE_SUPPORT of {server} to {language}
72287>>>>>>>>>>>/// @Param server               The name of the server being used
72287>>>>>>>>>>>/// @Param language             The language to set support to
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER_BEGIN
72287>>>>>>>>>>>/// @Description This command is used to initialize a SAVE_BUFFER
72287>>>>>>>>>>>/// statement. Doing this will allow a specified set of records to be
72287>>>>>>>>>>>/// stored in the buffer before a save takes place. Once the buffer is
72287>>>>>>>>>>>/// filled, it will be saved automatically. This set of commands can be
72287>>>>>>>>>>>/// used to efficiently save a large number of records. Once the buffer
72287>>>>>>>>>>>/// is full, the save occurs automatically and the buffer will be emptied
72287>>>>>>>>>>>/// out. It is good practice to use this method inside of a transaction to
72287>>>>>>>>>>>/// maintain atomicity. Note that these commands should not be used in
72287>>>>>>>>>>>/// conjuction with finds.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
72287>>>>>>>>>>>/// @See         SQL_SAVE_BUFFER_END SQL_SAVE_BUFFER
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER_BEGIN of {FileName} to {variable}
72287>>>>>>>>>>>/// @Param FileName                     Name of the file
72287>>>>>>>>>>>/// @Param variable                     Number of records to store in the buffer
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// Open Customer
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// For i from 0 to 1000
72287>>>>>>>>>>>///     Move i to Transactions.ID
72287>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
72287>>>>>>>>>>>/// Loop
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER
72287>>>>>>>>>>>/// @Description This command is used to send a record to the "Save
72287>>>>>>>>>>>/// Record" buffer. It must be used along with SQL_SAVE_BUFFER_BEGIN
72287>>>>>>>>>>>/// and SQL_SAVE_BUFFER_END. SQL_SAVE_BUFFER_BEGIN sets the number of
72287>>>>>>>>>>>/// records to store in the buffer before a save is done on all the records
72287>>>>>>>>>>>/// at once. Each time a record is created, this command should be called
72287>>>>>>>>>>>/// to insert it into the buffer. Using this set of commands can be useful
72287>>>>>>>>>>>/// to efficiently save a large number of records. Once the buffer is full,
72287>>>>>>>>>>>/// the save occurs automatically and the buffer will be emptied out. It is
72287>>>>>>>>>>>/// good practice to use this method inside of a transaction to maintain
72287>>>>>>>>>>>/// atomicity.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER_END
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER of {FileName}
72287>>>>>>>>>>>/// @Param FileName                     Name of the file
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// Open Customer
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// For i from 0 to 1000
72287>>>>>>>>>>>///     Move i to Transactions.ID
72287>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
72287>>>>>>>>>>>/// Loop
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER_END
72287>>>>>>>>>>>/// @Description This command indicates the end of the extended record
72287>>>>>>>>>>>/// buffer and forces a save of any data currently in the buffer.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
72287>>>>>>>>>>>/// @See         SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER_END of {FileName}
72287>>>>>>>>>>>/// @Param FileName                     Name of the file
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// Open Customer
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// For i from 0 to 1000
72287>>>>>>>>>>>///     Move i to Transactions.ID
72287>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
72287>>>>>>>>>>>/// Loop
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        SQL_SAVE_SET_ATTRIBUTES
72287>>>>>>>>>>>/// @Description Unknown - Not in help - Not call by any other macros
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Internal
72287>>>>>>>>>>>/// @Drivers     SQLFlex
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
72287>>>>>>>>>>>/// @See
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        ENABLE_TRACE_ON
72287>>>>>>>>>>>/// @Description This command enables driver level tracing to the
72287>>>>>>>>>>>/// specified file. Enabling trace on an application and using it
72287>>>>>>>>>>>/// in conjunction with SQL_TEXT_MESSAGE is a good way to study
72287>>>>>>>>>>>/// particular problems you encounter in the driver. SQL_TEXT_MESSAGE
72287>>>>>>>>>>>/// allows you to insert sections of your code into the trace file.
72287>>>>>>>>>>>/// This command can also set the trace to three different levels,
72287>>>>>>>>>>>/// allowing different amounts of information to be logged. Note that
72287>>>>>>>>>>>/// trace files can become very large so it is good practice to only
72287>>>>>>>>>>>/// turn them on when specifically needed.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 DISABLE_TRACE_ON SQL_TEXT_MESSAGE
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax ENABLE_TRACE_ON to {fileName} Debug_Level [{constant}]
72287>>>>>>>>>>>/// @Param fileName                     The path of the file to send the trace to
72287>>>>>>>>>>>/// @Param constant             DETAIL_LEVEL1, DETAIL_LEVEL2, DETAIL_LEVEL3 (optional)
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example ENABLE_TRACE_ON TO "C:\Temp\trace_file.txt" Debug_Level DETAIL_LEVEL3
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        DISABLE_TRACE_ON
72287>>>>>>>>>>>/// @Description This command disables the current trace taking
72287>>>>>>>>>>>/// place on a driver.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72287>>>>>>>>>>>/// @See ENABLE_TRACE_ON SQL_TEXT_MESSAGE
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax DISABLE_TRACE_ON
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        CREATE_TABLE_FROM_DAT_FILE
72287>>>>>>>>>>>/// @Description This command is used to create a SQL table from a .DAT
72287>>>>>>>>>>>/// file. The table being copied must be not be opened in order for this
72287>>>>>>>>>>>/// command to work properly. This is the programmatic equivalent to
72287>>>>>>>>>>>/// using the Flex2SQL Migration Tool. Optional restructuring options
72287>>>>>>>>>>>/// can be specified here (see below) as well as an alternative table
72287>>>>>>>>>>>/// name than the physical name of the .DAT file. Note that this only
72287>>>>>>>>>>>/// creates the  table structure, no data will be copied here. To copy
72287>>>>>>>>>>>/// the data, use COPY_DATA after the table has been created.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 COPY_DATA CONVERT_DAT_FILE
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax CREATE_TABLE_FROM_DAT_FILE {FileNumber} [{options} {table}]
72287>>>>>>>>>>>/// @Param FileNumber           Number of the file
72287>>>>>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
72287>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
72287>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
72287>>>>>>>>>>>/// @Param table            name of table to use instead of physical name (optional)
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
72287>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
72287>>>>>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        CONVERT_DAT_FILE
72287>>>>>>>>>>>/// @Description This command is the programmatic equivalent to the
72287>>>>>>>>>>>/// Flex2SQL Migration Tool. With this command, a SQL table can be
72287>>>>>>>>>>>/// created from a .DAT table. This combines the COPY_DATA and
72287>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE, creating the table structure and
72287>>>>>>>>>>>/// copying all the data into the new table with one command. The
72287>>>>>>>>>>>/// table being converted cannot be opened and so a manual login is
72287>>>>>>>>>>>/// needed. Note that to specify the database to copy the table to,
72287>>>>>>>>>>>/// use SET_DATABASE_NAME. Below is a list of the optional restructure
72287>>>>>>>>>>>/// options to use when creating the table.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE COPY_DATA
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax CONVERT_DAT_FILE {FileNumber} [{options} {table}]
72287>>>>>>>>>>>/// @Param FileNumber           Number of the file
72287>>>>>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
72287>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
72287>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
72287>>>>>>>>>>>/// @Param table            Name of table to use instead of physical name (optional)
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
72287>>>>>>>>>>>/// CONVERT_DAT_FILE Customer.File_Number DF_STRUCTEND_OPT_FORCE_NOT_NULL "Customer"
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        SET_DEFAULT_FILE_CASING
72287>>>>>>>>>>>/// @Description This command is used to set the file casing standard when
72287>>>>>>>>>>>/// creating or restructuring tables. By default, all table and column names
72287>>>>>>>>>>>/// are created using the specified casing. Passing FILE_CASING_UPPER or
72287>>>>>>>>>>>/// FILE_CASING_LOWER will allow the names to be saved in uppercase or
72287>>>>>>>>>>>/// lowercase respectively. This can be useful for backwards compatibility
72287>>>>>>>>>>>/// where casing was important. Note that the casing standard for a file can
72287>>>>>>>>>>>/// also be changed through mertech.ini. Below is a description of the constants
72287>>>>>>>>>>>/// that can be passed to this command.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
72287>>>>>>>>>>>/// FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
72287>>>>>>>>>>>/// FILE_CASING_KEEP (default) : All created or edited object names will maintain their inputed casing.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 GET_DEFAULT_FILE_CASING
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax SET_DEFAULT_FILE_CASING to {constant}
72287>>>>>>>>>>>/// @Param constant                     FILE_CASING_UPPER, FILE_CASING_LOWER, FILE_CASING_KEEP
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// SET_DEFAULT_FILE_CASING to FILE_CASING_UPPER
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        GET_DEFAULT_FILE_CASING
72287>>>>>>>>>>>/// @Description This command returns the file casing standard used
72287>>>>>>>>>>>/// when creating or restructuring tables. Note that an integer is returned,
72287>>>>>>>>>>>/// mapping to a casing method. Below are the meanings of the possible
72287>>>>>>>>>>>/// returned integers.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// 0 - FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
72287>>>>>>>>>>>/// 1 - FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
72287>>>>>>>>>>>/// 2 - FILE_CASING_KEEP : All created or edited object names will maintain their inputed casing.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 SET_DEFAULT_FILE_CASING
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax GET_DEFAULT_FILE_CASING to {variable}
72287>>>>>>>>>>>/// @Param variable                     Variable to hold the returned casing
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// GET_DEFAULT_FILE_CASING TO iCasing
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        SET_DEFAULT_TABLESPACE
72287>>>>>>>>>>>/// @Description This command sets the default table space to use when
72287>>>>>>>>>>>/// creating tables through Dataflex. A tablespace is a container of
72287>>>>>>>>>>>/// segments (objects that have an allotted amount of space), i.e. tables
72287>>>>>>>>>>>/// and indexes.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax SET_DEFAULT_TABLESPACE to {variable}
72287>>>>>>>>>>>/// @Param variable                     Name of the default table space
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// SET_DEFAULT_TABLESPACE to "Users"
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        GET_DEFAULT_TABLESPACE
72287>>>>>>>>>>>/// @Description This command returns the default table space name for
72287>>>>>>>>>>>/// the current database.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax GET_DEFAULT_TABLESPACE to {variable}
72287>>>>>>>>>>>/// @Param variable                     Variable to hold the default table space name.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// GET_DEFAULT_TABLESPACE to sTableSpace
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        SET_DEFAULT_INDEX_TABLESPACE
72287>>>>>>>>>>>/// @Description This command sets the default table space for indexes
72287>>>>>>>>>>>/// when creating tables through the DataFlex API. A tablespace is a
72287>>>>>>>>>>>/// container of segments (objects that have an allotted amount of space),
72287>>>>>>>>>>>/// i.e. tables and indexes.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09-2013 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax SET_DEFAULT_INDEX_TABLESPACE to {variable}
72287>>>>>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// SET_DEFAULT_INDEX_TABLESPACE to "Users"
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        GET_DEFAULT_INDEX_TABLESPACE
72287>>>>>>>>>>>/// @Description This command returns the default table space name for
72287>>>>>>>>>>>/// indexes in the current database.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax GET_DEFAULT_INDEX_TABLESPACE to {variable}
72287>>>>>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// GET_DEFAULT_INDEX_TABLESPACE to sTableSpace
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        ENABLE_SCRIPTING
72287>>>>>>>>>>>/// @Description Scripting is used for testing and preparation. This
72287>>>>>>>>>>>/// command allows structural changes to be compiled and tested without
72287>>>>>>>>>>>/// actually making any of the changes. Any table restructuring done
72287>>>>>>>>>>>/// between this command and DISABLE_SCRIPTING will not actually be
72287>>>>>>>>>>>/// committed but will instead create a mock INT file. The script and
72287>>>>>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72287>>>>>>>>>>>/// @See                 DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax ENABLE_SCRIPTING
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// ENABLE_SCRIPTING
72287>>>>>>>>>>>///     //Table restructuring would go here
72287>>>>>>>>>>>/// DISABLE_SCRIPTING
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
72287>>>>>>>>>>>/// Showln sChunk
72287>>>>>>>>>>>
72287>>>>>>>>>>>//=============================================================================
72287>>>>>>>>>>>/// @Name        DISABLE_SCRIPTING
72287>>>>>>>>>>>/// @Description This command ends any scripting started by ENABLE_SCRIPTING.
72287>>>>>>>>>>>/// The mock INT file and script can then be retrieved and examined.
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Assumptions
72287>>>>>>>>>>>/// @Status      Public
72287>>>>>>>>>>>/// @Drivers     All
72287>>>>>>>>>>>/// @VersionNote Last Revised: 2010-12-13 By Marcelo Nachbar
72287>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING  GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Syntax DISABLE_SCRIPTING
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// @Example
72287>>>>>>>>>>>/// ENABLE_SCRIPTING
72287>>>>>>>>>>>///     //Table restructuring would go here
72287>>>>>>>>>>>/// DISABLE_SCRIPTING
72287>>>>>>>>>>>///
72287>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
72287>>>>>>>>>>>/// Showln sChunk
72287>>>>>>>>>>>
72287>>>>>>>>>>>Function MertechInc_GET_RESTRUCTURE_SCRIPT Global Integer iLong Integer iOffset Returns String
72289>>>>>>>>>>>    Integer iChuck_Size
72289>>>>>>>>>>>    String sChunk
72289>>>>>>>>>>>
72289>>>>>>>>>>>    //Get current Chuck size and pre size string
72289>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
72294>>>>>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
72295>>>>>>>>>>>
72295>>>>>>>>>>>    //Get data
72295>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_RESTRUCTURE_SCRIPT CALLBACK 0 PASSING sChunk iOffset iLong RESULT MertechInc_iRet
72300>>>>>>>>>>>
72300>>>>>>>>>>>    // Replace insert a CR before any LF character
72300>>>>>>>>>>>    Move (Replaces(Character(10), sChunk, Character(13)+Character(10))) to sChunk
72301>>>>>>>>>>>
72301>>>>>>>>>>>    Function_Return sChunk
72302>>>>>>>>>>>End_Function
72303>>>>>>>>>>>
72303>>>>>>>>>>>
72303>>>>>>>>>>>//=============================================================================
72303>>>>>>>>>>>/// @Name        GET_SQL_SCRIPT_CHUNK
72303>>>>>>>>>>>/// @Description This command returns a chunk of the script generated
72303>>>>>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
72303>>>>>>>>>>>/// DISABLE_SCRIPTING. Since some scripts can be very large, the script
72303>>>>>>>>>>>/// can be looped through, grabbing chunks at a time.
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// @Assumptions
72303>>>>>>>>>>>/// @Status      Public
72303>>>>>>>>>>>/// @Drivers     All
72303>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72303>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_INT_CHUNK
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// @Syntax GET_SQL_SCRIPT_CHUNK OFFSET {offset} to {variable} [{length}]
72303>>>>>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
72303>>>>>>>>>>>/// @Param variable                     Variable to hold the chunk
72303>>>>>>>>>>>/// @Param length                       Length of chunk returned (optional)
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// @Example
72303>>>>>>>>>>>/// ENABLE_SCRIPTING
72303>>>>>>>>>>>///     //Table restructuring would go here
72303>>>>>>>>>>>/// DISABLE_SCRIPTING
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
72303>>>>>>>>>>>/// Showln sChunk
72303>>>>>>>>>>>
72303>>>>>>>>>>>//=============================================================================
72303>>>>>>>>>>>/// @Name        GET_INT_CHUNK
72303>>>>>>>>>>>/// @Description This command returns a chunk of the INT file generated
72303>>>>>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
72303>>>>>>>>>>>/// DISABLE_SCRIPTING. Since some INT files can be very large, the file
72303>>>>>>>>>>>/// can be looped through, grabbing chunks at a time.
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// @Assumptions
72303>>>>>>>>>>>/// @Status      Public
72303>>>>>>>>>>>/// @Drivers     All
72303>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72303>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// @Syntax GET_INT_CHUNK OFFSET {offset} to {variable} [{length}]
72303>>>>>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
72303>>>>>>>>>>>/// @Param variable                     Variable to hold the chunk
72303>>>>>>>>>>>/// @Param length                       Length of chunk returned (optional)
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// @Example
72303>>>>>>>>>>>/// ENABLE_SCRIPTING
72303>>>>>>>>>>>///     //Table restructuring would go here
72303>>>>>>>>>>>/// DISABLE_SCRIPTING
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// GET_INT_CHUNK OFFSET 0 to sChunk sLength
72303>>>>>>>>>>>/// Showln sChunk
72303>>>>>>>>>>>
72303>>>>>>>>>>>//=============================================================================
72303>>>>>>>>>>>/// @Name        REPORT_STMT
72303>>>>>>>>>>>/// @Description This command is an alternative to DataFlex's "Report"
72303>>>>>>>>>>>/// command. This allows embedded SQL to be used to fetch data instead of
72303>>>>>>>>>>>/// standard table queries.. All of the finds, for example, normally found
72303>>>>>>>>>>>/// in "Report" are replaced by SQL_FETCH_NEXT_ROW.
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// @Assumptions
72303>>>>>>>>>>>/// @Status      Public
72303>>>>>>>>>>>/// @Drivers     n/a
72303>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72303>>>>>>>>>>>/// @See
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// @Syntax See DataFlex / Visual DataFlex documentation
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// @Example
72303>>>>>>>>>>>/// /Header
72303>>>>>>>>>>>/// __/__/____                                                        Page ___.
72303>>>>>>>>>>>///                 MERTECH DATA SYSTEMS, INC. - NOT FOR RESALE
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// ID   NAME
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// /Body
72303>>>>>>>>>>>/// ____ _________________________
72303>>>>>>>>>>>/// /Total
72303>>>>>>>>>>>/// Records printed = _______.
72303>>>>>>>>>>>/// /*
72303>>>>>>>>>>>///
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// OPEN SALESP
72303>>>>>>>>>>>/// direct_output "con:"
72303>>>>>>>>>>>/// // Write the complete SELECT statement to retrieve the expected records from your REPORT
72303>>>>>>>>>>>/// // Must include the expression to qualify the required records and specify the order by as well
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// sql_set_stmt of salesp to "select recnum, id, name from SALESP where recnum > 5 order by id"
72303>>>>>>>>>>>/// sql_prepare_stmt of salesp
72303>>>>>>>>>>>/// sql_bindcolumns_stmt of salesp to salesp.recnum salesp.id salesp.name
72303>>>>>>>>>>>/// sql_execute_stmt of salesp
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// Report_stmt SALESP By Index.1
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// Section Header
72303>>>>>>>>>>>///     Sysdate Header.1
72303>>>>>>>>>>>///     Move PageCount to Header.2
72303>>>>>>>>>>>///     output header
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// Section Body
72303>>>>>>>>>>>///     Print Salesp.id   to Body.1
72303>>>>>>>>>>>///     Print Salesp.name to Body.2
72303>>>>>>>>>>>///     output body
72303>>>>>>>>>>>/// Section Total
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// Return
72303>>>>>>>>>>>/// ReportEnd
72303>>>>>>>>>>>
72303>>>>>>>>>>>//=============================================================================
72303>>>>>>>>>>>/// @Name        GET_SERVER_CFG
72303>>>>>>>>>>>/// @Description This command, when passed a valid server name, returns
72303>>>>>>>>>>>/// the a value for the specified attribute. See the list below for an
72303>>>>>>>>>>>/// explanation of each attribute.
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// SERVER_REVISION    Returns the major version, to the left of the decimal, of the server
72303>>>>>>>>>>>/// SUPPORT_DESC       Returns 1 if Server supports descending index segments
72303>>>>>>>>>>>/// SUPPORT_CASE       Returns 1 if Server supports case insensitive index segments
72303>>>>>>>>>>>/// SERVER_VERSION     Returns the full version of the server
72303>>>>>>>>>>>/// SERVER_ENCODING    Returns the Server Encoding
72303>>>>>>>>>>>/// CONNECTION_ACTIVE  Returns 1 if the connection to the server is active
72303>>>>>>>>>>>/// CITEXT_SUPPORT     Returns 1 if Server supports citext, a PostgreSQL data type
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// @Assumptions
72303>>>>>>>>>>>/// @Status      Internal
72303>>>>>>>>>>>/// @Drivers     All
72303>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72303>>>>>>>>>>>/// @See
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// @Syntax GET_SERVER_CFG {constant} of {server} to {variable}
72303>>>>>>>>>>>/// @Param constant                     SERVER_REVISION,SERVER_MIN_REVISION,SUPPORT_DESC,SUPPORT_CASE,SERVER_VERSION,SERVER_ENCODING,CONNECTION_ACTIVE
72303>>>>>>>>>>>/// @Param server                       Name of the server being checked
72303>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
72303>>>>>>>>>>>///
72303>>>>>>>>>>>/// @Example
72303>>>>>>>>>>>/// GET_SERVER_CFG SERVER_VERSION of "localhost" to sVersion
72303>>>>>>>>>>>
72303>>>>>>>>>>>Function MertechInc_GET_SERVER_CFG Global String sServer Integer iAttribute Returns String
72305>>>>>>>>>>>    String sReturnValue
72305>>>>>>>>>>>
72305>>>>>>>>>>>    Get MertechInc_Pre_Size_String 512 to sReturnValue
72306>>>>>>>>>>>
72306>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SERVER_CFG CALLBACK 0 PASSING sServer sReturnValue iAttribute RESULT MertechInc_iRet
72311>>>>>>>>>>>
72311>>>>>>>>>>>    //If iAttribute = SERVER_VERSION or SERVER_ENCODING then return sReturnValue
72311>>>>>>>>>>>    //else we need to return MertechInc_iRet
72311>>>>>>>>>>>    If ((iAttribute = 4) or (iAttribute = 5)) Function_Return sReturnValue
72314>>>>>>>>>>>    Else                                      Function_Return MertechInc_iRet
72316>>>>>>>>>>>End_Function
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        GET_CONNECTION_STATUS
72317>>>>>>>>>>>/// @Description Retrieve the connection status for the specified server.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Internal
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
72317>>>>>>>>>>>/// @See
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax GET_CONNECTION_STATUS of <serverName> [<databaseName>] to <variable>
72317>>>>>>>>>>>/// @Param serverName    Server Name
72317>>>>>>>>>>>/// @Param databaseName  Database Name
72317>>>>>>>>>>>/// @Param variable      DFTRUE means connection is active
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        GET_CLIENT_CFG
72317>>>>>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Internal
72317>>>>>>>>>>>/// @Drivers     MySQLFlex and PgFlex
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
72317>>>>>>>>>>>/// @See
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax GET_CLIENT_CFG [ENCODING | ENCODING_ID] of <Server> [<MySQL_Database>] to <Var>
72317>>>>>>>>>>>/// @Param Server           Server name to get encoding of
72317>>>>>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
72317>>>>>>>>>>>/// @Param Var              Variable to hold returned value
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        SET_CLIENT_CFG
72317>>>>>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Internal
72317>>>>>>>>>>>/// @Drivers     MySQLFlex and PgFlex
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
72317>>>>>>>>>>>/// @See
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax SET_CLIENT_CFG [ENCODING | UNIQUE_CHECKS] of <Server> [<MySQL_Database>] to <Value>
72317>>>>>>>>>>>/// @Param Server           Server name to get encoding of
72317>>>>>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
72317>>>>>>>>>>>/// @Param Value            Value to set
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Comment ENCODING - Set the Client Encoding
72317>>>>>>>>>>>/// @Comment UNIQUE_CHECKS {DFTRUE/DFFALSE} - enable/disable uniqueness checks for secondary indexes in InnoDB tables
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        CALL_DB2_PROCEDURE
72317>>>>>>>>>>>/// @Description Executes a DB2 Server stored procedure.
72317>>>>>>>>>>>/// @Status      Public
72317>>>>>>>>>>>/// @Drivers     DB2Flex
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax CALL_DB2_PROCEDURE <OWNER> <STORED_PROC> {PASSING <ARG1> {. <ARGn>}}
72317>>>>>>>>>>>/// @Param Owner        Name of the Procedure's Owner.
72317>>>>>>>>>>>/// @Param Stored_Proc  Full name of the stored procedure being called.
72317>>>>>>>>>>>/// @Param Arg1..Argn   Arguments passed to the procedure.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        GET_RESULTS
72317>>>>>>>>>>>/// @Description Returns the initial result set.
72317>>>>>>>>>>>/// @Status      Public
72317>>>>>>>>>>>/// @Drivers     DB2Flex
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax GET_RESULTS
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        GET_MORE_RESULTS
72317>>>>>>>>>>>/// @Description Returns remaining values not retrieved with GET_RESULT.
72317>>>>>>>>>>>/// @Status      Public
72317>>>>>>>>>>>/// @Drivers     DB2Flex
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax GET_MORE_RESULTS
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        GET_CURRENT_USER_NAME
72317>>>>>>>>>>>/// @Description This command is used to get the name of the user currently
72317>>>>>>>>>>>/// logged into the server.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Public
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72317>>>>>>>>>>>/// @See                 GET_CURRENT_USER_PASSWORD
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax GET_CURRENT_USER_NAME of {server} to {variable}
72317>>>>>>>>>>>/// @Param server               The name of the server the user is in
72317>>>>>>>>>>>/// @Param variable             Variable to hold the username
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Example
72317>>>>>>>>>>>/// GET_CURRENT_USER_NAME of "localhost" to sUserName
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        GET_CURRENT_USER_PASSWORD
72317>>>>>>>>>>>/// @Description This command is used to get the password associated with
72317>>>>>>>>>>>/// the user currently logged into the server.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Public
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72317>>>>>>>>>>>/// @See                 GET_CURRENT_USER_NAME
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax GET_CURRENT_USER_PASSWORD of {server} to {variable}
72317>>>>>>>>>>>/// @Param server               The name of the server the user is in
72317>>>>>>>>>>>/// @Param variable             Variable to hold the password
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Example
72317>>>>>>>>>>>/// GET_CURRENT_USER_PASSWORD of "localhost" to sPassword
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        CREATE_DB2_DATABASE
72317>>>>>>>>>>>/// @Description Creates a DB2 database with the same DataFlex collating sequence.
72317>>>>>>>>>>>/// @Status      Public
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-12 By Ian Smith
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax CREATE_DB2_DATABASE <DB Name> <DB Alias> <Code Set> <Territory> [<Path> <Node Name> <User ID><Password>]
72317>>>>>>>>>>>/// @Param DB Name     Name of the database being created
72317>>>>>>>>>>>/// @Param DB Alias    Alias Name applied to the database being created
72317>>>>>>>>>>>/// @Param Code Set    Code Set used by the database being created
72317>>>>>>>>>>>/// @Param Territory   Territory associated to the database being created
72317>>>>>>>>>>>/// @Param Path        Location of the database                                    - Optional
72317>>>>>>>>>>>/// @Param Node Name   Name of the machine (node) where the database is to reside  - Optional
72317>>>>>>>>>>>/// @Param User ID     User ID owning the database                                 - Optional
72317>>>>>>>>>>>/// @Param Password    Password of the User owning the database                    - Optional
72317>>>>>>>>>>>///
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        SQL_OPEN_CURSOR_STMT
72317>>>>>>>>>>>/// @Description This command is used to create a new SQl Cursor. Once
72317>>>>>>>>>>>/// created, SQL_SET_CURRENT_CURSOR_STMT can be called to specify which
72317>>>>>>>>>>>/// cursor is to be used for a given SQL statement. Creating multiple
72317>>>>>>>>>>>/// cursors using this command allows multiple SQL statements to be
72317>>>>>>>>>>>/// opened at once. Optionally a different server can be specified for each
72317>>>>>>>>>>>/// cursor by passing the server name to this command as well. If no
72317>>>>>>>>>>>/// server is specified, the current server will be used. Note that it
72317>>>>>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Public
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
72317>>>>>>>>>>>/// @See                 SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax SQL_OPEN_CURSOR_STMT [of {server}] to {variable}
72317>>>>>>>>>>>/// @Param server                       Name of the server (optional)
72317>>>>>>>>>>>/// @Param variable                     Variable to hold the returned cursor handle
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Example
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// Integer iCursor1 iCursor2 iCustomer
72317>>>>>>>>>>>/// String  sName
72317>>>>>>>>>>>/// Number  nOrderTotal
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to iCursor1
72317>>>>>>>>>>>/// SQL_SET_STMT         to "SELECT CUSTOMER_NUMBER,NAME FROM CUSTOMER "
72317>>>>>>>>>>>/// SQL_APPEND_STMT      to "ORDER BY NAME "
72317>>>>>>>>>>>/// SQL_PREPARE_STMT
72317>>>>>>>>>>>/// SQL_EXECUTE_STMT
72317>>>>>>>>>>>/// Repeat
72317>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT TO iCursor1
72317>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO iCustomer sName
72317>>>>>>>>>>>///     If (Found) Begin
72317>>>>>>>>>>>///        SQL_OPEN_CURSOR_STMT to iCursor2
72317>>>>>>>>>>>///        SQL_SET_STMT         to "SELECT SUM(ORDER_TOTAL) FROM ORDERHEA "
72317>>>>>>>>>>>///        SQL_APPEND_STMT      to ("WHERE CUSTOMER_NUMBER = " + Trim(iCustomer))
72317>>>>>>>>>>>///        SQL_PREPARE_STMT
72317>>>>>>>>>>>///        SQL_EXECUTE_STMT
72317>>>>>>>>>>>///        SQL_FETCH_NEXT_ROW INTO nOrderTotal
72317>>>>>>>>>>>///        If (Found and nOrderTotal > 0) Begin
72317>>>>>>>>>>>///            Showln "Customer : " iCustomer "-" sName " - Total: " nOrderTotal
72317>>>>>>>>>>>///        End
72317>>>>>>>>>>>///        SQL_CLOSE_CURSOR_STMT to Cursor2
72317>>>>>>>>>>>///
72317>>>>>>>>>>>///        Indicate Found True
72317>>>>>>>>>>>///     End
72317>>>>>>>>>>>/// Until (Not(Found))
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to Cursor1
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        SQL_CLOSE_CURSOR_STMT
72317>>>>>>>>>>>/// @Description This command closes the specified cursor that was created
72317>>>>>>>>>>>/// from SQL_OPEN_CURSOR_STMT. It is good practice to close all cursors
72317>>>>>>>>>>>/// once the statements associated with them are complete.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Public
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
72317>>>>>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax SQL_CLOSE_CURSOR_STMT [of {server}] to {variable}
72317>>>>>>>>>>>/// @Param server                       Name of the server (optional)
72317>>>>>>>>>>>/// @Param variable                     Cursor handle to close
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Example
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
72317>>>>>>>>>>>/// SQL_PREPARE_STMT
72317>>>>>>>>>>>/// SQL_EXECUTE_STMT
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
72317>>>>>>>>>>>/// SQL_PREPARE_STMT
72317>>>>>>>>>>>/// SQL_EXECUTE_STMT
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// Repeat
72317>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
72317>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
72317>>>>>>>>>>>///     If (Found) Begin
72317>>>>>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
72317>>>>>>>>>>>///     End
72317>>>>>>>>>>>///
72317>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
72317>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
72317>>>>>>>>>>>///     If (Found) Begin
72317>>>>>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
72317>>>>>>>>>>>///     End
72317>>>>>>>>>>>/// Until (FindErr)
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
72317>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        SQL_SET_CURRENT_CURSOR_STMT
72317>>>>>>>>>>>/// @Description This command is used to open a cursor to be used for an
72317>>>>>>>>>>>/// SQl statement. The cursor must be created using the SQL_OPEN_CURSOR_STMT,
72317>>>>>>>>>>>/// but once it has been created, this command can easily switch between
72317>>>>>>>>>>>/// cursors as desired. Optionally a different server can be specified for each
72317>>>>>>>>>>>/// cursor by passing the server name to this command as well. If no
72317>>>>>>>>>>>/// server is specified, the current server will be used. Note that it
72317>>>>>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Public
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
72317>>>>>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax SQL_SET_CURRENT_CURSOR_STMT [of {server}] to {variable}
72317>>>>>>>>>>>/// @Param server                       Name of the server (optional)
72317>>>>>>>>>>>/// @Param variable                     Cursor handle to use
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Example
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
72317>>>>>>>>>>>/// SQL_PREPARE_STMT
72317>>>>>>>>>>>/// SQL_EXECUTE_STMT
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
72317>>>>>>>>>>>/// SQL_PREPARE_STMT
72317>>>>>>>>>>>/// SQL_EXECUTE_STMT
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// Repeat
72317>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
72317>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
72317>>>>>>>>>>>///     If (Found) Begin
72317>>>>>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
72317>>>>>>>>>>>///     End
72317>>>>>>>>>>>///
72317>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
72317>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
72317>>>>>>>>>>>///     If (Found) Begin
72317>>>>>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
72317>>>>>>>>>>>///     End
72317>>>>>>>>>>>/// Until (FindErr)
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
72317>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        SQL_GET_CURRENT_CURSOR_STMT
72317>>>>>>>>>>>/// @Description This command returns the current active cursor being
72317>>>>>>>>>>>/// used. The cursor is returned to the specified variable.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Public
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
72317>>>>>>>>>>>/// @See SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax SQL_GET_CURRENT_CURSOR_STMT [of {server}] to {variable}
72317>>>>>>>>>>>/// @Param server                       Name of the server (optional)
72317>>>>>>>>>>>/// @Param variable         Variable to hold the current cursor handle
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Example
72317>>>>>>>>>>>/// SQL_GET_CURRENT_CURSOR_STMT to hCursor
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        SQL_SET_MAX_CURSORS_STMT
72317>>>>>>>>>>>/// @Description Sets the maximum number of simultaneous cursors allowed.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Deprecated
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
72317>>>>>>>>>>>/// @See
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax SQL_SET_MAX_CURSORS_STMT [of {server}] to {variable}
72317>>>>>>>>>>>/// @Param server                       Name of the server (optional)
72317>>>>>>>>>>>/// @Param variable                     Maximum number of cursors allowed
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Example
72317>>>>>>>>>>>/// SQL_SET_MAX_CURSORS_STMT to 50
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        SQL_GET_MAX_CURSORS_STMT
72317>>>>>>>>>>>/// @Description Retrieves the maximum number of cursors allowed.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Deprecated
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
72317>>>>>>>>>>>/// @See
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax SQL_GET_MAX_CURSORS_STMT [of {server}] to {variable}
72317>>>>>>>>>>>/// @Param server                       Name of the server (optional)
72317>>>>>>>>>>>/// @Param variable                     Maximum number of cursors allowed
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Example
72317>>>>>>>>>>>/// SQL_GET_MAX_CURSORS_STMT to iCursors
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        SQL_SET_LOCAL_TD_PATH
72317>>>>>>>>>>>/// @Description Sets the directory where the driver will find the LOCAL TD files.
72317>>>>>>>>>>>/// @Status      Deprecated
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
72317>>>>>>>>>>>/// @Param DirectoryPath   Directory path were the TD files are to be located.
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        SQL_GET_LOCAL_TD_PATH
72317>>>>>>>>>>>/// @Description Gets the directory where the driver is looking for the LOCAL TD files.
72317>>>>>>>>>>>/// @Status      Deprecated
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
72317>>>>>>>>>>>/// @Param DirectoryPath   Directory path were the driver is looking
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        GET_DRIVER_REVISION
72317>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
72317>>>>>>>>>>>/// of the driver associated with the current workspace into the specified
72317>>>>>>>>>>>/// variable.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Public
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72317>>>>>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax GET_DRIVER_REVISION to {variable}
72317>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Example
72317>>>>>>>>>>>/// GET_DRIVER_REVISION to sVersion
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        GET_DRIVER_MAJOR_REVISION
72317>>>>>>>>>>>/// @Description This command will put the current version (no decimals)
72317>>>>>>>>>>>/// of the driver associated with the current workspace into the specified
72317>>>>>>>>>>>/// variable.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Public
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72317>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax GET_DRIVER_MAJOR_REVISION to {variable}
72317>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Example
72317>>>>>>>>>>>/// GET_DRIVER_MAJOR_REVISION to sVersion
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        GET_DRIVER_LICENSE_EXPIRATION_TIME
72317>>>>>>>>>>>/// @Description This command is used to find out how long until a
72317>>>>>>>>>>>/// specific temporary license for a driver expires. If 0 is returned,
72317>>>>>>>>>>>/// then the license is not a temporary license. If -1 is returned, then
72317>>>>>>>>>>>/// the license has already expired. Otherwise, the number returned
72317>>>>>>>>>>>/// is the number of days until the license will expire.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Public
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 Aaron Gulack
72317>>>>>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH SET_DRIVER_LICENSE_EXPIRATION_WARNING
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax GET_DRIVER_LICENSE_EXPIRATION_TIME to {variable}
72317>>>>>>>>>>>/// @Param variable                     Variable to hold the days until expiration
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Example
72317>>>>>>>>>>>/// GET_DRIVER_LICENSE_EXPIRATION_TIME to iExpire
72317>>>>>>>>>>>/// Showln iExpire
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        SET_DRIVER_LICENSE_EXPIRATION_WARNING
72317>>>>>>>>>>>/// @Description This command is used to set a custom warning message to
72317>>>>>>>>>>>/// be displayed when a temporary license for a driver is close to expiring.
72317>>>>>>>>>>>/// Note that since the license evaluation is done during Login and before
72317>>>>>>>>>>>/// any open calls, this command should be called before either of those.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Public
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72317>>>>>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH GET_DRIVER_LICENSE_EXPIRATION_TIME
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax SET_DRIVER_LICENSE_EXPIRATION_WARNING to {variable}
72317>>>>>>>>>>>/// @Param variable                     New warning message for expiring license
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Example
72317>>>>>>>>>>>/// SET_DRIVER_LICENSE_EXPIRATION_WARNING to "Your license is about to expire."
72317>>>>>>>>>>>/// Login "localhost" "" "" "sql_drv"
72317>>>>>>>>>>>
72317>>>>>>>>>>>//=============================================================================
72317>>>>>>>>>>>/// @Name        GET_DRIVER_LICENSE_PATH
72317>>>>>>>>>>>/// @Description This command will return the current path of the license
72317>>>>>>>>>>>/// associated with the driver.
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Assumptions
72317>>>>>>>>>>>/// @Status      Internal
72317>>>>>>>>>>>/// @Drivers     All
72317>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72317>>>>>>>>>>>/// @See                 SET_DRIVER_LICENSE_EXPIRATION_WARNING GET_DRIVER_LICENSE_EXPIRATION_TIME
72317>>>>>>>>>>>///
72317>>>>>>>>>>>/// @Syntax GET_DRIVER_LICENSE_PATH to {variable}
72317>>>>>>>>>>>/// @Param variable                     Variable to hold the path of the license
72317>>>>>>>>>>>
72317>>>>>>>>>>>Function MertechInc_GET_DRIVER_LICENSE_PATH Global Returns String
72319>>>>>>>>>>>    String sReturnValue
72319>>>>>>>>>>>
72319>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
72345>>>>>>>>>>>>
72345>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
72347>>>>>>>>>>>        Get MertechInc_Pre_Size_String 4096 to sReturnValue
72348>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING sReturnValue MertechInc_Blank CALLDRV_LICENSE_PATH RESULT MertechInc_iRet
72353>>>>>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
72356>>>>>>>>>>>    End
72356>>>>>>>>>>>>
72356>>>>>>>>>>>
72356>>>>>>>>>>>    Function_Return sReturnValue
72357>>>>>>>>>>>End_Function
72358>>>>>>>>>>>
72358>>>>>>>>>>>//=============================================================================
72358>>>>>>>>>>>/// @Name        SET_DATABASE_PORT
72358>>>>>>>>>>>/// @Description This command is used to dynamically change the port
72358>>>>>>>>>>>/// number to use for all TCP/IP connections to the server. Note that
72358>>>>>>>>>>>/// the port is used for the current session only.
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Assumptions The port is valid and available
72358>>>>>>>>>>>/// @Status      Public
72358>>>>>>>>>>>/// @Drivers     MySQLFlex PgFlex
72358>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
72358>>>>>>>>>>>/// @See                 GET_DATABASE_PORT
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Syntax SET_DATABASE_PORT of {constant} to {variable}
72358>>>>>>>>>>>/// @Param constant                     MYSQL or PGSQL
72358>>>>>>>>>>>/// @Param variable                     Port number to use to connect to server
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Example
72358>>>>>>>>>>>/// GET_DATABASE_PORT of MYSQL to 1433
72358>>>>>>>>>>>
72358>>>>>>>>>>>//=============================================================================
72358>>>>>>>>>>>/// @Name        GET_DATABASE_PORT
72358>>>>>>>>>>>/// @Description This command returns the TCP/IP port used to connect
72358>>>>>>>>>>>/// to the server.
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Assumptions
72358>>>>>>>>>>>/// @Status      Public
72358>>>>>>>>>>>/// @Drivers     MySQLFlex PgFlex
72358>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72358>>>>>>>>>>>/// @See                 SET_DATABASE_PORT
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Syntax GET_DATABASE_PORT of {MYSQL/PGSQL} to {variable}
72358>>>>>>>>>>>/// @Param variable                     Variable to hold the TCP/IP port number
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Example
72358>>>>>>>>>>>/// GET_DATABASE_PORT of MYSQL to iPort
72358>>>>>>>>>>>
72358>>>>>>>>>>>//=============================================================================
72358>>>>>>>>>>>/// @Name        GET_SERIAL_NUMBER
72358>>>>>>>>>>>/// @Description This command returns the serial number associated with
72358>>>>>>>>>>>/// the current driver's license.
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Assumptions
72358>>>>>>>>>>>/// @Status      Public
72358>>>>>>>>>>>/// @Drivers     All
72358>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
72358>>>>>>>>>>>/// @See
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Syntax GET_SERIAL_NUMBER to {variable}
72358>>>>>>>>>>>/// @Param variable                     Variable to hold the driver's serial number
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Example
72358>>>>>>>>>>>/// GET_SERIAL_NUMBER to iSerial
72358>>>>>>>>>>>
72358>>>>>>>>>>>//=============================================================================
72358>>>>>>>>>>>/// @Name        SET_DATABASE_SOCKET
72358>>>>>>>>>>>/// @Description This command is used to set the socket used to connect
72358>>>>>>>>>>>/// to the server when running an application under Linux/Unix.
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Assumptions
72358>>>>>>>>>>>/// @Status      Public
72358>>>>>>>>>>>/// @Drivers     MySQLFlex
72358>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72358>>>>>>>>>>>/// @See                 GET_DATABASE_SOCKET
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
72358>>>>>>>>>>>/// @Param variable                     Full name of the socket
72358>>>>>>>>>>>
72358>>>>>>>>>>>//=============================================================================
72358>>>>>>>>>>>/// @Name        GET_DATABASE_SOCKET
72358>>>>>>>>>>>/// @Description This command returns the name of the socket used to
72358>>>>>>>>>>>/// connect to the server when running an application under Linux/Unix.
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Assumptions
72358>>>>>>>>>>>/// @Status      Public
72358>>>>>>>>>>>/// @Drivers     MySQLFlex
72358>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72358>>>>>>>>>>>/// @See                 SET_DATABASE_SOCKET
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
72358>>>>>>>>>>>/// @Param variable                     Variable to hold the full socket name
72358>>>>>>>>>>>
72358>>>>>>>>>>>//=============================================================================
72358>>>>>>>>>>>/// @Name        SET_AUTHENTICATION_MODE
72358>>>>>>>>>>>/// @Description This command is used to control what mode the user logs
72358>>>>>>>>>>>/// in as. When DEFAULT is passed, the user will be logged in with the
72358>>>>>>>>>>>/// default privileges given to it. When SYSDBA is passed, the user will
72358>>>>>>>>>>>/// be logged in with the roles assigned to the sysdba user, most likely
72358>>>>>>>>>>>/// full control over the database.
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Assumptions
72358>>>>>>>>>>>/// @Status      Public
72358>>>>>>>>>>>/// @Drivers     OraFlex
72358>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
72358>>>>>>>>>>>/// @See
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Syntax SET_AUTHENTICATION_MODE of Oracle to {SYSDBA/DEFAULT}
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Example
72358>>>>>>>>>>>/// SET_AUTHENTICATION_MODE of Oracle to DEFAULT
72358>>>>>>>>>>>
72358>>>>>>>>>>>//=============================================================================
72358>>>>>>>>>>>/// @Name        SQL_ESCAPE_STRING
72358>>>>>>>>>>>/// @Description This command is used to properly escape strings before
72358>>>>>>>>>>>/// they are used in embedded SQL statements. This can be extremely
72358>>>>>>>>>>>/// important when you do not have full control of the strings being passed
72358>>>>>>>>>>>/// to the SQL statement as this will ensure that the strings are properly
72358>>>>>>>>>>>/// quoted.
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Assumptions
72358>>>>>>>>>>>/// @Status      Public
72358>>>>>>>>>>>/// @Drivers     All
72358>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72358>>>>>>>>>>>/// @See
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Syntax SQL_ESCAPE_STRING of {string} to {variable}
72358>>>>>>>>>>>/// @Param string               The string to be escaped.
72358>>>>>>>>>>>/// @Param variable     Variable to hold the newly escaped string
72358>>>>>>>>>>>///
72358>>>>>>>>>>>/// @Example
72358>>>>>>>>>>>/// SQL_ESCAPE_STRING of "They said to me, 'hello'." to sEscaped
72358>>>>>>>>>>>
72358>>>>>>>>>>>Function SQLESCAPESTRING Global String sData Returns String
72360>>>>>>>>>>>    String sReturnData
72360>>>>>>>>>>>
72360>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
72386>>>>>>>>>>>>
72386>>>>>>>>>>>
72386>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
72388>>>>>>>>>>>        Get MertechInc_Pre_Size_String 0 to sReturnData
72389>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_ESCAPE_STRING CALLBACK 0 PASSING sData sReturnData 0 RESULT MertechInc_iRet
72394>>>>>>>>>>>    End
72394>>>>>>>>>>>>
72394>>>>>>>>>>>
72394>>>>>>>>>>>    Function_Return sReturnData
72395>>>>>>>>>>>End_Function
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        DIRECT_PATH_LOAD
72396>>>>>>>>>>>/// @Description
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Assumptions
72396>>>>>>>>>>>/// @Status      Internal
72396>>>>>>>>>>>/// @Drivers     OraFlex
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
72396>>>>>>>>>>>/// @See
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        SQL_INITIALIZE_SEQUENCE
72396>>>>>>>>>>>/// @Description This command is used to initialize all auto increment
72396>>>>>>>>>>>/// columns, or sequences in Oracle, of the specified table to be the
72396>>>>>>>>>>>/// highest number plus one. This is useful when inserting a large amount
72396>>>>>>>>>>>/// of records in the table and the sequence is not being updated because
72396>>>>>>>>>>>/// the auto incremented column is being manually filled.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Assumptions
72396>>>>>>>>>>>/// @Status      Public
72396>>>>>>>>>>>/// @Drivers     OraFlex PgFlex
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72396>>>>>>>>>>>/// @See
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// SQL_INITIALIZE_SEQUENCE of {FileNumber}
72396>>>>>>>>>>>/// @Param FileNumber                   The file number
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        LOB_APPEND
72396>>>>>>>>>>>/// @Description This command is used to append data to an existing LOB
72396>>>>>>>>>>>/// column in the database. When called, the data corresponding field
72396>>>>>>>>>>>/// in the buffer is appended to the respective column in the database.
72396>>>>>>>>>>>/// This can be very useful when saving data that exceeds VDF size limits
72396>>>>>>>>>>>/// but falls within the limits of the SQL database. Note that this command
72396>>>>>>>>>>>/// must write to a file that is active and locked. Also the save is handled
72396>>>>>>>>>>>/// within the command so no extra calls are needed to save the changes made.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
72396>>>>>>>>>>>/// @Status      Deprecated
72396>>>>>>>>>>>/// @Drivers     All
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72396>>>>>>>>>>>/// @See                 SQL_LOB_ADD_CHUNK
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Syntax LOB_APPEND of {FileName} {FieldNumber}
72396>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
72396>>>>>>>>>>>/// @Param FieldNumber          Number of the field being appended to
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Example
72396>>>>>>>>>>>/// Clear Customer
72396>>>>>>>>>>>/// Find Gt Customer By Index.1
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// Direct_Input 'C:\Mertech.xml'
72396>>>>>>>>>>>/// Lock
72396>>>>>>>>>>>///    Find Eq Customer by Recnum
72396>>>>>>>>>>>///
72396>>>>>>>>>>>///    Read_Block Customer.Comments 16384
72396>>>>>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
72396>>>>>>>>>>>///    Repeat
72396>>>>>>>>>>>///        Read_Block Customer.Comments 16384
72396>>>>>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
72396>>>>>>>>>>>///    Until (SeqEOF)
72396>>>>>>>>>>>/// Unlock
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// Close_Input
72396>>>>>>>>>>>/// Find Eq Customer By Recnum
72396>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
72396>>>>>>>>>>>/// Showln 'Length: ' iLength
72396>>>>>>>>>>>
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        LOB_LENGTH
72396>>>>>>>>>>>/// @Description This command returns the length of the data in the
72396>>>>>>>>>>>/// specified column. This command must be used after a proper FIND to
72396>>>>>>>>>>>/// ensure that a valid record is in the buffer. This can be a useful
72396>>>>>>>>>>>/// command for checking if uploaded data exceeds size limits.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
72396>>>>>>>>>>>/// @Status      Deprecated
72396>>>>>>>>>>>/// @Drivers     All
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72396>>>>>>>>>>>/// @See                 SQL_GET_LOB_LENGTH
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Syntax LOB_LENGTH of {FileName} {FieldNumber} to {variable}
72396>>>>>>>>>>>/// @Param FileName                     Name of the file
72396>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB field
72396>>>>>>>>>>>/// @Param variable                     Variable to hold the length
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Example
72396>>>>>>>>>>>/// Clear Customer
72396>>>>>>>>>>>/// Find Gt Customer By Index.1
72396>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
72396>>>>>>>>>>>/// Showln 'Length: ' iLength
72396>>>>>>>>>>>
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        LOB_READ
72396>>>>>>>>>>>/// @Description This command reads a chunk of data from a specified LOB
72396>>>>>>>>>>>/// column, moving it into its corresponding field buffer. Because the
72396>>>>>>>>>>>/// chunk will be moved into the field buffer, it can only be as large as
72396>>>>>>>>>>>/// the buffer allows. To account for this, the constants FIRST or NEXT
72396>>>>>>>>>>>/// are passed as well indicating whether to grab the first chunk for
72396>>>>>>>>>>>/// the buffer or the next. Each chunk grabbed will be as large as allowed.
72396>>>>>>>>>>>/// All these things considered, when reading data larger than the field
72396>>>>>>>>>>>/// buffer, it is good practice to perform the read in a loop, adding the
72396>>>>>>>>>>>/// length each time. Another optional parameter that can be passed is a
72396>>>>>>>>>>>/// variable that will store the length of the chunk. Note that a LOB read
72396>>>>>>>>>>>/// must be done after a successful find on the record.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
72396>>>>>>>>>>>/// @Status      Deprecated
72396>>>>>>>>>>>/// @Drivers     All
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72396>>>>>>>>>>>/// @See                 SQL_GET_LOB SQL_GET_LOB_CHUNK
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Syntax LOB_READ of {FileName} {FieldNumber} {FIRST/NEXT} [{length}]
72396>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
72396>>>>>>>>>>>/// @Param FieldNumber          Number of the field being read from
72396>>>>>>>>>>>/// @Param FIRST                        Reads the first chunk of data
72396>>>>>>>>>>>/// @Param NEXT                         Reads the next chuck of data (if larger than buffer limit)
72396>>>>>>>>>>>/// @Param length                       Variable to hold the chunk length (optional)
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Example
72396>>>>>>>>>>>/// Direct_Output ('binary:Mertech.pdf')
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// Clear customer
72396>>>>>>>>>>>/// Find Gt customer by Index.1
72396>>>>>>>>>>>/// SQL_LOB_LENGTH of customer 13 to liLength
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// While (liLength > 0)
72396>>>>>>>>>>>///     Write customer.comments
72396>>>>>>>>>>>///     SQL_LOB_READ of customer 13 Next liLength
72396>>>>>>>>>>>/// Loop
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// Close_Output
72396>>>>>>>>>>>
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        LOB_WRITE
72396>>>>>>>>>>>/// @Description This command is used to write data to a LOB column.
72396>>>>>>>>>>>/// By passing the file name and field number of the LOB column, this
72396>>>>>>>>>>>/// command will take the current value of the respective field in
72396>>>>>>>>>>>/// the field buffer, write it to the database and save it. Any data
72396>>>>>>>>>>>/// currently in that field will be overridden by the data from the
72396>>>>>>>>>>>/// buffer. Note that this command must write to a file that is active
72396>>>>>>>>>>>/// and locked. Also this command handles the save so no extra calls
72396>>>>>>>>>>>/// are needed to save the changes.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
72396>>>>>>>>>>>/// @Status      Deprecated
72396>>>>>>>>>>>/// @Drivers     All
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72396>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Syntax LOB_WRITE of {FileName} {FieldNumber}
72396>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
72396>>>>>>>>>>>/// @Param FieldNumber          Number of the field being written to
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Example
72396>>>>>>>>>>>/// Clear Customer
72396>>>>>>>>>>>/// Find Gt Customer By Index.1
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// Direct_Input 'C:\Mertech.xml'
72396>>>>>>>>>>>/// Lock
72396>>>>>>>>>>>///    Find Eq Customer by Recnum
72396>>>>>>>>>>>///
72396>>>>>>>>>>>///    Read_Block Customer.Comments 16384
72396>>>>>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
72396>>>>>>>>>>>///    Repeat
72396>>>>>>>>>>>///        Read_Block Customer.Comments 16384
72396>>>>>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
72396>>>>>>>>>>>///    Until (SeqEOF)
72396>>>>>>>>>>>/// Unlock
72396>>>>>>>>>>>/// Close_Input
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// Find Eq Customer By Recnum
72396>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
72396>>>>>>>>>>>/// Showln 'Length: ' iLength
72396>>>>>>>>>>>
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        LOB_LOADFROMFILE
72396>>>>>>>>>>>/// @Description This command loads an external file into a specified LOB
72396>>>>>>>>>>>/// column. After specifying the file name and field number, the path and
72396>>>>>>>>>>>/// file must then be passed respectively. When using Oracle, instead of
72396>>>>>>>>>>>/// passing the directory, a directory alias must be passed. This alias
72396>>>>>>>>>>>/// can be created using a "CREATE DIRECTORY" statement in SQL. For more
72396>>>>>>>>>>>/// information on setting this directory alias, see the Oracle help.
72396>>>>>>>>>>>/// For other servers, the file must be a local file available to the
72396>>>>>>>>>>>/// application that is calling the command. Note that this command must
72396>>>>>>>>>>>/// write to a file that is active and locked. Also this command handles
72396>>>>>>>>>>>/// the save so no extra calls are needed to save the changes.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
72396>>>>>>>>>>>/// @Status      Deprecated
72396>>>>>>>>>>>/// @Drivers     All
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72396>>>>>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Syntax LOB_LOADFROMFILE of {FileName} {FieldNumber} From {path} {file}
72396>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
72396>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB column being used
72396>>>>>>>>>>>/// @Param path                         The path of the file, excluding the file name
72396>>>>>>>>>>>/// @Param file                         The name of the file, including the extension
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Example
72396>>>>>>>>>>>/// Clear Customer
72396>>>>>>>>>>>/// Find Gt Customer By Index.1
72396>>>>>>>>>>>/// Lock
72396>>>>>>>>>>>///    Find Eq Customer by Recnum
72396>>>>>>>>>>>///    LOB_TRUNCATE OF customel 13 to 0 // Customer.Comments
72396>>>>>>>>>>>///    Saverecord Customer
72396>>>>>>>>>>>///    // Directory name is case sensitive.
72396>>>>>>>>>>>///    // Make sure the name case matches
72396>>>>>>>>>>>///    LOB_LOADFROMFILE OF customel 13 FROM "C:\Mertech\FilesToLoad" "Mertech.XML"
72396>>>>>>>>>>>/// Unlock
72396>>>>>>>>>>>
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        LOB_ERASE
72396>>>>>>>>>>>/// @Description This command is used to erase a portion of data from a
72396>>>>>>>>>>>/// LOB column. For text fields, the portion of data to be erased is
72396>>>>>>>>>>>/// replaced with white space, and in binary fields, with 0X0. To erase
72396>>>>>>>>>>>/// a portion of the data, pass the length to erase as well as the number
72396>>>>>>>>>>>/// to offset from. For this command to work properly, it must be done
72396>>>>>>>>>>>/// after a valid find. Note that the save is handled inside this command
72396>>>>>>>>>>>/// so no extra commands are needed to save the changes.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
72396>>>>>>>>>>>/// @Status      Deprecated
72396>>>>>>>>>>>/// @Drivers     All
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72396>>>>>>>>>>>/// @See LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Syntax LOB_ERASE OF {FileName} {FieldNumber} {length} {offset}
72396>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
72396>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB column being erased
72396>>>>>>>>>>>/// @Param Length                       Length of chunk to erase from column
72396>>>>>>>>>>>/// @Param offset                       Starting position for erase
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Example
72396>>>>>>>>>>>/// Clear customer
72396>>>>>>>>>>>/// Find Gt customer by Recnum
72396>>>>>>>>>>>/// Lock
72396>>>>>>>>>>>/// Find Eq customer by Recnum
72396>>>>>>>>>>>/// LOB_LENGTH OF customer 13 to liTotalLength
72396>>>>>>>>>>>/// LOB_ERASE  OF customer 13    liTotalLength 1
72396>>>>>>>>>>>/// Unlock
72396>>>>>>>>>>>
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        LOB_TRUNCATE
72396>>>>>>>>>>>/// @Description This command is used to trim a LOB column down to a
72396>>>>>>>>>>>/// specified length. By passing the table name and column number, the
72396>>>>>>>>>>>/// value in the column can then be trimmed down the specified length.
72396>>>>>>>>>>>/// This can be a useful command for clearing out a column before entering
72396>>>>>>>>>>>/// new data into it. Note that this command must write to a file that is active
72396>>>>>>>>>>>/// and locked. Also this command handles the save so no extra calls
72396>>>>>>>>>>>/// are needed to save the changes. This command can be used to clear out a field before adding new data
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
72396>>>>>>>>>>>/// @Status      Deprecated
72396>>>>>>>>>>>/// @Drivers     All
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72396>>>>>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE FLUSH_LOB_BUFFER
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Syntax LOB_TRUNCATE of {FileName} {FieldNumber} to {variable}
72396>>>>>>>>>>>/// @Param FileName                     Name of the file
72396>>>>>>>>>>>/// @Param FieldNumber          The field number
72396>>>>>>>>>>>/// @Param length                       New length to truncate to
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Example
72396>>>>>>>>>>>/// Clear Customer
72396>>>>>>>>>>>/// Find Gt Customer By Index.1
72396>>>>>>>>>>>/// Lock
72396>>>>>>>>>>>///    Find Eq Customer by Recnum
72396>>>>>>>>>>>///    SQL_LOB_TRUNCATE of Customer 13 to 0 // Customer.Comments
72396>>>>>>>>>>>///    Saverecord Customer
72396>>>>>>>>>>>/// Unlock
72396>>>>>>>>>>>
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        FLUSH_LOB_BUFFER
72396>>>>>>>>>>>/// @Description This command currently serves no function.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Assumptions
72396>>>>>>>>>>>/// @Status      Deprecated
72396>>>>>>>>>>>/// @Drivers     MySQLFlex
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
72396>>>>>>>>>>>/// @See
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Syntax FLUSH_LOB_BUFFER of {FileName}
72396>>>>>>>>>>>/// @Param FileName                     Name of the file
72396>>>>>>>>>>>
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        SQL_ENABLE_RECONNECT
72396>>>>>>>>>>>/// @Description Allow MySql Driver to auto reconnect after a time-out.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// Driver auto-reconnect feature handles the issue where MySQL
72396>>>>>>>>>>>/// will kick off a user after inactivity.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Status      Deprecated
72396>>>>>>>>>>>/// @Drivers     MySQL
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-11 By Ian Smith
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Syntax SQL_ENABLE_RECONNECT of <ServerName> to dftrue/dffalse
72396>>>>>>>>>>>/// @Param ServerName  Server Name.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Usage SQL_ENABLE_RECONNECT Of sServerID To dftrue
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        CALL_MYSQL_STORED_PROCEDURE
72396>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
72396>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
72396>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
72396>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
72396>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
72396>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
72396>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
72396>>>>>>>>>>>/// is set to true.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Assumptions
72396>>>>>>>>>>>/// @Status      Deprecated
72396>>>>>>>>>>>/// @Drivers     MySQLFlex
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72396>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Syntax CALL_MYSQL_STORED_PROCEDURE {procedure} Passing {argument}
72396>>>>>>>>>>>/// @Param procedure            Full name of the procedure
72396>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Example
72396>>>>>>>>>>>/// CALL_MYSQL_STORED_PROCEDURE "getCustomerStatus" passing sCustomerID sStatus
72396>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
72396>>>>>>>>>>>/// Showln sStatus
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        CALL_MYSQL_STORED_FUNCTION
72396>>>>>>>>>>>/// @Description This command is used to execute a function stored in MySQL.
72396>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
72396>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
72396>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
72396>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
72396>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
72396>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
72396>>>>>>>>>>>/// values.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Status      Deprecated
72396>>>>>>>>>>>/// @Drivers     MySQLFlex
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72396>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Syntax CALL_MYSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
72396>>>>>>>>>>>/// @Param function                     Full name of the function
72396>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
72396>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Example
72396>>>>>>>>>>>/// CALL_MYSQL_STORED_FUNCTION "getCustomerStatus" Returns sStatus passing sCustomerID
72396>>>>>>>>>>>/// Showln sStatus
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        DO_SET_ALL_FUNCTION_PARAMETERS
72396>>>>>>>>>>>/// @Description Sets the parameters for a MySQL stored function call.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Assumptions
72396>>>>>>>>>>>/// @Status      Internal
72396>>>>>>>>>>>/// @Drivers     MySQLFlex
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
72396>>>>>>>>>>>/// @See
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Syntax DO_SET_ALL_FUNCTION_PARAMETERS [sParam1 [sParam2 . sParamn]]
72396>>>>>>>>>>>/// @Param sParam1.n    Parameters for the stored function
72396>>>>>>>>>>>
72396>>>>>>>>>>>//=============================================================================
72396>>>>>>>>>>>/// @Name        GET_NO_AVAILABLE_SQLSERVERS
72396>>>>>>>>>>>/// @Description This command is used to get the number of available MSSQL
72396>>>>>>>>>>>/// servers detected in the network. When used with GET_SQLSERVER_NAME,
72396>>>>>>>>>>>/// all the available server names can be easily retrieved.
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
72396>>>>>>>>>>>/// @Status      Public
72396>>>>>>>>>>>/// @Drivers     SQLFlex
72396>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72396>>>>>>>>>>>/// @See                 GET_SQLSERVER_NAME
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Syntax GET_NO_AVAILABLE_SQLSERVERS to {variable}
72396>>>>>>>>>>>/// @Param variable                     Variable to hold number of servers
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// @Example
72396>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
72396>>>>>>>>>>>///
72396>>>>>>>>>>>/// While (i <= iServers)
72396>>>>>>>>>>>///     GET_SQLSERVER_NAME i to sServer
72396>>>>>>>>>>>///     Showln sServer
72396>>>>>>>>>>>///     Increment i
72396>>>>>>>>>>>/// Loop
72396>>>>>>>>>>>
72396>>>>>>>>>>>Function SQL_AVAILABLE_SQL_SERVERS Global Returns Integer
72398>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_ENUMERATE_SERVER_COUNT RESULT MertechInc_iRet
72403>>>>>>>>>>>
72403>>>>>>>>>>>    Function_Return MertechInc_iRet
72404>>>>>>>>>>>End_Function
72405>>>>>>>>>>>
72405>>>>>>>>>>>
72405>>>>>>>>>>>//=============================================================================
72405>>>>>>>>>>>/// @Name        GET_SQLSERVER_NAME
72405>>>>>>>>>>>/// @Description This command returns the name of the server based on the
72405>>>>>>>>>>>/// specified index number. The number of servers can be retrieved from
72405>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS and the names can be indexed from that
72405>>>>>>>>>>>/// number.
72405>>>>>>>>>>>///
72405>>>>>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
72405>>>>>>>>>>>/// @Status      Public
72405>>>>>>>>>>>/// @Drivers     SQLFlex
72405>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72405>>>>>>>>>>>/// @See                 GET_NO_AVAILABLE_SQLSERVERS
72405>>>>>>>>>>>///
72405>>>>>>>>>>>/// @Syntax SQL_AVAILABLE_SQL_SERVER_NAME {index} to {variable}
72405>>>>>>>>>>>/// @Param index                The numbered index name to retrieve
72405>>>>>>>>>>>/// @Param variable             Variable to hold the server name
72405>>>>>>>>>>>///
72405>>>>>>>>>>>/// @Example
72405>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
72405>>>>>>>>>>>///
72405>>>>>>>>>>>/// While (i <= iServers)
72405>>>>>>>>>>>///     GET_SQLSERVER_NAME i to sServer
72405>>>>>>>>>>>///     Showln sServer
72405>>>>>>>>>>>///     Increment i
72405>>>>>>>>>>>/// Loop
72405>>>>>>>>>>>
72405>>>>>>>>>>>Function SQL_AVAILABLE_SQL_SERVER_NAME Global Integer iIndex Returns String
72407>>>>>>>>>>>    String sName
72407>>>>>>>>>>>
72407>>>>>>>>>>>    Get MertechInc_Pre_Size_String 80 to sName
72408>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING sName iIndex CALLDRV_ENUMERATE_SERVER_SERVER RESULT MertechInc_iRet
72413>>>>>>>>>>>
72413>>>>>>>>>>>    Function_Return sName
72414>>>>>>>>>>>End_Function
72415>>>>>>>>>>>
72415>>>>>>>>>>>
72415>>>>>>>>>>>//=============================================================================
72415>>>>>>>>>>>/// @Name        SET_USE_ROWCOUNT_IN_TRANSACTION
72415>>>>>>>>>>>/// @Description Turn on / off Row_Count for specified server.
72415>>>>>>>>>>>/// @Status      Deprecated
72415>>>>>>>>>>>/// @Drivers     All
72415>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
72415>>>>>>>>>>>///
72415>>>>>>>>>>>/// @Syntax SET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
72415>>>>>>>>>>>/// @Param Server      Name of server to turn On / Off Row_Count
72415>>>>>>>>>>>/// @Param State       TRUE = turn on Row_Count  FALSE = turn off Row_Count
72415>>>>>>>>>>>///
72415>>>>>>>>>>>/// @Comment This SHOULD ALWAYS BE TURNED ON
72415>>>>>>>>>>>
72415>>>>>>>>>>>Procedure Set SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Integer iState
72417>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
72443>>>>>>>>>>>>
72443>>>>>>>>>>>
72443>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer iState CALLDRV_VALUE_SET RESULT MertechInc_iRet
72448>>>>>>>>>>>    If MertechInc_iRet EQ -1 INDICATE ERR True
72451>>>>>>>>>>>End_Procedure
72452>>>>>>>>>>>
72452>>>>>>>>>>>//IGS - commented out by a.n. Other
72452>>>>>>>>>>>//#REPLACE UseRowCountInTransactions SQL_USE_ROWCOUNT_IN_TRANSACTIONS
72452>>>>>>>>>>>
72452>>>>>>>>>>>//=============================================================================
72452>>>>>>>>>>>/// @Name        GET_USE_ROWCOUNT_IN_TRANSACTION
72452>>>>>>>>>>>/// @Description Gets the Row_Count setting for specified server.
72452>>>>>>>>>>>/// @Status      Deprecated
72452>>>>>>>>>>>/// @Drivers     All
72452>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
72452>>>>>>>>>>>///
72452>>>>>>>>>>>/// @Syntax GET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
72452>>>>>>>>>>>/// @Param Server      Name of server to get Row_Count state of
72452>>>>>>>>>>>/// @Param State       Variable to hold returned value
72452>>>>>>>>>>>
72452>>>>>>>>>>>Function SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Returns Integer
72454>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
72480>>>>>>>>>>>>
72480>>>>>>>>>>>
72480>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
72485>>>>>>>>>>>
72485>>>>>>>>>>>    Function_Return MertechInc_iRet
72486>>>>>>>>>>>End_Function
72487>>>>>>>>>>>
72487>>>>>>>>>>>
72487>>>>>>>>>>>//=============================================================================
72487>>>>>>>>>>>/// @Name        SQL_SET_DATE_FORMAT
72487>>>>>>>>>>>/// @Description This command controls the date format of data returned
72487>>>>>>>>>>>/// through embedded SQL. If set to DATAFLEX, then the dates will be
72487>>>>>>>>>>>/// returned in whatever format is set in DF_DATE_FORMAT. When set to
72487>>>>>>>>>>>/// NATIVE, this command will force dates to return dates in the format
72487>>>>>>>>>>>/// specified on the SQL server. Note that in order for the variables to
72487>>>>>>>>>>>/// be in the right form, they need to be string variables.
72487>>>>>>>>>>>///
72487>>>>>>>>>>>/// @Assumptions
72487>>>>>>>>>>>/// @Status      Public
72487>>>>>>>>>>>/// @Drivers     SQLFlex
72487>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72487>>>>>>>>>>>/// @See
72487>>>>>>>>>>>///
72487>>>>>>>>>>>/// @Syntax SQL_SET_DATE_FORMAT to {DATAFLEX/NATIVE}
72487>>>>>>>>>>>///
72487>>>>>>>>>>>/// @Example
72487>>>>>>>>>>>/// SQL_SET_DATE_FORMAT to NATIVE
72487>>>>>>>>>>>
72487>>>>>>>>>>>Procedure Set SQL_USE_DATAFLEX_DATEFORMAT Global Integer iState
72489>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
72515>>>>>>>>>>>>
72515>>>>>>>>>>>
72515>>>>>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
72517>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
72522>>>>>>>>>>>        IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
72525>>>>>>>>>>>    End
72525>>>>>>>>>>>>
72525>>>>>>>>>>>End_Procedure
72526>>>>>>>>>>>
72526>>>>>>>>>>>Function SQL_USE_DATAFLEX_DATEFORMAT Global Returns Integer
72528>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
72554>>>>>>>>>>>>
72554>>>>>>>>>>>
72554>>>>>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
72556>>>>>>>>>>>        CALL_DRIVER 0 MertechInc_DriverName FUNCTION CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
72561>>>>>>>>>>>    End
72561>>>>>>>>>>>>
72561>>>>>>>>>>>    Else Move DFFALSE to MertechInc_iRet
72563>>>>>>>>>>>
72563>>>>>>>>>>>    function_return MertechInc_iRet
72564>>>>>>>>>>>End_Function
72565>>>>>>>>>>>
72565>>>>>>>>>>>
72565>>>>>>>>>>>//=============================================================================
72565>>>>>>>>>>>/// @Name        SET_FIELDS_NOT_NULL
72565>>>>>>>>>>>/// @Description This command is used to specify how to handle blank
72565>>>>>>>>>>>/// and zero values on the SQL backend. Since blank or zero values can
72565>>>>>>>>>>>/// often be stored as null in the server database, this command allows
72565>>>>>>>>>>>/// that to be altered if needed. When set to true, a value will be
72565>>>>>>>>>>>/// inserted into blank records to keep them from being null. See the
72565>>>>>>>>>>>/// list below for what value will be stored instead of null. If set to
72565>>>>>>>>>>>/// false, values will be stored normally in the database. Note that this
72565>>>>>>>>>>>/// command effects all data types.
72565>>>>>>>>>>>///
72565>>>>>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
72565>>>>>>>>>>>///
72565>>>>>>>>>>>/// DF_BCD -                                    0 (zero)
72565>>>>>>>>>>>///
72565>>>>>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
72565>>>>>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
72565>>>>>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
72565>>>>>>>>>>>///
72565>>>>>>>>>>>/// DF_BINARY -                                 0X0
72565>>>>>>>>>>>///
72565>>>>>>>>>>>/// @Assumptions
72565>>>>>>>>>>>/// @Status      Public
72565>>>>>>>>>>>/// @Drivers     All
72565>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
72565>>>>>>>>>>>/// @See                 SET_FIELDS_NULL GET_FIELDS_NULL
72565>>>>>>>>>>>///
72565>>>>>>>>>>>/// @Syntax SET_FIELDS_NOT_NULL to {variable}
72565>>>>>>>>>>>/// @Param variable             Boolean variable to indicate how to handle null values
72565>>>>>>>>>>>///
72565>>>>>>>>>>>
72565>>>>>>>>>>>Procedure Set SQL_FORCE_FIELDS_NOT_NULL Global Integer iState
72567>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
72593>>>>>>>>>>>>
72593>>>>>>>>>>>
72593>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
72595>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
72600>>>>>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
72603>>>>>>>>>>>    End
72603>>>>>>>>>>>>
72603>>>>>>>>>>>End_Procedure
72604>>>>>>>>>>>
72604>>>>>>>>>>>
72604>>>>>>>>>>>
72604>>>>>>>>>>>
72604>>>>>>>>>>>Function SQL_FORCE_FIELDS_NOT_NULL Global Returns Integer
72606>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
72632>>>>>>>>>>>>
72632>>>>>>>>>>>
72632>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
72634>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
72639>>>>>>>>>>>    End
72639>>>>>>>>>>>>
72639>>>>>>>>>>>    Else Move DFFALSE to MertechInc_iRet
72641>>>>>>>>>>>
72641>>>>>>>>>>>    Function_Return MertechInc_iRet
72642>>>>>>>>>>>End_Function
72643>>>>>>>>>>>
72643>>>>>>>>>>>
72643>>>>>>>>>>>//=============================================================================
72643>>>>>>>>>>>/// @Name        SET_FIELDS_NULL
72643>>>>>>>>>>>/// @Description This command is used to specify how to store blank or zero
72643>>>>>>>>>>>/// values in the database. Since database can sometimes store these value,
72643>>>>>>>>>>>/// i.e. '' or 0, as null, using this command can be useful in managing that.
72643>>>>>>>>>>>/// When set to true, any value in a column of the given type considered blank
72643>>>>>>>>>>>/// or 0 will be stored as null in the database. Setting it to false will cause
72643>>>>>>>>>>>/// the server to save as it normally would. Note that this command is used to
72643>>>>>>>>>>>/// set specific data types only, it can not effect all types at once. Below is
72643>>>>>>>>>>>/// a list of value that would be considered blank/zero values.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// DF_BCD -                                    0 (zero)
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
72643>>>>>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
72643>>>>>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// DF_BINARY -                                 0X0
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Assumptions
72643>>>>>>>>>>>/// @Status      Public
72643>>>>>>>>>>>/// @Drivers     All
72643>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
72643>>>>>>>>>>>/// @See                 GET_FIELDS_NULL SET_FIELDS_NOT_NULL
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Syntax SET_FIELDS_NULL {datatype} to {variable}
72643>>>>>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
72643>>>>>>>>>>>/// @Param variable             Boolean to indicate how to handle blank data
72643>>>>>>>>>>>
72643>>>>>>>>>>>
72643>>>>>>>>>>>//=============================================================================
72643>>>>>>>>>>>/// @Name        GET_FIELDS_NULL
72643>>>>>>>>>>>/// @Description This command will return the value of SET_FIELDS_NULL for
72643>>>>>>>>>>>/// the specified data type.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Assumptions
72643>>>>>>>>>>>/// @Status      Public
72643>>>>>>>>>>>/// @Drivers     All
72643>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
72643>>>>>>>>>>>/// @See                 SET_FIELDS_NULL SET_FIELDS_NOT_NULL
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Syntax GET_FIELDS_NULL {datatype} to {variable}
72643>>>>>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
72643>>>>>>>>>>>/// @Param variable             Variable to hold the value of SET_FIELDS_NULL
72643>>>>>>>>>>>
72643>>>>>>>>>>>
72643>>>>>>>>>>>//=============================================================================
72643>>>>>>>>>>>/// @Name        STRUCTURE_START_DYNAMIC
72643>>>>>>>>>>>/// @Description This command is used when scripting structural changes.
72643>>>>>>>>>>>/// It is the same as using ENABLE_SCRIPTING and Structure_Start separately.
72643>>>>>>>>>>>/// It allows structural changes to be compiled and tested without
72643>>>>>>>>>>>/// actually making any of the changes. Any table restructuring done
72643>>>>>>>>>>>/// between this command and STRUCTURE_END_DYNAMIC will not actually be
72643>>>>>>>>>>>/// committed but will instead create a mock INT file. The script and
72643>>>>>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Assumptions
72643>>>>>>>>>>>/// @Status      Deprecated
72643>>>>>>>>>>>/// @Drivers     All
72643>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72643>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
72643>>>>>>>>>>>/// @Param FileNumber                   The number of the file
72643>>>>>>>>>>>
72643>>>>>>>>>>>//=============================================================================
72643>>>>>>>>>>>/// @Name        STRUCTURE_END_DYNAMIC
72643>>>>>>>>>>>/// @Description This command ends the scripting started by
72643>>>>>>>>>>>/// STRUCTURE_START_DYNAMIC. It is the same as calling Structure_End
72643>>>>>>>>>>>/// and DISABLE_SCRIPTING separately.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Assumptions
72643>>>>>>>>>>>/// @Status      Deprecated
72643>>>>>>>>>>>/// @Drivers     All
72643>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72643>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
72643>>>>>>>>>>>/// @Param FileNumber                   The number of the file
72643>>>>>>>>>>>
72643>>>>>>>>>>>//=============================================================================
72643>>>>>>>>>>>/// @Name        SQLSERVER_ATTACH_DB
72643>>>>>>>>>>>/// @Description Attachs an MS SQL mdf to the current server instance. If
72643>>>>>>>>>>>/// the passed database is already attached, no error is generated.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// The SQLSERVER_ATTACH_DB command is intended for use with our new support
72643>>>>>>>>>>>/// of Microsoft LocalDB's.  When using LocalDB's a common use case might be
72643>>>>>>>>>>>/// to attach to a customer DB, do some work on it, and then detach this DB
72643>>>>>>>>>>>/// and attach to a different DB.  This was possible using stored procedures,
72643>>>>>>>>>>>/// but the code had some complexities that a developer need not worry about.
72643>>>>>>>>>>>/// When you attach a database, you must pass the database name, along with
72643>>>>>>>>>>>/// the path to an MDF file which contains the database.  Any associated LDF's
72643>>>>>>>>>>>/// (log files) and NDF's (secondary data files) must be in the same folder.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// If you call SQLSERVER_ATTACH_DB on a database that is already attached,
72643>>>>>>>>>>>/// no error will be generated.  After you call SQLSERVER_ATTACH_DB, you
72643>>>>>>>>>>>/// should call SET_DATABASE_NAME if you wish to make the attached database
72643>>>>>>>>>>>/// the currently selected database.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// SQLSERVER_ATTACH_DB will work on all supported version of SQL server.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Assumptions
72643>>>>>>>>>>>/// @Status      Public
72643>>>>>>>>>>>/// @Drivers     SQLFlex
72643>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 Aaron Gulack
72643>>>>>>>>>>>/// @See
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Syntax SQLSERVER_ATTACH_DB {database} on {filePath}
72643>>>>>>>>>>>/// @Param database                     Name of the database
72643>>>>>>>>>>>/// @Param filePath                     Path of the MDF file
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Example
72643>>>>>>>>>>>/// SQLSERVER_ATTACH_DB "MTSample" ON "C:\Mertech\Data\SampleDb.mdf"
72643>>>>>>>>>>>
72643>>>>>>>>>>>//=============================================================================
72643>>>>>>>>>>>/// @Name        SQLSERVER_DETACH_DB
72643>>>>>>>>>>>/// @Description The SQLSERVER_DETACH_DB command is intended for use with our
72643>>>>>>>>>>>/// new support of Microsoft LocalDB's.  When using LocalDB's a common use
72643>>>>>>>>>>>/// case might be to attach to a customer DB, do some work on it, and then
72643>>>>>>>>>>>/// detach this DB and attach to a different DB.  This was possible using
72643>>>>>>>>>>>/// stored procedures, but the code had some complexities that a developer
72643>>>>>>>>>>>/// need not worry about.  A detach can only be done if the database passed
72643>>>>>>>>>>>/// has no open connections.  As part of the detach process, the command
72643>>>>>>>>>>>/// closes ALL open files (even those not associated with this database or
72643>>>>>>>>>>>/// driver).
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// NOTE: SQLSERVER_DETACH_DB will often fail to execute if you are testing
72643>>>>>>>>>>>/// your application from the studio.  This is because the studio itself
72643>>>>>>>>>>>/// normally has open connections to the database.  If you test your
72643>>>>>>>>>>>/// application outside of the studio and the studio is closed (and any
72643>>>>>>>>>>>/// other application or tools that access this database are closed) you
72643>>>>>>>>>>>/// can successfully detach the database.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Assumptions
72643>>>>>>>>>>>/// @Status      Public
72643>>>>>>>>>>>/// @Drivers     SQLFlex
72643>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72643>>>>>>>>>>>/// @See
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Syntax SQLSERVER_DETACH_DB {database}
72643>>>>>>>>>>>/// @Param database                     Name of the database
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Example
72643>>>>>>>>>>>/// SQLSERVER_DETACH_DB "TestDB"
72643>>>>>>>>>>>
72643>>>>>>>>>>>//=============================================================================
72643>>>>>>>>>>>/// @Name        SET_FIXED_FILE_RECORDS_USED
72643>>>>>>>>>>>/// @Description This command is used to set DF_FILE_RECORDS_USED to a
72643>>>>>>>>>>>/// fixed value. This can be useful because doing a SELECT COUNT(*) is
72643>>>>>>>>>>>/// a very expensive process to the server. Many applications do counts
72643>>>>>>>>>>>/// often and using this command can help cut down the server traffic.
72643>>>>>>>>>>>/// Sometimes when counts are used, an exact number is not necessary so
72643>>>>>>>>>>>/// a fixed value, updated occasionally can be used. By setting this
72643>>>>>>>>>>>/// command to 0 or greater, the value of DF_FILE_RECORDS_USED will be
72643>>>>>>>>>>>/// set to that specified value and the internal SELECT COUNT(*) will be
72643>>>>>>>>>>>/// suppressed. If this command is set to something less that zero,
72643>>>>>>>>>>>/// DF_FILE_RECORDS_USED will be dynamically calculated whenever it is
72643>>>>>>>>>>>/// called.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// The default value for this command is -1
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Assumptions
72643>>>>>>>>>>>/// @Status              Public
72643>>>>>>>>>>>/// @Drivers     All
72643>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72643>>>>>>>>>>>/// @See                 GET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Syntax SET_FIXED_FILE_RECORDS_USED to {variable}
72643>>>>>>>>>>>/// @Param variable                     Fixed value for DF_FILE_RECORDS_USED
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Example
72643>>>>>>>>>>>/// SET_FIXED_FILE_RECORDS_USED to 10000
72643>>>>>>>>>>>
72643>>>>>>>>>>>//=============================================================================
72643>>>>>>>>>>>/// @Name        GET_FIXED_FILE_RECORDS_USED
72643>>>>>>>>>>>/// @Description This command returns the value of DF_FILE_RECORDS_USED
72643>>>>>>>>>>>/// if it has been set to a fixed value by SET_FIXED_FILE_RECORDS_USED.
72643>>>>>>>>>>>/// If anything greater than or equal to 0 is returned then that is the
72643>>>>>>>>>>>/// fixed value returned by any SELECT COUNT(*) statements, internal or
72643>>>>>>>>>>>/// not. If something less than zero is returned, then DF_FILE_RECORDS_USED
72643>>>>>>>>>>>/// returns a dynamic count whenever it is called.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// By default the value of this is -1
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Assumptions
72643>>>>>>>>>>>/// @Status              Public
72643>>>>>>>>>>>/// @Drivers     All
72643>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72643>>>>>>>>>>>/// @See                 SET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Syntax GET_FILE_RECORDS_USED to {variable}
72643>>>>>>>>>>>/// @Param variable                     Variable to hold the fixed value
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Example
72643>>>>>>>>>>>/// GET_FIXED_FILE_RECORDS_USED to iRecords
72643>>>>>>>>>>>
72643>>>>>>>>>>>//=============================================================================
72643>>>>>>>>>>>/// @Name        SUPPRESS_SELECT_COUNT
72643>>>>>>>>>>>/// @Description This command sets the value of DF_FILE_RECORDS_USED to
72643>>>>>>>>>>>/// a fixed value of zero. That way anytime a SELECT COUNT(*) is done,
72643>>>>>>>>>>>/// zero is returned, cutting down on server traffic. This is the same
72643>>>>>>>>>>>/// as setting SET_FIXED_FILE_RECORDS_USED to 0.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Assumptions
72643>>>>>>>>>>>/// @Status      Public
72643>>>>>>>>>>>/// @Drivers     All
72643>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72643>>>>>>>>>>>/// @See                 UNSUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Syntax SUPPRESS_SELECT_COUNT
72643>>>>>>>>>>>
72643>>>>>>>>>>>//=============================================================================
72643>>>>>>>>>>>/// @Name        UNSUPPRESS_SELECT_COUNT
72643>>>>>>>>>>>/// @Description This command resets the value of DF_FILE_RECORDS_USED to
72643>>>>>>>>>>>/// -1. That way anytime a SELECT COUNT(*) is done, it returns the actual
72643>>>>>>>>>>>/// count of records. This is the same as setting SET_FIXED_FILE_RECORDS_USED
72643>>>>>>>>>>>/// to -1.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Assumptions
72643>>>>>>>>>>>/// @Status      Public
72643>>>>>>>>>>>/// @Drivers     All
72643>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
72643>>>>>>>>>>>/// @See                 SUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Syntax UNSUPPRESS_SELECT_COUNT
72643>>>>>>>>>>>
72643>>>>>>>>>>>//=============================================================================
72643>>>>>>>>>>>/// @Name        SET_CONNECTION_OPTION
72643>>>>>>>>>>>/// @Description This command sets options that are used for the next login call.
72643>>>>>>>>>>>/// Because of this, it should be used after calling load_driver but before
72643>>>>>>>>>>>/// calling Login in most cases. Only options that are not used internally by
72643>>>>>>>>>>>/// the driver can be set using this command. Connection options that CANNOT be
72643>>>>>>>>>>>/// set: Database, Server, FailoverPartner, MarsConn, uid, pwd, Trusted_Connection,
72643>>>>>>>>>>>/// wsid, app, AutoTranslate, Timeout.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Assumptions
72643>>>>>>>>>>>/// @Status      Public
72643>>>>>>>>>>>/// @Drivers     SQLFlex
72643>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
72643>>>>>>>>>>>/// @See         Get_Connection_Option, Clear_Connection_Option
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Syntax SET_CONNECTION_OPTION {option} to {value}
72643>>>>>>>>>>>/// @Param option         The connection option to set
72643>>>>>>>>>>>/// @Param value          The value to set the connection option to.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Example
72643>>>>>>>>>>>/// LOAD_DRIVER "SQL_DRV"
72643>>>>>>>>>>>/// SET_CONNECTION_OPTION "ApplicationIntent" to "ReadOnly"
72643>>>>>>>>>>>/// LOGIN "localhost/sqlexpress01" "" "" "sql_drv"
72643>>>>>>>>>>>
72643>>>>>>>>>>>//=============================================================================
72643>>>>>>>>>>>/// @Name        GET_CONNECTION_OPTION
72643>>>>>>>>>>>/// @Description This command gets the value of a connection option that was set
72643>>>>>>>>>>>/// using SET_CONNECTION_OPTION. Only options that are not used internally by
72643>>>>>>>>>>>/// the driver can be retrieved using this command. Connection options that CANNOT be
72643>>>>>>>>>>>/// retrieved: Database, Server, FailoverPartner, MarsConn, uid, pwd,
72643>>>>>>>>>>>/// Trusted_Connection, wsid, app, AutoTranslate, Timeout.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Assumptions
72643>>>>>>>>>>>/// @Status      Public
72643>>>>>>>>>>>/// @Drivers     SQLFlex
72643>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
72643>>>>>>>>>>>/// @See         Set_Connection_Option, Clear_Connection_Option
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Syntax GET_CONNECTION_OPTION {option} to {variable}
72643>>>>>>>>>>>/// @Param option         The connection option to get
72643>>>>>>>>>>>/// @Param value          A variable to hold the retrieved value of the connection option.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Example
72643>>>>>>>>>>>/// GET_CONNECTION_OPTION "ApplicationIntent" to sVal
72643>>>>>>>>>>>
72643>>>>>>>>>>>//=============================================================================
72643>>>>>>>>>>>/// @Name        CLEAR_CONNECTION_OPTION
72643>>>>>>>>>>>/// @Description This command will clear any or all connections options that
72643>>>>>>>>>>>/// were set using SET_CONNECTION_OPTION. Passing the keyword ALL will remove
72643>>>>>>>>>>>/// all custom set connection options while passing a string value will clear
72643>>>>>>>>>>>/// just that option passed for the next login call. Connection options that
72643>>>>>>>>>>>/// CANNOT be cleared: Database, Server, FailoverPartner, MarsConn, uid, pwd,
72643>>>>>>>>>>>/// Trusted_Connection, wsid, app, AutoTranslate, Timeout.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Assumptions
72643>>>>>>>>>>>/// @Status      Public
72643>>>>>>>>>>>/// @Drivers     SQLFlex
72643>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
72643>>>>>>>>>>>/// @See         Set_Connection_Option, Get_Connection_Option
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Syntax CLEAR_CONNECTION_OPTION ALL | {option}
72643>>>>>>>>>>>/// @Param option         The connection option to clear
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Example
72643>>>>>>>>>>>/// CLEAR_CONNECTION_OPTION "ApplicationIntent"
72643>>>>>>>>>>>
72643>>>>>>>>>>>
72643>>>>>>>>>>>///
72643>>>>>>>>>>>// Private:
72643>>>>>>>>>>>// Get the filenumber of a file.field parameter
72643>>>>>>>>>>>//
72643>>>>>>>>>>>
72643>>>>>>>>>>>///
72643>>>>>>>>>>>// Private:
72643>>>>>>>>>>>// Get the fieldnumber of a file.field parameter
72643>>>>>>>>>>>//
72643>>>>>>>>>>>
72643>>>>>>>>>>>
72643>>>>>>>>>>>
72643>>>>>>>>>>>
72643>>>>>>>>>>>//
72643>>>>>>>>>>>// Minimum required DataFlex version for new LOB support below is VDF 4
72643>>>>>>>>>>>//
72643>>>>>>>>>>>
72643>>>>>>>>>>>TYPE tMertechLOB_Args
72643>>>>>>>>>>>    FIELD tMertechLOB_Args.cbSize       AS WORD          // always the size of the structure (verification + versioning)
72643>>>>>>>>>>>    FIELD tMertechLOB_Args.nField       AS DWORD         // always the field number
72643>>>>>>>>>>>    FIELD tMertechLOB_Args.pszData      AS POINTER
72643>>>>>>>>>>>    FIELD tMertechLOB_Args.nSize        AS DWORD
72643>>>>>>>>>>>    FIELD tMertechLOB_Args.nOffset      AS POINTER
72643>>>>>>>>>>>END_TYPE
72643>>>>>>>>>>>
72643>>>>>>>>>>>//=============================================================================
72643>>>>>>>>>>>/// @Name        SQL_GET_DATA_CHUNK_EX
72643>>>>>>>>>>>/// @Description This command is used to get a chunk of data from a column
72643>>>>>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
72643>>>>>>>>>>>/// and the offset number, the chunk will be put into the specified variable.
72643>>>>>>>>>>>/// To specify how big of a chunk to get, use the SQL_SET_CHUNK_SIZE command.
72643>>>>>>>>>>>/// Otherwise the maximum length will be retrieved. An optional variable can
72643>>>>>>>>>>>/// also be passed which will store the length of the chunk. Note that unlike
72643>>>>>>>>>>>/// LOB_READ, this command works for any column type, not just LOB columns.
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Assumptions
72643>>>>>>>>>>>/// @Status      Public
72643>>>>>>>>>>>/// @Drivers     SQLFlex
72643>>>>>>>>>>>/// @VersionNote Last Revised: 2016-04-27 by Oliver Nelson
72643>>>>>>>>>>>/// @See         SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE SQL_GET_COLUMN_DATA_SIZE
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Syntax SQL_GET_DATA_CHUNK COLUMN {column} OFFSET {offset} to {variable} {length}
72643>>>>>>>>>>>/// @Param column               Column number to get chunk from
72643>>>>>>>>>>>/// @Param offset               Offset to start at for the chunk
72643>>>>>>>>>>>/// @Param variable             Variable to hold the returned chunk
72643>>>>>>>>>>>/// @Param length               Variable to hold the size of the returned chunk
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// @Example
72643>>>>>>>>>>>/// SQL_SET_MAX_DATA_SIZE to |CI$4000000 //(64MB)
72643>>>>>>>>>>>/// move |CI$80000 to iChunkSize // 512KB
72643>>>>>>>>>>>/// SQL_SET_CHUNK_SIZE to iChunkSize
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
72643>>>>>>>>>>>/// SQL_PREPARE_STMT
72643>>>>>>>>>>>/// SQL_EXECUTE_STMT
72643>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
72643>>>>>>>>>>>/// If (Found) Begin
72643>>>>>>>>>>>///     SQL_GET_COLUMN_DATA_SIZE COLUMN 6 to iDataSize
72643>>>>>>>>>>>///
72643>>>>>>>>>>>///     Repeat
72643>>>>>>>>>>>///         SQL_GET_DATA_CHUNK COLUMN 6 OFFSET iProgress to sChunk
72643>>>>>>>>>>>///         ADD iChunkSize to iProgress
72643>>>>>>>>>>>///         write sChunk
72643>>>>>>>>>>>///     until (iProgress >= iDataSize)
72643>>>>>>>>>>>///
72643>>>>>>>>>>>/// End
72643>>>>>>>>>>>
72643>>>>>>>>>>>
72643>>>>>>>>>>>Function MertechInc_SQL_GET_DATA_CHUNK_EX Global Integer iColumn Integer iOffset Returns String
72645>>>>>>>>>>>    Local String sLOB_Args
72645>>>>>>>>>>>    Local String sData
72645>>>>>>>>>>>    Local Integer iSize
72645>>>>>>>>>>>
72645>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iSize MertechInc_Blank 1 RESULT MertechInc_iRet
72650>>>>>>>>>>>
72650>>>>>>>>>>>    Move "" to sData
72651>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
72652>>>>>>>>>>>    // First move the size of the structure to the Structure
72652>>>>>>>>>>>    Put tMertechLOB_Args_size  to sLOB_Args at tMertechLOB_Args.cbSize
72653>>>>>>>>>>>    Put iColumn                to sLOB_Args at tMertechLOB_Args.nField
72654>>>>>>>>>>>    Put iOffset                to sLOB_Args at tMertechLOB_Args.nOffset
72655>>>>>>>>>>>    Put iSize                  to sLOB_Args at tMertechLOB_Args.nSize
72656>>>>>>>>>>>
72656>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK_EX CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
72661>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to iSize
72662>>>>>>>>>>>
72662>>>>>>>>>>>    If iSize GT 0 Begin
72664>>>>>>>>>>>        Move (Repeat(Character(0), iSize)) to sData
72665>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
72666>>>>>>>>>>>        Put iSize              to sLOB_Args at tMertechLOB_Args.nSize
72667>>>>>>>>>>>        Put iOffset            to sLOB_Args at tMertechLOB_Args.nOffset
72668>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK_EX CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
72673>>>>>>>>>>>        GetBuff from sLOB_Args at tMertechLOB_Args.nSize to iSize
72674>>>>>>>>>>>    End
72674>>>>>>>>>>>>
72674>>>>>>>>>>>    Else Begin
72675>>>>>>>>>>>        Move "" to sData
72676>>>>>>>>>>>    End
72676>>>>>>>>>>>>
72676>>>>>>>>>>>    Function_Return sData
72677>>>>>>>>>>>End_Function // MertechInc_SQL_GET_DATA_CHUNK_EX
72678>>>>>>>>>>>
72678>>>>>>>>>>>//=============================================================================
72678>>>>>>>>>>>/// @Name        SQL_GET_COLUMN_DATA_SIZE
72678>>>>>>>>>>>/// @Description This command is used to get the size of the data in a column
72678>>>>>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
72678>>>>>>>>>>>/// the size of the data in the column will be put into the specified variable.
72678>>>>>>>>>>>/// The size returned will be the smaller of the actual size of the data or
72678>>>>>>>>>>>/// the SQL_SET_MAX_DATA_SIZE setting. So for instance, if the data stored in
72678>>>>>>>>>>>/// a column is 64MB, but the SQL_SET_MAX_DATA_SIZE is set to 16MB, then this
72678>>>>>>>>>>>/// command will return 16MB. Note that you may need to use Set_Argument_Size
72678>>>>>>>>>>>/// to allow for a large chunk size because the default maximum string size
72678>>>>>>>>>>>/// in most modern dataflex versions is only 64KB.
72678>>>>>>>>>>>///
72678>>>>>>>>>>>/// @Assumptions
72678>>>>>>>>>>>/// @Status      Public
72678>>>>>>>>>>>/// @Drivers     SQLFlex
72678>>>>>>>>>>>/// @VersionNote Last Revised: 2016-04-27 Oliver Nelson
72678>>>>>>>>>>>/// @See         SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK_EX SQL_SET_MAX_DATA_SIZE
72678>>>>>>>>>>>///
72678>>>>>>>>>>>/// @Syntax SQL_GET_COLUMN_DATA_SIZE COLUMN {column} to {variable}
72678>>>>>>>>>>>/// @Param column               Column number to get chunk from
72678>>>>>>>>>>>/// @Param variable             Variable to hold the returned data size
72678>>>>>>>>>>>///
72678>>>>>>>>>>>/// @Example
72678>>>>>>>>>>>/// SQL_SET_MAX_DATA_SIZE to |CI$4000000 //(64MB)
72678>>>>>>>>>>>/// move |CI$80000 to iChunkSize // 512KB
72678>>>>>>>>>>>/// SQL_SET_CHUNK_SIZE to iChunkSize
72678>>>>>>>>>>>///
72678>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
72678>>>>>>>>>>>/// SQL_PREPARE_STMT
72678>>>>>>>>>>>/// SQL_EXECUTE_STMT
72678>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
72678>>>>>>>>>>>/// If (Found) Begin
72678>>>>>>>>>>>///     SQL_GET_COLUMN_DATA_SIZE COLUMN 6 to iDataSize
72678>>>>>>>>>>>///
72678>>>>>>>>>>>///     Repeat
72678>>>>>>>>>>>///         SQL_GET_DATA_CHUNK COLUMN 6 OFFSET iProgress to sChunk
72678>>>>>>>>>>>///         ADD iChunkSize to iProgress
72678>>>>>>>>>>>///         write sChunk
72678>>>>>>>>>>>///     until (iProgress >= iDataSize)
72678>>>>>>>>>>>///
72678>>>>>>>>>>>/// End
72678>>>>>>>>>>>
72678>>>>>>>>>>>
72678>>>>>>>>>>>Function MertechInc_SQL_GET_COLUMN_DATA_SIZE Global Integer iColumn Returns Integer
72680>>>>>>>>>>>    Local String sLOB_Args
72680>>>>>>>>>>>    Local String sData
72680>>>>>>>>>>>    Local Integer iSize
72680>>>>>>>>>>>
72680>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
72681>>>>>>>>>>>    // First move the size of the structure to the Structure
72681>>>>>>>>>>>    Put tMertechLOB_Args_size  to sLOB_Args at tMertechLOB_Args.cbSize
72682>>>>>>>>>>>    Put iColumn                to sLOB_Args at tMertechLOB_Args.nField
72683>>>>>>>>>>>    Put 0                      to sLOB_Args at tMertechLOB_Args.nOffset
72684>>>>>>>>>>>    Put |CI$7FFFFFFF           to sLOB_Args at tMertechLOB_Args.nSize
72685>>>>>>>>>>>
72685>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK_EX CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
72690>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to iSize
72691>>>>>>>>>>>
72691>>>>>>>>>>>    Function_Return iSize
72692>>>>>>>>>>>End_Function // MertechInc_SQL_GET_COLUMN_DATA_SIZE
72693>>>>>>>>>>>
72693>>>>>>>>>>>//=============================================================================
72693>>>>>>>>>>>/// @Name        SQL_SET_LOB
72693>>>>>>>>>>>/// @Description This command replaces whatever is currently in a LOB Field
72693>>>>>>>>>>>/// with the data passed. It writes to a client side buffer. It can be used
72693>>>>>>>>>>>/// to Write an arbitrary amount of data into a LOB.
72693>>>>>>>>>>>/// If passed an empty String, it will remove all the contents of the LOB.
72693>>>>>>>>>>>/// If you wish to Set a LOB back to NULL, please use the SQL_SET_LOB_NULL
72693>>>>>>>>>>>/// command.
72693>>>>>>>>>>>/// NOTE: Unlike the previous call LOB_WRITE, this call does not
72693>>>>>>>>>>>/// perform the Save. This must be done separately.
72693>>>>>>>>>>>///
72693>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
72693>>>>>>>>>>>/// @Status      Public
72693>>>>>>>>>>>/// @Drivers     All
72693>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
72693>>>>>>>>>>>/// @See                 SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
72693>>>>>>>>>>>///
72693>>>>>>>>>>>/// @Syntax             SQL_SET_LOB {FileName.FieldName} to {variable}
72693>>>>>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
72693>>>>>>>>>>>/// @Param              FieldName               The name of the LOB field being set
72693>>>>>>>>>>>/// @Param              variable                The variable to use to set the field's value
72693>>>>>>>>>>>///
72693>>>>>>>>>>>/// @Example
72693>>>>>>>>>>>/// Set_Argument_Size 262144
72693>>>>>>>>>>>/// String sLine
72693>>>>>>>>>>>///
72693>>>>>>>>>>>/// Clear Customer
72693>>>>>>>>>>>///    Move iID to Customer.ID
72693>>>>>>>>>>>/// Find Eq Customer by Index.1
72693>>>>>>>>>>>/// If (Found) Begin
72693>>>>>>>>>>>///    Direct_Input "C:\bigFile.xml"
72693>>>>>>>>>>>///    Reread Customer
72693>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
72693>>>>>>>>>>>///       Read_Block sLine 262144
72693>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
72693>>>>>>>>>>>///       While (not(SeqEof))
72693>>>>>>>>>>>///          Read_Block sLine 262144
72693>>>>>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
72693>>>>>>>>>>>///       Loop
72693>>>>>>>>>>>///    Saverecord Customer
72693>>>>>>>>>>>///    Unlock
72693>>>>>>>>>>>///    Close_Input
72693>>>>>>>>>>>/// End
72693>>>>>>>>>>>
72693>>>>>>>>>>>Procedure MertechInc_SQL_SET_LOB Global String sDriver Integer iFile Integer iField String sData
72695>>>>>>>>>>>    String sLOB_Args       // can drop local command if minimum vdf version is 6
72695>>>>>>>>>>>
72695>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
72696>>>>>>>>>>>    // First move the size of the structure to the Structure
72696>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
72697>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
72698>>>>>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
72699>>>>>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
72700>>>>>>>>>>>
72700>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_WRITE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
72705>>>>>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB
72706>>>>>>>>>>>
72706>>>>>>>>>>>//=============================================================================
72706>>>>>>>>>>>/// @Name        SQL_ADD_LOB_CHUNK
72706>>>>>>>>>>>/// @Description This command is used to add additional chunks to the buffer
72706>>>>>>>>>>>/// before saving the record. After SQL_SET_LOB has been called
72706>>>>>>>>>>>/// SQL_ADD_LOB_CHUNK can be called as many times as needed to add additional
72706>>>>>>>>>>>/// chunks of data before a save. It can also be called independent of
72706>>>>>>>>>>>/// SQL_SET_LOB to append data to an existing LOB column.
72706>>>>>>>>>>>/// NOTE: Unlike the previous call LOB_APPEND, this call does not perform
72706>>>>>>>>>>>/// the save. This must be done separately.
72706>>>>>>>>>>>///
72706>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
72706>>>>>>>>>>>/// @Status      Public
72706>>>>>>>>>>>/// @Drivers     All
72706>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
72706>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
72706>>>>>>>>>>>///
72706>>>>>>>>>>>/// @Syntax             SQL_ADD_LOB_CHUNK {FileName.FieldName} to {variable}
72706>>>>>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
72706>>>>>>>>>>>/// @Param              FieldName               The name of the LOB field being set
72706>>>>>>>>>>>/// @Param              variable                The variable to add as the LOB chunk
72706>>>>>>>>>>>///
72706>>>>>>>>>>>/// @Example
72706>>>>>>>>>>>/// Set_Argument_Size 262144
72706>>>>>>>>>>>/// String sLine
72706>>>>>>>>>>>///
72706>>>>>>>>>>>/// Clear Customer
72706>>>>>>>>>>>///    Move iID to Customer.ID
72706>>>>>>>>>>>/// Find Eq Customer by Index.1
72706>>>>>>>>>>>/// If (Found) Begin
72706>>>>>>>>>>>///    Direct_Input "C:\bigFile.xml"
72706>>>>>>>>>>>///    Reread Customer
72706>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
72706>>>>>>>>>>>///       Read_Block sLine 262144
72706>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
72706>>>>>>>>>>>///       While (not(SeqEof))
72706>>>>>>>>>>>///          Read_Block sLine 262144
72706>>>>>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
72706>>>>>>>>>>>///       Loop
72706>>>>>>>>>>>///    Saverecord Customer
72706>>>>>>>>>>>///    Unlock
72706>>>>>>>>>>>///    Close_Input
72706>>>>>>>>>>>/// End
72706>>>>>>>>>>>
72706>>>>>>>>>>>Procedure MertechInc_SQL_ADD_LOB_CHUNK Global String sDriver Integer iFile Integer iField String sData
72708>>>>>>>>>>>    String sLOB_Args
72708>>>>>>>>>>>
72708>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
72709>>>>>>>>>>>    // First move the size of the structure to the Structure
72709>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
72710>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
72711>>>>>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
72712>>>>>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
72713>>>>>>>>>>>
72713>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_APPEND CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
72718>>>>>>>>>>>end_procedure // MertechInc_SQL_ADD_LOB_CHUNK
72719>>>>>>>>>>>
72719>>>>>>>>>>>//=============================================================================
72719>>>>>>>>>>>/// @Name        SQL_GET_LOB
72719>>>>>>>>>>>/// @Description This command is used for getting the value of a specified LOB
72719>>>>>>>>>>>/// field. Two optional parameters can be passed specifying the offset and
72719>>>>>>>>>>>/// length of the chunk to get. Passing these parameters essentially makes this
72719>>>>>>>>>>>/// call the same as SQL_GET_LOB_CHUNK.
72719>>>>>>>>>>>/// Depending on the situation, the two calls can be interchanged for improved
72719>>>>>>>>>>>/// code readability. Excluding these additional parameters will get the whole
72719>>>>>>>>>>>/// field value within DataFlex variable size limits.
72719>>>>>>>>>>>///
72719>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
72719>>>>>>>>>>>/// @Status      Public
72719>>>>>>>>>>>/// @Drivers     All
72719>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
72719>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
72719>>>>>>>>>>>///
72719>>>>>>>>>>>/// @Syntax     SQL_GET_LOB {FileName.FieldName} TO {variable} [ OFFSET {offset} LENGTH {length} ]
72719>>>>>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
72719>>>>>>>>>>>/// @Param              FieldName                       The name of the LOB field
72719>>>>>>>>>>>/// @Param              variable                        The variable to hold the LOB value
72719>>>>>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB value (optional)
72719>>>>>>>>>>>/// @Param              length                          Length of value to get from the LOB field (optional)
72719>>>>>>>>>>>///
72719>>>>>>>>>>>/// @Example
72719>>>>>>>>>>>/// Set_Argument_Size 262144
72719>>>>>>>>>>>/// String sResult
72719>>>>>>>>>>>///
72719>>>>>>>>>>>/// Move 262144 to iChunkSize
72719>>>>>>>>>>>/// Move 0      to iChunk
72719>>>>>>>>>>>///
72719>>>>>>>>>>>/// Clear Customer
72719>>>>>>>>>>>///    Move iID to Customer.ID
72719>>>>>>>>>>>/// Find Eq Customer by Index.1
72719>>>>>>>>>>>/// If (Found) Begin
72719>>>>>>>>>>>///    Direct_Output ('Binary:' + sDestFileName)
72719>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
72719>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
72719>>>>>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
72719>>>>>>>>>>>///       Write sResult
72719>>>>>>>>>>>///       Increment iChunk
72719>>>>>>>>>>>///    Loop
72719>>>>>>>>>>>///    Close_Output
72719>>>>>>>>>>>/// End
72719>>>>>>>>>>>
72719>>>>>>>>>>>
72719>>>>>>>>>>>Function MertechInc_SQL_GET_LOB Global String sDriver Integer iFile Integer iField Integer iOffset Integer iLength Returns String
72721>>>>>>>>>>>    String sLOB_Args
72721>>>>>>>>>>>    String sData
72721>>>>>>>>>>>    DWord  nSize
72721>>>>>>>>>>>
72721>>>>>>>>>>>    Move "" To sData
72722>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
72723>>>>>>>>>>>    // First move the size of the structure to the Structure
72723>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
72724>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
72725>>>>>>>>>>>
72725>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
72730>>>>>>>>>>>
72730>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
72731>>>>>>>>>>>    If (nSize > 0) Begin
72733>>>>>>>>>>>      If (iOffset=0 and iLength=0) Begin
72735>>>>>>>>>>>        move (Repeat(Character(0), nSize)) to sData
72736>>>>>>>>>>>            //Send Assert (AddressOf(sData) <> 0) ("AddressOf(sData) is NULL") DFTrue
72736>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
72737>>>>>>>>>>>      End
72737>>>>>>>>>>>>
72737>>>>>>>>>>>      Else Begin
72738>>>>>>>>>>>        move (Repeat(Character(0), iLength)) to sData
72739>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
72740>>>>>>>>>>>        Put iLength            to sLOB_Args at tMertechLOB_Args.nSize
72741>>>>>>>>>>>        Put iOffset            to sLOB_Args at tMertechLOB_Args.nOffset
72742>>>>>>>>>>>      End
72742>>>>>>>>>>>>
72742>>>>>>>>>>>      Call_Driver iFile sDriver Function CALLDRV_LOB_EX_READ CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
72747>>>>>>>>>>>    End
72747>>>>>>>>>>>>
72747>>>>>>>>>>>    Else Begin
72748>>>>>>>>>>>        Move "" to sData
72749>>>>>>>>>>>    End
72749>>>>>>>>>>>>
72749>>>>>>>>>>>    Function_Return sData
72750>>>>>>>>>>>End_Function // MertechInc_SQL_GET_LOB
72751>>>>>>>>>>>
72751>>>>>>>>>>>//=============================================================================
72751>>>>>>>>>>>/// @Name        SQL_GET_LOB_CHUNK
72751>>>>>>>>>>>/// @Description This command is used for getting a chunk of data from a specified
72751>>>>>>>>>>>/// LOB field. The difference between this command and SQL_GET_LOB is only that
72751>>>>>>>>>>>/// the parameters OFFSET and LENGTH are not optional when using this command.
72751>>>>>>>>>>>/// You may consider using this command to retrieve small portions of a very
72751>>>>>>>>>>>/// large BLOB so as to reduce memory usage.
72751>>>>>>>>>>>///
72751>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
72751>>>>>>>>>>>/// @Status      Public
72751>>>>>>>>>>>/// @Drivers     All
72751>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
72751>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
72751>>>>>>>>>>>///
72751>>>>>>>>>>>/// @Syntax     SQL_GET_LOB_CHUNK {FileName.FieldName} TO {variable} OFFSET {offset} LENGTH {length}
72751>>>>>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
72751>>>>>>>>>>>/// @Param              FieldName                       The name of the LOB field
72751>>>>>>>>>>>/// @Param              variable                        The variable to hold the LOB chunk
72751>>>>>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB chunk
72751>>>>>>>>>>>/// @Param              length                          Length of chunk to get from the LOB field
72751>>>>>>>>>>>///
72751>>>>>>>>>>>/// @Example
72751>>>>>>>>>>>/// Set_Argument_Size 262144
72751>>>>>>>>>>>/// String sResult
72751>>>>>>>>>>>///
72751>>>>>>>>>>>/// Move 262144 to iChunkSize
72751>>>>>>>>>>>/// Move 0      to iChunk
72751>>>>>>>>>>>///
72751>>>>>>>>>>>/// Clear Customer
72751>>>>>>>>>>>///    Move iID to Customer.ID
72751>>>>>>>>>>>/// Find Eq Customer by Index.1
72751>>>>>>>>>>>/// If (Found) Begin
72751>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
72751>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
72751>>>>>>>>>>>///       SQL_GET_LOB_CHUNK Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
72751>>>>>>>>>>>///       // Do something with the LOB data
72751>>>>>>>>>>>///       Increment iChunk
72751>>>>>>>>>>>///    Loop
72751>>>>>>>>>>>/// End
72751>>>>>>>>>>>
72751>>>>>>>>>>>//=============================================================================
72751>>>>>>>>>>>/// @Name        SQL_GET_LOB_LENGTH
72751>>>>>>>>>>>/// @Description This command is used to get the length of a specified LOB field.
72751>>>>>>>>>>>/// It is useful, for example, in determining the number of iterations to
72751>>>>>>>>>>>/// perform while reading from a LOB field using chunking.
72751>>>>>>>>>>>///
72751>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
72751>>>>>>>>>>>/// @Status      Public
72751>>>>>>>>>>>/// @Drivers     All
72751>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
72751>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
72751>>>>>>>>>>>///
72751>>>>>>>>>>>/// @Syntax             SQL_GET_LOB_LENGTH {FileName.FieldName} to {variable}
72751>>>>>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
72751>>>>>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
72751>>>>>>>>>>>/// @Param              variable                        The variable to hold the length of the field
72751>>>>>>>>>>>///
72751>>>>>>>>>>>/// @Example
72751>>>>>>>>>>>/// Set_Argument_Size 262144
72751>>>>>>>>>>>/// String sResult
72751>>>>>>>>>>>///
72751>>>>>>>>>>>/// Move 16384 to iChunkSize
72751>>>>>>>>>>>/// Move 0     to iChunk
72751>>>>>>>>>>>///
72751>>>>>>>>>>>/// Clear Customer
72751>>>>>>>>>>>///    Move iID to Customer.ID
72751>>>>>>>>>>>/// Find Eq Customer by Index.1
72751>>>>>>>>>>>/// If (Found) Begin
72751>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
72751>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
72751>>>>>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
72751>>>>>>>>>>>///       // Do something with the LOB data
72751>>>>>>>>>>>///       Increment iChunk
72751>>>>>>>>>>>///    Loop
72751>>>>>>>>>>>/// End
72751>>>>>>>>>>>
72751>>>>>>>>>>>
72751>>>>>>>>>>>Function MertechInc_SQL_GET_LOB_LENGTH Global String sDriver Integer iFile Integer iField Returns Integer
72753>>>>>>>>>>>    String sLOB_Args
72753>>>>>>>>>>>    DWord  nSize
72753>>>>>>>>>>>
72753>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
72754>>>>>>>>>>>    // First move the size of the structure to the Structure
72754>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
72755>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
72756>>>>>>>>>>>
72756>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
72761>>>>>>>>>>>
72761>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
72762>>>>>>>>>>>    Function_Return nSize
72763>>>>>>>>>>>End_Function // MertechInc_SQL_GET_LOB_LENGTH
72764>>>>>>>>>>>
72764>>>>>>>>>>>//=============================================================================
72764>>>>>>>>>>>/// @Name        SQL_SET_LOB_NULL
72764>>>>>>>>>>>/// @Description This command is used to set a LOB column to null. Often
72764>>>>>>>>>>>/// LOB columns should either contain data or be null. A "blank" LOB column
72764>>>>>>>>>>>/// often doesn't appear empty in other environments, so settings it back to
72764>>>>>>>>>>>/// null is best.
72764>>>>>>>>>>>///
72764>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
72764>>>>>>>>>>>/// @Status      Public
72764>>>>>>>>>>>/// @Drivers     All
72764>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
72764>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
72764>>>>>>>>>>>///
72764>>>>>>>>>>>/// @Syntax             SQL_SET_LOB_NULL    {FileName.FieldName}
72764>>>>>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
72764>>>>>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
72764>>>>>>>>>>>///
72764>>>>>>>>>>>/// @Example
72764>>>>>>>>>>>////
72764>>>>>>>>>>>/// Clear Customer
72764>>>>>>>>>>>/// Move iID to Customer.ID
72764>>>>>>>>>>>/// Find Eq Customer by Index.1
72764>>>>>>>>>>>/// If (Found) Begin
72764>>>>>>>>>>>///    Reread Customer
72764>>>>>>>>>>>///        SQL_SET_LOB_NULL Customer.Comments
72764>>>>>>>>>>>///        Saverecord Customer
72764>>>>>>>>>>>///    Unlock
72764>>>>>>>>>>>/// End
72764>>>>>>>>>>>
72764>>>>>>>>>>>
72764>>>>>>>>>>>Procedure MertechInc_SQL_SET_LOB_NULL Global String sDriver Integer iFile Integer iField
72766>>>>>>>>>>>    String sLOB_Args
72766>>>>>>>>>>>
72766>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
72767>>>>>>>>>>>    // First move the size of the structure to the Structure
72767>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
72768>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
72769>>>>>>>>>>>
72769>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_SET_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
72774>>>>>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB_NULL
72775>>>>>>>>>>>
72775>>>>>>>>>>>
#REM ***********************************************
#REM MERTECH DATA SYSTEMS INC. - MERTECH.COM
#REM END OF MERTECH.INC
#REM ***********************************************
72775>>>>>>>>>>>//=============================================================================
72775>>>>>>>>>>>// End of Mertech.inc
72775>>>>>>>>>>>//=============================================================================
72775>>>>>>>>>Use cli.pkg
72775>>>>>>>>>Use ParseKeyWord.pkg
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
72775>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
72775>>>>>>>>>>>
72775>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
72777>>>>>>>>>>>    Integer iStart iEnd
72777>>>>>>>>>>>    String sRetval
72777>>>>>>>>>>>
72777>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
72778>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
72779>>>>>>>>>>>    If (iStart = 0) Begin
72781>>>>>>>>>>>        Function_Return ""
72782>>>>>>>>>>>    End
72782>>>>>>>>>>>>
72782>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
72783>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
72784>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
72786>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
72787>>>>>>>>>>>    End
72787>>>>>>>>>>>>
72787>>>>>>>>>>>    Else Begin
72788>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
72789>>>>>>>>>>>    End
72789>>>>>>>>>>>>
72789>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
72791>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
72792>>>>>>>>>>>        Decrement iEnd
72793>>>>>>>>>>>    End
72793>>>>>>>>>>>>
72793>>>>>>>>>>>    If (iEnd <> 0) Begin
72795>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
72796>>>>>>>>>>>    End
72796>>>>>>>>>>>>
72796>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
72797>>>>>>>>>>>
72797>>>>>>>>>>>    Function_Return (Trim(sRetval))
72798>>>>>>>>>>>End_Function
72799>>>>>>>>>>>
72799>>>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - WWW.MERTECHDATA.COM
#REM MERTECH.INC VERSION 1.0.3 FOR DATAFLEX UPDATE FRAMEWORK
#REM -----------------------------------------------
72799>>>>>>>>>
72799>>>>>>>>>Struct tCLIHandleMap
72799>>>>>>>>>    Integer iHdbc
72799>>>>>>>>>    String sDriver
72799>>>>>>>>>    String sConnect
72799>>>>>>>>>End_Struct
72799>>>>>>>>>
72799>>>>>>>>>Struct tColumnMap
72799>>>>>>>>>    Integer iFileNum
72799>>>>>>>>>    Variant[] vResultColumn
72799>>>>>>>>>End_Struct
72799>>>>>>>>>
72799>>>>>>>>>//*** Embedded SQL statement attribute constants
72799>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
72799>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
72799>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
72799>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
72799>>>>>>>>>
72799>>>>>>>>>//*** Embedded SQL column attribute constants
72799>>>>>>>>>Define SQLCOLATTRIB_SIZE           for 1
72799>>>>>>>>>Define SQLCOLATTRIB_LENGTH         for 1
72799>>>>>>>>>Define SQLCOLATTRIB_PRECISION      for 2
72799>>>>>>>>>Define SQLCOLATTRIB_LABEL          for 3
72799>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
72799>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
72799>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
72799>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
72799>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
72799>>>>>>>>>
72799>>>>>>>>>//*** Enforced DAC SQL.PKG Compatibility
72799>>>>>>>>>Define SQL_DAC_HIGH_COMPATABILITY for 1
72799>>>>>>>>>Define SQL_DAC_NORMAL_COMPATIBILITY  for 0
72799>>>>>>>>>
72799>>>>>>>>>Global_Variable Integer giSQLCompatibilityMode
72799>>>>>>>>>Move SQL_DAC_NORMAL_COMPATIBILITY to giSQLCompatibilityMode
72800>>>>>>>>>
72800>>>>>>>>>//*** Global object handle for the manager
72800>>>>>>>>>Global_Variable Handle _embsqlghoSQLHandleMngr
72800>>>>>>>>>Register_Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
72800>>>>>>>>>
72800>>>>>>>>>Class cSQLStatementDUF is a cObject
72801>>>>>>>>>    Procedure Construct_Object
72803>>>>>>>>>        Forward Send Construct_Object
72805>>>>>>>>>
72805>>>>>>>>>        Property Integer phCLIHandle      0
72806>>>>>>>>>        Property Integer piLastColumn     0
72807>>>>>>>>>        Property Integer piLastArgument   0
72808>>>>>>>>>        Property Integer piBindFile       0
72809>>>>>>>>>        Property Integer piCursorNum      0
72810>>>>>>>>>        Property Boolean pisBeforeFetch   True
72811>>>>>>>>>        Property Integer piParameterCount 0
72812>>>>>>>>>
72812>>>>>>>>>        Property Integer piDataChunkOffset 0
72813>>>>>>>>>        Property String psProcName ""
72814>>>>>>>>>        Property String psSchemaName ""
72815>>>>>>>>>        Property Variant[] pvParams
72816>>>>>>>>>        Property tColumnMap ptColumnMap
72817>>>>>>>>>    End_Procedure
72818>>>>>>>>>
72818>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns String
72820>>>>>>>>>        Integer hoCLIHandler
72820>>>>>>>>>        Date dDFDate
72820>>>>>>>>>
72820>>>>>>>>>        //*** Create a CLI handler object
72820>>>>>>>>>        Object oSQLDFCLIHandler is a cCLIHandler
72822>>>>>>>>>            Move Current_Object to hoCLIHandler
72823>>>>>>>>>        End_Object
72824>>>>>>>>>
72824>>>>>>>>>        //*** Convert the date
72824>>>>>>>>>        Get CLISQLDateToDFDate of hoCLIHandler (psDRiverID(Current_Object)) sSQLDate to dDFDate
72825>>>>>>>>>
72825>>>>>>>>>        //*** Destroy the object
72825>>>>>>>>>        Send Destroy_Object to hoCLIHandler
72826>>>>>>>>>
72826>>>>>>>>>        Function_Return dDFDate
72827>>>>>>>>>    End_Function
72828>>>>>>>>>
72828>>>>>>>>>    Function DFDateToSQLDate for cSQLStatementDUF Date dDFDate Returns String
72830>>>>>>>>>        Integer hoCLIHandler
72830>>>>>>>>>        String sSQLDate
72830>>>>>>>>>
72830>>>>>>>>>        //*** Create a CLI handler object
72830>>>>>>>>>        Object oDFSQLCLIHandler is a cCLIHandler
72832>>>>>>>>>            Move Current_Object to hoCLIHandler
72833>>>>>>>>>        End_Object
72834>>>>>>>>>
72834>>>>>>>>>        //*** Convert the date
72834>>>>>>>>>        Get CLIDFDateToSQLDate of hoCLIHandler (psDRiverID(Current_Object)) dDFDate to sSQLDate
72835>>>>>>>>>
72835>>>>>>>>>        //*** Destroy the object
72835>>>>>>>>>        Send Destroy_Object to hoCLIHandler
72836>>>>>>>>>
72836>>>>>>>>>        Function_Return sSQLDate
72837>>>>>>>>>    End_Function
72838>>>>>>>>>
72838>>>>>>>>>    Function IsProcedure String sFunctionName Returns Boolean
72840>>>>>>>>>        String sRoutineType
72840>>>>>>>>>
72840>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
72878>>>>>>>>>>
72878>>>>>>>>>
72878>>>>>>>>>        Case Begin
72878>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
72880>>>>>>>>>                sql_set_stmt to (SFormat("select type from master.sys.sysobjects where name = '%1' union all select type from sys.sysobjects where name = '%1'", sFunctionName))
72912>>>>>>>>>                sql_prepare_stmt
72961>>>>>>>>>                sql_execute_stmt
73001>>>>>>>>>
73001>>>>>>>>>                sql_fetch_next_row into sRoutineType
73176>>>>>>>>>                If (sRoutineType = "P") Begin
73178>>>>>>>>>                    Move "PROCEDURE" to sRoutineType
73179>>>>>>>>>                End
73179>>>>>>>>>>
73179>>>>>>>>>                Else Begin
73180>>>>>>>>>                    Move "FUNCTION" to sRoutineType
73181>>>>>>>>>                End
73181>>>>>>>>>>
73181>>>>>>>>>                Case Break
73182>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
73185>>>>>>>>>                sql_set_stmt to (SFormat("select routine_type from information_schema.routines where routine_name = '%1'", sFunctionName))
73217>>>>>>>>>                sql_prepare_stmt
73266>>>>>>>>>                sql_execute_stmt
73306>>>>>>>>>                sql_fetch_next_row into sRoutineType
73481>>>>>>>>>
73481>>>>>>>>>                Case Break
73482>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
73485>>>>>>>>>                sql_set_stmt  to (SFormat("SELECT object_type from all_objects where object_name = '%1'", sFunctionName))
73517>>>>>>>>>                sql_prepare_stmt
73566>>>>>>>>>                sql_execute_stmt
73606>>>>>>>>>                sql_fetch_next_row into sRoutineType
73781>>>>>>>>>
73781>>>>>>>>>                Case Break
73782>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
73785>>>>>>>>>                // Postgres doesn't differentiate between procedures and functions, so treat everything as procedures
73785>>>>>>>>>                // because that is better tested.
73785>>>>>>>>>                Move "PROCEDURE" to sRoutineType
73786>>>>>>>>>                Case Break
73787>>>>>>>>>        Case End
73787>>>>>>>>>
73787>>>>>>>>>        Function_Return (sRoutineType = "PROCEDURE")
73788>>>>>>>>>    End_Function
73789>>>>>>>>>
73789>>>>>>>>>    Function ProcParams String sFunctionName Returns Variant[]
73791>>>>>>>>>        Variant[] vFuncParams
73792>>>>>>>>>        Integer i iParamType
73792>>>>>>>>>
73792>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
73830>>>>>>>>>>
73830>>>>>>>>>
73830>>>>>>>>>        Case Begin
73830>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
73832>>>>>>>>>                sql_set_stmt to (SFormat("sys.sp_procedure_params_managed @procedure_name = '%1'", sFunctionName))
73864>>>>>>>>>                sql_prepare_stmt
73913>>>>>>>>>                sql_execute_stmt
73953>>>>>>>>>
73953>>>>>>>>>                Repeat
73953>>>>>>>>>>
73953>>>>>>>>>                    sql_fetch_next_row
74003>>>>>>>>>                    If (Found) Begin
74005>>>>>>>>>                        sql_fetch_column 6 into iParamType
74034>>>>>>>>>
74034>>>>>>>>>                        If (iParamType = 1) Begin
74036>>>>>>>>>                            Move "IN" to vFuncParams[i]
74037>>>>>>>>>                        End
74037>>>>>>>>>>
74037>>>>>>>>>                        If (iParamType = 2) Begin
74039>>>>>>>>>                            Move "INOUT" to vFuncParams[i]
74040>>>>>>>>>                        End
74040>>>>>>>>>>
74040>>>>>>>>>                        If (iParamType = 3) Begin
74042>>>>>>>>>                            Move "OUT" to vFuncParams[i]
74043>>>>>>>>>                        End
74043>>>>>>>>>>
74043>>>>>>>>>                        If (iParamType <> 4) Begin
74045>>>>>>>>>                            Increment i
74046>>>>>>>>>                        End
74046>>>>>>>>>>
74046>>>>>>>>>                    End
74046>>>>>>>>>>
74046>>>>>>>>>                Until (not(Found))
74048>>>>>>>>>
74048>>>>>>>>>                Function_Return vFuncParams
74049>>>>>>>>>
74049>>>>>>>>>                Case Break
74050>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
74053>>>>>>>>>                sql_set_stmt to (SFormat("select parameter_mode from INFORMATION_SCHEMA.PARAMETERS where SPECIFIC_NAME = '%1' order by ordinal_position", sFunctionName))
74085>>>>>>>>>                sql_prepare_stmt
74134>>>>>>>>>                sql_execute_stmt
74174>>>>>>>>>
74174>>>>>>>>>                Case Break
74175>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
74178>>>>>>>>>                sql_set_stmt to    "SELECT all_arguments.in_out as parameter_mode "
74210>>>>>>>>>                sql_append_stmt to "FROM all_objects inner join all_arguments on all_objects.object_id = all_arguments.object_id "
74242>>>>>>>>>                sql_append_stmt to (SFormat("WHERE all_objects.object_name = '%1' order by all_arguments.position", sFunctionName))
74274>>>>>>>>>                sql_prepare_stmt
74323>>>>>>>>>                sql_execute_stmt
74363>>>>>>>>>
74363>>>>>>>>>                Case Break
74364>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
74367>>>>>>>>>                sql_set_stmt    to "select information_schema.parameters.parameter_mode "
74399>>>>>>>>>                sql_append_stmt to "from information_schema.routines inner join information_schema.parameters "
74431>>>>>>>>>                sql_append_stmt to "on information_schema.routines.specific_name=information_schema.parameters.specific_name "
74463>>>>>>>>>                sql_append_stmt to (SFormat("where information_schema.routines.routine_name = '%1' ", sFunctionName))
74495>>>>>>>>>                sql_append_stmt to "order by information_schema.parameters.ordinal_position"
74527>>>>>>>>>                sql_prepare_stmt
74576>>>>>>>>>                sql_execute_stmt
74616>>>>>>>>>
74616>>>>>>>>>                Case Break
74617>>>>>>>>>        Case End
74617>>>>>>>>>
74617>>>>>>>>>        Repeat
74617>>>>>>>>>>
74617>>>>>>>>>            sql_fetch_next_row into vFuncParams[i]
74792>>>>>>>>>            Increment i
74793>>>>>>>>>        Until (not(Found))
74795>>>>>>>>>
74795>>>>>>>>>        Function_Return vFuncParams
74796>>>>>>>>>    End_Function
74797>>>>>>>>>
74797>>>>>>>>>    Procedure Set StoreHandleInfo Handle hConn
74799>>>>>>>>>        Set phCLIHandle to hConn
74800>>>>>>>>>    End_Procedure
74801>>>>>>>>>
74801>>>>>>>>>    Procedure FreeHandle
74803>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
74841>>>>>>>>>>
74841>>>>>>>>>
74841>>>>>>>>>                                 Case Begin
74841>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
74843>>>>>>>>>                                END_CALL_PROCEDURE
74848>>>>>>>>>                Case Break
74849>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
74852>>>>>>>>>                Case Break
74853>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
74856>>>>>>>>>                Case Break
74857>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
74860>>>>>>>>>                Case Break
74861>>>>>>>>>        Case End
74861>>>>>>>>>
74861>>>>>>>>>        SQL_CLOSE_CURSOR_STMT to (piCursorNum(Self))
74899>>>>>>>>>>
74899>>>>>>>>>        Send Destroy_Object
74900>>>>>>>>>    End_Procedure
74901>>>>>>>>>
74901>>>>>>>>>    Procedure SQLClose
74903>>>>>>>>>        Send FreeHandle
74904>>>>>>>>>    End_Procedure
74905>>>>>>>>>
74905>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
74907>>>>>>>>>        Integer iErrHandle
74907>>>>>>>>>        Integer iErrNum
74907>>>>>>>>>        String  sLocationInfo
74907>>>>>>>>>
74907>>>>>>>>>        //*** Get the DataFlex statement identifier
74907>>>>>>>>>        Move Current_object to iErrHandle
74908>>>>>>>>>
74908>>>>>>>>>        //*** Determine error number
74908>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
74911>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
74915>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
74919>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
74921>>>>>>>>>
74921>>>>>>>>>        //*** Create location information
74921>>>>>>>>>        Move "[" to sLocationInfo
74922>>>>>>>>>        If (sOriginMsg <> "") Begin
74924>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
74925>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
74926>>>>>>>>>        End
74926>>>>>>>>>>
74926>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
74927>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
74928>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
74929>>>>>>>>>
74929>>>>>>>>>        //*** Generate the error
74929>>>>>>>>>        Error iErrNum sLocationInfo
74930>>>>>>>>>>
74930>>>>>>>>>    End_Procedure
74931>>>>>>>>>
74931>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
74933>>>>>>>>>        Integer iErrHandle
74933>>>>>>>>>        String  sLocationInfo
74933>>>>>>>>>
74933>>>>>>>>>        //*** Get the DataFlex statement identifier
74933>>>>>>>>>        Move Current_object to iErrHandle
74934>>>>>>>>>
74934>>>>>>>>>        //*** Create location information
74934>>>>>>>>>        Move "[" to sLocationInfo
74935>>>>>>>>>        If (sOriginMsg <> "") Begin
74937>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
74938>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
74939>>>>>>>>>        End
74939>>>>>>>>>>
74939>>>>>>>>>        If (sErrtext <> "") Begin
74941>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
74942>>>>>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
74943>>>>>>>>>        End
74943>>>>>>>>>>
74943>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
74944>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
74945>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
74946>>>>>>>>>
74946>>>>>>>>>        //*** Generate the error
74946>>>>>>>>>        Error iErrNum sLocationInfo
74947>>>>>>>>>>
74947>>>>>>>>>    End_Procedure
74948>>>>>>>>>
74948>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
74950>>>>>>>>>        Integer bReport
74950>>>>>>>>>
74950>>>>>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
74953>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
74956>>>>>>>>>    End_Procedure
74957>>>>>>>>>
74957>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
74959>>>>>>>>>        String sResult
74959>>>>>>>>>        Integer iCols
74959>>>>>>>>>        Integer iOrgDateFmt
74959>>>>>>>>>        Integer iOrgDateSep
74959>>>>>>>>>        String sType
74959>>>>>>>>>
74959>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
74997>>>>>>>>>>
74997>>>>>>>>>
74997>>>>>>>>>        SQL_GET_NUM_COLS to iCols
75031>>>>>>>>>>
75031>>>>>>>>>        If (iCol <= iCols) Begin
75033>>>>>>>>>            //DAC SQL Driver currently uses military format for the SQL getting of dates.
75033>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
75035>>>>>>>>>                Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
75038>>>>>>>>>                Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
75041>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
75044>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
75047>>>>>>>>>            End
75047>>>>>>>>>>
75047>>>>>>>>>
75047>>>>>>>>>            //DAC SQL Driver cannot directly get TEXT fields into a result.
75047>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
75049>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sType
75090>>>>>>>>>>
75090>>>>>>>>>                If (sType=5) Begin
75092>>>>>>>>>                    Move "" to sResult
75093>>>>>>>>>                End
75093>>>>>>>>>>
75093>>>>>>>>>                Else Begin
75094>>>>>>>>>                    SQL_FETCH_COLUMN iCol into sResult
75123>>>>>>>>>                End
75123>>>>>>>>>>
75123>>>>>>>>>            End
75123>>>>>>>>>>
75123>>>>>>>>>            Else Begin
75124>>>>>>>>>               SQL_FETCH_COLUMN iCol into sResult
75153>>>>>>>>>            End
75153>>>>>>>>>>
75153>>>>>>>>>
75153>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
75155>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
75158>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
75161>>>>>>>>>            End
75161>>>>>>>>>>
75161>>>>>>>>>
75161>>>>>>>>>            Function_Return sResult
75162>>>>>>>>>        End
75162>>>>>>>>>>
75162>>>>>>>>>        Else Begin
75163>>>>>>>>>            Send HandleError (phCLIHandle(Self)) (phCLIHandle(Parent(Self))) (psDriverID(Self)) "SQLColumnValue"
75164>>>>>>>>>        End
75164>>>>>>>>>>
75164>>>>>>>>>        Function_Return ""
75165>>>>>>>>>    End_Function
75166>>>>>>>>>
75166>>>>>>>>>    Function SQLNextColumn Returns String
75168>>>>>>>>>        Integer iCol
75168>>>>>>>>>        String  sResult
75168>>>>>>>>>
75168>>>>>>>>>        Get piLastColumn to iCol
75169>>>>>>>>>        Increment iCol
75170>>>>>>>>>        Get SQLColumnValue iCol to sResult
75171>>>>>>>>>        Set piLastColumn to iCol
75172>>>>>>>>>
75172>>>>>>>>>        Function_Return sResult
75173>>>>>>>>>    End_Function
75174>>>>>>>>>
75174>>>>>>>>>    Procedure SQLPrepare String sStatement
75176>>>>>>>>>        tColumnMap tColumnMap
75176>>>>>>>>>        tColumnMap tColumnMap
75176>>>>>>>>>        Set ptColumnMap to tColumnMap
75177>>>>>>>>>        Set pisBeforeFetch to True
75178>>>>>>>>>
75178>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
75216>>>>>>>>>>
75216>>>>>>>>>        SQL_SET_STMT to sStatement
75248>>>>>>>>>
75248>>>>>>>>>        SQL_PREPARE_STMT
75297>>>>>>>>>    End_Procedure
75298>>>>>>>>>
75298>>>>>>>>>    Procedure SQLExecute
75300>>>>>>>>>        SQL_EXECUTE_STMT
75340>>>>>>>>>    End_Procedure
75341>>>>>>>>>
75341>>>>>>>>>    Procedure SQLExecDirect String sStatement
75343>>>>>>>>>        tColumnMap tColumnMap
75343>>>>>>>>>        tColumnMap tColumnMap
75343>>>>>>>>>        Set ptColumnMap to tColumnMap
75344>>>>>>>>>        Set pisBeforeFetch to True
75345>>>>>>>>>
75345>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
75383>>>>>>>>>>
75383>>>>>>>>>
75383>>>>>>>>>        SQL_SET_STMT to sStatement
75415>>>>>>>>>        SQL_PREPARE_STMT
75464>>>>>>>>>        SQL_EXECUTE_STMT
75504>>>>>>>>>    End_Procedure
75505>>>>>>>>>
75505>>>>>>>>>    Function SQLFetch Returns Integer
75507>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
75545>>>>>>>>>>
75545>>>>>>>>>        Set pisBeforeFetch to False
75546>>>>>>>>>
75546>>>>>>>>>        SQL_FETCH_NEXT_ROW
75596>>>>>>>>>        Function_Return (Found)
75597>>>>>>>>>    End_Function
75598>>>>>>>>>
75598>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
75600>>>>>>>>>        tColumnMap tColumnMap
75600>>>>>>>>>        tColumnMap tColumnMap
75600>>>>>>>>>        String[] sBindFileColumns
75601>>>>>>>>>        Integer iColCnt i iDateFormat iResultColumnType iBindFileColumnType
75601>>>>>>>>>        String sColumnName
75601>>>>>>>>>        Variant vFieldValue
75601>>>>>>>>>        Boolean isRecnumTable
75601>>>>>>>>>
75601>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
75639>>>>>>>>>>
75639>>>>>>>>>
75639>>>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of iFileNum to isRecnumTable
75642>>>>>>>>>        Get ptColumnMap to tColumnMap
75643>>>>>>>>>
75643>>>>>>>>>        If (tColumnMap.iFileNum <> iFileNum) Begin
75645>>>>>>>>>            Move iFileNum to tColumnMap.iFileNum
75646>>>>>>>>>
75646>>>>>>>>>            // First we build an array of the column names (in order) from the file buffer to bind to
75646>>>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of iFileNum to iColCnt
75649>>>>>>>>>            For i from 0 to iColCnt
75655>>>>>>>>>>
75655>>>>>>>>>                If (isRecnumTable) Begin
75657>>>>>>>>>                    Get_Attribute DF_FIELD_NAME of iFileNum i to sColumnName
75660>>>>>>>>>                End
75660>>>>>>>>>>
75660>>>>>>>>>                Else Begin
75661>>>>>>>>>                    Move "" to sColumnName
75662>>>>>>>>>                End
75662>>>>>>>>>>
75662>>>>>>>>>
75662>>>>>>>>>                Move (Uppercase(sColumnName)) to sBindFileColumns[i]
75663>>>>>>>>>            Loop
75664>>>>>>>>>>
75664>>>>>>>>>
75664>>>>>>>>>            // Next we iterate over the columns in the resultset.  Any column names that match we
75664>>>>>>>>>            // set its match location into an array that maps each resultset column to its matching
75664>>>>>>>>>            // column number in the file buffer.  If there is no match, we set that resultset
75664>>>>>>>>>            // column mappped column to -1.
75664>>>>>>>>>            //
75664>>>>>>>>>            // Since Arrays are zero based and columns are numbered from 1, when we actually map
75664>>>>>>>>>            // to set the value, we need to add 1 to array indexer to get the proper resultset
75664>>>>>>>>>            // column AND we need to add 1 to the mapped-to column since it was loaded into a zero
75664>>>>>>>>>            // based array also.  (Ex: vResultColumn[0] = 2 means column 1 from the resultset maps
75664>>>>>>>>>            // to Column 3 of the file buffer)
75664>>>>>>>>>
75664>>>>>>>>>            SQL_GET_NUM_COLS to iColCnt
75698>>>>>>>>>>
75698>>>>>>>>>            For i from 1 to iColCnt
75704>>>>>>>>>>
75704>>>>>>>>>                SQL_GET_COL_NAME i to sColumnName
75744>>>>>>>>>>
75744>>>>>>>>>                // Because SearchArray returns -1 if there isn't a match, we don't need to do
75744>>>>>>>>>                // anything to make an "unmapped column" have a value of -1.
75744>>>>>>>>>                Move (SearchArray(Uppercase(sColumnName), sBindFileColumns)) to tColumnMap.vResultColumn[i-1]
75745>>>>>>>>>
75745>>>>>>>>>                // If the types don't match between the columns, then "unmap" the column.  This
75745>>>>>>>>>                // should only occur when you're not mapping to the same file as the resultset.
75745>>>>>>>>>                // In this case, sql.pkg silently does nothing, so we need to duplicate this instead
75745>>>>>>>>>                // of generating an error.  If the mapping is to a string, then any type can be
75745>>>>>>>>>                // converted to a string so its okay.
75745>>>>>>>>>                If (tColumnMap.vResultColumn[i-1] <> -1) Begin
75747>>>>>>>>>                    SQL_GET_COL_ATTRIBUTE of i DFTYPE to iResultColumnType
75788>>>>>>>>>>
75788>>>>>>>>>                    Get_Attribute DF_FIELD_TYPE of iFileNum (tColumnMap.vResultColumn[i-1]) to iBindFileColumnType
75791>>>>>>>>>
75791>>>>>>>>>                    // If the conversion is to string (even if the resultset column is something
75791>>>>>>>>>                    // else) its ok, so Break out of the If block before we muck things up.
75791>>>>>>>>>                    If (iBindFileColumnType = DF_ASCII) Break
75794>>>>>>>>>
75794>>>>>>>>>                    // Otherwise, break the mapping
75794>>>>>>>>>                    If (iResultColumnType <> iBindFileColumnType) Begin
75796>>>>>>>>>                        Move -1 to tColumnMap.vResultColumn[i-1]
75797>>>>>>>>>                    End
75797>>>>>>>>>>
75797>>>>>>>>>                End
75797>>>>>>>>>>
75797>>>>>>>>>            Loop
75798>>>>>>>>>>
75798>>>>>>>>>
75798>>>>>>>>>            Set ptColumnMap to tColumnMap
75799>>>>>>>>>        End
75799>>>>>>>>>>
75799>>>>>>>>>
75799>>>>>>>>>        Get SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
75800>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to True
75801>>>>>>>>>        Clear iFileNum
75802>>>>>>>>>        For i from 0 to (SizeOfArray(tColumnMap.vResultColumn)-1)
75808>>>>>>>>>>
75808>>>>>>>>>            If (tColumnMap.vResultColumn[i] > -1) Begin
75810>>>>>>>>>                SQL_FETCH_COLUMN (i+1) into vFieldValue
75839>>>>>>>>>                Set_Field_Value iFileNum (tColumnMap.vResultColumn[i]) to vFieldValue
75842>>>>>>>>>            End
75842>>>>>>>>>>
75842>>>>>>>>>        Loop
75843>>>>>>>>>>
75843>>>>>>>>>        Set_Attribute DF_FILE_STATUS of iFileNum to DF_FILE_ACTIVE
75846>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
75847>>>>>>>>>    End_Procedure
75848>>>>>>>>>
75848>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
75850>>>>>>>>>        String data
75850>>>>>>>>>        Integer retlen
75850>>>>>>>>>
75850>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
75888>>>>>>>>>>
75888>>>>>>>>>
75888>>>>>>>>>        SQL_SET_CHUNK_SIZE to iLen
75929>>>>>>>>>>
75929>>>>>>>>>        SQL_GET_DATA_CHUNK COLUMN iCol OFFSET (piDataChunkOffset(Self)) to data retlen
75963>>>>>>>>>>
75963>>>>>>>>>        Set piDataChunkOffset to (piDataChunkOffset(Self)+retlen)
75964>>>>>>>>>
75964>>>>>>>>>        Function_Return data
75965>>>>>>>>>    End_Function
75966>>>>>>>>>
75966>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
75968>>>>>>>>>        Integer iNumColumns i iIndex
75968>>>>>>>>>        String[] cols
75969>>>>>>>>>
75969>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
76007>>>>>>>>>>
76007>>>>>>>>>
76007>>>>>>>>>        Get SQLStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT to iNumColumns
76008>>>>>>>>>
76008>>>>>>>>>        For i from 1 to iNumColumns
76014>>>>>>>>>>
76014>>>>>>>>>            SQL_GET_COL_NAME i to cols[i-1]
76054>>>>>>>>>>
76054>>>>>>>>>            Move (trim(Uppercase(cols[i-1]))) to cols[i-1]
76055>>>>>>>>>        Loop
76056>>>>>>>>>>
76056>>>>>>>>>
76056>>>>>>>>>        Move (trim(Uppercase(sColname))) to sColname
76057>>>>>>>>>        Move (SearchArray(sColname, cols)) to iIndex
76058>>>>>>>>>        Function_Return (iIndex+1)  // even if searcharray returns -1 (not found) this expects 0 for not found, so it's ok
76059>>>>>>>>>    End_Function
76060>>>>>>>>>
76060>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
76062>>>>>>>>>        Integer iCnt
76062>>>>>>>>>
76062>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
76100>>>>>>>>>>
76100>>>>>>>>>
76100>>>>>>>>>        Case Begin
76100>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
76102>>>>>>>>>                SQL_GET_NUM_COLS to iCnt
76136>>>>>>>>>>
76136>>>>>>>>>                Function_Return iCnt
76137>>>>>>>>>                Case Break
76138>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
76141>>>>>>>>>                SQL_GET_NUM_ROWS to iCnt
76175>>>>>>>>>>
76175>>>>>>>>>
76175>>>>>>>>>                //DAC Driver doesn't know the rowcount before the first fetch.
76175>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
76177>>>>>>>>>                    If (pisBeforeFetch(Self)) Begin
76179>>>>>>>>>                        Function_Return -1
76180>>>>>>>>>                    End
76180>>>>>>>>>>
76180>>>>>>>>>                End
76180>>>>>>>>>>
76180>>>>>>>>>
76180>>>>>>>>>                Function_Return iCnt
76181>>>>>>>>>                Case Break
76182>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
76185>>>>>>>>>                // TODO: Need something to indicate the quality of the SQL_GET_NUM_ROWS, or fake till I make it
76185>>>>>>>>>                Case Break
76186>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
76189>>>>>>>>>                Function_Return -1
76190>>>>>>>>>                // TODO: Are the messages returned in SQLGetMessage from the driver, or from the underlying connection?
76190>>>>>>>>>                Case Break
76191>>>>>>>>>            Case Else
76191>>>>>>>>>        Case End
76191>>>>>>>>>
76191>>>>>>>>>        Function_Return ""
76192>>>>>>>>>    End_Function
76193>>>>>>>>>
76193>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
76195>>>>>>>>>        String sValue
76195>>>>>>>>>        Integer iSQLType
76195>>>>>>>>>        Integer iDFType
76195>>>>>>>>>
76195>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
76233>>>>>>>>>>
76233>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol SQLTYPE to iSQLType
76274>>>>>>>>>>
76274>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to iDFType
76315>>>>>>>>>>
76315>>>>>>>>>
76315>>>>>>>>>        Case Begin
76315>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SIZE)
76317>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol SIZE to sValue
76358>>>>>>>>>>
76358>>>>>>>>>
76358>>>>>>>>>                //DAC Driver uses different values.
76358>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
76360>>>>>>>>>                    If (iSQLType=12) Begin
76362>>>>>>>>>                        Move (Integer(sValue-1)) to sValue
76363>>>>>>>>>                    End
76363>>>>>>>>>>
76363>>>>>>>>>                    If (iDFType=5) Begin
76365>>>>>>>>>                        Move "0" to sValue
76366>>>>>>>>>                    End
76366>>>>>>>>>>
76366>>>>>>>>>                    If (iSQLType=40) Begin
76368>>>>>>>>>                        Move "10" to sValue
76369>>>>>>>>>                    End
76369>>>>>>>>>>
76369>>>>>>>>>                End
76369>>>>>>>>>>
76369>>>>>>>>>
76369>>>>>>>>>                Case Break
76370>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_PRECISION)
76373>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DECIMALS to sValue
76414>>>>>>>>>>
76414>>>>>>>>>                Case Break
76415>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_LABEL)
76418>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
76459>>>>>>>>>>
76459>>>>>>>>>                Case Break
76460>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
76463>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
76504>>>>>>>>>>
76504>>>>>>>>>
76504>>>>>>>>>                //DAC Driver doesn't use Base Column Name.
76504>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
76506>>>>>>>>>                    Move "" to sValue
76507>>>>>>>>>                End
76507>>>>>>>>>>
76507>>>>>>>>>
76507>>>>>>>>>                Case Break
76508>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
76511>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol TABLE_NAME to sValue
76552>>>>>>>>>>
76552>>>>>>>>>                Case Break
76553>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
76556>>>>>>>>>                Move iSQLType to sValue
76557>>>>>>>>>
76557>>>>>>>>>                //DAC Driver uses different values.
76557>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
76559>>>>>>>>>                    If (iSQLType=2) Begin
76561>>>>>>>>>                        Move "3" to sValue
76562>>>>>>>>>                    End
76562>>>>>>>>>>
76562>>>>>>>>>                    If (iSQLType=-99) Begin
76564>>>>>>>>>                        Move "12" to sValue
76565>>>>>>>>>                    End
76565>>>>>>>>>>
76565>>>>>>>>>                    If (iSQLType=40) Begin
76567>>>>>>>>>                        Move "91" to sValue
76568>>>>>>>>>                    End
76568>>>>>>>>>>
76568>>>>>>>>>                End
76568>>>>>>>>>>
76568>>>>>>>>>
76568>>>>>>>>>                Case Break
76569>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_NULLABLE)
76572>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol NULLABLE to sValue
76613>>>>>>>>>>
76613>>>>>>>>>                Case Break
76614>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_DFTYPE)
76617>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sValue
76658>>>>>>>>>>
76658>>>>>>>>>
76658>>>>>>>>>                //DAC Driver uses different values.
76658>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
76660>>>>>>>>>                    If (iDFType = 5) Begin
76662>>>>>>>>>                        Move "0" to sValue
76663>>>>>>>>>                    End
76663>>>>>>>>>>
76663>>>>>>>>>                End
76663>>>>>>>>>>
76663>>>>>>>>>                Case Break
76664>>>>>>>>>        Case End
76664>>>>>>>>>
76664>>>>>>>>>        Function_Return sValue
76665>>>>>>>>>    End_Function
76666>>>>>>>>>
76666>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
76668>>>>>>>>>        Set psProcName to sProcName
76669>>>>>>>>>        If (Num_Arguments >= 2) ;            Set psSchemaName to sSchemaArg
76672>>>>>>>>>        Else ;            Set psSchemaName to ""
76674>>>>>>>>>    End_Procedure
76675>>>>>>>>>
76675>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
76677>>>>>>>>>        Integer iArgnum
76677>>>>>>>>>
76677>>>>>>>>>        Get piLastArgument to iArgnum
76678>>>>>>>>>        Increment iArgnum
76679>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
76680>>>>>>>>>        Set piLastArgument to iArgnum
76681>>>>>>>>>    End_Procedure
76682>>>>>>>>>
76682>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
76684>>>>>>>>>        Variant[] vParams
76685>>>>>>>>>
76685>>>>>>>>>        Get pvParams to vParams
76686>>>>>>>>>        Move sArgument to vParams[iArgnum-1]
76687>>>>>>>>>        Set pvParams to vParams
76688>>>>>>>>>
76688>>>>>>>>>    End_Procedure
76689>>>>>>>>>
76689>>>>>>>>>    Procedure SQLCall
76691>>>>>>>>>        Variant[] vParams
76692>>>>>>>>>        Variant[] vParamOpts
76693>>>>>>>>>        Integer i
76693>>>>>>>>>        Integer iMax
76693>>>>>>>>>        Integer iParamsIn
76693>>>>>>>>>        String sParameter
76693>>>>>>>>>        Boolean bIsProcedure
76693>>>>>>>>>
76693>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
76731>>>>>>>>>>
76731>>>>>>>>>
76731>>>>>>>>>        Get pvParams to vParams
76732>>>>>>>>>
76732>>>>>>>>>        // First, we need to figure out if this is a procedure or a function. Then if
76732>>>>>>>>>        // it's a procedure, "analyze" it to figure out which parameters are IN,
76732>>>>>>>>>        // OUT, or IN_OUT.  Then we adjust how we call SQL_SET_PROCEDURE_PARAMETER
76732>>>>>>>>>        // so that after the call you can retrieve the value.
76732>>>>>>>>>
76732>>>>>>>>>        Get IsProcedure (psProcName(Self)) to bIsProcedure
76733>>>>>>>>>
76733>>>>>>>>>        If (bIsProcedure) Begin
76735>>>>>>>>>            Get ProcParams (psProcName(Self)) to vParamOpts
76736>>>>>>>>>
76736>>>>>>>>>            Move (sizeOfArray(vParamOpts)) to iMax
76737>>>>>>>>>            Move (SizeOfArray(vParams)) to iParamsIn
76738>>>>>>>>>            Set piParameterCount to iMax
76739>>>>>>>>>
76739>>>>>>>>>            SQL_SET_PROCEDURE_NAME (psProcName(Self)) NUMPAR iMax
76783>>>>>>>>>            For i from 1 to iMax
76789>>>>>>>>>>
76789>>>>>>>>>                If ( (i-1) >= iParamsIn) Begin
76791>>>>>>>>>                    Move "" to sParameter
76792>>>>>>>>>                End
76792>>>>>>>>>>
76792>>>>>>>>>                Else Begin
76793>>>>>>>>>                    Move vParams[i-1] to sParameter
76794>>>>>>>>>                End
76794>>>>>>>>>>
76794>>>>>>>>>
76794>>>>>>>>>                Case Begin
76794>>>>>>>>>                    Case (vParamOpts[i-1] = "IN")
76796>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN
76833>>>>>>>>>>
76833>>>>>>>>>                        Case Break
76834>>>>>>>>>                    Case (vParamOpts[i-1] = "OUT")
76837>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter OUT
76874>>>>>>>>>>
76874>>>>>>>>>                        Case Break
76875>>>>>>>>>                    Case (vParamOpts[i-1] = "IN/OUT" or vParamOpts[i-1] = "INOUT")
76878>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN_OUT
76915>>>>>>>>>>
76915>>>>>>>>>                        Case Break
76916>>>>>>>>>                Case End
76916>>>>>>>>>            Loop
76917>>>>>>>>>>
76917>>>>>>>>>
76917>>>>>>>>>            SQL_PROCEDURE_EXECUTE
76957>>>>>>>>>        End
76957>>>>>>>>>>
76957>>>>>>>>>        Else Begin
76958>>>>>>>>>            SQL_SET_FUNCTION_NAME (psProcName(Self)) NUMPAR (SizeOfArray(vParams))
77006>>>>>>>>>            For i from 1 to (SizeOfArray(vParams))
77012>>>>>>>>>>
77012>>>>>>>>>                SQL_SET_FUNCTION_PARAMETER i to vParams[i-1]
77181>>>>>>>>>>
77181>>>>>>>>>            Loop
77182>>>>>>>>>>
77182>>>>>>>>>
77182>>>>>>>>>            SQL_FUNCTION_EXECUTE
77183>>>>>>>>>        End
77183>>>>>>>>>>
77183>>>>>>>>>    End_Procedure
77184>>>>>>>>>
77184>>>>>>>>>    Function SQLGetNextArgument Returns String
77186>>>>>>>>>        Integer iArgnum
77186>>>>>>>>>        String  sResult
77186>>>>>>>>>
77186>>>>>>>>>        Get piLastArgument to iArgnum
77187>>>>>>>>>        Increment iArgnum
77188>>>>>>>>>        Get SQLGetArgument iArgnum to sResult
77189>>>>>>>>>        Set piLastArgument to iArgnum
77190>>>>>>>>>
77190>>>>>>>>>        Function_Return sResult
77191>>>>>>>>>    End_Function
77192>>>>>>>>>
77192>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
77194>>>>>>>>>        String retval
77194>>>>>>>>>
77194>>>>>>>>>        If ( (piParameterCount(Self)) < iArgnum) Begin
77196>>>>>>>>>            Function_Return ""
77197>>>>>>>>>        End
77197>>>>>>>>>>
77197>>>>>>>>>        SQL_GET_PROCEDURE_PARAMETER iArgnum to retval
77253>>>>>>>>>>
77253>>>>>>>>>
77253>>>>>>>>>        Function_Return retval
77254>>>>>>>>>    End_Function
77255>>>>>>>>>
77255>>>>>>>>>    Function SQLReturnValue Returns String
77257>>>>>>>>>        String retval
77257>>>>>>>>>
77257>>>>>>>>>        SQL_GET_FUNCTION_RETURN to retval
77345>>>>>>>>>        Function_Return retval
77346>>>>>>>>>    End_Function
77347>>>>>>>>>
77347>>>>>>>>>    Function SQLNextResultSet Returns Integer
77349>>>>>>>>>        SQL_NEXT_RESULT_SET
77385>>>>>>>>>
77385>>>>>>>>>        Function_Return (Found)
77386>>>>>>>>>    End_Function
77387>>>>>>>>>
77387>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
77389>>>>>>>>>        // TODO
77389>>>>>>>>>        Function_Return ""
77390>>>>>>>>>    End_Function
77391>>>>>>>>>
77391>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
77393>>>>>>>>>        // TODO
77393>>>>>>>>>    End_Procedure
77394>>>>>>>>>
77394>>>>>>>>>End_Class
77395>>>>>>>>>
77395>>>>>>>>>Class cSQLConnectionDUF is a cObject
77396>>>>>>>>>    Procedure Construct_Object
77398>>>>>>>>>        Forward Send Construct_Object
77400>>>>>>>>>
77400>>>>>>>>>        Property Handle phCLIHandle 0
77401>>>>>>>>>        Property String psDriverID MertechInc_DriverName
77402>>>>>>>>>        Property Integer piBindFile 0
77403>>>>>>>>>        Property String psUsername ""
77404>>>>>>>>>        Property String psPassword ""
77405>>>>>>>>>
77405>>>>>>>>>        Property String psCurrentDatabase ""
77406>>>>>>>>>
77406>>>>>>>>>        Property tCLIHandleMap ptCLIHandleMap
77407>>>>>>>>>    End_Procedure
77408>>>>>>>>>
77408>>>>>>>>>    Procedure StoreHandleInfo Handle hCLIHandle String sDrvrId Handle iParentHandle
77410>>>>>>>>>        Set phCLIHandle      to hCLIHandle
77411>>>>>>>>>        Set psDriverID       to sDrvrId
77412>>>>>>>>>    End_Procedure
77413>>>>>>>>>
77413>>>>>>>>>    Procedure FreeHandle
77415>>>>>>>>>        Send Destroy
77416>>>>>>>>>    End_Procedure
77417>>>>>>>>>
77417>>>>>>>>>    Procedure Set SQLDatabase String sDatabase
77419>>>>>>>>>        tCLIHandleMap conn
77419>>>>>>>>>        tCLIHandleMap conn
77419>>>>>>>>>
77419>>>>>>>>>        Get ptCLIHandleMap to conn
77420>>>>>>>>>        Set psCurrentDatabase to sDatabase
77421>>>>>>>>>        SQL_USE_DATABASE of conn.sConnect to sDatabase
77459>>>>>>>>>>
77459>>>>>>>>>    End_Procedure
77460>>>>>>>>>
77460>>>>>>>>>    Function SQLConnect String sDriver String sConnect Returns Handle
77462>>>>>>>>>        tCLIHandleMap[] maps
77462>>>>>>>>>        tCLIHandleMap[] maps
77463>>>>>>>>>        tCLIHandleMap conn
77463>>>>>>>>>        tCLIHandleMap conn
77463>>>>>>>>>
77463>>>>>>>>>        Get ptCLIHandleMaps to maps
77464>>>>>>>>>        Move sDriver to conn.sDriver
77465>>>>>>>>>        Move sConnect to conn.sConnect
77466>>>>>>>>>
77466>>>>>>>>>        If (SizeOfArray(maps) > 0) Begin
77468>>>>>>>>>            Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
77469>>>>>>>>>        End
77469>>>>>>>>>>
77469>>>>>>>>>        Else Begin
77470>>>>>>>>>            Move 1 to conn.iHdbc
77471>>>>>>>>>        End
77471>>>>>>>>>>
77471>>>>>>>>>
77471>>>>>>>>>        Set CurrentConnection to sDriver sConnect
77472>>>>>>>>>        If (not(Err)) Begin
77474>>>>>>>>>            Move conn to maps[(SizeOfArray(maps))]
77475>>>>>>>>>            Set ptCLIHandleMaps to maps
77476>>>>>>>>>            Set ptCLIHandleMap to conn
77477>>>>>>>>>        End
77477>>>>>>>>>>
77477>>>>>>>>>
77477>>>>>>>>>        Function_Return Self
77478>>>>>>>>>    End_Function
77479>>>>>>>>>
77479>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
77481>>>>>>>>>        Boolean bIsOpen
77481>>>>>>>>>        String sDriver sServer
77481>>>>>>>>>        tCLIHandleMap[] maps
77481>>>>>>>>>        tCLIHandleMap[] maps
77482>>>>>>>>>        tCLIHandleMap conn
77482>>>>>>>>>        tCLIHandleMap conn
77482>>>>>>>>>
77482>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
77485>>>>>>>>>        If (bIsOpen) Begin
77487>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
77487>>>>>>>>>            Move (Repeat(' ', 255)) to sDriver
77488>>>>>>>>>            Move (Repeat(' ', 255)) to sServer
77489>>>>>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDriver
77492>>>>>>>>>            Get_Attribute DF_FILE_SERVER_NAME of iFileNum to sServer
77495>>>>>>>>>
77495>>>>>>>>>            Indicate Err False
77496>>>>>>>>>
77496>>>>>>>>>            Get ptCLIHandleMaps to maps
77497>>>>>>>>>            Move sDriver to conn.sDriver
77498>>>>>>>>>            Move sServer to conn.sConnect
77499>>>>>>>>>
77499>>>>>>>>>            If (SizeOfArray(maps) > 0) Begin
77501>>>>>>>>>                Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
77502>>>>>>>>>            End
77502>>>>>>>>>>
77502>>>>>>>>>            Else Begin
77503>>>>>>>>>                Move 1 to conn.iHdbc
77504>>>>>>>>>            End
77504>>>>>>>>>>
77504>>>>>>>>>
77504>>>>>>>>>            Set CurrentConnection to sDriver sServer
77505>>>>>>>>>            If (not(Err)) Begin
77507>>>>>>>>>                Move conn to maps[(SizeOfArray(maps))]
77508>>>>>>>>>                Set ptCLIHandleMaps to maps
77509>>>>>>>>>                Set ptCLIHandleMap to conn
77510>>>>>>>>>            End
77510>>>>>>>>>>
77510>>>>>>>>>
77510>>>>>>>>>            Send StoreHandleInfo conn.iHdbc conn.sDriver
77511>>>>>>>>>            Set piBindFile to iFileNum
77512>>>>>>>>>        End
77512>>>>>>>>>>
77512>>>>>>>>>        Else Begin
77513>>>>>>>>>            Error 4099 "File Not Open"
77514>>>>>>>>>>
77514>>>>>>>>>        End
77514>>>>>>>>>>
77514>>>>>>>>>
77514>>>>>>>>>        //*** Return success status
77514>>>>>>>>>        Function_Return (not(Err))
77515>>>>>>>>>    End_Function
77516>>>>>>>>>
77516>>>>>>>>>    Procedure SQLDisconnect
77518>>>>>>>>>        tCLIHandleMap map
77518>>>>>>>>>        tCLIHandleMap map
77518>>>>>>>>>        tCLIHandleMap[] maps
77518>>>>>>>>>        tCLIHandleMap[] maps
77519>>>>>>>>>        Integer iFound
77519>>>>>>>>>
77519>>>>>>>>>        Get ptCLIHandleMap to map
77520>>>>>>>>>        Get ptCLIHandleMaps to maps
77521>>>>>>>>>
77521>>>>>>>>>        Move (SearchArray(map, maps, Parent(Self), RefFunc(CompareMaps))) to iFound
77522>>>>>>>>>        If (iFound > -1) Begin
77524>>>>>>>>>            Send FreeHandle
77525>>>>>>>>>        End
77525>>>>>>>>>>
77525>>>>>>>>>    End_Procedure
77526>>>>>>>>>
77526>>>>>>>>>    Function CreateHandle Returns Integer
77528>>>>>>>>>        Handle hSQL
77528>>>>>>>>>        Integer iCursor
77528>>>>>>>>>
77528>>>>>>>>>        Get Create (RefClass(cSQLStatementDUF)) to hSQL
77529>>>>>>>>>
77529>>>>>>>>>        Set piBindFile of hSQL to (piBindFile(Current_object))
77530>>>>>>>>>
77530>>>>>>>>>        SQL_OPEN_CURSOR_STMT to iCursor
77568>>>>>>>>>>
77568>>>>>>>>>        Set piCursorNum of hSQL to iCursor
77569>>>>>>>>>
77569>>>>>>>>>        Function_Return hSQL
77570>>>>>>>>>    End_Function
77571>>>>>>>>>
77571>>>>>>>>>    Function SQLOpen Returns Integer
77573>>>>>>>>>        Handle hDFHandle
77573>>>>>>>>>
77573>>>>>>>>>        Get CreateHandle to hDFHandle
77574>>>>>>>>>
77574>>>>>>>>>        Send StoreHandleInfo to hDFHandle Self (psDriverID(Self))
77575>>>>>>>>>
77575>>>>>>>>>        Function_Return hDFHandle
77576>>>>>>>>>    End_Function
77577>>>>>>>>>
77577>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
77579>>>>>>>>>        String sCurrentDriver
77579>>>>>>>>>        Integer iDriver
77579>>>>>>>>>        Integer iNumDrivers
77579>>>>>>>>>
77579>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumDrivers
77582>>>>>>>>>        For iDriver from 1 to iNumDrivers
77588>>>>>>>>>>
77588>>>>>>>>>          Get_Attribute DF_DRIVER_NAME of iDriver to sCurrentDriver
77591>>>>>>>>>          If (Uppercase(sDriver) = Uppercase(sCurrentDriver)) ;              Function_Return iDriver
77594>>>>>>>>>        Loop
77595>>>>>>>>>>
77595>>>>>>>>>        Function_Return 0
77596>>>>>>>>>    End_Function
77597>>>>>>>>>
77597>>>>>>>>>    Function FirstServerForDriverNo Integer iDriver Returns String
77599>>>>>>>>>        String sServer
77599>>>>>>>>>        Integer iNumServers
77599>>>>>>>>>        Integer iServer
77599>>>>>>>>>
77599>>>>>>>>>        If (iDriver <> 0) Begin
77601>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
77604>>>>>>>>>            If (iNumServers<>0) Begin
77606>>>>>>>>>                Move 1 to iServer
77607>>>>>>>>>                Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iServer to sServer
77610>>>>>>>>>            End
77610>>>>>>>>>>
77610>>>>>>>>>        End
77610>>>>>>>>>>
77610>>>>>>>>>
77610>>>>>>>>>        Function_Return sServer
77611>>>>>>>>>    End_Function
77612>>>>>>>>>
77612>>>>>>>>>    Procedure Set CurrentConnection String sDriver String sServer
77614>>>>>>>>>        Integer iDriver
77614>>>>>>>>>        String sUsername
77614>>>>>>>>>        String sPassword
77614>>>>>>>>>
77614>>>>>>>>>        If (sDriver="") Begin
77616>>>>>>>>>            DO_GETFILENUMBER_DRIVERNAME 0
77642>>>>>>>>>>
77642>>>>>>>>>            Move MertechInc_DriverName to sDriver
77643>>>>>>>>>        End
77643>>>>>>>>>>
77643>>>>>>>>>
77643>>>>>>>>>        If ("MDSMYSQL|ORA_DRV|MDSPGSQL|SQL_DRV|MDS_DB2" contains Uppercase(Trim(sDriver))) Begin
77645>>>>>>>>>            Move (Uppercase(Trim(sDriver))) to MertechInc_DriverName
77646>>>>>>>>>
77646>>>>>>>>>            If (Trim(sDriver) <> "") Begin
77648>>>>>>>>>                Move (Uppercase(Trim(sDriver))) to MertechInc_CurrentDriver
77649>>>>>>>>>            End
77649>>>>>>>>>>
77649>>>>>>>>>            Else Begin
77650>>>>>>>>>                Move "" to MertechInc_CurrentDriver
77651>>>>>>>>>            End
77651>>>>>>>>>>
77651>>>>>>>>>
77651>>>>>>>>>            Get psUsername to sUsername
77652>>>>>>>>>            Get psPassword to sPassword
77653>>>>>>>>>
77653>>>>>>>>>            Get DriverIndex MertechInc_CurrentDriver to iDriver
77654>>>>>>>>>
77654>>>>>>>>>            If (sServer   = "") Begin
77656>>>>>>>>>                Get FirstServerForDriverNo iDriver to sServer
77657>>>>>>>>>            End
77657>>>>>>>>>>
77657>>>>>>>>>            If (sUsername = "") Begin
77659>>>>>>>>>                Get_Current_User_Name of sServer to sUsername
77698>>>>>>>>>>
77698>>>>>>>>>            End
77698>>>>>>>>>>
77698>>>>>>>>>            If (sPassword = "") Begin
77700>>>>>>>>>                Get_Current_User_Password of sServer to sPassword
77739>>>>>>>>>>
77739>>>>>>>>>            End
77739>>>>>>>>>>
77739>>>>>>>>>
77739>>>>>>>>>            Move False to Err
77740>>>>>>>>>            Send Ignore_Error of Error_Object_Id 25000
77741>>>>>>>>>            Login sServer sUsername sPassword sDriver
77743>>>>>>>>>            Send Trap_Error of Error_Object_Id 25000
77744>>>>>>>>>
77744>>>>>>>>>            If (Err = False) Begin
77746>>>>>>>>>                Call_Driver 0 MertechInc_DriverName Function CALLDRV_CURRENT_SQL_SERVER_CONNECTION CALLBACK 0 PASSING sServer MertechInc_Blank 0 RESULT MertechInc_iRet
77751>>>>>>>>>            End
77751>>>>>>>>>>
77751>>>>>>>>>            Else Begin
77752>>>>>>>>>                Procedure_Return
77753>>>>>>>>>            End
77753>>>>>>>>>>
77753>>>>>>>>>
77753>>>>>>>>>            If (MertechInc_iRet = -1) Begin
77755>>>>>>>>>                Move True to Err
77756>>>>>>>>>            End
77756>>>>>>>>>>
77756>>>>>>>>>        End
77756>>>>>>>>>>
77756>>>>>>>>>        Else Begin
77757>>>>>>>>>            Error 4099 "Invalid Driver"
77758>>>>>>>>>>
77758>>>>>>>>>        End
77758>>>>>>>>>>
77758>>>>>>>>>
77758>>>>>>>>>    End_Procedure
77759>>>>>>>>>
77759>>>>>>>>>End_Class
77760>>>>>>>>>
77760>>>>>>>>>Class cSQLHandleManagerDUF is a cObject
77761>>>>>>>>>
77761>>>>>>>>>    Procedure Construct_Object
77763>>>>>>>>>        Forward Send Construct_Object
77765>>>>>>>>>
77765>>>>>>>>>        Property String  psDefaultDriver     ""
77766>>>>>>>>>        Property String  psDefaultConnection ""
77767>>>>>>>>>        Property tCLIHandleMap[] ptCLIHandleMaps
77768>>>>>>>>>    End_Procedure
77769>>>>>>>>>
77769>>>>>>>>>    Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
77771>>>>>>>>>        If ((map1.iHdbc = map2.iHdbc) and (map1.sConnect = map2.sConnect) and (map1.sDriver = map2.sDriver)) Begin
77773>>>>>>>>>            Function_Return (EQ)
77774>>>>>>>>>        End
77774>>>>>>>>>>
77774>>>>>>>>>        Function_Return (GT)
77775>>>>>>>>>    End_Function
77776>>>>>>>>>
77776>>>>>>>>>    Function CreateHandle Returns Handle
77778>>>>>>>>>        Handle hSQL
77778>>>>>>>>>
77778>>>>>>>>>        Get Create (RefClass(cSQLConnectionDUF)) to hSQL
77779>>>>>>>>>        Function_Return hSQL
77780>>>>>>>>>    End_Function
77781>>>>>>>>>
77781>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
77783>>>>>>>>>        Set psDefaultDriver to sDriver
77784>>>>>>>>>        Set psDefaultConnection to sConnect
77785>>>>>>>>>    End_Procedure
77786>>>>>>>>>
77786>>>>>>>>>    Function SQLConnect String sDriver String sConnect String sUID String sPWD Returns Handle
77788>>>>>>>>>        Handle hSql
77788>>>>>>>>>        Boolean bOK
77788>>>>>>>>>        String sServer sUsername sPassword
77788>>>>>>>>>
77788>>>>>>>>>        Get CreateHandle to hSql
77789>>>>>>>>>
77789>>>>>>>>>        If (sDriver = "" and sConnect = "") Begin
77791>>>>>>>>>            Get psDefaultDriver to sDriver
77792>>>>>>>>>            Get psDefaultConnection to sConnect
77793>>>>>>>>>        End
77793>>>>>>>>>>
77793>>>>>>>>>
77793>>>>>>>>>        If (num_arguments = 2) Begin
77795>>>>>>>>>            Get ParseKeyWord sConnect "SERVER"  to sServer
77796>>>>>>>>>            If (sServer = "") Begin
77798>>>>>>>>>                Get ParseKeyWord sConnect "DSN" to sServer
77799>>>>>>>>>            End
77799>>>>>>>>>>
77799>>>>>>>>>            Get ParseKeyWord sConnect "UID"     to sUsername
77800>>>>>>>>>            Get ParseKeyWord sConnect "PWD"     to sPassword
77801>>>>>>>>>        End
77801>>>>>>>>>>
77801>>>>>>>>>        Else Begin
77802>>>>>>>>>            Move sUID                           to sUsername
77803>>>>>>>>>            Move sPWD                           to sPassword
77804>>>>>>>>>        End
77804>>>>>>>>>>
77804>>>>>>>>>
77804>>>>>>>>>        Set psUsername of hSql to sUsername
77805>>>>>>>>>        Set psPassword of hSql to sPassword
77806>>>>>>>>>
77806>>>>>>>>>        Get SQLConnect of hSql sDriver sServer to bOK
77807>>>>>>>>>        If (not(bOK)) Begin
77809>>>>>>>>>            Send FreeHandle of hSQL
77810>>>>>>>>>            Function_Return 0
77811>>>>>>>>>        End
77811>>>>>>>>>>
77811>>>>>>>>>
77811>>>>>>>>>        Function_Return hSql
77812>>>>>>>>>    End_Function
77813>>>>>>>>>
77813>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
77815>>>>>>>>>        Handle hSql
77815>>>>>>>>>        Boolean bOK
77815>>>>>>>>>
77815>>>>>>>>>        //*** Allocate a new handle
77815>>>>>>>>>        Get CreateHandle to hSql
77816>>>>>>>>>        Get SQLFileConnect of hSql iFileNum to bOK
77817>>>>>>>>>
77817>>>>>>>>>        //*** If failure, kill the handle and return a 0 handle
77817>>>>>>>>>        If (not(bOK)) Begin
77819>>>>>>>>>            Send FreeHandle of hSql
77820>>>>>>>>>            Function_Return 0
77821>>>>>>>>>        End
77821>>>>>>>>>>
77821>>>>>>>>>
77821>>>>>>>>>        Function_Return hSql
77822>>>>>>>>>    End_Function
77823>>>>>>>>>
77823>>>>>>>>>End_Class
77824>>>>>>>>>
77824>>>>>>>>>
77824>>>>>>>>>Function CreateSQLmanager for cDesktop Returns Integer
77826>>>>>>>>>    Handle hSqlManager
77826>>>>>>>>>
77826>>>>>>>>>    Get Create (RefClass(cSQLHandleManagerDUF)) to hSqlManager
77827>>>>>>>>>    Function_Return hSqlManager
77828>>>>>>>>>End_Function
77829>>>>>>>>>
77829>>>>>>>>>
77829>>>>>>>>>
77829>>>>>>>>>
77829>>>>>>>>>Get CreateSQLManager of Desktop to _embsqlghoSQLHandleMngr
77830>>>>>>>>>
77830>>>>>>>    Use Mertech.inc
77830>>>>>>>
77830>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
77830>>>>>>>>>Use DUFLanguageConstants.inc
77830>>>>>>>>>
77830>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
77830>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
77830>>>>>>>>>
77830>>>>>>>>>    Define DATAFLEX_ID for "DATAFLEX"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_OEM_Txt for "OEM"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_SERVER for "SERVER"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
77830>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
77830>>>>>>>>>
77830>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
77830>>>>>>>>>
77830>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
77830>>>>>>>>>    Global_Variable Handle ghoDbUpdateHandler    
77830>>>>>>>>>    Move 0 to ghoDbUpdateHandler
77831>>>>>>>>>
77831>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
77831>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
77832>>>>>>>>>
77832>>>>>>>>>Struct tSQLScriptArray
77832>>>>>>>>>    Boolean bError
77832>>>>>>>>>    Boolean bArgumentSizeChanged
77832>>>>>>>>>    Integer iOrgArgumentSize
77832>>>>>>>>>    String[] sSQLScriptArray
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tSqlErrorArray
77832>>>>>>>>>    String[]  sSqlErrorArray
77832>>>>>>>>>    String[]  sSqlStatementArray
77832>>>>>>>>>    Integer[] iSqlErrorArray
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tSqlColumnNew
77832>>>>>>>>>    String  sBaseColumnName
77832>>>>>>>>>    String  sBaseTableName
77832>>>>>>>>>    String  sLabel
77832>>>>>>>>>    Integer iSqlType
77832>>>>>>>>>    Integer iSize
77832>>>>>>>>>    Integer iPrecision
77832>>>>>>>>>    Integer iDFType
77832>>>>>>>>>    Integer iDFNativeType
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tColumnType
77832>>>>>>>>>    String  sSQLType
77832>>>>>>>>>    Integer iSQLType
77832>>>>>>>>>    Boolean bCanEditSize
77832>>>>>>>>>    Integer iDefaultSize
77832>>>>>>>>>    Integer iMinSize
77832>>>>>>>>>    Number  nMaxSize
77832>>>>>>>>>    String  sDataFlexType
77832>>>>>>>>>    Integer iDataFlexType
77832>>>>>>>>>    Boolean bNativeDataType
77832>>>>>>>>>    String  sPrecision
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
77832>>>>>>>>>// Various SQL back-ends can have slightly different
77832>>>>>>>>>// keywords.
77832>>>>>>>>>Struct tSQLKeyWords
77832>>>>>>>>>    Integer iSQLWord
77832>>>>>>>>>    Integer iSQLDbType
77832>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tSQLRelation
77832>>>>>>>>>    Integer iFileNumber
77832>>>>>>>>>    Integer iFieldNumber
77832>>>>>>>>>    String  sFileName
77832>>>>>>>>>    String  sFieldName
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tSQLLoggedInUser
77832>>>>>>>>>    String sUser
77832>>>>>>>>>    String sProgram
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
77832>>>>>>>>>Enumeration_List
77832>>>>>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
77832>>>>>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
77832>>>>>>>>>End_Enumeration_List
77832>>>>>>>>>
77832>>>>>>>>>// We need to re-define the standard constants because several driver constants
77832>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
77832>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
77832>>>>>>>>>// They can have slightly different SQL keywords.
77832>>>>>>>>>// Note: If a new type is added to the list,
77832>>>>>>>>>//       the struct array xxx must be adjusted
77832>>>>>>>>>//       so that it is filled with all SQL
77832>>>>>>>>>//       keywords for that new type.
77832>>>>>>>>>Enum_List
77832>>>>>>>>>    Define EN_DbTypeDataFlex   for 0
77832>>>>>>>>>    Define EN_DbTypeMSSQL      for 1
77832>>>>>>>>>    Define EN_DbTypeMySQL      for 2
77832>>>>>>>>>    Define EN_DbTypeOracle     for 3
77832>>>>>>>>>    Define EN_DbTypeDB2        for 4
77832>>>>>>>>>    Define EN_DbTypePostgre    for 5
77832>>>>>>>>>    Define EN_DbTypePervasive  for 6
77832>>>>>>>>>//    Define EN_DbTypeMSSQL
77832>>>>>>>>>//    Define EN_DbTypeMySQL
77832>>>>>>>>>//    Define EN_DbTypeOracle
77832>>>>>>>>>//    Define EN_DbTypeDB2
77832>>>>>>>>>//    Define EN_DbTypePostgre
77832>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
77832>>>>>>>>>End_Enum_List
77832>>>>>>>>>
77832>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
77832>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
77832>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
77832>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
77832>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
77832>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
77832>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
77832>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
77832>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
77832>>>>>>>>>
77832>>>>>>>>>// We need to re-define the standard constants because several driver constants
77832>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
77832>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
77832>>>>>>>>>Enum_List
77832>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
77832>>>>>>>>>    Define DF_BCD_DUF       for -1499
77832>>>>>>>>>    Define DF_DATE_DUF      for -1498
77832>>>>>>>>>    Define DF_TEXT_DUF      for -1495
77832>>>>>>>>>    Define DF_BINARY_DUF    for -1494
77832>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
77832>>>>>>>>>End_Enum_List
77832>>>>>>>>>
77832>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
77832>>>>>>>>>
77832>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
77832>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
77832>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
77832>>>>>>>>>
77832>>>>>>>>>// These are not defined pre DF 18:
77832>>>>>>>>>
77832>>>>>>>>>Struct tSQLIntTableInfo
77832>>>>>>>>>    String sDriverName
77832>>>>>>>>>    String sServerName
77832>>>>>>>>>    String sDatabaseName
77832>>>>>>>>>    String sSchemaName
77832>>>>>>>>>    Boolean bRecnumTable
77832>>>>>>>>>    Integer iPrimaryIndex
77832>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
77832>>>>>>>>>    String sTableCharacterFormat
77832>>>>>>>>>    Boolean bUseDummyZeroDate
77832>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
77832>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
77832>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
77832>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
77832>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
77832>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
77832>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
77832>>>>>>>>>    String sFileIndexTablespace
77832>>>>>>>>>    String sFileLongTablespace
77832>>>>>>>>>    String sTableTablespace
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tSQLIntColumnInfo
77832>>>>>>>>>    Integer iFieldNumber
77832>>>>>>>>>    Integer iFieldIndex
77832>>>>>>>>>    Integer iFieldRelatedFile
77832>>>>>>>>>    Integer iFieldRelatedField
77832>>>>>>>>>    Integer iIndexNumber
77832>>>>>>>>>    Integer iIndexNumberSegments
77832>>>>>>>>>    Integer iIndexSegmentField1
77832>>>>>>>>>    Integer iIndexSegmentField2
77832>>>>>>>>>    Integer iIndexSegmentFieldn
77832>>>>>>>>>    String  sIndexName
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tAPIColumn
77832>>>>>>>>>    Integer iFieldNumber
77832>>>>>>>>>    String  sFieldName
77832>>>>>>>>>    Integer iType
77832>>>>>>>>>    String  sType
77832>>>>>>>>>    Integer iLength
77832>>>>>>>>>    Integer iPrecision
77832>>>>>>>>>    Integer iOptions
77832>>>>>>>>>    Boolean bIsSQLType
77832>>>>>>>>>    Boolean bAllowNULL
77832>>>>>>>>>    String  sDefaultValue
77832>>>>>>>>>    Boolean bShouldChange
77832>>>>>>>>>    Boolean bCancel
77832>>>>>>>>>    Boolean bError
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tAPIColumnCompare
77832>>>>>>>>>    Integer iFieldNumber
77832>>>>>>>>>    // FROM database:
77832>>>>>>>>>    Boolean bExistsFrom
77832>>>>>>>>>    String  sFieldNameFrom
77832>>>>>>>>>    Integer iTypeFrom
77832>>>>>>>>>    String  sTypeFrom
77832>>>>>>>>>    Integer iLengthFrom
77832>>>>>>>>>    Integer iPrecisionFrom
77832>>>>>>>>>    Integer iOptionsFrom
77832>>>>>>>>>    Boolean bIsSQLTypeFrom
77832>>>>>>>>>    Boolean bAllowNULLFrom
77832>>>>>>>>>    String  sDefaultValueFrom
77832>>>>>>>>>    Boolean bShouldChangeFrom
77832>>>>>>>>>    Boolean bCancelFrom
77832>>>>>>>>>    Boolean bErrorFrom
77832>>>>>>>>>    // TO database:
77832>>>>>>>>>    Boolean bExistsTo
77832>>>>>>>>>    Integer iFieldNumberTo
77832>>>>>>>>>    String  sFieldNameTo
77832>>>>>>>>>    Integer iTypeTo
77832>>>>>>>>>    String  sTypeTo
77832>>>>>>>>>    Integer iLengthTo
77832>>>>>>>>>    Integer iPrecisionTo
77832>>>>>>>>>    Integer iOptionsTo
77832>>>>>>>>>    Boolean bIsSQLTypeTo
77832>>>>>>>>>    Boolean bAllowNULLTo
77832>>>>>>>>>    String  sDefaultValueTo
77832>>>>>>>>>    Boolean bShouldChangeTo
77832>>>>>>>>>    Boolean bCancelTo
77832>>>>>>>>>    Boolean bErrorTo
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tAPIRelation
77832>>>>>>>>>    Handle  hTableFrom
77832>>>>>>>>>    Integer iColumnFrom
77832>>>>>>>>>    Handle  hTableTo
77832>>>>>>>>>    Integer iColumnTo
77832>>>>>>>>>    String  sLogicalNameFrom
77832>>>>>>>>>    String  sLogicalNameTo
77832>>>>>>>>>    String  sFieldNameFrom
77832>>>>>>>>>    String  sFieldNameTo
77832>>>>>>>>>    Boolean bShouldChange
77832>>>>>>>>>    Boolean bCancel
77832>>>>>>>>>    Boolean bError
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tAPIRelationCompare
77832>>>>>>>>>    // Common:
77832>>>>>>>>>    Handle  hTableFrom
77832>>>>>>>>>    Integer iColumnFrom
77832>>>>>>>>>    Handle  hTableTo
77832>>>>>>>>>    Integer iColumnTo
77832>>>>>>>>>    // FROM database:
77832>>>>>>>>>    Boolean bExistsFrom
77832>>>>>>>>>    String  sLogicalNameFrom_From
77832>>>>>>>>>    String  sLogicalNameTo_From
77832>>>>>>>>>    String  sFieldNameFrom_From
77832>>>>>>>>>    String  sFieldNameTo_From
77832>>>>>>>>>    Boolean bShouldChange_From
77832>>>>>>>>>    Boolean bCancel_From
77832>>>>>>>>>    Boolean bError_From
77832>>>>>>>>>    // TO database:
77832>>>>>>>>>    Boolean bExistsTo
77832>>>>>>>>>    String  sLogicalNameFrom_To
77832>>>>>>>>>    String  sLogicalNameTo_To
77832>>>>>>>>>    String  sFieldNameFrom_To
77832>>>>>>>>>    String  sFieldNameTo_To
77832>>>>>>>>>    Boolean bShouldChange_To
77832>>>>>>>>>    Boolean bCancel_To
77832>>>>>>>>>    Boolean bError_To
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tAPIIndexSegment
77832>>>>>>>>>    Integer iFieldNumber
77832>>>>>>>>>    String  sFieldName
77832>>>>>>>>>    Boolean bUppercase
77832>>>>>>>>>    Boolean bAscending
77832>>>>>>>>>    Boolean bShouldChange
77832>>>>>>>>>    Boolean bCancel
77832>>>>>>>>>    Boolean bError
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tAPIIndex
77832>>>>>>>>>    Integer iIndexNumber
77832>>>>>>>>>    Integer iPrimaryIndex
77832>>>>>>>>>    String  sSQLIndexName
77832>>>>>>>>>    Integer iSQLIndexType
77832>>>>>>>>>    Boolean bIsSQLClustered
77832>>>>>>>>>    Boolean bIsSQLPrimaryKey
77832>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
77832>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
77832>>>>>>>>>    Boolean bShouldChange
77832>>>>>>>>>    Boolean bCancel
77832>>>>>>>>>    Boolean bError
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tAPIIndexCompare
77832>>>>>>>>>    // Common:
77832>>>>>>>>>    Integer iIndexNumber
77832>>>>>>>>>    // FROM database:
77832>>>>>>>>>    Boolean bExistsFrom
77832>>>>>>>>>    Integer iPrimaryIndexFrom
77832>>>>>>>>>    String  sSQLIndexNameFrom
77832>>>>>>>>>    Integer iSQLIndexTypeFrom
77832>>>>>>>>>    Boolean bIsSQLClusteredFrom
77832>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
77832>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
77832>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
77832>>>>>>>>>    Boolean bShouldChangeFrom
77832>>>>>>>>>    Boolean bCancelFrom
77832>>>>>>>>>    Boolean bErrorFrom
77832>>>>>>>>>    // TO database:
77832>>>>>>>>>    Boolean bExistsTo
77832>>>>>>>>>    Integer iPrimaryIndexTo
77832>>>>>>>>>    String  sSQLIndexNameTo
77832>>>>>>>>>    Integer iSQLIndexTypeTo
77832>>>>>>>>>    Boolean bIsSQLClusteredTo
77832>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
77832>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
77832>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
77832>>>>>>>>>    Boolean bShouldChangeTo
77832>>>>>>>>>    Boolean bCancelTo
77832>>>>>>>>>    Boolean bErrorTo
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tAPITableNameInfo
77832>>>>>>>>>    Integer iTableNumber
77832>>>>>>>>>    String  sRootName
77832>>>>>>>>>    String  sLogicalName
77832>>>>>>>>>    String  sDisplayName
77832>>>>>>>>>    String  sDriverID
77832>>>>>>>>>    Boolean bIsAlias
77832>>>>>>>>>    Boolean bIsSQL
77832>>>>>>>>>    Boolean bIsSystemFile
77832>>>>>>>>>    Boolean bShouldChange
77832>>>>>>>>>    Boolean bCancel
77832>>>>>>>>>    Boolean bError
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tAPITableNameInfoCompare
77832>>>>>>>>>    Integer iTableNumber
77832>>>>>>>>>    // FROM
77832>>>>>>>>>    Boolean bExistsFrom
77832>>>>>>>>>    String  sRootNameFrom
77832>>>>>>>>>    String  sLogicalNameFrom
77832>>>>>>>>>    String  sDisplayNameFrom
77832>>>>>>>>>    String  sDriverIDFrom
77832>>>>>>>>>    Boolean bIsAliasFrom
77832>>>>>>>>>    Boolean bIsSQLFrom
77832>>>>>>>>>    Boolean bIsSystemFileFrom
77832>>>>>>>>>    // TO database:
77832>>>>>>>>>    Boolean bExistsTo
77832>>>>>>>>>    String  sRootNameTo
77832>>>>>>>>>    String  sLogicalNameTo
77832>>>>>>>>>    String  sDisplayNameTo
77832>>>>>>>>>    String  sDriverIDTo
77832>>>>>>>>>    Boolean bIsAliasTo
77832>>>>>>>>>    Boolean bIsSQLTo
77832>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
77832>>>>>>>>>    Boolean bShouldChange
77832>>>>>>>>>    Boolean bCancel
77832>>>>>>>>>    Boolean bError
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tAPITable
77832>>>>>>>>>    Handle hTable
77832>>>>>>>>>    Boolean bFromTable
77832>>>>>>>>>    Boolean bToTable
77832>>>>>>>>>    tAPITableNameInfo ApiTableInfo
77832>>>>>>>>>    tAPITableNameInfo ApiTableInfo
77832>>>>>>>>>    tAPIColumn[]      aApiColumns
77832>>>>>>>>>    tAPIColumn[]      aApiColumns
77832>>>>>>>>>    tAPIIndex[]       aApiIndexes
77832>>>>>>>>>    tAPIIndex[]       aApiIndexes
77832>>>>>>>>>    tAPIRelation[]    aApiRelations
77832>>>>>>>>>    tAPIRelation[]    aApiRelations
77832>>>>>>>>>    Boolean bShouldChange
77832>>>>>>>>>    Boolean bCancel
77832>>>>>>>>>    Boolean bError
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tAPITableCompare
77832>>>>>>>>>    Handle hTable
77832>>>>>>>>>    // FROM database:
77832>>>>>>>>>    Boolean bExistsFrom
77832>>>>>>>>>    // TO database:
77832>>>>>>>>>    Boolean bExistsTo
77832>>>>>>>>>    // Both:
77832>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
77832>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
77832>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
77832>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
77832>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
77832>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
77832>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
77832>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
77832>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
77832>>>>>>>>>    Boolean bCancel         // User cancel
77832>>>>>>>>>    Boolean bError          // Error occured while collecting data
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Struct tAPITableBooleans
77832>>>>>>>>>    Boolean bApiTableUpdateAuto
77832>>>>>>>>>    Boolean bCompareDate_DateTime
77832>>>>>>>>>    Boolean bCompareIndexAscending
77832>>>>>>>>>    Boolean bCompareIndexUppercase
77832>>>>>>>>>    Boolean bCompareFilelistUppercase
77832>>>>>>>>>End_Struct
77832>>>>>>>>>
77832>>>>>>>>>Define C_tAPIColumn_None for 0
77832>>>>>>>>>Define C_tAPIColumn_Identity for 1
77832>>>>>>>>>
77832>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
77832>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
77832>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
77832>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
77832>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
77832>>>>>>>>>Enum_List
77832>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
77832>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
77832>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
77832>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
77832>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
77832>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
77832>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
77832>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
77832>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
77832>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
77832>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
77832>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
77832>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
77832>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
77832>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
77832>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
77832>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
77832>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
77832>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
77832>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
77832>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
77832>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
77832>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
77832>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
77832>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
77832>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
77832>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
77832>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
77832>>>>>>>>>    Define CI_SQLTo                    //for "TO"
77832>>>>>>>>>    Define CI_SQLGO                    //for "GO"
77832>>>>>>>>>    Define CI_SQLUse                   //for "USE"
77832>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
77832>>>>>>>>>
77832>>>>>>>>>    Define CI_SQLName                  //for "NAME"
77832>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
77832>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
77832>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
77832>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
77832>>>>>>>>>    Define CI_SQLID                    //for "ID"
77832>>>>>>>>>    Define CI_SQLAND                   //for "AND"
77832>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
77832>>>>>>>>>    Define CI_SQLSet                   //for "SET"
77832>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
77832>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
77832>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
77832>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
77832>>>>>>>>>End_Enum_List
77832>>>>>>>>>
77832>>>>>>>>>
77832>>>>>
77832>>>>>// This needs to be after Mertech drivers are defined.
77832>>>>>//Use cDbUpdateFunctionLibrary_Mixin.pkg
77832>>>>>
77832>>>>>
77832>>>>>// Create a new PSQL identifier for the Btrieve driver.
77832>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
77832>>>>>
77832>>>>>
77832>>>>>
77832>>>>>
77832>>>>>
77832>>>>>
77832>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
77832>>>>>// They can have slightly different SQL keywords.
77832>>>>>// Note: If a new type is added to the list,
77832>>>>>//       the struct array xxx must be adjusted
77832>>>>>//       so that it is filled with all SQL
77832>>>>>//       keywords for that new type.
77832>>>>>Enum_List  
77832>>>>>End_Enum_List
77832>>>>>
77832>>>>>// We need to have our "own" constants for the standard DataFlex data types.
77832>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
77832>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
77832>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
77832>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
77832>>>>>Define CS_DbTypeMySQL       for "MySQL"
77832>>>>>Define CS_DbTypeOracle      for "Oracle"
77832>>>>>Define CS_DbTypeDB2         for "IBM DB2"
77832>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
77832>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
77832>>>>>
77832>>>>>
77832>>>>>// SQLConnection.ini constants:
77832>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
77832>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
77832>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
77832>>>>>Define CS_SQLIniSectionName             for "Connection"
77832>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
77832>>>>>
77832>>>>>// DF 19 ini-file settings:
77832>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
77832>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
77832>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
77832>>>>>Define CS_SQLIniUIDKeyword              for "UID"
77832>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
77832>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
77832>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
77832>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
77832>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
77832>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
77832>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
77832>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
77832>>>>>
77832>>>>>// Database Update Framework extended settings:
77832>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
77832>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
77832>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
77832>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
77832>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
77832>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
77832>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
77832>>>>>
77832>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
77832>>>>>Define CS_SQLIniConnectionYes           for "Yes"
77832>>>>>Define CS_SQLIniConnectionNo            for "No"
77832>>>>>
77832>>>>>Struct tSQLConnection
77832>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
77832>>>>>    String sConnectionID            // 2. The name of the connection ID.
77832>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
77832>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
77832>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
77832>>>>>    String sDatabase                // 6. SQL Database
77832>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
77832>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
77832>>>>>    String sUserID                  // 9. User ID
77832>>>>>    String sPassword                // 10. Password
77832>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
77832>>>>>    String sBaseTableSpace          // 12. DB2 specific
77832>>>>>    String sLongTableSpace          // 13. DB2 specific
77832>>>>>    String sIndexTableSpace         // 14. DB2 specific
77832>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
77832>>>>>    Boolean bError                  // 16. Set to true on error.
77832>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
77832>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
77832>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
77832>>>>>End_Struct
77832>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
77832>>>>>Use cSQLConnectionIniFile.inc
77832>>>>>
77832>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
77833>>>>>    Procedure Construct_Object
77835>>>>>        Forward Send Construct_Object
77837>>>>>        Property String psDriverID DATAFLEX_ID
77838>>>>>    End_Procedure
77839>>>>>
77839>>>>>    Function ServerKeyword String sServer Returns String
77841>>>>>        String sRetval
77841>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
77843>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
77844>>>>>        End                                        
77844>>>>>>
77844>>>>>        Else Begin
77845>>>>>            Move CS_SQLIniDSNKeyword to sRetval
77846>>>>>        End
77846>>>>>>
77846>>>>>            
77846>>>>>        Function_Return sRetval
77847>>>>>    End_Function
77848>>>>>
77848>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77850>>>>>        String sConnect sServerKeyWord sDriverID
77850>>>>>
77850>>>>>        Get psDriverID to sDriverID
77851>>>>>        Get ServerKeyword sServer to sServerKeyWord
77852>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
77853>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
77855>>>>>            Move "" to sDatabase
77856>>>>>        End
77856>>>>>>
77856>>>>>        
77856>>>>>        // 2019-10-20 I think this was plain wrong for the DAW ODBC_DRV driver. At least it didn't work for login to an MS-SQL db.
77856>>>>>//        If (bTrusted = False and (sDriverID = ODBC_DRV_ID and sServerKeyWord = CS_SQLIniDSNKeyword)) Begin
77856>>>>>//            Function_Return sConnect
77856>>>>>//        End
77856>>>>>
77856>>>>>        If (sDatabase <> "") Begin
77858>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77859>>>>>        End
77859>>>>>>
77859>>>>>        If (bTrusted = True) Begin
77861>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
77862>>>>>        End
77862>>>>>>
77862>>>>>        Else Begin
77863>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
77864>>>>>        End
77864>>>>>>
77864>>>>>        Function_Return sConnect
77865>>>>>    End_Function
77866>>>>>
77866>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77868>>>>>        Boolean bLoginSuccessful
77868>>>>>        String sDriverID
77868>>>>>
77868>>>>>        Get psDriverID to sDriverID
77869>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77871>>>>>            Function_Return True
77872>>>>>        End
77872>>>>>>
77872>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77873>>>>>        If (bTrusted = False and sDatabase <> "") Begin
77875>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
77876>>>>>            Login sServer sUserId sPassword sDriverID  
77878>>>>>        End
77878>>>>>>
77878>>>>>        Else Begin
77879>>>>>            Login sConnectionString "" "" sDriverID
77881>>>>>        End
77881>>>>>>
77881>>>>>        Move (LastErr = 0) to bLoginSuccessful
77882>>>>>        Function_Return bLoginSuccessful
77883>>>>>    End_Function
77884>>>>>End_Class
77885>>>>>
77885>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
77886>>>>>    Function ServerKeyword String sServer Returns String
77888>>>>>        Function_Return CS_SQLIniServerKeyword
77889>>>>>    End_Function
77890>>>>>End_Class
77891>>>>>
77891>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
77892>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77894>>>>>        Boolean bLoginSuccessful
77894>>>>>        String sDriverID
77894>>>>>
77894>>>>>        Get psDriverID to sDriverID
77895>>>>>        Move (Trim(sDriverID)) to sDriverID
77896>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77898>>>>>            Function_Return True
77899>>>>>        End
77899>>>>>>
77899>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77900>>>>>        If (bTrusted = False) Begin
77902>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
77904>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
77905>>>>>            End
77905>>>>>>
77905>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77908>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77909>>>>>            End
77909>>>>>>
77909>>>>>            Login sServer sUserId sPassword sDriverID  
77911>>>>>        End
77911>>>>>>
77911>>>>>        Else Begin
77912>>>>>            Login sConnectionString "" "" sDriverID
77914>>>>>        End
77914>>>>>>
77914>>>>>        Move (LastErr = 0) to bLoginSuccessful
77915>>>>>
77915>>>>>        Function_Return bLoginSuccessful
77916>>>>>    End_Function
77917>>>>>End_Class
77918>>>>>
77918>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
77919>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77921>>>>>        Boolean bLoginSuccessful
77921>>>>>        String sDriverID
77921>>>>>
77921>>>>>        Move False to Err
77922>>>>>        Get psDriverID to sDriverID
77923>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77925>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77926>>>>>        End
77926>>>>>>
77926>>>>>        Login sServer sUserId sPassword sDriverID
77928>>>>>
77928>>>>>        Move (not(Err)) to bLoginSuccessful
77929>>>>>        Function_Return bLoginSuccessful
77930>>>>>    End_Function
77931>>>>>End_Class
77932>>>>>
77932>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
77933>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77935>>>>>        Boolean bLoginSuccessful
77935>>>>>        String sDriverID
77935>>>>>
77935>>>>>        Move False to Err
77936>>>>>        Get psDriverID to sDriverID
77937>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77937>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77937>>>>>//        End
77937>>>>>        Login sServer sUserId sPassword sDriverID
77939>>>>>
77939>>>>>        Move (not(Err)) to bLoginSuccessful
77940>>>>>        Function_Return bLoginSuccessful
77941>>>>>    End_Function
77942>>>>>End_Class
77943>>>>>
77943>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
77944>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77946>>>>>        Function_Return ""
77947>>>>>    End_Function
77948>>>>>End_Class
77949>>>>>
77949>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
77950>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77952>>>>>        Boolean bLoginSuccessful
77952>>>>>        String sDriverID
77952>>>>>
77952>>>>>        Get psDriverID to sDriverID
77953>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
77953>>>>>        Move False to Err
77954>>>>>        If (bTrusted = False) Begin
77956>>>>>            Login sServer sUserId sPassword sDriverID
77958>>>>>        End
77958>>>>>>
77958>>>>>        Else Begin
77959>>>>>            Login sServer "" "" sDriverID
77961>>>>>        End
77961>>>>>>
77961>>>>>        Move (not(Err)) to bLoginSuccessful
77962>>>>>
77962>>>>>        Function_Return bLoginSuccessful
77963>>>>>    End_Function
77964>>>>>End_Class
77965>>>>>
77965>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
77966>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77968>>>>>        Boolean bLoginSuccessful
77968>>>>>        String sDriverID
77968>>>>>        Integer iPos
77968>>>>>
77968>>>>>        Get psDriverID to sDriverID
77969>>>>>        Move (Pos("/", sServer)) to iPos
77970>>>>>        If (iPos = 0) Begin
77972>>>>>            If (sDatabase <> "") Begin
77974>>>>>                Move (sServer + "/" + sDatabase) to sServer
77975>>>>>            End
77975>>>>>>
77975>>>>>        End
77975>>>>>>
77975>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
77975>>>>>        Move False to Err
77976>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
77976>>>>>        Login sServer sUserId sPassword sDriverID
77978>>>>>
77978>>>>>        Move (not(Err)) to bLoginSuccessful
77979>>>>>        Function_Return bLoginSuccessful
77980>>>>>    End_Function
77981>>>>>End_Class
77982>>>>>
77982>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
77983>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77985>>>>>        Boolean bLoginSuccessful
77985>>>>>        String sDriverID
77985>>>>>
77985>>>>>        Get psDriverID to sDriverID
77986>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
77986>>>>>        Move False to Err
77987>>>>>        If (bTrusted = False) Begin
77989>>>>>            Login sServer sUserId sPassword sDriverID
77991>>>>>        End
77991>>>>>>
77991>>>>>        Else Begin
77992>>>>>            Login sServer "" "" sDriverID
77994>>>>>        End
77994>>>>>>
77994>>>>>        Move (not(Err)) to bLoginSuccessful
77995>>>>>        Function_Return bLoginSuccessful
77996>>>>>    End_Function
77997>>>>>End_Class
77998>>>>>
77998>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
77999>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
78001>>>>>        Boolean bLoginSuccessful
78001>>>>>        String sDriverID
78001>>>>>
78001>>>>>        Get psDriverID to sDriverID
78002>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
78002>>>>>        Move False to Err
78003>>>>>        If (bTrusted = False) Begin
78005>>>>>            Login sServer sUserId sPassword sDriverID
78007>>>>>        End
78007>>>>>>
78007>>>>>        Else Begin
78008>>>>>            Login sServer "" "" sDriverID
78010>>>>>        End
78010>>>>>>
78010>>>>>        Move (not(Err)) to bLoginSuccessful
78011>>>>>        Function_Return bLoginSuccessful
78012>>>>>    End_Function
78013>>>>>End_Class
78014>>>>>
78014>>>>>Class cDbUpdateDatabaseDriver is a cObject
78015>>>>>    Procedure Construct_Object
78017>>>>>        Forward Send Construct_Object
78019>>>>>        Property String psDriverID DATAFLEX_ID
78020>>>>>        Property Handle phoDriverSpecificObject
78021>>>>>    End_Procedure
78022>>>>>
78022>>>>>    Function CreateDriver Returns Handle
78024>>>>>        String sDriverID
78024>>>>>        Handle hoDriver hcDriverClass
78024>>>>>
78024>>>>>        Get psDriverID to sDriverID
78025>>>>>        Case Begin
78025>>>>>            Case (sDriverID = MSSQLDRV_ID)
78027>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
78028>>>>>                Case Break
78029>>>>>            Case (sDriverID = ODBC_DRV_ID)
78032>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
78033>>>>>                Case Break
78034>>>>>            Case (sDriverID = DB2_DRV_ID)
78037>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
78038>>>>>                Case Break               
78039>>>>>//            Case (sDriverID = DFBTRDRV_ID)
78039>>>>>//                Move (RefClass(cDbUpdateDatabaseDriver)) to hcDriverClass
78039>>>>>//                Case Break
78039>>>>>            Case (sDriverID = SQLFLEX)
78042>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
78043>>>>>                Case Break
78044>>>>>            Case (sDriverID = ORAFLEX)
78047>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
78048>>>>>                Case Break
78049>>>>>            Case (sDriverID = MDSPgSQL)
78052>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
78053>>>>>                Case Break
78054>>>>>            Case (sDriverID = MDSMySQL)
78057>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
78058>>>>>                Case Break
78059>>>>>            // DATAFLEX_ID = Default driver
78059>>>>>            Case Else
78059>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
78060>>>>>                Move DATAFLEX_ID to sDriverID
78061>>>>>        Case End
78061>>>>>
78061>>>>>        Get Create hcDriverClass to hoDriver
78062>>>>>        Set psDriverID of hoDriver to sDriverID
78063>>>>>        Set phoDriverSpecificObject to hoDriver
78064>>>>>
78064>>>>>        Function_Return hoDriver
78065>>>>>    End_Function
78066>>>>>
78066>>>>>    Procedure DestroyDriver
78068>>>>>        If (phoDriverSpecificObject(Self)) Begin
78070>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
78071>>>>>        End
78071>>>>>>
78071>>>>>    End_Procedure
78072>>>>>
78072>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78074>>>>>        String sConnect
78074>>>>>        Handle hoDriver
78074>>>>>
78074>>>>>        Get CreateDriver to hoDriver
78075>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
78076>>>>>        Send DestroyDriver
78077>>>>>        Function_Return sConnect
78078>>>>>    End_Function
78079>>>>>
78079>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
78081>>>>>        Boolean bLoginSuccessful
78081>>>>>        Handle hoDriver
78081>>>>>
78081>>>>>        Get CreateDriver to hoDriver
78082>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
78083>>>>>        Send DestroyDriver
78084>>>>>        Function_Return bLoginSuccessful
78085>>>>>    End_Function
78086>>>>>
78086>>>>>End_Class
78087>>>
78087>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cLoginEncryption.pkg)
78087>>>>>Use cCryptographer.pkg
78087>>>>>
78087>>>>>Class cLoginEncryption is a cObject
78088>>>>>    
78088>>>>>    Procedure Construct_Object
78090>>>>>        Forward Send Construct_Object
78092>>>>>        // this must be set to a multi (40ish) character random key
78092>>>>>        Property String psEncryptPassword ""
78093>>>>>        
78093>>>>>        Object oDataCrypter is a cCryptographer
78095>>>>>            Set piHash to CALG_SHA_256
78096>>>>>            Set piCipher to CALG_AES_256
78097>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
78098>>>>>            Set piProvider to PROV_RSA_AES
78099>>>>>        End_Object
78100>>>>>    End_Procedure
78101>>>>>    
78101>>>>>    // This can be augmented to return a password encryption key using any
78101>>>>>    // hidden mechanism desired.
78101>>>>>    Function GetEncryptionPassword Returns String
78103>>>>>        String sPassword
78103>>>>>        Get psEncryptPassword to sPassword
78104>>>>>        Function_Return sPassword
78105>>>>>    End_Function
78106>>>>>    
78106>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
78106>>>>>    //
78106>>>>>    // Params:
78106>>>>>    //   sPlainText     String to encrypt.
78106>>>>>    // Returns:
78106>>>>>    //   Base64 encoded hash.
78106>>>>>    Function EncryptPassword String sPlainText Returns String
78108>>>>>        String sEncryptPassword sBinary sBase64
78108>>>>>        Address pBase64
78108>>>>>        Integer iVoid
78108>>>>>        
78108>>>>>        //  Encrypt Key
78108>>>>>        Get GetEncryptionPassword to sEncryptPassword
78109>>>>>        If (sEncryptPassword = "") Begin
78111>>>>>            Error DFERR_PROGRAM "No encryption password set"
78112>>>>>>
78112>>>>>        End
78112>>>>>>
78112>>>>>        
78112>>>>>        Get Encrypt of oDataCrypter sEncryptPassword sPlainText to sBinary
78113>>>>>        
78113>>>>>        If (sPlainText = sBinary or sBinary = "") Begin
78115>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
78116>>>>>>
78116>>>>>            Function_Return ""
78117>>>>>        End
78117>>>>>>
78117>>>>>        
78117>>>>>        //  Encode binary hash to Base64
78117>>>>>        Move (Base64Encode(AddressOf(sBinary), Length(sBinary))) to pBase64
78118>>>>>        Move pBase64 to sBase64
78119>>>>>        Move (Free(pBase64)) to iVoid
78120>>>>>        
78120>>>>>        Function_Return sBase64
78121>>>>>    End_Function
78122>>>>>    
78122>>>>>    
78122>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
78122>>>>>    //
78122>>>>>    // Params:
78122>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
78122>>>>>    // Returns:
78122>>>>>    //   Readable plain text password
78122>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
78124>>>>>        String sEncryptPassword sPlainText sBinary
78124>>>>>        Boolean bIsHex
78124>>>>>        Integer iLen iVoid
78124>>>>>        Address pBinary
78124>>>>>        
78124>>>>>        If (sBase64EncryptedPassword <> "") Begin
78126>>>>>            //  Decode from Base64
78126>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
78127>>>>>            
78127>>>>>            Move (Repeat(Character(0), iLen)) to sBinary
78128>>>>>            Move (CopyMemory(AddressOf(sBinary), pBinary, iLen)) to iVoid
78129>>>>>            
78129>>>>>            Move (Free(pBinary)) to iVoid
78130>>>>>            
78130>>>>>            //  Encrypted binary hash to string
78130>>>>>            Get GetEncryptionPassword to sEncryptPassword
78131>>>>>            Get Decrypt of oDataCrypter sEncryptPassword sBinary to sPlainText
78132>>>>>        End
78132>>>>>>
78132>>>>>        
78132>>>>>        Function_Return sPlainText
78133>>>>>    End_Function
78134>>>>>End_Class
78135>>>
78135>>>Class cSQLConnectionIniFile is a cIniFile
78136>>>    Procedure Construct_Object
78138>>>        Forward Send Construct_Object
78140>>>
78140>>>        Property String Private_psIniFilePath
78141>>>        Property String Private_psIniFileName CS_SQLIniFileName
78142>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
78143>>>
78143>>>        Property Boolean pbDFConnId False
78144>>>
78144>>>        // *** You really want to change this value! ***
78144>>>        // It is used when encrypting/decrypting passwords.
78144>>>        Property String psHashString "zx!2139(LI0+?ips7433"
78145>>>
78145>>>    End_Procedure
78146>>>
78146>>>    Procedure End_Construct_Object
78148>>>        Forward Send End_Construct_Object
78150>>>    End_Procedure
78151>>>
78151>>>    Procedure Set psIniFilePath String sPath
78153>>>        String sIniFile
78153>>>        Get vFolderFormat sPath to sPath
78154>>>        Set private_psIniFilePath to sPath
78155>>>        Get psIniFileName to sIniFile
78156>>>        Set psFileName to (sPath + sIniFile)
78157>>>    End_Procedure
78158>>>
78158>>>    Function psIniFilePath Returns String
78160>>>        Function_Return (private_psIniFilePath(Self))
78161>>>    End_Function
78162>>>
78162>>>    Procedure Set psIniFileName String sFileName
78164>>>        String sPath
78164>>>        Get psIniFilePath to sPath
78165>>>        Set psFileName to (sPath + sFileName)
78166>>>        Set private_psIniFileName to sFileName
78167>>>    End_Procedure
78168>>>
78168>>>    Function psIniFileName Returns String
78170>>>        Function_Return (private_psIniFileName(Self))
78171>>>    End_Function
78172>>>
78172>>>    // *** Generalized messages to Get & Set values of the ini file.
78172>>>    // Sets a value in the program's ini file (write)
78172>>>    // Pass a section name, the value name parameter and the value itself to be written.
78172>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
78174>>>        String sIniFile sPath
78174>>>
78174>>>        Get psIniFilePath to sPath
78175>>>        Get psIniFileName to sIniFile
78176>>>        Move (sPath + sIniFile) to sIniFile
78177>>>        Set psFileName to sIniFile
78178>>>        Send WriteString sSection sValueName sValue
78179>>>    End_Procedure
78180>>>
78180>>>    // Get a value from program's ini-file (read)
78180>>>    // Pass a section name and the name of the value parameter & a default value.
78180>>>    // Returns the value
78180>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
78182>>>        String sValue sIniFile sPath
78182>>>
78182>>>        Get psIniFilePath to sPath
78183>>>        Get psIniFileName to sIniFile
78184>>>        Move (sPath + sIniFile) to sIniFile
78185>>>        Set psFileName to sIniFile
78186>>>        Get ReadString sSection sValueName sDefaultValue to sValue
78187>>>
78187>>>        Function_Return sValue
78188>>>    End_Function
78189>>>
78189>>>    // Sort function that first sorts on bEnabled & then on the connection string.
78189>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
78191>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
78194>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
78197>>>
78197>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
78200>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
78203>>>
78203>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
78206>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
78209>>>
78209>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
78212>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
78215>>>
78215>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
78218>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
78221>>>
78221>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
78224>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
78227>>>
78227>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
78230>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
78233>>>
78233>>>        Function_Return (EQ)
78234>>>    End_Function
78235>>>
78235>>>    Function SQLIniFileNumberOfConnections Returns Integer
78237>>>        Handle hoSections
78237>>>        Integer iItems
78237>>>
78237>>>        Send ReadSections hoSections
78238>>>        Move (Item_Count(hoSections)) to iItems
78239>>>        Function_Return iItems
78240>>>    End_Function
78241>>>
78241>>>    // The normal connection string looks something like this;
78241>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
78241>>>    // ...but the full connection string looks like this;
78241>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
78241>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
78241>>>//        String sSection
78241>>>//        Integer iCount
78241>>>//
78241>>>//        Move False to Err
78241>>>//        Get psIniSectionName to sSection
78241>>>//        Get SQLIniFileNumberOfConnections to iCount
78241>>>//        Increment iCount
78241>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
78241>>>//
78241>>>//        Function_Return (Err = False)
78241>>>//    End_Function
78241>>>
78241>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
78243>>>        Integer iCount
78243>>>        Boolean bExists
78243>>>        String sSection
78243>>>
78243>>>        Move False to Err
78244>>>        Move 1 to iCount
78245>>>        Get psIniSectionName to sSection
78246>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
78247>>>        While (bExists = True)
78251>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
78252>>>            Increment iCount
78253>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
78254>>>        Loop
78255>>>>
78255>>>        Function_Return (Err = False)
78256>>>    End_Function
78257>>>
78257>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
78259>>>        Integer iCount
78259>>>        String sSection
78259>>>        Boolean bExists
78259>>>
78259>>>        Move False to Err
78260>>>        Move 1 to iCount
78261>>>        Get psIniSectionName to sSection
78262>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
78263>>>        While (bExists = True)
78267>>>            If (iCount = iItem) Begin
78269>>>                Send DeleteSection sSection
78270>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
78270>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
78271>>>            End
78271>>>>
78271>>>            Increment iCount
78272>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
78273>>>        Loop
78274>>>>
78274>>>
78274>>>        Function_Return (Err = False)
78275>>>    End_Function
78276>>>
78276>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
78276>>>    // If it fails the returned struct member SQLConnection.bError = True.
78276>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
78278>>>        tSQLConnection[] SQLConnectionsArray
78278>>>        tSQLConnection[] SQLConnectionsArray
78279>>>        tSQLConnection   SQLConnection
78279>>>        tSQLConnection   SQLConnection
78279>>>        Integer iIndex
78279>>>
78279>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
78280>>>        If (iIndex = -1) Begin
78282>>>            Move True to SQLConnection.bError
78283>>>            Function_Return SQLConnection
78284>>>        End
78284>>>>
78284>>>
78284>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
78285>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
78286>>>
78286>>>        Function_Return SQLConnection
78287>>>    End_Function
78288>>>
78288>>>    // Returns -1 if the passed connection ID was not found, else the item number.
78288>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
78290>>>        tSQLConnection[] SQLConnectionsArray
78290>>>        tSQLConnection[] SQLConnectionsArray
78291>>>        Integer iRetval iCount iSize
78291>>>        String sValue
78291>>>        Boolean bExists
78291>>>
78291>>>        Move -1 to iRetval
78292>>>
78292>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
78293>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
78294>>>        Decrement iSize
78295>>>        For iCount from 0 to iSize
78301>>>>
78301>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
78302>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
78303>>>            If (bExists) Begin
78305>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
78306>>>                Move iSize to iCount         // We're done!
78307>>>            End
78307>>>>
78307>>>        Loop
78308>>>>
78308>>>
78308>>>        Function_Return iRetval
78309>>>    End_Function
78310>>>
78310>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
78310>>>    // Used to check that ConnectionID's are unique.
78310>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
78312>>>        Integer iCount iSize iItems
78312>>>        String sValue
78312>>>        Boolean bExists
78312>>>        tSQLConnection[] SQLConnectionsArray
78312>>>        tSQLConnection[] SQLConnectionsArray
78313>>>
78313>>>        Move 0 to iItems
78314>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
78315>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
78316>>>        Decrement iSize
78317>>>        For iCount from 0 to iSize
78323>>>>
78323>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
78324>>>            Move (sValue = sConnectionID) to bExists
78325>>>            If (bExists) Begin
78327>>>                Increment iItems
78328>>>            End
78328>>>>
78328>>>        Loop
78329>>>>
78329>>>
78329>>>        Function_Return (iItems > 1)
78330>>>    End_Function
78331>>>
78331>>>    // To update the SQLConnections.ini file with a new default Connection ID.
78331>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78333>>>        Boolean bOK
78333>>>        Integer iSize iCount
78333>>>        tSQLConnection[] SQLConnectionsArray
78333>>>        tSQLConnection[] SQLConnectionsArray
78334>>>        tSQLConnection SQLConnection
78334>>>        tSQLConnection SQLConnection
78334>>>        String sConnectionString
78334>>>
78334>>>        Move False to Err
78335>>>        Get psConnectionString to sConnectionString
78336>>>
78336>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
78337>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
78338>>>        Decrement iSize
78339>>>        // Set all current connection to inactive.
78339>>>        For iCount from 0 to iSize
78345>>>>
78345>>>            Move False to SQLConnectionsArray[iCount].bEnabled
78346>>>        Loop
78347>>>>
78347>>>
78347>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
78348>>>        Move True              to SQLConnection.bEnabled
78349>>>        Move sConnectionString to SQLConnection.sConnectionString
78350>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
78351>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
78352>>>
78352>>>        Function_Return (bOK = True)
78353>>>    End_Function
78354>>>
78354>>>    // Used for updating an existing connection with new data.
78354>>>    // Returns True if successful.
78354>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
78356>>>        Boolean bOK
78356>>>        Integer iItem iSize iCount
78356>>>        tSQLConnection[] SQLConnectionsArray
78356>>>        tSQLConnection[] SQLConnectionsArray
78357>>>
78357>>>        Move False to Err
78358>>>        Move -1 to iItem
78359>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
78360>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
78361>>>        Decrement iSize
78362>>>        // Set all current connection to inactive.
78362>>>        For iCount from 0 to iSize
78368>>>>
78368>>>            Move False to SQLConnectionsArray[iCount].bEnabled
78369>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
78371>>>                Move iCount to iItem
78372>>>            End
78372>>>>
78372>>>        Loop
78373>>>>
78373>>>
78373>>>        If (iItem <> -1) Begin
78375>>>            Move True to SQLConnection.bEnabled
78376>>>            Move SQLConnection to SQLConnectionsArray[iItem]
78377>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
78378>>>        End
78378>>>>
78378>>>
78378>>>        Function_Return (bOK = True)
78379>>>    End_Function
78380>>>
78380>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
78382>>>        tSQLConnection[] SQLConnectionsArray
78382>>>        tSQLConnection[] SQLConnectionsArray
78383>>>        String sSection sValue
78383>>>        Integer iCount
78383>>>        Boolean bExists
78383>>>
78383>>>        Get psIniSectionName to sSection
78384>>>        Get SectionExists sSection to bExists
78385>>>        If (bExists = False) Begin
78387>>>            Function_Return SQLConnectionsArray
78388>>>        End
78388>>>>
78388>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
78389>>>        If (bExists = True) Begin
78391>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
78392>>>>
78392>>>        End
78392>>>>
78392>>>
78392>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
78393>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
78394>>>
78394>>>        While (bExists = True)                 
78398>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
78398>>>            // We always put the enabled/active connection at the top
78398>>>//            Move (iCount = 1) to bEnabled
78398>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
78398>>>
78398>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
78399>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
78400>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
78401>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
78402>>>
78402>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
78402>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
78403>>>            If (sValue = "99") Begin
78405>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
78406>>>            End
78406>>>>
78406>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
78407>>>
78407>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
78408>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
78409>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
78411>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
78412>>>            End
78412>>>>
78412>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
78414>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
78415>>>            End
78415>>>>
78415>>>
78415>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
78416>>>
78416>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
78417>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
78418>>>
78418>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
78419>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
78420>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
78422>>>                Get DecryptPassword sValue to sValue
78423>>>            End
78423>>>>
78423>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
78424>>>
78424>>>            // Here we reconstruct the connection string to be complete with all params;
78424>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
78425>>>
78425>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
78426>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
78427>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
78428>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
78429>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
78430>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
78431>>>
78431>>>            Increment iCount
78432>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
78433>>>        Loop
78434>>>>
78434>>>
78434>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
78434>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
78436>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
78437>>>        End
78437>>>>
78437>>>
78437>>>        Function_Return SQLConnectionsArray
78438>>>    End_Function
78439>>>
78439>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
78441>>>        Integer iCount iSize
78441>>>        Boolean bOK
78441>>>        String sSection sValue
78441>>>
78441>>>        // First we need to _remove_ all current connections from the ini-file.
78441>>>        Move 0 to iCount
78442>>>        Get SQLIniFileDeleteAllConnections to bOK
78443>>>        If (bOK = False) Begin
78445>>>            Function_Return False
78446>>>        End
78446>>>>
78446>>>
78446>>>        Move False to Err
78447>>>        Get psIniSectionName to sSection
78448>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
78448>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
78449>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
78450>>>        Decrement iSize
78451>>>
78451>>>        For iCount from 0 to iSize
78457>>>>
78457>>>            // DF 19 compatible settings:
78457>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
78458>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
78459>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
78460>>>            
78460>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
78461>>>
78461>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
78462>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
78464>>>                Get EncryptPassword sValue to sValue
78465>>>            End
78465>>>>
78465>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
78466>>>
78466>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
78468>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
78469>>>            End
78469>>>>
78469>>>
78469>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
78470>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
78471>>>
78471>>>            // The Database Update Framework extended settings:
78471>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
78472>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
78473>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
78474>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
78475>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
78476>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
78477>>>        Loop
78478>>>>
78478>>>
78478>>>        Function_Return (bOK and Err = False)
78479>>>    End_Function
78480>>>
78480>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
78480>>>    //
78480>>>    // SQL utility function that returns a database type (string) constant
78480>>>    // corresponding to the passed iDbType.
78480>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
78482>>>        String sRetval
78482>>>        If (iDbType = EN_dbTypeMSSQL) Begin
78484>>>            Move CS_dbTypeMSSQL to sRetval
78485>>>        End
78485>>>>
78485>>>        If (iDbType = EN_dbTypeMySQL) Begin
78487>>>            Move CS_dbTypeMySQL to sRetval
78488>>>        End
78488>>>>
78488>>>        If (iDbType = EN_dbTypeOracle) Begin
78490>>>            Move CS_dbTypeOracle to sRetval
78491>>>        End
78491>>>>
78491>>>        If (iDbType = EN_dbTypeDB2) Begin
78493>>>            Move CS_dbTypeDB2 to sRetval
78494>>>        End
78494>>>>
78494>>>        If (iDbType = EN_dbTypePostgre) Begin
78496>>>            Move CS_dbTypePostgre to sRetval
78497>>>        End
78497>>>>
78497>>>        If (iDbType = EN_DbTypePervasive) Begin
78499>>>            Move CS_DbTypePervasive to sRetval
78500>>>        End
78500>>>>
78500>>>        Function_Return sRetval
78501>>>    End_Function
78502>>>
78502>>>    // SQL utility function that returns a database type constant (integer)
78502>>>    // corresponding to the passed sDbType string constant.
78502>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
78504>>>        Integer iRetval
78504>>>        If (sDbType = CS_dbTypeMSSQL) Begin
78506>>>            Move EN_dbTypeMSSQL to iRetval
78507>>>        End
78507>>>>
78507>>>        If (sDbType = CS_dbTypeMySQL) Begin
78509>>>            Move EN_dbTypeMySQL to iRetval
78510>>>        End
78510>>>>
78510>>>        If (sDbType = CS_dbTypeOracle) Begin
78512>>>            Move EN_dbTypeOracle to iRetval
78513>>>        End
78513>>>>
78513>>>        If (sDbType = CS_dbTypeDB2) Begin
78515>>>            Move EN_dbTypeDB2 to iRetval
78516>>>        End
78516>>>>
78516>>>        If (sDbType = CS_dbTypePostgre) Begin
78518>>>            Move EN_dbTypePostgre to iRetval
78519>>>        End
78519>>>>
78519>>>        If (sDbType = CS_DbTypePervasive) Begin
78521>>>            Move EN_DbTypePervasive to iRetval
78522>>>        End
78522>>>>
78522>>>        Function_Return iRetval
78523>>>    End_Function
78524>>>
78524>>>    // Pass an integer DbType and function returns the database type integer as a string value.
78524>>>    // Used e.g. when reading a connection ini-file to display the database type in
78524>>>    // the SQL Connection program's grid.
78524>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
78526>>>        String sRetval
78526>>>        If (iDbType = EN_dbTypeMSSQL) Begin
78528>>>            Move "EN_dbTypeMSSQL" to sRetval
78529>>>        End
78529>>>>
78529>>>        If (iDbType = EN_dbTypeMySQL) Begin
78531>>>            Move "EN_dbTypeMySQL" to sRetval
78532>>>        End
78532>>>>
78532>>>        If (iDbType = EN_dbTypeOracle) Begin
78534>>>            Move "EN_dbTypeOracle" to sRetval
78535>>>        End
78535>>>>
78535>>>        If (iDbType = EN_dbTypeDB2) Begin
78537>>>            Move "EN_dbTypeDB2" to sRetval
78538>>>        End
78538>>>>
78538>>>        If (iDbType = EN_dbTypePostgre) Begin
78540>>>            Move "EN_dbTypePostgre" to sRetval
78541>>>        End
78541>>>>
78541>>>        If (iDbType = EN_DbTypePervasive) Begin
78543>>>            Move "EN_dbTypePervasive" to sRetval
78544>>>        End
78544>>>>
78544>>>        Function_Return sRetval
78545>>>    End_Function
78546>>>
78546>>>    // Pass a driver id and the function will return
78546>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
78546>>>    // quite work and always returns "MS SQL Server"
78546>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
78548>>>        Integer iRetval
78548>>>        If (sDriverID = MSSQLDRV_ID) Begin
78550>>>            Move EN_dbTypeMSSQL to iRetval
78551>>>        End
78551>>>>
78551>>>        If (sDriverID = SQLFLEX) Begin
78553>>>            Move EN_dbTypeMSSQL to iRetval
78554>>>        End
78554>>>>
78554>>>        If (sDriverID = ODBC_DRV_ID) Begin
78556>>>            Move EN_dbTypeMSSQL to iRetval
78557>>>        End
78557>>>>
78557>>>        If (sDriverID = MDSMySQL) Begin
78559>>>            Move EN_dbTypeMySQL to iRetval
78560>>>        End
78560>>>>
78560>>>        If (sDriverID = ORAFLEX) Begin
78562>>>            Move EN_dbTypeOracle to iRetval
78563>>>        End
78563>>>>
78563>>>        If (sDriverID = DB2_DRV_ID) Begin
78565>>>            Move EN_dbTypeDB2 to iRetval
78566>>>        End
78566>>>>
78566>>>        If (sDriverID = MDSPgSQL) Begin
78568>>>            Move EN_dbTypePostgre to iRetval
78569>>>        End
78569>>>>
78569>>>        If (sDriverID = DFBTRDRV_ID) Begin
78571>>>            Move EN_DbTypePervasive to iRetval
78572>>>        End
78572>>>>
78572>>>        Function_Return iRetval
78573>>>    End_Function
78574>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78574>>>>
78574>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78576>>>>    Integer iStart iEnd
78576>>>>    String sRetval
78576>>>>
78576>>>>    Move (Trim(sConnect)) to sConnect
78577>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78578>>>>    If (iStart = 0) Begin
78580>>>>        Function_Return ""
78581>>>>    End
78581>>>>>
78581>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78582>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78583>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78585>>>>        Move (Pos(",", sRetval))          to iEnd
78586>>>>    End
78586>>>>>
78586>>>>    Else Begin
78587>>>>        Move (Pos(";", sRetval))          to iEnd
78588>>>>    End
78588>>>>>
78588>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78590>>>>        Move (Pos(",", sRetval))          to iEnd
78591>>>>        Decrement iEnd
78592>>>>    End
78592>>>>>
78592>>>>    If (iEnd <> 0) Begin
78594>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78595>>>>    End
78595>>>>>
78595>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78596>>>>
78596>>>>    Function_Return (Trim(sRetval))
78597>>>>End_Function
78598>>>>
78598>>>>
78598>>>
78598>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78600>>>        String sConnect
78600>>>        Handle hoDriver
78600>>>
78600>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78601>>>        Set psDriverID of hoDriver to sDriverID
78602>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
78603>>>        Send Destroy of hoDriver
78604>>>
78604>>>        Function_Return sConnect
78605>>>    End_Function
78606>>>
78606>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
78606>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
78608>>>        String sConnect
78608>>>
78608>>>        Case Begin
78608>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
78610>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
78611>>>                If (sDatabase <> "") Begin
78613>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
78614>>>                End
78614>>>>
78614>>>                Case Break
78615>>>
78615>>>            Case (sDriverID = ODBC_DRV_ID)
78618>>>                If (Uppercase(sServer) contains ".DSN") Begin
78620>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
78621>>>                End
78621>>>>
78621>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
78624>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
78625>>>                End
78625>>>>
78625>>>
78625>>>                If (sDatabase <> "") Begin
78627>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
78628>>>                End
78628>>>>
78628>>>                Case Break
78629>>>
78629>>>            Case (sDriverID = DB2_DRV_ID)
78632>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
78633>>>                If (sDatabase <> "") Begin
78635>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
78636>>>                End
78636>>>>
78636>>>                Case Break
78637>>>
78637>>>            Case (sDriverID = ORAFLEX)
78640>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
78641>>>                If (sDatabase <> "") Begin
78643>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
78644>>>                End
78644>>>>
78644>>>                Case Break
78645>>>
78645>>>            Case (sDriverID = MDSPgSQL)
78648>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
78649>>>                If (sDatabase <> "") Begin
78651>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
78652>>>                End
78652>>>>
78652>>>                Case Break
78653>>>
78653>>>            Case (sDriverID = MDSMySQL)
78656>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
78657>>>                If (sDatabase <> "") Begin
78659>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
78660>>>                End
78660>>>>
78660>>>                Case Break
78661>>>
78661>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78664>>>                Break
78665>>>
78665>>>            Case Else
78665>>>                Move "" to sConnect
78666>>>        Case End
78666>>>
78666>>>        Function_Return sConnect
78667>>>    End_Function
78668>>>
78668>>>    // Use Base64
78668>>>    Function EncryptPassword String sPassword Returns String
78670>>>        String sRetval
78670>>>        Handle hoLoginEncryption
78670>>>
78670>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
78671>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
78672>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
78673>>>        Send Destroy of hoLoginEncryption
78674>>>          
78674>>>        Function_Return sRetval
78675>>>    End_Function
78676>>>
78676>>>    Function DecryptPassword String sPassword Returns String
78678>>>        String sRetval
78678>>>        Handle hoLoginEncryption
78678>>>
78678>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
78679>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
78680>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
78681>>>        Send Destroy of hoLoginEncryption
78682>>>
78682>>>        Function_Return sRetval
78683>>>    End_Function
78684>>>
78684>>>    // Returns the full path of the Application (no trailing "\")
78684>>>    Function ApplicationPath Returns String
78686>>>        String sApplicationFileName sPath
78686>>>        Integer iNumChars iRetval
78686>>>
78686>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
78687>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
78688>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
78689>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
78690>>>        Move (CString(sApplicationFileName)) to sPath
78691>>>
78691>>>        Function_Return sPath
78692>>>    End_Function
78693>>>
78693>>>    // Pass a filename including the extension. The return value
78693>>>    // will be the path of of the first found "sSearchFileName in the workspace.
78693>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
78693>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
78695>>>        Boolean bExists
78695>>>        Handle hoPaths hoIniFile
78695>>>        String[] asWorkSpaceFiles
78696>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
78696>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
78696>>>        
78696>>>        Get psIniFilePath to sProgramsPath
78697>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
78698>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
78699>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
78700>>>        If (bExists = True) Begin
78702>>>            Function_Return sProgramsPath
78703>>>        End                      
78703>>>>
78703>>>    
78703>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
78704>>>        If (Right(sProgramsPath, 1) ="\") Begin
78706>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
78707>>>        End                                              
78707>>>>
78707>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
78708>>>        
78708>>>        Move False to bExists
78709>>>        Get Create (RefClass(Array)) to hoPaths
78710>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
78711>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
78712>>>        Decrement iSize       
78713>>>        
78713>>>        For iCount from 0 to iSize
78719>>>>
78719>>>            Move asWorkspaceFiles[iCount] to sFileName
78720>>>            Get Create (Refclass(cIniFile)) to hoIniFile
78721>>>            Set psFileName of hoIniFile to sFileName
78722>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
78723>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
78729>>>>
78729>>>                Get Value of hoPaths iPath to sSection    
78730>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
78731>>>                // Check if there are more than one path specified;
78731>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
78732>>>                If (iNoOfPaths > 1) Begin         
78734>>>                    Move sRelativePath to sRelativePaths
78735>>>                    For iCountPath from 1 to iNoOfPaths
78741>>>>
78741>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
78742>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
78743>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
78744>>>                        Get vFolderFormat sPath to sPath
78745>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
78746>>>                        If (bExists = True) Begin
78748>>>                            Move iNoOfPaths to iCountPath
78749>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
78750>>>                            Move iSize to iCount
78751>>>                        End                                                    
78751>>>>
78751>>>                    Loop
78752>>>>
78752>>>                End
78752>>>>
78752>>>                Else Begin
78753>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
78754>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
78755>>>                    Get vFolderFormat sPath to sPath
78756>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
78757>>>                    If (bExists = True) Begin
78759>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
78760>>>                        Move iSize to iCount
78761>>>                    End                                                    
78761>>>>
78761>>>                End
78761>>>>
78761>>>            Loop
78762>>>>
78762>>>            If (bExists = False) Begin
78764>>>                Move "" to sPath    
78765>>>            End
78765>>>>
78765>>>            Send Destroy of hoIniFile          
78766>>>        Loop        
78767>>>>
78767>>>        Send Destroy of hoPaths
78768>>>        
78768>>>        // Then not found in workspace, look for the file in DFSysPath;
78768>>>        If (sPath = "") Begin
78770>>>            Get_File_Path sSearchFileName to sFileName   
78771>>>            Get ParseFolderName sFileName to sPath
78772>>>        End                  
78772>>>>
78772>>>        
78772>>>        Function_Return sPath    
78773>>>    End_Function
78774>>>    
78774>>>    // Pass the path to the workspace Programs folder - returns a string array
78774>>>    // with one or more .ws file names.
78774>>>    // First checks if there is a .sws file - and if so reads the name of the
78774>>>    // workspace file (.ws) and returns it as a string array.
78774>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
78774>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
78776>>>        String[] asSWSFiles asWorkspaceFiles   
78778>>>        String sFile sHomePath sDirSep
78778>>>        Integer iCh iSize
78778>>>        Boolean bExists      
78778>>>        Handle hoIniFile 
78778>>>        
78778>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
78779>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
78780>>>        If (Right(sProgramsPath, 1) ="\") Begin
78782>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
78783>>>        End                                              
78783>>>>
78783>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
78784>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
78785>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
78786>>>        Get vFolderFormat sHomePath to sHomePath 
78787>>>        
78787>>>        // First check if theres an .sws file. If there is we will open it and
78787>>>        // read the name of the .ws file name.
78787>>>        File_Exist (sHomePath + "*.sws") bExists
78788>>>        If (bExists = True) Begin
78790>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
78791>>>            If (iCh < 0) Begin
78793>>>                Function_Return asSWSFiles
78794>>>            End                                 
78794>>>>
78794>>>            
78794>>>            Repeat
78794>>>>
78794>>>                Readln channel iCh sFile
78796>>>                If (Trim(sFile) <> "") Begin
78798>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
78799>>>                End
78799>>>>
78799>>>            Until (SeqEof = True)
78801>>>            Send Seq_Close_Channel iCh    
78802>>>            
78802>>>            Move (SizeOfArray(asSWSFiles)) to iSize
78803>>>            If (iSize <> 0) Begin
78805>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
78806>>>                // Use the file with that is last as it might have the DataFlex version in it,
78806>>>                // and thus is the latest one and it is more likely it is accurate (?)...
78806>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
78807>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
78808>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
78809>>>                If (sFile <> "") Begin
78811>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
78812>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
78813>>>                    File_Exist sFile bExists
78814>>>                    If (bExists = True) Begin
78816>>>                        Move sFile to asWorkspaceFiles[0] 
78817>>>                    End
78817>>>>
78817>>>                End
78817>>>>
78817>>>                Send Destroy of hoIniFile
78818>>>            End
78818>>>>
78818>>>        End
78818>>>>
78818>>>        
78818>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
78818>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
78820>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
78821>>>            File_Exist (sProgramsPath + "*.ws") bExists
78822>>>            If (bExists = False) Begin
78824>>>                Function_Return asWorkspaceFiles
78825>>>            End
78825>>>>
78825>>>        
78825>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
78826>>>            If (iCh < 0) Begin
78828>>>                Function_Return asWorkspaceFiles
78829>>>            End                                 
78829>>>>
78829>>>            
78829>>>            Repeat
78829>>>>
78829>>>                Readln channel iCh sFile
78831>>>                If (Trim(sFile) <> "") Begin
78833>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
78834>>>                End
78834>>>>
78834>>>            Until (SeqEof = True)
78836>>>            Send Seq_Close_Channel iCh
78837>>>        End
78837>>>>
78837>>>        
78837>>>        Function_Return asWorkspaceFiles
78838>>>    End_Function
78839>>>
78839>>>End_Class
78840>
78840>Object oHtmlHelp is a cHtmlHelp
78842>    Set pbAlwaysOnTop to False
78843>End_Object
78844>
78844>Object oApplication is a cApplication
78846>    Set peHelpType to htHtmlHelp
78847>    Set psHelpFile to "Developer5.chm"
78848>    Set psCompany to "RDC Tools International"
78849>    Set psProduct to "DUF - SQL Connections Manager"
78850>    Set psVersion to (String(piVersionMajor(phoVersionInfo(Self))) + "." + String(piVersionMinor(phoVersionInfo(Self))))
78851>    Set psAutoOpenWorkspace to ""
78852>
78852>    Property String psCommandLineIniFilePath ""
78854>    Property Boolean pbIniFileExists False     
78856>    Property Handle phoMainView 0
78858>
78858>    // If the folder contains exactly one workspace file (*.ws), it will be
78858>    // returned. Else an empty string ("") will be returned.
78858>    Function FindWorkspaceFile String sPath Returns String
78861>        String sSingleWorkspaceFile
78861>        Handle hoSQLIniFile                  
78861>        String[] aWsFiles
78862>        Integer iSize
78862>        
78862>        Get Create (RefClass(cSQLConnectionIniFile)) to hoSQLIniFile
78863>        Get WorkspaceIniFiles of hoSQLIniFile sPath to aWsFiles
78864>        Move (SizeOfArray(aWsFiles)) to iSize
78865>        If (iSize = 1) Begin
78867>            Move aWsFiles[0] to sSingleWorkspaceFile
78868>        End                    
78868>        Else Begin
78869>            Move "" to sSingleWorkspaceFile
78870>        End
78870>        Send Destroy of hoSQLIniFile      
78871>        Function_Return sSingleWorkspaceFile
78872>    End_Function
78873>
78873>    Procedure OnCreate
78876>        Integer eOpened
78876>        Handle hoCmdLine
78876>        String sArgument sPath sFileName sWsFile
78876>        Integer iRetval
78876>        Boolean bExists
78876>
78876>        Get phoCommandLine to hoCmdLine
78877>        Get Argument of hoCmdLine 1 to sArgument
78878>        If (sArgument <> "") Begin
78880>            Get ParseFolderName sArgument to sPath
78881>            Get vFolderExists sPath to iRetval
78882>            If (iRetval = True) Begin
78884>                Set psCommandLineIniFilePath to sPath
78885>                Get vFilePathExists (sPath + CS_SQLIniFileName) to bExists
78886>                Set pbIniFileExists to bExists
78887>            End
78887>        End
78887>
78887>        Get OpenWorkspaceFile of (phoWorkspace(Self)) "config.ws" to eOpened
78888>        If (eOpened <> wsWorkspaceOpened) Begin
78890>            Get GetApplicationPath to sPath     
78891>            Get FindWorkspaceFile sPath to sWsFile
78892>            If (sWsFile = "") Begin
78894>                Get vSelect_File "Workspace Files (*.ws)|*.ws|All Files (*.*)|*.*" "Please select a Workspace file (*.ws)" sPath to sWsFile
78895>                Get vFilePathExists sWsFile to bExists
78896>                If (bExists = False) Begin
78898>                    Send Stop_Box "No Workspace file selected. Cannot continue!"
78899>                    Send Exit_Application
78900>                End
78900>            End
78900>            Get OpenWorkspaceFile of (phoWorkspace(Self)) sWsFile to eOpened
78901>            If (eOpened <> wsWorkspaceOpened) Begin
78903>                Set psHome          of (phoWorkspace(Self)) to sPath
78904>                Set psProgramPath   of (phoWorkspace(Self)) to sPath
78905>                Set psDataPath      of (phoWorkspace(Self)) to sPath
78906>                Set psFileList      of (phoWorkspace(Self)) to sPath
78907>                Set psHelpPath      of (phoWorkspace(Self)) to sPath
78908>                Set psBitmapPath    of (phoWorkspace(Self)) to sPath
78909>            End
78909>        End
78909>    End_Procedure  
78910>    
78910>
78910>End_Object
78911>
78911>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
78911>>>//****************************************************************************
78911>>>// $Module type: Class
78911>>>// $Module name: cSQLConnectionHandler.pkg
78911>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
78911>>>// Web-site    : http://www.rdctools.com
78911>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
78911>>>//
78911>>>// Description : A handler class for using CLI connection ID's to login to a database server.
78911>>>//
78911>>>// $Rev History:
78911>>>//    2015-08-11  Module header created
78911>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
78911>>>//                Added a new structure for passing connection data back & forth.
78911>>>//                Added better error handling.
78911>>>//                Added a decompose message for the connection string.
78911>>>//    2017-01-09  Added support for Mertech drivers
78911>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
78911>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
78911>>>//    2017-02-12  Reworked the whole connection property interface.
78911>>>//                Now there is one struct property that is the at cencter of a connection.
78911>>>//****************************************************************************
78911>>>Use cli.pkg
78911>>>Use MSSqldrv.pkg
78911>>>Use db2_drv.pkg
78911>>>Use odbc_drv.pkg
78911>>>Use cSQLConnectionIniFile.pkg
78911>>>Use cDbUpdateDatabaseDriver.pkg
78911>>>Use vWin32fh.pkg
78911>>>
78911>>>// The cConnection class is the new SQL connections class for DF 19.
78911>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
78911>>>
78911>>>// We're making references to this object handle so we need it defined
78911>>>// here as well as for the cDbUpdateHandler class
78911>>>
78911>>>    Global_Variable Handle ghoSQLConnectionHandler
78911>>>    Move 0 to ghoSQLConnectionHandler
78912>>>
78912>>>Class cSQLConnectionHandler is a cObject
78913>>>
78913>>>    Procedure Construct_Object
78915>>>        Forward Send Construct_Object
78917>>>        Move Self to ghoSQLConnectionHandler
78918>>>
78918>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
78919>>>
78919>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
78919>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
78919>>>        // methods to this class.
78919>>>        Property Boolean pbUseConnectionID True
78920>>>        Property Boolean pbToANSI          True
78921>>>        Property Boolean pbRecnum          True
78922>>>        Property Boolean pbCopyData        True
78923>>>        Property Boolean pbApiTableUpdateAuto    False
78924>>>        Property Boolean pbCompareDate_DateTime  False
78925>>>        Property Boolean pbCompareIndexAscending False
78926>>>        Property Boolean pbCompareIndexUppercase False
78927>>>
78927>>>        // Driver default value settings:
78927>>>        // Note: When the object is created the corresponding values
78927>>>        // from the driver .int files are read.
78927>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
78927>>>        Property String psDriverDefaultValueASCII    ""
78928>>>        Property String psDriverDefaultValueBinary   ""
78929>>>        Property String psDriverDefaultValueDate     ""
78930>>>        Property String psDriverDefaultValueDateTime ""
78931>>>        Property String psDriverDefaultValueNumeric  ""
78932>>>        Property String psDriverDefaultValueText     ""
78933>>>
78933>>>        // Driver "nullability" settings:
78933>>>        // Note: When the object is created the corresponding values
78933>>>        // from the driver .int files are read.
78933>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
78933>>>        Property Boolean pbDriverDefaultNullableASCII    False
78934>>>        Property Boolean pbDriverDefaultNullableBinary   False
78935>>>        Property Boolean pbDriverDefaultNullableDate     False
78936>>>        Property Boolean pbDriverDefaultNullableDateTime False
78937>>>        Property Boolean pbDriverDefaultNullableNumeric  False
78938>>>        Property Boolean pbDriverDefaultNullableText     False
78939>>>
78939>>>        // *** This is the central point of connection data for the Database Update Framework ***
78939>>>        //     It is private because the get/set version also updates the DAW/Mertech
78939>>>        //     driver interfaces.
78939>>>        //     There are also procedure/function pairs to set/get individual data members
78939>>>        //     of the struct they are all routed throu this struct property.
78939>>>        Property tSQLConnection Private.pSQLConnection
78940>>>
78940>>>    End_Procedure
78941>>>
78941>>>    Procedure End_Construct_Object
78943>>>        tSQLConnection SQLConnection
78943>>>        tSQLConnection SQLConnection
78943>>>
78943>>>        Forward Send End_Construct_Object
78945>>>
78945>>>        // Now is the time to read and apply SQL connection settings.
78945>>>        Get SetupSQLConnection True True to SQLConnection
78946>>>        Set Private.pSQLConnection to SQLConnection
78947>>>    End_Procedure
78948>>>
78948>>>    // *** Properties ***
78948>>>    // All connection related "properties" (get/set pairs) are really done by changing the
78948>>>    // private.pSQLConnection struct connection property. These "properties" are
78948>>>    // merely here for conveniance.
78948>>>    //
78948>>>    // The pSQLConnection get/set are here so we have a "central hub"
78948>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
78948>>>    // This struct property contains all the connection data.
78948>>>    //
78948>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
78950>>>        Boolean bOK
78950>>>
78950>>>        Set Private.pSQLConnection to SQLConnection
78951>>>
78951>>>        // When starting a program we might not have a connection id yet:
78951>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
78953>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
78953>>>            Procedure_Return
78954>>>        End
78954>>>>
78954>>>
78954>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
78954>>>        // be logged in already and don't want to do it again.
78954>>>        If (SQLConnection.bDAWConnection = False) Begin
78956>>>            // After we have set the class property we need to tell the DAW/Mertech
78956>>>            // driver interfaces about the change & make a new login.
78956>>>            Get SQLLogin SQLConnection to bOK
78957>>>            If (bOK = False) Begin
78959>>>                Error DFERR_PROGRAM "Login error."
78960>>>>
78960>>>            End
78960>>>>
78960>>>        End
78960>>>>
78960>>>
78960>>>        // Now is the time to setup our driver default values by reading the driver .int file:
78960>>>        Send SetupDriverDefaults SQLConnection.sDriverID
78961>>>
78961>>>    End_Procedure
78962>>>
78962>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
78962>>>    // attempt to load the driver.
78962>>>    // Returns true if the passed driver is SQL based.
78962>>>    Function IsSQLDriver String sDriverID Returns Boolean
78964>>>        Boolean bOK
78964>>>
78964>>>        Get IsDAWSQLDriver sDriverID to bOK
78965>>>        If (bOK = False) Begin
78967>>>            Get IsMertechDriver sDriverID to bOK
78968>>>        End
78968>>>>
78968>>>
78968>>>        Function_Return bOK
78969>>>    End_Function
78970>>>
78970>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
78970>>>    Procedure SetupDriverDefaults String sDriverID
78972>>>        String sAttributeValue
78972>>>        Integer iDriverID
78972>>>        Boolean bNULL bSQLDriver bIsMertechDriver
78972>>>
78972>>>        Get IsSQLDriver sDriverID to bSQLDriver
78973>>>        If (bSQLDriver = False) Begin
78975>>>            Procedure_Return
78976>>>        End                                      
78976>>>>
78976>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
78977>>>        If (bIsMertechDriver = True) Begin
78979>>>            Procedure_Return
78980>>>        End
78980>>>>
78980>>>        
78980>>>        Get DriverIndex sDriverID to iDriverID
78981>>>
78981>>>        // Driver default values for various data types:
78981>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
78984>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
78985>>>
78985>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
78988>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
78989>>>
78989>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
78992>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
78993>>>
78993>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
78996>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
78997>>>
78997>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
79000>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
79001>>>
79001>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
79004>>>        Set psDriverDefaultValueText                                    to sAttributeValue
79005>>>
79005>>>        // The default setting for the "nullability" of newly created ASCII columns.
79005>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
79008>>>        Set pbDriverDefaultNullableASCII to bNULL
79009>>>
79009>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
79012>>>        Set pbDriverDefaultNullableBinary to bNULL
79013>>>
79013>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
79016>>>        Set pbDriverDefaultNullableDate to bNULL
79017>>>
79017>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
79020>>>        Set pbDriverDefaultNullableDateTime to bNULL
79021>>>
79021>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
79024>>>        Set pbDriverDefaultNullableNumeric to bNULL
79025>>>
79025>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
79028>>>        Set pbDriverDefaultNullableText to bNULL
79029>>>
79029>>>    End_Procedure
79030>>>
79030>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
79032>>>        Boolean bOK bIsDaw bIsMertech
79032>>>        String sConnectionString
79032>>>        Handle hoErrorObj hoDriver hoIniFile
79032>>>        Integer iDriverID
79032>>>
79032>>>        Move False to bOK
79033>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
79034>>>        If (bIsDaw = False) Begin
79036>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
79037>>>            If (bIsMertech = False) Begin
79039>>>                Function_Return False
79040>>>            End
79040>>>>
79040>>>        End
79040>>>>
79040>>>
79040>>>        Get phoSQLConnectionIniFile to hoIniFile
79041>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
79042>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
79043>>>        If (iDriverID = 0) Begin
79045>>>            Move hoErrorObj to Error_Object_Id
79046>>>            Function_Return False
79047>>>        End
79047>>>>
79047>>>
79047>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
79047>>>        If (bIsMertech = False) Begin
79049>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
79052>>>        End
79052>>>>
79052>>>
79052>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
79053>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
79054>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
79055>>>        Send Destroy   of hoDriver
79056>>>
79056>>>        Function_Return bOK
79057>>>    End_Function
79058>>>
79058>>>    Function pSQLConnection Returns tSQLConnection
79060>>>        tSQLConnection SQLConnection
79060>>>        tSQLConnection SQLConnection
79060>>>        Get Private.pSQLConnection to SQLConnection
79061>>>        Function_Return SQLConnection
79062>>>    End_Function
79063>>>
79063>>>    Procedure Set psConnectionID String sValue
79065>>>        tSQLConnection SQLConnection
79065>>>        tSQLConnection SQLConnection
79065>>>
79065>>>        Get Private.pSQLConnection to SQLConnection
79066>>>        If (SQLConnection.sConnectionID = "") Begin
79068>>>            Move sValue to SQLConnection.sConnectionID
79069>>>        End
79069>>>>
79069>>>
79069>>>        // Else we might want to change the current connection ID
79069>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
79072>>>            Move False to Err
79073>>>            Logout SQLConnection.sDriverID
79074>>>            // This will also make a login to the new server.
79074>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
79075>>>        End
79075>>>>
79075>>>        Set pSQLConnection to SQLConnection
79076>>>    End_Procedure
79077>>>
79077>>>    Function psConnectionID Returns String
79079>>>        tSQLConnection SQLConnection
79079>>>        tSQLConnection SQLConnection
79079>>>        Get Private.pSQLConnection to SQLConnection
79080>>>        Function_Return SQLConnection.sConnectionID
79081>>>    End_Function
79082>>>
79082>>>    // Note: If the psDriverID + other connection properties are to be changed,
79082>>>    //       the psDriverID *must* be the first property that is changed!
79082>>>    //       Otherwise errors might be raised by the driver when e.g. the format
79082>>>    //       for a connection string has the wrong format for that driver.
79082>>>    Procedure Set psDriverID String sValue
79084>>>        tSQLConnection SQLConnection
79084>>>        tSQLConnection SQLConnection
79084>>>        Get pSQLConnection to SQLConnection
79085>>>        Move sValue        to SQLConnection.sDriverID
79086>>>        Set pSQLConnection to SQLConnection
79087>>>        If (sValue <> DATAFLEX_ID) Begin
79089>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
79090>>>        End
79090>>>>
79090>>>    End_Procedure
79091>>>
79091>>>    Function psDriverID Returns String
79093>>>        tSQLConnection SQLConnection
79093>>>        tSQLConnection SQLConnection
79093>>>        Get Private.pSQLConnection to SQLConnection
79094>>>        If (SQLConnection.sDriverID = "") Begin
79096>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
79097>>>        End
79097>>>>
79097>>>        Function_Return SQLConnection.sDriverID
79098>>>    End_Function
79099>>>
79099>>>    Procedure Set psConnectionString String sValue
79101>>>        tSQLConnection SQLConnection
79101>>>        tSQLConnection SQLConnection
79101>>>        Get Private.pSQLConnection to SQLConnection
79102>>>        Move sValue        to SQLConnection.sConnectionString
79103>>>        Set pSQLConnection to SQLConnection
79104>>>    End_Procedure
79105>>>
79105>>>    Function psConnectionString Returns String
79107>>>        tSQLConnection SQLConnection
79107>>>        tSQLConnection SQLConnection
79107>>>        Get Private.pSQLConnection to SQLConnection
79108>>>        Function_Return SQLConnection.sConnectionString
79109>>>    End_Function
79110>>>
79110>>>    Procedure Set psServer String sValue
79112>>>        tSQLConnection SQLConnection
79112>>>        tSQLConnection SQLConnection
79112>>>        Get Private.pSQLConnection to SQLConnection
79113>>>        Move sValue        to SQLConnection.sServer
79114>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
79115>>>        Set pSQLConnection to SQLConnection
79116>>>    End_Procedure
79117>>>
79117>>>    Function psServer Returns String
79119>>>        tSQLConnection SQLConnection
79119>>>        tSQLConnection SQLConnection
79119>>>        Get Private.pSQLConnection to SQLConnection
79120>>>        Function_Return SQLConnection.sServer
79121>>>    End_Function
79122>>>
79122>>>    Procedure Set psDatabase String sValue
79124>>>        tSQLConnection SQLConnection
79124>>>        tSQLConnection SQLConnection
79124>>>        Get Private.pSQLConnection to SQLConnection
79125>>>        Move sValue        to SQLConnection.sDatabase
79126>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
79127>>>        Set pSQLConnection to SQLConnection
79128>>>    End_Procedure
79129>>>
79129>>>    Function psDatabase Returns String
79131>>>        tSQLConnection SQLConnection
79131>>>        tSQLConnection SQLConnection
79131>>>        Get Private.pSQLConnection to SQLConnection
79132>>>        Function_Return SQLConnection.sDatabase
79133>>>    End_Function
79134>>>
79134>>>    Procedure Set psUserID String sValue
79136>>>        tSQLConnection SQLConnection
79136>>>        tSQLConnection SQLConnection
79136>>>        Get Private.pSQLConnection to SQLConnection
79137>>>        Move sValue        to SQLConnection.sUserID
79138>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
79139>>>        Set pSQLConnection to SQLConnection
79140>>>    End_Procedure
79141>>>
79141>>>    Function psUserID Returns String
79143>>>        tSQLConnection SQLConnection
79143>>>        tSQLConnection SQLConnection
79143>>>        Get Private.pSQLConnection to SQLConnection
79144>>>        Function_Return SQLConnection.sUserID
79145>>>    End_Function
79146>>>
79146>>>    // This is the uncrypted password
79146>>>    Procedure Set psPassword String sValue
79148>>>        tSQLConnection SQLConnection
79148>>>        tSQLConnection SQLConnection
79148>>>        Get Private.pSQLConnection to SQLConnection
79149>>>        Move sValue        to SQLConnection.sPassword
79150>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
79151>>>        Set pSQLConnection to SQLConnection
79152>>>    End_Procedure
79153>>>
79153>>>    Function psPassword Returns String
79155>>>        tSQLConnection SQLConnection
79155>>>        tSQLConnection SQLConnection
79155>>>        Get Private.pSQLConnection to SQLConnection
79156>>>        Function_Return SQLConnection.sPassword
79157>>>    End_Function
79158>>>
79158>>>    Procedure Set pbTrusted Boolean bValue
79160>>>        tSQLConnection SQLConnection
79160>>>        tSQLConnection SQLConnection
79160>>>        Get Private.pSQLConnection to SQLConnection
79161>>>        Move bValue        to SQLConnection.bTrusted
79162>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
79163>>>        Set pSQLConnection to SQLConnection
79164>>>    End_Procedure
79165>>>
79165>>>    Function pbTrusted Returns Boolean
79167>>>        tSQLConnection SQLConnection
79167>>>        tSQLConnection SQLConnection
79167>>>        Get Private.pSQLConnection to SQLConnection
79168>>>        Function_Return SQLConnection.bTrusted
79169>>>    End_Function
79170>>>
79170>>>    // *** All of these properties are special to the Database Update Framework ***
79170>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
79170>>>    //     the Private.pSQLConnection property is set instead of the going throu
79170>>>    //     the central pSQLConnection "hub".
79170>>>    Procedure Set pbSilentLogin Boolean bValue
79172>>>        tSQLConnection SQLConnection
79172>>>        tSQLConnection SQLConnection
79172>>>        Get Private.pSQLConnection to SQLConnection
79173>>>        Move bValue to SQLConnection.bTrusted
79174>>>        Set Private.pSQLConnection to SQLConnection
79175>>>    End_Procedure
79176>>>
79176>>>    Function pbSilentLogin Returns Boolean
79178>>>        tSQLConnection SQLConnection
79178>>>        tSQLConnection SQLConnection
79178>>>        Get Private.pSQLConnection to SQLConnection
79179>>>        Function_Return SQLConnection.bSilentLogin
79180>>>    End_Function
79181>>>
79181>>>    Procedure Set piDbType Integer iValue
79183>>>        tSQLConnection SQLConnection
79183>>>        tSQLConnection SQLConnection
79183>>>        Get Private.pSQLConnection to SQLConnection
79184>>>        Move iValue to SQLConnection.iDbType
79185>>>        Set Private.pSQLConnection to SQLConnection
79186>>>    End_Procedure
79187>>>
79187>>>    Function piDbType Returns Integer
79189>>>        tSQLConnection SQLConnection
79189>>>        tSQLConnection SQLConnection
79189>>>        Get Private.pSQLConnection to SQLConnection
79190>>>        Function_Return SQLConnection.iDbType
79191>>>    End_Function
79192>>>
79192>>>    Procedure Set psBaseTableSpace String sValue
79194>>>        tSQLConnection SQLConnection
79194>>>        tSQLConnection SQLConnection
79194>>>        Get Private.pSQLConnection to SQLConnection
79195>>>        Move sValue to SQLConnection.sBaseTableSpace
79196>>>        Set Private.pSQLConnection to SQLConnection
79197>>>    End_Procedure
79198>>>
79198>>>    Function psBaseTableSpace Returns String
79200>>>        tSQLConnection SQLConnection
79200>>>        tSQLConnection SQLConnection
79200>>>        Get Private.pSQLConnection to SQLConnection
79201>>>        Function_Return SQLConnection.sBaseTableSpace
79202>>>    End_Function
79203>>>
79203>>>    Procedure Set psIndexTableSpace String sValue
79205>>>        tSQLConnection SQLConnection
79205>>>        tSQLConnection SQLConnection
79205>>>        Get Private.pSQLConnection to SQLConnection
79206>>>        Move sValue to SQLConnection.sIndexTableSpace
79207>>>        Set Private.pSQLConnection to SQLConnection
79208>>>    End_Procedure
79209>>>
79209>>>    Function psIndexTableSpace Returns String
79211>>>        tSQLConnection SQLConnection
79211>>>        tSQLConnection SQLConnection
79211>>>        Get Private.pSQLConnection to SQLConnection
79212>>>        Function_Return SQLConnection.sIndexTableSpace
79213>>>    End_Function
79214>>>
79214>>>    Procedure Set psLongTableSpace String sValue
79216>>>        tSQLConnection SQLConnection
79216>>>        tSQLConnection SQLConnection
79216>>>        Get Private.pSQLConnection to SQLConnection
79217>>>        Move sValue to SQLConnection.sLongTableSpace
79218>>>        Set Private.pSQLConnection to SQLConnection
79219>>>    End_Procedure
79220>>>
79220>>>    Function psLongTableSpace Returns String
79222>>>        tSQLConnection SQLConnection
79222>>>        tSQLConnection SQLConnection
79222>>>        Get Private.pSQLConnection to SQLConnection
79223>>>        Function_Return SQLConnection.sLongTableSpace
79224>>>    End_Function
79225>>>
79225>>>    Procedure Set psSchema String sValue
79227>>>        tSQLConnection SQLConnection
79227>>>        tSQLConnection SQLConnection
79227>>>        Get Private.pSQLConnection to SQLConnection
79228>>>        Move sValue to SQLConnection.sSchema
79229>>>        Set Private.pSQLConnection to SQLConnection
79230>>>    End_Procedure
79231>>>
79231>>>    Function psSchema Returns String
79233>>>        tSQLConnection SQLConnection
79233>>>        tSQLConnection SQLConnection
79233>>>        Get Private.pSQLConnection to SQLConnection
79234>>>        Function_Return SQLConnection.sSchema
79235>>>    End_Function
79236>>>
79236>>>    Procedure Set pbEnabled Boolean bValue
79238>>>        tSQLConnection SQLConnection
79238>>>        tSQLConnection SQLConnection
79238>>>        Get Private.pSQLConnection to SQLConnection
79239>>>        Move bValue to SQLConnection.bEnabled
79240>>>        Set Private.pSQLConnection to SQLConnection
79241>>>    End_Procedure
79242>>>
79242>>>    Function pbEnabled Returns Boolean
79244>>>        tSQLConnection SQLConnection
79244>>>        tSQLConnection SQLConnection
79244>>>        Get Private.pSQLConnection to SQLConnection
79245>>>        Function_Return SQLConnection.bEnabled
79246>>>    End_Function
79247>>>
79247>>>
79247>>>    // ************************************
79247>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
79249>>>        tSQLConnection SQLConnection
79249>>>        tSQLConnection SQLConnection
79249>>>
79249>>>        // If this object was created by the cDbUpdateHandler class we will
79249>>>        // deferr reading SQL connection values until later.
79249>>>        If (bReadDFConnSettings = True) Begin
79251>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
79251>>>            If (ghoConnection > 0) Begin
79253>>>                Get ReadcConnections to SQLConnection
79254>>>            End
79254>>>>
79254>>>
79254>>>            // In addition to the above; there might be other values set even if a cConnection
79254>>>            // object is used.
79254>>>            If (bReadSQLConnections = True) Begin
79256>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
79257>>>            End
79257>>>>
79257>>>        End
79257>>>>
79257>>>
79257>>>        Function_Return SQLConnection
79258>>>    End_Function
79259>>>
79259>>>    // This is for the new cConnection class used by DF 19 and up (only).
79259>>>    Function ReadcConnections Returns tSQLConnection
79261>>>        tConnection Connection
79261>>>        tConnection Connection
79261>>>        tSQLConnection SQLConnection SQLConnectionEmpty
79261>>>        tSQLConnection SQLConnection SQLConnectionEmpty
79261>>>        Integer iRetval iDbType
79261>>>        Boolean bOK bConnected
79261>>>        String sConnectionID
79261>>>
79261>>>            tConnection[] Connections
79261>>>            tConnection[] Connections
79262>>>            // - If the DF 19 cConnection class has been used in the cApplication object
79262>>>            // - and there are multiple connection id's defined for the same driver. This is
79262>>>            //   because otherwise we can't possibly know which connection id to use... So
79262>>>            //   we then generate an error and abort the program...
79262>>>            Get IsSinglecConnection (&sConnectionID) to bOK
79263>>>            If (bOK = False) Begin
79265>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
79266>>>>
79266>>>                Abort
79267>>>>
79267>>>            End
79267>>>>
79267>>>            If (sConnectionID = "") Begin
79269>>>                Get ConnectionIDs of ghoConnection to Connections
79270>>>                If (SizeOfArray(Connections) > 0) Begin
79272>>>                    Move Connections[0].sId to sConnectionID
79273>>>                End
79273>>>>
79273>>>            End
79273>>>>
79273>>>
79273>>>            Move 0 to iRetval
79274>>>            // DAW DF19 connection info:
79274>>>            // We first check that the connection is OK:
79274>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
79275>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
79275>>>            If (iRetval = -1) Begin
79277>>>                Function_Return SQLConnectionEmpty
79278>>>            End
79278>>>>
79278>>>
79278>>>            If (sConnectionID <> "") Begin
79280>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
79281>>>            End
79281>>>>
79281>>>            If (Connection.sId = "") Begin
79283>>>                Move True to SQLConnectionEmpty.bError
79284>>>                Function_Return SQLConnectionEmpty
79285>>>            End
79285>>>>
79285>>>
79285>>>            // DUF connection info struct property:
79285>>>            Get Private.pSQLConnection                       to SQLConnection
79286>>>
79286>>>            Move Connection.sId to sConnectionID
79287>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
79288>>>
79288>>>            If (bConnected = False) Begin
79290>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
79291>>>                If (iRetval <> 0) Begin
79293>>>                    Send UserError CS_DUF_CannotLoginToServer
79294>>>                    Send Exit_Application
79295>>>                End
79295>>>>
79295>>>                Move True                                   to SQLConnection.bDAWConnection
79296>>>                // We need to get the DAW connection info again as it might have
79296>>>                // been changed in the DAW db login dialog.
79296>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
79297>>>            End
79297>>>>
79297>>>
79297>>>            Move True                                        to SQLConnection.bEnabled
79298>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
79299>>>
79299>>>            // Not used in DUF:
79299>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
79299>>>
79299>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
79300>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
79301>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
79302>>>            Move Connection.sId                              to SQLConnection.sConnectionID
79303>>>            Move Connection.sUID                             to SQLConnection.sUserID
79304>>>            Move Connection.sPWD                             to SQLConnection.sPassword
79305>>>
79305>>>            // Not used in DUF:
79305>>>            // Move Connection.sSection to SQLConnection.xxx
79305>>>
79305>>>            // The rest of the properties of the SQLConnection struct should have been
79305>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
79305>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
79307>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
79308>>>            End
79308>>>>
79308>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
79310>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
79311>>>                If (SQLConnection.sServer = "") Begin
79313>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
79314>>>                End
79314>>>>
79314>>>            End
79314>>>>
79314>>>
79314>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
79315>>>
79315>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
79315>>>            // the value from the driver id:
79315>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
79316>>>            // ...but in case it has been explicitly set in the object we use that value.
79316>>>            Get piDbType                                     to iDbType
79317>>>            If (iDbType <> SQLConnection.iDbType) Begin
79319>>>                Move iDbType to SQLConnection.iDbType
79320>>>            End
79320>>>>
79320>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
79321>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
79322>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
79323>>>            Get psSchema                                     to SQLConnection.sSchema
79324>>>
79324>>>            // We finally set the struct property to the newly fetched values.
79324>>>            Set pSQLConnection to SQLConnection
79325>>>
79325>>>        Function_Return SQLConnection
79326>>>    End_Function
79327>>>
79327>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
79327>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
79327>>>    // connection id for a particular driver.
79327>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
79327>>>    // object. We can then match a connection id from the DAW cConnect class array.
79327>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
79327>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
79327>>>    // connections of the DAW cConnect class.
79327>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
79329>>>        tConnection[] ConnIdArray
79329>>>        tConnection[] ConnIdArray
79330>>>        Integer iCount iSize iConnectionIDCounter
79330>>>        Boolean bEnabled bFound
79330>>>        String sConnectionID2 sDriverID sDriverConn
79330>>>
79330>>>        Move False to bFound
79331>>>        If (ghoConnection > 0) Begin
79333>>>
79333>>>            // The property of the cDbUpdateHandler container object
79333>>>            Get psDriverID to sDriverID
79334>>>
79334>>>            Move 0 to iConnectionIDCounter
79335>>>            // This is the the DAW cConnect array with all registered connection id's.
79335>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
79336>>>            Move (SizeOfArray(ConnIdArray)) to iSize
79337>>>            Decrement iSize
79338>>>            For iCount from 0 to iSize
79344>>>>
79344>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
79345>>>                Move ConnIdArray[iCount].sId to sConnectionID2
79346>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
79347>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
79347>>>                // connection in the DAW cConnect object _and_ that there is only one!
79347>>>                If (sConnectionID = "") Begin
79349>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
79350>>>                End
79350>>>>
79350>>>                Else Begin
79351>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
79353>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
79354>>>                    End
79354>>>>
79354>>>                End
79354>>>>
79354>>>
79354>>>                If (bFound = True) Begin
79356>>>                    Increment iConnectionIDCounter
79357>>>                End
79357>>>>
79357>>>            Loop
79358>>>>
79358>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
79359>>>            If (bFound = True) Begin
79361>>>                Move sConnectionID2 to sConnectionID
79362>>>            End
79362>>>>
79362>>>        End
79362>>>>
79362>>>
79362>>>        // Special case; a cConnection object has been setup in the cApplication,
79362>>>        // but no DFConn.ini record has been created.
79362>>>        If (iSize = -1) Begin
79364>>>            Move True to bFound
79365>>>        End
79365>>>>
79365>>>
79365>>>        Function_Return bFound
79366>>>    End_Function
79367>>>
79367>>>    // Send on object creation to read the default connection string settings, and
79367>>>    // create a connection to the server.
79367>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
79369>>>        String sPath sFileName
79369>>>        Boolean bExists bActive
79369>>>        tSQLConnection[] SQLConnectionArray
79369>>>        tSQLConnection[] SQLConnectionArray
79370>>>        tSQLConnection SQLConnection SQLConnectionEmpty
79370>>>        tSQLConnection SQLConnection SQLConnectionEmpty
79370>>>        Handle hoIniFile
79370>>>        Integer iSize iCount iRetval
79370>>>
79370>>>        Get psIniFilePath to sPath
79371>>>        Get phoSQLConnectionIniFile to hoIniFile
79372>>>        If (sPath = "") Begin
79374>>>            Get ApplicationPath of hoIniFile to sPath
79375>>>            Set psIniFilePath   of hoIniFile to sPath
79376>>>        End
79376>>>>
79376>>>        Get vFolderFormat sPath to sPath
79377>>>        Get psIniFileName to sFileName
79378>>>        Get vFilePathExists (sPath + sFileName) to bExists
79379>>>
79379>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
79380>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
79381>>>        If (iSize = 0) Begin
79383>>>            // This may have been set by the "ReadcConnections" function,
79383>>>            // if a cConnection object has been setup for DataFlex 19 or later
79383>>>            // in the cApplication object.
79383>>>            Get pSQLConnection to SQLConnection
79384>>>            If (SQLConnection.sConnectionID = "") Begin
79386>>>                Function_Return SQLConnectionEmpty
79387>>>            End
79387>>>>
79387>>>            Move SQLConnection to SQLConnectionArray[0] 
79388>>>            Move 1 to iSize
79389>>>        End
79389>>>>
79389>>>
79389>>>        Move False to bActive
79390>>>        // The first connection should be the one that is active, but all connections might have been disabled.
79390>>>        Decrement iSize
79391>>>        For iCount from 0 to iSize
79397>>>>
79397>>>            Move SQLConnectionArray[iCount] to SQLConnection
79398>>>            If (SQLConnection.bEnabled = True) Begin
79400>>>                Move True to bActive
79401>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
79402>>>            End
79402>>>>
79402>>>        Loop
79403>>>>
79403>>>
79403>>>        // In case all connections have been disabled, we're out of here.
79403>>>        If (bActive = False) Begin
79405>>>            Function_Return SQLConnectionEmpty
79406>>>        End
79406>>>>
79406>>>
79406>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
79407>>>
79407>>>        Set pSQLConnection to SQLConnection
79408>>>        Get AutoSetConnectionID to iRetval
79409>>>
79409>>>        Function_Return SQLConnection
79410>>>    End_Function
79411>>>
79411>>>    Procedure Set psIniFilePath String sPath
79413>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
79414>>>    End_Procedure
79415>>>
79415>>>    Function psIniFilePath Returns String
79417>>>        String sRetval
79417>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
79418>>>        Function_Return sRetval
79419>>>    End_Function
79420>>>
79420>>>    Procedure Set psIniFileName String sFileName
79422>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
79423>>>    End_Procedure
79424>>>
79424>>>    Function psIniFileName Returns String
79426>>>        String sRetval
79426>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
79427>>>        Function_Return sRetval
79428>>>    End_Function
79429>>>
79429>>>    Procedure Set psIniSectionName String sSection
79431>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
79432>>>    End_Procedure
79433>>>
79433>>>    Function psIniSectionName Returns String
79435>>>        String sRetval
79435>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
79436>>>        Function_Return sRetval
79437>>>    End_Function
79438>>>
79438>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
79440>>>        Handle ho
79440>>>        Get phoSQLConnectionIniFile to ho
79441>>>        Set IniFileValue of ho to sSection sValueName sValue
79442>>>    End_Procedure
79443>>>
79443>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
79445>>>        Handle ho
79445>>>        String sRetval
79445>>>        Get phoSQLConnectionIniFile to ho
79446>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
79447>>>        Function_Return sRetval
79448>>>    End_Function
79449>>>
79449>>>    Function SectionExists String sSection Returns Boolean
79451>>>        Handle ho
79451>>>        Boolean bRetval
79451>>>        Get phoSQLConnectionIniFile to ho
79452>>>        Get SectionExists of ho sSection to bRetval
79453>>>        Function_Return bRetval
79454>>>    End_Function
79455>>>
79455>>>    Function KeyExists String sSection String sKey Returns Boolean
79457>>>        Handle ho
79457>>>        Boolean bRetval
79457>>>        Get phoSQLConnectionIniFile to ho
79458>>>        Get KeyExists of ho sSection sKey to bRetval
79459>>>        Function_Return bRetval
79460>>>    End_Function
79461>>>
79461>>>    Function EncryptPassword String sPassword Returns String
79463>>>        Handle ho
79463>>>        String sRetval
79463>>>        Get phoSQLConnectionIniFile to ho
79464>>>        Get EncryptPassword of ho sPassword to sRetval
79465>>>        Function_Return sRetval
79466>>>    End_Function
79467>>>
79467>>>    Function DecryptPassword String sPassword Returns String
79469>>>        Handle ho
79469>>>        String sRetval
79469>>>        Get phoSQLConnectionIniFile to ho
79470>>>        Get DecryptPassword of ho sPassword to sRetval
79471>>>        Function_Return sRetval
79472>>>    End_Function
79473>>>
79473>>>    // *** Main Connection Message ***
79473>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
79475>>>        Handle hoDriver
79475>>>        String sConnectionString sError
79475>>>        Boolean bLoginSuccessful
79475>>>
79475>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
79476>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
79477>>>        Set psDriverID of hoDriver to sDriverID
79478>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
79479>>>        If (bLoginSuccessful = False) Begin
79481>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
79482>>>>
79482>>>            If (bExitProgram = True) Begin
79484>>>                Send Exit_Application
79485>>>            End
79485>>>>
79485>>>        End
79485>>>>
79485>>>        Send Destroy of hoDriver
79486>>>    End_Procedure
79487>>>
79487>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
79489>>>        Integer iRetval
79489>>>        Handle hoCLI
79489>>>        String sDriverID
79489>>>
79489>>>        Get psDriverID to sDriverID
79490>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
79491>>>        If (hoCLI <> 0) Begin
79493>>>            Set psDriverID of hoCLI to sDriverID
79494>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
79495>>>            Send Destroy of hoCLI
79496>>>        End
79496>>>>
79496>>>
79496>>>        Function_Return iRetval
79497>>>    End_Function
79498>>>
79498>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
79500>>>        tSQLConnection SQLConnection
79500>>>        tSQLConnection SQLConnection
79500>>>
79500>>>        Set psDriverID to sDriverID
79501>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
79502>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
79503>>>    End_Procedure
79504>>>
79504>>>    // This is needed when e.g. the connection id we have specified in the program code
79504>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
79504>>>    // or the one in the DataFlex Bin folder.)
79504>>>    // We then need to delete the current one before creating a new one.
79504>>>    // This is because the parameters may differ between the program code and the
79504>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
79504>>>    // when one tries to create a Connection ID that already exists.
79504>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
79506>>>        Integer iResult iDriver iNumConn iConn
79506>>>        Handle hoCLI
79506>>>        String sID
79506>>>
79506>>>        If (sDriverID = "" or sConnectionID = "") Begin
79508>>>            Procedure_Return
79509>>>        End
79509>>>>
79509>>>
79509>>>        Move 0 to iResult
79510>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
79511>>>        If (hoCLI <> 0) Begin
79513>>>            Set psDriverID of hoCLI to sDriverID
79514>>>            Get DriverIndex sDriverID to iDriver
79515>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
79518>>>            Decrement iNumConn
79519>>>            For iConn from 0 to iNumConn
79525>>>>
79525>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
79528>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
79530>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
79531>>>                End
79531>>>>
79531>>>            Loop
79532>>>>
79532>>>            Send Destroy of hoCLI
79533>>>        End
79533>>>>
79533>>>
79533>>>    End_Procedure
79534>>>
79534>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
79536>>>        Integer iResult iDriver iNumConn iConn
79536>>>        Handle hoCLI
79536>>>        String sID sConnectionString sVal sDatabase
79536>>>        tSQLConnection SQLConnection
79536>>>        tSQLConnection SQLConnection
79536>>>        Boolean bTrusted
79536>>>
79536>>>        Move 0 to iResult
79537>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
79538>>>        If (hoCLI <> 0) Begin
79540>>>            Set psDriverID of hoCLI to sDriverID
79541>>>            Get DriverIndex sDriverID to iDriver
79542>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
79545>>>            Decrement iNumConn
79546>>>            For iConn from 0 to iNumConn
79552>>>>
79552>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
79555>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
79557>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
79558>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
79561>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
79564>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
79565>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
79568>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
79569>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
79570>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
79571>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
79572>>>
79572>>>                    Case Begin
79572>>>                        Case (sDriverID = MSSQLDRV_ID)
79574>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
79575>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
79576>>>                            Move bTrusted                                               to SQLConnection.bTrusted
79577>>>                            Case Break
79578>>>                        Case (sDriverID = DB2_DRV_ID)
79581>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
79582>>>                            Case Break
79583>>>                        Case (sDriverID = ODBC_DRV_ID)
79586>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
79587>>>                            If (SQLConnection.sServer = "") Begin
79589>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
79590>>>                            End
79590>>>>
79590>>>                            Case Break
79591>>>                        Case (sDriverID = SQLFLEX)
79594>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
79595>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
79596>>>                            If (SQLConnection.bTrusted = True) Begin
79598>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
79599>>>                            End
79599>>>>
79599>>>                            Else Begin
79600>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
79601>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
79602>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
79603>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
79604>>>                            End
79604>>>>
79604>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
79605>>>                            Case Break
79606>>>                        Case (sDriverID = MDSMySQL)
79609>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
79610>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
79611>>>                            If (SQLConnection.bTrusted = True) Begin
79613>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
79614>>>                            End
79614>>>>
79614>>>                            Else Begin
79615>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
79616>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
79617>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
79618>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
79619>>>                            End
79619>>>>
79619>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
79620>>>                            Case Break
79621>>>                        Case (sDriverID = MDSPgSQL)
79624>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
79625>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
79626>>>                            If (SQLConnection.bTrusted = True) Begin
79628>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
79629>>>                            End
79629>>>>
79629>>>                            Else Begin
79630>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
79631>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
79632>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
79633>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
79634>>>                            End
79634>>>>
79634>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
79635>>>                            Case Break
79636>>>
79636>>>                        Case (sDriverID = ORAFLEX)
79639>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
79640>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
79641>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
79642>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
79644>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
79645>>>                            End
79645>>>>
79645>>>                            If (SQLConnection.bTrusted = True) Begin
79647>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
79648>>>                            End
79648>>>>
79648>>>                            Else Begin
79649>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
79650>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
79651>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
79652>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
79653>>>                            End
79653>>>>
79653>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
79654>>>                            Case Break
79655>>>                        Case Else
79655>>>                            Error ("Wrong driver ID passed:" * sDriverID)
79656>>>>
79656>>>                            Case Break
79657>>>                    Case End
79657>>>                End
79657>>>>
79657>>>            Loop
79658>>>>
79658>>>            Send Destroy of hoCLI
79659>>>        End
79659>>>>
79659>>>
79659>>>        Function_Return SQLConnection
79660>>>    End_Function
79661>>>
79661>>>    Function DriverIndex String sDriverID Returns Integer
79663>>>        String  sCurrentDriver
79663>>>        Integer iNumberOfDrivers iDriver iCount
79663>>>
79663>>>        Move 0 to iDriver
79664>>>        Move 0 to iCount
79665>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79668>>>        For iCount from 1 to iNumberOfDrivers
79674>>>>
79674>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
79677>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
79679>>>                Function_Return iCount
79680>>>            End
79680>>>>
79680>>>        Loop
79681>>>>
79681>>>
79681>>>        // If driver not previously loaded; attempt to do so now.
79681>>>        If (iDriver = 0) Begin
79683>>>            Move 0 to LastErr
79684>>>            Load_Driver sDriverID
79685>>>            // If driver could not be loaded.
79685>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
79687>>>                Move -1 to iCount
79688>>>            End
79688>>>>
79688>>>        End
79688>>>>
79688>>>        Function_Return iCount
79689>>>    End_Function
79690>>>
79690>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
79690>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
79692>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
79692>>>        Boolean bTrusted bSilent
79692>>>        Integer iRetval
79692>>>
79692>>>        Move SQLConnection.sDriverID     to sDriverID
79693>>>        Move SQLConnection.sConnectionID to sConnectionID
79694>>>        Move SQLConnection.sServer       to sServer
79695>>>        Move SQLConnection.sDatabase     to sDatabase
79696>>>        Move SQLConnection.bTrusted      to bTrusted
79697>>>        Move SQLConnection.sUserID       to sUserID
79698>>>        Move SQLConnection.sPassword     to sPassword
79699>>>        Move SQLConnection.bSilentLogin  to bSilent
79700>>>
79700>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
79701>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
79701>>>        Get AutoSetConnectionID to iRetval
79702>>>    End_Procedure
79703>>>
79703>>>    // Called when the object is constructed.
79703>>>    // It will check the psDriverID for a ConnectionID and save it
79703>>>    // as psConnectionID property. It is later used whenever a login to
79703>>>    // the database is needed.
79703>>>    Function AutoSetConnectionID Returns Boolean
79705>>>        String sConnectionID sDriverID sConnectionString
79705>>>        Integer iDriver iRetval
79705>>>        Handle hoCLI
79705>>>        Boolean bOK bSilent bMertechDriver
79705>>>
79705>>>        Get pbSilentLogin      to bSilent
79706>>>        Get psConnectionID     to sConnectionID
79707>>>        Get psConnectionString to sConnectionString
79708>>>        // Get the driver Connection ID string & set the psConnectionString property.
79708>>>        Get psDriverID to sDriverID
79709>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
79710>>>        If (bOK = False) Begin
79712>>>            Function_Return False
79713>>>        End
79713>>>>
79713>>>
79713>>>        // Mertech drivers can't use connection ID's.
79713>>>        Get IsMertechDriver sDriverID to bMertechDriver
79714>>>        If (bMertechDriver = True) Begin
79716>>>            // This ensures that the correct Server & Database attributes are set both for
79716>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
79716>>>            Get _MertechSQLManagerHandle to hoCLI
79717>>>            Function_Return (hoCLI <> 0)
79718>>>        End
79718>>>>
79718>>>
79718>>>        Get DriverIndex sDriverID          to iDriver
79719>>>        // If driver not loaded; load it.
79719>>>        If (iDriver = 0) Begin
79721>>>            Load_Driver sDriverID
79722>>>            Get DriverIndex sDriverID      to iDriver
79723>>>        End
79723>>>>
79723>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
79723>>>        If (iDriver = 0) Begin
79725>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
79726>>>>
79726>>>            Function_Return False
79727>>>        End           
79727>>>>
79727>>>        Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
79730>>>        
79730>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
79731>>>        Set psDriverID of hoCLI            to sDriverID
79732>>>        // Delete the connection first; in case it exists
79732>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
79733>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
79734>>>        Send Destroy of hoCLI
79735>>>
79735>>>        Function_Return (iRetval = 0)
79736>>>    End_Function
79737>>>
79737>>>    // Returns the handle of the Mertech SQL handler.
79737>>>    // It also ensures that the correct Server & Database attributes are set both for
79737>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
79737>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
79737>>>    //       So the return value is of no use! But we don't need the handle for this class.
79737>>>    Function _MertechSQLManagerHandle Returns Handle
79739>>>        Handle hoSQLHandler
79739>>>        String sDriverID sServer sDatabase
79739>>>
79739>>>        Move 0 to hoSQLHandler
79740>>>        Get psDriverID to sDriverID
79741>>>        Get psServer   to sServer
79742>>>        Get psDatabase to sDatabase
79743>>>        // This command is used to set the server to be used when opening tables
79743>>>        SET_CURRENT_SQL_SERVER to sServer
79786>>>>
79786>>>        // This command is used to specify which server to use for embedded SQL statements,
79786>>>        // but it has been constructed rather studidly as only constants and not variables
79786>>>        // are allowed...
79786>>>        If (sDriverID = MDSPgSQL) Begin
79788>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
79804>>>        End
79804>>>>
79804>>>        If (sDriverID = MDSMySQL) Begin
79806>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
79822>>>        End
79822>>>>
79822>>>        If (sDriverID = ORAFLEX) Begin
79824>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
79840>>>        End
79840>>>>
79840>>>        If (sDriverID = SQLFLEX) Begin
79842>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
79858>>>        End
79858>>>>
79858>>>
79858>>>        // This command is used to specify which database is used for embedded SQL statements.
79858>>>        SQL_USE_DATABASE sDatabase
79896>>>>
79896>>>        SET_DATABASE_NAME to sDatabase
79934>>>>
79934>>>
79934>>>        // Can't have this here because the property is defined for the cDbUpdateFunctionLibrary class,
79934>>>        // which object may or may not have been created at this point. So don't use the return
79934>>>        // value for this function!
79934>>>        //Get phoSQLManagerMT to hoSQLHandler
79934>>>
79934>>>        Function_Return hoSQLHandler
79935>>>    End_Function
79936>>>
79936>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
79938>>>        Boolean bOK bMertechDriver
79938>>>
79938>>>        Get IsDAWSQLDriver sDriverID to bOK
79939>>>
79939>>>        If (bOK = False) Begin
79941>>>            Get IsMertechDriver sDriverID to bOK
79942>>>        End
79942>>>>
79942>>>
79942>>>        If (bOK = False) Begin
79944>>>            Get IsMertechDriver sDriverID to bMertechDriver
79945>>>            If (bMertechDriver = True) Begin
79947>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
79948>>>>
79948>>>            End
79948>>>>
79948>>>            Else Begin
79949>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
79950>>>>
79950>>>            End
79950>>>>
79950>>>            Function_Return False
79951>>>        End
79951>>>>
79951>>>
79951>>>        Function_Return True
79952>>>    End_Function
79953>>>
79953>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
79955>>>        Boolean bOK
79955>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
79956>>>        Function_Return bOK
79957>>>    End_Function
79958>>>
79958>>>    Function IsMertechDriver String sDriverID Returns Boolean
79960>>>        Boolean bOK
79960>>>        Move False to bOK
79961>>>//        #IFDEF DUF_Use_Mertech_Drivers
79961>>>            Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMYSQL) to bOK
79962>>>//        #ENDIF
79962>>>        Function_Return bOK
79963>>>    End_Function
79964>>>
79964>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
79966>>>        Handle hoIniFile
79966>>>        String sConnect
79966>>>
79966>>>        Get phoSQLConnectionIniFile to hoIniFile
79967>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
79968>>>
79968>>>        Function_Return sConnect
79969>>>    End_Function
79970>>>
79970>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
79970>>>    // Pass a complete driver connection string
79970>>>    // Returns the following as a struct:
79970>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
79970>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
79970>>>    //
79970>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
79972>>>        tSQLConnection SQLConnection
79972>>>        tSQLConnection SQLConnection
79972>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
79972>>>        Boolean bTrusted bSilent bOK
79972>>>        Integer iPos
79972>>>
79972>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
79973>>>        If (bOK = False) Begin
79975>>>            Function_Return SQLConnection
79976>>>        End
79976>>>>
79976>>>
79976>>>        Move False to bTrusted
79977>>>        Move False to bSilent
79978>>>
79978>>>        Case Begin
79978>>>            Case (sDriverID = MSSQLDRV_ID)
79980>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
79981>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
79982>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
79983>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
79984>>>                If (bTrusted = False) Begin
79986>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
79987>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
79988>>>                End
79988>>>>
79988>>>                Case Break
79989>>>
79989>>>            Case (sDriverID = ODBC_DRV_ID)
79992>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
79994>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
79995>>>                End
79995>>>>
79995>>>                Else Begin
79996>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
79997>>>                End
79997>>>>
79997>>>
79997>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
79998>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
79999>>>                If (bTrusted = False) Begin
80001>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
80002>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
80003>>>                End
80003>>>>
80003>>>                Case Break
80004>>>
80004>>>            Case (sDriverID = DB2_DRV_ID)
80007>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
80008>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
80009>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
80010>>>                Case Break
80011>>>
80011>>>            Case (sDriverID = SQLFLEX)
80014>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
80015>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
80016>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
80017>>>                If (bTrusted = False) Begin
80019>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
80020>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
80021>>>                End
80021>>>>
80021>>>                Case Break
80022>>>
80022>>>            Case (sDriverID = ORAFLEX)
80025>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
80026>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
80027>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
80029>>>                    Move (sServer + "/" + sDatabase)                                to sServer
80030>>>                End
80030>>>>
80030>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
80031>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
80032>>>                Case Break
80033>>>
80033>>>            Case (sDriverID = MDSPgSQL)
80036>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
80037>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
80038>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
80039>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
80040>>>                Case Break
80041>>>
80041>>>            Case (sDriverID = MDSMySQL)
80044>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
80045>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
80046>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
80047>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
80048>>>                Case Break
80049>>>
80049>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
80052>>>                Break
80053>>>        Case End
80053>>>
80053>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
80054>>>
80054>>>        // bSilent?
80054>>>        Move (Pos(",0", sConnectionString))                                     to iPos
80055>>>        If (iPos = 0) Begin
80057>>>            Move (Pos(",1", sConnectionString))                                 to iPos
80058>>>        End
80058>>>>
80058>>>        If (iPos = 0) Begin
80060>>>            Move "0"                                                            to sValue
80061>>>        End
80061>>>>
80061>>>        Else Begin
80062>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
80063>>>        End
80063>>>>
80063>>>        Move (If(sValue = 1, True, False))                                      to bSilent
80064>>>
80064>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
80065>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
80066>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
80067>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
80068>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
80069>>>        Move bTrusted                                                           to SQLConnection.bTrusted
80070>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
80071>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
80072>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
80073>>>
80073>>>        Function_Return SQLConnection
80074>>>    End_Function
80075>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
80075>>>>
80075>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
80077>>>>    Integer iStart iEnd
80077>>>>    String sRetval
80077>>>>
80077>>>>    Move (Trim(sConnect)) to sConnect
80078>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
80079>>>>    If (iStart = 0) Begin
80081>>>>        Function_Return ""
80082>>>>    End
80082>>>>>
80082>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
80083>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
80084>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
80086>>>>        Move (Pos(",", sRetval))          to iEnd
80087>>>>    End
80087>>>>>
80087>>>>    Else Begin
80088>>>>        Move (Pos(";", sRetval))          to iEnd
80089>>>>    End
80089>>>>>
80089>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
80091>>>>        Move (Pos(",", sRetval))          to iEnd
80092>>>>        Decrement iEnd
80093>>>>    End
80093>>>>>
80093>>>>    If (iEnd <> 0) Begin
80095>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
80096>>>>    End
80096>>>>>
80096>>>>    Move (Replace("=", sRetval, ""))      to sRetval
80097>>>>
80097>>>>    Function_Return (Trim(sRetval))
80098>>>>End_Function
80099>>>>
80099>>>>
80099>>>
80099>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
80099>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
80101>>>        Handle ho
80101>>>        Integer iIndex
80101>>>        Boolean bRetval bOK
80101>>>        tSQLConnection SQLConnection
80101>>>        tSQLConnection SQLConnection
80101>>>
80101>>>        Get pSQLConnection to SQLConnection
80102>>>        Get phoSQLConnectionIniFile to ho
80103>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
80104>>>        If (iIndex = -1) Begin
80106>>>            Function_Return False
80107>>>        End
80107>>>>
80107>>>
80107>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
80108>>>        Send UpdateConnectionString SQLConnection
80109>>>        If (ghoConnection > 0) Begin
80111>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
80112>>>            If (iIndex <> -1) Begin
80114>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
80115>>>            End
80115>>>>
80115>>>        End
80115>>>>
80115>>>
80115>>>        Function_Return bRetval
80116>>>    End_Function
80117>>>
80117>>>End_Class
80118>Object oSQLConnectionHandler is a cSQLConnectionHandler
80120>    // If a file was passed on the command line - which can be done from the Studio -
80120>    // we change the ini-file path here. (The file name is always the same)
80120>    Procedure End_Construct_Object
80123>        String sPath
80123>        Boolean bExists
80123>        Get psCommandLineIniFilePath of ghoApplication to sPath
80124>        If (sPath <> "") Begin
80126>            Set psIniFilePath to sPath
80127>        End
80127>        Else Begin
80128>            Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
80129>            Set psIniFilePath to sPath
80130>            Get vFolderFormat sPath to sPath
80131>            Get vFilePathExists (sPath + CS_SQLIniFileName) to bExists
80132>            Set pbIniFileExists of ghoApplication to bExists
80133>        End
80133>        Forward Send End_Construct_Object
80135>    End_Procedure
80136>End_Object
80137>
80137>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
80137>>>
80137>>>//****************************************************************************
80137>>>// $Module type: Class
80137>>>// $Module name: cDbUpdateFunctionLibrary
80137>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
80137>>>// Web-site    : http://www.rdctools.com
80137>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
80137>>>//
80137>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
80137>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
80137>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
80137>>>//               with the help of Sql-scripts.
80137>>>//
80137>>>// $Rev History:
80137>>>//    2014-09-05  Module header created
80137>>>//
80137>>>//****************************************************************************
80137>>>Use cApplication.pkg
80137>>>Use seq_chnl.pkg
80137>>>Use GlobalFunctionsProcedures.pkg
80137>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
80137>>>Use Dfcursor.pkg
80137>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
80137>>>>>// StatPnl.pkg - creates the standard status_panel object.
80137>>>>>//
80137>>>>>//
80137>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
80137>>>>>// invoke the standard status panel. The standard has always been that the package name
80137>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
80137>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
80137>>>>>// prior revisions has been replace with status panel that is part of the application.
80137>>>>>// This should work much better and faster than the old sentinel based solution.
80137>>>>>// While the way this operates has changed, the interface has not and therefore this should work
80137>>>>>// with most applications.
80137>>>>>//
80137>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
80137>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
80137>>>>>// a cleaner more robust interface.
80137>>>>>//
80137>>>>>//
80137>>>>>// Compatibility Note:
80137>>>>>//
80137>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
80137>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
80137>>>>>//
80137>>>>>// If for some reason you application will not work using this as a replacement for the old status
80137>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
80137>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
80137>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
80137>>>>>//
80137>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
80137>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
80137>>>>>//
80137>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
80137>>>>>// can still access the new object via the ghoStatusPanel handle.
80137>>>>>//
80137>>>>>//
80137>>>>>// Creating your own Status Panel objects
80137>>>>>//
80137>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
80137>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
80137>>>>>// with a different file and object name and direct your status panel request to the new object.
80137>>>>>//
80137>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
80137>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
80137>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
80137>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
80137>>>>>// e.g.
80137>>>>>//       Procedure UpdateStatusBar
80137>>>>>//           Send DoAdvance of oProgressBar
80137>>>>>//           Send ProcessEvents
80137>>>>>//       End_Procedure
80137>>>>>//
80137>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
80137>>>>>// messages this will be done for you.
80137>>>>>//
80137>>>>>// the standard Interface for status panels are:
80137>>>>>//
80137>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
80137>>>>>// Send Start_StatusPanel      - start the status panel
80137>>>>>// Send Stop_StatusPanel       - stop the status panel
80137>>>>>// Send Update_StatusPanel     - update the status panel's action area
80137>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
80137>>>>>//
80137>>>>>// Get/Set Caption_Text - updates the caption bar
80137>>>>>// Get/Set Title_Text   - updates the title area
80137>>>>>// Get/Set Message_Text - updates the Message area
80137>>>>>// Get/Set Action_Text  - updates the action area
80137>>>>>// Get/Set Button_Text  - updates the button area
80137>>>>>//
80137>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
80137>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
80137>>>>>//
80137>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
80137>>>>>Use cProcessStatusPanel.pkg
80137>>>>>Use cCJSkinFramework.pkg
80137>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cProgressBar.pkg)
80137>>>>>>>Use Windows.pkg
80137>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cWinControl.pkg)
80137>>>>>>>>>Use Windows.pkg
80137>>>>>>>>>
80137>>>>>>>>>// Key State Masks for Mouse Messages
80137>>>>>>>>>
80137>>>>>>>>>Define MK_LBUTTON  for |CI$0001
80137>>>>>>>>>Define MK_RBUTTON  for |CI$0002
80137>>>>>>>>>Define MK_SHIFT    for |CI$0004
80137>>>>>>>>>Define MK_CONTROL  for |CI$0008
80137>>>>>>>>>Define MK_MBUTTON  for |CI$0010
80137>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
80137>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
80137>>>>>>>>>
80137>>>>>>>>>Enum_List // Mouse Key Flags
80137>>>>>>>>>    Define mkLeft    for MK_LBUTTON
80137>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
80137>>>>>>>>>    Define mkRight   for MK_RBUTTON
80137>>>>>>>>>    Define mkX1      for MK_XBUTTON1
80137>>>>>>>>>    Define mkX2      for MK_XBUTTON2
80137>>>>>>>>>    Define mkShift   for MK_SHIFT
80137>>>>>>>>>    Define mkControl for MK_CONTROL
80137>>>>>>>>>End_Enum_List
80137>>>>>>>>>
80137>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
80137>>>>>>>>>    Define mbLeft
80137>>>>>>>>>    Define mbMiddle
80137>>>>>>>>>    Define mbRight
80137>>>>>>>>>    Define mbX1
80137>>>>>>>>>    Define mbX2
80137>>>>>>>>>End_Enum_List
80137>>>>>>>>>
80137>>>>>>>>>Class cWinControl is a DfBaseControl
80138>>>>>>>>>    Procedure Construct_Object
80140>>>>>>>>>        Forward Send Construct_Object
80142>>>>>>>>>        Property Integer private_pbEnabled True
80143>>>>>>>>>        Property Integer private_pbVisible True
80144>>>>>>>>>    End_Procedure
80145>>>>>>>>>    
80145>>>>>>>>>    Procedure End_Construct_Object
80147>>>>>>>>>        Forward Send End_Construct_Object
80149>>>>>>>>>        
80149>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
80150>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
80151>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
80152>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
80153>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
80154>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
80155>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
80156>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
80157>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
80158>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
80159>>>>>>>>>    End_Procedure
80160>>>>>>>>>    
80160>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
80162>>>>>>>>>        //Intentionally cancelled
80162>>>>>>>>>    End_Procedure
80163>>>>>>>>>    
80163>>>>>>>>>    Procedure Command Integer wParam Integer lParam
80165>>>>>>>>>        //Intentionally cancelled
80165>>>>>>>>>    End_Procedure
80166>>>>>>>>>    
80166>>>>>>>>>    Procedure DoRecreateWindow
80168>>>>>>>>>        // Recreates the window
80168>>>>>>>>>        If (Window_Handle(Self)) Begin
80170>>>>>>>>>            // attempt to do this without disturbing the focus tree.
80170>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
80171>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
80172>>>>>>>>>        End
80172>>>>>>>>>>
80172>>>>>>>>>    End_Procedure
80173>>>>>>>>>    
80173>>>>>>>>>    Procedure DoUpdateWindow
80175>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
80175>>>>>>>>>        Handle hWnd
80175>>>>>>>>>        
80175>>>>>>>>>        Get Window_Handle to hWnd
80176>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
80179>>>>>>>>>    End_Procedure
80180>>>>>>>>>    
80180>>>>>>>>>    Procedure Page Integer iState
80182>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
80183>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
80184>>>>>>>>>        Forward Send Page iState
80186>>>>>>>>>    End_Procedure
80187>>>>>>>>>    
80187>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
80189>>>>>>>>>        Integer x y eButton
80189>>>>>>>>>        
80189>>>>>>>>>        Move (Hi(lParam))  to y
80190>>>>>>>>>        Move (Low(lParam)) to x
80191>>>>>>>>>        
80191>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
80192>>>>>>>>>    End_Procedure
80193>>>>>>>>>    
80193>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
80195>>>>>>>>>        Integer x y eButton
80195>>>>>>>>>        
80195>>>>>>>>>        Move (Hi(lParam))  to y
80196>>>>>>>>>        Move (Low(lParam)) to x
80197>>>>>>>>>        
80197>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
80198>>>>>>>>>    End_Procedure
80199>>>>>>>>>    
80199>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
80201>>>>>>>>>        Integer x y eButton
80201>>>>>>>>>        
80201>>>>>>>>>        Move (Hi(lParam))  to y
80202>>>>>>>>>        Move (Low(lParam)) to x
80203>>>>>>>>>        
80203>>>>>>>>>        Send OnMouseUp mbRight x y wParam
80204>>>>>>>>>    End_Procedure
80205>>>>>>>>>    
80205>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
80207>>>>>>>>>        Integer x y eButton fKeys
80207>>>>>>>>>        
80207>>>>>>>>>        Move (Hi(lParam))  to y
80208>>>>>>>>>        Move (Low(lParam)) to x
80209>>>>>>>>>        
80209>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
80210>>>>>>>>>    End_Procedure
80211>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
80213>>>>>>>>>        Integer x y eButton
80213>>>>>>>>>        
80213>>>>>>>>>        Move (Hi(lParam))  to y
80214>>>>>>>>>        Move (Low(lParam)) to x
80215>>>>>>>>>        
80215>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
80216>>>>>>>>>    End_Procedure
80217>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
80219>>>>>>>>>        Integer x y eButton
80219>>>>>>>>>        
80219>>>>>>>>>        Move (Hi(lParam))  to y
80220>>>>>>>>>        Move (Low(lParam)) to x
80221>>>>>>>>>        
80221>>>>>>>>>        Send OnMouseDown mbRight x y wParam
80222>>>>>>>>>    End_Procedure
80223>>>>>>>>>    
80223>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
80225>>>>>>>>>        Integer x y eButton
80225>>>>>>>>>        
80225>>>>>>>>>        Move (Hi(lParam))  to y
80226>>>>>>>>>        Move (Low(lParam)) to x
80227>>>>>>>>>        
80227>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
80228>>>>>>>>>    End_Procedure
80229>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
80231>>>>>>>>>        Integer x y eButton
80231>>>>>>>>>        
80231>>>>>>>>>        Move (Hi(lParam))  to y
80232>>>>>>>>>        Move (Low(lParam)) to x
80233>>>>>>>>>        
80233>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
80234>>>>>>>>>    End_Procedure
80235>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
80237>>>>>>>>>        Integer x y eButton
80237>>>>>>>>>        
80237>>>>>>>>>        Move (Hi(lParam))  to y
80238>>>>>>>>>        Move (Low(lParam)) to x
80239>>>>>>>>>        
80239>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
80240>>>>>>>>>    End_Procedure
80241>>>>>>>>>    
80241>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
80243>>>>>>>>>        Integer x y eButton
80243>>>>>>>>>        
80243>>>>>>>>>        Move (Hi(lParam))  to y
80244>>>>>>>>>        Move (Low(lParam)) to x
80245>>>>>>>>>        
80245>>>>>>>>>        Send OnMouseMove x y wParam
80246>>>>>>>>>    End_Procedure
80247>>>>>>>>>    
80247>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
80249>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
80249>>>>>>>>>        //String sButton
80249>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
80249>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
80249>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
80249>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
80249>>>>>>>>>        
80249>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
80249>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
80249>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
80249>>>>>>>>>    End_Procedure
80250>>>>>>>>>    
80250>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
80252>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
80252>>>>>>>>>        //String sButton
80252>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
80252>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
80252>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
80252>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
80252>>>>>>>>>        
80252>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
80252>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
80252>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
80252>>>>>>>>>    End_Procedure
80253>>>>>>>>>    
80253>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
80255>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
80255>>>>>>>>>        //String sButton
80255>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
80255>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
80255>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
80255>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
80255>>>>>>>>>        
80255>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
80255>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
80255>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
80255>>>>>>>>>    End_Procedure
80256>>>>>>>>>    
80256>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
80258>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
80258>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
80258>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
80258>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
80258>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
80258>>>>>>>>>        
80258>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
80258>>>>>>>>>    End_Procedure
80259>>>>>>>>>    
80259>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
80261>>>>>>>>>        Handle hWnd
80261>>>>>>>>>        
80261>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
80263>>>>>>>>>            Set private_pbEnabled to bEnabled
80264>>>>>>>>>            Get Window_Handle to hWnd
80265>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
80268>>>>>>>>>        End
80268>>>>>>>>>>
80268>>>>>>>>>    End_Procedure
80269>>>>>>>>>    Function pbEnabled Returns Boolean
80271>>>>>>>>>        Function_Return (private_pbEnabled(Self))
80272>>>>>>>>>    End_Function
80273>>>>>>>>>    
80273>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
80275>>>>>>>>>        Handle  hWnd
80275>>>>>>>>>        Integer iVoid
80275>>>>>>>>>        
80275>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
80277>>>>>>>>>            Set private_pbVisible to bVisible
80278>>>>>>>>>            Get Window_Handle to hWnd
80279>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
80282>>>>>>>>>        End
80282>>>>>>>>>>
80282>>>>>>>>>    End_Procedure
80283>>>>>>>>>    Function pbVisible Returns Boolean
80285>>>>>>>>>        Function_Return (private_pbVisible(Self))
80286>>>>>>>>>    End_Function
80287>>>>>>>>>    
80287>>>>>>>>>End_Class
80288>>>>>>>Use CommCtrl.pkg
80288>>>>>>>
80288>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
80288>>>>>>>Class cProgressBar is a cWinControl
80289>>>>>>>    
80289>>>>>>>    Procedure Construct_Object
80291>>>>>>>        Forward Send Construct_Object
80293>>>>>>>        Property Integer private_piMinimum
80294>>>>>>>        Property Integer private_piMaximum   100
80295>>>>>>>        Property Integer private_piAdvanceBy 10
80296>>>>>>>        Property Integer private_piPosition
80297>>>>>>>        Property Integer private_pbVertical  False
80298>>>>>>>        Property Integer private_pbSmooth    False
80299>>>>>>>        Property Integer private_piBackColor clDefault
80300>>>>>>>        Property Integer private_piBarColor  clDefault
80301>>>>>>>        
80301>>>>>>>        Send Define_ToolTip_Support_Mixin
80302>>>>>>>        
80302>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
80303>>>>>>>        Set Focus_Mode to NonFocusable
80304>>>>>>>        Set Skip_State to True
80305>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
80306>>>>>>>    End_Procedure
80307>>>>>>>    
80307>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
80308>>>>>>>    
80308>>>>>>>    Procedure Set piMinimum Integer iMin
80310>>>>>>>        Integer iMax
80310>>>>>>>        
80310>>>>>>>        Set private_piMinimum to iMin
80311>>>>>>>        Get private_piMaximum to iMax
80312>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
80313>>>>>>>    End_Procedure
80314>>>>>>>    Function piMinimum Returns Integer
80316>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
80319>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
80321>>>>>>>    End_Function
80322>>>>>>>    
80322>>>>>>>    Procedure Set piMaximum Integer iMax
80324>>>>>>>        Integer iMin
80324>>>>>>>        
80324>>>>>>>        Set private_piMaximum to iMax
80325>>>>>>>        Get private_piMinimum to iMin
80326>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
80327>>>>>>>    End_Procedure
80328>>>>>>>    Function piMaximum Returns Integer
80330>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
80333>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
80335>>>>>>>    End_Function
80336>>>>>>>    
80336>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
80338>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
80339>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
80340>>>>>>>    End_Procedure
80341>>>>>>>    Function piAdvanceBy Returns Integer
80343>>>>>>>        Function_Return (private_piAdvanceBy(Self))
80344>>>>>>>    End_Function
80345>>>>>>>    
80345>>>>>>>    Procedure Set piPosition Integer iPos
80347>>>>>>>        Set private_piPosition to iPos
80348>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
80349>>>>>>>    End_Procedure
80350>>>>>>>    
80350>>>>>>>    Function piPosition Returns Integer
80352>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
80355>>>>>>>        Else;            Function_Return (private_piPosition(Self))
80357>>>>>>>    End_Function
80358>>>>>>>    
80358>>>>>>>    Procedure Set pbVertical Boolean bVertical
80360>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
80362>>>>>>>            Set private_pbVertical to bVertical
80363>>>>>>>            Send DoRecreateWindow
80364>>>>>>>        End
80364>>>>>>>>
80364>>>>>>>    End_Procedure
80365>>>>>>>    
80365>>>>>>>    Function pbVertical Returns Boolean
80367>>>>>>>        Function_Return (private_pbVertical(Self))
80368>>>>>>>    End_Function
80369>>>>>>>    
80369>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
80371>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
80373>>>>>>>            Set private_pbSmooth to bSmooth
80374>>>>>>>            Send DoRecreateWindow
80375>>>>>>>        End
80375>>>>>>>>
80375>>>>>>>    End_Procedure
80376>>>>>>>    Function pbSmooth Returns Boolean
80378>>>>>>>        Function_Return (private_pbSmooth(Self))
80379>>>>>>>    End_Function
80380>>>>>>>    
80380>>>>>>>    Procedure Set piBackColor Integer rgbColor
80382>>>>>>>        Set private_piBackColor to rgbColor
80383>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
80384>>>>>>>    End_Procedure
80385>>>>>>>    Function piBackColor Returns Integer
80387>>>>>>>        Function_Return (private_piBackColor(Self))
80388>>>>>>>    End_Function
80389>>>>>>>    
80389>>>>>>>    Procedure Set piBarColor Integer rgbColor
80391>>>>>>>        Set private_piBarColor to rgbColor
80392>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
80393>>>>>>>    End_Procedure
80394>>>>>>>    Function piBarColor Returns Integer
80396>>>>>>>        Function_Return (private_piBarColor(Self))
80397>>>>>>>    End_Function
80398>>>>>>>    
80398>>>>>>>    Procedure DoAdvance
80400>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
80401>>>>>>>    End_Procedure
80402>>>>>>>    
80402>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
80404>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
80405>>>>>>>    End_Procedure
80406>>>>>>>    
80406>>>>>>>    Procedure private_DoInitWindow
80408>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
80409>>>>>>>        Set piBackColor to (private_piBackColor(Self))
80410>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
80411>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
80412>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
80413>>>>>>>        Set piPosition  to (private_piPosition(Self))
80414>>>>>>>    End_Procedure
80415>>>>>>>    
80415>>>>>>>    Procedure Page_Object Integer iState
80417>>>>>>>        Handle hWnd
80417>>>>>>>        
80417>>>>>>>        Get Window_Handle to hWnd
80418>>>>>>>        If (hWnd=0 and iState) Begin
80420>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
80421>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
80422>>>>>>>            Forward Send Page_Object True
80424>>>>>>>        End
80424>>>>>>>>
80424>>>>>>>        Else ;            Forward Send Page_Object iState
80427>>>>>>>        
80427>>>>>>>        // Handle tooltip support....
80427>>>>>>>        If (iState = 0) Begin
80429>>>>>>>            Send RequestDeleteToolTip
80430>>>>>>>        End
80430>>>>>>>>
80430>>>>>>>        Else Begin
80431>>>>>>>            Send RequestAddToolTip
80432>>>>>>>        End
80432>>>>>>>>
80432>>>>>>>    End_Procedure
80433>>>>>>>    
80433>>>>>>>    Procedure Page Integer iState
80435>>>>>>>        Forward Send Page iState
80437>>>>>>>        If (iState =1);            Send private_DoInitWindow
80440>>>>>>>    End_Procedure
80441>>>>>>>    
80441>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
80441>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
80441>>>>>>>    // is implemented in a mixin class.
80441>>>>>>>    Procedure RequestAddToolTip
80443>>>>>>>        Send AddToolTip
80444>>>>>>>    End_Procedure
80445>>>>>>>    
80445>>>>>>>    
80445>>>>>>>    // Called by Page_Object. Handles tooltip removal.
80445>>>>>>>    Procedure RequestDeleteToolTip
80447>>>>>>>        Send DeleteToolTip
80448>>>>>>>    End_Procedure
80449>>>>>>>End_Class
80450>>>>>Use Windows.pkg
80450>>>>>Use DUFLanguageConstants.inc
80450>>>>>Use Statpnl.pkg
80450>>>>>
80450>>>>>
80450>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
80450>>>>>
80450>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
80450>>>>>
80450>>>>>Object Status_Panel is a cProcessStatusPanel
80452>>>>>    Set Size to 152 222
80453>>>>>    Set Border_Style to Border_Dialog
80454>>>>>    Set Icon to "Default.ico"
80455>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
80456>>>>>
80456>>>>>    Property Boolean Cancel_Button_Visible_State True
80458>>>>>
80458>>>>>    Procedure Activate
80461>>>>>        Integer iSizeBefore
80461>>>>>        Get GuiSize to iSizeBefore
80462>>>>>        Forward Send Activate
80464>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
80465>>>>>    End_Procedure
80466>>>>>
80466>>>>>    Procedure End_Construct_Object
80469>>>>>        Forward Send End_Construct_Object
80471>>>>>        Set Label of oTitleTxt      to ""
80472>>>>>        Set Label of oTableNameTxt  to ""
80473>>>>>        Set Label of oMessageTxt    to ""
80474>>>>>        Set Label of oActionTxt     to ""
80475>>>>>    End_Procedure
80476>>>>>
80476>>>>>    Object oTitleTxt is a TextBox
80478>>>>>        Set Location to 5 21
80479>>>>>        Set Size to 8 179
80480>>>>>        Set Auto_Size_State to False
80481>>>>>        Set Justification_Mode  to jMode_Center
80482>>>>>        Set Label to "This is the Title Text"
80483>>>>>    End_Object
80484>>>>>
80484>>>>>    Object oTableNameTxt is a TextBox
80486>>>>>        Set Size to 19 204
80487>>>>>        Set Location to 18 9
80488>>>>>        Set Auto_Size_State to False
80489>>>>>        Set Justification_Mode to JMode_Left
80490>>>>>        Set Label to "This is the TableName Text"
80491>>>>>    End_Object
80492>>>>>
80492>>>>>    Object oMessageTxt is a TextBox
80494>>>>>        Set Location to 39 9
80495>>>>>        Set Size to 19 204
80496>>>>>        Set Auto_Size_State to False
80497>>>>>        Set Justification_Mode to JMode_Left
80498>>>>>        Set Label to "This is the Message text"
80499>>>>>    End_Object
80500>>>>>
80500>>>>>    Object oActionTxt is a TextBox
80502>>>>>        Set Size to 16 204
80503>>>>>        Set Location to 60 9
80504>>>>>        Set Auto_Size_State to False
80505>>>>>        Set Justification_Mode to JMode_Left
80506>>>>>        Set Label to "This is the Action Text"
80507>>>>>    End_Object
80508>>>>>
80508>>>>>    Object oStopButton is a Button
80510>>>>>        Set Location to 123 82
80511>>>>>        Set Label to C_$Cancel
80512>>>>>
80512>>>>>        Procedure OnClick 
80515>>>>>            Integer iRetval
80515>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
80516>>>>>            If (iRetval = MBR_Yes) Begin
80518>>>>>                Send Exit_Application
80519>>>>>            End
80519>>>>>>
80519>>>>>        End_Procedure
80520>>>>>
80520>>>>>    End_Object
80521>>>>>
80521>>>>>    Object oPercentage_tb is a TextBox
80523>>>>>        Set Location to 74 196
80524>>>>>        Set Size to 10 25
80525>>>>>//        Set Label to "% Done"
80525>>>>>    End_Object
80526>>>>>
80526>>>>>    Object oCopyRight is a TextBox
80528>>>>>        Set Location to 140 21
80529>>>>>        Set Size to 9 197
80530>>>>>        Set FontPointHeight to 8
80531>>>>>        Set Auto_Size_State to False
80532>>>>>        Set Justification_Mode  to jMode_Center
80533>>>>>        Set Label to "Copyright 2001-2020 RDC Tools International"
80534>>>>>    End_Object
80535>>>>>
80535>>>>>    Object oProgressBar is a cProgressBar
80537>>>>>        Set Size to 10 179
80538>>>>>        Set Location to 83 22
80539>>>>>        Set pbVisible to True // default
80540>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
80541>>>>>    End_Object
80542>>>>>
80542>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
80545>>>>>        Set pbVisible of ghoProgressBar to bVisible
80546>>>>>    End_Procedure
80547>>>>>
80547>>>>>    Function Progress_Bar_Visible_State Returns Boolean
80550>>>>>        Boolean bVisible
80550>>>>>        Get pbVisible of ghoProgressBar to bVisible
80551>>>>>        Function_Return (bVisible)
80552>>>>>    End_Function
80553>>>>>
80553>>>>>    Object oProgressBarOverall is a cProgressBar
80555>>>>>        Set Size to 10 179
80556>>>>>        Set Location to 107 22
80557>>>>>        Set pbVisible to True // default
80558>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
80559>>>>>    End_Object
80560>>>>>
80560>>>>>    Object oOverallProgress_tb is a TextBox
80562>>>>>        Set Size to 10 65
80563>>>>>        Set Location to 95 24
80564>>>>>        Set Label to "Overall Progress"
80565>>>>>    End_Object
80566>>>>>
80566>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
80569>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
80570>>>>>    End_Procedure
80571>>>>>
80571>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
80574>>>>>        Boolean bVisible
80574>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
80575>>>>>        Function_Return (bVisible)
80576>>>>>    End_Function
80577>>>>>
80577>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
80577>>>>>    // objects defined within this instance of the status panel.
80577>>>>>
80577>>>>>    // note: all of the messages that change text should be forwarded
80577>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
80577>>>>>
80577>>>>>    Procedure Set Message_Text String sText
80580>>>>>        Set Label of oMessageTxt to sText
80581>>>>>        Forward Set Message_Text to sText
80583>>>>>    End_Procedure
80584>>>>>
80584>>>>>    Function Message_Text Returns String
80587>>>>>        Function_Return (Label(oMessageTxt))
80588>>>>>    End_Function
80589>>>>>
80589>>>>>    Procedure Set Action_Text String sText
80592>>>>>        Set Label of oActionTxt to sText
80593>>>>>        Forward Set Action_Text to sText
80595>>>>>    End_Procedure
80596>>>>>
80596>>>>>    Function Action_Text Returns String
80599>>>>>        Function_Return (Label(oActionTxt))
80600>>>>>    End_Function
80601>>>>>
80601>>>>>    Procedure Set Button_Text String sText
80604>>>>>        Set Label of oStopButton to sText
80605>>>>>        Forward Set Button_Text to sText
80607>>>>>    End_Procedure
80608>>>>>
80608>>>>>    Function Button_Text Returns String
80611>>>>>        Function_Return (Label(oStopButton))
80612>>>>>    End_Function
80613>>>>>
80613>>>>>    Procedure Set Title_Text String sText
80616>>>>>        Set Label of oTitleTxt to sText
80617>>>>>        Forward Set Title_Text to sText
80619>>>>>    End_Procedure
80620>>>>>
80620>>>>>    Function Title_Text Returns String
80623>>>>>        Function_Return (Label(oTitleTxt))
80624>>>>>    End_Function
80625>>>>>
80625>>>>>    Procedure Set TableName_Text String sText
80628>>>>>        Set Label of oTableNameTxt to sText
80629>>>>>    End_Procedure
80630>>>>>
80630>>>>>    Function TableName_Text Returns String
80633>>>>>        Function_Return (Label(oTableNameTxt))
80634>>>>>    End_Function
80635>>>>>
80635>>>>>    Procedure Set License_Text String sText
80638>>>>>//        Set Label of oLicense_txt to sText
80638>>>>>    End_Procedure
80639>>>>>
80639>>>>>    // gets called when status panel is activated passing whether a button
80639>>>>>    // should appear
80639>>>>>    Procedure EnableCancelButton Boolean bEnable
80642>>>>>        Boolean bVisible
80642>>>>>        Get Cancel_Button_Visible_State to bVisible
80643>>>>>        If (bEnable = False) Begin
80645>>>>>            Set Visible_State of oStopButton to bVisible
80646>>>>>        End
80646>>>>>>
80646>>>>>        Set Enabled_State of oStopButton to bEnable
80647>>>>>    End_Procedure
80648>>>>>
80648>>>>>    Procedure Reset_StatusPanel
80651>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
80652>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
80653>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
80654>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
80655>>>>>    End_Procedure
80656>>>>>
80656>>>>>//    Object oProgressBar is a cProgressBar
80656>>>>>//        Move Self to ghoProgressBar
80656>>>>>//        Set Location to 1 25
80656>>>>>//        Set Size to 9 173
80656>>>>>//        Set piMinimum        to 0
80656>>>>>//        Set piMaximum        to 2000
80656>>>>>//        Set piAdvanceBy      to 100
80656>>>>>//        Set pbSmooth to True
80656>>>>>//
80656>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
80656>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
80656>>>>>//        // color will show correctly.
80656>>>>>//        Procedure Page Integer iPageObject
80656>>>>>//            Handle hWin
80656>>>>>//            Forward Send Page iPageObject
80656>>>>>//            If (ghoSkinFramework <> 0) Begin
80656>>>>>//                Get Window_Handle to hWin
80656>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
80656>>>>>//            End
80656>>>>>//        End_Procedure
80656>>>>>//    End_Object
80656>>>>>
80656>>>>>End_Object
80657>>>>>
80657>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
80657>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
80657>>>>>//
80657>>>>>// We need to create a mixin class for the library.
80657>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
80657>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
80657>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
80657>>>>>// Note: This class should _not_ have a construct_object defined.
80657>>>>>//
80657>>>>>Use VdfBase.pkg
80657>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\WinUuid.pkg)
80657>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll Address Uuid Returns Integer
80658>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringA" Rpcrt4.dll Address aUuid Address lpUUIDString Returns Integer
80659>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll Address aUuid Returns Integer
80660>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeA" Rpcrt4.dll Address pStr Returns Integer
80661>>>>>>>
80661>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
80661>>>>>>>Function RandomHexUUID Global Returns String
80663>>>>>>>    Address pUUID pUUIDStr
80663>>>>>>>    Integer iRetval iOffset iChar
80663>>>>>>>    String sUUID sKey
80663>>>>>>>    
80663>>>>>>>    Move (Alloc(16)) to pUUID
80664>>>>>>>    
80664>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
80665>>>>>>>    
80665>>>>>>>    If (iRetval = 0) Begin
80667>>>>>>>        Move 0 to pUUIDStr
80668>>>>>>>        
80668>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
80669>>>>>>>        If (iRetval = 0) Begin
80671>>>>>>>            Move pUUIDStr to sUUID
80672>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
80673>>>>>>>            
80673>>>>>>>            Move (Uppercase (sUUID)) to sUUID
80674>>>>>>>        End
80674>>>>>>>>
80674>>>>>>>    End
80674>>>>>>>>
80674>>>>>>>    
80674>>>>>>>    Move (Free(pUUID)) to iRetval
80675>>>>>>>    
80675>>>>>>>    Function_Return sUUID
80676>>>>>>>End_Function
80677>>>>>>>
80677>>>>>>>
80677>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
80677>>>>>>>Function SeqHexUUID Global Returns String
80679>>>>>>>    Address pUUID pUUIDStr
80679>>>>>>>    Integer iRetval iOffset iChar
80679>>>>>>>    String sUUID sKey
80679>>>>>>>    
80679>>>>>>>    Move (Alloc(16)) to pUUID
80680>>>>>>>    
80680>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
80681>>>>>>>    
80681>>>>>>>    If (iRetval = 0) Begin
80683>>>>>>>        Move 0 to pUUIDStr
80684>>>>>>>        
80684>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
80685>>>>>>>        If (iRetval = 0) Begin
80687>>>>>>>            Move pUUIDStr to sUUID
80688>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
80689>>>>>>>            
80689>>>>>>>            Move (Uppercase (sUUID)) to sUUID
80690>>>>>>>        End
80690>>>>>>>>
80690>>>>>>>    End
80690>>>>>>>>
80690>>>>>>>    
80690>>>>>>>    Move (Free(pUUID)) to iRetval
80691>>>>>>>    
80691>>>>>>>    Function_Return sUUID
80692>>>>>>>End_Function
80693>>>>>Use cli.pkg
80693>>>>>Use sql.pkg
80693>>>>>Use MSSqldrv.pkg
80693>>>>>Use db2_drv.pkg
80693>>>>>Use odbc_drv.pkg
80693>>>>>Use DFBTRDRV.PKG
80693>>>>>Use cSQLConnectionIniFile.inc
80693>>>>>Use cDbUpdateFunctionLibrary.inc
80693>>>>>
80693>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
80694>>>>>    Procedure CreateDbUpdateLibraryProperties
80696>>>>>        Handle hoSQLManagerMT
80696>>>>>
80696>>>>>        Property String private.psUseDatabase ""
80697>>>>>
80697>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
80697>>>>>        Property Handle  private.phCurrentTable 0
80698>>>>>        Property Integer private.piCurrentField 0
80699>>>>>
80699>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
80700>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
80701>>>>>
80701>>>>>        Property Handle phoSQLManagerMT
80702>>>>>            Move (Create(Self,RefClass(cSQLHandleManagerDUF))) to hoSQLManagerMT
80703>>>>>            Set phoSQLManagerMT to hoSQLManagerMT
80704>>>>>
80704>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
80705>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
80706>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
80707>>>>>        Property Handle phoSQLConnectionHandler 0
80708>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
80709>>>>>
80709>>>>>        Property Boolean pbHandleQueryErrors True
80710>>>>>
80710>>>>>        Property tSqlColumnNew[] paQueryColumns
80711>>>>>        Property String[] paSQLFetchResults
80712>>>>>
80712>>>>>        // Error handling
80712>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
80713>>>>>        Property Boolean pbSqlError False
80714>>>>>        Property tSqlErrorArray paSqlErrorArray
80715>>>>>        Property Boolean pbProcessingError False
80716>>>>>
80716>>>>>        // Statistics on query
80716>>>>>        Property TimeSpan ptsTotalQueryTime
80717>>>>>        Property TimeSpan ptsQueryExec
80718>>>>>        Property TimeSpan ptsFetchResults
80719>>>>>        Property Integer piColumns 0
80720>>>>>        Property Integer piRows 0
80721>>>>>        Property Integer piRowType 0
80722>>>>>        Property String[] paQueryMessages
80723>>>>>        Property String psSQLStatementString
80724>>>>>
80724>>>>>        Property Integer[] paTableConvertExceptions
80725>>>>>
80725>>>>>        Property Integer[] paTableDateCorrectionExceptions
80726>>>>>
80726>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
80726>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
80726>>>>>        // the statements in smaller chunks than to execute them all at the same time.
80726>>>>>        Property Integer piChunkMax 500
80727>>>>>
80727>>>>>        // Fill the paSQLKeywordArray array with values;
80727>>>>>        Send SetupSQLKeywordArray
80728>>>>>        Move Self to ghoDbUpdateFunctionLibrary
80729>>>>>    End_Procedure
80730>>>>>
80730>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
80730>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
80732>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
80734>>>>>            Function_Return (EQ)
80735>>>>>        End
80735>>>>>>
80735>>>>>        Function_Return (GT)
80736>>>>>    End_Function
80737>>>>>
80737>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
80737>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
80739>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
80742>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
80745>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
80748>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
80751>>>>>
80751>>>>>        Function_Return (EQ)
80752>>>>>    End_Function
80753>>>>>
80753>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
80755>>>>>        tSQLKeyWords[] SQLKeywordArray
80755>>>>>        tSQLKeyWords[] SQLKeywordArray
80756>>>>>        Integer iSize
80756>>>>>
80756>>>>>        Get paSQLKeywordArray to SQLKeywordArray
80757>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
80758>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
80759>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
80760>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
80761>>>>>
80761>>>>>        Set paSQLKeywordArray to SQLKeywordArray
80762>>>>>    End_Procedure
80763>>>>>
80763>>>>>    // Creates a struct array with all SQL keywords
80763>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
80763>>>>>    // have slightly different wording.
80763>>>>>    // If a new EN_dbTypexxx type is added; additions
80763>>>>>    // needs to be done for every keyword group below.
80763>>>>>    Procedure SetupSQLKeywordArray
80765>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
80765>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
80767>>>>>
80767>>>>>        // This should only be called once; but in case it is
80767>>>>>        // we delete the array first.
80767>>>>>        Set paSQLKeywordArray to SQLKeywordArray
80768>>>>>
80768>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
80768>>>>>        //
80768>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
80769>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
80770>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
80771>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
80772>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
80773>>>>>
80773>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
80774>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
80775>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
80776>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
80777>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
80778>>>>>
80778>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
80779>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
80780>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
80781>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
80782>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
80783>>>>>
80783>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
80784>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
80785>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
80786>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
80787>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
80788>>>>>
80788>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
80789>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
80790>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
80791>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
80792>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
80793>>>>>
80793>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
80794>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
80795>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
80796>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
80797>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
80798>>>>>
80798>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
80799>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
80800>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
80801>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
80802>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
80803>>>>>
80803>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
80804>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
80805>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
80806>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
80807>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
80808>>>>>
80808>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
80809>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
80810>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
80811>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
80812>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
80813>>>>>
80813>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
80814>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
80815>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
80816>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
80817>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
80818>>>>>
80818>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
80819>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
80820>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
80821>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
80822>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
80823>>>>>
80823>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
80824>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
80825>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
80826>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
80827>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
80828>>>>>
80828>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
80829>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
80830>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
80831>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
80832>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
80833>>>>>
80833>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
80834>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
80835>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
80836>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
80837>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
80838>>>>>
80838>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
80839>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
80840>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
80841>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
80842>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
80843>>>>>
80843>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
80844>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
80845>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
80846>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
80847>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
80848>>>>>
80848>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
80849>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
80850>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
80851>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
80852>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
80853>>>>>
80853>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
80854>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
80855>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
80856>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
80857>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
80858>>>>>
80858>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
80859>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
80860>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
80861>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
80862>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
80863>>>>>
80863>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
80864>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
80865>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
80866>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
80867>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
80868>>>>>
80868>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
80869>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
80870>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
80871>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
80872>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
80873>>>>>
80873>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
80874>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
80875>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
80876>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
80877>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
80878>>>>>
80878>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
80879>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
80880>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
80881>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
80882>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
80883>>>>>
80883>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
80884>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
80885>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
80886>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
80887>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
80888>>>>>
80888>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
80889>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
80890>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
80891>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
80892>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
80893>>>>>
80893>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
80894>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
80895>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
80896>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
80897>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
80898>>>>>
80898>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
80899>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
80900>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
80901>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
80902>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
80903>>>>>
80903>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
80904>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
80905>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
80906>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
80907>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
80908>>>>>
80908>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
80909>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
80910>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
80911>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
80912>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
80913>>>>>
80913>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
80914>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
80915>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
80916>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
80917>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
80918>>>>>
80918>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
80919>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
80920>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
80921>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
80922>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
80923>>>>>
80923>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
80924>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
80925>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
80926>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
80927>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
80928>>>>>
80928>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
80929>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
80930>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
80931>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
80932>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
80933>>>>>
80933>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
80934>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
80935>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
80936>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
80937>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
80938>>>>>
80938>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
80939>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
80940>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
80941>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
80942>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
80943>>>>>
80943>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
80944>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
80945>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
80946>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
80947>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
80948>>>>>
80948>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
80949>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
80950>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
80951>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
80952>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
80953>>>>>
80953>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
80954>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
80955>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
80956>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
80957>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
80958>>>>>
80958>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
80959>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
80960>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
80961>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
80962>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
80963>>>>>
80963>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
80964>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
80965>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
80966>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
80967>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
80968>>>>>
80968>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
80969>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
80970>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
80971>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
80972>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
80973>>>>>
80973>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
80974>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
80975>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
80976>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
80977>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
80978>>>>>
80978>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
80979>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
80980>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
80981>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
80982>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
80983>>>>>
80983>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
80984>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
80985>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
80986>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
80987>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
80988>>>>>
80988>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
80988>>>>>        Get paSQLKeywordArray to SQLKeywordArray
80989>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
80990>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
80991>>>>>
80991>>>>>    End_Procedure
80992>>>>>
80992>>>>>End_Class
80993>>>Use cSQLConnectionHandler.pkg
80993>>>Use vWin32fh.pkg
80993>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
80993>>>>>
80993>>>>>Use LanguageText.pkg
80993>>>>>Use Windows.pkg
80993>>>>>Use Dfclient.pkg
80993>>>>>Use DFbitmap.pkg
80993>>>>>Use GlobalFunctionsProcedures.pkg
80993>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cRichEdit.pkg)
80993>>>>>>>Use Windows.pkg
80993>>>>>>>Use cEdit_Mixin.pkg
80993>>>>>>>
80993>>>>>>>// constants used for RichEdit Properties
80993>>>>>>>// peAlignment
80993>>>>>>>Enum_List
80993>>>>>>>    Define alLeft   for 1
80993>>>>>>>    Define alRight  for 2
80993>>>>>>>    Define alCenter for 3
80993>>>>>>>End_Enum_List
80993>>>>>>>
80993>>>>>>>// peBullets
80993>>>>>>>Enum_List
80993>>>>>>>    Define buNone
80993>>>>>>>    Define buBullets
80993>>>>>>>    Define buArabicNumbers
80993>>>>>>>    Define buLowerLetters
80993>>>>>>>    Define buUpperLetters
80993>>>>>>>    Define buLowerRomans
80993>>>>>>>    Define buUpperRomans
80993>>>>>>>End_Enum_List
80993>>>>>>>
80993>>>>>>>// peBulletStyle
80993>>>>>>>Enum_List
80993>>>>>>>    Define busRightParen   for 0
80993>>>>>>>    Define busEncloseParen for 256
80993>>>>>>>    Define busPeriod       for 512
80993>>>>>>>    Define busNumberOnly   for 768
80993>>>>>>>    Define busNoDisplay    for 1024
80993>>>>>>>End_Enum_List
80993>>>>>>>
80993>>>>>>>// peLineSpacingType
80993>>>>>>>Enum_List
80993>>>>>>>    Define lstSingle
80993>>>>>>>    Define lstSingleAndOneHalf
80993>>>>>>>    Define lstDouble
80993>>>>>>>End_Enum_List
80993>>>>>>>
80993>>>>>>>Class cRichEdit is a DFBaseRichEdit
80994>>>>>>>    
80994>>>>>>>    Procedure Construct_Object
80996>>>>>>>        Forward Send Construct_Object
80998>>>>>>>        Send Define_cEdit_Mixin
80999>>>>>>>        
80999>>>>>>>        On_Key Key_Ctrl+Key_B Send ToggleBold
81000>>>>>>>        On_Key Key_Ctrl+Key_I Send ToggleItalics
81001>>>>>>>        On_Key Key_Ctrl+Key_U Send ToggleUnderline
81002>>>>>>>        
81002>>>>>>>    End_Procedure
81003>>>>>>>    
81003>>>>>>>    Import_Class_Protocol cEdit_Mixin
81004>>>>>>>    
81004>>>>>>>    Procedure ToggleBold
81006>>>>>>>        Set pbBold to (not(pbBold(Self)))
81007>>>>>>>    End_Procedure
81008>>>>>>>    
81008>>>>>>>    Procedure ToggleItalics
81010>>>>>>>        Set pbItalics to (not(pbItalics(Self)))
81011>>>>>>>    End_Procedure
81012>>>>>>>    
81012>>>>>>>    Procedure ToggleUnderline
81014>>>>>>>        Set pbUnderLine to (not(pbUnderLine(Self)))
81015>>>>>>>    End_Procedure
81016>>>>>>>    
81016>>>>>>>End_Class
81017>>>>>>>
81017>>>>>>>
81017>>>>>Use cTextEdit.pkg
81017>>>>>Use cRichEdit.pkg
81017>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\gFormatNumbers.pkg)
81017>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cFormatter.pkg)
81017>>>>>>>>>Use VDFBase.pkg
81017>>>>>>>>>
81017>>>>>>>>>Class cFormatter is an cObject
81018>>>>>>>>>    
81018>>>>>>>>>    Procedure Construct_object
81020>>>>>>>>>        Integer iCh
81020>>>>>>>>>        Forward Send construct_object
81022>>>>>>>>>        Property String  psCurrencySymbol
81023>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
81024>>>>>>>>>        
81024>>>>>>>>>        Property String  psLeft
81025>>>>>>>>>        Property String  psright
81026>>>>>>>>>        Property Integer pbThousandsSep
81027>>>>>>>>>        Property Integer piPoints
81028>>>>>>>>>        
81028>>>>>>>>>        Property String  psCurPosLeft
81029>>>>>>>>>        Property String  psCurPosright
81030>>>>>>>>>        Property Integer pbCurPosThousandsSep
81031>>>>>>>>>        Property Integer piCurPosPoints
81032>>>>>>>>>        
81032>>>>>>>>>        Property String  psCurNegLeft
81033>>>>>>>>>        Property String  psCurNegright
81034>>>>>>>>>        Property Integer pbCurNegThousandsSep
81035>>>>>>>>>        Property Integer piCurNegPoints
81036>>>>>>>>>        
81036>>>>>>>>>        Property String  psNumPosLeft
81037>>>>>>>>>        Property String  psNumPosright
81038>>>>>>>>>        Property Integer pbNumPosThousandsSep
81039>>>>>>>>>        Property Integer piNumPosPoints
81040>>>>>>>>>        
81040>>>>>>>>>        Property String  psNumNegLeft
81041>>>>>>>>>        Property String  psNumNegright
81042>>>>>>>>>        Property Integer pbNumNegThousandsSep
81043>>>>>>>>>        Property Integer piNumNegPoints
81044>>>>>>>>>        
81044>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
81045>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
81046>>>>>>>>>        
81046>>>>>>>>>    End_Procedure
81047>>>>>>>>>    
81047>>>>>>>>>    // internal
81047>>>>>>>>>    // parse passed format string and set temporary properties with result
81047>>>>>>>>>    Procedure ParseFormat String sFmt
81049>>>>>>>>>        
81049>>>>>>>>>        String sLeft sRight sDigit
81049>>>>>>>>>        Integer bSep iPos i iDigits
81049>>>>>>>>>        
81049>>>>>>>>>        // replace any literals. A "/" followed by anything.
81049>>>>>>>>>        // some literals are special. $ . , / #
81049>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
81050>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
81051>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
81052>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
81053>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
81054>>>>>>>>>        Move (Character(9)) to sDigit
81055>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
81056>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
81057>>>>>>>>>        
81057>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
81058>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
81061>>>>>>>>>        
81061>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
81062>>>>>>>>>        
81062>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
81063>>>>>>>>>        
81063>>>>>>>>>        // Move all the special literals back into place before parsing
81063>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
81064>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
81065>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
81066>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
81067>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
81068>>>>>>>>>        
81068>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
81070>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
81071>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
81073>>>>>>>>>                Move -2 to iDigits
81074>>>>>>>>>                Increment i
81075>>>>>>>>>            End
81075>>>>>>>>>>
81075>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
81079>>>>>>>>>                Increment i
81080>>>>>>>>>            Loop
81081>>>>>>>>>>
81081>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
81082>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
81085>>>>>>>>>            //
81085>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
81086>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
81090>>>>>>>>>                Increment i
81091>>>>>>>>>            Loop
81092>>>>>>>>>>
81092>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
81093>>>>>>>>>        End
81093>>>>>>>>>>
81093>>>>>>>>>        Else Begin                             // we have no decinal
81094>>>>>>>>>            Move 0 to iDigits                  // so points is none
81095>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
81096>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
81098>>>>>>>>>                Move sFmt to sLeft
81099>>>>>>>>>                Move ""   to sRight
81100>>>>>>>>>            End
81100>>>>>>>>>>
81100>>>>>>>>>            Else Begin
81101>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
81102>>>>>>>>>                Move 1 to i
81103>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
81107>>>>>>>>>                    Increment i
81108>>>>>>>>>                Loop
81109>>>>>>>>>>
81109>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
81110>>>>>>>>>            End
81110>>>>>>>>>>
81110>>>>>>>>>        End
81110>>>>>>>>>>
81110>>>>>>>>>        // set temporary format properties and exit
81110>>>>>>>>>        Set pbThousandsSep to bSep
81111>>>>>>>>>        Set psLeft         to sLeft
81112>>>>>>>>>        Set psRight        to sRight
81113>>>>>>>>>        Set piPoints       to iDigits
81114>>>>>>>>>    End_Procedure
81115>>>>>>>>>    
81115>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
81115>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
81115>>>>>>>>>    //
81115>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
81115>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
81117>>>>>>>>>        String sPos sNeg
81117>>>>>>>>>        Integer iPos
81117>>>>>>>>>        
81117>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
81118>>>>>>>>>        If iPos Begin
81120>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
81121>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
81122>>>>>>>>>        End
81122>>>>>>>>>>
81122>>>>>>>>>        Else Begin
81123>>>>>>>>>            Move sFmt         to sPos
81124>>>>>>>>>            Move ("-" + sFmt) to sNeg
81125>>>>>>>>>        End
81125>>>>>>>>>>
81125>>>>>>>>>        Send ParseFormat sPos
81126>>>>>>>>>        If bCurrency Begin
81128>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
81129>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
81130>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
81131>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
81132>>>>>>>>>        End
81132>>>>>>>>>>
81132>>>>>>>>>        Else Begin
81133>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
81134>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
81135>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
81136>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
81137>>>>>>>>>        End
81137>>>>>>>>>>
81137>>>>>>>>>        
81137>>>>>>>>>        Send ParseFormat sNeg
81138>>>>>>>>>        If bCurrency Begin
81140>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
81141>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
81142>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
81143>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
81144>>>>>>>>>        End
81144>>>>>>>>>>
81144>>>>>>>>>        Else Begin
81145>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
81146>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
81147>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
81148>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
81149>>>>>>>>>        End
81149>>>>>>>>>>
81149>>>>>>>>>    End_Procedure
81150>>>>>>>>>    
81150>>>>>>>>>    // low level formatting. Pass parameters
81150>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
81152>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
81152>>>>>>>>>        Integer bIsNegative iDec iLen iCh
81152>>>>>>>>>        
81152>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
81155>>>>>>>>>        Move (Character(iCh)) to sDec
81156>>>>>>>>>        
81156>>>>>>>>>        Move (abs(nNumber)) to sNumber
81157>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
81158>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
81159>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
81160>>>>>>>>>        // format for decimal separator
81160>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
81163>>>>>>>>>        
81163>>>>>>>>>        // format for thousand sep.
81163>>>>>>>>>        If bSep Begin
81165>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
81168>>>>>>>>>            Move (Character(iCh)) to sSep
81169>>>>>>>>>            Move (Length(sLeft)) to iLen
81170>>>>>>>>>            While (iLen>3)
81174>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
81175>>>>>>>>>                Move (iLen-3) to iLen
81176>>>>>>>>>            Loop
81177>>>>>>>>>>
81177>>>>>>>>>        End
81177>>>>>>>>>>
81177>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
81177>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
81180>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
81181>>>>>>>>>    End_Function
81182>>>>>>>>>    
81182>>>>>>>>>    // Public: Format for currency
81182>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
81184>>>>>>>>>        String  sLeft sRight
81184>>>>>>>>>        Integer bSep
81184>>>>>>>>>        If (nNumber<0) Begin
81186>>>>>>>>>            Get pbCurNegThousandsSep to bSep
81187>>>>>>>>>            Get psCurNegLeft         to sLeft
81188>>>>>>>>>            Get psCurNegRight        to sRight
81189>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
81192>>>>>>>>>        End
81192>>>>>>>>>>
81192>>>>>>>>>        Else Begin
81193>>>>>>>>>            Get pbCurPosThousandsSep to bSep
81194>>>>>>>>>            Get psCurPosLeft         to sLeft
81195>>>>>>>>>            Get psCurPosRight        to sRight
81196>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
81199>>>>>>>>>        End
81199>>>>>>>>>>
81199>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
81200>>>>>>>>>    End_Function
81201>>>>>>>>>    
81201>>>>>>>>>    // Public: Format for numeric
81201>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
81203>>>>>>>>>        String  sLeft sRight
81203>>>>>>>>>        Integer bSep
81203>>>>>>>>>        If (nNumber<0) Begin
81205>>>>>>>>>            Get pbNumNegThousandsSep to bSep
81206>>>>>>>>>            Get psNumNegLeft         to sLeft
81207>>>>>>>>>            Get psNumNegRight        to sRight
81208>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
81211>>>>>>>>>        End
81211>>>>>>>>>>
81211>>>>>>>>>        Else Begin
81212>>>>>>>>>            Get pbNumPosThousandsSep to bSep
81213>>>>>>>>>            Get psNumPosLeft         to sLeft
81214>>>>>>>>>            Get psNumPosRight        to sRight
81215>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
81218>>>>>>>>>        End
81218>>>>>>>>>>
81218>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
81219>>>>>>>>>    End_Function
81220>>>>>>>>>    
81220>>>>>>>>>    
81220>>>>>>>>>    // Public: Format passing format string
81220>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
81222>>>>>>>>>        Integer iPos bIsNeg
81222>>>>>>>>>        String  sLeft sRight
81222>>>>>>>>>        Integer iPoints bSep
81222>>>>>>>>>        Move (nNumber<0) to bIsNeg
81223>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
81224>>>>>>>>>        Case Begin
81224>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
81227>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
81231>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
81235>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
81237>>>>>>>>>        Case End
81237>>>>>>>>>        Send ParseFormat sFmt
81238>>>>>>>>>        Get pbThousandsSep to bSep
81239>>>>>>>>>        Get psLeft         to sLeft
81240>>>>>>>>>        Get psRight        to sRight
81241>>>>>>>>>        Get piPoints       to iPoints
81242>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
81243>>>>>>>>>    End_Function
81244>>>>>>>>>    
81244>>>>>>>>>End_Class
81245>>>>>>>
81245>>>>>>>Global_Variable Handle ghoFormatter
81245>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
81246>>>>>>>
81246>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
81248>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
81249>>>>>>>End_Function
81250>>>>>>>
81250>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
81252>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
81253>>>>>>>End_Function
81254>>>>>>>
81254>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
81256>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
81257>>>>>>>End_Function
81258>>>>>>>
81258>>>>>>>Procedure SetCurrencyFormat Global String sFmt
81260>>>>>>>    Send SetFormat of ghoFormatter sFmt True
81261>>>>>>>End_Procedure
81262>>>>>>>
81262>>>>>>>Procedure SetNumberFormat Global String sFmt
81264>>>>>>>    Send SetFormat of ghoFormatter sFmt False
81265>>>>>>>End_Procedure
81266>>>>>>>
81266>>>>>>>
81266>>>>>Use tWinStructs.pkg
81266>>>>>
81266>>>>>Use cli.pkg
81266>>>>>Use DFBTRDRV.PKG
81266>>>>>Use MSSqldrv.pkg
81266>>>>>Use db2_drv.pkg
81266>>>>>Use odbc_drv.pkg
81266>>>>>Use seq_chnl.pkg
81266>>>>>
81266>>>>>Register_Function phoWorkspace Returns Handle
81266>>>>>Register_Function Help_filename Returns String
81266>>>>>Register_Function GetHelpFile Returns String
81266>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
81266>>>>>
81266>>>>>// Use of Mertech drivers:
81266>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
81266>>>>>    Use mertech.inc
81266>>>>>
81266>>>>>
81266>>>>>
81266>>>>>
81266>>>>>
81266>>>>>// *** Constant Declarations: ***
81266>>>>>//
81266>>>>>
81266>>>>>
81266>>>>>
81266>>>>>
81266>>>>>
81266>>>>>
81266>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
81266>>>>>
81266>>>>>
81266>>>>>
81266>>>>>
81266>>>>>
81266>>>>>
81266>>>>>
81266>>>>>
81266>>>>>
81266>>>>>// System icon menu constants. If the upper left hand
81266>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
81266>>>>>    Define SC_RESTORE  for |CI$F120
81266>>>>>    Define SC_MOVE     for |CI$F010
81266>>>>>    Define SC_SIZE     for |CI$F000
81266>>>>>    Define SC_MINIMIZE for |CI$F020
81266>>>>>    Define SC_MAXIMIZE for |CI$F030
81266>>>>>    Define SC_CLOSE    for |CI$F060
81266>>>>>    Define SC_KEYMENU  for |CI$F100
81266>>>>>    Define SC_NEXTWINDOW for |CI$F040
81266>>>>>    Define SC_PREVWINDOW for |CI$F050
81266>>>>>
81266>>>>>Define CS_SignProgram        for "signtool.exe"
81266>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
81266>>>>>Define CS_VerifyCredentials  for "verify"
81266>>>>>Define CS_VerifyFileParam    for "/a"
81266>>>>>Define CS_DefAuthVerPolicy   for "/pa"
81266>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
81266>>>>>
81266>>>>>// *** Struct Declarations: ***
81266>>>>>
81266>>>>>Struct AboutSHELLEXECUTEINFO
81266>>>>>    DWord   cbSize
81266>>>>>    Integer fMask
81266>>>>>    Handle  hwnd
81266>>>>>    Pointer lpVerb
81266>>>>>    Pointer lpFile
81266>>>>>    Pointer lpParameters
81266>>>>>    Pointer lpDirectory
81266>>>>>    Integer nShow
81266>>>>>    Pointer hInstApp
81266>>>>>    Pointer lpIDList
81266>>>>>    Pointer lpClass
81266>>>>>    Handle  hkeyClass
81266>>>>>    DWord   dwHotKey
81266>>>>>    Handle  hIconMonitor // Union
81266>>>>>    //Handle  hMonitor     // Union
81266>>>>>    Handle  hProcess
81266>>>>>End_Struct
81266>>>>>
81266>>>>>
81266>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
81266>>>>>//Type MEMORYSTATUS
81266>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
81266>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
81266>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
81266>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
81266>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
81266>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
81266>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
81266>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
81266>>>>>//End_Type
81266>>>>>
81266>>>>>// *** External Function calls: ***
81266>>>>>//
81266>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
81267>>>>>
81267>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
81268>>>>>
81268>>>>>
81268>>>>>    External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
81269>>>>>
81269>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
81270>>>>>
81270>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
81271>>>>>
81271>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
81272>>>>>
81272>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
81273>>>>>
81273>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
81274>>>>>
81274>>>>>// *** Global/Desktop Function Declarations: ***
81274>>>>>
81274>>>>>Function ComputerName Desktop Returns String
81276>>>>>    String sName
81276>>>>>    Get_Environment "COMPUTERNAME" to sName
81277>>>>>>
81277>>>>>    Function_Return sName
81278>>>>>End_Function
81279>>>>>
81279>>>>>Function Network_User_Name Desktop Returns String
81281>>>>>    String sName
81281>>>>>    Get_Environment "USERNAME" to sName
81282>>>>>>
81282>>>>>    Function_Return sName
81283>>>>>End_Function
81284>>>>>
81284>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
81286>>>>>    String sClient sDriver sClientDriver
81286>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
81286>>>>>    Handle hoMsqlDrv
81286>>>>>
81286>>>>>    Move 0 to iDriver
81287>>>>>    Move "" to sClient
81288>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
81291>>>>>    For iCount from 1 to iNumberOfDrivers
81297>>>>>>
81297>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
81300>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
81302>>>>>            Move iCount to iDriver
81303>>>>>            Move iNumberOfDrivers to iCount // We're done.
81304>>>>>        End
81304>>>>>>
81304>>>>>    Loop
81305>>>>>>
81305>>>>>
81305>>>>>    // This info is (at current) only available for the MS SQL driver:
81305>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
81307>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
81310>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
81311>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
81312>>>>>        Send Destroy of hoMsqlDrv
81313>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
81314>>>>>    End
81314>>>>>>
81314>>>>>
81314>>>>>    Function_Return sClient
81315>>>>>End_Function
81316>>>>>
81316>>>>>// *** Class Declarations: ***
81316>>>>>//
81316>>>>>Class cBitmapContainerDFLink is a BitmapContainer
81317>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
81319>>>>>        Send Mouse_Up iWindowNumber iPosition
81320>>>>>    End_Procedure
81321>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
81323>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
81325>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
81326>>>>>    End_Procedure
81327>>>>>End_Class
81328>>>>>
81328>>>>>Class cCopyEditorContentButton is a Button
81329>>>>>    Procedure Construct_Object
81331>>>>>        Forward Send Construct_Object
81333>>>>>        Property Handle phoEditorHandle
81334>>>>>        Set psToolTip to C_$DescCopy
81335>>>>>    End_Procedure
81336>>>>>
81336>>>>>    Procedure CopyToWindowsClipboard
81338>>>>>        Handle hoEditor
81338>>>>>        Boolean bCanCopy
81338>>>>>        Address aEditorAddress
81338>>>>>
81338>>>>>        Get phoEditorHandle to hoEditor
81339>>>>>        Send Select_All of hoEditor
81340>>>>>        Get CanCopy of hoEditor to bCanCopy
81341>>>>>        If (bCanCopy = True) Begin
81343>>>>>            Get paValue of hoEditor to aEditorAddress
81344>>>>>            Send Copy   of hoEditor
81345>>>>>            // Remove the selection after text is copied to the clipboard.
81345>>>>>            Send Beginning_of_Data of hoEditor
81346>>>>>            Send Info_Box C_$CopyToClipboard_Text
81347>>>>>        End
81347>>>>>>
81347>>>>>    End_Procedure
81348>>>>>End_Class
81349>>>>>
81349>>>>>Class SysinfoDisplay is a cTextEdit
81350>>>>>    Procedure Construct_Object
81352>>>>>        Forward Send Construct_Object
81354>>>>>
81354>>>>>        Set Size to 100 245
81355>>>>>        Set Location to 6 6
81356>>>>>        Set Border_Style to Border_None
81357>>>>>        Set Read_Only_State to True
81358>>>>>        Set pbWrap to True
81359>>>>>        Set peAnchors to anAll
81360>>>>>    End_Procedure
81361>>>>>
81361>>>>>    // Augmented class message to adjust certain text strings that are wrong...
81361>>>>>
81361>>>>>    Procedure AppendTextLn String sText
81363>>>>>        String sWorkspaceWSFile
81363>>>>>
81363>>>>>        // Only works for English:
81363>>>>>        If (ghoApplication > 0) Begin
81365>>>>>            If (sText contains "Workspace Name") Begin
81367>>>>>                Move "Workspace Config Filename:" to sText
81368>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
81369>>>>>                Move (sText * sWorkspaceWSFile) to sText
81370>>>>>            End
81370>>>>>>
81370>>>>>        End
81370>>>>>>
81370>>>>>        Send AppendText sText
81371>>>>>        Send AppendText (character(10))
81372>>>>>    End_Procedure
81373>>>>>
81373>>>>>    //    This method will show the name Of the current directory in the system
81373>>>>>    //    information box
81373>>>>>    Procedure Show_Current_Directory
81375>>>>>        String sDir
81375>>>>>
81375>>>>>        Get_Current_Directory To sDir
81376>>>>>
81376>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
81377>>>>>    End_Procedure
81378>>>>>
81378>>>>>    Procedure Show_Windows_Directory
81380>>>>>        String sWindir
81380>>>>>
81380>>>>>        Get_Windows_Directory To sWindir
81381>>>>>
81381>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
81382>>>>>    End_Procedure
81383>>>>>
81383>>>>>    Procedure Show_Current_User
81385>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
81386>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
81387>>>>>    End_Procedure
81388>>>>>
81388>>>>>    Procedure Show_Number_Format
81390>>>>>        Integer iFormat
81390>>>>>        String sFormatText
81390>>>>>
81390>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
81393>>>>>        Move (Character (iFormat)) To sFormatText
81394>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
81395>>>>>
81395>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
81398>>>>>        Move (Character (iFormat)) to sFormatText
81399>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
81400>>>>>    End_Procedure
81401>>>>>
81401>>>>>    Procedure Show_Filelist_Name
81403>>>>>        String sFilename
81403>>>>>
81403>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
81406>>>>>
81406>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
81407>>>>>    End_Procedure
81408>>>>>
81408>>>>>    Procedure Show_Lock_Delay
81410>>>>>        Integer iLockdelay
81410>>>>>
81410>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
81413>>>>>
81413>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
81414>>>>>    End_Procedure
81415>>>>>
81415>>>>>    Procedure Show_Lock_Timeout
81417>>>>>        Integer iLockTimeout
81417>>>>>
81417>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
81420>>>>>
81420>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
81421>>>>>    End_Procedure
81422>>>>>
81422>>>>>    Procedure Show_Screen_Size
81424>>>>>        Integer iYscreensize iXscreensize
81424>>>>>
81424>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
81425>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
81426>>>>>
81426>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
81427>>>>>    End_Procedure
81428>>>>>
81428>>>>>    Procedure Show_Page_Size
81430>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
81431>>>>>    End_procedure
81432>>>>>
81432>>>>>    Procedure Show_Date
81434>>>>>        Date dToday
81434>>>>>
81434>>>>>        Move (CurrentDateTime()) to dToday
81435>>>>>
81435>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
81436>>>>>    End_procedure
81437>>>>>
81437>>>>>    Procedure Show_Date_Format
81439>>>>>        Integer iDateFormat
81439>>>>>        String sDateFormat
81439>>>>>
81439>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
81442>>>>>        Case Begin
81442>>>>>            Case (iDateFormat = DF_DATE_USA)
81444>>>>>                Move C_$USA To sDateFormat
81445>>>>>                Case Break
81446>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
81449>>>>>                Move C_$European To sDateFormat
81450>>>>>                Case Break
81451>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
81454>>>>>                Move C_$Military To sDateFormat
81455>>>>>                Case Break
81456>>>>>            Case Else
81456>>>>>                Move C_$UnknownDateType To sDateFormat
81457>>>>>                Case Break
81458>>>>>        Case End
81458>>>>>
81458>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
81459>>>>>    End_Procedure
81460>>>>>
81460>>>>>    // 2013-08-14 NGS
81460>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
81460>>>>>    Procedure Show_Systemresources
81462>>>>>        tWinMemoryStatusEx MemoryStatusInfo
81462>>>>>        tWinMemoryStatusEx MemoryStatusInfo
81462>>>>>        Integer iRetval
81462>>>>>        Number nValue
81462>>>>>        String sValue
81462>>>>>
81462>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
81463>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
81464>>>>>        If (iRetval = 0) Begin
81466>>>>>            Move (ShowLastError ()) to iRetval
81467>>>>>            Procedure_Return
81468>>>>>        End
81468>>>>>>
81468>>>>>
81468>>>>>        Send AppendTextLn ""
81469>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
81470>>>>>
81470>>>>>        // Show memory in Gigabytes:
81470>>>>>        Move (nValue/1024/1024/1024) to nValue
81471>>>>>        Move (Round(nValue)) to nValue
81472>>>>>        Get FormatNumber nValue 2 to sValue
81473>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
81474>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
81475>>>>>
81475>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
81475>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
81476>>>>>        Move (Round(nValue)) to nValue
81477>>>>>        Get FormatNumber nValue 0 to sValue
81478>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
81479>>>>>
81479>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
81479>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
81480>>>>>        Move (Round(nValue)) to nValue
81481>>>>>        Get FormatNumber nValue 0 to sValue
81482>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
81483>>>>>
81483>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
81483>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
81484>>>>>        Move (Round(nValue)) to nValue
81485>>>>>        Get FormatNumber nValue 0 to sValue
81486>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
81487>>>>>
81487>>>>>        // Add an empty row after the memory information:
81487>>>>>        Send AppendTextLn ""
81488>>>>>    End_Procedure
81489>>>>>
81489>>>>>    Procedure Show_Registration
81491>>>>>        String sRegName
81491>>>>>        Integer iSN iUsersMax iUserCount
81491>>>>>
81491>>>>>        Registration sRegName iSN
81492>>>>>>
81492>>>>>        Get_Licensed_Max_Users to iUsersMax
81493>>>>>        Get_Current_User_Count to iUserCount
81494>>>>>
81494>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
81495>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
81496>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
81497>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
81498>>>>>    End_Procedure
81499>>>>>
81499>>>>>    //****************************************************************************
81499>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
81499>>>>>    // To the workspace object passing the an object and message To send back
81499>>>>>    // To this object. It is expected that the workspace object will send this
81499>>>>>    // message for every line Of information it wants displayed (passing the
81499>>>>>    // information To be displayed
81499>>>>>    //****************************************************************************
81499>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
81499>>>>>
81499>>>>>    Procedure Show_ServicePack
81501>>>>>        String sKey sVersion sDataFlex
81501>>>>>        Handle hoRegistry
81501>>>>>        Boolean bExists bOpened
81501>>>>>
81501>>>>>        Move "DataFlex"        to sDataFlex
81502>>>>>
81502>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
81503>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
81504>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
81505>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
81506>>>>>
81506>>>>>        If (bExists) Begin
81508>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
81509>>>>>        End
81509>>>>>>
81509>>>>>        Else Begin
81510>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
81511>>>>>        End
81511>>>>>>
81511>>>>>        Get KeyExists of hoRegistry sKey to bExists
81512>>>>>        If (bExists) Begin
81514>>>>>            Get OpenKey of hoRegistry sKey to bOpened
81515>>>>>            If (bOpened) Begin
81517>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
81518>>>>>                If (bExists) Begin
81520>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
81521>>>>>                End
81521>>>>>>
81521>>>>>                Send CloseKey of hoRegistry
81522>>>>>            End
81522>>>>>>
81522>>>>>        End
81522>>>>>>
81522>>>>>        Send Destroy of hoRegistry
81523>>>>>
81523>>>>>        If (sVersion <> "") Begin
81525>>>>>           Send AppendTextLn sVersion
81526>>>>>           Send AppendTextLn ""
81527>>>>>        End
81527>>>>>>
81527>>>>>    End_Procedure
81528>>>>>
81528>>>>>    Procedure Show_WorkspaceInformation
81530>>>>>        Integer hoWorkspace
81530>>>>>
81530>>>>>        If (ghoApplication <> 0) Begin
81532>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
81533>>>>>            If (hoWorkspace <> 0) Begin
81535>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
81536>>>>>            End
81536>>>>>>
81536>>>>>        End
81536>>>>>>
81536>>>>>    End_Procedure
81537>>>>>
81537>>>>>    //****************************************************************************
81537>>>>>    // If connection ids are used, we will send the message EnumerateConnections
81537>>>>>    // to the connection manager object passing the an object and message to send
81537>>>>>    // back to this object. It is expected that the connection manager object will
81537>>>>>    // send this message for every line Of information it wants displayed (passing
81537>>>>>    // the information To be displayed
81537>>>>>    //****************************************************************************
81537>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
81537>>>>>
81537>>>>>    Procedure Show_ConnectionIdInformation
81539>>>>>        If (ghoConnection > 0) Begin
81541>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
81542>>>>>            Send AppendTextLn ""
81543>>>>>        End
81543>>>>>>
81543>>>>>    End_Procedure
81544>>>>>
81544>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
81546>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
81547>>>>>    End_Function
81548>>>>>
81548>>>>>    Procedure Show_Versions
81550>>>>>        Integer iVersion iRevision iBuild
81550>>>>>
81550>>>>>        Version_information iVersion iRevision iBuild
81552>>>>>
81552>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
81553>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
81554>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
81555>>>>>        Send AppendTextLn "This is a 32-bit exe file"
81556>>>>>    End_Procedure
81557>>>>>
81557>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
81559>>>>>        Boolean bOK
81559>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
81560>>>>>        Function_Return bOK
81561>>>>>    End_Function
81562>>>>>
81562>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
81564>>>>>        Boolean bOK
81564>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MySQLFlex) to bOK
81565>>>>>        Function_Return bOK
81566>>>>>    End_Function
81567>>>>>
81567>>>>>    //***
81567>>>>>    //*** BW
81567>>>>>    //*** Procedure: Show_Drivers
81567>>>>>    //*** Purpose  : Show loaded database drivers
81567>>>>>    //***
81567>>>>>
81567>>>>>    Procedure Show_Drivers
81569>>>>>        String sDriverID sVersion sClient sValue
81569>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
81569>>>>>        Handle hoCLIHandler hoBtrvHandler
81569>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
81569>>>>>
81569>>>>>        Move False to bStudioLicense
81570>>>>>
81570>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
81571>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
81572>>>>>
81572>>>>>        // For testing purposes:
81572>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
81572>>>>>//        Load_Driver MSSQLDRV_ID
81572>>>>>//        Load_Driver ODBC_DRV_ID
81572>>>>>//        Load_Driver DB2_DRV_ID
81572>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
81572>>>>>//
81572>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
81572>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
81572>>>>>//            Load_Driver SQLFLEX
81572>>>>>//            Load_Driver MDSPgSQL
81572>>>>>//            Load_Driver MDSMySQL
81572>>>>>//            Load_Driver ORAFLEX
81572>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
81572>>>>>//        #ENDIF
81572>>>>>        Move False to Err
81573>>>>>
81573>>>>>        // Loop through all loaded drivers.
81573>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
81576>>>>>        If (iNumberOfDrivers > 1) Begin
81578>>>>>            Send AppendTextLn ""
81579>>>>>        End
81579>>>>>>
81579>>>>>        For iDriver from 1 to iNumberOfDrivers
81585>>>>>>
81585>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
81585>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
81585>>>>>            // would be thrown, so we safeguard from that here.
81585>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
81586>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
81589>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
81590>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
81591>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
81592>>>>>
81592>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
81594>>>>>
81594>>>>>                // Pervasive/Btrieve database
81594>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
81596>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
81597>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
81598>>>>>                    If (sClient <> "0.0.0") Begin
81600>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
81601>>>>>                    End
81601>>>>>>
81601>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
81602>>>>>                    If (sClient <> "0.0.0") Begin
81604>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
81605>>>>>                    End
81605>>>>>>
81605>>>>>                End
81605>>>>>>
81605>>>>>
81605>>>>>                Else Begin
81606>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
81607>>>>>                    Move 0 to iNumServers
81608>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
81610>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
81613>>>>>                    End
81613>>>>>>
81613>>>>>
81613>>>>>                    If (bIsDAWDriver = True) Begin
81615>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
81617>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
81618>>>>>                        End
81618>>>>>>
81618>>>>>                        Get CKRevision of hoCLIHandler to sVersion
81619>>>>>                    End
81619>>>>>>
81619>>>>>
81619>>>>>                    If (bIsMertechDriver = True) Begin
81621>>>>>                        GET_DRIVER_REVISION to sVersion
81658>>>>>>
81658>>>>>                    End
81658>>>>>>
81658>>>>>
81658>>>>>                    // If the serialnumber is = 0, it means that the
81658>>>>>                    // Studio licens is in use and there is no
81658>>>>>                    // number of max users defined because the driver is
81658>>>>>                    // relying on the info from the VDF license.
81658>>>>>                    If (bStudioLicense = False) Begin
81660>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
81661>>>>>                        Move (iSerialNo = 0) to bStudioLicense
81662>>>>>                    End
81662>>>>>>
81662>>>>>                End
81662>>>>>>
81662>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
81663>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
81665>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
81666>>>>>                End
81666>>>>>>
81666>>>>>                If (iNumServers <> 0) Begin
81668>>>>>                    For iCount from 1 to iNumServers
81674>>>>>>
81674>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
81677>>>>>                        If (not(sValue contains ";PWD=")) Begin
81679>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
81680>>>>>                        End
81680>>>>>>
81680>>>>>                    Loop
81681>>>>>>
81681>>>>>                End
81681>>>>>>
81681>>>>>            End
81681>>>>>>
81681>>>>>        Loop
81682>>>>>>
81682>>>>>
81682>>>>>        Send AppendTextLn ""
81683>>>>>        If (bStudioLicense = False) Begin
81685>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
81686>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
81687>>>>>        End
81687>>>>>>
81687>>>>>        Else Begin
81688>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
81689>>>>>        End
81689>>>>>>
81689>>>>>        Send Destroy of hoCLIHandler
81690>>>>>        Send Destroy of hoBtrvHandler
81691>>>>>    End_Procedure
81692>>>>>
81692>>>>>    Procedure Show_HelpFile
81694>>>>>        String sHelpFile
81694>>>>>        Integer eHelpType
81694>>>>>
81694>>>>>        If (ghoApplication <> 0) Begin
81696>>>>>            Get peHelpType Of ghoApplication To eHelpType
81697>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
81699>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
81700>>>>>            End
81700>>>>>>
81700>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
81703>>>>>                Get Help_filename Of Help_object_id To sHelpFile
81704>>>>>            End
81704>>>>>>
81704>>>>>            Else Begin
81705>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
81706>>>>>            End
81706>>>>>>
81706>>>>>
81706>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
81707>>>>>        End
81707>>>>>>
81707>>>>>    End_Procedure
81708>>>>>
81708>>>>>    Procedure Show_EnterAsTab
81710>>>>>        Boolean bEnterKeyAsTabKey
81710>>>>>        String sText
81710>>>>>
81710>>>>>        If (ghoApplication <> 0) Begin
81712>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
81713>>>>>            If (bEnterKeyAsTabKey) Begin
81715>>>>>                Move "True" To sText
81716>>>>>            End
81716>>>>>>
81716>>>>>            Else Begin
81717>>>>>                Move "False" To sText
81718>>>>>            End
81718>>>>>>
81718>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
81719>>>>>        End
81719>>>>>>
81719>>>>>    End_Procedure
81720>>>>>
81720>>>>>    //    During activation we will remove the old information and add the newly
81720>>>>>    //    found systeminformation
81720>>>>>    Procedure Add_Focus Integer hoRoot
81722>>>>>        Forward Send Add_Focus hoRoot
81724>>>>>
81724>>>>>        Send Delete_Data
81725>>>>>
81725>>>>>        Set Changed_State To False
81726>>>>>        Set Read_Only_State To True
81727>>>>>
81727>>>>>        Send Show_Registration
81728>>>>>        Send Show_Drivers
81729>>>>>        Send Show_ServicePack
81730>>>>>        Send Show_Versions
81731>>>>>        Send AppendTextLn ""
81732>>>>>
81732>>>>>        If (ghoApplication <> 0) Begin
81734>>>>>            Send Show_WorkSpaceInformation
81735>>>>>            Send Show_HelpFile
81736>>>>>            Send AppendTextLn ""
81737>>>>>        End
81737>>>>>>
81737>>>>>        Else Begin
81738>>>>>            Send AppendTextLn ""
81739>>>>>        End
81739>>>>>>
81739>>>>>
81739>>>>>        If (ghoConnection <> 0) Begin
81741>>>>>            Send Show_ConnectionIdInformation
81742>>>>>        End
81742>>>>>>
81742>>>>>
81742>>>>>        Send Show_Current_User
81743>>>>>        Send Show_Windows_Directory
81744>>>>>        Send Show_Current_Directory
81745>>>>>
81745>>>>>        // This is already shown in the workspace details,
81745>>>>>        // unless no workspace object is present:
81745>>>>>        If (ghoApplication = 0) Begin
81747>>>>>            Send Show_Filelist_Name
81748>>>>>        End
81748>>>>>>
81748>>>>>
81748>>>>>        If (ghoApplication <> 0) Begin
81750>>>>>            Send AppendTextLn ""
81751>>>>>            Send Show_EnterAsTab
81752>>>>>        End
81752>>>>>>
81752>>>>>
81752>>>>>        Send Show_Screen_Size
81753>>>>>        Send Show_Page_Size
81754>>>>>        Send Show_Number_Format
81755>>>>>        Send Show_Date_Format
81756>>>>>        Send Show_Lock_Delay
81757>>>>>        Send Show_Lock_Timeout
81758>>>>>        Send Show_Date
81759>>>>>        Send Show_Systemresources
81760>>>>>        Send Beginning_of_Data
81761>>>>>
81761>>>>>        Set Icon to 'default.ico'
81762>>>>>    End_Procedure
81763>>>>>End_Class
81764>>>>>
81764>>>>>Class SysInfoDialog is a ModalPanel
81765>>>>>    Procedure Construct_Object
81767>>>>>        Forward Send Construct_Object
81769>>>>>
81769>>>>>        Set Label to C_$SystemInformation
81770>>>>>        Set Size to 140 267
81771>>>>>        Set Locate_Mode to CENTER_ON_PARENT
81772>>>>>        Set Border_Style to Border_Thick
81773>>>>>        Set Sysmenu_Icon to False
81774>>>>>
81774>>>>>        // "+1" will make the panel to paint correctly.
81774>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
81775>>>>>
81775>>>>>        // 2014-09-14 NGS
81775>>>>>        // Added a container object around the cTexteditor
81775>>>>>        // object to get a border around the text.
81775>>>>>        Object oSysinfoDisplayContainer is a Container3d
81777>>>>>            Set Location to 2 4
81778>>>>>            Set Size to 110 255
81779>>>>>            Set Border_Style to Border_ClientEdge
81780>>>>>            Set Color to clWhite
81781>>>>>            Set peAnchors to anAll
81782>>>>>
81782>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
81784>>>>>            End_Object
81785>>>>>
81785>>>>>        End_Object
81786>>>>>
81786>>>>>        Object oCloseButton is a Button
81788>>>>>            Set Label to C_$Close
81789>>>>>            Set Location to 120 210
81790>>>>>            Set Message item 0 to msg_Close_Panel
81791>>>>>            Set Default_State To True
81792>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
81792>>>>>            // and changes its peAnchors, we might as well prepare this object
81792>>>>>            // for that situation.
81792>>>>>            Set peAnchors to anBottomRight
81793>>>>>        End_Object
81794>>>>>
81794>>>>>        Object oCopyButton is a cCopyEditorContentButton
81796>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
81797>>>>>            Set Size to 14 50
81798>>>>>            Set Location to 120 158
81799>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
81799>>>>>            // we might as well prepare the object for it.
81799>>>>>            Set peAnchors to anBottomRight
81800>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
81801>>>>>        End_Object
81802>>>>>
81802>>>>>        On_Key kCancel Send Close_Panel
81803>>>>>    End_Procedure
81804>>>>>
81804>>>>>    Procedure Page Integer iPageObject
81806>>>>>        Handle hMenu
81806>>>>>        Integer iPrevState
81806>>>>>
81806>>>>>        Forward Send Page iPageObject
81808>>>>>
81808>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
81808>>>>>        //
81808>>>>>    End_Procedure
81809>>>>>
81809>>>>>End_Class
81810>>>>>
81810>>>>>Class cAboutEdit is an cRichEdit
81811>>>>>    Procedure Construct_Object
81813>>>>>        Forward Send Construct_Object
81815>>>>>
81815>>>>>        Property String psContentText
81816>>>>>
81816>>>>>        Set Size to 77 153
81817>>>>>        Set Location to 8 60
81818>>>>>        Set Read_Only_State to True
81819>>>>>        Set Skip_State to True
81820>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
81820>>>>>        // or 1/20 of a printer's point.
81820>>>>>        Set piRightMargin to (0.1 * 1440)
81821>>>>>        Set Border_Style  to Border_None
81822>>>>>    End_Procedure
81823>>>>>
81823>>>>>    // Adds a line of text to the edit object
81823>>>>>    Procedure Add_Line String sText
81825>>>>>        String sContentText
81825>>>>>        Get psContentText to sContentText
81826>>>>>        Move (sContentText + String(sText)) to sContentText
81827>>>>>        Set psContentText to sContentText
81828>>>>>    End_Procedure
81829>>>>>
81829>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
81829>>>>>    // Note that we use a property psContentText and add to it,
81829>>>>>    // because the object isn't paged yet when we add these
81829>>>>>    // values and the COM edit object needs to be paged
81829>>>>>    // for the text to become visible. See Also: Procedure Page below.
81829>>>>>    Procedure Add_LineLn String sText
81831>>>>>        String sContentText sCR
81831>>>>>
81831>>>>>        Move (Character(10) + String(Character(13))) to sCR
81832>>>>>        Get psContentText to sContentText
81833>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
81834>>>>>        Set psContentText to sContentText
81835>>>>>    End_Procedure
81836>>>>>
81836>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
81838>>>>>        String sLinkText
81838>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
81839>>>>>        Send Show_HomePage sLinkText
81840>>>>>    End_Procedure
81841>>>>>
81841>>>>>    Procedure Page Integer iPageObject
81843>>>>>        String sContentText
81843>>>>>
81843>>>>>        Forward Send Page iPageObject
81845>>>>>        Get psContentText to sContentText
81846>>>>>        Send AppendText sContentText
81847>>>>>        send Beginning_of_Data
81848>>>>>    End_Procedure
81849>>>>>
81849>>>>>End_Class
81850>>>>>
81850>>>>>Class AboutDialog is a ModalPanel
81851>>>>>    Procedure Construct_Object
81853>>>>>
81853>>>>>        Forward Send Construct_Object
81855>>>>>
81855>>>>>        Set Label to C_$About
81856>>>>>        Set Size to 118 230
81857>>>>>        Set Locate_Mode to CENTER_ON_PARENT
81858>>>>>        Set Border_Style to Border_Thick
81859>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
81860>>>>>
81860>>>>>        Object oSysInfoDialog is a SysInfoDialog
81862>>>>>        End_Object
81863>>>>>
81863>>>>>        Object oBox is a Container3d
81865>>>>>            Set Border_Style to Border_Normal
81866>>>>>            Set Size to 90 220
81867>>>>>            Set Location to 4 5
81868>>>>>            Set Color to clWhite
81869>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
81869>>>>>            // we might as well prepare the object for it.
81869>>>>>            Set peAnchors to anAll
81870>>>>>
81870>>>>>            Object oAboutGraphic is a BitmapContainer
81872>>>>>                Set Border_Style To Border_None
81873>>>>>                Set Bitmap_Style to Bitmap_Center
81874>>>>>                Set Color to clWhite
81875>>>>>                Set Size to 45 50
81876>>>>>                Set Location to 0 3
81877>>>>>            End_Object
81878>>>>>
81878>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
81880>>>>>                Set Border_Style to Border_None
81881>>>>>                Set Bitmap_Style to Bitmap_Center
81882>>>>>                Set Color to clWhite
81883>>>>>                Set Size to 30 55
81884>>>>>                Set Location to 50 3
81885>>>>>            End_Object
81886>>>>>
81886>>>>>            Object oInfoList_Editor is an cAboutEdit
81888>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
81888>>>>>                // we might as well prepare the object for it.
81888>>>>>                Set peAnchors to anAll
81889>>>>>            End_Object
81890>>>>>
81890>>>>>            // These objects are here for backwards compatability only.
81890>>>>>            // They are not used.
81890>>>>>            Object oProductName is a TextBox
81892>>>>>                Set Label To C_$ProductName
81893>>>>>                Set Size To 10 45
81894>>>>>                Set Location To 8 53
81895>>>>>                Set Visible_State to False
81896>>>>>                Set Focus_Mode to NonFocusable
81897>>>>>            End_Object
81898>>>>>
81898>>>>>            Object oVersion is a TextBox
81900>>>>>                Set Label To C_$Version
81901>>>>>                Set Size To 10 25
81902>>>>>                Set Location To 21 53
81903>>>>>                Set Visible_State to False
81904>>>>>                Set Focus_Mode to NonFocusable
81905>>>>>            End_Object
81906>>>>>
81906>>>>>            Object oCopyright is a TextBox
81908>>>>>                Set Label To C_$Copyright
81909>>>>>                Set Size To 10 31
81910>>>>>                Set Location To 34 53
81911>>>>>                Set Visible_State to False
81912>>>>>                Set Focus_Mode to NonFocusable
81913>>>>>            End_Object
81914>>>>>
81914>>>>>            Object oAuthor is a TextBox
81916>>>>>                Set Label To C_$Author
81917>>>>>                Set Size To 10 22
81918>>>>>                Set Location To 46 53
81919>>>>>                Set Visible_State to False
81920>>>>>                Set Focus_Mode to NonFocusable
81921>>>>>            End_Object
81922>>>>>
81922>>>>>        End_Object
81923>>>>>
81923>>>>>        Object oOKButton is a Button
81925>>>>>            On_Item C_$Close Send Close_Panel
81926>>>>>            Set Location to 98 176
81927>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
81927>>>>>            // we might as well prepare the object for it.
81927>>>>>            Set peAnchors to anBottomRight
81928>>>>>        End_Object
81929>>>>>
81929>>>>>        Object oSysInfoButton is a Button
81931>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
81932>>>>>            Set Location to 98 123
81933>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
81933>>>>>            // we might as well prepare the object for it.
81933>>>>>            Set peAnchors to anBottomRight
81934>>>>>        End_Object
81935>>>>>
81935>>>>>        Object oCopyButton is a cCopyEditorContentButton
81937>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
81938>>>>>            Set Size to 14 50
81939>>>>>            Set Location to 98 70
81940>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
81940>>>>>            // we might as well prepare the object for it.
81940>>>>>            Set peAnchors to anBottomRight
81941>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
81942>>>>>        End_Object
81943>>>>>
81943>>>>>        On_Key Kcancel Send KeyAction of oOKButton
81944>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
81945>>>>>        Set LogoDF to "DF32.bmp"
81946>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
81946>>>>>    End_Procedure
81947>>>>>
81947>>>>>    Procedure Page Integer iPageObject
81949>>>>>        Handle hMenu
81949>>>>>        Integer iPrevState
81949>>>>>
81949>>>>>        Forward Send Page iPageObject
81951>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
81951>>>>>        Set Icon to "Default.ico"
81952>>>>>
81952>>>>>        // Shadow upper left corner menu items: (icon menu items)
81952>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
81953>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
81954>>>>>        // The "Move" menu command may come in handy to have.
81954>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
81954>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
81955>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
81956>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
81957>>>>>        // The "Close" menu command may be good to have.
81957>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
81957>>>>>    End_Procedure
81958>>>>>
81958>>>>>    Procedure Set ProductName String sText
81960>>>>>        Set Value of oProductName to sText
81961>>>>>    End_Procedure
81962>>>>>
81962>>>>>    Procedure Set Copyright String sText
81964>>>>>        Set Value of oCopyright to sText
81965>>>>>    End_Procedure
81966>>>>>
81966>>>>>    Procedure Set Author String sText
81968>>>>>        Set Value of oAuthor to sText
81969>>>>>    End_Procedure
81970>>>>>
81970>>>>>    Procedure Set Version String sVersion
81972>>>>>        Handle hoVersionInfo
81972>>>>>        Boolean bIncluded
81972>>>>>        Integer iMajor iMinor iRelease iBuild
81972>>>>>        Date dCompileDate
81972>>>>>        String sCertInfo
81972>>>>>
81972>>>>>        If (sVersion = "") Begin
81974>>>>>            // This automatically shows the program version of the program, if available.
81974>>>>>            // It will be displayed as the second item in the edit object.
81974>>>>>            If (ghoApplication <> 0) Begin
81976>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
81977>>>>>                If (hoVersionInfo <> 0) Begin
81979>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
81980>>>>>                    If (bIncluded) Begin
81982>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
81983>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
81984>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
81985>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
81986>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
81987>>>>>                    End
81987>>>>>>
81987>>>>>                End
81987>>>>>>
81987>>>>>            End
81987>>>>>>
81987>>>>>        End
81987>>>>>>
81987>>>>>
81987>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
81987>>>>>        Get GetCompileDate to dCompileDate
81988>>>>>        If (sVersion <> "") Begin
81990>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
81991>>>>>        End
81991>>>>>>
81991>>>>>
81991>>>>>        Get IsProgramDigitallySigned to sCertInfo
81992>>>>>        If (sCertInfo <> "-1") Begin
81994>>>>>            If (sCertInfo <> "") Begin
81996>>>>>                Send Add_LineLn sCertInfo
81997>>>>>            End
81997>>>>>>
81997>>>>>            Else Begin
81998>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
81999>>>>>            End
81999>>>>>>
81999>>>>>        End
81999>>>>>>
81999>>>>>    End_Procedure
82000>>>>>
82000>>>>>    Function IsDate Desktop String sDate Returns Boolean
82002>>>>>        Boolean bIsDate
82002>>>>>        String sGoodCharacters sChar
82002>>>>>        Integer iCount iLength
82002>>>>>
82002>>>>>        Move True to bIsDate
82003>>>>>        Move "0123456789-/" to sGoodCharacters
82004>>>>>        Move (Length(sDate)) to iLength
82005>>>>>        For iCount from 1 to iLength
82011>>>>>>
82011>>>>>            Move (Left(sDate, 1)) to sChar
82012>>>>>            Move (Mid(sDate, 12, 2)) to sDate
82013>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
82014>>>>>            If (bIsDate = False) Begin
82016>>>>>                Move iLength to iCount
82017>>>>>            End
82017>>>>>>
82017>>>>>        Loop
82018>>>>>>
82018>>>>>        Function_Return bIsDate
82019>>>>>    End_Function
82020>>>>>
82020>>>>>    Function GetCompileDate Returns Date
82022>>>>>        Date dCompileDate
82022>>>>>        String sAppFilename sProgram sData sCompileDate
82022>>>>>        Integer iChannel iPos iDateFormat iCount iSize
82022>>>>>        Boolean bIsValid
82022>>>>>
82022>>>>>        Move 0 to dCompileDate
82023>>>>>        // Get full path to the current running executable
82023>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
82024>>>>>        Get GetApplicationName     of ghoApplication to sProgram
82025>>>>>
82025>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
82025>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
82026>>>>>
82026>>>>>        Get_Argument_Size to iSize
82027>>>>>        Set_Argument_Size 15000000
82028>>>>>>
82028>>>>>        Read_Block channel iChannel sData 15000000   // This must be big enough to reach the compile date location
82030>>>>>        Move (Pos(sProgram,sData)) to iPos
82031>>>>>        If (iPos > 0) Begin
82033>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
82033>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
82034>>>>>
82034>>>>>            // If the current date format is non US, we need to temporary
82034>>>>>            // change the format and then move the string to the date variable.
82034>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
82037>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
82040>>>>>            Move (Date(sCompileDate))    to dCompileDate
82041>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
82044>>>>>        End
82044>>>>>>
82044>>>>>//        Else Begin
82044>>>>>//            Error DFERR_PROGRAM "Compile Date location in .exe not found"
82044>>>>>//        End
82044>>>>>
82044>>>>>        Send Seq_Close_Channel iChannel
82045>>>>>        Set_Argument_Size iSize
82046>>>>>>
82046>>>>>//        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
82046>>>>>//        Read_Block channel iChannel sData 75            // The compile information we're interested in
82046>>>>>
82046>>>>>        // The data is padded with Character(0)s. Strip them out
82046>>>>>//        Move (CString(sData)) to sData
82046>>>>>
82046>>>>>        // The compile date is after the first ", ", so string parsing is required
82046>>>>>//        Move (Pos(", ", sData)) to iPos
82046>>>>>//        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
82046>>>>>        // If the current date format is non US, we need to temporary
82046>>>>>        // change the format and then move the string to the date variable.
82046>>>>>//        Get_Attribute DF_DATE_FORMAT        to iDateFormat
82046>>>>>//        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
82046>>>>>//
82046>>>>>//        // Note the build in IsDateValid can return the wrong result
82046>>>>>//        // when controls characters are part of the sCompileDate.
82046>>>>>//        Get IsDate sCompileDate))           to bIsValid
82046>>>>>//        If (bIsValid = True) Begin
82046>>>>>//            Move (Date(sCompileDate))       to dCompileDate
82046>>>>>//        End
82046>>>>>//
82046>>>>>//        // As of DataFlex 19.1 the header has changed; and so has the compile date location.
82046>>>>>//        // It seems to me that the position for the compilation date can vary. So we read line-by-line
82046>>>>>//        // until we encounter the program name that appears just in front of the compile date.
82046>>>>>//        // Although I'm not sure about if/how the position varies, the below seems to work just fine.
82046>>>>>//        If (dCompileDate = 0) Begin
82046>>>>>//            Move "" to sCompileDate
82046>>>>>//            Move 30000 to iSize
82046>>>>>//            For iCount from 1 to iSize
82046>>>>>//                Readln channel iChannel sData
82046>>>>>//                Move (Pos(sProgram, sData)) to iPos
82046>>>>>//                If (iPos <> 0) Begin
82046>>>>>//                    Move (Mid(sData, 10, (iPos + (Length(sProgram) + 2)))) to sCompileDate
82046>>>>>//                    Move (Trim(sCompileDate)) to sCompileDate
82046>>>>>//                    Move iSize to iCount // We're out of here.
82046>>>>>//                End
82046>>>>>//            Loop
82046>>>>>//            If (Left(sCompileDate, 1) = "0") Begin
82046>>>>>//                Move ("1" + String(sCompileDate)) to sCompileDate
82046>>>>>//            End
82046>>>>>//            Get IsDate sCompileDate)) to bIsValid
82046>>>>>//            If (bIsValid = True) Begin
82046>>>>>//                Move (Date(sCompileDate)) to dCompileDate
82046>>>>>//            End
82046>>>>>//        End
82046>>>>>//        Send Seq_Close_Channel iChannel
82046>>>>>//        Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
82046>>>>>
82046>>>>>        Function_Return dCompileDate
82047>>>>>    End_Function
82048>>>>>
82048>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
82048>>>>>    // (the passed program), has been finished
82048>>>>>    // The DOS box does also _not_ flash briefly.
82048>>>>>    Procedure RunProgramWait String sProgram String sParameter
82050>>>>>        Handle hProcess
82050>>>>>        Integer iVoid
82050>>>>>        AboutSHELLEXECUTEINFO sInfo
82050>>>>>        AboutSHELLEXECUTEINFO sInfo
82050>>>>>
82050>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
82051>>>>>
82051>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
82052>>>>>        Move SW_SHOW                 to sInfo.nShow
82053>>>>>
82053>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
82054>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
82055>>>>>        // This will "hide" the DOS box from showing (no flasing box):
82055>>>>>        Move 0                       to sInfo.nShow
82056>>>>>
82056>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
82057>>>>>        Move sInfo.hProcess to hProcess
82058>>>>>        If (hProcess) Begin
82060>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
82061>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
82062>>>>>        End
82062>>>>>>
82062>>>>>    End_Procedure
82063>>>>>
82063>>>>>    Function AddFolderDelimiter String sPath Returns String
82065>>>>>        String sDirSep
82065>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
82066>>>>>        Move (Trim(sPath)) to sPath
82067>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
82069>>>>>            Move (sPath + sDirSep) to sPath
82070>>>>>        End
82070>>>>>>
82070>>>>>        Function_Return sPath
82071>>>>>    End_Function
82072>>>>>
82072>>>>>    // Returns an empty string if the current program is not digitally signed,
82072>>>>>    // or there is a problem with the certificate.
82072>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
82072>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
82072>>>>>    Function IsProgramDigitallySigned Returns String
82074>>>>>        Boolean bExists
82074>>>>>        String sPath sProgram sParams sRetval
82074>>>>>        Integer iCh
82074>>>>>
82074>>>>>        Move "" to sRetval
82075>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
82076>>>>>        Get AddFolderDelimiter sPath to sPath
82077>>>>>        File_Exist (sPath + CS_SignProgram) bExists
82078>>>>>        If (bExists = False) Begin
82080>>>>>            Function_Return "-1"
82081>>>>>        End
82081>>>>>>
82081>>>>>
82081>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
82082>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
82083>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
82084>>>>>        Move (sParams * String("| clip"))    to sParams
82085>>>>>        Get Seq_New_Channel to iCh
82086>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
82088>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
82091>>>>>        Close_Output channel iCh
82093>>>>>        // New ShellExecute based message that waits for the passed process to end.
82093>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
82094>>>>>        Direct_Input channel iCh "CLIPBOARD:"
82096>>>>>            Readln channel iCh sRetval
82098>>>>>            Readln channel iCh sRetval
82100>>>>>            Readln channel iCh sRetval
82102>>>>>            Readln channel iCh sRetval
82104>>>>>        Close_Input channel iCh
82106>>>>>        Send Seq_Release_Channel iCh
82107>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
82109>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
82110>>>>>        End
82110>>>>>>
82110>>>>>        Else Begin
82111>>>>>            Move "" to sRetval
82112>>>>>        End
82112>>>>>>
82112>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
82112>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
82113>>>>>>
82113>>>>>        Function_Return sRetval
82114>>>>>    End_Function
82115>>>>>
82115>>>>>    Procedure Add_LineLn String sValue
82117>>>>>        Send Add_LineLn of oInfoList_Editor sValue
82118>>>>>    End_Procedure
82119>>>>>
82119>>>>>    Procedure Add_Line String sValue
82121>>>>>        Send Add_Line of oInfoList_Editor sValue
82122>>>>>    End_Procedure
82123>>>>>
82123>>>>>    Procedure Set Logo string sLogo
82125>>>>>        // Square bitmaps of 80x80 work best
82125>>>>>        Set Bitmap of oAboutGraphic to sLogo
82126>>>>>    End_Procedure
82127>>>>>
82127>>>>>    Procedure Set LogoDF String sLogo
82129>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
82130>>>>>    End_Procedure
82131>>>>>
82131>>>>>    Procedure Show_Sysinfo
82133>>>>>        Send Popup_Modal of oSysinfoDialog
82134>>>>>    End_Procedure
82135>>>>>
82135>>>>>    Procedure Show_HomePage String sWebpage
82137>>>>>        Handle hWnd
82137>>>>>        Get Window_Handle to hWnd
82138>>>>>        Runprogram Shell Background (Trim(sWebpage))
82139>>>>>    End_Procedure
82140>>>>>
82140>>>>>End_Class
82141>>>
82141>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
82141>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
82141>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
82141>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
82141>>>// decimals you may Get truncation that again may cause problems with finding.
82141>>>//
82141>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
82141>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
82141>>>
82141>>>
82141>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
82141>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
82141>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
82141>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
82141>>>//
82141>>>
82141>>>Class cDbUpdateFunctionLibrary is a cObject
82142>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
82143>>>>
82143>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
82145>>>>    Integer iStart iEnd
82145>>>>    String sRetval
82145>>>>
82145>>>>    Move (Trim(sConnect)) to sConnect
82146>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
82147>>>>    If (iStart = 0) Begin
82149>>>>        Function_Return ""
82150>>>>    End
82150>>>>>
82150>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
82151>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
82152>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
82154>>>>        Move (Pos(",", sRetval))          to iEnd
82155>>>>    End
82155>>>>>
82155>>>>    Else Begin
82156>>>>        Move (Pos(";", sRetval))          to iEnd
82157>>>>    End
82157>>>>>
82157>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
82159>>>>        Move (Pos(",", sRetval))          to iEnd
82160>>>>        Decrement iEnd
82161>>>>    End
82161>>>>>
82161>>>>    If (iEnd <> 0) Begin
82163>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
82164>>>>    End
82164>>>>>
82164>>>>    Move (Replace("=", sRetval, ""))      to sRetval
82165>>>>
82165>>>>    Function_Return (Trim(sRetval))
82166>>>>End_Function
82167>>>>
82167>>>>
82167>>>
82167>>>    Procedure Construct_Object
82169>>>        Handle ho
82169>>>        Forward Send Construct_Object
82171>>>
82171>>>        Move Self to ghoDbUpdateFunctionLibrary
82172>>>
82172>>>        Send CreateDbUpdateLibraryProperties
82173>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
82173>>>        // we will create one as it is used for all ConnectionID, ConnectionString
82173>>>        // etc settings.
82173>>>        If (ghoSQLConnectionHandler = 0) Begin
82175>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
82176>>>            Set phoSQLConnectionHandler to ho
82177>>>        End   
82177>>>>
82177>>>        
82177>>>        Property String private.psCollation "Latin1_General_CS_AS"
82178>>>
82178>>>    End_Procedure
82179>>>
82179>>>    Procedure End_Construct_Object
82181>>>        Forward Send End_Construct_Object
82183>>>    End_Procedure
82184>>>
82184>>>    // *** SQL Messages for making changes to the SQL back-end ***
82184>>>    //
82184>>>    // * Dummy function for the Studio's Code Explorer *
82184>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
82186>>>        Function_Return False
82187>>>    End_Function
82188>>>
82188>>>    // Function for creating a new *Database*.
82188>>>    // Note: This is for creating SQL DATABASES - not tables!
82188>>>    // Returns True if successful.
82188>>>    // ToDo: Currently only works for MS-SQL...
82188>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
82190>>>        String sSQL sSQL1 sConnectionID sConnectionString
82190>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
82190>>>        Handle hConnection hStmt hoSQLManager
82190>>>        Integer iFetchResult iDbType
82190>>>        Boolean bOK bMertechDriver bExists
82190>>>
82190>>>        Get piDbType to iDbType
82191>>>//        If (iDbType <> EN_DbTypeMSSQL and sDriverID <> MDSMySQL and sDriverID <> MDSDB2 and sDriverID <> ODBC_DRV_ID) Begin
82191>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
82193>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 with Mertech drivers"
82194>>>>
82194>>>            Function_Return False
82195>>>        End
82195>>>>
82195>>>
82195>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
82196>>>        If (bExists = True) Begin
82198>>>            Function_Return True
82199>>>        End
82199>>>>
82199>>>
82199>>>        Get IsMertechDriver sDriverID to bMertechDriver
82200>>>        If (bMertechDriver = False) Begin
82202>>>            Get phoSQLManager to hoSQLManager
82203>>>        End
82203>>>>
82203>>>        Else Begin
82204>>>            Get _MertechSQLManagerHandle to hoSQLManager
82205>>>        End
82205>>>>
82205>>>
82205>>>        Get psConnectionID     to sConnectionID
82206>>>        Get psConnectionString to sConnectionString
82207>>>        Move 0 to LastErr
82208>>>
82208>>>        If (sDriverID = ODBC_DRV_ID) Begin
82210>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
82210>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
82210>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
82210>>>//                Move (Pos(";", sConnectionString)) to iPos
82210>>>//                If (iPos > 0) Begin
82210>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
82210>>>//                    Move (Trim(sConnectionString)) to sConnectionString
82210>>>//                End
82210>>>//            End
82210>>>        End
82210>>>>
82210>>>
82210>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82211>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
82212>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82213>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
82215>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
82216>>>>
82216>>>            Function_Return False
82217>>>        End
82217>>>>
82217>>>
82217>>>        Get SqlOpen of hConnection to hStmt
82218>>>
82218>>>        If (hStmt = 0) Begin
82220>>>            Send SqlDisconnect of hoSQLManager
82221>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
82222>>>>
82222>>>            Function_Return False
82223>>>        End
82223>>>>
82223>>>
82223>>>        Get psCollation to sCollation
82224>>>
82224>>>        Case Begin
82224>>>            Case (sDriverID = MSSQLDRV_ID)
82226>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
82227>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
82228>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
82229>>>
82229>>>                // Check if database exists
82229>>>                Send SqlExecDirect of hStmt sSQL
82230>>>                Get SqlFetch of hStmt to iFetchResult
82231>>>                Send SqlClose of hStmt
82232>>>                Send SqlDisconnect of hConnection
82233>>>                // If database already exists we're out of here!
82233>>>                // Note that we return True as this is not an error.
82233>>>                If (iFetchResult > 0) Begin
82235>>>                    Function_Return True
82236>>>                End
82236>>>>
82236>>>                // Database doesn't exist, create it.
82236>>>                If (iFetchResult = 0) Begin
82238>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
82239>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
82240>>>                    If (sCollation <> "") Begin
82242>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
82243>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
82244>>>                    End
82244>>>>
82244>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
82245>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
82246>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
82248>>>                        Function_Return False
82249>>>                    End
82249>>>>
82249>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
82249>>>                    Sleep 1
82250>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
82251>>>                End
82251>>>>
82251>>>                Case Break
82252>>>
82252>>>            Case (sDriverID = MDSPgSQL)
82255>>>                SQLIncludeScriptFile ..\Scripts\CreatePostgreSQLDatabase.sql as CreatePostgreSQLDatabase.sql
82255>>>                Get _SqlUtilCreatePostGreSQLDatabaseByScript "CreatePostgreSQLDatabase.sql" sDatabase to bOK
82256>>>                Case Break
82257>>>
82257>>>            Case (sDriverID = MDSMySQL or (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID))
82260>>>                // ToDo: How should this be set/checked?
82260>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
82260>>>//                    Set psCollation to "utf8"
82260>>>//                End
82260>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
82260>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
82261>>>                Case Break
82262>>>
82262>>>            Case (sDriverID = MDSDB2)
82265>>>                        CompilerWarnings Off
82265>>>                        CREATE_DB2_DATABASE sDatabase "" sCollation ""
82297>>>                        CompilerWarnings Off
82297>>>                Case Break
82298>>>
82298>>>            Case Else
82298>>>                Error DFERR_PROGRAM "Unsupported database type"
82299>>>>
82299>>>        Case End
82299>>>
82299>>>        If (Err = False) Begin
82301>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
82302>>>        End
82302>>>>
82302>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
82302>>>        // the one we just created.
82302>>>        If (bUpdateConnectionString = True and Err = False) Begin
82304>>>            Set psDatabase to sDatabase
82305>>>            //...and perhaps also the SQLConnections.ini file setting.
82305>>>            If (bPermanantly = True) Begin
82307>>>                If (ghoSQLConnectionHandler <> 0) Begin
82309>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
82310>>>                End
82310>>>>
82310>>>            End
82310>>>>
82310>>>        End
82310>>>>
82310>>>
82310>>>        Function_Return (Err = False)
82311>>>    End_Function
82312>>>
82312>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
82312>>>    // will be used.
82312>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
82314>>>        Boolean bOK bExists bShowProgress bErr
82314>>>        String sStatement sDriverID
82314>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
82314>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
82314>>>        Integer iDbType
82314>>>
82314>>>        If (sDatabase = "") Begin
82316>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
82317>>>>
82317>>>            Function_Return False
82318>>>        End
82318>>>>
82318>>>        If (sBackupName = "") Begin
82320>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
82321>>>>
82321>>>            Function_Return False
82322>>>        End
82322>>>>
82322>>>
82322>>>        // Create backup-folder if it doesn't exist
82322>>>        Get vFolderExists sPath to bExists
82323>>>        If (bExists = False) Begin
82325>>>            Get vCreateDirectory sPath to bErr
82326>>>            If (bErr = True) Begin
82328>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
82329>>>>
82329>>>                Function_Return False
82330>>>            End
82330>>>>
82330>>>        End
82330>>>>
82330>>>        // Make sure the path ends with a back-slash
82330>>>        If (sPath <> "") Begin
82332>>>            Get vFolderFormat sPath to sPath
82333>>>        End
82333>>>>
82333>>>
82333>>>        Get psDriverID to sDriverID
82334>>>        Get piDbType   to iDbType
82335>>>        If (num_arguments > 3) Begin
82337>>>            Move bShowProg to bShowProgress
82338>>>        End
82338>>>>
82338>>>
82338>>>        Case Begin
82338>>>            Case (iDbType = EN_DbTypeMSSQL)
82340>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
82340>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
82340>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
82341>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
82342>>>
82342>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
82343>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
82344>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
82345>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
82346>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
82347>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
82348>>>                Case Break
82349>>>            Case Else
82349>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
82350>>>        Case End
82350>>>
82350>>>        Function_Return bOK
82351>>>    End_Function
82352>>>
82352>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
82354>>>//        Boolean bOK bExists
82354>>>        String sStatement sDriverID sRetval //sPrevious
82354>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
82354>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
82354>>>        Integer iDbType iRows iFetchResult //iColumn
82354>>>        Handle hoSQLHandler hoSQLConnect hstmt
82354>>>        tSQLConnection SQLConnection
82354>>>        tSQLConnection SQLConnection
82354>>>
82354>>>        If (sDatabase = "") Begin
82356>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
82357>>>>
82357>>>            Function_Return ""
82358>>>        End
82358>>>>
82358>>>
82358>>>        Move "" to sRetval
82359>>>        Get psDriverID to sDriverID
82360>>>        Get piDbType   to iDbType
82361>>>
82361>>>        Case Begin
82361>>>            Case (iDbType = EN_DbTypeMSSQL)
82363>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
82363>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
82364>>>
82364>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
82365>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
82366>>>                Get phoSQLManager to hoSQLHandler
82367>>>
82367>>>                If (hoSQLHandler <> 0) Begin
82369>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
82370>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
82371>>>
82371>>>                    If (hoSQLConnect <> 0) Begin
82373>>>                        Get SQLOpen of hoSQLConnect to hstmt
82374>>>                        If (hstmt <> 0) Begin
82376>>>                            Send SqlExecDirect of hstmt sStatement
82377>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
82378>>>                            Get SQLFetch of hstmt to iFetchResult
82379>>>                            If (iFetchResult <> 0) Begin
82381>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
82382>>>                            End
82382>>>>
82382>>>                            Send SQLClose of hstmt
82383>>>                        End
82383>>>>
82383>>>                        Send SQLDisconnect of hoSQLConnect
82384>>>                    End
82384>>>>
82384>>>                End
82384>>>>
82384>>>                Case Break
82385>>>            Case Else
82385>>>                If (bSilent = False) Begin
82387>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
82388>>>                End
82388>>>>
82388>>>        Case End
82388>>>
82388>>>        Function_Return sRetval
82389>>>    End_Function
82390>>>
82390>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
82392>>>        Boolean bMertechDriver // bOK bExists 
82392>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
82392>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
82392>>>        Handle hConnection hStmt hoSQLManager
82392>>>        Integer iDbType // iFetchResult
82392>>>
82392>>>        If (sDatabase = "") Begin
82394>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
82395>>>>
82395>>>            Function_Return False
82396>>>        End
82396>>>>
82396>>>
82396>>>        If (sSQLCollation = "") Begin
82398>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
82399>>>>
82399>>>            Function_Return False
82400>>>        End
82400>>>>
82400>>>
82400>>>        Get psDriverID to sDriverID
82401>>>        Get piDbType   to iDbType
82402>>>
82402>>>        Get IsMertechDriver sDriverID to bMertechDriver
82403>>>        If (bMertechDriver = False) Begin
82405>>>            Get phoSQLManager to hoSQLManager
82406>>>        End
82406>>>>
82406>>>        Else Begin
82407>>>            Get _MertechSQLManagerHandle to hoSQLManager
82408>>>        End
82408>>>>
82408>>>
82408>>>        Get psConnectionID     to sConnectionID
82409>>>        Get psConnectionString to sConnectionString
82410>>>        Move 0 to LastErr
82411>>>
82411>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82412>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
82413>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82414>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
82416>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
82417>>>>
82417>>>            Function_Return False
82418>>>        End
82418>>>>
82418>>>
82418>>>        Get SqlOpen of hConnection to hStmt
82419>>>
82419>>>        If (hStmt = 0) Begin
82421>>>            Send SqlDisconnect of hoSQLManager
82422>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
82423>>>>
82423>>>            Function_Return False
82424>>>        End
82424>>>>
82424>>>
82424>>>        // Check if collation already exists
82424>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
82425>>>        // If the current collate is the same as the new; do nothing.
82425>>>        If (sSQLCollation = sSQLCollationCheck) Begin
82427>>>            Function_Return True
82428>>>        End
82428>>>>
82428>>>
82428>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
82429>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
82430>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
82431>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
82432>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
82433>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
82434>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
82435>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
82436>>>
82436>>>        // MS-SQL Syntax:
82436>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
82436>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
82436>>>        // ALTER DATABASE [database] SET MULTI_USER;
82436>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
82437>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
82438>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
82439>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
82439>>>
82439>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
82440>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
82441>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
82442>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
82444>>>           Function_Return False
82445>>>        End
82445>>>>
82445>>>
82445>>>        Function_Return (Err = False)
82446>>>    End_Function
82447>>>
82447>>>
82447>>>    // * Dummy function for the Studio's Code Explorer *
82447>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
82449>>>        Function_Return False
82450>>>    End_Function
82451>>>
82451>>>    // Converts from SQL to Embedded (DataFlex .dat files).
82451>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
82451>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
82451>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
82451>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
82451>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
82453>>>        Handle hToTable
82453>>>        Boolean bOK bExists bOpened bMertechDriver bCopyData
82453>>>        String sDriverID sPhysicalName sRootName sDisplayName
82453>>>        tSQLConnection SQLConnection
82453>>>        tSQLConnection SQLConnection
82453>>>        Integer iPos iMaxRecords
82453>>>
82453>>>        Get psDriverID to sDriverID
82454>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
82455>>>        If (bExists = False) Begin
82457>>>            Function_Return False
82458>>>        End
82458>>>>
82458>>>
82458>>>        If (num_arguments > 1) Begin
82460>>>            Move bCpyDat to bCopyData
82461>>>        End
82461>>>>
82461>>>        Else Begin
82462>>>            Move False to bCopyData
82463>>>        End
82463>>>>
82463>>>
82463>>>        Open hTable
82465>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
82468>>>        If (bOpened = False) Begin
82470>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
82471>>>>
82471>>>            Function_Return False
82472>>>        End
82472>>>>
82472>>>        Move 0 to hToTable
82473>>>
82473>>>        Move 16711679 to iMaxRecords
82474>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
82477>>>        Move (Pos(".", sDisplayName)) to iPos
82478>>>        If (iPos > 0) Begin
82480>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
82481>>>        End
82481>>>>
82481>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
82484>>>        Get _TableNameOnly sRootName                 to sRootName
82485>>>        Move (sRootName + ".dat")                    to sPhysicalName
82486>>>
82486>>>        If (ghoProgressBar <> 0) Begin
82488>>>            Send DoAdvance of ghoProgressBar
82489>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
82490>>>        End
82490>>>>
82490>>>
82490>>>        Move False to Err
82491>>>
82491>>>        Structure_Start hToTable DATAFLEX_ID
82492>>>            Structure_Copy hTable to hToTable
82493>>>
82493>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
82496>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
82499>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
82502>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
82505>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
82508>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
82509>>>
82509>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
82511>>>
82511>>>        Set Action_Text of ghoStatusPanel to ""
82512>>>        Move (not(Err)) to bOK
82513>>>        If (bOK = True and bCopyData = True) Begin
82515>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
82516>>>        End
82516>>>>
82516>>>
82516>>>        Get IsMertechDriver sDriverID to bMertechDriver
82517>>>        If (bMertechDriver = True) Begin
82519>>>            Open hTable
82521>>>        End
82521>>>>
82521>>>
82521>>>        // This must be after copying data...
82521>>>        If (Err = False) Begin
82523>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
82526>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
82529>>>        End
82529>>>>
82529>>>        Move (not(Err)) to bOK
82530>>>
82530>>>        Function_Return (bOK = True)
82531>>>    End_Function
82532>>>
82532>>>    Function AddFolderDelimiter String sPath Returns String
82534>>>        String sDirSep
82534>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
82535>>>        Move (Trim(sPath)) to sPath
82536>>>        If (Right(sPath, 1) <> sDirSep) Begin
82538>>>            Move (sPath + sDirSep) to sPath
82539>>>        End
82539>>>>
82539>>>        Function_Return sPath
82540>>>    End_Function
82541>>>
82541>>>    // Creates an SQL Table at the SQL end by its filelist number;
82541>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
82541>>>    Function SqlTableCreate Integer hTable Returns Boolean
82543>>>        String sTableName sSQLString sPath sCreateTable sDriverID
82543>>>        Integer iDbType
82543>>>        Boolean bExists
82543>>>
82543>>>        Get psDriverID to sDriverID
82544>>>        Get UtilTableHandleToString hTable to sTableName
82545>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
82546>>>        If (bExists = True) Begin
82548>>>            Function_Return False
82549>>>        End
82549>>>>
82549>>>
82549>>>        Get psDataPathFirstPart to sPath
82550>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
82551>>>
82551>>>        Get piDbType to iDbType
82552>>>        Get _SqlProperTableName sTableName to sTableName
82553>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
82554>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
82555>>>
82555>>>        Move False to Err
82556>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
82557>>>
82557>>>        Function_Return (Err = False)
82558>>>    End_Function
82559>>>
82559>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
82559>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
82559>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
82561>>>        String sSQLString sPath sCreateTable sDriverID
82561>>>        Integer iDbType
82561>>>        Boolean bExists
82561>>>
82561>>>        Get psDriverID to sDriverID
82562>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
82563>>>        If (bExists = True) Begin
82565>>>            Function_Return False
82566>>>        End
82566>>>>
82566>>>
82566>>>        Get psDataPathFirstPart to sPath
82567>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
82568>>>        If (bExists = True) Begin
82570>>>            // ToDo: What should we do if an .int file already exists?
82570>>>        End
82570>>>>
82570>>>
82570>>>        Get piDbType to iDbType
82571>>>        Get _SqlProperTableName sTableName to sTableName
82572>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
82573>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
82574>>>
82574>>>        Move False to Err
82575>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
82576>>>
82576>>>        Function_Return (Err = False)
82577>>>    End_Function
82578>>>    
82578>>>    // ToDo: 2019-09-23 This needs to be finilized 
82578>>>    // It resets SQL constraints after a Structure_End, if necessary.
82578>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
82580>>>        Boolean bOK                                                            
82580>>>        String sStatement
82580>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
82581>>>        Function_Return bOK
82582>>>    End_Function
82583>>>    
82583>>>    // First deletes the data cache file and then drops the passed SQL table.
82583>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
82583>>>    //       else try using the SqlTableRemoveByTableName message.
82583>>>    Function SqlTableRemove Handle hTable Returns Boolean
82585>>>        String sSQLString sPath sDropTable sTableName sDriverID
82585>>>        Integer iRetval iDbType
82585>>>        Boolean bExists bMertechDriver bOK
82585>>>
82585>>>        Get psDriverID to sDriverID
82586>>>        Get IsMertechDriver sDriverID to bMertechDriver
82587>>>        Get UtilTableHandleToString hTable to sTableName
82588>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
82589>>>        If (bExists = False) Begin
82591>>>            Function_Return False
82592>>>        End
82592>>>>
82592>>>
82592>>>        Get psDataPathFirstPart to sPath
82593>>>        Get UtilDeleteCacheFile sTableName to iRetval
82594>>>
82594>>>        Get piDbType to iDbType
82595>>>        Get _SqlProperTableName sTableName to sTableName
82596>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
82597>>>        Move (sDropTable * String(sTableName)) to sSQLString
82598>>>
82598>>>        Move False to Err
82599>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
82600>>>
82600>>>        // We also need to remove the cache-file since the table has been changed
82600>>>        Get UtilDeleteCacheFile sTableName to bOK
82601>>>
82601>>>        Function_Return (Err = False)
82602>>>    End_Function
82603>>>
82603>>>    // First deletes the data cache file and then drops the passed data table.
82603>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
82605>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
82605>>>        Integer iRetval iDbType
82605>>>        Boolean bMertechDriver bOK
82605>>>
82605>>>        Get psDriverID to sDriverID
82606>>>        Get IsMertechDriver sDriverID to bMertechDriver
82607>>>        Get psDataPathFirstPart to sPath
82608>>>        Get UtilDeleteCacheFile sTableName to iRetval
82609>>>
82609>>>        Get piDbType to iDbType
82610>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
82611>>>        Get psSchema to sSchema
82612>>>        If (sSchema = "") Begin
82614>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
82615>>>        End
82615>>>>
82615>>>        Move (Uppercase(sTableName)) to sVal
82616>>>        If (not(sVal contains (sSchema + "."))) Begin
82618>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
82619>>>        End
82619>>>>
82619>>>        Move (sDropTable * String(sTableName)) to sSQLString
82620>>>
82620>>>        Move False to Err
82621>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
82622>>>
82622>>>        // We also need to remove the cache-file since the table has been changed
82622>>>        Get UtilDeleteCacheFile sTableName to bOK
82623>>>
82623>>>        Function_Return (Err = False)
82624>>>    End_Function
82625>>>
82625>>>    // *** Sql View Messages ***
82625>>>
82625>>>    // First deletes the data cache file and then drops the passed Sql data view.
82625>>>    Function SqlViewRemove String sDataView Returns Boolean
82627>>>        String sDriverID sSQLString sDropViewKeyWord
82627>>>        Integer iRetval
82627>>>        Boolean bMertechDriver bOK
82627>>>
82627>>>        Get psDriverID to sDriverID
82628>>>        Get IsMertechDriver sDriverID to bMertechDriver
82629>>>        Get UtilDeleteCacheFile sDataView to iRetval
82630>>>
82630>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
82631>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
82632>>>        Set psSQLStatementString to sSQLString
82633>>>
82633>>>        // As we don't check if the view exist or not, it might happen
82633>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
82633>>>        Move False to Err
82634>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
82635>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
82636>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
82637>>>        Move 0 to LastErr
82638>>>
82638>>>        // We also need to remove the cache-file since the table has been changed
82638>>>        Get UtilDeleteCacheFile sDataView to bOK
82639>>>
82639>>>        Function_Return (Err = False)
82640>>>    End_Function
82641>>>
82641>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
82643>>>        Boolean bOK
82643>>>        Integer iDbType
82643>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
82643>>>
82643>>>        Get psDriverID to sDriverID
82644>>>        Get piDbType   to iDbType
82645>>>
82645>>>        Case Begin
82645>>>            Case (iDbType = EN_DbTypeDB2)
82647>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
82648>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
82649>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
82650>>>            Break
82651>>>
82651>>>            Case (iDbType = EN_DbTypeMSSQL)
82654>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
82655>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
82656>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
82657>>>            Break
82658>>>
82658>>>            Case (iDbType = EN_DbTypeOracle)
82661>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
82662>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
82663>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
82664>>>            Break
82665>>>
82665>>>            Case (iDbType = EN_DbTypePostgre)
82668>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
82669>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
82670>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
82671>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
82672>>>            Break
82673>>>
82673>>>            Case (iDbType = EN_DbTypeMySQL)
82676>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
82677>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
82678>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
82679>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
82680>>>            Break
82681>>>        Case End
82681>>>
82681>>>        Move False to Err
82682>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
82683>>>        Move (Err = False) to bOK
82684>>>
82684>>>        Function_Return bOK
82685>>>    End_Function
82686>>>
82686>>>    // * Dummy function for the Studio's Code Explorer *
82686>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
82688>>>        Function_Return False
82689>>>    End_Function
82690>>>
82690>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
82690>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
82692>>>        Integer iLength iDecimals
82692>>>        String sColumnValue
82692>>>        String sTableName sDriverID
82692>>>        Boolean bOK bInitializeValue
82692>>>
82692>>>        Get psDriverID to sDriverID
82693>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82694>>>        If (bOK = False) Begin
82696>>>            Function_Return False
82697>>>        End
82697>>>>
82697>>>
82697>>>        Get UtilTableHandleToString hTable to sTableName
82698>>>        If (sTableName = "") Begin
82700>>>            Function_Return False
82701>>>        End
82701>>>>
82701>>>
82701>>>        If (num_arguments > 3) Begin
82703>>>            Move iLen     to iLength
82704>>>            Move iDec     to iDecimals
82705>>>            Move bInitVal to bInitializeValue
82706>>>            Move sColVal  to sColumnValue
82707>>>        End
82707>>>>
82707>>>
82707>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
82708>>>
82708>>>        Function_Return (bOK = True)
82709>>>    End_Function
82710>>>
82710>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
82710>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
82712>>>        Integer iDbType iLength iDecimals iDriver
82712>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
82712>>>        String sDriverID sNotNull
82712>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState bIsMertechDriver
82712>>>        Handle hTable
82712>>>
82712>>>        Get psDriverID to sDriverID
82713>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82714>>>        If (bOK = False) Begin
82716>>>            Function_Return True
82717>>>        End
82717>>>>
82717>>>
82717>>>        Get UtilTableNameToHandle sTableName to hTable
82718>>>        If (hTable = 0) Begin
82720>>>            Get NextFreeFilelistSlot to hTable
82721>>>        End
82721>>>>
82721>>>
82721>>>        Get piDbType to iDbType
82722>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
82722>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
82723>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
82725>>>            Function_Return True
82726>>>        End
82726>>>>
82726>>>
82726>>>        Get DriverIndex sDriverID to iDriver
82727>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
82728>>>        If (bIsMertechDriver = False) Begin
82730>>>            Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
82733>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
82736>>>        End
82736>>>>
82736>>>
82736>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
82737>>>        If (num_arguments > 3) Begin
82739>>>            Move iLen     to iLength
82740>>>            Move iDec     to iDecimals
82741>>>            Move bInitVal to bInitializeValue
82742>>>            Move sColVal  to sColumnValue
82743>>>        End
82743>>>>
82743>>>
82743>>>        Get _SqlProperTableName sTableName   to sTableName
82744>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
82745>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
82746>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
82747>>>
82747>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
82748>>>        If (bFixed = False) Begin
82750>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
82751>>>        End
82751>>>>
82751>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
82752>>>
82752>>>        Move False to Err
82753>>>        Send SqlUtilExecuteQuery sStmt sDriverID
82754>>>
82754>>>        If (bInitializeValue = True and Err = False) Begin
82756>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
82757>>>        End
82757>>>>
82757>>>
82757>>>        If (Err = False) Begin
82759>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
82760>>>        End
82760>>>>
82760>>>
82760>>>        Move (not(Err)) to bRetval
82761>>>
82761>>>        // We also need to remove the cache-file since the table has been changed
82761>>>        Get UtilDeleteCacheFile sTableName to bOK
82762>>>        If (bIsMertechDriver = False) Begin
82764>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
82767>>>        End
82767>>>>
82767>>>        Function_Return bRetval
82768>>>    End_Function
82769>>>
82769>>>    // To update all current rows for a table column with a common value.
82769>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
82771>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
82771>>>        Boolean bRetval bSQLDriver
82771>>>        Integer iCurrErr iDbType
82771>>>
82771>>>        Move False to bRetval
82772>>>        Get piDbType to iDbType
82773>>>        Get psDriverID to sDriverID
82774>>>        Get IsSQLDriver sDriverID to bSQLDriver
82775>>>        If (bSQLDriver = False) Begin
82777>>>            Function_Return bRetval
82778>>>        End
82778>>>>
82778>>>        Get UtilTableHandleToString hTable to sTableName
82779>>>
82779>>>        Move Err to iCurrErr
82780>>>        Move False to Err
82781>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
82782>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
82783>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
82784>>>        If (sDriverID = MDSMySQL) Begin
82786>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
82787>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'" * sSet * sSqlSafe_Updates + "=1") to sStmt
82788>>>        End
82788>>>>
82788>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
82788>>>        If (iDbType = EN_DbTypeMySQL) Begin
82790>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
82791>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
82792>>>        End
82792>>>>
82792>>>        Else Begin
82793>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
82794>>>        End
82794>>>>
82794>>>
82794>>>        Send SqlUtilExecuteQuery sStmt sDriverID
82795>>>        Move (Err = False) to bRetval
82796>>>        Move iCurrErr to Err
82797>>>
82797>>>        Function_Return bRetval
82798>>>    End_Function
82799>>>
82799>>>    // The fourth & fifth arguments are optional, depending on the iDataType
82799>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
82799>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
82801>>>        String sDriverID sTableName
82801>>>        Boolean bOK
82801>>>
82801>>>        Get psDriverID to sDriverID
82802>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82803>>>        If (bOK = False) Begin
82805>>>            Function_Return False
82806>>>        End
82806>>>>
82806>>>
82806>>>        Get UtilTableHandleToString hTable to sTableName
82807>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
82808>>>
82808>>>        Function_Return (Err = False)
82809>>>    End_Function
82810>>>
82810>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
82810>>>    // The fourth & fifth arguments are optional, depending on the iDataType
82810>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
82810>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
82812>>>        Integer iDbType iLength iDecimals
82812>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
82812>>>        Boolean bExists bOK bFixed
82812>>>        Handle hTable
82812>>>
82812>>>        Get psDriverID to sDriverID
82813>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82814>>>        If (bOK = False) Begin
82816>>>            Function_Return False
82817>>>        End
82817>>>>
82817>>>
82817>>>        Get UtilTableNameToHandle sTableName to hTable
82818>>>        If (hTable = 0) Begin
82820>>>            Get NextFreeFilelistSlot to hTable
82821>>>        End
82821>>>>
82821>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
82822>>>        If (bExists = False) Begin
82824>>>            Function_Return False
82825>>>        End
82825>>>>
82825>>>
82825>>>        If (num_arguments > 3) Begin
82827>>>            Move iLen to iLength
82828>>>        End
82828>>>>
82828>>>        If (num_arguments > 4) Begin
82830>>>            Move iDec to iDecimals
82831>>>        End
82831>>>>
82831>>>
82831>>>        Get piDbType to iDbType
82832>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
82833>>>
82833>>>        Move False to Err
82834>>>        Get _SqlProperTableName sTableName    to sTableName
82835>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
82836>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
82837>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
82838>>>
82838>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
82839>>>        If (bFixed = False) Begin
82841>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
82842>>>        End
82842>>>>
82842>>>
82842>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
82843>>>        Send SqlUtilExecuteQuery sStmt sDriverID
82844>>>
82844>>>        // We also need to remove the cache-file since the table has been changed
82844>>>        Get UtilDeleteCacheFile sTableName to bOK
82845>>>
82845>>>        Function_Return (Err = False)
82846>>>    End_Function
82847>>>
82847>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
82849>>>        Boolean bOK bErr bIsSQLDriver
82849>>>        String sDriverID
82849>>>        Integer iDataType
82849>>>
82849>>>        Get psDriverID to sDriverID
82850>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
82851>>>        If (bIsSQLDriver = False) Begin
82853>>>            Function_Return False
82854>>>        End
82854>>>>
82854>>>
82854>>>        Move Err to bErr
82855>>>        Move False to bErr
82856>>>
82856>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
82856>>>        // inserts randomly character(10) and spaces, so we correct from that here:
82856>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
82857>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
82860>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
82862>>>            Move ("[" + String(sValue) + "]") to sValue
82863>>>        End
82863>>>>
82863>>>
82863>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
82866>>>        Move (not(Err)) to bOK
82867>>>        Move bErr to Err
82868>>>
82868>>>        Function_Return bOK
82869>>>    End_Function
82870>>>
82870>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
82872>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
82872>>>        String sDriverID
82872>>>
82872>>>        Get psDriverID to sDriverID
82873>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
82874>>>        If (bIsSQLDriver = False) Begin
82876>>>            Function_Return False
82877>>>        End
82877>>>>
82877>>>
82877>>>        Move Err to bErr
82878>>>        Move False to bErr
82879>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
82882>>>        If (bNullable = bCurrentState) Begin
82884>>>            Function_Return True
82885>>>        End
82885>>>>
82885>>>
82885>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
82888>>>        If (bOpen = False) Begin
82890>>>            Get AutoConnectionIDLogin to bOK
82891>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
82892>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
82893>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
82894>>>            Open hTable
82896>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
82897>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
82898>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
82899>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
82902>>>        End
82902>>>>
82902>>>        If (bOpen = True) Begin
82904>>>            Structure_Start hTable sDriverID
82905>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
82908>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
82909>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
82911>>>            Set Action_Text of ghoStatusPanel to ""
82912>>>        End
82912>>>>
82912>>>
82912>>>        Move (not(Err)) to bOK
82913>>>        Move bErr to Err
82914>>>
82914>>>        Function_Return bOK
82915>>>    End_Function
82916>>>
82916>>>    // Drop column by its table handle
82916>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
82918>>>        String sDriverID sTableName
82918>>>        Boolean bOK
82918>>>
82918>>>        Get psDriverID to sDriverID
82919>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82920>>>        If (bOK = False) Begin
82922>>>            Function_Return False
82923>>>        End
82923>>>>
82923>>>
82923>>>        Get UtilTableHandleToString hTable to sTableName
82924>>>        If (sTableName = "") Begin
82926>>>            Function_Return False
82927>>>        End
82927>>>>
82927>>>
82927>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
82928>>>
82928>>>        Function_Return (bOK = True)
82929>>>    End_Function
82930>>>
82930>>>    // Drop column by its table name as a string.
82930>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
82932>>>        Integer iDbType iDriver
82932>>>        String sDriverID sStmt sAlterTable sDropColumn
82932>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
82932>>>        Handle hTable
82932>>>
82932>>>        Get psDriverID to sDriverID
82933>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82934>>>        If (bOK = False) Begin
82936>>>            Function_Return False
82937>>>        End
82937>>>>
82937>>>
82937>>>        Get DriverIndex sDriverID to iDriver
82938>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
82941>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
82944>>>
82944>>>        Get UtilTableNameToHandle sTableName to hTable
82945>>>        If (hTable <> 0) Begin
82947>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
82948>>>            If (bExists = False) Begin
82950>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
82953>>>                Function_Return False
82954>>>            End
82954>>>>
82954>>>        End
82954>>>>
82954>>>
82954>>>        Get piDbType to iDbType
82955>>>        If (iDbType = EN_DbTypeMSSQL) Begin
82957>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
82958>>>            Get UtilDeleteCacheFile sTableName to bOK
82959>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
82962>>>            Function_Return bOK
82963>>>        End
82963>>>>
82963>>>
82963>>>        Move False to Err
82964>>>        Get _SqlProperTableName sTableName    to sTableName
82965>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
82966>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
82967>>>
82967>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
82968>>>        Send SqlUtilExecuteQuery sStmt sDriverID
82969>>>        Move (not(Err)) to bRetval
82970>>>
82970>>>        // We also need to remove the cache-file since the table has been changed
82970>>>        Get UtilDeleteCacheFile sTableName to bOK
82971>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
82974>>>
82974>>>        Function_Return bRetval
82975>>>    End_Function
82976>>>
82976>>>    // Rename a field/column by table handle (filelist number)
82976>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
82978>>>        String sDriverID sTableName
82978>>>        Boolean bOK
82978>>>
82978>>>        Get psDriverID to sDriverID
82979>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82980>>>        If (bOK = False) Begin
82982>>>            Function_Return False
82983>>>        End
82983>>>>
82983>>>
82983>>>        Get UtilTableHandleToString hTable to sTableName
82984>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
82985>>>
82985>>>        Function_Return (Err = False)
82986>>>    End_Function
82987>>>
82987>>>    // Rename a field/column by table name.
82987>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
82989>>>        Integer iDbType iDataType
82989>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
82989>>>        Boolean bOK bRetval
82989>>>        Handle hTable
82989>>>
82989>>>        Move sTableName to sOrgTableName
82990>>>        Get psDriverID to sDriverID
82991>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82992>>>        If (bOK = False) Begin
82994>>>            Function_Return False
82995>>>        End
82995>>>>
82995>>>
82995>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
82996>>>        If (sVal = "") Begin
82998>>>            Function_Return False
82999>>>        End
82999>>>>
82999>>>
82999>>>        Get piDbType to iDbType
83000>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
83001>>>        Get _SqlProperTableName sTableName     to sTableName
83002>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
83003>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
83004>>>
83004>>>        Case Begin
83004>>>            Case (iDbType = EN_dbTypeMSSQL)
83006>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
83007>>>                Case Break
83008>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
83008>>>            Case (iDbType = EN_dbTypeOracle)
83011>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
83012>>>                Case Break
83013>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
83013>>>            Case (iDbType = EN_dbTypeDB2)
83016>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
83017>>>                Case Break
83018>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
83018>>>            Case (iDbType = EN_dbTypePostgre)
83021>>>                Move sOrgTableName to sTableName
83022>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
83023>>>                Case Break
83024>>>            Case (iDbType = EN_dbTypeMySQL)
83027>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
83027>>>                Move sOrgTableName to sTableName
83028>>>                Get psDatabase to sDatabase
83029>>>                Get UtilTableNameToHandle sTableName to hTable
83030>>>                If (hTable = 0) Begin
83032>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
83033>>>                    If (bOK = False) Begin
83035>>>                        Function_Return False
83036>>>                    End
83036>>>>
83036>>>                    Get NextFreeFilelistSlot to hTable
83037>>>                End
83037>>>>
83037>>>                Else Begin
83038>>>                    Open hTable
83040>>>                End
83040>>>>
83040>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
83041>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
83042>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
83043>>>                Case Break
83044>>>            Case Else
83044>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
83045>>>        Case End
83045>>>
83045>>>        Move False to Err
83046>>>        Send SqlUtilExecuteQuery sStmt sDriverID
83047>>>        Move (Err = False) to bRetval
83048>>>        // We also need to remove the cache-file since the table has been changed
83048>>>        Get UtilDeleteCacheFile sTableName to bOK
83049>>>
83049>>>        Function_Return bRetval
83050>>>    End_Function
83051>>>
83051>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
83053>>>        Handle hoSQLHandler hSQLConnect hStmt
83053>>>        Boolean bMertechDriver
83053>>>        Integer iNumCols iCount iDataType
83053>>>        String sValue
83053>>>
83053>>>        Get IsMertechDriver sDriverID to bMertechDriver
83054>>>        If (bMertechDriver = False) Begin
83056>>>            Get phoSQLManager to hoSQLHandler
83057>>>        End
83057>>>>
83057>>>        Else Begin
83058>>>            Get _MertechSQLManagerHandle to hoSQLHandler
83059>>>        End
83059>>>>
83059>>>
83059>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
83060>>>        If (hSQLConnect <> 0) Begin
83062>>>            Get SQLOpen of hSQLConnect to hStmt
83063>>>            If (hStmt <> 0) Begin
83065>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
83066>>>
83066>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
83067>>>                For iCount from 1 to iNumCols
83073>>>>
83073>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
83074>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
83076>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
83077>>>                        Move iNumCols to iCount // We're out of here
83078>>>                    End
83078>>>>
83078>>>                Loop
83079>>>>
83079>>>
83079>>>                Send SQLClose of hStmt
83080>>>            End
83080>>>>
83080>>>            Send SQLDisconnect of hSQLConnect
83081>>>        End
83081>>>>
83081>>>
83081>>>        Function_Return iDataType
83082>>>    End_Function
83083>>>
83083>>>    // * Dummy function for the Studio's Code Explorer *
83083>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
83085>>>        Function_Return False
83086>>>    End_Function
83087>>>
83087>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
83089>>>        String sMessage // sConnectionString
83089>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
83089>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
83089>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
83092>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
83092>>>        TimeSpan tsQuery tsFetch
83092>>>        tSqlErrorArray aSqlErrorArray
83092>>>        tSqlErrorArray aSqlErrorArray
83092>>>        Boolean bOK bMertechDriver bShowProgress
83092>>>        tSQLConnection SQLConnection
83092>>>        tSQLConnection SQLConnection
83092>>>
83092>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83093>>>        If (bOK = False) Begin
83095>>>            Procedure_Return
83096>>>        End
83096>>>>
83096>>>
83096>>>        If (num_arguments > 2) Begin
83098>>>            Move bShowProgr to bShowProgress
83099>>>        End
83099>>>>
83099>>>
83099>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83100>>>
83100>>>        Get IsMertechDriver sDriverID to bMertechDriver
83101>>>        If (bMertechDriver = True) Begin
83103>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
83104>>>        End
83104>>>>
83104>>>        If (bMertechDriver = False) Begin
83106>>>            Get phoSQLManager to hoSqlHandler
83107>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
83108>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
83109>>>        End
83109>>>>
83109>>>
83109>>>        If (hoSQLConnect <> 0) Begin
83111>>>            Get SqlOpen of hoSQLConnect to hoStmt
83112>>>            If (hoStmt <> 0) Begin
83114>>>                // record starting date/time stamp
83114>>>                Move (CurrentDateTime()) to dtQueryExecStart
83115>>>                // turn on error handling if enabled
83115>>>                If (pbHandleQueryErrors(Self)) Begin
83117>>>                    Set pbSqlError to False
83118>>>                    Set paSqlErrorArray to aSqlErrorArray
83119>>>                    Move Error_Object_Id to hoError
83120>>>                    If (ghoDbUpdateHandler <> 0) Begin
83122>>>                        Move ghoDbUpdateHandler to Error_Object_Id
83123>>>                    End
83123>>>>
83123>>>                    Else Begin
83124>>>                        Move Self to Error_Object_Id
83125>>>                    End
83125>>>>
83125>>>                End
83125>>>>
83125>>>
83125>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
83125>>>                Set psSQLStatementString to sStmt
83126>>>                Send Cursor_Wait of Cursor_Control
83127>>>                Send SqlExecDirect of hoStmt sStmt
83128>>>                Send Cursor_Ready of Cursor_Control
83129>>>
83129>>>                If (pbHandleQueryErrors(Self)) Begin
83131>>>                    Move hoError to Error_Object_Id
83132>>>                End
83132>>>>
83132>>>
83132>>>                Move 0 to iMsgs
83133>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
83133>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
83133>>>                If (bMertechDriver = False) Begin
83135>>>                    Move Err to iErr
83136>>>                    Move LastErr to iLastErr
83137>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
83138>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
83139>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83140>>>                    Send _SqlColumnInfo hoStmt
83141>>>                    Send Ignore_Error of Error_Object_Id 12289
83142>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
83143>>>                    Repeat
83143>>>>
83143>>>                        Get SqlFetch of hoStmt to iFetchResult
83144>>>                        If (iFetchResult <> 0) Begin
83146>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
83147>>>                        End
83147>>>>
83147>>>                    Until (iFetchResult = 0)
83149>>>                    Send Trap_Error of Error_Object_Id 12289
83150>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
83151>>>                    Move iErr to Err
83152>>>                    Move iLastErr to LastErr
83153>>>                    Set paSQLFetchResults to aSQLFetchResults
83154>>>                End
83154>>>>
83154>>>
83154>>>                Set piRows    to iRows
83155>>>                Set piRowType to iRowType
83156>>>                Move (CurrentDateTime()) to dtQueryExecEnd
83157>>>                Move (CurrentDateTime()) to dtFetchStart
83158>>>
83158>>>                If (iMsgs <> 0) Begin
83160>>>                    If (ghoDbUpdateHandler > 0) Begin
83162>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83163>>>                    End
83163>>>>
83163>>>                    For i from 1 to iMsgs
83169>>>>
83169>>>                        Get SqlGetMessage of hoStmt i to sMessage
83170>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
83171>>>                        If (bShowProgress = True) Begin
83173>>>                            If (Active_State(ghoStatusPanel)) Begin
83175>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
83176>>>                            End
83176>>>>
83176>>>                            Else Begin
83177>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
83179>>>                            End
83179>>>>
83179>>>                        End
83179>>>>
83179>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
83180>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
83181>>>                    Loop
83182>>>>
83182>>>                    If (ghoDbUpdateHandler > 0) Begin
83184>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83185>>>                    End
83185>>>>
83185>>>                    Set paQueryMessages to sMsg
83186>>>                End
83186>>>>
83186>>>                Else Begin
83187>>>                    If (bShowProgress = True) Begin
83189>>>                        Get paSqlErrorArray to aSqlErrorArray
83190>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
83192>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
83193>>>                            Decrement iMsgs
83194>>>                            For i from 0 to iMsgs
83200>>>>
83200>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
83203>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
83206>>>                            Loop
83207>>>>
83207>>>                        End
83207>>>>
83207>>>                    End
83207>>>>
83207>>>                End
83207>>>>
83207>>>                Move (CurrentDateTime()) to dtFetchEnd
83208>>>            End
83208>>>>
83208>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
83209>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
83210>>>            Set ptsQueryExec to tsQuery
83211>>>            Set ptsFetchResults to tsFetch
83212>>>            Send SqlClose of hoStmt
83213>>>        End
83213>>>>
83213>>>
83213>>>        Send SqlDisconnect of hoSQLConnect
83214>>>    End_Procedure
83215>>>
83215>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
83215>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
83215>>>    // Returns False if no error occured.
83215>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
83217>>>        Boolean bOK bShowProgress
83217>>>        tSQLScriptArray SQLScriptArray
83217>>>        tSQLScriptArray SQLScriptArray
83217>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
83217>>>        TimeSpan tsTotalTime
83217>>>
83217>>>        Move (CurrentDateTime()) to dtTotalQueryStart
83218>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
83219>>>        If (SQLScriptArray.bError = True) Begin
83221>>>            Function_Return False
83222>>>        End
83222>>>>
83222>>>
83222>>>        If (num_arguments > 3) Begin
83224>>>            Move bShowProgr to bShowProgress
83225>>>        End
83225>>>>
83225>>>
83225>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
83226>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
83227>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
83228>>>
83228>>>        If (SQLScriptArray.bArgumentSizeChanged = True) Begin
83230>>>            Set_Argument_Size SQLScriptArray.iOrgArgumentSize
83231>>>>
83231>>>        End
83231>>>>
83231>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
83232>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
83233>>>        Set ptsTotalQueryTime to tsTotalTime
83234>>>
83234>>>        Function_Return bOK
83235>>>    End_Function
83236>>>
83236>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
83236>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
83236>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
83236>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
83238>>>        Integer iChannel iArgumentSize iCount
83238>>>        Number nByteCount
83238>>>        String sSQLScript
83238>>>        tSQLScriptArray SqlScriptArray
83238>>>        tSQLScriptArray SqlScriptArray
83238>>>        UChar[] uCharData
83239>>>
83239>>>        Move False to Err
83240>>>        Get Seq_New_Channel to iChannel
83241>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83243>>>            Error DFERR_PROGRAM 'No channel available...'
83244>>>>
83244>>>            Move True to SqlScriptArray.bError
83245>>>            Function_Return SqlScriptArray
83246>>>        End
83246>>>>
83246>>>
83246>>>        // First decide the size of the script
83246>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83248>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
83250>>>        Close_Input channel iChannel
83252>>>
83252>>>        Move (SizeOfArray(uCharData)) to nByteCount
83253>>>        If (nByteCount  < 1) Begin
83255>>>            Send Seq_Release_Channel iChannel
83256>>>            Move True to SqlScriptArray.bError
83257>>>            Function_Return SqlScriptArray
83258>>>        End
83258>>>>
83258>>>
83258>>>        // If necessary change the string argument_size
83258>>>        Get_Argument_Size to iArgumentSize
83259>>>        If (nByteCount >= iArgumentSize) Begin
83261>>>            Move (nByteCount + 2048) to nByteCount
83262>>>            Set_Argument_Size nByteCount // Set new argument size just a bit higher than "needed" for overhead margin.
83263>>>>
83263>>>            Move True          to SqlScriptArray.bArgumentSizeChanged
83264>>>            Move iArgumentSize to SqlScriptArray.iOrgArgumentSize
83265>>>        End
83265>>>>
83265>>>        Else Begin
83266>>>            Move False to SqlScriptArray.bArgumentSizeChanged
83267>>>        End
83267>>>>
83267>>>        // Read the script file from memory line-by-line
83267>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83269>>>            Move 0 to iCount
83270>>>            Repeat
83270>>>>
83270>>>                Readln channel iChannel sSQLScript
83272>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
83273>>>                Increment iCount
83274>>>            Until (SeqEof = True)
83276>>>        Close_Input channel iChannel
83278>>>        Send Seq_Release_Channel iChannel
83279>>>
83279>>>        // Finally "sanitize" the script by removing all comments.
83279>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
83280>>>
83280>>>        Function_Return SqlScriptArray
83281>>>    End_Function
83282>>>
83282>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
83284>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
83284>>>        Handle hoSql hoSQLConnect hoStmt hoError
83284>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
83284>>>        String[] sMsg aSQLQueryMessages
83286>>>        DateTime dtQueryExecStart dtQueryExecEnd
83286>>>        TimeSpan tsQuery
83286>>>        tSqlErrorArray aSqlErrorArray
83286>>>        tSqlErrorArray aSqlErrorArray
83286>>>        tSQLConnection SQLConnection
83286>>>        tSQLConnection SQLConnection
83286>>>        Boolean bMertechDriver bShowProgress
83286>>>
83286>>>        If (num_arguments > 4) Begin
83288>>>            Move bShowProgr to bShowProgress
83289>>>        End
83289>>>>
83289>>>        Get IsMertechDriver sDriverID to bMertechDriver
83290>>>        If (bMertechDriver = False) Begin
83292>>>            Get phoSQLManager to hoSql
83293>>>        End
83293>>>>
83293>>>        Else Begin
83294>>>            Get _MertechSQLManagerHandle to hoSql
83295>>>        End
83295>>>>
83295>>>
83295>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
83296>>>        // There seems to be a problem to pass strings when their value gets really big, aka
83296>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
83296>>>        // or later SqlExecDirect stops working correctly with no error messages!
83296>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
83296>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
83296>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
83296>>>        Get piChunkMax to iChunkMax
83297>>>        Move 0 to iChunkCounter
83298>>>        Move "" to sStmt
83299>>>
83299>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
83300>>>        Move (Character(13) + Character(10)) to sCR
83301>>>
83301>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83302>>>
83302>>>        If (bMertechDriver = True) Begin
83304>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
83305>>>        End
83305>>>>
83305>>>        If (bMertechDriver = False) Begin
83307>>>            Get phoSQLManager  to hoSQL
83308>>>            If (sDriverID = ODBC_DRV_ID) Begin
83310>>>                If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
83312>>>                    Move (Pos(";", SQLConnection.sConnectionString)) to iPos
83313>>>                    If (iPos > 0) Begin
83315>>>                        Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
83316>>>                        Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
83317>>>                    End
83317>>>>
83317>>>                End
83317>>>>
83317>>>            End
83317>>>>
83317>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
83318>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
83319>>>        End
83319>>>>
83319>>>
83319>>>        If (hoSQLConnect <> 0) Begin
83321>>>            Move False to Err
83322>>>            Get SqlOpen of hoSQLConnect to hoStmt
83323>>>            If (hoStmt <> 0) Begin
83325>>>
83325>>>                // If the embedded resource should be written as a script file to disk:
83325>>>                If (bCreateScriptFile = True) Begin
83327>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
83328>>>                    Get vFolderFormat sExportFile to sExportFile
83329>>>                    Move (sExportFile + sMemFileName) to sExportFile
83330>>>                    Get Seq_New_Channel to iOut
83331>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83333>>>                        Direct_Output channel iOut sExportFile
83335>>>                    End
83335>>>>
83335>>>                End
83335>>>>
83335>>>
83335>>>                // Record starting date/time stamp
83335>>>                Move (CurrentDateTime()) to dtQueryExecStart
83336>>>                // Turn on error handling if enabled
83336>>>                If (pbHandleQueryErrors(Self)) Begin
83338>>>                    Set pbSqlError to False
83339>>>                    Set paSqlErrorArray to aSqlErrorArray
83340>>>                    Move Error_Object_Id to hoError
83341>>>                    Move Self to Error_Object_Id
83342>>>                End
83342>>>>
83342>>>
83342>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
83343>>>                Decrement iRows
83344>>>                If (sDriverID = MSSQLDRV_ID) Begin
83346>>>                    Move (sNoCountKeyWord + sCR) to sStmt
83347>>>                End
83347>>>>
83347>>>
83347>>>                For iCount from 0 to iRows
83353>>>>
83353>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
83354>>>
83354>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
83356>>>                        If (sSQLVal <> "") Begin
83358>>>                            Move (sSQLVal + sCR) to sSQLVal
83359>>>                        End
83359>>>>
83359>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
83360>>>                    End
83360>>>>
83360>>>
83360>>>                    // - Each time we encounter a "GO" statement we execute it,
83360>>>                    // or if at the very end of the script.
83360>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
83362>>>
83362>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
83362>>>                        // instead of all in one go.
83362>>>                        Send SqlExecDirect of hoStmt sStmt
83363>>>
83363>>>                        If (bCreateScriptFile = True) Begin
83365>>>                            Write channel iOut sStmt
83367>>>                        End
83367>>>>
83367>>>                        Move "" to sStmt
83368>>>                        Move 0 to iChunkCounter
83369>>>                    End
83369>>>>
83369>>>                    Increment iChunkCounter
83370>>>                Loop
83371>>>>
83371>>>
83371>>>                // ToDo: This sometimes generates a GPF with Mertech drivers;
83371>>>                //       so not used for now.
83371>>>                If (bMertechDriver = False) Begin
83373>>>                    Repeat
83373>>>>
83373>>>                        If (pbHandleQueryErrors(Self)) Begin
83375>>>                            Move hoError to Error_Object_Id
83376>>>                        End
83376>>>>
83376>>>                        Move (CurrentDateTime()) to dtQueryExecEnd
83377>>>
83377>>>                        Send _SqlColumnInfo hoStmt
83378>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
83379>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83380>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
83381>>>                        Set piRows    to iRows
83382>>>                        Set piRowType to iRowType
83383>>>
83383>>>                        If (iMsgs <> 0) Begin
83385>>>                            If (ghoDbUpdateHandler > 0) Begin
83387>>>                                Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83388>>>                            End
83388>>>>
83388>>>                            For i from 1 to iMsgs
83394>>>>
83394>>>                                Get SqlGetMessage of hoStmt i to sMessage
83395>>>                                Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
83396>>>                                If (bShowProgress = True) Begin
83398>>>                                    If (Active_State(ghoStatusPanel)) Begin
83400>>>                                        Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83401>>>                                    End
83401>>>>
83401>>>                                    Else Begin
83402>>>                                        Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83404>>>                                    End
83404>>>>
83404>>>                                End
83404>>>>
83404>>>                                Move sMessage to sMsg[SizeOfArray(sMsg)]
83405>>>                                Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
83406>>>                            Loop
83407>>>>
83407>>>
83407>>>
83407>>>                            If (ghoDbUpdateHandler > 0) Begin
83409>>>                                Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83410>>>                            End
83410>>>>
83410>>>                            Set paQueryMessages to sMsg
83411>>>                        End
83411>>>>
83411>>>
83411>>>                        Get SQLNextResultSet of hoStmt to iNextSet
83412>>>                    Until (iNextSet = 0)
83414>>>                End
83414>>>>
83414>>>                Move (CurrentDateTime()) to dtQueryExecEnd
83415>>>            End
83415>>>>
83415>>>
83415>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
83416>>>            Set ptsQueryExec to tsQuery
83417>>>            Send SqlClose of hoStmt
83418>>>
83418>>>            If (bCreateScriptFile = True) Begin
83420>>>                Close_Output channel iOut
83422>>>                Send Seq_Release_Channel iOut
83423>>>            End
83423>>>>
83423>>>        End
83423>>>>
83423>>>        Send SqlDisconnect of hoSQLConnect
83424>>>
83424>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
83425>>>    End_Function
83426>>>
83426>>>    // * Dummy function for the Studio's Code Explorer *
83426>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
83428>>>        Function_Return False
83429>>>    End_Function
83430>>>
83430>>>    // Does three things with auxilirary files;
83430>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
83430>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
83430>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
83430>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
83432>>>        String sDataPath sDDSrcPath sDriverID
83432>>>        Boolean bOK bExists bMertechDriver
83432>>>        Integer iCount iCh iPos
83432>>>
83432>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
83432>>>        If (sTableName contains ".") Begin
83434>>>            Move (Pos(".", sTableName)) to iPos
83435>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
83436>>>        End
83436>>>>
83436>>>
83436>>>        Get psDriverID to sDriverID
83437>>>        Get psDataPathFirstPart to sDataPath
83438>>>        Get vFolderExists sDataPath to bOK
83439>>>        If (bOK = False) Begin
83441>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
83442>>>>
83442>>>            Function_Return False
83443>>>        End
83443>>>>
83443>>>
83443>>>        Get IsMertechDriver sDriverID to bMertechDriver
83444>>>        // First delete the cache file:
83444>>>        Get UtilDeleteCacheFile sTableName to bOK
83445>>>
83445>>>        Get Seq_New_Channel to iCh
83446>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83448>>>            Function_Return False
83449>>>        End
83449>>>>
83449>>>
83449>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
83450>>>        If (bExists = False) Begin
83452>>>            Function_Return False
83453>>>        End
83453>>>>
83453>>>
83453>>>        Get SqlUtilUpdateIntFile hTable to bOK
83454>>>        // Add the new column name to the .tag filen (if it doesn't exist):
83454>>>        Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
83455>>>
83455>>>        // If in development environment; output new .fd file:
83455>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
83456>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
83457>>>        If (iCount > 1) Begin
83459>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
83460>>>        End
83460>>>>
83460>>>        Get vFolderExists sDDSrcPath to bExists
83461>>>        If (bExists = True) Begin
83463>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
83464>>>            Move False to Err
83465>>>            Get AutoConnectionIDLogin to bOK
83466>>>            If (hTable <> 0) Begin
83468>>>                Open hTable
83470>>>            End
83470>>>>
83470>>>            Else Begin
83471>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
83472>>>            End
83472>>>>
83472>>>
83472>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
83475>>>            If (bOK = True) Begin
83477>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
83479>>>            End
83479>>>>
83479>>>            If (Err = True) Begin
83481>>>                Move False to bOK
83482>>>            End
83482>>>>
83482>>>        End
83482>>>>
83482>>>
83482>>>        Function_Return (bOK = True)
83483>>>    End_Function
83484>>>
83484>>>    Function UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
83486>>>        Integer iChIn iChOut // iCount
83486>>>        Boolean bExists
83486>>>        String sExistingColumn
83486>>>
83486>>>        Move False to bExists
83487>>>        Get Seq_New_Channel to iChIn
83488>>>        Get Seq_New_Channel to iChOut
83489>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83491>>>            Function_Return True
83492>>>        End
83492>>>>
83492>>>
83492>>>        Move False to Err
83493>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
83493>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
83495>>>        While (not(SeqEof))
83499>>>            Readln channel iChIn sExistingColumn
83501>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
83503>>>                Move True to bExists
83504>>>            End
83504>>>>
83504>>>            If (Trim(sExistingColumn) = "") Begin
83506>>>                Move True to SeqEof
83507>>>            End
83507>>>>
83507>>>        Loop
83508>>>>
83508>>>        Close_Input channel iChIn
83510>>>        Send Seq_Release_Channel iChIn
83511>>>
83511>>>        If (bExists = False) Begin
83513>>>            Append_Output channel iChOut sFullTAGFileName
83515>>>            Writeln channel iChOut sColumnName
83518>>>            Close_Output channel iChOut
83520>>>            Send Seq_Release_Channel iChOut
83521>>>        End
83521>>>>
83521>>>
83521>>>        Function_Return (Err = False)
83522>>>    End_Function
83523>>>
83523>>>    // Message for changing .int files to use connection ID's
83523>>>    //
83523>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
83523>>>    // OR changes an existing connection id to a new id.
83523>>>    // Pass the full path to the data folder and the name of the connection id (string value).
83523>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
83523>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
83525>>>        String sFileName sDriverID sDriverFile sConnectionString
83525>>>        String[] sFilesData
83526>>>        Boolean bOK bCancel
83526>>>        Integer iSize iCount
83526>>>
83526>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
83527>>>        Move (SizeOfArray(sFilesData))    to iSize
83528>>>        If (iSize = 0) Begin
83530>>>            If (ghoStatusPanel <> 0) Begin
83532>>>                If (Active_State(ghoStatusPanel)) Begin
83534>>>                    Send Stop_StatusPanel of ghoStatusPanel
83535>>>                End
83535>>>>
83535>>>            End
83535>>>>
83535>>>            Send Info_Box CS_DUF_NoIntFilesFound
83536>>>            Procedure_Return
83537>>>        End
83537>>>>
83537>>>
83537>>>        Move (Trim(sConnectionID)) to sConnectionID
83538>>>        Get vFolderFormat sDataPath to sDataPath
83539>>>        Decrement iSize
83540>>>        For iCount from 0 to iSize
83546>>>>
83546>>>            Move sFilesData[iCount] to sFileName
83547>>>            // This makes sure that we also can change an existing connection id to something new:
83547>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
83548>>>            If (ghoStatusPanel <> 0) Begin
83550>>>                If (Active_State(ghoStatusPanel)) Begin
83552>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
83553>>>                    If (bCancel = True) Begin
83555>>>                        Send Deactivate of ghoStatusPanel
83556>>>                        Procedure_Return
83557>>>                    End
83557>>>>
83557>>>                End
83557>>>>
83557>>>            End
83557>>>>
83557>>>        Loop
83558>>>>
83558>>>
83558>>>        Get psDriverID to sDriverID
83559>>>
83559>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
83559>>>        Move "" to sFileName
83560>>>        If (sDriverID = MSSQLDRV_ID) Begin
83562>>>            Move "MSSQLDrv.int" to sFileName
83563>>>        End
83563>>>>
83563>>>        If (sDriverID = DB2_DRV_ID) Begin
83565>>>            Move "DB2_Drv.int" to sFileName
83566>>>        End
83566>>>>
83566>>>        If (sDriverID = ODBC_DRV_ID) Begin
83568>>>            Move "ODBC_Drv.int" to sFileName
83569>>>        End
83569>>>>
83569>>>        If (sFileName <> "") Begin
83571>>>            Move "" to sDriverFile
83572>>>            Get_File_Path sFileName to sDriverFile
83573>>>            If (sDriverFile <> "") Begin
83575>>>                Get psConnectionString to sConnectionString
83576>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
83577>>>            End
83577>>>>
83577>>>        End
83577>>>>
83577>>>    End_Procedure
83578>>>
83578>>>    // Checks if the database exists in SQL. Returns = True if it does.
83578>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
83580>>>        String[] sDatabaseArray
83581>>>        String sVal sServer sDriverID
83581>>>        Integer iCount iSize iPos
83581>>>        Boolean bExists
83581>>>        tSQLConnection SQLConnection
83581>>>        tSQLConnection SQLConnection
83581>>>
83581>>>        Move False to bExists
83582>>>        Get psDriverID to sDriverID
83583>>>        // DB2 doesn't have a "Database" name, so we always return True.
83583>>>        If (sDriverID = DB2_DRV_ID) Begin
83585>>>            Function_Return bExists
83586>>>        End
83586>>>>
83586>>>
83586>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
83587>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
83589>>>            Function_Return False
83590>>>        End
83590>>>>
83590>>>
83590>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83591>>>        Move SQLConnection.sServer to sServer
83592>>>
83592>>>        // Special code to handle a FILEDSN that also can contain "/"
83592>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
83594>>>            Move sDatabaseArray[0] to sVal  // Dummy!
83595>>>        End
83595>>>>
83595>>>        Else If (sServer contains "/") Begin
83598>>>            Move (Pos("/", sServer)) to iPos
83599>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
83600>>>        End
83600>>>>
83600>>>
83600>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
83601>>>        Decrement iSize
83602>>>        For iCount from 0 to iSize
83608>>>>
83608>>>            Move sDatabaseArray[iCount] to sVal
83609>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
83611>>>                Move True to bExists
83612>>>                If (bExists = True) Begin
83614>>>                    Move iSize to iCount // We're done.
83615>>>                End
83615>>>>
83615>>>            End
83615>>>>
83615>>>        Loop
83616>>>>
83616>>>
83616>>>        Function_Return bExists
83617>>>    End_Function
83618>>>
83618>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
83618>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
83620>>>        String sDatabase sSchema sTableName sVal
83620>>>        Boolean bExists
83620>>>        String[] sTablesArray
83621>>>        Integer iSize iCount
83621>>>
83621>>>        Move False to bExists
83622>>>        Get UtilTableHandleToString hTable to sTableName
83623>>>        Get psDatabase to sDatabase
83624>>>        Get psSchema   to sSchema
83625>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
83626>>>        Move (SizeOfArray(sTablesArray)) to iSize
83627>>>        Decrement iSize
83628>>>        For iCount from 0 to iSize
83634>>>>
83634>>>            Move sTablesArray[iCount] to sVal
83635>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
83637>>>                Move True to bExists
83638>>>                Move iSize to iCount // We're done!
83639>>>            End
83639>>>>
83639>>>        Loop
83640>>>>
83640>>>
83640>>>        Function_Return bExists
83641>>>    End_Function
83642>>>
83642>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
83642>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
83644>>>        String sDatabase sSchema sVal
83644>>>        Boolean bExists
83644>>>        String[] sTablesArray
83645>>>        Integer iSize iCount
83645>>>
83645>>>        Move False to bExists
83646>>>        Get psDatabase to sDatabase
83647>>>        Get psSchema   to sSchema
83648>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
83649>>>        Move (SizeOfArray(sTablesArray)) to iSize
83650>>>        Decrement iSize
83651>>>        For iCount from 0 to iSize
83657>>>>
83657>>>            Move sTablesArray[iCount] to sVal
83658>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
83660>>>                Move True to bExists
83661>>>                Move iSize to iCount // We're done!
83662>>>            End
83662>>>>
83662>>>        Loop
83663>>>>
83663>>>
83663>>>        Function_Return bExists
83664>>>    End_Function
83665>>>
83665>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
83667>>>        String sVal sTableSpelledCorrectly
83667>>>        Boolean bExists
83667>>>        String[] sTablesArray
83668>>>        Integer iSize iCount
83668>>>
83668>>>        Move False to bExists
83669>>>        Move sTableName to sTableSpelledCorrectly
83670>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
83671>>>        Move (SizeOfArray(sTablesArray)) to iSize
83672>>>        Decrement iSize
83673>>>        For iCount from 0 to iSize
83679>>>>
83679>>>            Move sTablesArray[iCount] to sVal
83680>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
83682>>>                Move sVal to sTableSpelledCorrectly
83683>>>                Move iSize to iCount // We're done!
83684>>>            End
83684>>>>
83684>>>        Loop
83685>>>>
83685>>>
83685>>>        Function_Return sTableSpelledCorrectly
83686>>>    End_Function
83687>>>
83687>>>    // ToDo: This index name function needs to be finished...
83687>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
83689>>>        String sSchema sTableName sDriverID
83689>>>        Boolean bExists
83689>>>
83689>>>        Get psDriverID to sDriverID
83690>>>        Get psSchema to sSchema
83691>>>        Get UtilTableHandleToString hTable to sTableName
83692>>>
83692>>>        Function_Return bExists
83693>>>    End_Function
83694>>>
83694>>>    // Checks if a column/field name exists in a SQL table definition
83694>>>    // Returns True if it does
83694>>>    // Sample:
83694>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
83694>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
83696>>>        Integer iNumColumns iColumn
83696>>>        String sColumn sDriverID
83696>>>        String[] sColumnsArray
83697>>>        Boolean bExists bOK
83697>>>
83697>>>        Move False to bExists
83698>>>        Get AutoConnectionIDLogin to bOK
83699>>>        Get psDriverID to sDriverID
83700>>>
83700>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
83701>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
83702>>>        Decrement iNumColumns
83703>>>        For iColumn from 0 to iNumColumns
83709>>>>
83709>>>            Move sColumnsArray[iColumn] to sColumn
83710>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
83712>>>                Move True to bExists
83713>>>                Move iNumColumns to iColumn // We're out of here
83714>>>            End
83714>>>>
83714>>>        Loop
83715>>>>
83715>>>
83715>>>        Function_Return bExists
83716>>>    End_Function
83717>>>
83717>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
83719>>>        Integer iNumColumns iColumn iDFType iNativeType
83719>>>        Boolean bOpened bOK
83719>>>        String sColumnName sNativeTypeName
83719>>>
83719>>>        Get AutoConnectionIDLogin to bOK
83720>>>        Get OpenTableExclusive hTable to bOK
83721>>>        If (bOK = False) Begin
83723>>>            Function_Return False
83724>>>        End
83724>>>>
83724>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
83727>>>        If (bOpened = False) Begin
83729>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
83730>>>>
83730>>>            Function_Return False
83731>>>        End
83731>>>>
83731>>>
83731>>>        Move False to Err
83732>>>
83732>>>        Structure_Start hTable
83733>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
83736>>>
83736>>>            For iColumn from 1 to iNumColumns
83742>>>>
83742>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
83745>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
83748>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
83751>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
83754>>>
83754>>>                Case Begin
83754>>>                    Case (iDFType = DF_DATE)
83756>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
83758>>>                            // Convert datetime to date
83758>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
83761>>>                        End
83761>>>>
83761>>>                        Case Break
83762>>>                    Case (iDFType = DF_DATETIME)
83765>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
83767>>>                            // Convert datetime to datetime2
83767>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
83770>>>                        End
83770>>>>
83770>>>                        Case Break
83771>>>                    Case (iDFType = DF_ASCII)
83774>>>                        If (iNativeType = SQL_CHAR) Begin
83776>>>                            // Convert char to varchar
83776>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
83779>>>                        End
83779>>>>
83779>>>                        Case Break
83780>>>                    Case (iDFType = DF_TEXT)
83783>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
83785>>>                            // Convert text to varchar(max)
83785>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
83788>>>                        End
83788>>>>
83788>>>                        Case Break
83789>>>                    Case (iDFType = DF_BINARY)
83792>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
83794>>>                            // Convert image to varbinary(max)
83794>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
83797>>>                        End
83797>>>>
83797>>>                        Case Break
83798>>>                Case End
83798>>>            Loop
83799>>>>
83799>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
83800>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83802>>>
83802>>>        Set Action_Text of ghoStatusPanel to ""
83803>>>        Function_Return (Err = False)
83804>>>    End_Function
83805>>>
83805>>>
83805>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
83805>>>    // the DbUpdateVersion database revision in.
83805>>>    // Also pass the file number of the current (embedded?) table number used in development.
83805>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
83805>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
83807>>>        Boolean bOK bOpened
83807>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
83807>>>
83807>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
83810>>>        Get _TableNameOnly sTableName to sTableName
83811>>>        If (sTableName = "") Begin
83813>>>            Function_Return False
83814>>>        End
83814>>>>
83814>>>
83814>>>        // This just creates the table and a "dummy" column.
83814>>>        Get SqlTableCreate hTable sDriverID to bOK
83815>>>        If (bOK = False) Begin
83817>>>            Function_Return False
83818>>>        End
83818>>>>
83818>>>
83818>>>        Close hTable
83819>>>        Move False to Err
83820>>>
83820>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
83821>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
83822>>>        Move "Decimal" to sDataType
83823>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
83824>>>
83824>>>        // Adds the "sColumnName" passed to the function
83824>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
83825>>>        Send SqlUtilExecuteQuery sStmt sDriverID
83826>>>
83826>>>        // Now we can delete the dummy column:
83826>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
83827>>>
83827>>>        // Finally, we attach to the newly created table.
83827>>>        If (Err = False) Begin
83829>>>            Get ApiTableAttachToSQL hTable True to bOK
83830>>>        End
83830>>>>
83830>>>        Open hTable
83832>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
83835>>>
83835>>>        Function_Return (Err = False and bOK = True and bOpened = True)
83836>>>    End_Function
83837>>>
83837>>>    // The table must already exist in the filelist for this function to work.
83837>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
83837>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
83839>>>        Boolean bOK bExists bUseConnectionID bMertech
83839>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
83839>>>        String[] sIndexArray
83840>>>        Integer iCount iCh iSize
83840>>>
83840>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
83841>>>        Get psConnectionString to sConnectionString
83842>>>
83842>>>        Move CS_ANSI_Txt to sANSI_OEM
83843>>>        If (bANSI = False) Begin
83845>>>            Move CS_OEM_Txt to sANSI_OEM
83846>>>        End
83846>>>>
83846>>>
83846>>>        Get psDataPathFirstPart to sDataPath
83847>>>        Get vFolderExists sDataPath to bOK
83848>>>        If (bOK = False) Begin
83850>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
83851>>>>
83851>>>            Function_Return False
83852>>>        End
83852>>>>
83852>>>        Get vFolderFormat sDataPath to sDataPath
83853>>>
83853>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
83856>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
83859>>>        Get _TableNameOnly sRootName to sDatabaseName
83860>>>        Move sLogicalName  to sPhysicalFileName
83861>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
83862>>>
83862>>>        Get IsMertechDriver sDriverID to bMertech
83863>>>        If (bMertech = True) Begin
83865>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
83865>>>            // Else it will create an error in the error log (although it won't do anything...)
83865>>>            // Get _MertechSqlUtilCreateIntFile hTable sLogicalName sDataPath sPhysicalFileName to bOK
83865>>>            Function_Return (bOK = True)
83866>>>        End
83866>>>>
83866>>>
83866>>>        Get psSchema hTable to sSchemaName
83867>>>        If (sSchemaName = "") Begin
83869>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
83870>>>        End
83870>>>>
83870>>>
83870>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
83870>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
83871>>>        If (bExists = True) Begin
83873>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
83874>>>        End
83874>>>>
83874>>>
83874>>>        Get UtilDeleteCacheFile sRootName to bOK
83875>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
83876>>>
83876>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
83877>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
83882>>>            If (bUseConnectionID = True) Begin
83884>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
83891>>>            End
83891>>>>
83891>>>            Else Begin
83892>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
83899>>>            End
83899>>>>
83899>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
83904>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
83909>>>            // There seems to be a new order how these are set from DF19.
83909>>>            If (bSysFile = True) Begin
83911>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
83916>>>            End
83916>>>>
83916>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
83921>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
83926>>>            If (bSysFile = True) Begin
83928>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
83933>>>            End
83933>>>>
83933>>>
83933>>>            If (bSysFile = False) Begin
83935>>>                Move (SizeOfArray(sIndexArray)) to iSize
83936>>>                Move (SortArray(sIndexArray)) to sIndexArray
83937>>>                If (iSize > 0) Begin
83939>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
83942>>>                    Writeln channel iCh // Just an empty line
83944>>>                End
83944>>>>
83944>>>                Decrement iSize
83945>>>                For iCount from 0 to iSize
83951>>>>
83951>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
83954>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
83957>>>                    Writeln channel iCh
83959>>>                Loop
83960>>>>
83960>>>            End
83960>>>>
83960>>>        Send Seq_Close_Channel iCh
83961>>>
83961>>>        // Wait a sec for Windows to finish writing the file:
83961>>>        Sleep 1
83962>>>
83962>>>        Function_Return (bOK = True)
83963>>>    End_Function
83964>>>
83964>>>    // Returns a handle to the SQL server associated with the passed driver ID.
83964>>>    // Pass e.g. the psServer property to determine the current connection server.
83964>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
83964>>>    // This handle can be used to obtain attributes about the server, such as default
83964>>>    // column types.
83964>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
83966>>>        Handle hDatabase
83966>>>        Integer iDriver iServers iCount
83966>>>        String sValue
83966>>>
83966>>>        If (sServer = "") Begin
83968>>>            Function_Return 0
83969>>>        End
83969>>>>
83969>>>
83969>>>        Get DriverIndex sDriverID to iDriver
83970>>>        If (iDriver = 0) Begin
83972>>>            Function_Return 0
83973>>>        End
83973>>>>
83973>>>
83973>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
83976>>>        For iCount from 1 to iServers
83982>>>>
83982>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
83985>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
83987>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
83990>>>            End
83990>>>>
83990>>>        Loop
83991>>>>
83991>>>
83991>>>        Function_Return hDatabase
83992>>>    End_Function
83993>>>
83993>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
83993>>>//        String sRootName
83993>>>//        Boolean bOK
83993>>>//
83993>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
83993>>>//        Move (sRootName contains sDriverID) to bOK
83993>>>//
83993>>>//        Function_Return bOK
83993>>>//    End_Function
83993>>>
83993>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
83993>>>//        String sDriverID sRootName sDisplayName sSchema sVal
83993>>>//        Integer iDbType
83993>>>//        Boolean bOK
83993>>>//
83993>>>//        Get UtilIsFilelistEntryDriverBased to bOK
83993>>>//        If (bOK = True) Begin
83993>>>//            Function_Return False
83993>>>//        End
83993>>>//
83993>>>//        Get psDriverID to sDriverID
83993>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
83993>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
83993>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
83993>>>//
83993>>>//        Get psDriverID to sDriverID
83993>>>//        Get piDbType   to iDbType
83993>>>//        Get psSchema   to sSchema
83993>>>//        If (sSchema = "") Begin
83993>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
83993>>>//        End
83993>>>//
83993>>>//        Move (Uppercase(sDisplayName)) to sVal
83993>>>//        If (not(sVal contains (sSchema + "."))) Begin
83993>>>//            If (iDbType = EN_dbTypeDB2) Begin
83993>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
83993>>>//            End
83993>>>//            Else Begin
83993>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
83993>>>//            End
83993>>>//        End
83993>>>//
83993>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
83993>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
83993>>>//
83993>>>//        Function_Return True
83993>>>//    End_Function
83993>>>
83993>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
83993>>>    // from the passed filelist.
83993>>>    // Returns the number of tables affected.
83993>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
83995>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
83995>>>        Integer iRetval
83995>>>        Handle hTable
83995>>>
83995>>>        // We first save the current filelist as the passed filelist name
83995>>>        // may come from another workspace, to restore it when we're ready.
83995>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
83998>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
84001>>>        Move 0 to hTable
84002>>>        Move 0 to iRetval
84003>>>
84003>>>        Repeat
84003>>>>
84003>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
84006>>>            If (hTable <> 0) Begin
84008>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84011>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84014>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
84017>>>                Move (Uppercase(sRootName)) to sVal
84018>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
84020>>>                    // Prefixes:
84020>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
84021>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
84022>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
84023>>>                    // Suffixes:
84023>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
84024>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
84025>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
84026>>>
84026>>>                    // Change Filelist entry:
84026>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
84029>>>
84029>>>                    Move (Lowercase(sDisplayName)) to sVal
84030>>>                    If (sVal contains "dbo.") Begin
84032>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
84033>>>
84033>>>                        // Change Filelist entry:
84033>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
84036>>>                    End
84036>>>>
84036>>>                    Increment iRetval
84037>>>                End
84037>>>>
84037>>>            End
84037>>>>
84037>>>        Until (hTable = 0)
84039>>>
84039>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
84042>>>
84042>>>        Function_Return iRetval
84043>>>    End_Function
84044>>>
84044>>>    // To open all Sql based tables in Filelist.cfg
84044>>>    Procedure SqlUtilOpenAllTables
84046>>>        Handle hTable
84046>>>        String sRoot sDriverID
84046>>>        Boolean bOK
84046>>>
84046>>>        Move 0 to hTable
84047>>>        Move "" to sDriverID
84048>>>        Get AutoConnectionIDLogin to bOK
84049>>>
84049>>>        Repeat
84049>>>>
84049>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
84052>>>            If (hTable > 0) Begin
84054>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
84057>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
84059>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
84062>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
84064>>>                        Open hTable
84066>>>                    End
84066>>>>
84066>>>                End
84066>>>>
84066>>>            End
84066>>>>
84066>>>
84066>>>        Until (hTable = 0)
84068>>>    End_Procedure
84069>>>
84069>>>//    Function SqlUtilSchemaName Handle hTable Returns String
84069>>>//        String sRetval sDriverID
84069>>>//        String sTableName
84069>>>//        Integer iDbType iIndex
84069>>>//        Boolean bOK
84069>>>//
84069>>>//        Get psDriverID to sDriverID
84069>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
84069>>>//        If (hTable = 0 or bOK = False) Begin
84069>>>//            Function_Return ""
84069>>>//        End
84069>>>//
84069>>>//        Move False to Err
84069>>>//        Get UtilTableHandleToString hTable to sTableName
84069>>>//        Get piDbType to iDbType
84069>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
84069>>>//        If (iIndex = -1) Begin
84069>>>//            Function_Return ""
84069>>>//        End
84069>>>//
84069>>>//        Function_Return sRetval
84069>>>//    End_Function
84069>>>
84069>>>    // Checks if the passed Table;
84069>>>    // 1) Already has a Filelist entry that points to SQL and
84069>>>    // 2) It has an .int file.
84069>>>    // If both is True it should already be connected to SQL
84069>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
84071>>>        Boolean bExists bRootName
84071>>>        String sRootName sDataPath
84071>>>
84071>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84074>>>        Move (sRootName contains sDriverID) to bRootName
84075>>>
84075>>>        Get psDataPathFirstPart to sDataPath
84076>>>        Get vFolderExists sDataPath to bExists
84077>>>        If (bExists = False) Begin
84079>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
84079>>>            Function_Return False
84080>>>        End
84080>>>>
84080>>>
84080>>>        Get vFolderFormat sDataPath to sDataPath
84081>>>        Get _TableNameOnly sRootName to sRootName
84082>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
84083>>>
84083>>>        Function_Return (bRootName = True and bExists = True)
84084>>>    End_Function
84085>>>
84085>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
84087>>>        Boolean bViewTableType bOpen bOK
84087>>>        Integer iTableCount iNumTables
84087>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
84087>>>        Handle hoCliHandler
84087>>>        tSQLConnection SQLConnection
84087>>>        tSQLConnection SQLConnection
84087>>>
84087>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
84090>>>        If (bOpen = False) Begin
84092>>>            Get AutoConnectionIDLogin to bOK
84093>>>            Open hTable
84095>>>        End
84095>>>>
84095>>>
84095>>>        Get pSQLConnection to SQLConnection
84096>>>        Get phoCLIHandler to hoCliHandler
84097>>>        Set psDriverID of hoCliHandler to sDriverID
84098>>>
84098>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
84101>>>        Get _TableNameOnly sTableName to sTableName
84102>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
84105>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
84106>>>
84106>>>        For iTableCount from 1 to iNumTables
84112>>>>
84112>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
84113>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
84114>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
84116>>>                Get TableType of hoCliHandler iTableCount to sTableType
84117>>>                Move iNumTables to iTableCount // We're done.
84118>>>            End
84118>>>>
84118>>>        Loop
84119>>>>
84119>>>
84119>>>        Move (sTableType = "VIEW") to bViewTableType
84120>>>        If (bOpen = False) Begin
84122>>>            Close hTable
84123>>>        End
84123>>>>
84123>>>
84123>>>        Function_Return bViewTableType
84124>>>    End_Function
84125>>>
84125>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
84125>>>    //
84125>>>    // SQL utility function that returns a database type (string) constant
84125>>>    // corresponding to the passed iDbType.
84125>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
84127>>>        String sRetval
84127>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
84128>>>        Function_Return sRetval
84129>>>    End_Function
84130>>>
84130>>>    // SQL utility function that returns a database type constant (integer)
84130>>>    // corresponding to the passed sDbType string constant.
84130>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
84132>>>        Integer iRetval
84132>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
84133>>>        Function_Return iRetval
84134>>>    End_Function
84135>>>
84135>>>    // Pass an integer DbType and function returns the database type integer as a string value.
84135>>>    // Used e.g. when reading a connection ini-file to display the database type in
84135>>>    // the SQL Connection program's grid.
84135>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
84137>>>        String sRetval
84137>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
84138>>>        Function_Return sRetval
84139>>>    End_Function
84140>>>
84140>>>    // Pass a driver name as a string and the function will return
84140>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
84140>>>    // quite work and always returns "MS SQL Server"
84140>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
84142>>>        Integer iRetval
84142>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
84143>>>        Function_Return iRetval
84144>>>    End_Function
84145>>>
84145>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
84145>>>    // that "fits" in the max allowed length for table names.
84145>>>    // Max number of characters allowed for table names;
84145>>>    // IBM DB2      = 128
84145>>>    // MS-SQL       = 128
84145>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
84145>>>    // MySQL        = 64
84145>>>    // PostgreSQL   = 64
84145>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
84147>>>        String sGUIDName
84147>>>        Integer iDbType iLength
84147>>>
84147>>>        Get piDbType to iDbType
84148>>>        Move (RandomHexUUID()) to sGUIDName
84149>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
84150>>>        Move (Length(sGUIDName)) to iLength
84151>>>
84151>>>        Case Begin
84151>>>            Case (iDbType = EN_DbTypeDB2)
84153>>>            If (iLength > 128) Begin
84155>>>                Move (Left(sGUIDName, 128)) to sGUIDName
84156>>>            End
84156>>>>
84156>>>            Case Break
84157>>>
84157>>>            Case (iDbType = EN_DbTypeMSSQL)
84160>>>            If (iLength > 128) Begin
84162>>>                Move (Left(sGUIDName, 128)) to sGUIDName
84163>>>            End
84163>>>>
84163>>>            Case Break
84164>>>
84164>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
84167>>>            If (iLength > 128) Begin
84169>>>                Move (Left(sGUIDName, 128)) to sGUIDName
84170>>>            End
84170>>>>
84170>>>            Case Break
84171>>>
84171>>>            Case (iDbType = EN_DbTypeMySQL)
84174>>>            If (iLength > 64) Begin
84176>>>                Move (Left(sGUIDName, 64)) to sGUIDName
84177>>>            End
84177>>>>
84177>>>            Case Break
84178>>>
84178>>>            Case (iDbType = EN_DbTypePostgre)
84181>>>            If (iLength > 64) Begin
84183>>>                Move (Left(sGUIDName, 64)) to sGUIDName
84184>>>            End
84184>>>>
84184>>>        Case End
84184>>>
84184>>>        Function_Return sGUIDName
84185>>>    End_Function
84186>>>
84186>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
84186>>>    // Pass the memory resource file reference and the filename to be created,
84186>>>    // including full path.
84186>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
84188>>>        String sText
84188>>>        Integer iCh iSize iArgSize
84188>>>
84188>>>        Move ("Resource:" + sMemFileName) to sMemFileName
84189>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
84190>>>        Get_Channel_Size iCh to iSize
84191>>>        Get_Argument_Size to iArgSize
84192>>>        If (iSize > iArgSize) Begin
84194>>>            Set_Argument_Size iSize
84195>>>>
84195>>>        End
84195>>>>
84195>>>        Read_Block channel iCh sText iSize
84197>>>        Send Seq_Close_Channel iCh
84198>>>
84198>>>        Get Seq_Open_Output_Channel sFileName to iCh
84199>>>            Write channel iCh sText
84201>>>        Send Seq_Close_Channel iCh
84202>>>
84202>>>        If (iSize <> iArgSize) Begin
84204>>>            Set_Argument_Size iArgSize
84205>>>>
84205>>>        End
84205>>>>
84205>>>        // Wait for file to be written to disk.
84205>>>        Sleep 2
84206>>>    End_Procedure
84207>>>
84207>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
84209>>>        String sNotNull sRetval sDefaultValue
84209>>>        Boolean bOK
84209>>>
84209>>>        Get IsSQLDriver sDriverID to bOK
84210>>>        If (bOK = False) Begin
84212>>>            Function_Return ""
84213>>>        End
84213>>>>
84213>>>
84213>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
84214>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
84215>>>
84215>>>        Case Begin
84215>>>            Case (iDbType = EN_dbTypeMSSQL)
84217>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
84218>>>                Case Break
84219>>>            Case (iDbType = EN_dbTypeMySQL)
84222>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
84223>>>                Case Break
84224>>>            Case (iDbType = EN_dbTypePostgre)
84227>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
84228>>>                Case Break
84229>>>            Case (iDbType = EN_dbTypeDB2)
84232>>>                Move (String(sNotNull))                                     to sRetval
84233>>>                Case Break
84234>>>
84234>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
84234>>>            // ToDo: We need to look deeper into how Oracle handles NULL
84234>>>            Case (iDbType = EN_dbTypeOracle)
84237>>>                Move  ""                                                    to sRetval
84238>>>                Case Break
84239>>>
84239>>>            Case Else
84239>>>                Move  ""                                                    to sRetval
84240>>>        Case End
84240>>>
84240>>>        Function_Return sRetval
84241>>>    End_Function
84242>>>
84242>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
84244>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
84244>>>        Boolean bOpened bOK bMertech
84244>>>
84244>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
84244>>>        // which makes the program unable to run because they can't be opened.
84244>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
84244>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
84244>>>        // proper .int files for the two tables.
84244>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
84246>>>            Function_Return True
84247>>>        End
84247>>>>
84247>>>
84247>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84250>>>        Get _TableNameOnly sRootName to sDatabaseName
84251>>>        Move CS_OEM_Txt  to sOrgFormat
84252>>>        Move CS_ANSI_Txt to sNewFormat
84253>>>        Get AutoConnectionIDLogin to bOK
84254>>>
84254>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
84254>>>        Sleep 1
84255>>>
84255>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84258>>>        If (bOpened = False) Begin
84260>>>            Open hTable
84262>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
84265>>>        End
84265>>>>
84265>>>        If (bOpened = False) Begin
84267>>>            Function_Return False
84268>>>        End
84268>>>>
84268>>>
84268>>>        Get psDriverID to sDriverID
84269>>>        Get IsMertechDriver sDriverID to bMertech
84270>>>        If (bMertech = True) Begin
84272>>>            Get psDataPathFirstPart to sDataPath
84273>>>            Get vFolderExists sDataPath to bOK
84274>>>            If (bOK = False) Begin
84276>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
84277>>>>
84277>>>                Function_Return False
84278>>>            End
84278>>>>
84278>>>            Get vFolderFormat sDataPath to sDataPath
84279>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84282>>>            Get _TableNameOnly sRootName to sDatabaseName
84283>>>            Move sDatabaseName to sPhysicalFileName
84284>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
84285>>>            Get _MertechSqlUtilCreateIntFile hTable sDatabaseName sDataPath sPhysicalFileName to bOK
84286>>>            Function_Return (bOK = True)
84287>>>        End
84287>>>>
84287>>>
84287>>>        Move False to Err
84288>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
84291>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
84292>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
84292>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
84292>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
84293>>>
84293>>>        Move False to Err
84294>>>
84294>>>        If (hTable > 0) Begin
84296>>>            Structure_Start hTable
84297>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
84300>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
84303>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84305>>>        End
84305>>>>
84305>>>        Else Begin
84306>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
84309>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
84312>>>        End
84312>>>>
84312>>>        Function_Return (Err = False)
84313>>>    End_Function
84314>>>
84314>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
84316>>>        String[] sReturnArray
84317>>>        String sValue // sUserID sPassword
84317>>>        Handle hoSQLHandler hoSQLConnect hStmt
84317>>>        Integer iFetchResult iRetval
84317>>>        tSQLConnection SQLConnection
84317>>>        tSQLConnection SQLConnection
84317>>>
84317>>>        Get _MertechSQLManagerHandle to hoSQLHandler
84318>>>        If (hoSQLHandler <> 0) Begin
84320>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84321>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
84322>>>            If (hoSQLConnect <> 0) Begin
84324>>>                Get SQLOpen of hoSQLConnect to hStmt
84325>>>                If (hStmt <> 0) Begin
84327>>>                    Send SQLSetProcedureName of hStmt sStmt
84328>>>                    If (sArgument <> "") Begin
84330>>>                        Send SqlSetArgument  of hStmt 1 sArgument
84331>>>                    End
84331>>>>
84331>>>                    Send SQLCall of hStmt
84332>>>
84332>>>                    Get SqlReturnValue       of hStmt to iRetval
84333>>>                    If (iRetval = 0) Begin
84335>>>                        Repeat
84335>>>>
84335>>>                            Get SQLFetch of hStmt to iFetchResult
84336>>>                            If (iFetchResult <> 0) Begin
84338>>>                                Get SQLColumnValue of hStmt 1 to sValue
84339>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
84340>>>                            End
84340>>>>
84340>>>                        Until (iFetchResult = 0)
84342>>>                        Send SQLClose of hStmt
84343>>>                    End
84343>>>>
84343>>>                End
84343>>>>
84343>>>                Send SQLDisconnect of hoSQLConnect
84344>>>            End
84344>>>>
84344>>>        End
84344>>>>
84344>>>
84344>>>        Function_Return sReturnArray
84345>>>    End_Function
84346>>>
84346>>>    // * Dummy function for the Studio's Code Explorer *
84346>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
84348>>>        Function_Return False
84349>>>    End_Function
84350>>>
84350>>>    // Enumerate SQL Servers.
84350>>>    // Pass a driver id. Returns a string array.
84350>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
84350>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
84350>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
84352>>>        String[] sReturnArray
84353>>>        Handle hoSQLHandler
84353>>>        String sServer
84353>>>        Integer iCount iNumItems iDataSourceType
84353>>>
84353>>>        If (num_arguments > 1) Begin
84355>>>            Move iDatSrcType to iDataSourceType
84356>>>        End
84356>>>>
84356>>>
84356>>>        Case Begin
84356>>>            Case (sDriverID = MSSQLDRV_ID)
84358>>>                Get phoMSSQLHandler to hoSQLHandler
84359>>>                Get EnumerateServers of hoSQLHandler to iNumItems
84360>>>                For iCount from 0 to (iNumItems - 1)
84366>>>>
84366>>>                    Get String_Value of hoSQLHandler iCount to sServer
84367>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
84368>>>                Loop
84369>>>>
84369>>>                Case Break
84370>>>
84370>>>            Case (sDriverID = DB2_DRV_ID)
84373>>>                Get phoDB2SQLHandler to hoSQLHandler
84374>>>                Send SeedDataSources of hoSQLHandler
84375>>>                Move 0 to iCount
84376>>>                Repeat
84376>>>>
84376>>>                    Get DataSources of hoSQLHandler to sServer
84377>>>                    If (sServer <> "") Begin
84379>>>                        Move (Replace(",", sServer, "")) to sServer
84380>>>                        Move sServer to sReturnArray[iCount]
84381>>>                    End
84381>>>>
84381>>>                    Increment iCount
84382>>>                Until (sServer = "")
84384>>>                Case Break
84385>>>
84385>>>            Case (sDriverID = ODBC_DRV_ID)
84388>>>                Get phoODBCSQLHandler to hoSQLHandler
84389>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
84390>>>                Move 0 to iCount
84391>>>                Repeat
84391>>>>
84391>>>                    Get DataSources of hoSQLHandler to sServer
84392>>>                    If (sServer <> "") Begin
84394>>>                        Move (Replace(",", sServer, ", ")) to sServer
84395>>>                        Move sServer to sReturnArray[iCount]
84396>>>                    End
84396>>>>
84396>>>                    Increment iCount
84397>>>                Until (sServer = "")
84399>>>                Case Break
84400>>>
84400>>>            Case (sDriverID = SQLFLEX)
84403>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
84404>>>                Case Break
84405>>>
84405>>>            Case (sDriverID = ORAFLEX)
84408>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
84409>>>                Case Break
84410>>>
84410>>>            // There appearantly is no way to enumerate servers for this backend.
84410>>>            Case (sDriverID = MDSPgSQL)
84413>>>                Move "localhost" to sReturnArray[0]
84414>>>                Case Break
84415>>>
84415>>>            // There appearantly is no way to enumerate servers for this backend.
84415>>>            Case (sDriverID = MDSMySQL)
84418>>>                Move "localhost" to sReturnArray[0]
84419>>>                Case Break
84420>>>
84420>>>            Case Else
84420>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
84421>>>>
84421>>>        Case End
84421>>>
84421>>>        Function_Return sReturnArray
84422>>>    End_Function
84423>>>
84423>>>    // Returns all databases as a string array for the passed driver id.
84423>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
84425>>>        String[] sReturnArray
84426>>>        String sServer sVal
84426>>>        tSQLIntTableInfo[] sReturnStructArray
84426>>>        tSQLIntTableInfo[] sReturnStructArray
84427>>>        tSQLConnection SQLConnection
84427>>>        tSQLConnection SQLConnection
84427>>>        Boolean bOK
84427>>>        Integer iCount iSize
84427>>>
84427>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84428>>>        If (bOK = False) Begin
84430>>>            Function_Return sReturnArray
84431>>>        End
84431>>>>
84431>>>
84431>>>        Case Begin
84431>>>            Case (sDriverID = MSSQLDRV_ID)
84433>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
84434>>>                Case Break
84435>>>            Case (sDriverID = DB2_DRV_ID)
84438>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
84439>>>                Case Break
84440>>>
84440>>>            // This is needed to be able to check if a database exists or not.
84440>>>            Case (sDriverID = ODBC_DRV_ID)
84443>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
84444>>>                If (SizeOfArray(sReturnStructArray)) Begin
84446>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
84448>>>                        // If a FILEDSN: (can only be one database name)
84448>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
84449>>>                    End
84449>>>>
84449>>>                    Else Begin
84450>>>                        // Else the DSN's were read from the registry.
84450>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84451>>>                        Move SQLConnection.sServer to sServer
84452>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
84453>>>                        Decrement iSize
84454>>>                        for iCount from 0 to iSize
84460>>>>
84460>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
84461>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
84463>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
84464>>>                                Move iSize to iCount // We're done.
84465>>>                            End
84465>>>>
84465>>>                        Loop
84466>>>>
84466>>>                    End
84466>>>>
84466>>>                End
84466>>>>
84466>>>                Case Break
84467>>>
84467>>>            Case (sDriverID = SQLFLEX)
84470>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
84471>>>                Case Break
84472>>>
84472>>>            Case (sDriverID = MDSPgSQL)
84475>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
84476>>>                Case Break
84477>>>
84477>>>            Case (sDriverID = MDSMySQL)
84480>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
84481>>>                Case Break
84482>>>
84482>>>            Case (sDriverID = ORAFLEX)
84485>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
84486>>>                Case Break
84487>>>
84487>>>            Case Else
84487>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
84487>>>        Case End
84487>>>
84487>>>        Function_Return sReturnArray
84488>>>    End_Function
84489>>>
84489>>>    // Returns all table spaces as a string array for the passed driver id.
84489>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
84491>>>        String[] sReturnArray
84492>>>        Boolean bOK
84492>>>
84492>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84493>>>        If (bOK = False) Begin
84495>>>            Function_Return sReturnArray
84496>>>        End
84496>>>>
84496>>>
84496>>>        Case Begin
84496>>>            Case (sDriverID = DB2_DRV_ID)
84498>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
84499>>>                Case Break
84500>>>
84500>>>            Case (sDriverID = MDSPgSQL)
84503>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
84504>>>                Case Break
84505>>>
84505>>>            Case (sDriverID = ORAFLEX)
84508>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
84509>>>                Case Break
84510>>>
84510>>>            Case Else
84510>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
84511>>>>
84511>>>                Case Break
84512>>>        Case End
84512>>>
84512>>>        Function_Return sReturnArray
84513>>>    End_Function
84514>>>
84514>>>    // Returns all schemas as a string array for the passed driver id.
84514>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
84516>>>        String[] sReturnArray
84517>>>        Boolean bOK
84517>>>
84517>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84518>>>        If (bOK = False) Begin
84520>>>            Function_Return sReturnArray
84521>>>        End
84521>>>>
84521>>>
84521>>>        Case Begin
84521>>>            Case (sDriverID = DB2_DRV_ID)
84523>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
84524>>>                Case Break
84525>>>
84525>>>            Case (sDriverID = MDSPgSQL)
84528>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
84529>>>                Case Break
84530>>>
84530>>>            Case (sDriverID = ORAFLEX)
84533>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
84534>>>                Case Break
84535>>>
84535>>>            Case Else
84535>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
84536>>>>
84536>>>                Case Break
84537>>>        Case End
84537>>>
84537>>>        Function_Return sReturnArray
84538>>>    End_Function
84539>>>
84539>>>    // Returns a string array with all tables for the current database.
84539>>>    Function SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
84541>>>        String[] sReturnArray sArray
84543>>>        String sConnectionString sSelect
84543>>>        Integer iSize iCount iDbType
84543>>>        Boolean bOK
84543>>>
84543>>>        If (sDriverID = DATAFLEX_ID) Begin
84545>>>            Function_Return sArray
84546>>>        End
84546>>>>
84546>>>
84546>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84547>>>        If (bOK = False) Begin
84549>>>            Function_Return sReturnArray
84550>>>        End
84550>>>>
84550>>>        If (sSchema = "") Begin
84552>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
84553>>>        End
84553>>>>
84553>>>
84553>>>        Get psConnectionString to sConnectionString
84554>>>
84554>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
84554>>>        // the dbType.
84554>>>        Get piDbType to iDbType
84555>>>        If (sDriverID = ODBC_DRV_ID) Begin
84557>>>            If (iDbType = EN_DbTypeMySQL) Begin
84559>>>                Move MDSMySQL to sDriverID
84560>>>            End
84560>>>>
84560>>>            If (iDbType = EN_DbTypeMSSQL) Begin
84562>>>                Move MSSQLDRV_ID to sDriverID
84563>>>            End
84563>>>>
84563>>>            If (iDbType = EN_DbTypeDB2) Begin
84565>>>                Move DB2_DRV_ID to sDriverID
84566>>>            End
84566>>>>
84566>>>            If (iDbType = EN_DbTypePostgre) Begin
84568>>>                Move MDSPgSQL to sDriverID
84569>>>            End
84569>>>>
84569>>>        End
84569>>>>
84569>>>
84569>>>        Case Begin
84569>>>            Case (sDriverID = MSSQLDRV_ID)
84571>>>                Get _SqlTableArrayDAW to sReturnArray
84572>>>                Case Break
84573>>>
84573>>>            Case (sDriverID = DB2_DRV_ID)
84576>>>                Get _SqlTableArrayDAW to sReturnArray
84577>>>                Case Break
84578>>>
84578>>>            Case (sDriverID = ODBC_DRV_ID)
84581>>>                Get _SqlTableArrayDAW to sReturnArray
84582>>>                Case Break
84583>>>
84583>>>            Case (sDriverID = SQLFLEX)
84586>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
84587>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
84588>>>                Case Break
84589>>>
84589>>>            Case (sDriverID = MDSMySQL)
84592>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
84593>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
84594>>>                Case Break
84595>>>
84595>>>            Case (sDriverID = MDSPgSQL)
84598>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
84599>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
84600>>>                Case Break
84601>>>
84601>>>            Case (sDriverID = ORAFLEX)
84604>>>                Move "SELECT table_name from user_tables" to sSelect
84605>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
84606>>>                Move (SizeOfArray(sArray)) to iSize
84607>>>                Decrement iSize
84608>>>                For iCount from 0 to iSize
84614>>>>
84614>>>                    If (not(sArray[iCount] contains "$")) Begin
84616>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
84617>>>                    End
84617>>>>
84617>>>                Loop
84618>>>>
84618>>>                Case Break
84619>>>
84619>>>            Case Else
84619>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
84620>>>>
84620>>>                Case Break
84621>>>        Case End
84621>>>
84621>>>        Function_Return sReturnArray
84622>>>    End_Function
84623>>>
84623>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
84623>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
84625>>>        String[] sReturnArray
84626>>>        String sConnectionString sSelect sSchema
84626>>>        Boolean bOK
84626>>>        Integer iDbType
84626>>>
84626>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84627>>>        If (bOK = False) Begin
84629>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
84630>>>>
84630>>>            Function_Return sReturnArray
84631>>>        End
84631>>>>
84631>>>
84631>>>        Get psConnectionString to sConnectionString
84632>>>        Get psSchema to sSchema
84633>>>
84633>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
84633>>>        // the dbType.
84633>>>        Get piDbType to iDbType
84634>>>
84634>>>        Case Begin
84634>>>            Case (sDriverID = ODBC_DRV_ID)
84636>>>                If (iDbType = EN_DbTypeMySQL) Begin
84638>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
84639>>>                End
84639>>>>
84639>>>                If (iDbType = EN_DbTypePostgre) Begin
84641>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
84642>>>                End
84642>>>>
84642>>>                If (iDbType = EN_DbTypeMSSQL) Begin
84644>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
84645>>>                End
84645>>>>
84645>>>
84645>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
84646>>>                Case Break
84647>>>
84647>>>            Case (sDriverID = MSSQLDRV_ID)
84650>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
84651>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
84652>>>                Case Break
84653>>>
84653>>>            Case (sDriverID = DB2_DRV_ID)
84656>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
84657>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
84658>>>                Case Break
84659>>>
84659>>>            Case (sDriverID = SQLFLEX)
84662>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
84663>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
84664>>>                Case Break
84665>>>
84665>>>            Case (sDriverID = MDSMySQL)
84668>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
84669>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
84670>>>                Case Break
84671>>>
84671>>>            Case (sDriverID = MDSPgSQL)
84674>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
84675>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
84676>>>                Case Break
84677>>>
84677>>>            Case (sDriverID = ORAFLEX)
84680>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
84681>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
84682>>>                Case Break
84683>>>
84683>>>            Case Else
84683>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
84684>>>>
84684>>>                Case Break
84685>>>        Case End
84685>>>
84685>>>        Function_Return sReturnArray
84686>>>    End_Function
84687>>>
84687>>>
84687>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
84687>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
84689>>>        String[] sReturnArray sReturnArray2
84691>>>        String sConnectionString sSelect sSchema
84691>>>        Boolean bOK
84691>>>        Integer iCount iSize
84691>>>
84691>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84692>>>        If (bOK = False) Begin
84694>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
84695>>>>
84695>>>            Function_Return sReturnArray
84696>>>        End
84696>>>>
84696>>>
84696>>>        Get psConnectionString to sConnectionString
84697>>>        Get psSchema to sSchema
84698>>>
84698>>>        Case Begin
84698>>>            Case (sDriverID = MSSQLDRV_ID)
84700>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
84701>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
84702>>>                Case Break
84703>>>
84703>>>            Case (sDriverID = DB2_DRV_ID)
84706>>>                Error "Not implemented yet! The select statement has not been finalized."
84707>>>>
84707>>>//                Move () to sSelect
84707>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
84707>>>                Case Break
84708>>>
84708>>>            Case (sDriverID = SQLFLEX)
84711>>>                Error "Not implemented yet! The select statement has not been finalized."
84712>>>>
84712>>>//                Move () to sSelect
84712>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
84712>>>                Case Break
84713>>>
84713>>>            Case (sDriverID = MDSMySQL)
84716>>>                Error "Not implemented yet! The select statement has not been finalized."
84717>>>>
84717>>>//                Move () to sSelect
84717>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
84717>>>                Case Break
84718>>>
84718>>>            Case (sDriverID = MDSPgSQL)
84721>>>                Error "Not implemented yet! The select statement has not been finalized."
84722>>>>
84722>>>//                Move () to sSelect
84722>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
84722>>>                Case Break
84723>>>
84723>>>            Case (sDriverID = ORAFLEX)
84726>>>                Error "Not implemented yet! The select statement has not been finalized."
84727>>>>
84727>>>//                Move () to sSelect
84727>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
84727>>>                Case Break
84728>>>
84728>>>            Case Else
84728>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
84729>>>>
84729>>>                Case Break
84730>>>        Case End
84730>>>
84730>>>        Move (SizeOfArray(sReturnArray)) to iSize
84731>>>        Decrement iSize
84732>>>        For iCount from 0 to iSize
84738>>>>
84738>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
84740>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
84741>>>            End
84741>>>>
84741>>>        Loop
84742>>>>
84742>>>
84742>>>        Function_Return sReturnArray2
84743>>>    End_Function
84744>>>
84744>>>    // Returns a string array with all table names the passed table handle has relation ships with.
84744>>>    // The format of the array is "TableName.FieldName"
84744>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
84746>>>        String[] sFileNameArray sFieldNameArray
84748>>>        tSQLRelation[] sRelationsArray
84748>>>        tSQLRelation[] sRelationsArray
84749>>>        String sConnectionString sSelect sSchema sFileName sFieldName
84749>>>        Boolean bOK
84749>>>        Integer iCount iSize iLength
84749>>>
84749>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84750>>>        If (bOK = False) Begin
84752>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
84753>>>>
84753>>>            Function_Return sRelationsArray
84754>>>        End
84754>>>>
84754>>>
84754>>>        Get psConnectionString to sConnectionString
84755>>>        Get psSchema to sSchema
84756>>>
84756>>>        Case Begin
84756>>>            Case (sDriverID = MSSQLDRV_ID)
84758>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
84759>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
84760>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
84761>>>                Case Break
84762>>>
84762>>>            Case (sDriverID = DB2_DRV_ID)
84765>>>                Error "Not implemented yet! The select statement has not been finalized."
84766>>>>
84766>>>//                Move () to sSelect
84766>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
84766>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
84766>>>                Case Break
84767>>>
84767>>>            Case (sDriverID = SQLFLEX)
84770>>>                Error "Not implemented yet! The select statement has not been finalized."
84771>>>>
84771>>>//                Move () to sSelect
84771>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
84771>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
84771>>>                Case Break
84772>>>
84772>>>            Case (sDriverID = MDSMySQL)
84775>>>                Error "Not implemented yet! The select statement has not been finalized."
84776>>>>
84776>>>//                Move () to sSelect
84776>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
84776>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
84776>>>                Case Break
84777>>>
84777>>>            Case (sDriverID = MDSPgSQL)
84780>>>                Error "Not implemented yet! The select statement has not been finalized."
84781>>>>
84781>>>//                Move () to sSelect
84781>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
84781>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
84781>>>                Case Break
84782>>>
84782>>>            Case (sDriverID = ORAFLEX)
84785>>>                Error "Not implemented yet! The select statement has not been finalized."
84786>>>>
84786>>>//                Move () to sSelect
84786>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
84786>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
84786>>>                Case Break
84787>>>
84787>>>            Case Else
84787>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
84788>>>>
84788>>>                Case Break
84789>>>        Case End
84789>>>
84789>>>        Move (Length(sTableName)) to iLength
84790>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
84791>>>        Move (SizeOfArray(sFileNameArray)) to iSize
84792>>>        Decrement iSize
84793>>>        For iCount from 0 to iSize
84799>>>>
84799>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
84801>>>                Move sFileNameArray[iCount]         to sFileName
84802>>>                Move sFieldNameArray[iCount]        to sFieldName
84803>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
84804>>>                Move sFileName  to sRelationsArray[iCount].sFileName
84805>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
84806>>>            End
84806>>>>
84806>>>        Loop
84807>>>>
84807>>>
84807>>>        Function_Return sRelationsArray
84808>>>    End_Function
84809>>>
84809>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
84811>>>        tSQLLoggedInUser[] SQLLoggedInUser
84811>>>        tSQLLoggedInUser[] SQLLoggedInUser
84812>>>        String[] sUsers sPrograms
84814>>>        String sSelect
84814>>>        Integer iSize iCount
84814>>>
84814>>>        Case Begin
84814>>>            Case (sDriverID = MSSQLDRV_ID)
84816>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
84817>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
84818>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
84819>>>                Case Break
84820>>>            Case (sDriverID = SQLFLEX)
84823>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
84824>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
84825>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
84826>>>                Case Break
84827>>>            Case Else
84827>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
84828>>>>
84828>>>        Case End
84828>>>
84828>>>        Move (SizeOfArray(sUsers)) to iSize
84829>>>        Decrement iSize
84830>>>        For iCount from 0 to iSize
84836>>>>
84836>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
84837>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
84838>>>        Loop
84839>>>>
84839>>>
84839>>>        Function_Return SQLLoggedInUser
84840>>>    End_Function
84841>>>
84841>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
84841>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
84841>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
84843>>>        String[] sFilesData
84844>>>        Boolean bExists
84844>>>        Integer iCh
84844>>>        String sFileName sExt
84844>>>
84844>>>        Get vFolderExists sDataPath to bExists
84845>>>        If (bExists = True) Begin
84847>>>            Move (ToANSI(Trim(sDataPath))) to sDataPath
84848>>>            Move ("dir:" + sDataPath)      to sDataPath
84849>>>            Get Seq_New_Channel to iCh  // get free channel for input
84850>>>            Direct_Input channel iCh sDataPath
84852>>>                Repeat
84852>>>>
84852>>>                    Readln channel iCh sFileName
84854>>>                    Get ParseFileExtension sFileName to sExt
84855>>>                    If (Uppercase(sExt) = "INT") Begin
84857>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
84859>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
84860>>>                        End
84860>>>>
84860>>>                    End
84860>>>>
84860>>>                Until (SeqEof = True)
84862>>>            Close_Input channel iCh
84864>>>            Send Seq_Release_Channel iCh
84865>>>        End
84865>>>>
84865>>>        Function_Return sFilesData
84866>>>    End_Function
84867>>>
84867>>>    // Only done for MSSQLDRV_ID so far...
84867>>>    Function SqlEnumerateDatabaseCollations String sDriverID Returns String[]
84869>>>        Boolean bMertechDriver
84869>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
84869>>>        String sDescription sFrom sSys sValue sPrevious
84869>>>        Handle hStmt hoSQLManager hoSQLConnect
84869>>>        Integer iFetchResult iRows iColumn iPos
84869>>>        tSQLConnection SQLConnection
84869>>>        tSQLConnection SQLConnection
84869>>>        String[] asCollations
84870>>>        
84870>>>        If (sDriverID = "") Begin
84872>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84873>>>>
84873>>>            Function_Return asCollations
84874>>>        End
84874>>>>
84874>>>
84874>>>        // Only done for MSSQLDRV_ID so far...
84874>>>        If (sDriverID <> MSSQLDRV_ID) Begin
84876>>>            Function_Return asCollations
84877>>>        End                 
84877>>>>
84877>>>
84877>>>        Get IsMertechDriver sDriverID to bMertechDriver
84878>>>        If (bMertechDriver = False) Begin
84880>>>            Get phoSQLManager to hoSQLManager
84881>>>        End
84881>>>>
84881>>>        Else Begin
84882>>>            Get _MertechSQLManagerHandle to hoSQLManager
84883>>>        End
84883>>>>
84883>>>
84883>>>        Get psConnectionID     to sConnectionID
84884>>>        Get psConnectionString to sConnectionString
84885>>>        Move 0 to LastErr
84886>>>
84886>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84887>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
84888>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84889>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84891>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84892>>>>
84892>>>            Function_Return asCollations
84893>>>        End
84893>>>>
84893>>>
84893>>>        Get SqlOpen of hoSQLConnect to hStmt
84894>>>
84894>>>        If (hStmt = 0) Begin
84896>>>            Send SqlDisconnect of hoSQLManager
84897>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84898>>>>
84898>>>            Function_Return asCollations
84899>>>        End
84899>>>>
84899>>>
84899>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
84900>>>        Get _SqlFindKeyWord CI_SQLName        to sName
84901>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
84902>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
84903>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
84904>>>
84904>>>        // MS-SQL Syntax:  
84904>>>        // SELECT name, description
84904>>>        //   from sys.fn_helpcollations();
84904>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
84905>>>
84905>>>        Move 1 to iColumn
84906>>>        Send SqlExecDirect of hStmt sSQL
84907>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
84908>>>        Repeat
84908>>>>
84908>>>            Get SQLFetch of hStmt to iFetchResult
84909>>>            If (iFetchResult <> 0) Begin
84911>>>                Get SQLColumnValue of hStmt iColumn to sValue 
84912>>>                If (sValue <> sPrevious) Begin         
84914>>>                    // We need to skip all collations starting with "SQL" because they
84914>>>                    // are obsolete and for pre-SQL Server 2000.
84914>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
84915>>>                    If (iPos <> 1) Begin
84917>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
84918>>>                    End
84918>>>>
84918>>>                End
84918>>>>
84918>>>                Move sValue to sPrevious
84919>>>            End
84919>>>>
84919>>>        Until (iFetchResult = 0)
84921>>>        Send SQLClose of hStmt
84922>>>        Send SQLDisconnect of hoSQLConnect
84923>>>
84923>>>        Function_Return asCollations
84924>>>    End_Function
84925>>>
84925>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
84925>>>    // for DAW drivers.
84925>>>    // Returns: A string array.
84925>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
84927>>>        String[] sReturnArray
84928>>>        String sValue sPrevious
84928>>>        Handle hoSQLHandler hoSQLConnect hstmt
84928>>>        Integer iFetchResult iRows
84928>>>        tSQLConnection SQLConnection
84928>>>        tSQLConnection SQLConnection
84928>>>
84928>>>        Get phoSQLManager to hoSQLHandler
84929>>>
84929>>>        If (hoSQLHandler <> 0) Begin
84931>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84932>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
84933>>>
84933>>>            If (hoSQLConnect <> 0) Begin
84935>>>                Get SQLOpen of hoSQLConnect to hstmt
84936>>>                If (hstmt <> 0) Begin
84938>>>                    Send SqlExecDirect of hstmt sStmt
84939>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
84940>>>                    Repeat
84940>>>>
84940>>>                        Get SQLFetch of hstmt to iFetchResult
84941>>>                        If (iFetchResult <> 0) Begin
84943>>>                            Get SQLColumnValue of hstmt iColumn to sValue
84944>>>                            If (sValue <> sPrevious) Begin
84946>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
84947>>>                            End
84947>>>>
84947>>>                            Move sValue to sPrevious
84948>>>                        End
84948>>>>
84948>>>                    Until (iFetchResult = 0)
84950>>>                    Send SQLClose of hstmt
84951>>>                End
84951>>>>
84951>>>                Send SQLDisconnect of hoSQLConnect
84952>>>            End
84952>>>>
84952>>>        End
84952>>>>
84952>>>
84952>>>        Function_Return sReturnArray
84953>>>    End_Function
84954>>>
84954>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
84954>>>    // for Mertech drivers.
84954>>>    // Returns: A string array.
84954>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
84956>>>        String[] sReturnArray
84957>>>        String sValue
84957>>>        Handle hoSQLHandler hoSQLConnect hStmt
84957>>>        Integer iFetchResult iRows
84957>>>        tSQLConnection SQLConnection
84957>>>        tSQLConnection SQLConnection
84957>>>
84957>>>        Get _MertechSQLManagerHandle to hoSQLHandler
84958>>>
84958>>>        If (hoSQLHandler <> 0) Begin
84960>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84961>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
84962>>>
84962>>>            If (hoSQLConnect <> 0) Begin
84964>>>                Get SQLOpen of hoSQLConnect to hStmt
84965>>>                If (hStmt <> 0) Begin
84967>>>                    Send SqlExecDirect of hStmt sStmt
84968>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
84969>>>                    Repeat
84969>>>>
84969>>>                        Get SQLFetch of hStmt to iFetchResult
84970>>>                        If (iFetchResult <> 0) Begin
84972>>>                            Get SQLColumnValue of hStmt 1 to sValue
84973>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
84974>>>                        End
84974>>>>
84974>>>                    Until (iFetchResult = 0)
84976>>>                    Send SQLClose of hStmt
84977>>>                End
84977>>>>
84977>>>                Send SQLDisconnect of hoSQLConnect
84978>>>            End
84978>>>>
84978>>>        End
84978>>>>
84978>>>
84978>>>        Function_Return sReturnArray
84979>>>    End_Function
84980>>>
84980>>>    // * Dummy function for the Studio's Code Explorer *
84980>>>    Function PRIVATE_SQL_SUB_FUNCTIONS Returns Boolean
84982>>>        Function_Return False
84983>>>    End_Function
84984>>>
84984>>>    // Returns the index for the passed sTableName
84984>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
84984>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
84986>>>        Integer iIndex iSize iCount
84986>>>        String[] sTablesArray
84987>>>        String sDatabase sSchema sVal sConnectionString
84987>>>
84987>>>        Move -1 to iIndex
84988>>>        Get psConnectionString to sConnectionString
84989>>>        Get psDatabase to sDatabase
84990>>>        Get psSchema   to sSchema
84991>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
84992>>>        Move (SizeOfArray(sTablesArray)) to iSize
84993>>>        Decrement iSize
84994>>>        For iCount from 0 to iSize
85000>>>>
85000>>>            Move sTablesArray[iCount] to sVal
85001>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85003>>>                Move iCount to iIndex // We found it!
85004>>>                Move iSize to iCount  // End the loop
85005>>>            End
85005>>>>
85005>>>        Loop
85006>>>>
85006>>>
85006>>>        Function_Return iIndex
85007>>>    End_Function
85008>>>
85008>>>    // Helper function that builds a string like;
85008>>>    // "SELECT name from [Master].[sys].[databases] where name"
85008>>>    Function _SqlSelectFromWhereName Returns String
85010>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
85010>>>
85010>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
85011>>>        Get _SqlFindKeyWord CI_SQLName         to sName
85012>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
85013>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
85014>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
85015>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
85016>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
85017>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
85018>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
85019>>>        Function_Return sRetval
85020>>>    End_Function
85021>>>
85021>>>    // Helper function to create a SQL statement like;
85021>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
85021>>>    // Used for checking if an index exists.
85021>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
85023>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
85023>>>
85023>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
85024>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
85025>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
85026>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
85027>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
85028>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
85029>>>        Get _SqlFindKeyWord CI_SQLName to sName
85030>>>
85030>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
85031>>>
85031>>>        Function_Return sRetval
85032>>>    End_Function
85033>>>
85033>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
85033>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
85033>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
85035>>>        String sRetval
85035>>>        If (iLength <> 0) Begin
85037>>>            Move ("(" + String(iLength)) to sRetval
85038>>>            If (iDecimals <> 0) Begin
85040>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
85041>>>            End
85041>>>>
85041>>>            Move (sRetval + ")") to sRetval
85042>>>        End
85042>>>>
85042>>>        Function_Return sRetval
85043>>>    End_Function
85044>>>
85044>>>    Procedure _SqlColumnInfo Handle hoStmt
85046>>>        Integer i iCols iItem
85046>>>        tSqlColumnNew[] aQueryColumns
85046>>>        tSqlColumnNew[] aQueryColumns
85047>>>
85047>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
85048>>>        For i from 1 to iCols
85054>>>>
85054>>>            Move (SizeOfArray(aQueryColumns)) to iItem
85055>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
85056>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
85057>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
85058>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
85059>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
85060>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
85061>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
85062>>>        Loop
85063>>>>
85063>>>        Set piColumns to iCols
85064>>>        Set paQueryColumns to aQueryColumns
85065>>>    End_Procedure
85066>>>
85066>>>    // Checks that the passed sDriverID is defined.
85066>>>    // Also checks if the driver has been loaded; else it gets loaded.
85066>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
85068>>>        Boolean bOK
85068>>>        Integer iDriver
85068>>>
85068>>>        If (sDriverID = DATAFLEX_ID) Begin
85070>>>            Function_Return False
85071>>>        End
85071>>>>
85071>>>
85071>>>        Get IsDAWSQLDriver sDriverID to bOK
85072>>>
85072>>>        If (bOK = False) Begin
85074>>>            Get IsMertechDriver sDriverID to bOK
85075>>>        End
85075>>>>
85075>>>
85075>>>        If (bOK = False) Begin
85077>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
85078>>>>
85078>>>            Function_Return False
85079>>>        End
85079>>>>
85079>>>
85079>>>        Get DriverIndex sDriverID to iDriver
85080>>>        If (iDriver = 0) Begin
85082>>>            Load_Driver sDriverID
85083>>>        End
85083>>>>
85083>>>
85083>>>        Function_Return True
85084>>>    End_Function
85085>>>
85085>>>    // Checks that the length parameter has been passed correctly.
85085>>>    // This is only of concern for certain SQL data types.
85085>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
85087>>>        Integer iLength
85087>>>        Boolean bOK bCheckTypeLength
85087>>>
85087>>>        If (num_arguments > 1) Begin
85089>>>            Move iLen to iLength
85090>>>        End
85090>>>>
85090>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
85091>>>
85091>>>        If (bCheckTypeLength = True) Begin
85093>>>            Move (iLength > 0) to bOK
85094>>>        End
85094>>>>
85094>>>
85094>>>        Function_Return (bOK = True)
85095>>>    End_Function
85096>>>
85096>>>    Function _SqlProperTableName String sTableName Returns String
85098>>>        String sVal sSchema sDriverID
85098>>>        Integer iDbType
85098>>>
85098>>>        If (Trim(sTableName) = "") Begin
85100>>>            Function_Return ""
85101>>>        End
85101>>>>
85101>>>
85101>>>        Get psDriverID to sDriverID
85102>>>        Get piDbType   to iDbType
85103>>>        If (iDbType = EN_dbTypeOracle) Begin
85105>>>            Get psUserID to sSchema
85106>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
85106>>>            Move (Uppercase(sSchema)) to sSchema
85107>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
85108>>>            Function_Return sTableName
85109>>>        End
85109>>>>
85109>>>        If (iDbType = EN_DbTypeMySQL) Begin
85111>>>            Get psDatabase to sVal
85112>>>            Move (sVal + "." + sTableName) to sTableName
85113>>>            Function_Return sTableName
85114>>>        End
85114>>>>
85114>>>        If (iDbType = EN_DbTypePostgre) Begin
85116>>>            Move ('"' + sTableName + '"') to sTableName
85117>>>            Function_Return sTableName
85118>>>        End
85118>>>>
85118>>>
85118>>>        Get psSchema to sSchema
85119>>>        If (sSchema = "") Begin
85121>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85122>>>        End
85122>>>>
85122>>>
85122>>>        Move (Uppercase(sTableName)) to sVal
85123>>>        If (not(sVal contains (sSchema + "."))) Begin
85125>>>            If (iDbType = EN_dbTypeDB2) Begin
85127>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
85128>>>            End
85128>>>>
85128>>>            Else Begin
85129>>>                Move (sSchema + "." + sTableName) to sTableName
85130>>>            End
85130>>>>
85130>>>        End
85130>>>>
85130>>>
85130>>>        Function_Return sTableName
85131>>>    End_Function
85132>>>
85132>>>    // SQL column names can be case-sensitive. This function is used to check that
85132>>>    // the passed sFieldName has the correct spelling.
85132>>>    // Used with Embedded SQL statement calls.
85132>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
85132>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
85134>>>        String sRetval sValue sDriverID
85134>>>        String[] sColumnNamesArray
85135>>>        Integer iCount iColumns
85135>>>
85135>>>        Move "" to sRetval
85136>>>        Get psDriverID to sDriverID
85137>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
85138>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
85139>>>        Decrement iColumns
85140>>>
85140>>>        For iCount from 0 to iColumns
85146>>>>
85146>>>            Move sColumnNamesArray[iCount] to sValue
85147>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
85149>>>                Move sValue to sRetval
85150>>>                Move iColumns to iCount // We're done.
85151>>>            End
85151>>>>
85151>>>        Loop
85152>>>>
85152>>>
85152>>>        Function_Return sRetval
85153>>>    End_Function
85154>>>
85154>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
85156>>>        String[] sReturnArray
85157>>>        Handle hoSQLHandler
85157>>>        Integer iCount iSize iItem
85157>>>        String sServer
85157>>>        tSQLConnection SQLConnection
85157>>>        tSQLConnection SQLConnection
85157>>>
85157>>>        Get phoMSSQLHandler to hoSQLHandler
85158>>>        Send Delete_Data    of hoSQLHandler
85159>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
85160>>>
85160>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85161>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
85162>>>        Decrement iSize
85163>>>
85163>>>        For iCount from 0 to iSize
85169>>>>
85169>>>            Get String_Value of hoSQLHandler iCount to sServer
85170>>>            Move (Trim(sServer)) to sReturnArray[iItem]
85171>>>            Increment iItem
85172>>>        Loop
85173>>>>
85173>>>
85173>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85174>>>
85174>>>        Function_Return sReturnArray
85175>>>    End_Function
85176>>>
85176>>>    Function _SqlTableArrayDAW Returns String[]
85178>>>        String[] sReturnArray
85179>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
85179>>>        Handle hoSQLHandler
85179>>>        Integer iCount iSize iItem iPos
85179>>>        Boolean bOK
85179>>>        tSQLConnection SQLConnection
85179>>>        tSQLConnection SQLConnection
85179>>>
85179>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85180>>>        If (SQLConnection.sConnectionString = "") Begin
85182>>>            Function_Return sReturnArray
85183>>>        End
85183>>>>
85183>>>
85183>>>        Move SQLConnection.sSchema      to sDefSchema
85184>>>        Move (Uppercase(sDefSchema))    to sDefSchema
85185>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
85186>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
85187>>>
85187>>>        Get phoCLIHandler to hoSQLHandler
85188>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
85189>>>        Send Delete_Data  of hoSQLHandler
85190>>>
85190>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85191>>>        Move SQLConnection.sConnectionString to sConnectionString
85192>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
85192>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
85192>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
85192>>>//                Move (Pos(";", sConnectionString)) to iPos
85192>>>//                If (iPos > 0) Begin
85192>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
85192>>>//                    Move (Trim(sConnectionString)) to sConnectionString
85192>>>//                End
85192>>>//            End
85192>>>//        End
85192>>>
85192>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
85193>>>        Move False to Err
85194>>>        Move 0 to iItem
85195>>>
85195>>>        // Note that the enumeration starts from table no 1. (not zero)
85195>>>        for iCount from 1 to iSize
85201>>>>
85201>>>            Get TableName    of hoSQLHandler iCount to sTable
85202>>>            Get TableType    of hoSQLHandler iCount to sTableType
85203>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
85204>>>            If (sSchema = "") Begin
85206>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
85207>>>            End
85207>>>>
85207>>>            Get TableComment of hoSQLHandler iCount to sComment
85208>>>            Move (Trim(sTable)) to sTable
85209>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
85211>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
85212>>>            End
85212>>>>
85212>>>            Else Begin
85213>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
85214>>>            End
85214>>>>
85214>>>            If (bOK = True) Begin
85216>>>                Move sTable to sReturnArray[iItem]
85217>>>                Increment iItem
85218>>>            End
85218>>>>
85218>>>        Loop
85219>>>>
85219>>>
85219>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85220>>>
85220>>>        Function_Return sReturnArray
85221>>>    End_Function
85222>>>
85222>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
85224>>>        String[] sReturnArray
85225>>>        String sValue
85225>>>        Handle hoSQLHandler hoSQLConnect hStmt
85225>>>        Integer iRetval iCols iFetchResult
85225>>>        tSQLConnection SQLConnection
85225>>>        tSQLConnection SQLConnection
85225>>>
85225>>>        Get phoSQLManager to hoSQLHandler
85226>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85227>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
85228>>>
85228>>>        If (hoSQLConnect <> 0) Begin
85230>>>            Get SqlOpen of hoSQLConnect to hStmt
85231>>>            If (hStmt <> 0) Begin
85233>>>                Send SqlSetProcedurename of hStmt sStmt
85234>>>                If (sArgument <> "") Begin
85236>>>                    Send SqlSetArgument  of hStmt 1 sArgument
85237>>>                End
85237>>>>
85237>>>
85237>>>                Send SqlCall             of hStmt
85238>>>                Get SqlReturnValue       of hStmt to iRetval
85239>>>                If (iRetval = 0) Begin
85241>>>                    Repeat
85241>>>>
85241>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
85242>>>                        If (iCols > 0) Begin
85244>>>                            Repeat
85244>>>>
85244>>>                                Get SqlFetch of hStmt to iFetchResult
85245>>>                                If (iFetchResult <> 0) Begin
85247>>>                                    Get SqlColumnValue of hStmt 1 to sValue
85248>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
85249>>>                                End
85249>>>>
85249>>>                            Until (iFetchResult = 0)
85251>>>                        End
85251>>>>
85251>>>                        Get SqlNextResultSet of hStmt to iRetval
85252>>>                    Until (iRetval = 0)
85254>>>                    Send SqlClose of hStmt
85255>>>                End
85255>>>>
85255>>>            End
85255>>>>
85255>>>            Send SqlDisconnect of hoSQLConnect
85256>>>        End
85256>>>>
85256>>>        Function_Return sReturnArray
85257>>>    End_Function
85258>>>
85258>>>    Function _SqlDatabasesArrayDB2 Returns String[]
85260>>>        String[] sReturnArray
85261>>>        String sDataSource
85261>>>        Handle hoSQLHandler
85261>>>        Integer iItem
85261>>>
85261>>>        Get phoDB2SQLHandler to hoSQLHandler
85262>>>        Send SeedDataSources of hoSQLHandler
85263>>>
85263>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85264>>>
85264>>>        Repeat
85264>>>>
85264>>>            Get DataSources of hoSQLHandler to sDataSource
85265>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
85266>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
85267>>>            Increment iItem
85268>>>        Until (sDataSource = "")
85270>>>
85270>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85271>>>
85271>>>        Function_Return sReturnArray
85272>>>    End_Function
85273>>>
85273>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
85275>>>        String[] sReturnArray
85276>>>        String sDataSource
85276>>>        Handle hoSQLHandler
85276>>>        Integer iItem
85276>>>
85276>>>        Get phoODBCSQLHandler to hoSQLHandler
85277>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85278>>>
85278>>>        Send SeedDataSources of hoSQLHandler
85279>>>
85279>>>        Repeat
85279>>>>
85279>>>            Get DataSources of hoSQLHandler to sDataSource
85280>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
85282>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
85283>>>                Increment iItem
85284>>>            End
85284>>>>
85284>>>        Until (sDataSource = "")
85286>>>
85286>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85287>>>
85287>>>        Function_Return sReturnArray
85288>>>    End_Function
85289>>>
85289>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
85291>>>        String[] sDataSources
85292>>>        tSQLConnection SQLConnection
85292>>>        tSQLConnection SQLConnection
85292>>>        tSQLIntTableInfo[] sReturnArray
85292>>>        tSQLIntTableInfo[] sReturnArray
85293>>>        Integer iDataSources iCount iItem
85293>>>        String sConnection sServer sDatabase sKey sSubKey
85293>>>        Handle hoIniFile hoRegistry hoODBCDataSources
85293>>>        Boolean bExists bKeyOpened
85293>>>
85293>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85294>>>        Move SQLConnection.sConnectionString to sConnection
85295>>>        Move SQLConnection.sServer           to sServer
85296>>>
85296>>>        // FileDSN - read DATABASE name from DSN ini-file
85296>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
85298>>>            Get Create (RefClass(cIniFile)) to hoIniFile
85299>>>            Set psFileName of hoIniFile to sServer
85300>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
85301>>>            Move sDatabase to sReturnArray[0].sDatabaseName
85302>>>            Send Destroy of hoIniFile
85303>>>        End
85303>>>>
85303>>>
85303>>>        // DSN - read DATABASE name from the registry
85303>>>        Else Begin
85304>>>            Get Create (RefClass(cRegistry)) to hoRegistry
85305>>>
85305>>>            // We start with checking the "System DNS" area in the registry as it is the
85305>>>            // most probably place the info is kept that we're after.
85305>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
85306>>>            Set pfAccessRights of hoRegistry to Key_Read
85307>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
85308>>>            If (bExists = True) Begin
85310>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
85311>>>            End
85311>>>>
85311>>>            Else Begin
85312>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
85313>>>            End
85313>>>>
85313>>>
85313>>>            Get KeyExists of hoRegistry sKey to bExists
85314>>>            If (bExists) Begin
85316>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
85317>>>                If (bKeyOpened) Begin
85319>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
85320>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
85321>>>                    If (iDataSources > 0) Begin
85323>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
85324>>>                        Decrement iDataSources
85325>>>                        for iCount from 0 to iDataSources
85331>>>>
85331>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
85332>>>                        Loop
85333>>>>
85333>>>                        Move 0 to iItem
85334>>>                        for iCount from 0 to iDataSources
85340>>>>
85340>>>                            Move sDataSources[iCount] to sSubKey
85341>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
85342>>>                            If (bKeyOpened = True) Begin
85344>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
85345>>>                                If (bExists = True) Begin
85347>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
85348>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
85349>>>                                    Increment iItem
85350>>>                                End
85350>>>>
85350>>>                            End
85350>>>>
85350>>>                        Loop
85351>>>>
85351>>>                    End
85351>>>>
85351>>>                    Send CloseKey of hoRegistry
85352>>>                    Send Destroy of hoODBCDataSources
85353>>>                End
85353>>>>
85353>>>            End
85353>>>>
85353>>>
85353>>>            // We then check the "User DNS" area in the registry.
85353>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
85354>>>            Set pfAccessRights of hoRegistry to Key_Read
85355>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
85356>>>            Get KeyExists of hoRegistry sKey to bExists
85357>>>
85357>>>            If (bExists) Begin
85359>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
85360>>>                If (bKeyOpened) Begin
85362>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
85363>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
85364>>>                    If (iDataSources > 0) Begin
85366>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
85367>>>                        Decrement iDataSources
85368>>>                        for iCount from 0 to iDataSources
85374>>>>
85374>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
85375>>>                        Loop
85376>>>>
85376>>>                        for iCount from 0 to iDataSources
85382>>>>
85382>>>                            Move sDataSources[iCount] to sSubKey
85383>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
85384>>>                            If (bKeyOpened = True) Begin
85386>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
85387>>>                                If (bExists = True) Begin
85389>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
85390>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
85391>>>                                    Increment iItem
85392>>>                                End
85392>>>>
85392>>>                            End
85392>>>>
85392>>>                        Loop
85393>>>>
85393>>>                    End
85393>>>>
85393>>>                    Send CloseKey of hoRegistry
85394>>>                    Send Destroy of hoODBCDataSources
85395>>>                End
85395>>>>
85395>>>            End
85395>>>>
85395>>>
85395>>>            Send Destroy of hoRegistry
85396>>>        End
85396>>>>
85396>>>
85396>>>        Function_Return sReturnArray
85397>>>    End_Function
85398>>>
85398>>>    // We might have a split Sql script where the info about which database to use is
85398>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
85398>>>    // insert it for scriplets to come after the first one.
85398>>>    Function _SqlFormatStatement String sStmt Returns String
85400>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
85400>>>        Integer iStart iEnd iDbType
85400>>>        Boolean bOK
85400>>>
85400>>>        Get piDbType to iDbType
85401>>>        Get psDriverID to sDriverID
85402>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
85403>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
85404>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
85405>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
85406>>>        Move (Replaces(" ", sStmt, "")) to sTmp
85407>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
85409>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
85410>>>            Move (Pos("]", sTmp)) to iEnd
85411>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
85412>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
85413>>>            Set Private.psUseDatabase to sUseDatabase
85414>>>        End
85414>>>>
85414>>>        Else Begin
85415>>>            Move (Uppercase(sStmt)) to sTmp
85416>>>
85416>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
85416>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
85418>>>                Get Private.psUseDatabase to sUseDatabase
85419>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
85420>>>            End
85420>>>>
85420>>>
85420>>>            // This is a bit special to place here but was done so because it was easier that way.
85420>>>            // We will get an error when trying to create a view if it already exists.
85420>>>            // So to avoid such errors; we first remove it & then recreate it.
85420>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
85423>>>                // Make sure we only have one space between statements/words.
85423>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
85424>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
85425>>>                Move (Trim(sTmp)) to sTmp
85426>>>                Move (Pos(" ", sTmp)) to iEnd
85427>>>                Move (Left(sTmp, iEnd)) to sTmp
85428>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
85430>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
85431>>>                End
85431>>>>
85431>>>                Move (Trim(sTmp)) to sTmp
85432>>>                // Remove data view as it already exists!
85432>>>                Get SqlViewRemove sDriverID sTmp to bOK
85433>>>            End
85433>>>>
85433>>>        End
85433>>>>
85433>>>
85433>>>        Function_Return sStmt
85434>>>    End_Function
85435>>>
85435>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
85435>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
85437>>>        String sRetval
85437>>>        Integer iDbType iIndex
85437>>>        tSQLKeyWords[] SQLKeywordArray
85437>>>        tSQLKeyWords[] SQLKeywordArray
85438>>>        tSQLKeyWords   SQLKeyWords
85438>>>        tSQLKeyWords   SQLKeyWords
85438>>>
85438>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
85438>>>        Move "" to sRetval
85439>>>        Get piDbType to iDbType
85440>>>        Move iDbType             to SQLKeyWords.iSQLDbType
85441>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
85442>>>
85442>>>        Get paSQLKeywordArray to SQLKeywordArray
85443>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
85444>>>        If (iIndex >= 0) Begin
85446>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
85447>>>        End
85447>>>>
85447>>>
85447>>>        Function_Return sRetval
85448>>>    End_Function
85449>>>
85449>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
85449>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
85451>>>        String[] sSQLScriptArray
85452>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
85452>>>        Integer iSize iCount
85452>>>        Boolean bCommentStart bCommentEnd bDashComment
85452>>>
85452>>>        Move False to bCommentStart
85453>>>        Move False to bCommentEnd
85454>>>        Move False to bDashComment
85455>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
85456>>>        Move "*/"  to sCommentEnd
85457>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
85458>>>
85458>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
85459>>>        Decrement iSize
85460>>>        Move "" to sText
85461>>>
85461>>>        For iCount from 0 to iSize
85467>>>>
85467>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
85468>>>            Move (Trim(sLine)) to sTmp
85469>>>            If (sTmp <> "") Begin
85471>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
85472>>>                If (bCommentStart = False) Begin
85474>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
85475>>>                    If (bCommentStart = False) Begin
85477>>>                    End
85477>>>>
85477>>>                End
85477>>>>
85477>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
85478>>>                If (bCommentEnd = True) Begin
85480>>>                    Move False to bCommentStart
85481>>>                End
85481>>>>
85481>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
85483>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
85484>>>                End
85484>>>>
85484>>>            End
85484>>>>
85484>>>        Loop
85485>>>>
85485>>>
85485>>>        // Update the retval struct array:
85485>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
85486>>>        Function_Return SqlScriptArray
85487>>>    End_Function
85488>>>
85488>>>
85488>>>    // *** Database API Functions: ***
85488>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
85488>>>    // make changes/updates to the database.
85488>>>
85488>>>    // * Dummy function for the Studio's Code Explorer *
85488>>>    Function API_TABLE_FUNCTIONS Returns Boolean
85490>>>        Function_Return False
85491>>>    End_Function
85492>>>
85492>>>    // This might not do what you think - Here's what it does:
85492>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
85492>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
85492>>>    // to the SQL table.
85492>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
85492>>>    // already exists in SQL.
85492>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
85492>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
85492>>>    // restructuring an existing table.
85492>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
85494>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
85494>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
85494>>>        Handle hToTable
85494>>>
85494>>>        Move True to bUseConnectionID
85495>>>        If (num_arguments > 1) Begin
85497>>>            Move bUseConnID to bUseConnectionID
85498>>>        End
85498>>>>
85498>>>
85498>>>        Get psDriverID to sDriverID
85499>>>        // If the table doesn't exist on the SQL back-end we do nothing.
85499>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
85500>>>        If (bExists = False) Begin
85502>>>            Function_Return False
85503>>>        End
85503>>>>
85503>>>
85503>>>        Get UtilTableIsAlias hTable to bIsAlias
85504>>>
85504>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85505>>>        If (bOK = False) Begin
85507>>>            Function_Return False
85508>>>        End
85508>>>>
85508>>>
85508>>>        // Then we need to check that the function hasn't been called before; which in case
85508>>>        // we do nothing
85508>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
85509>>>        If (bExists = True) Begin
85511>>>            Function_Return False
85512>>>        End
85512>>>>
85512>>>
85512>>>        Get psConnectionID     to sConnectionID
85513>>>        Get psConnectionString to sConnectionString
85514>>>        If (sConnectionID = "" or sConnectionString = "") Begin
85516>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
85517>>>>
85517>>>            Function_Return False
85518>>>        End
85518>>>>
85518>>>
85518>>>        Set Private.phCurrentTable to hTable
85519>>>        Get psSchema to sSchema
85520>>>        If (sSchema = "") Begin
85522>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85523>>>        End
85523>>>>
85523>>>
85523>>>        Get IsMertechDriver sDriverID to bMertechDriver
85524>>>
85524>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
85524>>>        // was a programmer's error and we adjust for it here.
85524>>>        If (bMertechDriver = True) Begin
85526>>>            Move False to bUseConnectionID
85527>>>        End
85527>>>>
85527>>>
85527>>>        // If we should use a connection id we need to check it exists;
85527>>>        // else we create it before attempting creating the table
85527>>>        If (bUseConnectionID = True) Begin
85529>>>            Get AutoConnectionIDLogin to bOK
85530>>>            If (bOk = False) Begin
85532>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
85533>>>>
85533>>>                Function_Return False
85534>>>            End
85534>>>>
85534>>>        End
85534>>>>
85534>>>
85534>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85537>>>        Get _TableNameOnly sRootName to sRootName
85538>>>        If (sRootName = "") Begin
85540>>>            Function_Return False
85541>>>        End
85541>>>>
85541>>>        Move (sRootName + ".int")                    to sPhysicalName
85542>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85545>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85548>>>
85548>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
85548>>>        //
85548>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
85548>>>        // because then the table should not be visible to users.
85548>>>//        Move (Pos("@", sDisplayName)) to iPos
85548>>>//        If (iPos <> 1) Begin
85548>>>//            If (sDisplayName contains ".") Begin
85548>>>//                Move (Pos(".", sDisplayName)) to iPos
85548>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
85548>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
85548>>>//            End
85548>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
85548>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85548>>>//            End
85548>>>//        End
85548>>>
85548>>>        If (bIsAlias = False) Begin
85550>>>            Get OpenTableExclusive hTable to bOpened
85551>>>            If (bOpened = False) Begin
85553>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
85554>>>>
85554>>>                Function_Return False
85555>>>            End
85555>>>>
85555>>>        End
85555>>>>
85555>>>
85555>>>        If (ghoProgressBar <> 0) Begin
85557>>>            Send DoAdvance of ghoProgressBar
85558>>>            Set Message_Text of ghoStatusPanel to ""
85559>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
85560>>>        End
85560>>>>
85560>>>        // Note: The hToTable will get changed by the Structure_xxx command...
85560>>>        Move hTable to hToTable
85561>>>        Move False to Err
85562>>>
85562>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
85562>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
85562>>>        // a proper and updated .int file.
85562>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
85565>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
85566>>>
85566>>>        If (bIsAlias = False) Begin
85568>>>            Structure_Start hToTable sDriverID
85569>>>                Set Private.phCurrentTable to hTable
85570>>>                If (bUseConnectionID = True) Begin
85572>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
85575>>>                End
85575>>>>
85575>>>                Else Begin
85576>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
85579>>>                End
85579>>>>
85579>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
85582>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
85582>>>                Move False to Err
85583>>>                Move 0 to LastErr
85584>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85585>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85587>>>            Set Action_Text of ghoStatusPanel to ""
85588>>>        End
85588>>>>
85588>>>
85588>>>        Move (not(Err)) to bOK
85589>>>        If (bOK = True) Begin
85591>>>            // The attributes set above will always trigger an error
85591>>>            // We also adjust the Filelist entries
85591>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
85594>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85597>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85600>>>
85600>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
85600>>>            Get SqlUtilUpdateIntFile hTable to bOK
85601>>>        End
85601>>>>
85601>>>
85601>>>        Function_Return (bOK = True)
85602>>>    End_Function
85603>>>
85603>>>    // Sample usage:
85603>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
85603>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
85603>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
85605>>>        Boolean bOK bIsSQLTable
85605>>>
85605>>>        Get AutoConnectionIDLogin to bOK
85606>>>        Move False to Err
85607>>>        Get OpenTableExclusive hTable to bOK
85608>>>        If (bOK = False) Begin
85610>>>            Function_Return False
85611>>>        End
85611>>>>
85611>>>
85611>>>        // ToDo: Add to all table change functions!
85611>>>            Get UtilTableIsSQL hTable to bIsSQLTable
85612>>>            If (bIsSQLTable = True) Begin
85614>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85617>>>            End
85617>>>>
85617>>>
85617>>>        Set Private.phCurrentTable to hTable
85618>>>        Structure_Start hTable
85619>>>            Set_Attribute iAttribute of hTable to iValue
85622>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85623>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85625>>>
85625>>>        Set Action_Text of ghoStatusPanel to ""
85626>>>        Function_Return (Err = False)
85627>>>    End_Function
85628>>>
85628>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
85630>>>        Boolean bOK
85630>>>        
85630>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
85631>>>        If (bOK = True) Begin
85633>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
85634>>>        End
85634>>>>
85634>>>        
85634>>>        Function_Return (bOK = True)
85635>>>    End_Function
85636>>>    
85636>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
85636>>>    // or to change the filelist slot names.
85636>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
85638>>>        String sFileListName
85638>>>        
85638>>>        Move False to Err
85639>>>
85639>>>        If (ghoProgressBar <> 0) Begin
85641>>>            Send DoAdvance of ghoProgressBar
85642>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
85643>>>        End
85643>>>>
85643>>>        // If all strings are empty it means that we should remove this entry from filelist.
85643>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
85645>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
85648>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
85651>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
85654>>>            Function_Return (Err = False) // And we're done.
85655>>>        End
85655>>>>
85655>>>
85655>>>        If (sDriverID <> DATAFLEX_ID) Begin
85657>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
85657>>>            Move (sDriverID + ":" + sRootName) to sRootName
85658>>>        End
85658>>>>
85658>>>//        Else Begin
85658>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85658>>>//        End
85658>>>//
85658>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
85658>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
85658>>>
85658>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
85661>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
85664>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
85667>>>        
85667>>>        Function_Return (Err = False)
85668>>>    End_Function
85669>>>
85669>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
85671>>>        Boolean bOK
85671>>>
85671>>>        Get AutoConnectionIDLogin to bOK
85672>>>        Move False to Err
85673>>>        Get OpenTableExclusive hTable to bOK
85674>>>        If (bOK = False) Begin
85676>>>            Function_Return False
85677>>>        End
85677>>>>
85677>>>
85677>>>        Set Private.phCurrentTable to hTable
85678>>>        Structure_Start hTable
85679>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
85682>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85683>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85685>>>
85685>>>        Set Action_Text of ghoStatusPanel to ""
85686>>>        Function_Return (Err = False)
85687>>>    End_Function
85688>>>
85688>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
85690>>>        Boolean bOK bIsSQLTable
85690>>>
85690>>>        Move False to Err
85691>>>        Get AutoConnectionIDLogin to bOK
85692>>>        Open hToTable
85694>>>        Get OpenTableExclusive hTable to bOK
85695>>>        If (bOK = False) Begin
85697>>>            Function_Return False
85698>>>        End
85698>>>>
85698>>>
85698>>>            Get UtilTableIsSQL hTable to bIsSQLTable
85699>>>            If (bIsSQLTable = True) Begin
85701>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85704>>>            End
85704>>>>
85704>>>
85704>>>        Set Private.phCurrentTable to hTable
85705>>>        Structure_Start hTable
85706>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
85709>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
85712>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85713>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85715>>>
85715>>>        Set Action_Text of ghoStatusPanel to ""
85716>>>        Function_Return (Err = False)
85717>>>    End_Function
85718>>>
85718>>>    Procedure ApiTableConvertAllAddException Integer hTable
85720>>>        Integer[] aTableConvertExceptions
85721>>>        Get paTableConvertExceptions to aTableConvertExceptions
85722>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
85723>>>        Set paTableConvertExceptions to aTableConvertExceptions
85724>>>    End_Procedure
85725>>>
85725>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
85727>>>        Integer[] aTableDateCorrectionExceptions
85728>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
85729>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
85730>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
85731>>>    End_Procedure
85732>>>
85732>>>    Procedure ApiTableConvertALLToSql
85734>>>        Integer[] iTablesArray
85735>>>        Integer iSize iCount
85735>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
85735>>>        String sDriverID
85735>>>
85735>>>        Get psDriverID to sDriverID
85736>>>        Get pbUseConnectionID to bUseConnectionID
85737>>>        Get pbToANSI          to bToANSI
85738>>>        Get pbRecnum          to bRecnum
85739>>>        Get pbCopyData        to bCopyData
85740>>>        If (ghoDbUpdateHandler > 0) Begin
85742>>>            Get pbContinueOnError to bContinueOnError
85743>>>        End
85743>>>>
85743>>>
85743>>>        Get _AllTablesToConvert to iTablesArray
85744>>>        Move (SizeOfArray(iTablesArray)) to iSize
85745>>>        Set pbVisible   of ghoProgressBarOverall to True
85746>>>        Set piPosition  of ghoProgressBarOverall to 0
85747>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
85748>>>        Set piMaximum   of ghoProgressBarOverall to iSize
85749>>>
85749>>>        Decrement iSize
85750>>>        For iCount from 0 to iSize
85756>>>>
85756>>>            Set piPosition of ghoProgressBarOverall to iCount
85757>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
85758>>>            // Probably the right logic here is to just continue trying to convert every table even
85758>>>            // if there was an error converting one table...
85758>>>            //If (bContinueOnError = False and bOK = False) Break
85758>>>        Loop
85759>>>>
85759>>>
85759>>>    End_Procedure
85760>>>
85760>>>    Procedure ApiTableAttachALLToSql
85762>>>        Integer[] iTablesArray
85763>>>        Integer iSize iCount
85763>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
85763>>>        String sDriverID
85763>>>
85763>>>        Get psDriverID to sDriverID
85764>>>        Get pbUseConnectionID to bUseConnectionID
85765>>>        Get pbToANSI          to bToANSI
85766>>>        Get pbRecnum          to bRecnum
85767>>>        Get pbCopyData        to bCopyData
85768>>>        If (ghoDbUpdateHandler > 0) Begin
85770>>>            Get pbContinueOnError to bContinueOnError
85771>>>        End
85771>>>>
85771>>>
85771>>>        Get _AllTablesToConvert to iTablesArray
85772>>>        Move (SizeOfArray(iTablesArray)) to iSize
85773>>>        Decrement iSize
85774>>>        For iCount from 0 to iSize
85780>>>>
85780>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
85781>>>        Loop
85782>>>>
85782>>>
85782>>>    End_Procedure
85783>>>
85783>>>    // Subfunction to the ApiTableUpdate function (et al)
85783>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
85785>>>        Handle hTable
85785>>>        String sConnectionID
85785>>>        Boolean bTableExists bSameTableNames bANSI bOK
85785>>>
85785>>>        Get ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
85786>>>        If (bSameTableNames = True) Begin
85788>>>            Function_Return True
85789>>>        End
85789>>>>
85789>>>
85789>>>        Move True to bOK
85790>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
85791>>>        Set Private.phCurrentTable              to hTable
85792>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
85795>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
85798>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
85801>>>
85801>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
85803>>>            Get psConnectionID to sConnectionID
85804>>>            Get UtilTableExists hTable to bTableExists
85805>>>            If (bTableExists = True) Begin
85807>>>                Get SqlUtilUpdateIntFile hTable to bOK
85808>>>            End
85808>>>>
85808>>>            Else Begin
85809>>>                Get pbToANSI to bANSI
85810>>>                Get SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
85811>>>            End
85811>>>>
85811>>>        End
85811>>>>
85811>>>
85811>>>        Function_Return bOK
85812>>>    End_Function
85813>>>
85813>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
85815>>>        Handle hToTable hoLogFile
85815>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
85815>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
85815>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
85815>>>        tSQLConnection SQLConnection
85815>>>        tSQLConnection SQLConnection
85815>>>
85815>>>        Get UtilTableExists hTable to bExists
85816>>>        If (bExists = False) Begin
85818>>>            Set Private.phCurrentTable to hTable
85819>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
85820>>>>
85820>>>            Function_Return False
85821>>>        End
85821>>>>
85821>>>
85821>>>        Get UtilTableIsAlias hTable to bIsAlias
85822>>>        // If this is an Alias file there is nothing to convert to SQL.
85822>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
85822>>>        If (bIsAlias = True) Begin
85824>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85827>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
85829>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
85832>>>                Get psConnectionID to sConnectionID
85833>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
85834>>>            End
85834>>>>
85834>>>            Function_Return True
85835>>>        End
85835>>>>
85835>>>
85835>>>        Set Private.phCurrentTable to hTable
85836>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85839>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85842>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85845>>>
85845>>>        If (ghoProgressBar <> 0) Begin
85847>>>            Send DoAdvance of ghoProgressBar
85848>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
85849>>>            Set Message_Text   of ghoStatusPanel to ""
85850>>>            Set Action_Text    of ghoStatusPanel to ""
85851>>>        End
85851>>>>
85851>>>
85851>>>        // Marco Kuipers suggestion;
85851>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
85851>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
85851>>>        // SQL table.
85851>>>        Get UtilTableIsSQL hTable to bOK
85852>>>        If (bOK = False) Begin
85854>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
85855>>>            If (bExists = True) Begin
85857>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
85857>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
85857>>>                Get phoLogFile to hoLogFile
85858>>>                If (hoLogFile <> 0) Begin          
85860>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
85861>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
85861>>>                    Send LogError sWarning False
85862>>>                End
85862>>>>
85862>>>                Else Begin
85863>>>                    Error DFERR_PROGRAM sWarning
85864>>>>
85864>>>                End                                                       
85864>>>>
85864>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
85865>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
85866>>>            End
85866>>>>
85866>>>        End
85866>>>>
85866>>>
85866>>>        // Does the rootname contain a driver?
85866>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
85868>>>            // Does the table already exist as an SQL table?
85868>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
85869>>>            // It can happen that the table is missing from Filelist.cfg but still
85869>>>            // exist on the SQL side, in case we want to search for the table by its name.
85869>>>            If (bExists = False) Begin
85871>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
85872>>>            End
85872>>>>
85872>>>            If (bExists = True) Begin
85874>>>                Set TableName_Text of ghoStatusPanel to ""
85875>>>                Function_Return False
85876>>>            End
85876>>>>
85876>>>        End
85876>>>>
85876>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
85877>>>
85877>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
85878>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
85878>>>        // passed as True, we adjust for that here.
85878>>>        Get IsMertechDriver sDriverID to bMertechDriver
85879>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
85881>>>            Move False to bUseConnectionID
85882>>>        End
85882>>>>
85882>>>
85882>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85883>>>        Move SQLConnection.sSchema           to sSchema
85884>>>        If (sSchema = "") Begin
85886>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
85887>>>            Move (Lowercase(sSchema))        to sSchema
85888>>>        End
85888>>>>
85888>>>
85888>>>        If (sDriverID = ORAFLEX) Begin
85890>>>            Move SQLConnection.sUserID       to sSchema
85891>>>        End
85891>>>>
85891>>>
85891>>>        Move SQLConnection.sDatabase         to sDatabase
85892>>>        Move SQLConnection.sConnectionID     to sConnectionID
85893>>>        Move SQLConnection.sConnectionString to sConnectionString
85894>>>        If (sConnectionID = "" or sConnectionString = "") Begin
85896>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
85897>>>>
85897>>>            Function_Return False
85898>>>        End
85898>>>>
85898>>>
85898>>>        Get AutoConnectionIDLogin to bOK
85899>>>        Open hTable
85901>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85904>>>        If (bOpened = False) Begin
85906>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
85907>>>>
85907>>>            Function_Return False
85908>>>        End
85908>>>>
85908>>>
85908>>>        If (ghoProgressBar <> 0) Begin
85910>>>            Send DoAdvance of ghoProgressBar
85911>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
85912>>>        End
85912>>>>
85912>>>
85912>>>        Move 0 to hToTable
85913>>>        Get _TableNameOnly sRootName                 to sRootName
85914>>>        Move (sRootName + ".int")                    to sPhysicalName
85915>>>
85915>>>        Case Begin
85915>>>            Case (sDriverID = MSSQLDRV_ID)
85917>>>                Case Break
85918>>>            Case (sDriverID = ODBC_DRV_ID)
85921>>>                Case Break
85922>>>            Case (sDriverID = DB2_DRV_ID)
85925>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
85926>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
85927>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
85928>>>                Case Break
85929>>>            Case (sDriverID = ORAFLEX)
85932>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
85933>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
85934>>>                Case Break
85935>>>            Case (sDriverID = MDSMySQL)
85938>>>                Case Break
85939>>>            Case (sDriverID = MDSPgSQL)
85942>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
85943>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
85944>>>                Case Break
85945>>>            Case (sDriverID = DATAFLEX_ID)
85948>>>                Case Break
85949>>>            Case Else
85949>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
85950>>>>
85950>>>                Case Break
85951>>>        Case End
85951>>>
85951>>>        Move False to Err
85952>>>
85952>>>        If (bMertechDriver = True) Begin
85954>>>            // Note: This function also sets the Err flag.
85954>>>            Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bToAnsi bCopyData to bOK
85955>>>        End
85955>>>>
85955>>>
85955>>>        If (bMertechDriver = False) Begin
85957>>>            Structure_Start hToTable sDriverID
85958>>>                Structure_Copy hTable to hToTable
85959>>>                Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
85962>>>
85962>>>                If (sDriverID <> DATAFLEX_ID) Begin
85964>>>                    If (bUseConnectionID = True) Begin
85966>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
85969>>>                    End
85969>>>>
85969>>>                    Else Begin
85970>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
85973>>>                    End
85973>>>>
85973>>>
85973>>>                    Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
85976>>>
85976>>>                    If (sSchema <> "") Begin
85978>>>                        Set_Attribute DF_FILE_OWNER of hToTable to sSchema
85981>>>                    End
85981>>>>
85981>>>
85981>>>                    If (sDriverID = DB2_DRV_ID) Begin
85983>>>                        If (sLongTableSpace <> "") Begin
85985>>>                            Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
85988>>>                        End
85988>>>>
85988>>>                        If (sBaseTableSpace <> "") Begin
85990>>>                            Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
85993>>>                        End
85993>>>>
85993>>>                        If (sIndexTableSpace <> "") Begin
85995>>>                            Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
85998>>>                        End
85998>>>>
85998>>>                    End
85998>>>>
85998>>>                End
85998>>>>
85998>>>
85998>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85999>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86001>>>            Set Action_Text of ghoStatusPanel to ""
86002>>>        End
86002>>>>
86002>>>
86002>>>        Move (not(Err)) to bOK
86003>>>
86003>>>        If (bOK = True and bCopyData = True) Begin
86005>>>            If (bMertechDriver = False) Begin
86007>>>                Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
86008>>>            End
86008>>>>
86008>>>            Else Begin
86009>>>                Get _MertechCopyDataToSQL hTable sRootName sDriverID to bOK
86010>>>            End
86010>>>>
86010>>>
86010>>>            If (ghoDbUpdateHandler > 0) Begin
86012>>>                Get pbContinueOnError to bContinueOnError
86013>>>            End
86013>>>>
86013>>>            // If the data copy failed we will keep the newly created SQL table but
86013>>>            // rename it by adding a GUID to the end of the table name
86013>>>            // - or as much as "fit" because different SQL back-ends have
86013>>>            // different rules how long a table name can be.
86013>>>            // The new table will probably contain data but something went
86013>>>            // wrong while converting the data from embedded to SQL.
86013>>>            If (bOK = False and bContinueOnError = False) Begin
86015>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86016>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86017>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
86018>>>>
86018>>>            End
86018>>>>
86018>>>        End
86018>>>>
86018>>>
86018>>>        // This must be after copying data...
86018>>>        If (Err = False) Begin
86020>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86023>>>            // It seems the Studio does not do this any more, so commented out.
86023>>>            // We also adjust the display name by prefixing it by the schema name;
86023>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86023>>>            //                // The max length for the display_name is 31 characters...
86023>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
86023>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
86023>>>            //                End
86023>>>            //            End
86023>>>        End
86023>>>>
86023>>>
86023>>>        Close hTable
86024>>>        Move (not(Err)) to bOK
86025>>>        Function_Return bOK
86026>>>    End_Function
86027>>>
86027>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
86027>>>    // It will first drop all indicies, copy the data and then recreate indicies.
86027>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
86027>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
86029>>>        Boolean bOpened bOK
86029>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
86029>>>        String sErrorFile sEmpty sPath
86029>>>
86029>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
86032>>>        Get AutoConnectionIDLogin to bOK
86033>>>        If (sDriverID = DATAFLEX_ID) Begin
86035>>>            Send IncreaseSortBufferSize
86036>>>//            Send SetAllIndexesToBatch hToTable
86036>>>        End
86036>>>>
86036>>>
86036>>>        Move False to Err
86037>>>        Open sPhysicalName as hToTable
86039>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
86042>>>        If (bOpened = False) Begin
86044>>>            Function_Return False
86045>>>        End
86045>>>>
86045>>>
86045>>>        If (ghoStatusPanel <> 0) Begin
86047>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
86048>>>            Set piMinimum of ghoProgressBar to 0
86049>>>            Set piMaximum of ghoProgressBar to 100 // 100%
86050>>>        End
86050>>>>
86050>>>
86050>>>        Move "" to sEmpty
86051>>>        Move False to Err
86052>>>        Move True to bOK
86053>>>        Set Private.phCurrentTable to hToTable
86054>>>
86054>>>        // No need to get the record identifier
86054>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
86057>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86060>>>        If (sDriverID <> DATAFLEX_ID) Begin
86062>>>            // Remove all indices to speed up copying of data:
86062>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86067>>>            If (iRetval <> 0) Begin       
86069>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86070>>>>
86070>>>                Close hToTable
86071>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86074>>>                Function_Return False
86075>>>            End
86075>>>>
86075>>>        End
86075>>>>
86075>>>
86075>>>        Move (sRootName + ".err") to sErrorFile
86076>>>        Move 0 to iIndex
86077>>>        Move False to Err
86078>>>
86078>>>        If (sDriverID = MSSQLDRV_ID) Begin
86080>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
86083>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
86088>>>            If (iRetval <> 0) Begin
86090>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86091>>>>
86091>>>                Close hToTable
86092>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86095>>>                Function_Return False
86096>>>            End
86096>>>>
86096>>>        End
86096>>>>
86096>>>        Else Begin
86097>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
86100>>>        End
86100>>>>
86100>>>
86100>>>        If (Err = False) Begin
86102>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
86103>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
86104>>>        End
86104>>>>
86104>>>
86104>>>        If (sDriverID <> DATAFLEX_ID) Begin
86106>>>            // Recreate indices:
86106>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86111>>>            If (iRetval <> 0) Begin
86113>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86114>>>>
86114>>>                Close hToTable
86115>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86118>>>                Function_Return False
86119>>>            End
86119>>>>
86119>>>        End
86119>>>>
86119>>>
86119>>>        Close hToTable
86120>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86123>>>
86123>>>        If (bOK = True) Begin
86125>>>            Move (not(Err)) to bOK
86126>>>        End
86126>>>>
86126>>>
86126>>>        If (ghoStatusPanel <> 0) Begin
86128>>>            Set TableName_Text of ghoStatusPanel to ""
86129>>>            Set Message_Text   of ghoStatusPanel to ""
86130>>>            Set Action_Text    of ghoStatusPanel to ""
86131>>>        End
86131>>>>
86131>>>
86131>>>        Function_Return (bOK = True)
86132>>>    End_Function
86133>>>
86133>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
86133>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
86133>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
86135>>>        Handle hFile
86135>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
86135>>>        Integer iIdentityType iDataType iDbType iCount iSize
86135>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile
86135>>>        tSQLConnection SQLConnection
86135>>>        tSQLConnection SQLConnection
86135>>>        tAPIColumn[] aColumns
86135>>>        tAPIColumn[] aColumns
86136>>>        tColumnType ColumnType
86136>>>        tColumnType ColumnType
86136>>>
86136>>>        // First check if the passed filenumber already exists; in case we do nothing
86136>>>        Get UtilTableExists hTable to bOk
86137>>>        If (bOk = True) Begin
86139>>>            Function_Return False
86140>>>        End
86140>>>>
86140>>>
86140>>>        Set Private.phCurrentTable to hTable
86141>>>        Move sLogicalName to sTableName
86142>>>        If (ghoProgressBar <> 0) Begin
86144>>>            Send DoAdvance of ghoProgressBar
86145>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
86146>>>        End
86146>>>>
86146>>>
86146>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
86147>>>        Get psDriverID to sDriverID
86148>>>        Get IsSQLDriver sDriverID to bSqlDriver
86149>>>        Get piDbType to iDbType
86150>>>
86150>>>        // If no columns passed in, we need to create a "dummy" column
86150>>>        Move False to bDeleteDummy
86151>>>        If (Num_Arguments = 8) Begin
86153>>>            Move aColumnIn to aColumns
86154>>>        End
86154>>>>
86154>>>        If ((SizeOfArray(aColumns)) = 0) Begin
86156>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
86157>>>            Move ColumnType.iSQLType to iDataType
86158>>>            If (bRecnum = False) Begin
86160>>>                Move C_tAPIColumn_Identity to iIdentityType
86161>>>            End
86161>>>>
86161>>>            Else Begin
86162>>>                Move C_tAPIColumn_None     to iIdentityType
86163>>>            End
86163>>>>
86163>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
86164>>>            Move True to bDeleteDummy
86165>>>        End
86165>>>>
86165>>>
86165>>>        // If columns have been passed as an array we need to check if an identity column
86165>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
86165>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
86165>>>        // two identity columns and SQL doesn't like that and throws an error.
86165>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
86167>>>            Move (SizeOfArray(aColumns)) to iSize
86168>>>            Decrement iSize
86169>>>            for iCount from 0 to iSize
86175>>>>
86175>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
86177>>>                    Move False to bRecnum
86178>>>                    Move iSize to iCount
86179>>>                End
86179>>>>
86179>>>            Loop
86180>>>>
86180>>>        End
86180>>>>
86180>>>
86180>>>        // If this is a SQL based driver we also check if the table exists
86180>>>        // in the SQL back end; in case we do nothing.
86180>>>        If (bSqlDriver = True) Begin
86182>>>            // Get all connection properties
86182>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86183>>>            Move SQLConnection.sSchema to sSchema
86184>>>            If (sSchema = "") Begin
86186>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
86187>>>            End
86187>>>>
86187>>>
86187>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86188>>>            // It can happen that the table is missing from Filelist.cfg but still
86188>>>            // exist on the SQL side, in case we want to search for the table by its name.
86188>>>            If (bExists = False) Begin
86190>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
86191>>>            End
86191>>>>
86191>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
86191>>>            // we will just add it to Filelist.cfg
86191>>>            If (bExists = True) Begin
86193>>>                If (bExistsInFilelist = False) Begin
86195>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86197>>>                        Move (sDriverID + ":" + sRootName) to sRootName
86198>>>                    End
86198>>>>
86198>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86201>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86204>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86207>>>                    Move False to bSysFile
86208>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
86209>>>                End
86209>>>>
86209>>>                Function_Return False
86210>>>            End
86210>>>>
86210>>>        End
86210>>>>
86210>>>
86210>>>        Move CS_ANSI_Txt to sANSI_OEM
86211>>>        If (num_arguments > 6) Begin
86213>>>            If (bANSI = False) Begin
86215>>>                Move CS_OEM_Txt to sANSI_OEM
86216>>>            End
86216>>>>
86216>>>        End
86216>>>>
86216>>>
86216>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
86216>>>        // is a programmer's error and we auto-correct for it here.
86216>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
86216>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
86216>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
86216>>>        // set it back and use a Mertech function to convert it to SQL.
86216>>>        Get IsMertechDriver sDriverID to bMertechDriver
86217>>>        If (bMertechDriver = True) Begin
86219>>>            If (bUseConnectionID = True) Begin
86221>>>                Move False to bUseConnectionID
86222>>>            End
86222>>>>
86222>>>            Move sDriverID to sOriginalDriverID
86223>>>            Move DATAFLEX_ID to sDriverID
86224>>>        End
86224>>>>
86224>>>
86224>>>        Move False to Err
86225>>>        If (sDriverID = DATAFLEX_ID) Begin
86227>>>            Move sRootName to sPhysicalFile
86228>>>        End
86228>>>>
86228>>>
86228>>>        If (sDriverID <> DATAFLEX_ID) Begin
86230>>>            Move SQLConnection.sConnectionID to sConnectionID
86231>>>
86231>>>            // If DAW driver and we should use a connection id we need to
86231>>>            // check if the connection ID exists; else we create it before attempting creating the table
86231>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
86233>>>                Get IsConnectionID sConnectionID sDriverID to bExists
86234>>>                If (bExists = False) Begin
86236>>>                    Get AutoSetConnectionID sConnectionID to bOk
86237>>>                    If (bOk = False) Begin
86239>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86240>>>>
86240>>>                        Function_Return False
86241>>>                    End
86241>>>>
86241>>>                End
86241>>>>
86241>>>            End
86241>>>>
86241>>>
86241>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86243>>>                Move (sTableName + ".int") to sPhysicalFile
86244>>>            End
86244>>>>
86244>>>            Else Begin
86245>>>                Move (sRootName + ".int") to sPhysicalFile
86246>>>            End
86246>>>>
86246>>>            Move (Uppercase(sDisplayName)) to sVal
86247>>>//            If (not(sVal contains (sSchema + "."))) Begin
86247>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
86247>>>//            End
86247>>>        End
86247>>>>
86247>>>        Move False to Err
86248>>>        Move 0 to hFile
86249>>>
86249>>>        Structure_Start hFile sDriverID
86250>>>            If (sDriverID <> DATAFLEX_ID) Begin
86252>>>                If (bUseConnectionID = True) Begin
86254>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
86257>>>                End
86257>>>>
86257>>>                Else Begin
86258>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
86261>>>                End
86261>>>>
86261>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
86264>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
86267>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
86270>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
86273>>>
86273>>>                If (sSchema <> "") Begin
86275>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
86278>>>                End
86278>>>>
86278>>>
86278>>>                If (sDriverID = DB2_DRV_ID) Begin
86280>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
86282>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
86285>>>                    End
86285>>>>
86285>>>                End
86285>>>>
86285>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
86287>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
86289>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
86292>>>                    End
86292>>>>
86292>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
86294>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
86297>>>                    End
86297>>>>
86297>>>                End
86297>>>>
86297>>>            End
86297>>>>
86297>>>
86297>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
86300>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
86301>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86302>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86304>>>        Set Action_Text of ghoStatusPanel to ""
86305>>>
86305>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
86305>>>        If (bMertechDriver = True) Begin
86307>>>            Move sOriginalDriverID to sDriverID
86308>>>            If (not(sVal contains (sSchema + "."))) Begin
86310>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
86311>>>            End
86311>>>>
86311>>>            // Note: This function also sets the Err flag.
86311>>>            //Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
86311>>>        End
86311>>>>
86311>>>
86311>>>        Move (not(Err)) to bOK
86312>>>        If (bOk = True) Begin
86314>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86316>>>                Move (sDriverID + ":" + sRootName) to sRootName
86317>>>            End
86317>>>>
86317>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86320>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86323>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86326>>>
86326>>>            // Lastly we remove the temporary column we created above, if all went well.
86326>>>            If (bDeleteDummy) Begin
86328>>>                Get ApiColumnRemove hTable "temp" to bOk
86329>>>            End
86329>>>>
86329>>>        End
86329>>>>
86329>>>
86329>>>        Set TableName_Text of ghoStatusPanel to ""
86330>>>        Close hTable
86331>>>        Function_Return (bOK = True)
86332>>>    End_Function
86333>>>
86333>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
86335>>>        Move False to Err
86336>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
86339>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
86342>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
86345>>>
86345>>>        Function_Return (Err = False)
86346>>>    End_Function
86347>>>
86347>>>    // ToDo: Needs to be revised
86347>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
86349>>>        Handle hTable
86349>>>        String sDEFName sDataPath
86349>>>        Boolean bExists
86349>>>
86349>>>        // Do nothing if MSSQL Driver.
86349>>>//        Get IsMSSQLDriver to bExists
86349>>>//        If (bExists = True) Begin
86349>>>//            Procedure_Return
86349>>>//        End
86349>>>
86349>>>        Get psDataPathFirstPart to sDataPath
86350>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
86351>>>        If (bExists = True) Begin
86353>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
86353>>>            // still be missing from the filelist and needs to be added.
86353>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
86354>>>            If (bExists = True) Begin
86356>>>                Procedure_Return
86357>>>            End
86357>>>>
86357>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
86357>>>            Else Begin
86358>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
86361>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
86364>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
86367>>>                Procedure_Return
86368>>>            End
86368>>>>
86368>>>        End
86368>>>>
86368>>>
86368>>>        Move (sPath + sFileName + ".def") to sDEFName
86369>>>        Move 0 to hTable
86370>>>        Move False to Err
86371>>>
86371>>>        Structure_Start hTable DATAFLEX_ID
86372>>>            Load_Def sDEFName Onto hTable
86373>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
86376>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86377>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86379>>>        Set Action_Text of ghoStatusPanel to ""
86380>>>
86380>>>        Move iFilelistSlot to hTable
86381>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
86384>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86387>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86390>>>
86390>>>    End_Procedure
86391>>>
86391>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
86393>>>        Boolean bTmp bErr bOK
86393>>>        String sTableName sDisplayName sFileName
86393>>>
86393>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
86393>>>        Move Err to bTmp
86394>>>        Move False to Err
86395>>>
86395>>>        Get AutoConnectionIDLogin to bOK
86396>>>        // First get the info for the current filelist slot:
86396>>>        Open iFromFileSlot
86398>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
86401>>>        If (bOK = True) Begin
86403>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
86406>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
86409>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
86412>>>
86412>>>            //...then move it.
86412>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
86415>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
86418>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
86421>>>
86421>>>            //...and finally remove the old filelist values.
86421>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
86424>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
86427>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
86430>>>        End
86430>>>>
86430>>>        Close iFromFileSlot
86431>>>
86431>>>        Move Err to bErr
86432>>>        Move bTmp to Err
86433>>>        Function_Return (bErr = False)
86434>>>    End_Function
86435>>>
86435>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
86437>>>        Handle hTable
86437>>>        Boolean bOK
86437>>>        String sDriverID
86437>>>
86437>>>        Get UtilTableExists hTableFrom to bOK
86438>>>        If (bOK = False) Begin
86440>>>            Set Private.phCurrentTable to hTableFrom
86441>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86442>>>>
86442>>>            Function_Return False
86443>>>        End
86443>>>>
86443>>>
86443>>>        Get UtilTableExists hTableTo to bOK
86444>>>        If (bOK = False) Begin
86446>>>            Set Private.phCurrentTable to hTableTo
86447>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86448>>>>
86448>>>            Function_Return False
86449>>>        End
86449>>>>
86449>>>
86449>>>        Get AutoConnectionIDLogin to bOK
86450>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
86451>>>        If (bOK = False) Begin
86453>>>            Function_Return False
86454>>>        End
86454>>>>
86454>>>
86454>>>        Move False to Err
86455>>>        Open hTableTo
86457>>>
86457>>>        Move hTableFrom to hTable
86458>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86461>>>        Set Private.phCurrentTable to hTable
86462>>>
86462>>>        Structure_Start hTable sDriverID
86463>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
86466>>>            If (iColumnTo <> 0) Begin
86468>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
86471>>>            End
86471>>>>
86471>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86472>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86474>>>        Set Action_Text of ghoStatusPanel to ""
86475>>>
86475>>>        If (hTableTo > 0) Begin
86477>>>            Close hTableTo
86478>>>        End
86478>>>>
86478>>>
86478>>>        Function_Return (Err = False)
86479>>>    End_Function
86480>>>
86480>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
86480>>>    Function ApiTableRemove Handle hTable Returns Boolean
86482>>>        String sTableName sDriverID
86482>>>        Boolean bOk
86482>>>        String sDataPath
86482>>>
86482>>>        Get AutoConnectionIDLogin to bOK
86483>>>        Move False to Err
86484>>>        Get psDriverID to sDriverID
86485>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
86486>>>        If (sTableName = "") Begin
86488>>>            Function_Return False
86489>>>        End
86489>>>>
86489>>>
86489>>>        Set Private.phCurrentTable to hTable
86490>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
86491>>>        Delete_db sTableName
86492>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
86493>>>
86493>>>        If (sDriverID <> DATAFLEX_ID) Begin
86495>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
86495>>>            Get psDataPathFirstPart to sDataPath
86496>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
86497>>>        End
86497>>>>
86497>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
86497>>>        If (hTable <> 0) Begin
86499>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86502>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86505>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86508>>>        End
86508>>>>
86508>>>
86508>>>        Close hTable
86509>>>        Function_Return (hTable <> 0)
86510>>>    End_Function
86511>>>
86511>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
86513>>>        Handle hTable
86513>>>        Boolean bOK
86513>>>
86513>>>        Get AutoConnectionIDLogin to bOK
86514>>>        Move False to Err
86515>>>        Open hTableFrom Mode DF_EXCLUSIVE
86517>>>        Move hTableFrom to hTable
86518>>>
86518>>>        Structure_Start hTable
86519>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
86522>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86523>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86525>>>        Set Action_Text of ghoStatusPanel to ""
86526>>>
86526>>>        Close hTableFrom
86527>>>        Function_Return (Err = False)
86528>>>    End_Function
86529>>>
86529>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
86531>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
86531>>>        Boolean bOK bExists bOpened
86531>>>        tAPITableNameInfo APITableNameInfo
86531>>>        tAPITableNameInfo APITableNameInfo
86531>>>
86531>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86534>>>        If (bOpened = False) Begin
86536>>>            Get OpenTableExclusive hTable to bOpened
86537>>>            If (bOpened = False) Begin
86539>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
86540>>>                Function_Return False
86541>>>            End
86541>>>>
86541>>>        End
86541>>>>
86541>>>
86541>>>        Set Private.phCurrentTable to hTable
86542>>>        Move hTable         to APITableNameInfo.iTableNumber
86543>>>        Move sRootName      to APITableNameInfo.sRootName
86544>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
86545>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
86546>>>        Get ApiTableFilelistNamesCompare True APITableNameInfo to bExists
86547>>>        If (bExists = True) Begin
86549>>>            Function_Return True
86550>>>        End
86550>>>>
86550>>>
86550>>>        Set Private.phCurrentTable to hTable
86551>>>        Move False to Err
86552>>>        Get psDataPathFirstPart to sDataPath
86553>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
86556>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
86559>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
86562>>>
86562>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86565>>>        Close hTable
86566>>>        If (sDriverID = DATAFLEX_ID) Begin
86568>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
86569>>>            If (bExists = True) Begin
86571>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
86573>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
86576>>>                    // We need a short break here before attempting to delete the physical old files or Windows
86576>>>                    // might report "File in use..." and the deletion will fail.
86576>>>                    Sleep 2
86577>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
86578>>>                End
86578>>>>
86578>>>            End
86578>>>>
86578>>>        End
86578>>>>
86578>>>
86578>>>        If (sDriverID <> DATAFLEX_ID) Begin
86580>>>            If (not(sPhysicalName contains ".")) Begin
86582>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
86583>>>            End
86583>>>>
86583>>>
86583>>>            // Change the table name in the .int file to the new table new:
86583>>>            Get UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
86584>>>            If (bOK = False) Begin
86586>>>                Function_Return False
86587>>>            End
86587>>>>
86587>>>
86587>>>            // Change table name at the SQL side:
86587>>>            Get psSchema to sSchema
86588>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
86589>>>
86589>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
86590>>>            // Remove cache file and Rename the physical file names:
86590>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
86591>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
86592>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
86593>>>            Move (sDriverID + ":" + sRootName) to sRootName
86594>>>
86594>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86594>>>//            If (not(sDisplayName contains ".")) Begin
86594>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
86594>>>//            End
86594>>>        End
86594>>>>
86594>>>
86594>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86597>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86600>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86603>>>
86603>>>        Function_Return (Err = False)
86604>>>    End_Function
86605>>>
86605>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
86607>>>        Move False to Err
86608>>>        Set Private.phCurrentTable to hTable
86609>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86612>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86615>>>
86615>>>        Function_Return (Err = False)
86616>>>    End_Function
86617>>>
86617>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
86617>>>    // Note that it first removes any driver prefixes in the rootname.
86617>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
86619>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
86619>>>        Handle hTable
86619>>>        Boolean bIsSame
86619>>>
86619>>>        Move APITableInfo.iTableNumber      to hTable
86620>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
86621>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
86624>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
86625>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
86628>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
86631>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
86632>>>
86632>>>        If (bCompareFilelistUppercase = True) Begin
86634>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
86635>>>        End
86635>>>>
86635>>>        Else Begin
86636>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
86637>>>        End
86637>>>>
86637>>>
86637>>>        Function_Return bIsSame
86638>>>    End_Function
86639>>>
86639>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
86639>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
86641>>>        Handle hTable
86641>>>        String sTableName
86641>>>        String sDriverIDFrom sDriverIDTo
86641>>>        Integer iDbType
86641>>>        Boolean bOk bMertechDriver bOpened bApiTableUpdateAuto
86641>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
86641>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
86641>>>        tSQLConnection SQLConnection
86641>>>        tSQLConnection SQLConnection
86641>>>        tAPITable      APITableFrom APITableTo
86641>>>        tAPITable      APITableFrom APITableTo
86641>>>        tColumnType    ColumnType
86641>>>        tColumnType    ColumnType
86641>>>        tAPIColumnCompare[]   aAPIColumnCompare
86641>>>        tAPIColumnCompare[]   aAPIColumnCompare
86642>>>        tAPIIndexCompare[]    aAPIIndexCompare
86642>>>        tAPIIndexCompare[]    aAPIIndexCompare
86643>>>        tAPIRelationCompare[] aAPIRelationCompare
86643>>>        tAPIRelationCompare[] aAPIRelationCompare
86644>>>
86644>>>        // We don't allow changes to the framework's DbVersion table.
86644>>>        If (Lowercase(sTableName) = "dbversion") Begin
86646>>>            Function_Return False
86647>>>        End
86647>>>>
86647>>>
86647>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
86648>>>        Get piDbType                            to iDbType
86649>>>        Get pbRecnum                            to bRecnum
86650>>>        Get pbToANSI                            to bToANSI
86651>>>        Get pbCopyData                          to bCopyData
86652>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
86653>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
86654>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
86655>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
86656>>>        Get IsMertechDriver sDriverIDFrom       to bMertechDriver
86657>>>        Get pbUseConnectionID                   to bUseConnectionID
86658>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
86660>>>            Move False                          to bUseConnectionID
86661>>>        End
86661>>>>
86661>>>
86661>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
86662>>>        Set Private.phCurrentTable              to hTable
86663>>>        Get UtilTableExists  hTable             to bTableExists
86664>>>
86664>>>        If (ghoProgressBar <> 0) Begin
86666>>>            Send DoAdvance of ghoProgressBar
86667>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
86668>>>            Set Message_Text   of ghoStatusPanel to ""
86669>>>            Set Action_Text    of ghoStatusPanel to ""
86670>>>        End
86670>>>>
86670>>>
86670>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
86671>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
86672>>>        Get UtilTableIsSQL hTable               to bIsSQLTableTo
86673>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
86674>>>        Move True                               to APITableFrom.bFromTable
86675>>>        Move hTable                             to APITableFrom.hTable
86676>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
86677>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
86678>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
86679>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
86680>>>
86680>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
86682>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
86683>>>            If (bOk = True) Begin
86685>>>                Get ApiTableAttachToSql hTable True to bOk
86686>>>                Function_Return bOk
86687>>>            End 
86687>>>>
86687>>>        End
86687>>>>
86687>>>
86687>>>        If (bTableExists = True) Begin
86689>>>            If (bIsSQLTableTo = True) Begin
86691>>>                Get UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
86692>>>            End
86692>>>>
86692>>>
86692>>>            Get OpenTableExclusive hTable to bOpened
86693>>>            If (bOpened = False) Begin
86695>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
86696>>>                Function_Return False
86697>>>            End
86697>>>>
86697>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
86698>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
86699>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
86700>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
86701>>>        End
86701>>>>
86701>>>
86701>>>        Move False to Err
86702>>>        Case Begin
86702>>>            // Alias table:
86702>>>            Case (bIsAliasFrom = True)
86704>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
86705>>>                Case Break
86706>>>
86706>>>            // New Table:
86706>>>            Case (bTableExists = False)
86709>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
86710>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
86710>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
86712>>>                    Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
86713>>>                End                                                                 
86713>>>>
86713>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
86714>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
86715>>>                Case Break
86716>>>
86716>>>            // Update table:
86716>>>            Case (bTableExists = True)
86719>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
86720>>>                If (bIsSame = True) Begin
86722>>>                    Case Break
86723>>>                End
86723>>>>
86723>>>                If (bFilelistError = True) Begin
86725>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
86726>>>                    If (bOk = False) Begin
86728>>>                        Case Break
86729>>>                    End
86729>>>>
86729>>>                End
86729>>>>
86729>>>
86729>>>                If (ghoProgressBar <> 0) Begin
86731>>>                    Send DoAdvance of ghoProgressBar
86732>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
86733>>>                End
86733>>>>
86733>>>
86733>>>                // Columns:
86733>>>                Move True to bOk
86734>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
86735>>>                If (bIsSame = False) Begin
86737>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
86738>>>                End
86738>>>>
86738>>>                If (bOk = False) Begin
86740>>>                    Case Break
86741>>>                End
86741>>>>
86741>>>
86741>>>                // Indexes:
86741>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
86742>>>                If (bIsSame = False) Begin
86744>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
86745>>>                End
86745>>>>
86745>>>
86745>>>                // Relations:
86745>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
86746>>>                If (bIsSame = False) Begin
86748>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
86749>>>                    If (bOk = False) Begin
86751>>>                        Case Break
86752>>>                    End
86752>>>>
86752>>>                End
86752>>>>
86752>>>
86752>>>                Case Break
86753>>>
86753>>>            Case Else
86753>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
86754>>>>
86754>>>                Move False to bOk
86755>>>        Case End
86755>>>        
86755>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
86755>>>        // or convert an embedded table to SQL
86755>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
86757>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
86758>>>            If (bOk = False) Begin
86760>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
86761>>>            End
86761>>>>
86761>>>        End
86761>>>>
86761>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
86764>>>            Get SqlTableConvertToEmbedded hTable True to bOk
86765>>>        End
86765>>>>
86765>>>        
86765>>>        // Filelist Names:
86765>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
86766>>>        Close hTable
86767>>>        Set TableName_Text of ghoStatusPanel to ""
86768>>>
86768>>>        Function_Return (bOK = True)
86769>>>    End_Function
86770>>>
86770>>>    // * Dummy function for the Studio's Code Explorer *
86770>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
86772>>>        Function_Return False
86773>>>    End_Function
86774>>>
86774>>>    // Adds a column name to the passed table number.
86774>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
86776>>>        Integer iColumn iCount iFile iPrecision iLastErr
86776>>>        Boolean bExists bOK bInitializeValue bRetval bMertechDriver
86776>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
86776>>>
86776>>>        Get UtilColumnExists hTable sFieldName to bExists
86777>>>        If (bExists = True) Begin
86779>>>            Function_Return False
86780>>>        End
86780>>>>
86780>>>
86780>>>        Move False to Err
86781>>>        If (num_arguments > 4) Begin
86783>>>            Move iPrec to iPrecision
86784>>>        End
86784>>>>
86784>>>        If (num_arguments > 6) Begin
86786>>>            Move bInitVal to bInitializeValue
86787>>>            Move sColVal  to sColumnValue
86788>>>        End
86788>>>>
86788>>>        If (iType < -1490) Begin
86790>>>            Move (iType + 1500) to iType
86791>>>        End
86791>>>>
86791>>>
86791>>>        Move hTable to iFile
86792>>>        Get psDriverID to sDriverID
86793>>>        Get IsMertechDriver sDriverID to bMertechDriver
86794>>>        Get AutoConnectionIDLogin to bOK
86795>>>        Move False to Err
86796>>>        Move LastErr to iLastErr
86797>>>        Get OpenTableExclusive iFile to bOK
86798>>>//        Open iFile Mode DF_EXCLUSIVE
86798>>>        Set Private.phCurrentTable to hTable
86799>>>            MERTECH_WARNING_MESSAGE Disabled
86832>>>>
86832>>>        Structure_Start iFile sDriverID
86833>>>            Move 0 to iColumn
86834>>>            Set Private.piCurrentField to iColumn
86835>>>            Create_Field hTable At iColumn
86836>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
86839>>>            If (bMertechDriver = True) Begin
86841>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
86842>>>                Send Ignore_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
86843>>>            End
86843>>>>
86843>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
86846>>>            If (bMertechDriver = True) Begin
86848>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
86849>>>                Send Trap_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
86850>>>                Move False to Err
86851>>>                Move iLastErr to LastErr
86852>>>            End
86852>>>>
86852>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
86855>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
86858>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86859>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86861>>>            MERTECH_WARNING_MESSAGE Enabled
86894>>>>
86894>>>
86894>>>        Set Action_Text of ghoStatusPanel to ""
86895>>>
86895>>>        // If in development environment; create .fd file:
86895>>>        Open hTable
86897>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
86898>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
86899>>>        If (iCount > 1) Begin
86901>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
86902>>>        End
86902>>>>
86902>>>        Get vFolderExists sDDSrcPath to bExists
86903>>>        If (bExists = True) Begin
86905>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
86906>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86909>>>            Get _TableNameOnly sTableName to sTableName
86910>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
86912>>>        End
86912>>>>
86912>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
86914>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
86915>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
86916>>>            If (iCount > 1) Begin
86918>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
86919>>>            End
86919>>>>
86919>>>            Get vFolderFormat sDataPath to sDataPath
86920>>>            // Add the new column name to the .tag filen (if it doesn't exist):
86920>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
86920>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
86920>>>        End
86920>>>>
86920>>>        // Check for a default value
86920>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
86922>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
86923>>>        End
86923>>>>
86923>>>        Close hTable
86924>>>
86924>>>        Function_Return (Err = False)
86925>>>    End_Function
86926>>>
86926>>>    // Adds a column name to the passed table number.
86926>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
86928>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
86928>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
86928>>>        String sDdSrcPath sTableName
86928>>>
86928>>>        Get UtilColumnExists hTable sFieldName to bExists
86929>>>        Move False to Err
86930>>>        If (bExists = True) Begin
86932>>>            Function_Return False
86933>>>        End
86933>>>>
86933>>>        If (num_arguments > 4) Begin
86935>>>            Move iPrec to iPrecision
86936>>>        End
86936>>>>
86936>>>        If (iType < -1490) Begin
86938>>>            Move (iType + 1500) to iType
86939>>>        End
86939>>>>
86939>>>
86939>>>        Get AutoConnectionIDLogin to bOK
86940>>>        Move False to Err
86941>>>        Get UtilTableIsSql hTable to bIsSQLTypeTo
86942>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
86942>>>        // data types between Embedded and SQL, else we can't compare the data types. 
86942>>>        Get piDbType to iDbType
86943>>>        If (bIsSQLTypeTo = False) Begin
86945>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
86946>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
86948>>>                Move DF_DATE to iType
86949>>>            End
86949>>>>
86949>>>        End
86949>>>>
86949>>>
86949>>>        // Structure_start will change the value of hTable...
86949>>>        Move hTable to iFile
86950>>>        Get OpenTableExclusive iFile to bOK
86951>>>        If (bOK = False) Begin
86953>>>            Function_Return False
86954>>>        End
86954>>>>
86954>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
86957>>>
86957>>>        // If the passed column number is higher than the current number of fields
86957>>>        // in the table, this means we should _not_ insert a field but rather add
86957>>>        // a new field to the end:
86957>>>        If (iColumn > iNumberOfFields) Begin
86959>>>            Move 0 to iColumn
86960>>>        End
86960>>>>
86960>>>
86960>>>        Set Private.phCurrentTable to hTable
86961>>>        Set Private.piCurrentField to iColumn
86962>>>
86962>>>        Structure_Start iFile
86963>>>            Create_Field iFile At iColumn
86964>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
86967>>>            If (bIsSQLTypeTo = False) Begin
86969>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
86972>>>            End
86972>>>>
86972>>>            Else Begin
86973>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
86976>>>            End
86976>>>>
86976>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
86977>>>            If (bIsDateType = False) Begin
86979>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
86982>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
86985>>>            End
86985>>>>
86985>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86986>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86988>>>
86988>>>        Set Action_Text of ghoStatusPanel to ""
86989>>>        // If in development environment; create .fd file:
86989>>>        Open hTable
86991>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
86992>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
86993>>>        If (iCount > 1) Begin
86995>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
86996>>>        End
86996>>>>
86996>>>        Get vFolderExists sDDSrcPath to bExists
86997>>>        If (bExists = True) Begin
86999>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87000>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87003>>>            Get _TableNameOnly sTableName to sTableName
87004>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87006>>>        End
87006>>>>
87006>>>
87006>>>        // Check for a default value
87006>>>        Close hTable
87007>>>
87007>>>        Function_Return (Err = False)
87008>>>    End_Function
87009>>>
87009>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean
87009>>>//        Integer iColumn iCount iFile
87009>>>//        Boolean bExists bOK
87009>>>//        String sDdSrcPath sTableName
87009>>>//
87009>>>//        Get AutoConnectionIDLogin to bOK
87009>>>//        Move False to Err
87009>>>//
87009>>>//        // Structure_start will change the value of hTable...
87009>>>//        Move hTable to iFile
87009>>>//        Open iFile Mode DF_EXCLUSIVE
87009>>>//
87009>>>//        Structure_Start iFile
87009>>>//            Send ApiColumnsAddToTable iFile aColumns False
87009>>>//        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87009>>>//
87009>>>//        // If in development environment; create .fd file:
87009>>>//        Open hTable
87009>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87009>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87009>>>//        If (iCount > 1) Begin
87009>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87009>>>//        End
87009>>>//        Get vFolderExists sDDSrcPath to bExists
87009>>>//        If (bExists = True) Begin
87009>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath
87009>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87009>>>//            Get _TableNameOnly sTableName to sTableName
87009>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87009>>>//        End
87009>>>//        Close hTable
87009>>>//
87009>>>//        Function_Return (Err = False)
87009>>>//    End_Function
87009>>>
87009>>>    // To update all records for a table column with a fixed value.
87009>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
87011>>>        Integer iRecs iCurrErr iField iRecord
87011>>>        Boolean bRetval bOpen
87011>>>
87011>>>        Move 0 to iRecs
87012>>>        Move False to bRetval
87013>>>        Move Err to iCurrErr
87014>>>        Move False to Err
87015>>>
87015>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87018>>>        If (bOpen = False) Begin
87020>>>            Open hTable
87022>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87025>>>            If (bOpen = False) Begin
87027>>>                Function_Return bRetval
87028>>>            End
87028>>>>
87028>>>        End
87028>>>>
87028>>>
87028>>>        Field_Map hTable sFieldName to iField
87030>>>        If (iField <> 0) Begin
87032>>>            Set Private.phCurrentTable to hTable
87033>>>            Set Private.piCurrentField to iField
87034>>>            Clear hTable
87035>>>            Repeat
87035>>>>
87035>>>                Vfind hTable 0 GT
87037>>>                If (Found) Begin
87039>>>                    If (ghoStatusPanel <> 0) Begin
87041>>>                        Get_Field_Value hTable 0 to iRecord
87044>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
87045>>>                    End
87045>>>>
87045>>>                    Reread hTable
87049>>>                        Set_Field_Value hTable iField to sColumnValue
87052>>>                        SaveRecord hTable
87053>>>                    Unlock
87054>>>>
87054>>>                End
87054>>>>
87054>>>           Until (not(Found))
87056>>>        End
87056>>>>
87056>>>
87056>>>        Move (Err = False) to bRetval
87057>>>        Move iCurrErr to Err
87058>>>
87058>>>        Function_Return bRetval
87059>>>    End_Function
87060>>>
87060>>>    // Note: This can only be used from within a Structure_Start/End construct.
87060>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
87062>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
87062>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
87062>>>        String sFieldName sDriverID sTableName sDefaultValue
87062>>>
87062>>>//        Set Private.phCurrentTable to hTable
87062>>>        Get psDriverID to sDriverID
87063>>>        Get piDbType to iDbType
87064>>>        Get UtilTableHandleToString hTable to sTableName
87065>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
87066>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
87067>>>        Get UtilTableIsSQL hTable to bIsSqlTable
87068>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
87070>>>            Move True to bIsSqlTable
87071>>>        End
87071>>>>
87071>>>        Move False to bIsOpen
87072>>>        If (hTable > 0) Begin
87074>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87077>>>        End
87077>>>>
87077>>>        If (bIsOpen = True) Begin
87079>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87082>>>        End
87082>>>>
87082>>>        Else Begin
87083>>>            Get pbRecnum to bRecnumTable
87084>>>        End
87084>>>>
87084>>>
87084>>>        Move False to Err
87085>>>        Move (SizeOfArray(aColumns)) to iSize
87086>>>        Decrement iSize
87087>>>        for iCount from 0 to iSize
87093>>>>
87093>>>            Move aColumns[iCount].sFieldName to sFieldName
87094>>>            If (hTable > 0) Begin
87096>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87097>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87098>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
87101>>>                Move (Trim(sFieldName) <> "") to bFieldExists
87102>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87103>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87104>>>            End
87104>>>>
87104>>>            Else Begin
87105>>>                Move False to bFieldExists
87106>>>            End
87106>>>>
87106>>>
87106>>>            If (bFieldExists = False) Begin
87108>>>                Move 0 to iColumn
87109>>>                Create_Field hTable At iColumn
87110>>>            End
87110>>>>
87110>>>            Else Begin
87111>>>                Move iCount to iColumn
87112>>>            End
87112>>>>
87112>>>
87112>>>            Set Private.piCurrentField to iColumn
87113>>>
87113>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
87114>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
87117>>>
87117>>>            Move aColumns[iCount].iType to iType
87118>>>            Move (not(iType < -1490)) to bNativeType
87119>>>            If (iType < -1490) Begin
87121>>>                Move (iType + 1500) to iType
87122>>>            End
87122>>>>
87122>>>
87122>>>            If (bIsSqlTable = True) Begin
87124>>>                If (aColumns[iCount].bIsSQLType = True) Begin
87126>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
87127>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
87130>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
87133>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
87136>>>
87136>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
87137>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87139>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87140>>>                    End
87140>>>>
87140>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
87143>>>
87143>>>                End
87143>>>>
87143>>>                Else Begin
87144>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
87147>>>                End
87147>>>>
87147>>>            End
87147>>>>
87147>>>            Else Begin
87148>>>                If (bCreating = False) Begin
87150>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
87151>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87153>>>                        Move DF_DATE to iType
87154>>>                    End
87154>>>>
87154>>>                End
87154>>>>
87154>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
87157>>>            End
87157>>>>
87157>>>
87157>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
87158>>>            If (bIsDateType = False) Begin
87160>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
87163>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
87166>>>            End
87166>>>>
87166>>>
87166>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
87168>>>                Move 0 to iIndex
87169>>>                Create_Index hTable at iIndex
87170>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
87173>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
87176>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
87179>>>
87179>>>                // If we have an identity table - we must create a primary_key table.
87179>>>                If (bIsSqlTable = True) Begin
87181>>>                End
87181>>>>
87181>>>            End
87181>>>>
87181>>>        Loop
87182>>>>
87182>>>
87182>>>        Function_Return (Err = False)
87183>>>    End_Function
87184>>>
87184>>>    // Changes a field type, length and precision for the passed table number and field name
87184>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
87186>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
87186>>>        Boolean bOK bIsSqlTable
87186>>>        String sFieldNameTo
87186>>>
87186>>>        If (num_arguments > 4) Begin
87188>>>            Move iPrec to iPrecFrom
87189>>>        End
87189>>>>
87189>>>        If (iTypeFrom < -1490) Begin
87191>>>            Move (iTypeFrom + 1500) to iTypeFrom
87192>>>        End
87192>>>>
87192>>>
87192>>>        Get AutoConnectionIDLogin to bOK
87193>>>        Move False to Err
87194>>>        Get OpenTableExclusive hTable to bOK
87195>>>        If (bOK = False) Begin
87197>>>            Function_Return False
87198>>>        End
87198>>>>
87198>>>
87198>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87199>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87200>>>        Field_Map hTable sFieldNameFrom to iColumn
87202>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87203>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87204>>>        If (Err = True) Begin
87206>>>            Function_Return False
87207>>>        End
87207>>>>
87207>>>
87207>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
87210>>>        Get UtilTableIsSQL hTable to bIsSqlTable
87211>>>        If (bIsSqlTable = False) Begin
87213>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
87216>>>        End
87216>>>>
87216>>>        Else Begin
87217>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
87220>>>        End
87220>>>>
87220>>>        // Let the driver decide the other values;
87220>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
87223>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
87226>>>
87226>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
87228>>>            Function_Return False
87229>>>        End
87229>>>>
87229>>>
87229>>>        Set Private.phCurrentTable to hTable
87230>>>        Set Private.piCurrentField to iColumn
87231>>>
87231>>>        Structure_Start hTable
87232>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
87235>>>//            If (bIsSqlTable = False) Begin
87235>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87238>>>//            End
87238>>>//            Else Begin
87238>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87238>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
87238>>>//            End
87238>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
87241>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
87244>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87245>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87247>>>
87247>>>        Set Action_Text of ghoStatusPanel to ""
87248>>>        Function_Return (Err = False)
87249>>>    End_Function
87250>>>
87250>>>    // Changes a field type, length and precision for the passed table number and field name
87250>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
87252>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
87252>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
87252>>>        String sFieldNameTo sDriverIDTo
87252>>>        tColumnType ColumnType
87252>>>        tColumnType ColumnType
87252>>>
87252>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
87253>>>        Get piDbType to iDbType
87254>>>        If (num_arguments > 4) Begin
87256>>>            Move iPrec to iPrecFrom
87257>>>            Move iOpt  to iOptionFrom
87258>>>        End
87258>>>>
87258>>>        If (iTypeFrom < -1490) Begin
87260>>>            Move (iTypeFrom + 1500) to iTypeFrom
87261>>>        End
87261>>>>
87261>>>
87261>>>        Get AutoConnectionIDLogin to bOK
87262>>>        Move False to Err
87263>>>        Close hTable
87264>>>        Get OpenTableExclusive hTable to bOK
87265>>>        If (bOK = False) Begin
87267>>>            Function_Return False
87268>>>        End
87268>>>>
87268>>>
87268>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
87271>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
87274>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
87275>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87277>>>            Move DF_DATE to iDataFlexType
87278>>>        End
87278>>>>
87278>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
87281>>>
87281>>>        If (bIsSQLTableTo = True) Begin
87283>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
87286>>>        End
87286>>>>
87286>>>        Else Begin
87287>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
87290>>>        End
87290>>>>
87290>>>
87290>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
87293>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
87296>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
87299>>>
87299>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87299>>>        // data types between Embedded and SQL, else we can't compare the data types.
87299>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87301>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
87302>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87304>>>                Move DF_DATE to iTypeTo  
87305>>>            End
87305>>>>
87305>>>        End
87305>>>>
87305>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87308>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
87309>>>        End
87309>>>>
87309>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
87310>>>
87310>>>        If (bCompareDate_DateTime = False) Begin
87312>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
87313>>>            If (bSkip = True) Begin
87315>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87317>>>                    Function_Return True
87318>>>                End
87318>>>>
87318>>>            End
87318>>>>
87318>>>        End
87318>>>>
87318>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87321>>>            Function_Return True
87322>>>        End
87322>>>>
87322>>>
87322>>>        Set Private.phCurrentTable to hTable
87323>>>        Set Private.piCurrentField to iColumn
87324>>>
87324>>>        Structure_Start hTable
87325>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
87327>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
87330>>>            End
87330>>>>
87330>>>
87330>>>            If (bIsSameDataType = False) Begin
87332>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
87335>>>                If (bIsSQLTableTo = True) Begin
87337>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
87340>>>                End
87340>>>>
87340>>>            End
87340>>>>
87340>>>
87340>>>            If (iLengthFrom <> iLengthTo) Begin
87342>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
87345>>>            End
87345>>>>
87345>>>            If (iPrecFrom <> iPrecTo) Begin
87347>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
87350>>>            End
87350>>>>
87350>>>
87350>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
87352>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
87352>>>                If (bRecnumTable = True) Begin
87354>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
87357>>>                End
87357>>>>
87357>>>
87357>>>                // We might need to create an index here.
87357>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
87357>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
87357>>>                // index update checking logic.
87357>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
87360>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
87362>>>                    Create_Index hTable At iIndex
87363>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
87366>>>                End
87366>>>>
87366>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
87369>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
87372>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
87375>>>                If (bIsSQLTableTo = True) Begin
87377>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
87380>>>                End
87380>>>>
87380>>>            End
87380>>>>
87380>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87381>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87383>>>
87383>>>        Set Action_Text of ghoStatusPanel to ""
87384>>>        Function_Return (Err = False)
87385>>>    End_Function
87386>>>
87386>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
87388>>>        Boolean bOK
87388>>>
87388>>>        Get AutoConnectionIDLogin to bOK
87389>>>        Move False to Err
87390>>>        Get OpenTableExclusive hTable to bOK
87391>>>        If (bOK = False) Begin
87393>>>            Function_Return False
87394>>>        End
87394>>>>
87394>>>
87394>>>        Structure_Start hTable
87395>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
87398>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87399>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87401>>>
87401>>>        Set Action_Text of ghoStatusPanel to ""
87402>>>        Function_Return (Err = False)
87403>>>    End_Function
87404>>>
87404>>>    // To move an existing field to another position in a table.
87404>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
87406>>>        String sColumn sDriverID
87406>>>        Integer iType
87406>>>        Boolean bOK bIsDate
87406>>>
87406>>>        Close hTable
87407>>>        Get AutoConnectionIDLogin to bOK
87408>>>        Get OpenTableExclusive hTable to bOK
87409>>>        If (bOK = False) Begin
87411>>>            Function_Return False
87412>>>        End
87412>>>>
87412>>>
87412>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87415>>>        If (sDriverID = DFBTRDRV_ID) Begin
87417>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
87418>>>>
87418>>>            Function_Return False
87419>>>        End
87419>>>>
87419>>>
87419>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
87422>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
87425>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
87426>>>
87426>>>        Set Private.phCurrentTable to hTable
87427>>>        Set Private.piCurrentField to iOld
87428>>>
87428>>>//        If (bIsDate = False) Begin
87428>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
87428>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
87428>>>//        End
87428>>>//        Else Begin
87428>>>//            Move 6 to iLength
87428>>>//            Move 0 to iPrecision
87428>>>//        End
87428>>>
87428>>>        Move False to Err
87429>>>
87429>>>        Structure_Start hTable
87430>>>            Delete_Field hTable iOld
87431>>>            Create_Field hTable At iNew
87432>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
87435>>>
87435>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
87438>>>            If (bIsSQLType = False) Begin
87440>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87443>>>            End
87443>>>>
87443>>>            Else Begin
87444>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87447>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
87447>>>            End
87447>>>>
87447>>>
87447>>>            If (bIsDate = False) Begin
87449>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
87452>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
87455>>>            End
87455>>>>
87455>>>
87455>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87456>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87458>>>
87458>>>        Set Action_Text of ghoStatusPanel to ""
87459>>>        Function_Return (Err = False)
87460>>>    End_Function
87461>>>
87461>>>    // Deletes a column name for the passed table number (and column number).
87461>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
87463>>>        Integer iColumn
87463>>>        Boolean bOK
87463>>>
87463>>>        Get AutoConnectionIDLogin to bOK
87464>>>        Move False to Err
87465>>>        Close hTable
87466>>>        Get OpenTableExclusive hTable to bOK
87467>>>        If (bOK = False) Begin
87469>>>            Function_Return False
87470>>>        End
87470>>>>
87470>>>
87470>>>        If (not(Err)) Begin
87472>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87473>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87474>>>            Field_Map hTable sFieldName to iColumn
87476>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87477>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87478>>>            If (iColumn = 0) Begin
87480>>>                Move 0 to LastErr
87481>>>                Function_Return False
87482>>>            End
87482>>>>
87482>>>            Move False to Err
87483>>>
87483>>>            Set Private.phCurrentTable to hTable
87484>>>            Set Private.piCurrentField to iColumn
87485>>>
87485>>>            Structure_Start hTable
87486>>>                Delete_Field hTable iColumn
87487>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87488>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87490>>>            Set Action_Text of ghoStatusPanel to ""
87491>>>        End
87491>>>>
87491>>>        Else Begin
87492>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
87493>>>>
87493>>>        End
87493>>>>
87493>>>
87493>>>        Function_Return (Err = False)
87494>>>    End_Function
87495>>>
87495>>>    // Renames a field for the passed table number & old field name & new field name
87495>>>    // Returns True if no errors occured.
87495>>>    // Sample usage:
87495>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
87495>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
87497>>>        Integer iField
87497>>>        Boolean bOK bExists bIsOpen
87497>>>
87497>>>        Get UtilColumnExists hTable sNewFieldName to bExists
87498>>>        If (bExists = True) Begin
87500>>>            Function_Return False
87501>>>        End
87501>>>>
87501>>>
87501>>>        // Note: The Field_Map command does _not_ work if the table has been
87501>>>        //       opened exclusively, so we first open it in normal mode.
87501>>>        Close hTable
87502>>>        Open hTable
87504>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87507>>>        If (bIsOpen = False) Begin
87509>>>            Function_Return False
87510>>>        End
87510>>>>
87510>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87511>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87512>>>        Field_Map hTable sOldFieldName to iField
87514>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87515>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87516>>>
87516>>>        Get AutoConnectionIDLogin to bOK
87517>>>        Get OpenTableExclusive hTable to bOK
87518>>>        If (bOK = False) Begin
87520>>>            Function_Return False
87521>>>        End
87521>>>>
87521>>>
87521>>>        Move False to Err
87522>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87523>>>        Set Private.phCurrentTable to hTable
87524>>>        Set Private.piCurrentField to iField
87525>>>
87525>>>        If (iField > 0) Begin
87527>>>            Structure_Start hTable
87528>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
87531>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87532>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87534>>>        End
87534>>>>
87534>>>        Else Begin
87535>>>            Move 0 to LastErr
87536>>>            Move False to Err
87537>>>        End
87537>>>>
87537>>>
87537>>>        Set Action_Text of ghoStatusPanel to ""
87538>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87539>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87540>>>
87540>>>        Function_Return (Err = False)
87541>>>    End_Function
87542>>>
87542>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87544>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87544>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87545>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
87545>>>        Boolean bRenameField
87545>>>
87545>>>        Open hTable
87547>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87548>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87549>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87550>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
87553>>>        Move (iSize max iNumberOfFieldsTo) to iSize
87554>>>        Decrement iSize
87555>>>        for iCount from 0 to iSize
87561>>>>
87561>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87563>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87564>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87565>>>
87565>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
87567>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
87569>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
87570>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
87571>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
87573>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
87574>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
87575>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
87576>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
87577>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
87578>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
87579>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
87580>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
87581>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
87582>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
87583>>>                        Increment iItem
87584>>>                    End
87584>>>>
87584>>>                End
87584>>>>
87584>>>            End
87584>>>>
87584>>>        Loop
87585>>>>
87585>>>
87585>>>        Move False to Err
87586>>>        Move 0 to LastErr
87587>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87588>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87589>>>        Function_Return aAPIColumnsToInsert
87590>>>    End_Function
87591>>>
87591>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
87593>>>        Integer iSize iCount
87593>>>        Boolean bOK
87593>>>        tAPIColumn[] aColumnsTo
87593>>>        tAPIColumn[] aColumnsTo
87594>>>        tAPIColumnCompare[] aAPIColumnCompare
87594>>>        tAPIColumnCompare[] aAPIColumnCompare
87595>>>
87595>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
87596>>>        If (iSize = 0) Begin
87598>>>            Function_Return True
87599>>>        End
87599>>>>
87599>>>
87599>>>        Move False to Err
87600>>>        Decrement iSize
87601>>>        for iCount from 0 to iSize
87607>>>>
87607>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
87608>>>        Loop
87609>>>>
87609>>>
87609>>>        Function_Return bOK
87610>>>    End_Function
87611>>>
87611>>>    // Returns a struct array with fields that has the same names but different field numbers.
87611>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87613>>>        tAPIColumnCompare[] aAPIColumnsToMove
87613>>>        tAPIColumnCompare[] aAPIColumnsToMove
87614>>>        Integer iSize iCount iItem iShouldMove
87614>>>
87614>>>        Move 0 to iItem
87615>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87616>>>        Decrement iSize
87617>>>        for iCount from 0 to iSize
87623>>>>
87623>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87625>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
87626>>>                If (iShouldMove <> -1) Begin
87628>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
87629>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
87630>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
87631>>>                    Increment iItem
87632>>>                End
87632>>>>
87632>>>            End
87632>>>>
87632>>>        Loop
87633>>>>
87633>>>
87633>>>        Move False to Err
87634>>>        Move 0 to LastErr
87635>>>        Function_Return aAPIColumnsToMove
87636>>>    End_Function
87637>>>
87637>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
87639>>>        Integer iSize iCount
87639>>>        Boolean bOK
87639>>>        tAPIColumnCompare[] aAPIColumnCompare
87639>>>        tAPIColumnCompare[] aAPIColumnCompare
87640>>>
87640>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
87641>>>        If (iSize = 0) Begin
87643>>>            Function_Return True
87644>>>        End
87644>>>>
87644>>>
87644>>>        Move False to Err
87645>>>        Decrement iSize
87646>>>        for iCount from 0 to iSize
87652>>>>
87652>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87653>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87654>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
87656>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
87657>>>                Get UtilColumnsStructFill hTable to aColumnsTo
87658>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87659>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
87660>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
87662>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
87663>>>                    Decrement iSize
87664>>>                    Move 0 to iCount
87665>>>                End
87665>>>>
87665>>>            End
87665>>>>
87665>>>        Loop
87666>>>>
87666>>>
87666>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87667>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87668>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
87670>>>            Move 0 to LastErr
87671>>>        End
87671>>>>
87671>>>        Function_Return bOK
87672>>>    End_Function
87673>>>
87673>>>    // Checks if the "FROM" and "TO" database field is the same _except_ for the field name.
87673>>>    // We then assume this field should be renamed.
87673>>>//    Function UtilColumCheckRename Handle hTable tAPIColumnCompare aAPIColumnCompare Returns Boolean
87673>>>//        Boolean bDifferentFieldNames bShouldBeRenamed
87673>>>//
87673>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87673>>>//        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom) <> Uppercase(aAPIColumnCompare.sFieldNameTo)) to bDifferentFieldNames
87673>>>//
87673>>>//        If (bDifferentFieldNames = True) Begin
87673>>>//            Move (aAPIColumnCompare.iFieldNumber = aAPIColumnCompare.iFieldNumberTo) to bShouldBeRenamed
87673>>>//            If (bShouldBeRenamed = False) Begin
87673>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
87673>>>//                Function_Return False
87673>>>//            End
87673>>>//
87673>>>//            Move (aAPIColumnCompare.iTypeFrom = aAPIColumnCompare.iTypeTo) to bShouldBeRenamed
87673>>>//            If (bShouldBeRenamed = False) Begin
87673>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
87673>>>//                Function_Return False
87673>>>//            End
87673>>>//
87673>>>//            Move (aAPIColumnCompare.iLengthFrom = aAPIColumnCompare.iLengthTo) to bShouldBeRenamed
87673>>>//            If (bShouldBeRenamed = False) Begin
87673>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
87673>>>//                Function_Return False
87673>>>//            End
87673>>>//
87673>>>//            Move (aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo) to bShouldBeRenamed
87673>>>//            If (bShouldBeRenamed = False) Begin
87673>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
87673>>>//                Function_Return False
87673>>>//            End
87673>>>//        End
87673>>>//
87673>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
87673>>>//        Function_Return True
87673>>>//    End_Function
87673>>>
87673>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
87673>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
87673>>>    // - The "FROM" field name is <> "TO" field name
87673>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
87673>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
87673>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
87675>>>        Boolean bShouldRename
87675>>>        String sFieldNameFrom sFieldNameTo
87675>>>
87675>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
87676>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
87677>>>        If (sFieldNameFrom = sFieldNameTo) Begin
87679>>>            Function_Return False
87680>>>        End
87680>>>>
87680>>>
87680>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
87681>>>//        If (bShouldRename = False) Begin
87681>>>//            Function_Return False
87681>>>//        End
87681>>>//
87681>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
87681>>>//            Function_Return True
87681>>>//        End
87681>>>
87681>>>        Function_Return bShouldRename
87682>>>    End_Function
87683>>>
87683>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
87683>>>    // Else it returns the column/field number of the field that exists in another position.
87683>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
87685>>>        Integer iCount iSize iRetval
87685>>>        String sFieldNameFrom
87685>>>
87685>>>        Move -1 to iRetval
87686>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
87688>>>            Function_Return iRetval
87689>>>        End
87689>>>>
87689>>>
87689>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
87690>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87691>>>        Decrement iSize
87692>>>        for iCount from 0 to iSize
87698>>>>
87698>>>            // We're only interested in fields other than the passed field/column number:
87698>>>            If (iCount <> iColumn) Begin
87700>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
87702>>>                    Move (iCount + 1) to iRetval
87703>>>                End
87703>>>>
87703>>>            End
87703>>>>
87703>>>        Loop
87704>>>>
87704>>>
87704>>>        Move 0 to LastErr
87705>>>        Function_Return iRetval
87706>>>    End_Function
87707>>>
87707>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87709>>>        tAPIColumnCompare[] aAPIColumnsToRename
87709>>>        tAPIColumnCompare[] aAPIColumnsToRename
87710>>>        Integer iSize iCount iItem iFieldTo iShouldMove
87710>>>        Boolean bRenameField
87710>>>
87710>>>        Open hTable
87712>>>        Move 0 to iItem
87713>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87714>>>        Decrement iSize
87715>>>        for iCount from 0 to iSize
87721>>>>
87721>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87723>>>                // Check if the field exists in another position (other field number)
87723>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
87724>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
87725>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
87727>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
87728>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
87729>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
87730>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
87731>>>                    Increment iItem
87732>>>                End
87732>>>>
87732>>>            End
87732>>>>
87732>>>        Loop
87733>>>>
87733>>>
87733>>>        Move False to Err
87734>>>        Move 0 to LastErr
87735>>>        Function_Return aAPIColumnsToRename
87736>>>    End_Function
87737>>>
87737>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
87739>>>        Integer iSize iCount
87739>>>        Boolean bOK
87739>>>        tAPIColumn[] aColumnsTo
87739>>>        tAPIColumn[] aColumnsTo
87740>>>        tAPIColumnCompare[] aAPIColumnCompare
87740>>>        tAPIColumnCompare[] aAPIColumnCompare
87741>>>
87741>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
87742>>>        If (iSize = 0) Begin
87744>>>            Function_Return True
87745>>>        End
87745>>>>
87745>>>
87745>>>        Move False to Err
87746>>>        Decrement iSize
87747>>>        For iCount from 0 to iSize
87753>>>>
87753>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87754>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
87755>>>        Loop
87756>>>>
87756>>>
87756>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87757>>>        Function_Return bOK
87758>>>    End_Function
87759>>>
87759>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
87761>>>        Boolean bDateType
87761>>>
87761>>>        If (bIsSQLTableTo = True) Begin
87763>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
87764>>>        End
87764>>>>
87764>>>        Else Begin
87765>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
87766>>>        End
87766>>>>
87766>>>
87766>>>        Function_Return bDateType
87767>>>    End_Function
87768>>>
87768>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
87770>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
87770>>>        Integer iCount2 iColumn2
87770>>>        Handle hFile
87770>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
87770>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
87770>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
87770>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
87770>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
87775>>>        tColumnType ColumnType
87775>>>        tColumnType ColumnType
87775>>>
87775>>>        Move False to Err
87776>>>        Close hTable
87777>>>        Get OpenTableExclusive hTable to bIsOpen
87778>>>        If (bIsOpen = False) Begin
87780>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
87781>>>>
87781>>>            Function_Return False
87782>>>        End 
87782>>>>
87782>>>        
87782>>>        Get piDbType to iDbType
87783>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87786>>>        Move bIsSQLTableFrom to bIsSQLDriver
87787>>>        Get UtilTableIsSQL hTable to bIsSQLTableTo
87788>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
87791>>>
87791>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87792>>>
87792>>>        // Before we start to change the table we need to do three things;
87792>>>        // 1) Insert any new fields
87792>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
87793>>>        If (SizeOfArray(aApiInsertColumns)) Begin
87795>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
87796>>>            If (bOK = False) Begin
87798>>>                Function_Return False
87799>>>            End
87799>>>>
87799>>>            // Update info with changes made.
87799>>>            Get UtilColumnsStructFill hTable to aColumnsTo
87800>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87801>>>        End
87801>>>>
87801>>>
87801>>>        // 2) Move fields with same names
87801>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
87802>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
87804>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
87805>>>            If (bOK = False) Begin
87807>>>                Function_Return False
87808>>>            End
87808>>>>
87808>>>            Get UtilColumnsStructFill hTable to aColumnsTo
87809>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87810>>>        End
87810>>>>
87810>>>        
87810>>>        // 3) Rename fields
87810>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
87811>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
87813>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
87814>>>            If (bOK = False) Begin
87816>>>                Function_Return False
87817>>>            End
87817>>>>
87817>>>            Get UtilColumnsStructFill hTable to aColumnsTo
87818>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87819>>>        End
87819>>>>
87819>>>
87819>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
87819>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
87819>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
87819>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
87819>>>//            If (bOK = False) Begin
87819>>>//                Function_Return False
87819>>>//            End
87819>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
87819>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87819>>>//        End
87819>>>
87819>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
87819>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
87821>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
87822>>>            If (bIsSame = True) Begin
87824>>>                Function_Return True
87825>>>            End
87825>>>>
87825>>>        End
87825>>>>
87825>>>
87825>>>        // We can now continue to make standard field changes:
87825>>>        Get OpenTableExclusive hTable to bIsOpen
87826>>>        Set Private.phCurrentTable to hTable
87827>>>        Move hTable to hFile
87828>>>        Structure_Start hFile sDriverIDTo
87829>>>
87829>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
87830>>>            Decrement iColumns
87831>>>            for iCount from 0 to iColumns
87837>>>>
87837>>>                Send DoAdvance of ghoProgressBar
87838>>>
87838>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
87839>>>                Set Private.piCurrentField                  to iColumn
87840>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
87841>>>                If (bIsSame = False) Begin
87843>>>
87843>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
87844>>>                    If (bFieldExistsFrom = True) Begin
87846>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
87847>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
87848>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
87849>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
87850>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
87851>>>
87851>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
87852>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
87853>>>                        If (iTypeFrom < -1490) Begin
87855>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
87856>>>                        End
87856>>>>
87856>>>
87856>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
87856>>>                        // data types between Embedded and SQL, else we can't compare the data types.
87856>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87858>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
87859>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87861>>>                                Move DF_DATE to iTypeFrom
87862>>>                            End
87862>>>>
87862>>>                        End
87862>>>>
87862>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87865>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
87866>>>                        End
87866>>>>
87866>>>
87866>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
87867>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
87868>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
87869>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
87870>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
87871>>>
87871>>>                        Move False to bSkipTypeChange
87872>>>                        If (bCompareDate_DateTime = False) Begin
87874>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
87875>>>                        End
87875>>>>
87875>>>
87875>>>                        If (bFieldExistsTo = False) Begin
87877>>>                            Move 0 to iColumn
87878>>>                            Create_Field hFile At iColumn
87879>>>                            Set Private.piCurrentField to iColumn
87880>>>                        End
87880>>>>
87880>>>
87880>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
87882>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
87885>>>                        End
87885>>>>
87885>>>
87885>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
87887>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
87890>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
87891>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87893>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87894>>>                            End
87894>>>>
87894>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
87897>>>                        End
87897>>>>
87897>>>
87897>>>                        If (bSkipTypeChange = False) Begin
87899>>>                            If (iTypeFrom <> iTypeTo) Begin
87901>>>                                If (bIsSQLTableTo = True) Begin
87903>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
87906>>>                                End
87906>>>>
87906>>>                                Else Begin                                                   
87907>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87909>>>                                        Move DF_DATE to iDataFlexType  // Date
87910>>>                                    End
87910>>>>
87910>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
87913>>>                                End
87913>>>>
87913>>>                            End
87913>>>>
87913>>>                        End
87913>>>>
87913>>>
87913>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
87914>>>                        // We can't set the length or precision for Date type columns (they are fixed).
87914>>>                        If (bIsDateType = False) Begin
87916>>>                            If (iLengthFrom <> iLengthTo) Begin
87918>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
87921>>>                            End
87921>>>>
87921>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
87923>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
87926>>>                            End
87926>>>>
87926>>>                        End
87926>>>>
87926>>>
87926>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
87928>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
87928>>>                            If (bRecnumTable = True) Begin
87930>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
87933>>>                            End
87933>>>>
87933>>>
87933>>>                            // We might need to create an index here.
87933>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
87933>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
87933>>>                            // index update checking logic.
87933>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
87936>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
87938>>>                                Create_Index hFile at iIndex
87939>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
87942>>>                            End
87942>>>>
87942>>>
87942>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
87945>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
87948>>>                                // Note: The order of these two are crucial!
87948>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
87951>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
87954>>>                        End
87954>>>>
87954>>>                    End
87954>>>>
87954>>>                    Else Begin
87955>>>                        Delete_Field hFile iColumn
87956>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
87957>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
87958>>>                        Decrement iCount2
87959>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
87959>>>                        // starting with the array number we just deleted the field for.
87959>>>                        for iColumn2 from iCount to iCount2
87965>>>>
87965>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
87966>>>                        Loop
87967>>>>
87967>>>                        Decrement iCount
87968>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87969>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
87970>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
87972>>>                            Move iColumns to iCount 
87973>>>                        End
87973>>>>
87973>>>                    End
87973>>>>
87973>>>                End
87973>>>>
87973>>>            Loop
87974>>>>
87974>>>
87974>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87975>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87977>>>
87977>>>        Set Action_Text of ghoStatusPanel to ""
87978>>>        Function_Return (Err = False)
87979>>>    End_Function
87980>>>
87980>>>    // * Dummy function for the Studio's Code Explorer *
87980>>>    Function API_INDEX_FUNCTIONS Returns Boolean
87982>>>        Function_Return False
87983>>>    End_Function
87984>>>
87984>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
87984>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
87984>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
87984>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
87986>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
87986>>>        String sDriverID
87986>>>        Boolean bOK bExists bIsMertechDriver bIsSQLTable
87986>>>
87986>>>        Get AutoConnectionIDLogin to bOK
87987>>>        Get OpenTableExclusive hTable to bOK
87988>>>        If (bOK = False) Begin
87990>>>            Function_Return False
87991>>>        End
87991>>>>
87991>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87994>>>
87994>>>            Get UtilTableIsSQL hTable to bIsSQLTable
87995>>>            If (bIsSQLTable = True) Begin
87997>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88000>>>            End
88000>>>>
88000>>>
88000>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
88001>>>            If (bIsMertechDriver = True) Begin
88003>>>                Get_Attribute DF_INDEX_NATIVE_CREATED of hTable iIndex to bExists
88006>>>            End
88006>>>>
88006>>>            Else Begin
88007>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
88010>>>                Move (iIndexSegments > 0) to bExists
88011>>>            End
88011>>>>
88011>>>        If (bExists = True) Begin
88013>>>            Function_Return True
88014>>>        End
88014>>>>
88014>>>
88014>>>        Move -1 to iSegment1
88015>>>        Move -1 to iSegment2
88016>>>        Move -1 to iSegment3
88017>>>        Move -1 to iSegment4
88018>>>        Move -1 to iSegment5
88019>>>        Move -1 to iSegment6
88020>>>        Move -1 to iSegment7
88021>>>        Move -1 to iSegment8
88022>>>        Move -1 to iSegment9
88023>>>        Move -1 to iSegment10
88024>>>
88024>>>        If (num_arguments > 3) Begin
88026>>>            Move iSgmnt1 to iSegment1
88027>>>        End
88027>>>>
88027>>>        If (num_arguments > 4) Begin
88029>>>            Move iSgmnt2 to iSegment2
88030>>>        End
88030>>>>
88030>>>        If (num_arguments > 5) Begin
88032>>>            Move iSgmnt3 to iSegment3
88033>>>        End
88033>>>>
88033>>>        If (num_arguments > 6) Begin
88035>>>            Move iSgmnt4 to iSegment4
88036>>>        End
88036>>>>
88036>>>        If (num_arguments > 7) Begin
88038>>>            Move iSgmnt5 to iSegment5
88039>>>        End
88039>>>>
88039>>>        If (num_arguments > 8) Begin
88041>>>            Move iSgmnt6 to iSegment6
88042>>>        End
88042>>>>
88042>>>        If (num_arguments > 9) Begin
88044>>>            Move iSgmnt7 to iSegment7
88045>>>        End
88045>>>>
88045>>>        If (num_arguments > 10) Begin
88047>>>            Move iSgmnt8 to iSegment8
88048>>>        End
88048>>>>
88048>>>        If (num_arguments > 11) Begin
88050>>>            Move iSgmnt9 to iSegment9
88051>>>        End
88051>>>>
88051>>>        If (num_arguments > 12) Begin
88053>>>            Move iSgmnt10 to iSegment10
88054>>>        End
88054>>>>
88054>>>
88054>>>        Move False to Err
88055>>>        Move hTable to iTableNo
88056>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88057>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88058>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88059>>>
88059>>>        // We start by deleting the index, if it exists.
88059>>>        If (bExists = True) Begin
88061>>>            Structure_Start hTable sDriverID
88062>>>                Delete_Index iTableNo iIndex
88063>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88064>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88066>>>        End
88066>>>>
88066>>>
88066>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88067>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88068>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88069>>>        Set Action_Text of ghoStatusPanel to ""
88070>>>        Move False to Err
88071>>>        Move 0 to LastErr
88072>>>
88072>>>        // Need to re-open if index deleted.
88072>>>        Move iTableNo to hTable
88073>>>        Get OpenTableExclusive hTable to bOK
88074>>>        If (bOK = False) Begin
88076>>>            Function_Return False
88077>>>        End
88077>>>>
88077>>>
88077>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88078>>>        Structure_Start hTable sDriverID
88079>>>            Create_Index hTable At iIndex
88080>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88083>>>
88083>>>            If (iSgmnt1 <> -1) Begin
88085>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88088>>>            End
88088>>>>
88088>>>            If (iSegment2 <> -1) Begin
88090>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88093>>>            End
88093>>>>
88093>>>            If (iSegment3 <> -1) Begin
88095>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88098>>>            End
88098>>>>
88098>>>            If (iSegment4 <> -1) Begin
88100>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88103>>>            End
88103>>>>
88103>>>            If (iSegment5 <> -1) Begin
88105>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88108>>>            End
88108>>>>
88108>>>            If (iSegment6 <> -1) Begin
88110>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88113>>>            End
88113>>>>
88113>>>            If (iSegment7 <> -1) Begin
88115>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88118>>>            End
88118>>>>
88118>>>            If (iSegment8 <> -1) Begin
88120>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88123>>>            End
88123>>>>
88123>>>            If (iSegment9 <> -1) Begin
88125>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88128>>>            End
88128>>>>
88128>>>            If (iSegment10 <> -1) Begin
88130>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
88133>>>            End
88133>>>>
88133>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88134>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88136>>>
88136>>>        Set Action_Text of ghoStatusPanel to ""
88137>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88138>>>
88138>>>        Function_Return (Err = False)
88139>>>    End_Function
88140>>>
88140>>>    // Example:
88140>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
88140>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
88140>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
88142>>>        Integer iTableNo iNumSgmnt iNumSgmnts
88142>>>        String sDriverID
88142>>>        Boolean bOK bIsSQLTable
88142>>>
88142>>>        Get AutoConnectionIDLogin to bOK
88143>>>
88143>>>        Move False to Err
88144>>>        Move hTable to iTableNo
88145>>>        Get OpenTableExclusive hTable to bOK
88146>>>        If (bOK = False) Begin
88148>>>            Function_Return False
88149>>>        End
88149>>>>
88149>>>
88149>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88152>>>            Get UtilTableIsSQL hTable to bIsSQLTable
88153>>>            If (bIsSQLTable = True) Begin
88155>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88158>>>            End
88158>>>>
88158>>>
88158>>>        // We start by deleting the index
88158>>>        Structure_Start hTable sDriverID
88159>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88160>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88161>>>            Delete_Index iTableNo iIndex
88162>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88163>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88164>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88166>>>
88166>>>        Move False to Err
88167>>>        Move iTableNo to hTable
88168>>>        Get OpenTableExclusive hTable to bOK
88169>>>        If (bOK = False) Begin
88171>>>            Function_Return False
88172>>>        End
88172>>>>
88172>>>
88172>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88173>>>        Structure_Start hTable sDriverID
88174>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
88175>>>
88175>>>            Create_Index hTable at iIndex
88176>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
88179>>>
88179>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
88185>>>>
88185>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
88188>>>            Loop
88189>>>>
88189>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88191>>>
88191>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88192>>>
88192>>>        Function_Return (Err = False)
88193>>>    End_Function
88194>>>
88194>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
88196>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
88196>>>        String sDriverID sSQLIndexName
88196>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
88196>>>
88196>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
88197>>>        If (iSegmentsFrom = 0) Begin
88199>>>            Function_Return False
88200>>>        End
88200>>>>
88200>>>
88200>>>        Get AutoConnectionIDLogin to bOK
88201>>>        Move False to Err
88202>>>        Get OpenTableExclusive hTable to bIsOpen
88203>>>        If (bIsOpen = False) Begin
88205>>>            Function_Return False
88206>>>        End
88206>>>>
88206>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88209>>>        Get UtilTableIsSql hTable to bIsSQLTable
88210>>>            If (bIsSQLTable = True) Begin
88212>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88215>>>            End
88215>>>>
88215>>>
88215>>>        Move 0     to iSegmentsTo
88216>>>        Move 0     to iSQLIndexType
88217>>>        Move ""    to sSQLIndexName
88218>>>        Move False to bIsSQLTemporaryIndex
88219>>>        Move False to bIsSQLPrimaryKey
88220>>>        Move False to bIsSQLClustered
88221>>>
88221>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
88222>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
88225>>>        Move (iSegmentsTo > 0) to bExists
88226>>>        If (bExists = True) Begin
88228>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
88230>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
88233>>>                    Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
88236>>>                    Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
88237>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
88240>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
88243>>>            End
88243>>>>
88243>>>        End
88243>>>>
88243>>>
88243>>>        Move hTable to iTableNo
88244>>>        Move False to Err
88245>>>        Move 0 to LastErr
88246>>>
88246>>>        // Note: If the SQL index type = DF_INDEX_TEMPORARY, we _must_ set the DF_INDEX_SQL_TYPE
88246>>>        //       _outside_ the Structure_Start/End construct.
88246>>>//        Move False to bIsSQLTemporaryIndex
88246>>>//        #IF (!@ > 170)
88246>>>//            If (bIsSQLTemporaryIndex = True and APIIndex.iIndexNumber <= iLastIndex) Begin
88246>>>//                If (APIIndex.iSQLIndexType <> iSQLIndexType) Begin
88246>>>//                    Set_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
88246>>>//                End
88246>>>//            End
88246>>>//        #ENDIF
88246>>>
88246>>>        Structure_Start hTable sDriverID
88247>>>            If (bExists = True) Begin
88249>>>                Delete_Index iTableNo APIIndex.iIndexNumber
88250>>>            End
88250>>>>
88250>>>
88250>>>            Create_Index hTable At APIIndex.iIndexNumber
88251>>>
88251>>>            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
88253>>>                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
88256>>>                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
88259>>>                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
88262>>>                Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
88265>>>            End
88265>>>>
88265>>>
88265>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
88268>>>
88268>>>            for iCount from 0 to (iSegmentsFrom -1)
88274>>>>
88274>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
88275>>>                If (iFieldFrom <> -1 ) Begin
88277>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
88280>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
88283>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
88286>>>                End
88286>>>>
88286>>>            Loop
88287>>>>
88287>>>
88287>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88288>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88290>>>
88290>>>        Set Action_Text of ghoStatusPanel to ""
88291>>>
88291>>>        Function_Return (Err = False)
88292>>>    End_Function
88293>>>
88293>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
88293>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
88293>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
88295>>>        Integer iLastIndex iCount iTableNo iSegments
88295>>>        String sSQLIndexNameCompare sTmpIndexName
88295>>>        Boolean bIsOpen bExists bIsSQLDriver bIsMertechDriver
88295>>>
88295>>>        // The Mertech drivers DF_INDEX_NAME property is read_only,
88295>>>        // so we can then not rename the index.
88295>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
88296>>>        If (bIsMertechDriver = True) Begin
88298>>>            Function_Return False
88299>>>        End    
88299>>>>
88299>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88300>>>        
88300>>>        If (bIsSQLDriver = False) Begin
88302>>>            Function_Return False
88303>>>        End
88303>>>>
88303>>>
88303>>>        Move False to Err
88304>>>        Move hTable to iTableNo
88305>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
88308>>>        for iCount from 0 to iLastIndex
88314>>>>
88314>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
88317>>>            Move (iSegments > 0) to bExists
88318>>>            If (bExists = True) Begin
88320>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
88323>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
88325>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
88326>>>                    Structure_Start iTableNo sDriverID
88327>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
88330>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88332>>>                    Open hTable
88334>>>                End
88334>>>>
88334>>>            End
88334>>>>
88334>>>        Loop
88335>>>>
88335>>>
88335>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88338>>>        If (bIsOpen = False) Begin
88340>>>            Get OpenTableExclusive hTable to bIsOpen
88341>>>        End
88341>>>>
88341>>>        If (bIsOpen = False) Begin
88343>>>            Function_Return False
88344>>>        End
88344>>>>
88344>>>
88344>>>        Function_Return (Err = False)
88345>>>    End_Function
88346>>>
88346>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
88346>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
88346>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
88348>>>        Integer iSize iCount
88348>>>        Integer iRetVal
88348>>>
88348>>>        Move 0 to iRetVal
88349>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
88352>>>        If (iRetVal = 0) Begin
88354>>>            Function_Return 0
88355>>>        End
88355>>>>
88355>>>        Move (SizeOfArray(APIIndexTo)) to iSize
88356>>>        Decrement iSize
88357>>>        for iCount from 0 to iSize
88363>>>>
88363>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
88365>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
88367>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
88368>>>                End
88368>>>>
88368>>>            End
88368>>>>
88368>>>        Loop
88369>>>>
88369>>>
88369>>>        Function_Return iRetVal
88370>>>    End_Function
88371>>>
88371>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88373>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88373>>>        Boolean bIsSQLTable
88373>>>        
88373>>>            Get UtilTableIsSQL hTable to bIsSQLTable
88374>>>            If (bIsSQLTable = True) Begin
88376>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88379>>>            End
88379>>>>
88379>>>
88379>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88382>>>        If (iSegment = iNumSegments) Begin
88384>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88384>>>        End
88384>>>>
88384>>>
88384>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88387>>>            for iCurSegment from iSegment to (iNumSegments - 1)
88393>>>>
88393>>>                //*** Move index segment attributes
88393>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88396>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88399>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88402>>>
88402>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
88405>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
88408>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
88411>>>            Loop
88412>>>>
88412>>>
88412>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88415>>>        End
88415>>>>
88415>>>
88415>>>        Function_Return (Err = False)
88416>>>    End_Function
88417>>>
88417>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
88419>>>        Integer iCount iSize iIndex
88419>>>        String sDriverID
88419>>>        Boolean bOK bIsSQLTable bIsOpen
88419>>>
88419>>>        Move (SizeOfArray(APIIndex)) to iSize
88420>>>        If (iSize = 0) Begin
88422>>>            Function_Return True
88423>>>        End
88423>>>>
88423>>>
88423>>>        Get AutoConnectionIDLogin to bOK
88424>>>        Move False to Err
88425>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88428>>>        If (bIsOpen = False) Begin
88430>>>            Get OpenTableExclusive hTable to bIsOpen
88431>>>            If (bIsOpen = False) Begin
88433>>>                Function_Return False
88434>>>            End
88434>>>>
88434>>>        End
88434>>>>
88434>>>
88434>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88437>>>        Get UtilTableIsSql hTable to bIsSQLTable
88438>>>            If (bIsSQLTable = True) Begin
88440>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88443>>>            End
88443>>>>
88443>>>
88443>>>        Move False to Err
88444>>>        Move 0 to LastErr
88445>>>        Decrement iSize
88446>>>
88446>>>        Structure_Start hTable sDriverID
88447>>>            for iCount from 0 to iSize
88453>>>>
88453>>>//                Move False to bIsSQLPrimaryKey
88453>>>//                #IF (!@ > 180)   // DF 18.1 and up
88453>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88453>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
88453>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88453>>>//                #ENDIF
88453>>>                // We can't delete if this is a primary key index:
88453>>>//                If (bIsSQLPrimaryKey = False) Begin
88453>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
88454>>>                    Delete_Index hTable iIndex
88455>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88455>>>//                End
88455>>>            Loop
88456>>>>
88456>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88457>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88459>>>//        Move False to Err
88459>>>        Move 0 to LastErr
88460>>>
88460>>>        Set Action_Text of ghoStatusPanel to ""
88461>>>        Function_Return (Err = False)
88462>>>    End_Function
88463>>>
88463>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
88465>>>        Boolean bOK
88465>>>
88465>>>        Get AutoConnectionIDLogin to bOK
88466>>>        Move False to Err
88467>>>        Get OpenTableExclusive hTable to bOK
88468>>>        If (bOK = False) Begin
88470>>>            Function_Return False
88471>>>        End
88471>>>>
88471>>>        Structure_Start hTable
88472>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
88475>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88476>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88478>>>
88478>>>        Set Action_Text of ghoStatusPanel to ""
88479>>>        Function_Return (Err = False)
88480>>>    End_Function
88481>>>
88481>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
88483>>>        Integer iCase
88483>>>        Boolean bOK
88483>>>
88483>>>        If (bUppercase = True) Begin
88485>>>            Move DF_CASE_IGNORED to iCase
88486>>>        End
88486>>>>
88486>>>        Else Begin
88487>>>            Move DF_CASE_USED to iCase
88488>>>        End
88488>>>>
88488>>>
88488>>>        Get AutoConnectionIDLogin to bOK
88489>>>        Move False to Err
88490>>>        Get OpenTableExclusive hTable to bOK
88491>>>        If (bOK = False) Begin
88493>>>            Function_Return False
88494>>>        End
88494>>>>
88494>>>        Structure_Start hTable
88495>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
88498>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88499>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88501>>>
88501>>>        Set Action_Text of ghoStatusPanel to ""
88502>>>        Function_Return (Err = False)
88503>>>    End_Function
88504>>>
88504>>>    // To delete an index
88504>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
88506>>>        Integer iTableNo iNumSegments
88506>>>        String sDriverID
88506>>>        Boolean bOK bIsSQLTable
88506>>>
88506>>>        Get AutoConnectionIDLogin to bOK
88507>>>        Move False to Err
88508>>>        Move hTable to iTableNo
88509>>>        Get OpenTableExclusive hTable to bOK
88510>>>        If (bOK = False) Begin
88512>>>            Function_Return False
88513>>>        End
88513>>>>
88513>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88516>>>            Get UtilTableIsSQL hTable to bIsSQLTable
88517>>>            If (bIsSQLTable = True) Begin
88519>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88522>>>            End
88522>>>>
88522>>>
88522>>>        // Check to see if the index exists or not...
88522>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88525>>>        If (iNumSegments = 0) Begin
88527>>>            Function_Return True // Then nothing to do.
88528>>>        End
88528>>>>
88528>>>
88528>>>        Structure_Start hTable sDriverID
88529>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88530>>>            Delete_Index iTableNo iIndex
88531>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88532>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88533>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88535>>>
88535>>>        Set Action_Text of ghoStatusPanel to ""
88536>>>        Function_Return (Err = False)
88537>>>    End_Function
88538>>>
88538>>>    // Delete an Index Segment
88538>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88540>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88540>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88540>>>        Integer iIndexType
88540>>>        String sDriverID
88540>>>
88540>>>        Get AutoConnectionIDLogin to bOK
88541>>>        Move False to Err
88542>>>
88542>>>        Get OpenTableExclusive hTable to bOK
88543>>>        If (bOK = False) Begin
88545>>>            Function_Return False
88546>>>        End
88546>>>>
88546>>>
88546>>>            Get UtilTableIsSQL hTable to bIsSQLTable
88547>>>            If (bIsSQLTable = True) Begin
88549>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88552>>>            End
88552>>>>
88552>>>
88552>>>        // Check to see if the index exists or not...
88552>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88555>>>        If (iNumSegments = 0) Begin
88557>>>            Function_Return False
88558>>>        End
88558>>>>
88558>>>
88558>>>        Move False to bIndexTemporary
88559>>>        Get psDriverID to sDriverID
88560>>>        Get IsSQLDriver sDriverID to bSQLDriver
88561>>>        If (bSQLDriver) Begin
88563>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88566>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88569>>>                Move True to bIndexTemporary
88570>>>        End
88570>>>>
88570>>>
88570>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88570>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88572>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88575>>>            If (iSegment = iNumSegments) Begin
88577>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88580>>>            End
88580>>>>
88580>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88583>>>                For iCurSegment from iSegment to (iNumSegments - 1)
88589>>>>
88589>>>                    //*** Move index segment attributes
88589>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88592>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88595>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88598>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88601>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88604>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88607>>>                Loop
88608>>>>
88608>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88611>>>            End
88611>>>>
88611>>>        End
88611>>>>
88611>>>
88611>>>        Else Begin
88612>>>           Structure_Start hTable
88613>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88616>>>               If (iSegment = iNumSegments) Begin
88618>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88621>>>               End
88621>>>>
88621>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88624>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
88630>>>>
88630>>>                       //*** Move index segment attributes
88630>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88633>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88636>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88639>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88642>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88645>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88648>>>                   Loop
88649>>>>
88649>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88652>>>               End
88652>>>>
88652>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88653>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88655>>>            Set Action_Text of ghoStatusPanel to ""
88656>>>        End
88656>>>>
88656>>>
88656>>>        Function_Return (Err = False)
88657>>>    End_Function
88658>>>
88658>>>    // Add/Insert an Index Segment
88658>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
88660>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88660>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
88660>>>        Integer iIndexType
88660>>>        String sDriverId
88660>>>
88660>>>        Get AutoConnectionIDLogin to bOK
88661>>>        Move False to Err
88662>>>
88662>>>        Get OpenTableExclusive hTable to bOK
88663>>>        If (bOK = False) Begin
88665>>>            Function_Return False
88666>>>        End
88666>>>>
88666>>>
88666>>>            Get UtilTableIsSQL hTable to bIsSQLTable
88667>>>            If (bIsSQLTable = True) Begin
88669>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88672>>>            End
88672>>>>
88672>>>
88672>>>        Move False to bIndexTemporary
88673>>>        // Check to see if the index exists or not...
88673>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88676>>>        If (iNumSegments = 0) Begin
88678>>>            Function_Return False
88679>>>        End
88679>>>>
88679>>>
88679>>>        Get psDriverID to sDriverID
88680>>>        Get IsSQLDriver sDriverID to bSQLDriver
88681>>>        If (bSQLDriver) Begin
88683>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88686>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88689>>>                Move True to bIndexTemporary
88690>>>        End
88690>>>>
88690>>>
88690>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88690>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88692>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88695>>>
88695>>>           If (iSegment > iNumSegments) Begin
88697>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88700>>>               Move (iNumSegments + 1) to iCurSegment
88701>>>           End
88701>>>>
88701>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
88704>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88707>>>               Move iNumSegments to iCurSegment
88708>>>
88708>>>               While (iCurSegment > iSegment)
88712>>>                   //*** Move index segment attributes
88712>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
88715>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
88718>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
88721>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
88724>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
88727>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
88730>>>                   Decrement iCurSegment
88731>>>               Loop
88732>>>>
88732>>>
88732>>>               //*** Now set new segment attributes
88732>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
88735>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
88738>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
88741>>>           End
88741>>>>
88741>>>        End
88741>>>>
88741>>>
88741>>>        Else Begin
88742>>>        Structure_Start hTable
88743>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88746>>>
88746>>>            If (iSegment > iNumSegments) Begin
88748>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88751>>>                Move (iNumSegments + 1) to iCurSegment
88752>>>            End
88752>>>>
88752>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
88755>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88758>>>                Move iNumSegments to iCurSegment
88759>>>
88759>>>                While (iCurSegment > iSegment)
88763>>>                    //*** Move index segment attributes
88763>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
88766>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
88769>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
88772>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88775>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88778>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88781>>>                    Decrement iCurSegment
88782>>>                Loop
88783>>>>
88783>>>
88783>>>                //*** Now set new segment attributes
88783>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
88786>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
88789>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
88792>>>            End
88792>>>>
88792>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88793>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88795>>>            Set Action_Text of ghoStatusPanel to ""
88796>>>        End
88796>>>>
88796>>>
88796>>>        Function_Return (Err = False)
88797>>>    End_Function
88798>>>
88798>>>    // * Dummy function for the Studio's Code Explorer *
88798>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
88800>>>        Function_Return False
88801>>>    End_Function  
88802>>>    
88802>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
88802>>>    // for an SQL conversion.
88802>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
88804>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
88804>>>        
88804>>>        Move True to bConvertTo30FormatbOK
88805>>>        Move True to bRepairAndReindexOK
88806>>>        Move True to bFixBogusDatesOK
88807>>>        Move True to bMoveMiscFilesToBackupOK
88808>>>        
88808>>>        If (bMoveMiscFilesToBackup = True) Begin   
88810>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
88811>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
88812>>>        End                                                                                
88812>>>>
88812>>>        If (bFixALLBogusFilelistEntries = True) Begin
88814>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
88815>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
88816>>>        End
88816>>>>
88816>>>        If (bConvertTo30Format = True) Begin
88818>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
88819>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
88820>>>        End                                                 
88820>>>>
88820>>>        If (bRepairAndReindex = True) Begin
88822>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
88823>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
88824>>>        End  
88824>>>>
88824>>>        If (bFixBogusDates = True) Begin
88826>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
88827>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
88828>>>        End                                    
88828>>>>
88828>>>        
88828>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
88829>>>    End_Function
88830>>>
88830>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
88832>>>        Boolean bOK bFlexErrs bTemp
88832>>>        Handle hTable
88832>>>        String sTableName
88832>>>        Integer iCount iSize
88832>>>        
88832>>>        Move True to bOK
88833>>>        Move 0 to hTable    
88834>>>
88834>>>        Get UtilFilelistNoOfTables to iSize
88835>>>        Set pbVisible    of ghoProgressBarOverall to True
88836>>>        Set piPosition   of ghoProgressBarOverall to 0
88837>>>        Set piMaximum    of ghoProgressBarOverall to iSize
88838>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
88839>>>
88839>>>        Repeat
88839>>>>
88839>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
88840>>>            Set piPosition of ghoProgressBarOverall to iCount  
88841>>>            Increment iCount
88842>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
88845>>>            If (hTable > 0) Begin
88847>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
88850>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
88851>>>                If (bFlexErrs = False) Begin
88853>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
88854>>>                    If (bTemp = False) Begin
88856>>>                        Move False to bOK
88857>>>                    End
88857>>>>
88857>>>                End
88857>>>>
88857>>>            End
88857>>>>
88857>>>        Until (hTable = 0)
88859>>>        
88859>>>        Set Action_Text of ghoStatusPanel to ""
88860>>>        Function_Return bOK
88861>>>    End_Function
88862>>>    
88862>>>    // Converts an embedded table from 2.3 -> 3.0.
88862>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
88862>>>    // It will return a TRUE if successful or the table is an SQL table.
88862>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
88864>>>        Boolean bOK bIsEmbedded bIsAlias
88864>>>        String sRevision
88864>>>        
88864>>>        Get AutoConnectionIDLogin to bOK
88865>>>        If (bOK = False) Begin
88867>>>            Function_Return True
88868>>>        End
88868>>>>
88868>>>        Get OpenTableExclusive hTable to bOK
88869>>>        If (bOK = False) Begin
88871>>>            Function_Return True
88872>>>        End
88872>>>>
88872>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
88873>>>        If (bIsEmbedded = False) Begin
88875>>>            Function_Return True
88876>>>        End                             
88876>>>>
88876>>>        Get UtilTableIsAlias hTable to bIsAlias
88877>>>        If (bIsAlias = True) Begin
88879>>>            Function_Return True
88880>>>        End                     
88880>>>>
88880>>>        
88880>>>        Move False to Err
88881>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
88884>>>        If (sRevision contains "2.3") Begin
88886>>>            Move False to Err
88887>>>            Set Private.phCurrentTable to hTable
88888>>>            Structure_Start hTable    
88889>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
88892>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
88893>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
88895>>>            Set Action_Text of ghoStatusPanel to ""
88896>>>        End
88896>>>>
88896>>>        
88896>>>        Function_Return (Err = False)
88897>>>    End_Function
88898>>>
88898>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
88900>>>        Boolean bIgnore bExists bOK bResponse
88900>>>        Handle hTable   
88900>>>        String sTableName
88900>>>        
88900>>>        Move False to Err 
88901>>>        Move True to bOK
88902>>>        Move 0 to hTable
88903>>>        Repeat
88903>>>>
88903>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
88906>>>            If (hTable > 0) Begin
88908>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
88911>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
88912>>>                If (bIgnore = False) Begin
88914>>>                    Get UtilTableExists hTable to bExists
88915>>>                    If (bExists = False) Begin
88917>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
88918>>>                        If (bResponse = False) Begin
88920>>>                            Move False to bOK
88921>>>                        End
88921>>>>
88921>>>                        
88921>>>                    End
88921>>>>
88921>>>                End
88921>>>>
88921>>>            End
88921>>>>
88921>>>        Until (hTable = 0)                     
88923>>>        
88923>>>        Set Action_Text of ghoStatusPanel to "" 
88924>>>        Function_Return bOK
88925>>>    End_Function
88926>>>    
88926>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
88926>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
88926>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
88926>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
88926>>>    //
88926>>>    // The root of the problem is the following:
88926>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
88926>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
88926>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
88926>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
88926>>>    // an SQL error will be thrown;
88926>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
88926>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
88928>>>        Boolean bOK bIsAlias bIsSQL
88928>>>        Integer iCount iSize iDateSize
88928>>>        Handle hTable
88928>>>        String sLogicalName
88928>>>        Integer[] aTablesToCheck aDateFields
88930>>>
88930>>>        Get _AllTablesDateCorrections to aTablesToCheck
88931>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
88932>>>        Set pbVisible    of ghoProgressBarOverall to True
88933>>>        Set piPosition   of ghoProgressBarOverall to 0
88934>>>        Set piMaximum    of ghoProgressBarOverall to iSize
88935>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
88936>>>
88936>>>        Move True to bOK
88937>>>        Decrement iSize
88938>>>        for iCount from 0 to iSize
88944>>>>
88944>>>            Move aTablesToCheck[iCount] to hTable
88945>>>            Set piPosition of ghoProgressBarOverall to iCount
88946>>>            Get UtilTableIsAlias hTable to bIsAlias
88947>>>            Get UtilTableIsSql   hTable to bIsSQL
88948>>>
88948>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
88951>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
88952>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
88953>>>
88953>>>            If (bIsAlias = False and bIsSQL = False) Begin
88955>>>                Get UtilCheckForDateFields hTable to aDateFields
88956>>>                Move (SizeOfArray(aDateFields)) to iDateSize
88957>>>                If (iDateSize > 0) Begin
88959>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
88960>>>                    Close hTable
88961>>>                End
88961>>>>
88961>>>            End
88961>>>>
88961>>>        Loop
88962>>>>
88962>>>
88962>>>        Close DF_ALL
88963>>>        Function_Return bOK
88964>>>    End_Function
88965>>>
88965>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
88965>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
88967>>>        Integer[] aDateFields aDateFieldsEmpty
88969>>>        Integer iSize iCount iType
88969>>>        Boolean bOpen bOK
88969>>>        
88969>>>        Get UtilTableExists hTable to bOK
88970>>>        If (bOK = False) Begin
88972>>>            Set Private.phCurrentTable to hTable
88973>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
88974>>>>
88974>>>            Function_Return aDateFieldsEmpty
88975>>>        End
88975>>>>
88975>>>        Set Private.phCurrentTable to hTable
88976>>>        Set Private.piCurrentField to 0
88977>>>
88977>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88977>>>        Open hTable
88979>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
88982>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
88982>>>        If (bOpen = False) Begin
88984>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
88984>>>            Function_Return aDateFieldsEmpty
88985>>>        End
88985>>>>
88985>>>
88985>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
88988>>>        For iCount from 1 to iSize
88994>>>>
88994>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
88997>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
88999>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
89000>>>            End
89000>>>>
89000>>>        Loop
89001>>>>
89001>>>
89001>>>        Function_Return aDateFields
89002>>>    End_Function
89003>>>
89003>>>    // Loops through all records for the passed hTable, and checks that all Date values
89003>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
89003>>>    // and the record is saved
89003>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89003>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
89003>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89005>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
89005>>>        String sDriverID sDateMin
89005>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
89005>>>        Date dDate dDateMin
89005>>>        Integer[] iaChangeField
89006>>>
89006>>>        Get UtilTableExists hTable to bOK
89007>>>        // I believe we should just skip files not found and not report an error.
89007>>>        // This is because a filelist may have entries but no files/tables on disk, but
89007>>>        // this may be adjusted by other calls to DUF in a later update package. 
89007>>>        // Especially considering that this call is probably done at the very
89007>>>        // beginning of a DUF update.
89007>>>        If (bOK = False) Begin
89009>>>//            Set Private.phCurrentTable to hTable
89009>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89009>>>//            Function_Return False
89009>>>            Function_Return True
89010>>>        End
89010>>>>
89010>>>
89010>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
89010>>>        // date format to "USA" = "MM/DD/YYYY"
89010>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
89013>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
89016>>>
89016>>>//        Send SetAllIndexesToBatch hTable True
89016>>>        Open hTable
89018>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89021>>>        If (bOpened = False) Begin
89023>>>            Function_Return False
89024>>>        End
89024>>>>
89024>>>        
89024>>>        Set Private.phCurrentTable to hTable
89025>>>        Move 0 to iRecord
89026>>>        Move (SizeOfArray(aDateFields)) to iSize
89027>>>        Decrement iSize
89028>>>
89028>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89031>>>        Get DriverIndex sDriverID to iDriverIndex
89032>>>        If (iDriverIndex <> 0) Begin
89034>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
89037>>>            If (sDateMin = "") Begin
89039>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
89040>>>            End
89040>>>>
89040>>>            Else Begin
89041>>>                If (IsDate(sDateMin)) Begin
89043>>>                    Move sDateMin to dDateMin
89044>>>                End
89044>>>>
89044>>>                Else Begin
89045>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
89046>>>                End
89046>>>>
89046>>>            End
89046>>>>
89046>>>        End
89046>>>>
89046>>>        Else Begin
89047>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
89048>>>        End
89048>>>>
89048>>>
89048>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
89051>>>        Set piPosition   of ghoProgressBar to 0
89052>>>        Set piAdvanceBy  of ghoProgressBar to 100
89053>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
89054>>>        Move False to Err
89055>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89056>>>
89056>>>        Clear hTable
89057>>>        Repeat
89057>>>>
89057>>>            Vfind hTable 0 GT
89059>>>            Move Found to bFound
89060>>>            If (bFound = True) Begin
89062>>>                Move False to bSaveChanges
89063>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
89064>>>                Move (SizeOfArray(aDateFields)) to iSize
89065>>>                Decrement iSize
89066>>>                For iCount from 0 to iSize
89072>>>>
89072>>>                    Move aDateFields[iCount] to iField
89073>>>                    Get_Field_Value hTable iField to dDate
89076>>>                    If (bFixZeroDates = True) Begin
89078>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
89079>>>                    End
89079>>>>
89079>>>                    Else Begin
89080>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
89081>>>                    End
89081>>>>
89081>>>                    If (bChange = True) Begin
89083>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
89084>>>                    End
89084>>>>
89084>>>                Loop
89085>>>>
89085>>>
89085>>>                // Only change Date fields that needs to be changed.
89085>>>                If (SizeOfArray(iaChangeField)) Begin
89087>>>                    Reread hTable
89091>>>                        Move (SizeOfArray(iaChangeField)) to iSize
89092>>>                        Decrement iSize
89093>>>                        For iCount from 0 to iSize
89099>>>>
89099>>>                            Move iaChangeField[iCount] to iField
89100>>>                            Set Private.piCurrentField to iField
89101>>>                            Set_Field_Value hTable iField to dDateMin
89104>>>                        Loop
89105>>>>
89105>>>                        Move False to Err
89106>>>                        SaveRecord hTable
89107>>>                    Unlock
89108>>>>
89108>>>                End
89108>>>>
89108>>>
89108>>>                Increment iRecord
89109>>>                // Increment the StatusPanel counter and check the
89109>>>                // cancel status every 100 records rather than every
89109>>>                // record, it's way faster.
89109>>>                If (Mod(iRecord, 100) = 0) Begin
89111>>>                    Send DoAdvance of ghoProgressBar
89112>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
89113>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89114>>>                End
89114>>>>
89114>>>            End
89114>>>>
89114>>>        Until (bFound = False)
89116>>>
89116>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
89119>>>        If (bResetIndexesToOnLine = True) Begin
89121>>>            Send SetAllIndexesToBatch hTable False
89122>>>        End
89122>>>>
89122>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89123>>>
89123>>>        Function_Return (Err = False)
89124>>>    End_Function
89125>>>
89125>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89125>>>    // Note that it first removes any driver prefixes in the rootname.
89125>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
89127>>>        Boolean bIsSame
89127>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89127>>>
89127>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
89128>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
89129>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
89130>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
89131>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
89132>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
89133>>>
89133>>>        If (bCompareFilelistUppercase = True) Begin
89135>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
89136>>>        End
89136>>>>
89136>>>        Else Begin
89137>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
89138>>>        End
89138>>>>
89138>>>        If (bIsSame = False) Begin
89140>>>            Function_Return False
89141>>>        End
89141>>>>
89141>>>
89141>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
89142>>>        If (bIsSame = False) Begin
89144>>>            Function_Return False
89145>>>        End
89145>>>>
89145>>>
89145>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
89146>>>        If (bIsSame = False) Begin
89148>>>            Function_Return False
89149>>>        End
89149>>>>
89149>>>
89149>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
89150>>>        If (bIsSame = False) Begin
89152>>>            Function_Return False
89153>>>        End
89153>>>>
89153>>>
89153>>>        Function_Return bIsSame
89154>>>    End_Function
89155>>>
89155>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89157>>>        Handle hTableFrom hTableTo
89157>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89157>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
89157>>>        String sRootName sDriverIDFrom sDriverIDTo
89157>>>        tAPIColumnCompare[]   aAPIColumnCompare
89157>>>        tAPIColumnCompare[]   aAPIColumnCompare
89158>>>        tAPIIndexCompare[]    aAPIIndexCompare
89158>>>        tAPIIndexCompare[]    aAPIIndexCompare
89159>>>        tAPIRelationCompare[] aAPIRelationCompare
89159>>>        tAPIRelationCompare[] aAPIRelationCompare
89160>>>
89160>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
89161>>>        If (bIsSame = True) Begin
89163>>>            Function_Return True
89164>>>        End
89164>>>>
89164>>>
89164>>>        Move False to bFilelistError
89165>>>        Move True to bIsSame
89166>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
89167>>>        Get pbCompareIndexAscending to bCompareIndexAscending
89168>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
89169>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89170>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89171>>>
89171>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
89172>>>        Get _TableNameOnly sRootName             to sRootName
89173>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
89174>>>
89174>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
89174>>>        // bCodeGenerateMode = True = Code Generation mode.
89174>>>        If (bCodeGenerateMode = True) Begin
89176>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89176>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89178>>>                Function_Return False
89179>>>            End
89179>>>>
89179>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89180>>>            If (bIsSame = False) Begin
89182>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
89183>>>                Move True to bFilelistError
89184>>>                Function_Return False
89185>>>            End
89185>>>>
89185>>>        End
89185>>>>
89185>>>
89185>>>        If (bCodeGenerateMode = False) Begin
89187>>>            // Then we want to create this table
89187>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89189>>>                Function_Return False
89190>>>            End
89190>>>>
89190>>>
89190>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89191>>>            If (bIsSame = False) Begin
89193>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
89194>>>>
89194>>>                Move True to bFilelistError
89195>>>                Function_Return False
89196>>>            End
89196>>>>
89196>>>        End
89196>>>>
89196>>>
89196>>>        // Check columns:
89196>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89197>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
89198>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
89199>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89200>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
89201>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
89202>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
89203>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
89204>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
89205>>>        If (bIsSame = False) Begin
89207>>>            Function_Return False
89208>>>        End
89208>>>>
89208>>>
89208>>>        // ...then check indexes:
89208>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
89209>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
89210>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
89211>>>        If (bIsSame = False) Begin
89213>>>            Function_Return False
89214>>>        End
89214>>>>
89214>>>
89214>>>        // ...and finally relationships:
89214>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
89215>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
89216>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
89217>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
89218>>>
89218>>>        Function_Return (bIsSame = True)
89219>>>    End_Function
89220>>>
89220>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
89220>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89222>>>        Handle hTable
89222>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89222>>>        String sRootName sDriverIDFrom sDriverIDTo
89222>>>
89222>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
89224>>>            Move True to bFilelistError
89225>>>            Function_Return False
89226>>>        End
89226>>>>
89226>>>
89226>>>        Move APITableCompare.hTable to hTable
89227>>>        Move True  to bIsSame
89228>>>        Move False to bFilelistError
89229>>>
89229>>>        If (APITableCompare.bExistsFrom = True) Begin
89231>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
89232>>>        End
89232>>>>
89232>>>        Else Begin
89233>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
89234>>>        End
89234>>>>
89234>>>        Get _TableNameOnly sRootName                                   to sRootName
89235>>>
89235>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
89236>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
89237>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
89238>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
89239>>>
89239>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
89239>>>        // bCodeGenerateMode = True = Code Generation mode.
89239>>>        If (bCodeGenerateMode = True) Begin
89241>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89241>>>            If (APITableCompare.bExistsTo = False) Begin
89243>>>                Function_Return False
89244>>>            End
89244>>>>
89244>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
89245>>>            If (bIsSame = False) Begin
89247>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
89248>>>                Move True to bFilelistError
89249>>>                Function_Return False
89250>>>            End
89250>>>>
89250>>>        End
89250>>>>
89250>>>
89250>>>        If (bCodeGenerateMode = False) Begin
89252>>>            If (APITableCompare.bExistsTo = False) Begin
89254>>>                // Then we might want to create this table
89254>>>                Function_Return False
89255>>>            End
89255>>>>
89255>>>
89255>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
89256>>>            If (bIsSame = False) Begin
89258>>>                Function_Return False
89259>>>            End
89259>>>>
89259>>>
89259>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
89260>>>            If (bIsSame = False) Begin
89262>>>                Function_Return False
89263>>>            End
89263>>>>
89263>>>
89263>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
89264>>>            If (bIsSame = False) Begin
89266>>>                Function_Return False
89267>>>            End
89267>>>>
89267>>>
89267>>>            // Check table names et al.
89267>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
89268>>>            If (bIsSame = False) Begin
89270>>>                Function_Return False
89271>>>            End
89271>>>>
89271>>>        End
89271>>>>
89271>>>
89271>>>        // Check Columns:
89271>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
89272>>>        If (bIsSame = False) Begin
89274>>>            Function_Return False
89275>>>        End
89275>>>>
89275>>>
89275>>>        // ...then check Indexes:
89275>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
89276>>>        If (bIsSame = False) Begin
89278>>>            Function_Return False
89279>>>        End
89279>>>>
89279>>>
89279>>>        // ...and finally Relationships:
89279>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
89280>>>
89280>>>        Function_Return (bIsSame = True)
89281>>>    End_Function
89282>>>
89282>>>    // To fill a complete Table array structure (tAPITable[]) with data.
89282>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
89282>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
89282>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
89282>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
89284>>>        tAPITableNameInfo ApiTableNameInfo
89284>>>        tAPITableNameInfo ApiTableNameInfo
89284>>>        tAPITable[]     aApiTables aApiTablesEmpty
89284>>>        tAPITable[]     aApiTables aApiTablesEmpty
89286>>>        tAPIColumn[]    aApiColumns
89286>>>        tAPIColumn[]    aApiColumns
89287>>>        tAPIIndex[]     aApiIndexes
89287>>>        tAPIIndex[]     aApiIndexes
89288>>>        tAPIRelation[]  aApiRelations
89288>>>        tAPIRelation[]  aApiRelations
89289>>>        Handle hTable
89289>>>        Integer iCount
89289>>>        Boolean bUserCancel bOK
89289>>>        String sLogicalName sMessageText
89289>>>
89289>>>        Get AutoConnectionIDLogin to bOK
89290>>>        Move 0 to hTable
89291>>>        If (bFromTables = True) Begin
89293>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
89294>>>            If (bCompareUtil = True) Begin
89296>>>                Move (sMessageText * "(1 of 3)") to sMessageText
89297>>>            End
89297>>>>
89297>>>        End
89297>>>>
89297>>>        Else Begin
89298>>>            Move "Reading 'TO' Table Structure:" to sMessageText
89299>>>            If (bCompareUtil = True) Begin
89301>>>                Move (sMessageText * "(2 of 3)") to sMessageText
89302>>>            End
89302>>>>
89302>>>        End
89302>>>>
89302>>>        Set Message_Text of ghoStatusPanel to sMessageText
89303>>>
89303>>>        Get UtilFilelistNoOfTables to iCount
89304>>>        Set piMaximum of ghoProgressBar to iCount
89305>>>        Move 0 to iCount
89306>>>
89306>>>        Repeat
89306>>>>
89306>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89309>>>            If (hTable > 0 and hTable <> 50) Begin
89311>>>
89311>>>                Open hTable
89313>>>                // ToDo: Needs to be revised
89313>>>                // For some reason tables may be reported as "unopened", while in
89313>>>                // fact the open was successful (!)
89313>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89313>>>//                If (bIsOpen = False) Begin
89313>>>//                    Move True to aApiTablesEmpty[0].bError
89313>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
89313>>>//                    Function_Return aApiTablesEmpty
89313>>>//                End
89313>>>
89313>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89316>>>                Set piPosition of ghoProgressBar to iCount
89317>>>                Send DoAdvance of ghoProgressBarOverall
89318>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
89319>>>
89319>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
89320>>>//                Close hTable DF_PERMANENT
89320>>>                Increment iCount
89321>>>            End
89321>>>>
89321>>>
89321>>>            If (bStatusPanel = True) Begin
89323>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
89324>>>                If (bUserCancel = True) Begin
89326>>>                    Move True to aApiTablesEmpty[0].bCancel
89327>>>                    Function_Return aApiTablesEmpty
89328>>>                End
89328>>>>
89328>>>            End
89328>>>>
89328>>>
89328>>>        Until (hTable = 0)
89330>>>
89330>>>        Function_Return aApiTables
89331>>>    End_Function
89332>>>
89332>>>    // Returns a 'single' table APITable struct.
89332>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
89334>>>        tAPITableNameInfo ApiTableNameInfo
89334>>>        tAPITableNameInfo ApiTableNameInfo
89334>>>        tAPITable         ApiTable ApiTableEmpty
89334>>>        tAPITable         ApiTable ApiTableEmpty
89334>>>        tAPIColumn[]     aApiColumns
89334>>>        tAPIColumn[]     aApiColumns
89335>>>        tAPIIndex[]      aApiIndexes
89335>>>        tAPIIndex[]      aApiIndexes
89336>>>        tAPIRelation[]   aApiRelations
89336>>>        tAPIRelation[]   aApiRelations
89337>>>        Boolean bIsOpen
89337>>>
89337>>>        Open hTable
89339>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89342>>>        If (bIsOpen = False) Begin
89344>>>            Move True to ApiTableEmpty.bError
89345>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89346>>>            Function_Return ApiTableEmpty
89347>>>        End
89347>>>>
89347>>>
89347>>>        // Fill Table Name Info
89347>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
89348>>>
89348>>>        // Fill columns
89348>>>        Get UtilColumnsStructFill hTable to aApiColumns
89349>>>        If (SizeOfArray(aApiColumns)) Begin
89351>>>            If (aApiColumns[0].bCancel = True) Begin
89353>>>                Move True to ApiTableEmpty.bError
89354>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89355>>>                Function_Return ApiTableEmpty
89356>>>            End
89356>>>>
89356>>>        End
89356>>>>
89356>>>
89356>>>        // Fill indexes
89356>>>        Get UtilIndexesStructFill hTable to aApiIndexes
89357>>>        If (SizeOfArray(aApiIndexes)) Begin
89359>>>            If (aApiIndexes[0].bCancel = True) Begin
89361>>>                Move True to ApiTableEmpty.bError
89362>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89363>>>                Function_Return ApiTableEmpty
89364>>>            End
89364>>>>
89364>>>        End
89364>>>>
89364>>>
89364>>>        // Fill relationships
89364>>>        Get UtilRelationsStructFill hTable to aApiRelations
89365>>>        If (SizeOfArray(aApiRelations)) Begin
89367>>>            If (aApiRelations[0].bCancel = True) Begin
89369>>>                Move True to ApiTableEmpty.bError
89370>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89371>>>                Function_Return ApiTableEmpty
89372>>>            End
89372>>>>
89372>>>        End
89372>>>>
89372>>>
89372>>>        Move hTable             to ApiTable.hTable
89373>>>        Move bFromTables        to ApiTable.bFromTable
89374>>>        Move (not(bFromTables)) to ApiTable.bToTable
89375>>>
89375>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
89376>>>        Move aApiColumns        to ApiTable.aApiColumns
89377>>>        Move aApiIndexes        to ApiTable.aApiIndexes
89378>>>        Move aApiRelations      to ApiTable.aApiRelations
89379>>>
89379>>>        Function_Return ApiTable
89380>>>    End_Function
89381>>>
89381>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
89383>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89383>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89383>>>        Boolean bIsOpen
89383>>>
89383>>>        Open hTable
89385>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89388>>>        If (bIsOpen = False) Begin
89390>>>            Move True   to APITableNameInfoEmpty.bError
89391>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
89392>>>            Function_Return APITableNameInfoEmpty
89393>>>        End
89393>>>>
89393>>>
89393>>>        Move hTable                                  to APITableNameInfo.iTableNumber
89394>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
89397>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
89400>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
89403>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
89406>>>
89406>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
89407>>>        Get UtilTableIsSQL                    hTable to APITableNameInfo.bIsSQL
89408>>>
89408>>>        Function_Return APITableNameInfo
89409>>>    End_Function
89410>>>
89410>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
89412>>>        Integer iSize iCount iItem
89412>>>        tAPITableNameInfo ApiTableNameInfo
89412>>>        tAPITableNameInfo ApiTableNameInfo
89412>>>
89412>>>        Move -1 to iItem
89413>>>        Move (SizeOfArray(aTableStructure)) to iSize
89414>>>        Decrement iSize
89415>>>        for iCount from 0 to iSize
89421>>>>
89421>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89422>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
89424>>>                Move iCount to iItem
89425>>>                Move iSize  to iCount // We're done.
89426>>>            End
89426>>>>
89426>>>        Loop
89427>>>>
89427>>>
89427>>>        Function_Return iItem
89428>>>    End_Function
89429>>>
89429>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
89431>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
89434>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
89437>>>
89437>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
89440>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
89443>>>
89443>>>        Function_Return (EQ)
89444>>>    End_Function
89445>>>
89445>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
89447>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
89447>>>        Handle hTable
89447>>>        tAPITable[] aAPITableFromAndTo
89447>>>        tAPITable[] aAPITableFromAndTo
89448>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89448>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89448>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89448>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89448>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89448>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89449>>>        tAPIColumnCompare[]   aAPIColumnCompare
89449>>>        tAPIColumnCompare[]   aAPIColumnCompare
89450>>>        tAPIIndexCompare[]    aAPIIndexCompare
89450>>>        tAPIIndexCompare[]    aAPIIndexCompare
89451>>>        tAPIRelationCompare[] aAPIRelationCompare
89451>>>        tAPIRelationCompare[] aAPIRelationCompare
89452>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89452>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89452>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89452>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89455>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89455>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89458>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89458>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89461>>>
89461>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
89462>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
89463>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
89465>>>            Function_Return aAPITableCompare
89466>>>        End
89466>>>>
89466>>>
89466>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
89467>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
89468>>>
89468>>>        Move 0 to iItem
89469>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
89470>>>        Decrement iSize
89471>>>        for iCount from 0 to iSize
89477>>>>
89477>>>
89477>>>            Move iCount to iItemFrom
89478>>>            Move iCount to iItemTo
89479>>>            Move APITableEmpty to APITableFrom
89480>>>            Move APITableEmpty to APITableTo
89481>>>
89481>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
89483>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89484>>>            End
89484>>>>
89484>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
89486>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
89487>>>            End
89487>>>>
89487>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
89489>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89490>>>                Move (iCount + 1) to iItemTo
89491>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
89492>>>            End
89492>>>>
89492>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
89494>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
89495>>>                If (iItemTo <> -1) Begin
89497>>>                    Move aAPITableTo[iItemTo] to APITableTo
89498>>>                End
89498>>>>
89498>>>                Else Begin
89499>>>                    Move APITableEmpty to APITableTo
89500>>>                End
89500>>>>
89500>>>            End
89500>>>>
89500>>>
89500>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
89501>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
89502>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
89503>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
89504>>>
89504>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
89505>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
89506>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
89507>>>            Move APITableTo.aApiRelations   to aApiRelationTo
89508>>>
89508>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
89509>>>
89509>>>            If (hTable > 0) Begin
89511>>>
89511>>>                // Table info:
89511>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
89512>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
89513>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
89514>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
89515>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
89516>>>
89516>>>                // Column info:
89516>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
89517>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
89518>>>
89518>>>                // Index info:
89518>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
89519>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
89520>>>
89520>>>                // Relation info:
89520>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
89521>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
89522>>>
89522>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
89523>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
89524>>>                Move False                                                              to aAPITableCompare[iItem].bError
89525>>>                If (iItemTo > iItemFrom) Begin
89527>>>                    Increment iCount
89528>>>                End
89528>>>>
89528>>>                Increment iItem
89529>>>            End
89529>>>>
89529>>>
89529>>>        Loop
89530>>>>
89530>>>
89530>>>        Function_Return aAPITableCompare
89531>>>    End_Function
89532>>>
89532>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
89534>>>        Integer iSize iCount iItem
89534>>>        tAPITableNameInfo ApiTableNameInfo
89534>>>        tAPITableNameInfo ApiTableNameInfo
89534>>>
89534>>>        Move -1 to iItem
89535>>>        Move (SizeOfArray(aTableStructure)) to iSize
89536>>>        Decrement iSize
89537>>>        For iCount from 0 to iSize
89543>>>>
89543>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89544>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
89546>>>                Move iCount to iItem
89547>>>                Move iSize  to iCount // We're done.
89548>>>            End
89548>>>>
89548>>>        Loop
89549>>>>
89549>>>
89549>>>        Function_Return iItem
89550>>>    End_Function
89551>>>
89551>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
89553>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89553>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89553>>>
89553>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
89555>>>            Function_Return APITableNameInfoCompare
89556>>>        End
89556>>>>
89556>>>
89556>>>        // FROM database info:
89556>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
89558>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
89559>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
89560>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
89561>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
89562>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
89563>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
89564>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
89565>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
89566>>>        End
89566>>>>
89566>>>
89566>>>        // TO database info:
89566>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
89568>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
89569>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
89570>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
89571>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
89572>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
89573>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
89574>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
89575>>>            Move True                               to APITableNameInfoCompare.bExistsTo
89576>>>        End
89576>>>>
89576>>>
89576>>>        Function_Return APITableNameInfoCompare
89577>>>    End_Function
89578>>>
89578>>>    // Note:
89578>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
89578>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
89578>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
89578>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
89578>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
89578>>>    Function UtilTableHandleToString Handle hTable Returns String
89580>>>        String sTableName
89580>>>        Boolean bOpen bExists bOK
89580>>>
89580>>>        Get UtilTableNumberIsInUse hTable to bExists
89581>>>        If (bExists = False) Begin
89583>>>            Function_Return ""
89584>>>        End
89584>>>>
89584>>>
89584>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89585>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89588>>>        If (bOpen = False) Begin
89590>>>            Get AutoConnectionIDLogin to bOK
89591>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89592>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
89593>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89594>>>            Open hTable
89596>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89597>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
89598>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89599>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
89602>>>        End
89602>>>>
89602>>>        If (bOpen = True) Begin
89604>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89605>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
89608>>>            // If blank it is an embedded table:
89608>>>            If (sTableName = "") Begin
89610>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89613>>>                Move 0 to LastErr
89614>>>                Move False to Err
89615>>>            End
89615>>>>
89615>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89616>>>        End
89616>>>>
89616>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89617>>>        Move 0 to LastErr
89618>>>
89618>>>        Function_Return sTableName
89619>>>    End_Function
89620>>>
89620>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
89620>>>    // Returns 0 if unsuccessful.
89620>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
89620>>>    Function UtilTableNameToHandle String sTableName Returns Integer
89622>>>        String sValue sPrefixTableName sDriverID
89622>>>        Handle hTable hRetval
89622>>>
89622>>>        Get psDriverID to sDriverID
89623>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
89625>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
89626>>>        End
89626>>>>
89626>>>        Move 0 to hTable
89627>>>        Move 0 to hRetval
89628>>>        Repeat
89628>>>>
89628>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89631>>>            If (hTable <> 0) Begin
89633>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
89636>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
89638>>>                    Move hTable to hRetval
89639>>>                    Move 0 to hTable
89640>>>                End
89640>>>>
89640>>>            End
89640>>>>
89640>>>        Until (hTable = 0)
89642>>>
89642>>>        Function_Return hRetval
89643>>>    End_Function
89644>>>
89644>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
89644>>>    // _after_ all tables have successfully been converted to SQL (.int files)
89644>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
89646>>>        Boolean bOK bExists
89646>>>        String sDataPath sBackupFolder
89646>>>
89646>>>        Close DF_ALL DF_PERMANENT
89647>>>        Send DoAdvance of ghoProgressBar
89648>>>
89648>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
89649>>>        Move CS_DUFBackupDataFolder to sBackupFolder
89650>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
89651>>>        Get vFolderFormat sDataPath to sDataPath
89652>>>
89652>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
89653>>>        If (bExists = False) Begin
89655>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
89656>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
89657>>>            If (bExists = False) Begin
89659>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
89660>>>>
89660>>>                Function_Return False
89661>>>            End
89661>>>>
89661>>>        End
89661>>>>
89661>>>
89661>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
89662>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
89663>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
89664>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
89665>>>        // We need to wait for Windows before we can copy files back
89665>>>        Sleep 2  
89666>>>        
89666>>>        //...except for these files that needs to be copied back to the Data folder:
89666>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
89667>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
89668>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
89669>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
89670>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
89671>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
89672>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
89672>>>        
89672>>>
89672>>>        Set Message_Text of ghoStatusPanel to ""
89673>>>        Function_Return True
89674>>>    End_Function
89675>>>    
89675>>>    Function UtilTableRepairAndReindexALL Returns Boolean
89677>>>        Boolean bOK bRetval
89677>>>        Handle hTable
89677>>>        Integer iSize iCount
89677>>>        
89677>>>        Move True to bOK
89678>>>        Get UtilFilelistNoOfTables to iSize
89679>>>        Set pbVisible    of ghoProgressBarOverall to True
89680>>>        Set piPosition   of ghoProgressBarOverall to 0
89681>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89682>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89683>>>
89683>>>        Repeat
89683>>>>
89683>>>            Set piPosition of ghoProgressBarOverall to iCount
89684>>>            Increment iCount
89685>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89688>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
89690>>>                Get UtilTableRepairAndReindex hTable to bRetval
89691>>>                If (bRetval = False) Begin
89693>>>                    Move False to bOK
89694>>>                End
89694>>>>
89694>>>            End
89694>>>>
89694>>>        Until (hTable = 0)
89696>>>                
89696>>>        Function_Return bOK
89697>>>    End_Function           
89698>>>    
89698>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
89698>>>    // After the header has been repaired - also makes a re-index.  
89698>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
89698>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
89700>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
89700>>>        Integer iRetval
89700>>>        String sRootName sFileName sDataPath
89700>>>        
89700>>>        Move False to Err
89701>>>        Move 0 to LastErr 
89702>>>        Move True to bOK
89703>>>        
89703>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
89704>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
89706>>>            Function_Return True
89707>>>        End
89707>>>>
89707>>>        Get UtilTableIsAlias hTable to bIsAlias 
89708>>>        If (bIsAlias = True) Begin
89710>>>            Function_Return True
89711>>>        End
89711>>>>
89711>>>        
89711>>>        // Check for bad file and remove if exists
89711>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89714>>>        Set private.phCurrentTable to hTable  
89715>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
89716>>>        
89716>>>        // This is important! Else it can happen that the table can't be opened,
89716>>>        // with a "4077 - File in use" error.
89716>>>        Close DF_ALL DF_PERMANENT    
89717>>>        Open hTable
89719>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89722>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89723>>>        If (bIsOpen = False) Begin
89725>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
89726>>>>
89726>>>            Function_Return False        
89727>>>        End
89727>>>>
89727>>>
89727>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
89728>>>        If (bBadExists = True) Begin
89730>>>            Get_File_Path (sRootName + ".BAD") to sFileName
89731>>>            Get vDeleteFile sFileName to iRetval
89732>>>        End
89732>>>>
89732>>>        
89732>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
89733>>>        
89733>>>        Move False to Err
89734>>>        // **** Repair and reindex the table. ****
89734>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
89735>>>
89735>>>        // Check for bad file: if it exists, something went wrong
89735>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
89736>>>        Get vFolderFormat sDataPath to sDataPath
89737>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
89738>>>        If (bBadExists = True) Begin
89740>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
89741>>>>
89741>>>            Move False to bOK
89742>>>        End
89742>>>>
89742>>>        Close hTable
89743>>>
89743>>>        Function_Return bOK
89744>>>    End_Function
89745>>>
89745>>>    // Repair and reindex the named DataFlex data-table.
89745>>>    // No checks are done if the passed table name is an embedded or SQL,
89745>>>    // so use with care (make sure you only pass embedded table names).
89745>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
89747>>>        String sMode
89747>>>        Integer iVoid
89747>>>
89747>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
89748>>>        Move "0" to sMode   // 0=Reindex after repair!    
89749>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
89750>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
89755>>>        Set Message_Text of ghoStatusPanel to ""
89756>>>        Function_Return (iVoid = 0)
89757>>>    End_Function
89758>>>
89758>>>    // Returns _two_ arrays.
89758>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
89758>>>    // Also returns all files that are Alias files in a second array.
89758>>>    // IMPORTANT: All master & alias files _must_ have been included into
89758>>>    //            the DoSetAllMasterAndAlias message.
89758>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
89760>>>        Integer[] iaFileIsAlias
89761>>>        Integer hTable iFileAlias iSize
89761>>>        Boolean bOpen
89761>>>
89761>>>        Move 0 to hTable
89762>>>        Repeat
89762>>>>
89762>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89765>>>            If (hTable <> 0) Begin
89767>>>                Open hTable
89769>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
89772>>>                If (bOpen = True) Begin
89774>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
89777>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
89779>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
89780>>>                        Move hTable to iaFileIsMaster[iSize]
89781>>>                    End
89781>>>>
89781>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
89784>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
89785>>>                        Move hTable to iaFileIsAlias[iSize]
89786>>>                    End
89786>>>>
89786>>>                End
89786>>>>
89786>>>            End
89786>>>>
89786>>>        Until (hTable = 0)
89788>>>
89788>>>        Function_Return iaFileIsAlias
89789>>>    End_Function  
89790>>>    
89790>>>    // Is a repair of the data-header necessary? (Embedded tables only)
89790>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
89792>>>        String sMode
89792>>>        Integer iRepairNeeded bIsOpen
89792>>>
89792>>>        Move "0" to sMode
89793>>>        Set private.phCurrentTable to hTable 
89794>>>        Close hTable
89795>>>        Open hTable
89797>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89800>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
89805>>>
89805>>>        Function_Return iRepairNeeded
89806>>>    End_Function
89807>>>
89807>>>
89807>>>    // Helper function
89807>>>    // Takes two params:
89807>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
89807>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
89807>>>    // Returns:
89807>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
89807>>>    //  DF_FILE_IS_MASTER if master
89807>>>    //  DF_FILE_IS_ALIAS if alias
89807>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
89809>>>        Integer i iSize
89809>>>
89809>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
89810>>>        Decrement iSize
89811>>>        for i from 0 to iSize
89817>>>>
89817>>>            If (hTable = iaFileIsMaster[i]) Begin
89819>>>                Function_Return DF_FILE_IS_MASTER
89820>>>            End
89820>>>>
89820>>>        Loop
89821>>>>
89821>>>
89821>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
89822>>>        Decrement iSize
89823>>>        for i from 0 to iSize
89829>>>>
89829>>>            If (hTable = iaFileIsAlias[i]) Begin
89831>>>                Function_Return DF_FILE_IS_ALIAS
89832>>>            End
89832>>>>
89832>>>        Loop
89833>>>>
89833>>>
89833>>>        Function_Return DF_FILE_ALIAS_DEFAULT
89834>>>    End_Function
89835>>>
89835>>>    // Determine the available indexes of a table.
89835>>>    //
89835>>>    // Arguments:
89835>>>    //   Handle hTable - The number of the table
89835>>>    //
89835>>>    // Returns:
89835>>>    //   String - A string to be used with the sort command
89835>>>    //   to re-index all indexes of a table.
89835>>>    Function UtilTableIndexString Handle hTable Returns String
89837>>>        String  sSortString
89837>>>        Integer iLastIndex iNumSegments iCount
89837>>>
89837>>>        Move "" to sSortString
89838>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
89841>>>
89841>>>        for iCount from 1 to iLastIndex
89847>>>>
89847>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
89850>>>            If iNumSegments Begin
89852>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
89855>>>                Move (Append(sSortString, iCount)) to sSortString
89856>>>            End
89856>>>>
89856>>>        Loop
89857>>>>
89857>>>
89857>>>        Function_Return sSortString
89858>>>    End_Function
89859>>>
89859>>>    
89859>>>    // * Dummy function for the Studio's Code Explorer *
89859>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
89861>>>        Function_Return False
89862>>>    End_Function
89863>>>
89863>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
89863>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
89865>>>        Boolean bIsSame
89865>>>        Integer iCount iColumns iColumn
89865>>>
89865>>>        Move True to bIsSame
89866>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
89867>>>        Set piMaximum of ghoProgressBar  to iColumns
89868>>>        Decrement iColumns
89869>>>
89869>>>        for iCount from 0 to iColumns
89875>>>>
89875>>>            Set piPosition of ghoProgressBar to iCount
89876>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
89877>>>            If (bIsSame = False) Begin
89879>>>                Function_Return False
89880>>>            End
89880>>>>
89880>>>        Loop
89881>>>>
89881>>>
89881>>>        Function_Return (bIsSame = True)
89882>>>    End_Function
89883>>>
89883>>>    // Compares a single column (For 'FROM' & 'TO' tables)
89883>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
89885>>>        Integer iFromType iToType iDbType
89885>>>        tColumnType ColumnType
89885>>>        tColumnType ColumnType
89885>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
89885>>>
89885>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
89887>>>            Function_Return False
89888>>>        End
89888>>>>
89888>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
89890>>>            Function_Return False
89891>>>        End
89891>>>>
89891>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
89893>>>            Function_Return False
89894>>>        End                                                                
89894>>>>
89894>>>
89894>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
89896>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
89898>>>                Function_Return False
89899>>>            End
89899>>>>
89899>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
89901>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
89903>>>                    End
89903>>>>
89903>>>                Else Begin
89904>>>                    Function_Return False
89905>>>                End
89905>>>>
89905>>>            End
89905>>>>
89905>>>        End
89905>>>>
89905>>>
89905>>>        Get piDbType                       to iDbType
89906>>>        Move APIColumnCompare.iTypeFrom    to iFromType
89907>>>        Move APIColumnCompare.iTypeTo      to iToType
89908>>>
89908>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
89908>>>        // data types between Embedded and SQL.
89908>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
89910>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
89911>>>        End
89911>>>>
89911>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
89913>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
89914>>>        End
89914>>>>
89914>>>
89914>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
89915>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
89916>>>
89916>>>        // Make Date and DateTime comparison?
89916>>>        If (bCompareDate_DataTime = True) Begin
89918>>>            If (iFromType <> iToType) Begin
89920>>>                Function_Return False
89921>>>            End
89921>>>>
89921>>>        End
89921>>>>
89921>>>
89921>>>        // This is when not checking for Date/DateTime differences but all other other field types...
89921>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
89923>>>            If (iFromType <> iToType) Begin
89925>>>                Function_Return False
89926>>>            End
89926>>>>
89926>>>        End
89926>>>>
89926>>>
89926>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
89926>>>        If (bIsDateTypeFrom = False) Begin
89928>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
89930>>>                Function_Return False
89931>>>            End
89931>>>>
89931>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
89933>>>                Function_Return False
89934>>>            End
89934>>>>
89934>>>        End
89934>>>>
89934>>>
89934>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
89936>>>            Function_Return False
89937>>>        End
89937>>>>
89937>>>
89937>>>        Function_Return True
89938>>>    End_Function
89939>>>
89939>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
89941>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
89941>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
89941>>>        tAPIColumn[] APIColumns APIColumnsEmpty
89941>>>        tAPIColumn[] APIColumns APIColumnsEmpty
89943>>>        String sDriverID sRootName sLogicalName
89943>>>
89943>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89944>>>        Get piDbType to iDbType
89945>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89948>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89951>>>
89951>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89954>>>        If (bIsOpen = False) Begin
89956>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89957>>>            Open hTable
89959>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89960>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89963>>>            If (bIsOpen = False) Begin
89965>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89966>>>                Move True to APIColumnsEmpty[0].bError
89967>>>                Function_Return APIColumnsEmpty
89968>>>            End
89968>>>>
89968>>>        End
89968>>>>
89968>>>
89968>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89971>>>        Get IsSQLDriver    sDriverID to bSqlDriver
89972>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
89973>>>
89973>>>        Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
89974>>>        If (bIsSqlTable = True) Begin
89976>>>            Get UtilTableExists hTable to bExists
89977>>>            If (bExists = False) Begin
89979>>>                Move True to APIColumnsEmpty[0].bError
89980>>>                Function_Return APIColumnsEmpty
89981>>>            End
89981>>>>
89981>>>        End
89981>>>>
89981>>>
89981>>>        Move 0 to iCount
89982>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
89985>>>        Set piMaximum of ghoProgressBar to iNumColumns
89986>>>
89986>>>        for iColumn from 1 to iNumColumns
89992>>>>
89992>>>            Move 0 to iOptions
89993>>>            Move False to bIdentityKey
89994>>>            Move False to Err
89995>>>            Move 0     to LastErr
89996>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
89997>>>            Set piPosition of ghoProgressBar to iColumn
89998>>>            If (bDawSqlDriver = True) Begin
90000>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90001>>>                If (bIsSqlTable = True) Begin
90003>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
90006>>>                    Move iType                                                to APIColumns[iCount].iType
90007>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
90010>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
90013>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
90016>>>                End
90016>>>>
90016>>>                Else Begin
90017>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
90020>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90021>>>                End
90021>>>>
90021>>>
90021>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90021>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
90024>>>                Move (iCheckFieldNumber >= 0) to bExists
90025>>>                If (bExists = False) Begin
90027>>>                    Move 0 to APIColumns[iCount].iType
90028>>>                End
90028>>>>
90028>>>                If (bExists = True) Begin
90030>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90033>>>                End
90033>>>>
90033>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90034>>>                If (bIdentityKey = True) Begin
90036>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
90037>>>                End
90037>>>>
90037>>>            End
90037>>>>
90037>>>            Else Begin
90038>>>                Move False to Err
90039>>>                Move 0     to LastErr
90040>>>                If (bIsSqlTable = True) Begin
90042>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
90045>>>                End
90045>>>>
90045>>>                Else Begin
90046>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
90049>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90050>>>                End
90050>>>>
90050>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90050>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
90051>>>                If (bExists = False) Begin
90053>>>                    Move 0 to APIColumns[iCount].iType
90054>>>                End
90054>>>>
90054>>>            End
90054>>>>
90054>>>
90054>>>            If (bExists = True) Begin
90056>>>                Move iColumn to APIColumns[iCount].iFieldNumber
90057>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
90060>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
90060>>>//                If (bIsSqlTable = True) Begin
90060>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
90060>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90060>>>//                End
90060>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
90063>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90066>>>
90066>>>                // If the length was zero we might have an Overlap(!) field.
90066>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
90066>>>                If (APIColumns[iCount].iLength = 0) Begin
90068>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
90071>>>                    If (iType = DF_OVERLAP) Begin
90073>>>                        Move 0 to APIColumns[iCount].iFieldNumber
90074>>>                        Move 0 to APIColumns[iCount].iLength
90075>>>                        Move 0 to APIColumns[iCount].iOptions
90076>>>                        Move 0 to APIColumns[iCount].iPrecision
90077>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
90078>>>                        Move "" to APIColumns[iCount].sFieldName
90079>>>                        Decrement iCount
90080>>>                    End
90080>>>>
90080>>>                End
90080>>>>
90080>>>            End
90080>>>>
90080>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90081>>>            If (bUserCancel = True) Begin
90083>>>                Move True to APIColumnsEmpty[0].bCancel
90084>>>                Function_Return APIColumnsEmpty
90085>>>            End
90085>>>>
90085>>>            Increment iCount
90086>>>        Loop
90087>>>>
90087>>>
90087>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90088>>>        Function_Return APIColumns
90089>>>    End_Function
90090>>>
90090>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90090>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90090>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90090>>>    // have "holes" in the series of index numbers.
90090>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
90092>>>        tAPIColumnCompare[] aAPIColumnCompare
90092>>>        tAPIColumnCompare[] aAPIColumnCompare
90093>>>        tAPIColumnCompare   APIColumnCompare
90093>>>        tAPIColumnCompare   APIColumnCompare
90093>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90093>>>
90093>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
90094>>>        Decrement iSizeFrom
90095>>>        for iCount from 0 to iSizeFrom
90101>>>>
90101>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
90102>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
90103>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
90104>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
90105>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
90106>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
90107>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
90108>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
90109>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
90110>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
90111>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
90112>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
90113>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
90114>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
90115>>>        Loop
90116>>>>
90116>>>
90116>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
90117>>>        Decrement iSizeTo
90118>>>        for iCount from 0 to iSizeTo
90124>>>>
90124>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
90125>>>            // Search if the field number already exists in the array; else add it.
90125>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
90126>>>            If (iItem = -1) Begin
90128>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
90129>>>            End
90129>>>>
90129>>>
90129>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
90130>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
90131>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
90132>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
90133>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
90134>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
90135>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
90136>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
90137>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
90138>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
90139>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
90140>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
90141>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
90142>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
90143>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
90144>>>        Loop
90145>>>>
90145>>>
90145>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
90146>>>
90146>>>        Function_Return aAPIColumnCompare
90147>>>    End_Function
90148>>>
90148>>>    // Checks if a field name exists in a table definition
90148>>>    // Returns True if it does
90148>>>    // Sample:
90148>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90148>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90150>>>        Integer iNumColumns iColumn
90150>>>        String sColumn
90150>>>        Boolean bExists bOK bOpen
90150>>>
90150>>>        Get AutoConnectionIDLogin to bOK
90151>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90152>>>        Open hTable
90154>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90155>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90158>>>        If (bOpen = False) Begin
90160>>>            Function_Return False
90161>>>        End
90161>>>>
90161>>>
90161>>>        Move False to bExists
90162>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90165>>>        for iColumn from 1 to iNumColumns
90171>>>>
90171>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90174>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90176>>>                Move iNumColumns to iColumn
90177>>>                Move True to bExists
90178>>>            End
90178>>>>
90178>>>        Loop
90179>>>>
90179>>>        Close hTable
90180>>>
90180>>>        Function_Return bExists
90181>>>    End_Function
90182>>>
90182>>>    // Returns the field/column number for the passed FieldName as an integer.
90182>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
90184>>>        Integer iNumColumns iColumn iRetval
90184>>>        String sColumn
90184>>>        Boolean bOK bOpen
90184>>>
90184>>>        Get AutoConnectionIDLogin to bOK
90185>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90186>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90187>>>        Open hTable
90189>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90190>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90193>>>        If (bOpen = False) Begin
90195>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90196>>>            Function_Return False
90197>>>        End
90197>>>>
90197>>>
90197>>>        Move 0 to iColumn
90198>>>        Move 0 to iRetval
90199>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90202>>>        for iColumn from 1 to iNumColumns
90208>>>>
90208>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90211>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90213>>>                Move iColumn to iRetval
90214>>>                Move iNumColumns to iColumn
90215>>>            End
90215>>>>
90215>>>        Loop
90216>>>>
90216>>>        Close hTable
90217>>>
90217>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90218>>>        Function_Return iRetval
90219>>>    End_Function
90220>>>
90220>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
90220>>>    // The reciprocal function is UtilColumnTypeToInteger.
90220>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
90222>>>        tColumnType RetvalType
90222>>>        tColumnType RetvalType
90222>>>
90222>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
90223>>>        Function_Return RetvalType.iSQLType
90224>>>    End_Function
90225>>>
90225>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
90225>>>    // The reciprocal function is UtilColumnTypeToString.
90225>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
90227>>>        tColumnType RetvalType
90227>>>        tColumnType RetvalType
90227>>>
90227>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90228>>>        Function_Return RetvalType.sSQLType
90229>>>    End_Function
90230>>>
90230>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
90232>>>        tColumnType RetvalType
90232>>>        tColumnType RetvalType
90232>>>
90232>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90233>>>        Function_Return RetvalType.sPrecision
90234>>>    End_Function
90235>>>
90235>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
90237>>>        tColumnType RetvalType
90237>>>        tColumnType RetvalType
90237>>>
90237>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90238>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
90238>>>        // if the column type length is _not_ fixed.
90238>>>        Function_Return (RetvalType.bCanEditSize = False)
90239>>>    End_Function
90240>>>
90240>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
90242>>>        tColumnType RetvalType
90242>>>        tColumnType RetvalType
90242>>>        String sValue
90242>>>        Integer iRetval iPos
90242>>>
90242>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90243>>>        Move RetvalType.sPrecision to sValue
90244>>>        Move (Pos(".", sValue)) to iPos
90245>>>        If (iPos <> 0) Begin
90247>>>            Move (Left(sValue, (iPos -1))) to iRetval
90248>>>        End
90248>>>>
90248>>>        Else Begin
90249>>>            Move sValue to iRetval
90250>>>        End
90250>>>>
90250>>>        Function_Return iRetval
90251>>>    End_Function
90252>>>
90252>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
90254>>>        tColumnType RetvalType
90254>>>        tColumnType RetvalType
90254>>>        String sValue
90254>>>        Integer iRetval iPos
90254>>>
90254>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90255>>>        Move RetvalType.sPrecision to sValue
90256>>>        Move (Pos(".", sValue)) to iPos
90257>>>        If (iPos = 0) Begin
90259>>>            Function_Return 0
90260>>>        End
90260>>>>
90260>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
90261>>>
90261>>>        Function_Return iRetval
90262>>>    End_Function
90263>>>
90263>>>    // * Dummy function for the Studio's Code Explorer *
90263>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
90265>>>        Function_Return False
90266>>>    End_Function
90267>>>
90267>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
90267>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90269>>>        Boolean bIsSame
90269>>>        Integer iCount iSize
90269>>>
90269>>>        Move True to bIsSame
90270>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
90271>>>        Decrement iSize
90272>>>        For iCount from 0 to iSize
90278>>>>
90278>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90279>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90280>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90281>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90282>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90283>>>            If (bIsSame = False) Begin
90285>>>                Function_Return False
90286>>>            End
90286>>>>
90286>>>        Loop
90287>>>>
90287>>>
90287>>>        Function_Return bIsSame
90288>>>    End_Function
90289>>>
90289>>>    // Compares a single index for a 'FROM' and a 'TO' table.
90289>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90291>>>        Boolean bIsSame
90291>>>        Integer iSegment
90291>>>
90291>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
90292>>>        If (bIsSame = False) Begin
90294>>>            Function_Return False
90295>>>        End
90295>>>>
90295>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
90296>>>        If (bIsSame = False) Begin
90298>>>            Function_Return False
90299>>>        End
90299>>>>
90299>>>
90299>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
90301>>>            // * We should probably not compare SQL index names?
90301>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
90301>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
90301>>>            //     Function_Return False
90301>>>            // End
90301>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
90302>>>            If (bIsSame = False) Begin
90304>>>                Function_Return False
90305>>>            End
90305>>>>
90305>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
90306>>>            If (bIsSame = False) Begin
90308>>>                Function_Return False
90309>>>            End
90309>>>>
90309>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
90310>>>            If (bIsSame = False) Begin
90312>>>                Function_Return False
90313>>>            End
90313>>>>
90313>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
90314>>>            If (bIsSame = False) Begin
90316>>>                Function_Return False
90317>>>            End
90317>>>>
90317>>>        End
90317>>>>
90317>>>
90317>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
90318>>>        Move (iSegment = -1) to bIsSame
90319>>>
90319>>>        Function_Return (bIsSame = True)
90320>>>    End_Function
90321>>>
90321>>>    // Compares each segment for the passed index.
90321>>>    // Returns -1 if same; else returns the index segment that differs.
90321>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90323>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
90323>>>        Boolean bIsSame
90323>>>
90323>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90324>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90325>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
90326>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
90327>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
90328>>>
90328>>>        Decrement iNumSegments
90329>>>        for iSegment from 0 to iNumSegments
90335>>>>
90335>>>            Move False to bIsSame
90336>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
90338>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90339>>>            End
90339>>>>
90339>>>            If (bIsSame = False) Begin
90341>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90342>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90343>>>                Function_Return iSegment
90344>>>            End
90344>>>>
90344>>>        Loop
90345>>>>
90345>>>
90345>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90346>>>        Function_Return -1 // This means bIsSame = True
90347>>>    End_Function
90348>>>
90348>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90350>>>        Boolean bIsSame
90350>>>
90350>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
90351>>>        If (bIsSame = False) Begin
90353>>>            Function_Return False
90354>>>        End
90354>>>>
90354>>>        If (bCompareIndexUppercase = True) Begin
90356>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
90357>>>            If (bIsSame = False) Begin
90359>>>                Function_Return False
90360>>>            End
90360>>>>
90360>>>        End
90360>>>>
90360>>>        If (bCompareIndexAscending = True) Begin
90362>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
90363>>>            If (bIsSame = False) Begin
90365>>>                Function_Return False
90366>>>            End
90366>>>>
90366>>>        End
90366>>>>
90366>>>
90366>>>        Function_Return True
90367>>>    End_Function
90368>>>
90368>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90370>>>        Boolean bIsSame bOK
90370>>>        Integer iSize iSizeTo iCount
90370>>>        tAPIIndexCompare[] aAPIIndexCompare
90370>>>        tAPIIndexCompare[] aAPIIndexCompare
90371>>>
90371>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
90372>>>        If (iSize = 0) Begin
90374>>>            Function_Return True
90375>>>        End
90375>>>>
90375>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
90376>>>        Get UtilTableIsSql hTable to bIsSQLTableTo
90377>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
90378>>>
90378>>>        for iCount from 0 to (iSize - 1)
90384>>>>
90384>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90385>>>            If (bIsSame = False) Begin
90387>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
90388>>>            End
90388>>>>
90388>>>        Loop
90389>>>>
90389>>>
90389>>>        // We probably should delete other indexes if they exists.
90389>>>        for iCount from (iSize +1) to iSizeTo
90395>>>>
90395>>>            Get ApiIndexRemove hTable iCount to bOK
90396>>>        Loop
90397>>>>
90397>>>
90397>>>        Function_Return bOK
90398>>>    End_Function
90399>>>
90399>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
90399>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
90399>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
90399>>>//        String sFieldName sDriverID
90399>>>//
90399>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90399>>>//        If (bIsOpen = False) Begin
90399>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90399>>>//            Open hTable
90399>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90399>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90399>>>//            If (bIsOpen = False) Begin
90399>>>//                Function_Return False
90399>>>//            End
90399>>>//        End
90399>>>//
90399>>>//        Move True to bEqual
90399>>>//        Get psDriverID to sDriverID
90399>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
90399>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
90399>>>//        Move (SizeOfArray(aColumns)) to iSize
90399>>>//        Decrement iSize
90399>>>//
90399>>>//        For iCount from 0 to iSize
90399>>>//            Move 0 to iOptions
90399>>>//            Move False to bIdentityKey
90399>>>//            Move aColumns[iCount].sFieldName to sFieldName
90399>>>//
90399>>>//            // We need to use the column name - not the column integer as
90399>>>//            // the order does not need to be the same, and the logic should still work.
90399>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
90399>>>//            If (iColumn > 0) Begin
90399>>>//                If (bDawSqlDriver = True) Begin
90399>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90399>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
90399>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
90399>>>//                        Move False to bEqual
90399>>>//                    End
90399>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90399>>>//                    If (bIdentityKey = True) Begin
90399>>>//                        Move C_tAPIColumn_Identity to iOptions
90399>>>//                    End
90399>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
90399>>>//                        Move False to bEqual
90399>>>//                    End
90399>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90399>>>//                End
90399>>>//                Else Begin
90399>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
90399>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
90399>>>//                        Move False to bEqual
90399>>>//                    End
90399>>>//                End
90399>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
90399>>>//                If (iLength <> aColumns[iCount].iLength) Begin
90399>>>//                    Move False to bEqual
90399>>>//                End
90399>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
90399>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
90399>>>//                    Move False to bEqual
90399>>>//                End
90399>>>//                If (bEqual = False) Begin
90399>>>//                    Function_Return False
90399>>>//                End
90399>>>//            End
90399>>>//
90399>>>//            Else Begin
90399>>>//                Function_Return False
90399>>>//            End
90399>>>//        Loop
90399>>>//
90399>>>//        Function_Return bEqual
90399>>>//    End_Function
90399>>>
90399>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
90401>>>        tAPIIndex[] APIIndexes
90401>>>        tAPIIndex[] APIIndexes
90402>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
90402>>>        String sDriverID
90402>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
90402>>>
90402>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90403>>>        Get psDriverID to sDriverID
90404>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90405>>>        Get UtilTableIsSQL hTable to bIsSQLTable
90406>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90409>>>        If (bIsOpen = False) Begin
90411>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90412>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90413>>>            Open hTable
90415>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90416>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90417>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90420>>>            If (bIsOpen = False) Begin
90422>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90423>>>                Move True to APIIndexes[0].bError
90424>>>                Function_Return APIIndexes
90425>>>            End
90425>>>>
90425>>>        End
90425>>>>
90425>>>
90425>>>        Move 0 to iCount
90426>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
90429>>>        for iIndex from 1 to iIndexes
90435>>>>
90435>>>            // This is a test that the index exists as there might be "holes" aka the index
90435>>>            // numbers doesn't not need to be consequitive:
90435>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90438>>>            If (iNumSegments > 0) Begin
90440>>>
90440>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
90441>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
90444>>>                If (bIsSQLTable = True) Begin
90446>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
90449>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
90452>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
90455>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
90458>>>                End
90458>>>>
90458>>>
90458>>>                Move 0 to iSegmentCount
90459>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90462>>>                For iSegment from 1 to iNumSegments
90468>>>>
90468>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
90471>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
90472>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
90475>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
90478>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
90481>>>                    Increment iSegmentCount
90482>>>                Loop
90483>>>>
90483>>>                Increment iCount
90484>>>            End
90484>>>>
90484>>>        Loop
90485>>>>
90485>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90486>>>
90486>>>        Function_Return APIIndexes
90487>>>    End_Function
90488>>>
90488>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90488>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90488>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90488>>>    // have "holes" in the series of index numbers.
90488>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
90490>>>        tAPIIndexCompare[] aAPIIndexCompare
90490>>>        tAPIIndexCompare[] aAPIIndexCompare
90491>>>        tAPIIndexCompare   APIIndexCompare
90491>>>        tAPIIndexCompare   APIIndexCompare
90491>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90491>>>
90491>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
90492>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
90493>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90495>>>            Function_Return aAPIIndexCompare
90496>>>        End
90496>>>>
90496>>>
90496>>>        Decrement iSizeFrom
90497>>>        for iCount from 0 to iSizeFrom
90503>>>>
90503>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
90504>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
90505>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
90506>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
90507>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
90508>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
90509>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
90510>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
90511>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
90512>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
90513>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
90514>>>        Loop
90515>>>>
90515>>>
90515>>>        Decrement iSizeTo
90516>>>        for iCount from 0 to iSizeTo
90522>>>>
90522>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
90523>>>            // Search if the Index number already exists in the array; else add it.
90523>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
90524>>>            If (iItem = -1) Begin
90526>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
90527>>>            End
90527>>>>
90527>>>
90527>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
90528>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
90529>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
90530>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
90531>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
90532>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
90533>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
90534>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
90535>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
90536>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
90537>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
90538>>>        Loop
90539>>>>
90539>>>
90539>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
90540>>>
90540>>>        Function_Return aAPIIndexCompare
90541>>>    End_Function
90542>>>
90542>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
90542>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
90544>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
90544>>>        String sDriverID
90544>>>
90544>>>        Get psDriverID to sDriverID
90545>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90546>>>        Get IsSQLDriver sDriverID to bIsSqlTable
90547>>>        If (bIsSqlTable = True) Begin
90549>>>            Get UtilTableIsSQL hTable to bIsSqlTable
90550>>>        End
90550>>>>
90550>>>
90550>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
90551>>>        If (bIsSame = False) Begin
90553>>>            Function_Return False
90554>>>        End
90554>>>>
90554>>>
90554>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
90556>>>            // Don't think we should do this. Or should we?
90556>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
90556>>>
90556>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
90557>>>            If (bIsSame = False) Begin
90559>>>                Function_Return False
90560>>>            End
90560>>>>
90560>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
90561>>>            If (bIsSame = False) Begin
90563>>>                Function_Return False
90564>>>            End
90564>>>>
90564>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
90565>>>            If (bIsSame = False) Begin
90567>>>                Function_Return False
90568>>>            End
90568>>>>
90568>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
90569>>>            If (bIsSame = False) Begin
90571>>>                Function_Return False
90572>>>            End
90572>>>>
90572>>>        End
90572>>>>
90572>>>
90572>>>        Function_Return bIsSame
90573>>>    End_Function
90574>>>
90574>>>    // DF_INDEX_SQL_TYPE values
90574>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
90574>>>    // returns a string with the name.
90574>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
90576>>>        String sRetval
90576>>>        Case Begin
90576>>>            Case (iIndexType = DF_INDEX_CLIENT)
90578>>>                Move "DF_INDEX_CLIENT" to sRetval
90579>>>                Case Break
90580>>>            Case (iIndexType = DF_INDEX_SERVER)
90583>>>                Move "DF_INDEX_SERVER" to sRetval
90584>>>                Case Break
90585>>>            Case (iIndexType = DF_INDEX_SERVER_ONLY)
90588>>>                Move "DF_INDEX_SERVER_ONLY" to sRetval
90589>>>                Case Break
90590>>>            Case (iIndexType = DF_INDEX_TEMPORARY)
90593>>>                Move "DF_INDEX_TEMPORARY" to sRetval
90594>>>                Case Break
90595>>>            Case Else
90595>>>                Move "UNKNOWN INDEX TYPE" to sRetval
90596>>>        Case End
90596>>>        Function_Return sRetval
90597>>>    End_Function
90598>>>
90598>>>    // * Dummy function for the Studio's Code Explorer *
90598>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
90600>>>        Function_Return False
90601>>>    End_Function
90602>>>
90602>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
90602>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
90604>>>        Boolean bIsSame
90604>>>        Integer iSize iCount
90604>>>
90604>>>        Move True to bIsSame
90605>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
90606>>>        Decrement iSize
90607>>>        For iCount from 0 to iSize
90613>>>>
90613>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
90614>>>            If (bIsSame = False) Begin
90616>>>                Function_Return False
90617>>>            End
90617>>>>
90617>>>        Loop
90618>>>>
90618>>>
90618>>>        Function_Return bIsSame
90619>>>    End_Function
90620>>>
90620>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
90620>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
90622>>>        Boolean bIsSame
90622>>>
90622>>>        Move True to bIsSame
90623>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
90625>>>            Function_Return False
90626>>>        End
90626>>>>
90626>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
90628>>>            Function_Return False
90629>>>        End
90629>>>>
90629>>>
90629>>>        // We could also compare field names, but I don't think that is necessary...
90629>>>
90629>>>        Function_Return bIsSame
90630>>>    End_Function
90631>>>
90631>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
90631>>>    // already exists.
90631>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
90633>>>        Boolean bOK
90633>>>        Integer iSizeTo iSize iCount iColumn
90633>>>        String sDriverID
90633>>>
90633>>>        Move True to bOK
90634>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
90635>>>        If (iSizeTo > 0) Begin
90637>>>            Get AutoConnectionIDLogin to bOK
90638>>>            Move False to Err
90639>>>            Open hTable Mode DF_EXCLUSIVE
90641>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90644>>>            Decrement iSizeTo
90645>>>
90645>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
90645>>>            // for the "TO" database. But start by deleting all current "TO" relations:
90645>>>            Structure_Start hTable sDriverID
90646>>>                for iCount from 0 to iSizeTo
90652>>>>
90652>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
90653>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
90656>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
90659>>>                Loop
90660>>>>
90660>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
90661>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90663>>>            Set Action_Text of ghoStatusPanel to ""
90664>>>        End
90664>>>>
90664>>>
90664>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
90665>>>        Decrement iSize
90666>>>        for iCount from 0 to iSize
90672>>>>
90672>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
90673>>>        Loop
90674>>>>
90674>>>
90674>>>        Function_Return bOK
90675>>>    End_Function
90676>>>
90676>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
90678>>>        tAPIRelation[] APIRelations
90678>>>        tAPIRelation[] APIRelations
90679>>>        Integer iColumn iColumnTo iNumColumns iCount
90679>>>        Handle hParent
90679>>>        Boolean bIsOpen
90679>>>
90679>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90680>>>        Move 0 to iCount
90681>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90684>>>        If (bIsOpen = False) Begin
90686>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90687>>>            Open hTable
90689>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90690>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90693>>>            If (bIsOpen = False) Begin
90695>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90696>>>                Move True to APIRelations[0].bError
90697>>>                Function_Return APIRelations
90698>>>            End
90698>>>>
90698>>>        End
90698>>>>
90698>>>
90698>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90701>>>        For iColumn from 1 to iNumColumns
90707>>>>
90707>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
90710>>>            If (hParent <> 0) Begin
90712>>>                Open hParent
90714>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
90715>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
90718>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
90719>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
90722>>>
90722>>>                Move hParent                                            to APIRelations[iCount].hTableTo
90723>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
90726>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
90729>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
90730>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
90733>>>                Move False                                              to APIRelations[iCount].bShouldChange
90734>>>                Move False                                              to APIRelations[iCount].bCancel
90735>>>                Move False                                              to APIRelations[iCount].bError
90736>>>                Close hParent
90737>>>                Increment iCount
90738>>>            End
90738>>>>
90738>>>        Loop
90739>>>>
90739>>>
90739>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90740>>>        Function_Return APIRelations
90741>>>    End_Function
90742>>>
90742>>>    Function UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
90744>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
90746>>>            Function_Return (EQ)
90747>>>        End
90747>>>>
90747>>>
90747>>>        Function_Return (GT)
90748>>>    End_Function
90749>>>
90749>>>    Function SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
90751>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
90754>>>
90754>>>        Function_Return (GT)
90755>>>    End_Function
90756>>>
90756>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90756>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
90756>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
90758>>>        tAPIRelation[] aAPIRelationFromAndTo
90758>>>        tAPIRelation[] aAPIRelationFromAndTo
90759>>>        tAPIRelationCompare[] aAPIRelationCompare
90759>>>        tAPIRelationCompare[] aAPIRelationCompare
90760>>>        tAPIRelationCompare   APIRelationCompare
90760>>>        tAPIRelationCompare   APIRelationCompare
90760>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90760>>>
90760>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
90761>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
90762>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90764>>>            Function_Return aAPIRelationCompare
90765>>>        End
90765>>>>
90765>>>
90765>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
90766>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(UtilRelationArrayCompare))) to aAPIRelationFromAndTo
90767>>>
90767>>>        Decrement iSizeFrom
90768>>>        for iCount from 0 to iSizeFrom
90774>>>>
90774>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
90775>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
90776>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
90777>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
90778>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
90779>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
90780>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
90781>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
90782>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
90783>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
90784>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
90785>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
90786>>>        Loop
90787>>>>
90787>>>
90787>>>        Decrement iSizeTo
90788>>>        for iCount from 0 to iSizeTo
90794>>>>
90794>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
90795>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
90796>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
90797>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
90798>>>
90798>>>            // Search if the relation already exists in the array; else add it.
90798>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to iItem
90799>>>            If (iItem = -1) Begin
90801>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
90802>>>            End
90802>>>>
90802>>>
90802>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
90803>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
90804>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
90805>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
90806>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
90807>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
90808>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
90809>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
90810>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
90811>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
90812>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
90813>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
90814>>>        Loop
90815>>>>
90815>>>
90815>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to aAPIRelationCompare
90816>>>
90816>>>        Function_Return aAPIRelationCompare
90817>>>    End_Function
90818>>>
90818>>>    // * Dummy function for the Studio's Code Explorer *
90818>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
90820>>>        Function_Return False
90821>>>    End_Function
90822>>>
90822>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
90822>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
90822>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
90822>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
90824>>>        Boolean bFound
90824>>>
90824>>>        Move False to Err
90825>>>        Open CodeMast
90827>>>        Open CodeType
90829>>>
90829>>>        If (bCodeType = True) Begin
90831>>>            Set Private.phCurrentTable to CODETYPE.File_Number
90832>>>            Clear CodeType
90833>>>            Move sTypeValue to CODETYPE.Type
90834>>>            Find eq CODETYPE by 1
90835>>>>
90835>>>            Move Found to bFound
90836>>>            If (bFound = True) Begin
90838>>>                Reread CodeType
90842>>>            End
90842>>>>
90842>>>            Else Begin
90843>>>                Clear CodeType
90844>>>            End
90844>>>>
90844>>>
90844>>>            Move sTypeValue to CODETYPE.Type
90845>>>            Move sValue2    to CODETYPE.Description
90846>>>            Move sValue3    to CODETYPE.Comment
90847>>>            SaveRecord CODETYPE
90848>>>
90848>>>            If (bFound = True) Begin
90850>>>                Unlock
90851>>>>
90851>>>            End
90851>>>>
90851>>>        End
90851>>>>
90851>>>
90851>>>        If (bCodeType = False) Begin
90853>>>            Set Private.phCurrentTable to CODEMAST.File_Number
90854>>>            Clear CODEMAST
90855>>>            Move sTypeValue to CODEMAST.Type
90856>>>            Move sValue2    to CODEMAST.Code
90857>>>            Find eq CODEMAST by 1
90858>>>>
90858>>>            Move Found to bFound
90859>>>            If (bFound = True) Begin
90861>>>                Reread CODEMAST
90865>>>            End
90865>>>>
90865>>>            Else Begin
90866>>>                Clear CODEMAST
90867>>>            End
90867>>>>
90867>>>
90867>>>            Move sTypeValue to CODEMAST.Type
90868>>>            Move sValue2    to CODEMAST.Code
90869>>>            Move sValue3    to CODEMAST.Description
90870>>>            SaveRecord CODEMAST
90871>>>
90871>>>            If (bFound = True) Begin
90873>>>                Unlock
90874>>>>
90874>>>            End
90874>>>>
90874>>>        End
90874>>>>
90874>>>
90874>>>        Close CodeMast
90875>>>        Close CodeType
90876>>>
90876>>>        Function_Return (Err = False)
90877>>>    End_Function
90878>>>
90878>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
90878>>>    // CodeType and then spins through all CodeMast records to change all related records.
90878>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
90880>>>        Boolean bFound
90880>>>
90880>>>        Move False to Err
90881>>>        Open CodeMast
90883>>>        Open CodeType
90885>>>
90885>>>        Clear CodeType
90886>>>        Move sFromValue to CODETYPE.Type
90887>>>        Find eq CODETYPE.Type
90888>>>>
90888>>>        If (Found = True) Begin
90890>>>            Reread CODETYPE
90894>>>                Move sToValue to CODETYPE.Type
90895>>>                SaveRecord CODETYPE
90896>>>            Unlock
90897>>>>
90897>>>        End
90897>>>>
90897>>>
90897>>>        Clear CODEMAST
90898>>>        Find gt CODEMAST by Recnum
90899>>>>
90899>>>        While (Found = True)
90903>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
90904>>>            If (bFound = True) Begin
90906>>>                Reread CODEMAST
90910>>>                    Move sToValue to CODEMAST.Type
90911>>>                    SaveRecord CODEMAST
90912>>>                Unlock
90913>>>>
90913>>>            End
90913>>>>
90913>>>            Find gt CODEMAST by Recnum
90914>>>>
90914>>>        Loop
90915>>>>
90915>>>
90915>>>        Close CodeMast
90916>>>        Close CodeType
90917>>>
90917>>>        Function_Return (Err = False)
90918>>>    End_Function
90919>>>
90919>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
90919>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
90921>>>        Boolean bFound
90921>>>
90921>>>        Move False to Err
90922>>>        Open CodeMast
90924>>>
90924>>>        Clear CODEMAST
90925>>>        Move sTypeValue to CODEMAST.Type
90926>>>        Move sValue2    to CODEMAST.Code
90927>>>        Find eq CODEMAST.Code
90928>>>>
90928>>>        Move Found to bFound
90929>>>        If (bFound = True) Begin
90931>>>            Delete CODEMAST
90932>>>        End
90932>>>>
90932>>>
90932>>>        Close CodeMast
90933>>>
90933>>>        Function_Return (Err = False)
90934>>>    End_Function
90935>>>
90935>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
90937>>>        Boolean bRecnum bToAnsi
90937>>>        Integer iCh
90937>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
90937>>>
90937>>>        If (Trim(sDataPath) = "") Begin
90939>>>            Function_Return False
90940>>>        End
90940>>>>
90940>>>
90940>>>        Move False to Err
90941>>>        Get psDriverID     to sDriverID
90942>>>        Get psConnectionID to sConnectionID
90943>>>        Get psSchema       to sSchemaName
90944>>>        Get True           to bRecnum
90945>>>        Get pbToANSI       to bToAnsi
90946>>>        Move CS_ANSI_Txt to sANSI_OEM
90947>>>        If (bToAnsi = False) Begin
90949>>>            Move CS_OEM_Txt to sANSI_OEM
90950>>>        End
90950>>>>
90950>>>
90950>>>        Get vFolderFormat sDataPath to sDataPath
90951>>>        Move "CodeMast.int"         to sFileName
90952>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
90953>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
90956>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
90959>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
90962>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
90965>>>            Writeln channel iCh ("")
90968>>>            Writeln channel iCh ("RECNUM_TABLE YES")
90971>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
90974>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
90977>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
90980>>>            Writeln channel iCh ("")
90983>>>            Writeln channel iCh ("INDEX_NUMBER 1")
90986>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
90989>>>            Writeln channel iCh ("")
90992>>>        Send Seq_Close_Channel iCh
90993>>>
90993>>>        Get vFolderFormat sDataPath to sDataPath
90994>>>        Move "CodeType.int"         to sFileName
90995>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
90996>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
90999>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91002>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
91005>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91008>>>            Writeln channel iCh ("")
91011>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91014>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91017>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91020>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91023>>>            Writeln channel iCh ("")
91026>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91029>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91032>>>            Writeln channel iCh ("")
91035>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91038>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91041>>>            Writeln channel iCh ("")
91044>>>        Send Seq_Close_Channel iCh
91045>>>
91045>>>        Function_Return (Err = False)
91046>>>    End_Function
91047>>>
91047>>>    // * Dummy function for the Studio's Code Explorer *
91047>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
91049>>>        Function_Return False
91050>>>    End_Function
91051>>>
91051>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
91051>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
91051>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
91053>>>        Boolean bOK bExists
91053>>>        String sDataPath sBackupFolder
91053>>>
91053>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
91054>>>        Move CS_DUFBackupDataFolder to sBackupFolder
91055>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91056>>>        Get vFolderFormat sDataPath to sDataPath
91057>>>
91057>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91058>>>        If (bExists = False) Begin
91060>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
91061>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91062>>>            If (bExists = False) Begin
91064>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
91065>>>>
91065>>>                Function_Return False
91066>>>            End
91066>>>>
91066>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
91067>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
91068>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
91069>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
91070>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
91071>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
91072>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
91073>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
91074>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
91075>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
91076>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
91077>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
91078>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
91079>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
91080>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
91081>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
91082>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
91083>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
91084>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
91085>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
91086>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
91087>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
91088>>>        End
91088>>>>
91088>>>
91088>>>        Set Message_Text of ghoStatusPanel to ""
91089>>>        Function_Return True
91090>>>    End_Function
91091>>>    
91091>>>    // Check if the file exists in the Data folder,
91091>>>    // else creates it from memory as it has been compiled into the program as a resource:
91091>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
91093>>>        String sPath
91093>>>        Boolean bExists
91093>>>
91093>>>        Get psDataPathFirstPart to sPath
91094>>>        Move (sPath + sFileName) to sFileName
91095>>>        Get vFilePathExists sFileName to bExists
91096>>>
91096>>>        If (bExists = False) Begin
91098>>>            // Read from memory & create file on disk.
91098>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
91099>>>            Get vFilePathExists sFileName to bExists
91100>>>        End
91100>>>>
91100>>>        Function_Return bExists
91101>>>    End_Function
91102>>>
91102>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
91104>>>        tColumnType RetvalType
91104>>>        tColumnType RetvalType
91104>>>        Integer iRetval
91104>>>
91104>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91105>>>        Move RetvalType.iDataFlexType to iRetval
91106>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
91108>>>            If (iLength <= 255) Begin
91110>>>                Move DF_ASCII to iRetval
91111>>>            End
91111>>>>
91111>>>        End
91111>>>>
91111>>>        Function_Return iRetval
91112>>>    End_Function
91113>>>
91113>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
91115>>>        String sRetval
91115>>>
91115>>>        Case Begin
91115>>>            Case (iDataType = DF_ASCII)
91117>>>                Move "DF_ASCII" to sRetval
91118>>>                Case Break
91119>>>            Case (iDataType = DF_BCD)
91122>>>                Move "DF_BCD" to sRetval
91123>>>                Case Break
91124>>>            Case (iDataType = DF_BINARY)
91127>>>                Move "DF_BINARY" to sRetval
91128>>>                Case Break
91129>>>            Case (iDataType = DF_DATE)
91132>>>                Move "DF_DATE" to sRetval
91133>>>                Case Break
91134>>>            Case (iDataType = DF_DATETIME)
91137>>>                Move "DF_DATETIME" to sRetval
91138>>>                Case Break
91139>>>            Case (iDataType = DF_TEXT)
91142>>>                Move "DF_TEXT" to sRetval
91143>>>                Case Break
91144>>>            Case Else
91144>>>                Move "" to sRetval
91145>>>        Case End
91145>>>
91145>>>        Function_Return sRetval
91146>>>    End_Function
91147>>>
91147>>>    // The default value used for a datatype as specified in the driver int file.
91147>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
91149>>>        String sRetval sServer
91149>>>        tColumnType RetvalType
91149>>>        tColumnType RetvalType
91149>>>        Integer iDriver iDataFlexType
91149>>>        Handle hDatabase
91149>>>
91149>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91150>>>        Move RetvalType.iDataFlexType to iDataFlexType
91151>>>        Get DriverIndex sDriverID to iDriver
91152>>>        Get psServer to sServer
91153>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91154>>>        If (hDatabase = 0) Begin
91156>>>            Function_Return ""
91157>>>        End
91157>>>>
91157>>>
91157>>>        Case Begin
91157>>>            Case (iDataFlexType = DF_ASCII)
91159>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
91162>>>                Case Break
91163>>>            Case (iDataFlexType = DF_BCD)
91166>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
91169>>>                Case Break
91170>>>            Case (iDataFlexType = DF_BINARY)
91173>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
91176>>>                Case Break
91177>>>            Case (iDataFlexType = DF_DATE)
91180>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
91183>>>                Case Break
91184>>>            Case (iDataFlexType = DF_DATETIME)
91187>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
91190>>>                Case Break
91191>>>            Case (iDataFlexType = DF_TEXT)
91194>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
91197>>>                Case Break
91198>>>            Case Else
91198>>>                Move "" to sRetval
91199>>>        Case End
91199>>>
91199>>>        Function_Return sRetval
91200>>>    End_Function
91201>>>
91201>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
91203>>>        String sDriverID sServer
91203>>>        tColumnType RetvalType
91203>>>        tColumnType RetvalType
91203>>>        Integer iDbType iDriver
91203>>>        Handle hDatabase
91203>>>
91203>>>        Get psDriverID to sDriverID
91204>>>        Get piDbType   to iDbType
91205>>>        Get DriverIndex sDriverID to iDriver
91206>>>        Get psServer to sServer
91207>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91208>>>        If (hDatabase = 0) Begin
91210>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
91211>>>>
91211>>>            Procedure_Return
91212>>>        End
91212>>>>
91212>>>
91212>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
91215>>>
91215>>>    End_Procedure
91216>>>
91216>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
91218>>>        String sDriverID sServer
91218>>>        tColumnType RetvalType
91218>>>        tColumnType RetvalType
91218>>>        Integer iDbType iDriver
91218>>>        Handle hDatabase
91218>>>
91218>>>        Get psDriverID to sDriverID
91219>>>        Get piDbType   to iDbType
91220>>>        Get DriverIndex sDriverID to iDriver
91221>>>        Get psServer to sServer
91222>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91223>>>        If (hDatabase = 0) Begin
91225>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
91226>>>>
91226>>>            Procedure_Return
91227>>>        End
91227>>>>
91227>>>
91227>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
91230>>>
91230>>>    End_Procedure
91231>>>
91231>>>    // Returns a struct array with the default column types for the SQL back-end and how they
91231>>>    // are mapped to the standard DataFlex data types.
91231>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
91231>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
91233>>>        tColumnType[] ColumnTypeArray EmptyArray
91233>>>        tColumnType[] ColumnTypeArray EmptyArray
91235>>>        String sDataType
91235>>>        Integer iDataType iDriverID iCount
91235>>>        Boolean bSQLDriver
91235>>>
91235>>>        Move 0 to iCount
91236>>>        Get DriverIndex sDriverID to iDriverID
91237>>>        Get IsSQLDriver sDriverID to bSQLDriver
91238>>>        If (bSQLDriver = False) Begin
91240>>>            Function_Return EmptyArray
91241>>>        End
91241>>>>
91241>>>
91241>>>        // DF_ASCII
91241>>>        If (sDriverID = ODBC_DRV_ID) Begin
91243>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
91246>>>        End
91246>>>>
91246>>>        Else Begin
91247>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
91250>>>        End
91250>>>>
91250>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91251>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
91252>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
91253>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91254>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91255>>>        Increment iCount
91256>>>
91256>>>        // DF_BINARY
91256>>>        If (sDriverID = ODBC_DRV_ID) Begin
91258>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
91261>>>        End
91261>>>>
91261>>>        Else Begin
91262>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
91265>>>        End
91265>>>>
91265>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91266>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
91267>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
91268>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91269>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91270>>>        Increment iCount
91271>>>
91271>>>        // DF_DATE
91271>>>        If (sDriverID = ODBC_DRV_ID) Begin
91273>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
91276>>>        End
91276>>>>
91276>>>        Else Begin
91277>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
91280>>>        End
91280>>>>
91280>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91281>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
91282>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
91283>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91284>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91285>>>        Increment iCount
91286>>>
91286>>>        // DF_DATETIME
91286>>>        If (sDriverID = ODBC_DRV_ID) Begin
91288>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
91291>>>        End
91291>>>>
91291>>>        Else Begin
91292>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
91295>>>        End
91295>>>>
91295>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91296>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
91297>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
91298>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91299>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91300>>>        Increment iCount
91301>>>
91301>>>        // DF_NUMERIC
91301>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
91301>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
91301>>>        // we make them here all "Numeric"...
91301>>>        Case Begin
91301>>>            Case (sDriverID = MSSQLDRV_ID)
91303>>>                Move SQL_NUMERIC to iDataType
91304>>>                Move "numeric"   to sDataType
91305>>>                Case Break
91306>>>            Case (sDriverID = DB2_DRV_ID)
91309>>>                Move SQL_NUMERIC to iDataType
91310>>>                Move "NUMERIC"   to sDataType
91311>>>                Case Break
91312>>>            Case (sDriverID = SQLFLEX)
91315>>>                Move eSQLServer_NUMERIC to iDataType
91316>>>                Move "numeric"   to sDataType
91317>>>                Case Break
91318>>>            Case (sDriverID = MDSMySQL)
91321>>>                Move eMySQL_DECIMAL to iDataType
91322>>>                Move "decimal"   to sDataType
91323>>>                Case Break
91324>>>            Case (sDriverID = ORAFLEX)
91327>>>                Move eOracle_NUMBER to iDataType
91328>>>                Move "NUMBER"   to sDataType
91329>>>                Case Break
91330>>>            Case (sDriverID = MDSPgSQL)
91333>>>                Move ePgSQL_FLOAT4 to iDataType
91334>>>                Move "decimal"   to sDataType
91335>>>                Case Break
91336>>>            Case Else
91336>>>                Move DF_BCD      to iDataType
91337>>>                Move "Numeric"   to sDataType
91338>>>        Case End
91338>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
91339>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
91340>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91341>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91342>>>        Increment iCount
91343>>>
91343>>>        // DF_TEXT
91343>>>        If (sDriverID = ODBC_DRV_ID) Begin
91345>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
91348>>>        End
91348>>>>
91348>>>        Else Begin
91349>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
91352>>>        End
91352>>>>
91352>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91353>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
91354>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
91355>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91356>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91357>>>
91357>>>        Function_Return ColumnTypeArray
91358>>>    End_Function
91359>>>
91359>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
91361>>>        tColumnType[] ColumnTypeArray
91361>>>        tColumnType[] ColumnTypeArray
91362>>>        tColumnType   ColumnType
91362>>>        tColumnType   ColumnType
91362>>>        Integer iCount iSize
91362>>>
91362>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
91363>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
91364>>>        Decrement iSize
91365>>>
91365>>>        for iCount from 0 to iSize
91371>>>>
91371>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
91373>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
91374>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
91375>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
91376>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
91377>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
91378>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
91379>>>                Move iSize to iCount
91380>>>            End
91380>>>>
91380>>>        Loop
91381>>>>
91381>>>
91381>>>        Function_Return ColumnType
91382>>>    End_Function
91383>>>
91383>>>    // Returns a struct with the default column types for the SQL back-end and how they
91383>>>    // are mapped to a DUF data type.
91383>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
91385>>>        tColumnType ColumnType
91385>>>        tColumnType ColumnType
91385>>>        String sDataType
91385>>>        Integer iDriverID iCount
91385>>>
91385>>>        Move 0 to iCount
91386>>>        Get DriverIndex sDriverID to iDriverID
91387>>>
91387>>>        Case Begin
91387>>>            // DF_ASCII
91387>>>            Case (iType = DF_ASCII_DUF)
91389>>>                If (sDriverID = ODBC_DRV_ID) Begin
91391>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
91394>>>                End
91394>>>>
91394>>>                Else Begin
91395>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
91398>>>                End
91398>>>>
91398>>>                Move DF_ASCII    to ColumnType.iDataFlexType
91399>>>                Move "ASCII"     to ColumnType.sDataFlexType
91400>>>                Move sDataType   to ColumnType.sSQLType
91401>>>                Move DF_ASCII    to ColumnType.iSQLType
91402>>>                Move False       to ColumnType.bCanEditSize
91403>>>                Case Break
91404>>>
91404>>>            // DF_BINARY
91404>>>            Case (iType = DF_BINARY_DUF)
91407>>>                If (sDriverID = ODBC_DRV_ID) Begin
91409>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
91412>>>                End
91412>>>>
91412>>>                Else Begin
91413>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
91416>>>                End
91416>>>>
91416>>>                Move DF_BINARY   to ColumnType.iDataFlexType
91417>>>                Move "Binary"    to ColumnType.sDataFlexType
91418>>>                Move sDataType   to ColumnType.sSQLType
91419>>>                Move DF_BINARY   to ColumnType.iSQLType
91420>>>                Move False       to ColumnType.bCanEditSize
91421>>>                Case Break
91422>>>
91422>>>            // DF_DATE
91422>>>            Case (iType = DF_DATE_DUF)
91425>>>                If (sDriverID = ODBC_DRV_ID) Begin
91427>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
91430>>>                End
91430>>>>
91430>>>                Else Begin
91431>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
91434>>>                End
91434>>>>
91434>>>                Move DF_DATE     to ColumnType.iDataFlexType
91435>>>                Move "Date"      to ColumnType.sDataFlexType
91436>>>                Move sDataType   to ColumnType.sSQLType
91437>>>                Move DF_DATE     to ColumnType.iSQLType
91438>>>                Move True        to ColumnType.bCanEditSize
91439>>>                Case Break
91440>>>
91440>>>            // DF_DATETIME
91440>>>            Case (iType = DF_DATETIME_DUF)
91443>>>                If (sDriverID = ODBC_DRV_ID) Begin
91445>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
91448>>>                End
91448>>>>
91448>>>                Else Begin
91449>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
91452>>>                End
91452>>>>
91452>>>                Move DF_DATETIME to ColumnType.iDataFlexType
91453>>>                Move "DateTime"  to ColumnType.sDataFlexType
91454>>>                Move sDataType   to ColumnType.sSQLType
91455>>>                Move DF_DATETIME to ColumnType.iSQLType
91456>>>                Move True        to ColumnType.bCanEditSize
91457>>>                Case Break
91458>>>
91458>>>            // DF_NUMERIC
91458>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
91458>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
91458>>>            // we make them here all "Numeric"...
91458>>>            // If (sDriverID = ODBC_DRV_ID) Begin
91458>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
91458>>>            // End
91458>>>            // Else Begin
91458>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
91458>>>            // End
91458>>>            // ToDo: How should we find the best "Numeric" data type here?
91458>>>            Case (iType = DF_BCD_DUF)
91461>>>                Move DF_BCD      to ColumnType.iDataFlexType
91462>>>                Move "Numeric"   to ColumnType.sDataFlexType
91463>>>                Move "Numeric"   to ColumnType.sSQLType
91464>>>                Move SQL_NUMERIC to ColumnType.iSQLType
91465>>>                Move False       to ColumnType.bCanEditSize
91466>>>                Case Break
91467>>>
91467>>>            // DF_TEXT
91467>>>            Case (iType = DF_TEXT_DUF)
91470>>>                If (sDriverID = ODBC_DRV_ID) Begin
91472>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
91475>>>                End
91475>>>>
91475>>>                Else Begin
91476>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
91479>>>                End
91479>>>>
91479>>>                Move DF_TEXT     to ColumnType.iDataFlexType
91480>>>                Move "Text"      to ColumnType.sDataFlexType
91481>>>                Move sDataType   to ColumnType.sSQLType
91482>>>                Move DF_TEXT     to ColumnType.iSQLType
91483>>>                Move False       to ColumnType.bCanEditSize
91484>>>                Case Break
91485>>>
91485>>>            Case Else
91485>>>                Move -1999       to ColumnType.iDataFlexType
91486>>>                Move "Undefined" to ColumnType.sDataFlexType
91487>>>                Move "Undefined" to ColumnType.sSQLType
91488>>>                Move -1999       to ColumnType.iSQLType
91489>>>                Move True        to ColumnType.bCanEditSize
91490>>>
91490>>>        Case End
91490>>>
91490>>>        Function_Return ColumnType
91491>>>    End_Function
91492>>>
91492>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
91494>>>        String sDataPath sDriverID
91494>>>        Boolean bMertechDriver bOK
91494>>>        Integer iPos
91494>>>
91494>>>        If (sTableName contains ".") Begin
91496>>>            Move (Pos(".", sTableName)) to iPos
91497>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
91498>>>        End
91498>>>>
91498>>>
91498>>>        Get psDriverID to sDriverID
91499>>>        Get psDataPathFirstPart to sDataPath
91500>>>        Get IsMertechDriver sDriverID to bMertechDriver
91501>>>        // First delete the cache file:
91501>>>        If (bMertechDriver = False) Begin
91503>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
91504>>>        End
91504>>>>
91504>>>        Else Begin
91505>>>            Get _MertechDeleteTDFile sTableName to bOK
91506>>>        End
91506>>>>
91506>>>
91506>>>        Function_Return bOK
91507>>>    End_Function
91508>>>
91508>>>    // Changes source code files.
91508>>>    // Pass a file name with full path and a value to search for, together with the value
91508>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
91508>>>    // to use a Connection ID.
91508>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
91508>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
91508>>>    // Returns True if no errors occured.
91508>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
91510>>>        Integer iCh iRow iItems iCount
91510>>>        String sValue sRow
91510>>>        String[] sFileArray
91511>>>        Boolean bExists bIsActive
91511>>>
91511>>>        Move False to Err
91512>>>        Move 0 to iRow
91513>>>
91513>>>        If (ghoStatusPanel <> 0) Begin
91515>>>            Get Active_state of ghoStatusPanel to bIsActive
91516>>>        End
91516>>>>
91516>>>
91516>>>        Get vFilePathExists sFileName to bExists
91517>>>        If (bExists = False) Begin
91519>>>            If (bShowResult = True) Begin
91521>>>                If (bIsActive = True) Begin
91523>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
91524>>>                End
91524>>>>
91524>>>                Else Begin
91525>>>                    Showln "File does not exist: " sFileName
91528>>>                End
91528>>>>
91528>>>            End
91528>>>>
91528>>>            Function_Return False
91529>>>        End
91529>>>>
91529>>>
91529>>>        Get Seq_Open_Input_Channel sFileName to iCh
91530>>>        If (iCh < 1) Begin
91532>>>            Function_Return False
91533>>>        End
91533>>>>
91533>>>
91533>>>        If (bShowResult = True) Begin
91535>>>            If (ghoStatusPanel <> 0) Begin
91537>>>                Get Active_state of ghoStatusPanel to bIsActive
91538>>>                If (bIsActive = True) Begin
91540>>>                    Set Message_Text of ghoStatusPanel to sFileName
91541>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
91542>>>                    Send DoAdvance of ghoProgressBar
91543>>>                End
91543>>>>
91543>>>            End
91543>>>>
91543>>>            Else Begin
91544>>>                Showln ""
91546>>>                Showln "sFileName = " sFileName
91549>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
91554>>>            End
91554>>>>
91554>>>        End
91554>>>>
91554>>>
91554>>>        While (not(SeqEof))
91558>>>            Readln channel iCh sRow
91560>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
91562>>>//                If (bShowResult = True) Begin
91562>>>//                    If (bIsActive = True) Begin
91562>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
91562>>>//                    End
91562>>>//                    Else Begin
91562>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
91562>>>//                    End
91562>>>//                End
91562>>>                // Change the whole line to the new connection id:
91562>>>                Move sChangeTo to sRow
91563>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
91563>>>            End
91563>>>>
91563>>>            Move sRow to sFileArray[iRow]
91564>>>            Increment iRow
91565>>>        Loop
91566>>>>
91566>>>        Send Seq_Close_Channel iCh
91567>>>
91567>>>        Sleep 1 // Wait for Windows to close the file
91568>>>
91568>>>        Get Seq_Open_Output_Channel sFileName to iCh
91569>>>        If (iCh < 1) Begin
91571>>>            Function_Return False
91572>>>        End
91572>>>>
91572>>>        Move (SizeOfArray(sFileArray)) to iItems
91573>>>        Decrement iItems
91574>>>
91574>>>        For iCount from 0 to iItems
91580>>>>
91580>>>            Move sFileArray[iCount] to sValue
91581>>>            Writeln channel iCh sValue
91584>>>        Loop
91585>>>>
91585>>>        Send Seq_Close_Channel iCh
91586>>>
91586>>>        Function_Return (Err = False)
91587>>>    End_Function
91588>>>
91588>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
91590>>>        Integer iRetval
91590>>>        Move 1 to iRetval
91591>>>        If (ghoSQLConnectionHandler <> 0) Begin
91593>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
91594>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
91595>>>        End
91595>>>>
91595>>>        Function_Return (iRetval = 0)
91596>>>    End_Function
91597>>>
91597>>>    // *** DEPRECIATED ***
91597>>>    // Use the AutoSetConnectionID function instead.
91597>>>    // This might be needed by API-methods when a connection id is to be used and
91597>>>    // the connection ID hasn't been established with the driver's CLI interface.
91597>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
91597>>>//    Function UtilCreateConnectionID String sConnectionID Returns Boolean
91597>>>//        String sConnectionString sDriverID
91597>>>//        Boolean bOK bSilent bDawDriver
91597>>>//        Handle hoCLI
91597>>>//
91597>>>//        Move False to bOK
91597>>>//        Get psDriverID to sDriverID
91597>>>//        Get IsDAWSQLDriver sDriverID to bDawDriver
91597>>>//        If (bDawDriver = False) Begin
91597>>>//            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
91597>>>//            Function_Return False
91597>>>//        End
91597>>>//
91597>>>//        Get psConnectionString to sConnectionString
91597>>>//        Get pbSilentLogin      to bSilent
91597>>>//
91597>>>//        Get phoCLIHandler to hoCLI
91597>>>//        If (hoCLI <> 0) Begin
91597>>>//            Set psDriverID of hoCLI to sDriverID
91597>>>//            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
91597>>>//        End
91597>>>//
91597>>>//        Function_Return (bOK = False)
91597>>>//    End_Function
91597>>>
91597>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
91597>>>    // and opens it in "notepad.exe".
91597>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
91597>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
91597>>>    Procedure UtilShowErrorList
91599>>>        tSqlErrorArray aSqlErrorArray
91599>>>        tSqlErrorArray aSqlErrorArray
91599>>>        Integer iRows iCount iCh iErrorNum
91599>>>        String sPath sFileName sErrorTxt sStatement
91599>>>
91599>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
91600>>>        Get vFolderFormat sPath to sPath
91601>>>        Move "SQLErrorLog.txt"  to sFileName
91602>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
91603>>>            Get paSqlErrorArray to aSqlErrorArray
91604>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
91605>>>            If (iRows > 0) Begin
91607>>>                Decrement iRows
91608>>>                for iCount from 0 to iRows
91614>>>>
91614>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
91615>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
91616>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
91617>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
91623>>>                    Writeln channel iCh "SQL Statement: " sStatement
91627>>>                Loop
91628>>>>
91628>>>            End
91628>>>>
91628>>>        Send Seq_Close_Channel iCh
91629>>>
91629>>>        If (iRows > 0) Begin
91631>>>            Runprogram Shell Background (sPath + sFileName)
91632>>>        End
91632>>>>
91632>>>    End_Procedure
91633>>>
91633>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
91633>>>    // and the table needs to exist as an SQL table.
91633>>>    Function UtilTableIsSql Handle hTable Returns Boolean
91635>>>        String sRootName sDriverID
91635>>>        Boolean bIsSQL
91635>>>
91635>>>        Move False to bIsSQL
91636>>>        If (hTable > 0) Begin
91638>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91641>>>            Get UtilTableIsSqlByRootName sRootName to bIsSQL
91642>>>            If (bIsSQL = True) Begin
91644>>>                Get psDriverID to sDriverID
91645>>>                Get _TableNameOnly sRootName to sRootName
91646>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
91647>>>            End
91647>>>>
91647>>>        End
91647>>>>
91647>>>
91647>>>        Function_Return bIsSQL
91648>>>    End_Function
91649>>>
91649>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
91651>>>        Boolean bIsSQL
91651>>>        Move (sRootName contains ":") to bIsSQL
91652>>>        Function_Return bIsSQL
91653>>>    End_Function
91654>>>
91654>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
91654>>>    // that the embedded .dat file exists on disk.
91654>>>    Function UtilTableIsEmbedded Handle hTable Returns Boolean
91656>>>        Boolean bExists bIsEmbedded
91656>>>        String sDataPath sRootName
91656>>>
91656>>>        Get UtilTableNumberIsInUse hTable to bExists
91657>>>        If (bExists = False) Begin
91659>>>            Function_Return False
91660>>>        End
91660>>>>
91660>>>
91660>>>        Move False to bIsEmbedded
91661>>>        If (hTable > 0) Begin
91663>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91666>>>            Move (not(sRootName contains ":")) to bIsEmbedded
91667>>>        End
91667>>>>
91667>>>        If (bIsEmbedded = True) Begin
91669>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91670>>>            Get vFolderFormat sDataPath to sDataPath
91671>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
91672>>>        End
91672>>>>
91672>>>
91672>>>        Function_Return bIsEmbedded
91673>>>    End_Function
91674>>>
91674>>>
91674>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
91674>>>    // An Alias file/table is a filelist number that share the same Physical filename
91674>>>    // but the Logical name is different.
91674>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
91674>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
91676>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
91676>>>        Handle hInTable hMasterTable 
91676>>>        Boolean bIsAlias
91676>>>        
91676>>>        Move hTable to hInTable
91677>>>        Move False to bIsAlias
91678>>>        Move 0 to hMasterTable
91679>>>        
91679>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91682>>>        // Remove any prefix with a driver name.
91682>>>        Get _TableNameOnly sRootName to sRootName     
91683>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91686>>>        Get _TableNameOnly sLogicalName to sLogicalName     
91687>>>        
91687>>>        // If the table has the same root and logical name it can't be an alias,
91687>>>        // so we can safely return a "False".
91687>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
91689>>>            Function_Return False
91690>>>        End
91690>>>>
91690>>>        
91690>>>        // Now we need to find a master table with the same root name (sRootName above),
91690>>>        // as the passed hTable root name.
91690>>>        // A master table always has the same root and logical name.
91690>>>        Move 0 to hTable
91691>>>        Repeat
91691>>>>
91691>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91694>>>            If (hTable > 0 and hTable <> 50) Begin
91696>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
91699>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
91700>>>                // If we found another table with the same root and logical name
91700>>>                // we have found a master table.
91700>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
91702>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
91705>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
91706>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
91708>>>                        Move hTable to hMasterTable   
91709>>>                        Move 0 to hTable // To end the loop.
91710>>>                    End
91710>>>>
91710>>>                End
91710>>>>
91710>>>            End
91710>>>>
91710>>>        Until (hTable = 0)
91712>>>        
91712>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
91714>>>            Move True to bIsAlias
91715>>>        End
91715>>>>
91715>>>        
91715>>>        Function_Return bIsAlias
91716>>>    End_Function
91717>>>
91717>>>    // To Open a table with any driver.
91717>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
91717>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
91717>>>    //
91717>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
91717>>>    // The found flag is still used to indicate if the open was successful or not. The function
91717>>>    // returns a True if successful (table could be opened).
91717>>>    //
91717>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
91717>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
91717>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
91717>>>    // set properly we can open the table.
91717>>>    //
91717>>>    // DAW Driver Syntax:
91717>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
91717>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
91717>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
91717>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
91717>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
91717>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
91717>>>    //
91717>>>    // DAW Driver Sample:
91717>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
91717>>>    //
91717>>>    // Mertech Driver Samples:
91717>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
91717>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
91717>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
91717>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
91717>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
91719>>>        String sTableNameOrg
91719>>>        Boolean bOpen bOK
91719>>>        tSQLConnection SQLConnection
91719>>>        tSQLConnection SQLConnection
91719>>>        
91719>>>        Move False to bOpen
91720>>>        Move sTableName to sTableNameOrg
91721>>>        If (hTable > 0) Begin
91723>>>            Send Ignore_Error of Error_Object_Id 20529
91724>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91725>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91726>>>            Send Ignore_Error of Error_Object_Id 10
91727>>>            Open hTable Mode iMode
91729>>>            Send Trap_Error of Error_Object_Id 20529
91730>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91731>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91732>>>            Send Trap_Error of Error_Object_Id 10
91733>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91736>>>            If (bOpen = True) Begin
91738>>>                Function_Return True
91739>>>            End
91739>>>>
91739>>>        End
91739>>>>
91739>>>
91739>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
91740>>>        If (hTable > 0) Begin
91742>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91745>>>        End
91745>>>>
91745>>>
91745>>>        Function_Return bOpen
91746>>>    End_Function
91747>>>
91747>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
91749>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
91749>>>        Boolean bOpen bMertechDriver bOK
91749>>>        tSQLConnection SQLConnection
91749>>>        tSQLConnection SQLConnection
91749>>>
91749>>>        If (hTable < 1) Begin
91751>>>            Function_Return False
91752>>>        End
91752>>>>
91752>>>
91752>>>        Move sTableName to sTableNameOrg
91753>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91754>>>        Move SQLConnection.sDriverID to sDriverID
91755>>>        Get IsMertechDriver sDriverID to bMertechDriver
91756>>>        Move SQLConnection.sConnectionString to sConnection
91757>>>        Move SQLConnection.sSchema to sSchema
91758>>>        If (sSchema = "") Begin
91760>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
91761>>>        End
91761>>>>
91761>>>
91761>>>        // We need to remove the ".int" part of the table name because
91761>>>        // the table name after the "#" in the connection syntax below wants the
91761>>>        // "bare" table name without any extension.
91761>>>        If (sDriverID <> DATAFLEX_ID) Begin
91763>>>            If (Lowercase(sTableName) contains ".int") Begin
91765>>>                Get ParseFileExtension sTableName to sExt
91766>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
91767>>>            End
91767>>>>
91767>>>            Else Begin
91768>>>                Move sTableName to sTableNameShort
91769>>>                Move (Append(sTableName, ".int")) to sTableName
91770>>>            End
91770>>>>
91770>>>            If (bMertechDriver = False) Begin
91772>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
91773>>>                Move sConnection to sTableName
91774>>>            End
91774>>>>
91774>>>        End
91774>>>>
91774>>>
91774>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91775>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91776>>>        If (hTable = 0) Begin
91778>>>            Get NextFreeFilelistSlot to hTable
91779>>>        End
91779>>>>
91779>>>
91779>>>        Case Begin
91779>>>            Case (sDriverID = MSSQLDRV_ID)
91781>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91781>>>                If (iMode <> DF_EXCLUSIVE) Begin
91783>>>                    Close hTable
91784>>>                    Open sTableName as hTable
91786>>>                End
91786>>>>
91786>>>                Else Begin
91787>>>                    Get OpenTableExclusive hTable to bOK
91788>>>                    If (bOK = False) Begin
91790>>>                        Function_Return False
91791>>>                    End
91791>>>>
91791>>>                End
91791>>>>
91791>>>                Case Break
91792>>>
91792>>>            Case (sDriverID = DB2_DRV_ID)
91795>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91795>>>                If (iMode <> DF_EXCLUSIVE) Begin
91797>>>                    Close hTable
91798>>>                    Open sTableName as hTable
91800>>>                End
91800>>>>
91800>>>                Else Begin
91801>>>                    Get OpenTableExclusive hTable to bOK
91802>>>                    If (bOK = False) Begin
91804>>>                        Function_Return False
91805>>>                    End
91805>>>>
91805>>>                End
91805>>>>
91805>>>                Case Break
91806>>>
91806>>>            Case (sDriverID = ODBC_DRV_ID)
91809>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91809>>>                If (iMode = DF_SHARE) Begin
91811>>>                    Close hTable
91812>>>                    Open sTableName as hTable
91814>>>                End
91814>>>>
91814>>>                Else Begin
91815>>>                    Get OpenTableExclusive hTable to bOK
91816>>>                    If (bOK = False) Begin
91818>>>                        Function_Return False
91819>>>                    End
91819>>>>
91819>>>                End
91819>>>>
91819>>>                Case Break
91820>>>
91820>>>            Case (sDriverID = SQLFLEX)
91823>>>                // ToDo: What is the <owner>? Same as Schema?
91823>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
91823>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
91824>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91824>>>                If (iMode <> DF_EXCLUSIVE) Begin
91826>>>                    Close hTable
91827>>>                    Open sTableName as hTable
91829>>>                End
91829>>>>
91829>>>                Else Begin
91830>>>                    Get OpenTableExclusive hTable to bOK
91831>>>                    If (bOK = False) Begin
91833>>>                        Function_Return False
91834>>>                    End
91834>>>>
91834>>>                End
91834>>>>
91834>>>                Case Break
91835>>>
91835>>>            Case (sDriverID = MDSMySQL)
91838>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
91838>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
91839>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91839>>>                If (iMode <> DF_EXCLUSIVE) Begin
91841>>>                    Close hTable
91842>>>                    Open sTableName as hTable
91844>>>                End
91844>>>>
91844>>>                Else Begin
91845>>>                    Get OpenTableExclusive hTable to bOK
91846>>>                    If (bOK = False) Begin
91848>>>                        Function_Return False
91849>>>                    End
91849>>>>
91849>>>                End
91849>>>>
91849>>>                Case Break
91850>>>
91850>>>            Case (sDriverID = MDSPgSQL)
91853>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
91853>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
91854>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91854>>>                If (iMode <> DF_EXCLUSIVE) Begin
91856>>>                    Close hTable
91857>>>                    Open sTableName as hTable
91859>>>                End
91859>>>>
91859>>>                Else Begin
91860>>>                    Get OpenTableExclusive hTable to bOK
91861>>>                    If (bOK = False) Begin
91863>>>                        Function_Return False
91864>>>                    End
91864>>>>
91864>>>                End
91864>>>>
91864>>>                Case Break
91865>>>
91865>>>            Case (sDriverID = ORAFLEX)
91868>>>                // ToDo: What is the <owner>? Same as Schema?
91868>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
91868>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
91869>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91869>>>                If (iMode <> DF_EXCLUSIVE) Begin
91871>>>                    Close hTable
91872>>>                    Open sTableName as hTable
91874>>>                End
91874>>>>
91874>>>                Else Begin
91875>>>                    Get OpenTableExclusive hTable to bOK
91876>>>                    If (bOK = False) Begin
91878>>>                        Function_Return False
91879>>>                    End
91879>>>>
91879>>>                End
91879>>>>
91879>>>                Case Break
91880>>>
91880>>>            Case (sDriverID = DATAFLEX_ID)
91883>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
91885>>>                    Close hTable
91886>>>                    Open sTableName as hTable
91888>>>                End
91888>>>>
91888>>>                Else If (iMode = DF_EXCLUSIVE) Begin
91891>>>                    Get OpenTableExclusive hTable to bOK
91892>>>                    If (bOK = False) Begin
91894>>>                        Function_Return False
91895>>>                    End
91895>>>>
91895>>>                End
91895>>>>
91895>>>                Else Begin
91896>>>                    Open hTable
91898>>>                End
91898>>>>
91898>>>                Case Break
91899>>>
91899>>>            Case Else
91899>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
91900>>>>
91900>>>        Case End
91900>>>
91900>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91901>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91902>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
91904>>>            Move False to Found
91905>>>        End
91905>>>>
91905>>>        // If open failed, the Err is set to true,
91905>>>        // but we don't want that because it could end our loop.
91905>>>        Move False to Err
91906>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91909>>>
91909>>>        Function_Return bOpen
91910>>>    End_Function
91911>>>
91911>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
91911>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
91911>>>    // if it is an SQL table
91911>>>    Function UtilTableExists Handle hTable Returns Boolean
91913>>>        Boolean bExists bIsSQLTable
91913>>>        String sDataPath sRootName
91913>>>
91913>>>        Get UtilTableNumberIsInUse hTable to bExists
91914>>>        If (bExists = False) Begin
91916>>>            Function_Return False
91917>>>        End
91917>>>>
91917>>>
91917>>>        Move False to bIsSQLTable
91918>>>        If (hTable > 0) Begin
91920>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91923>>>            Move (sRootName contains ":") to bIsSQLTable
91924>>>        End
91924>>>>
91924>>>        If (bIsSQLTable = True) Begin
91926>>>            Get UtilTableIsSQL hTable to bExists
91927>>>            Function_Return bExists
91928>>>        End
91928>>>>
91928>>>        Else Begin
91929>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91930>>>            Get vFolderFormat sDataPath to sDataPath
91931>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
91932>>>        End
91932>>>>
91932>>>
91932>>>        Function_Return bExists
91933>>>    End_Function
91934>>>
91934>>>    // Pass a table handle
91934>>>    // Returns True if the table exists in filelist.cfg.
91934>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
91936>>>        Handle hTable
91936>>>        Boolean bFound
91936>>>
91936>>>        Move False to bFound
91937>>>        Move 0 to hTable
91938>>>        Repeat
91938>>>>
91938>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91941>>>            If (hTable > 0) Begin
91943>>>                If (hTable = hCheckTable) Begin
91945>>>                    Move True to bFound
91946>>>                End
91946>>>>
91946>>>            End
91946>>>>
91946>>>            If (bFound = True) ;                Break
91949>>>        Until (hTable = 0)
91951>>>
91951>>>        Function_Return (bFound = True)
91952>>>    End_Function
91953>>>
91953>>>    // Pass a table's logical name
91953>>>    // Returns True if the table exists in filelist.cfg.
91953>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
91955>>>        Handle hTable
91955>>>        Boolean bFound
91955>>>        String sCompareTable
91955>>>
91955>>>        Move False to bFound
91956>>>        Move 0 to hTable
91957>>>        Repeat
91957>>>>
91957>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91960>>>            If (hTable > 0) Begin
91962>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
91965>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
91967>>>                    Move True to bFound
91968>>>                End
91968>>>>
91968>>>            End
91968>>>>
91968>>>            If (bFound = True) ;                Break
91971>>>        Until (hTable = 0)
91973>>>
91973>>>        Function_Return (bFound = True)
91974>>>    End_Function
91975>>>
91975>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
91975>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
91977>>>        Boolean bOK bExists
91977>>>        String sDriverID
91977>>>
91977>>>        Get UtilTableExists hTable to bExists
91978>>>        If (bExists = False) Begin
91980>>>            Function_Return DATAFLEX_ID
91981>>>        End
91981>>>>
91981>>>        Get OpenTableExclusive hTable to bOK
91982>>>        If (bOK = False) Begin
91984>>>            Function_Return DATAFLEX_ID
91985>>>        End
91985>>>>
91985>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91988>>>        Function_Return sDriverID
91989>>>    End_Function
91990>>>
91990>>>    // Number of tables in Filelist.cfg. Returns integger
91990>>>    Function UtilFilelistNoOfTables Returns Integer
91992>>>        Handle hTable
91992>>>        Integer iRetval
91992>>>
91992>>>        Move 0 to hTable
91993>>>        Move 0 to iRetval
91994>>>
91994>>>        Repeat
91994>>>>
91994>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91997>>>            If (hTable > 0) Begin
91999>>>                Increment iRetval
92000>>>            End
92000>>>>
92000>>>        Until (hTable = 0)
92002>>>
92002>>>        Function_Return iRetval
92003>>>    End_Function
92004>>>
92004>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
92004>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
92006>>>        Handle hTable
92006>>>        String sRoot sDriverID
92006>>>        Boolean bIsSQLTable
92006>>>        Integer iPos
92006>>>
92006>>>        Move 0 to hTable
92007>>>        Move "" to sDriverID
92008>>>        Move False to bIsSQLTable
92009>>>
92009>>>        Repeat
92009>>>>
92009>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92012>>>            If (hTable > 0) Begin
92014>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
92017>>>                If (sRoot contains ":") Begin
92019>>>                    Move (Pos(":", sRoot)) to iPos
92020>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
92021>>>                End
92021>>>>
92021>>>                Get IsSQLDriver sDriverID to bIsSQLTable
92022>>>            End
92022>>>>
92022>>>
92022>>>        Until (hTable = 0 or bIsSQLTable = True)
92024>>>
92024>>>        Function_Return sDriverID
92025>>>    End_Function
92026>>>
92026>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
92028>>>        String sRootName
92028>>>        Boolean bIsSQL
92028>>>        Handle hTable
92028>>>
92028>>>        Move False to bIsSQL
92029>>>        Move 0 to hTable
92030>>>        Repeat
92030>>>>
92030>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92033>>>            If (hTable > 0) Begin
92035>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92038>>>                Get UtilTableIsSqlByRootName sRootName to bIsSQL
92039>>>                If (bIsSQL = True) Begin
92041>>>                    Move 0 to hTable
92042>>>                End
92042>>>>
92042>>>            End
92042>>>>
92042>>>        Until (hTable = 0)
92044>>>
92044>>>        Function_Return (bIsSQL = False)
92045>>>    End_Function
92046>>>
92046>>>    // * Dummy function for the Studio's Code Explorer *
92046>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
92048>>>        Function_Return False
92049>>>    End_Function
92050>>>
92050>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
92052>>>        String  sRetval
92052>>>        String[] sOverlapFieldsArray
92053>>>        Integer iType iColumn iColumns
92053>>>        Boolean bOpen bOverlap
92053>>>
92053>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92056>>>        If (bOpen = False) Begin
92058>>>            Open hTable
92060>>>        End
92060>>>>
92060>>>
92060>>>        Move "" to sRetval
92061>>>
92061>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
92064>>>
92064>>>        for iColumn from 0 to iColumns
92070>>>>
92070>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
92073>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
92075>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
92078>>>                If (bOverlap) Begin
92080>>>                    If (sRetval <> "") Begin
92082>>>                        Append sRetval ","
92083>>>                    End
92083>>>>
92083>>>                    Append sRetval iColumn
92084>>>                End
92084>>>>
92084>>>            End
92084>>>>
92084>>>        Loop
92085>>>>
92085>>>
92085>>>        If (bOpen = False) Begin
92087>>>            Close hTable
92088>>>        End
92088>>>>
92088>>>
92088>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
92089>>>
92089>>>        Function_Return sOverlapFieldsArray
92090>>>    End_Function
92091>>>
92091>>>    // Returns a struct array with all data types for the passed driver & dbtype.
92091>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
92093>>>        tColumnType[] ColumnType
92093>>>        tColumnType[] ColumnType
92094>>>
92094>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
92094>>>        // the dbType.
92094>>>        If (sDriverID = ODBC_DRV_ID) Begin
92096>>>            If (iDbType = EN_DbTypeMySQL) Begin
92098>>>                Move MDSMySQL to sDriverID
92099>>>            End
92099>>>>
92099>>>            If (iDbType = EN_DbTypeMSSQL) Begin
92101>>>                Move MSSQLDRV_ID to sDriverID
92102>>>            End
92102>>>>
92102>>>            If (iDbType = EN_DbTypeDB2) Begin
92104>>>                Move DB2_DRV_ID to sDriverID
92105>>>            End
92105>>>>
92105>>>            If (iDbType = EN_DbTypePostgre) Begin
92107>>>                Move MDSPgSQL to sDriverID
92108>>>            End
92108>>>>
92108>>>        End
92108>>>>
92108>>>
92108>>>        Case Begin
92108>>>            Case (iDbType = EN_dbTypeDataFlex)
92110>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
92111>>>                Case Break
92112>>>
92112>>>            Case (iDbType = EN_DbTypeDB2)
92115>>>                Get _UtilEnumerateDB2Types to ColumnType
92116>>>                Case Break
92117>>>
92117>>>            Case (iDbType = EN_DbTypeMSSQL)
92120>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
92121>>>                Case Break
92122>>>
92122>>>            Case (sDriverID = MDSMySQL)
92125>>>                Get _UtilEnumerateMySQLTypes to ColumnType
92126>>>                Case Break
92127>>>
92127>>>            Case (sDriverID = ORAFLEX)
92130>>>                Get _UtilEnumerateOracleTypes to ColumnType
92131>>>                Case Break
92132>>>
92132>>>            Case (sDriverID = MDSPgSQL)
92135>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
92136>>>                Case Break
92137>>>        Case End
92137>>>
92137>>>        Function_Return ColumnType
92138>>>    End_Function
92139>>>
92139>>>    Function UtilEnumerateODBCDrivers Returns String
92141>>>        Handle hoRegistry hoODBCDriverNames
92141>>>        Boolean bExists bKeyOpened
92141>>>        String sKey
92141>>>        String[] sDrivers
92142>>>        Integer iDriverNames iDriverName
92142>>>
92142>>>        Get Create (RefClass (cRegistry)) to hoRegistry
92143>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
92144>>>        Set pfAccessRights of hoRegistry to Key_Read
92145>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
92146>>>        Get KeyExists of hoRegistry sKey to bExists
92147>>>        If (bExists) Begin
92149>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
92150>>>            If (bKeyOpened) Begin
92152>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
92153>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
92154>>>                If (iDriverNames > 0) Begin
92156>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
92157>>>                    Decrement iDriverNames
92158>>>                    for iDriverName from 0 to iDriverNames
92164>>>>
92164>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
92165>>>                    Loop
92166>>>>
92166>>>                End
92166>>>>
92166>>>                Send CloseKey of hoRegistry
92167>>>            End
92167>>>>
92167>>>        End
92167>>>>
92167>>>        Send Destroy of hoRegistry
92168>>>
92168>>>        Function_Return sDrivers
92169>>>    End_Function
92170>>>
92170>>>    // DataFlex Embedded Database Data Types:
92170>>>    // Helper function for UtilEnumerateColumnTypes
92170>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
92172>>>        tColumnType[] ColumnType
92172>>>        tColumnType[] ColumnType
92173>>>        Integer i
92173>>>
92173>>>        Move DF_ASCII           to ColumnType[i].iSQLType
92174>>>        Move "ASCII"            to ColumnType[i].sSQLType
92175>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92176>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92177>>>        Move "254"              to ColumnType[i].sPrecision
92178>>>        Increment i
92179>>>
92179>>>        Move DF_BCD             to ColumnType[i].iSQLType
92180>>>        Move "Numeric"          to ColumnType[i].sSQLType
92181>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92182>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92183>>>        Move "14.8"             to ColumnType[i].sPrecision
92184>>>        Increment i
92185>>>
92185>>>        Move DF_DATE            to ColumnType[i].iSQLType
92186>>>        Move "Date"             to ColumnType[i].sSQLType
92187>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
92188>>>        Move "Date"             to ColumnType[i].sDataFlexType
92189>>>        Move "6.0"              to ColumnType[i].sPrecision
92190>>>        Move True               to ColumnType[i].bCanEditSize
92191>>>        Increment i
92192>>>
92192>>>        Move DF_TEXT            to ColumnType[i].iSQLType
92193>>>        Move "Text"             to ColumnType[i].sSQLType
92194>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92195>>>        Move "Text"             to ColumnType[i].sDataFlexType
92196>>>        Move "16384"            to ColumnType[i].sPrecision
92197>>>        Increment i
92198>>>
92198>>>        Move DF_BINARY          to ColumnType[i].iSQLType
92199>>>        Move "Binary"           to ColumnType[i].sSQLType
92200>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92201>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92202>>>        Move "16384"            to ColumnType[i].sPrecision
92203>>>        Increment i
92204>>>
92204>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
92205>>>        Move "DateTime"         to ColumnType[i].sSQLType
92206>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
92207>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
92208>>>        Move "23"               to ColumnType[i].sPrecision
92209>>>        Move True               to ColumnType[i].bCanEditSize
92210>>>        Increment i
92211>>>
92211>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
92212>>>        Move "Overlap"          to ColumnType[i].sSQLType
92213>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
92214>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
92215>>>        Move "0.0"              to ColumnType[i].sPrecision
92216>>>
92216>>>        Function_Return ColumnType
92217>>>    End_Function
92218>>>
92218>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
92220>>>        tColumnType[] aColumnType
92220>>>        tColumnType[] aColumnType
92221>>>        Integer i
92221>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
92221>>>>// Generated By The Database Update Framework
92221>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
92221>>>>// Driver COLUMN DATA TYPES
92221>>>>//
92221>>>>// Created: 2019-07-18 18:57:13.935
92221>>>>
92221>>>>            Move "bigint"                                to aColumnType[i].sSQLType
92222>>>>            Move -5                                      to aColumnType[i].iSQLType
92223>>>>            Move True                                    to aColumnType[i].bCanEditSize
92224>>>>            Move True                                    to aColumnType[i].bNativeDataType
92225>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92226>>>>            Move 1                                       to aColumnType[i].iMinSize
92227>>>>            Move 14                                      to aColumnType[i].nMaxSize
92228>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92229>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92230>>>>            Move 14                                      to aColumnType[i].sPrecision
92231>>>>            Increment i
92232>>>>
92232>>>>            Move "binary"                                to aColumnType[i].sSQLType
92233>>>>            Move -2                                      to aColumnType[i].iSQLType
92234>>>>            Move True                                    to aColumnType[i].bCanEditSize
92235>>>>            Move True                                    to aColumnType[i].bNativeDataType
92236>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92237>>>>            Move 1                                       to aColumnType[i].iMinSize
92238>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92239>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92240>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92241>>>>            Move 8000                                    to aColumnType[i].sPrecision
92242>>>>            Increment i
92243>>>>
92243>>>>            Move "bit"                                   to aColumnType[i].sSQLType
92244>>>>            Move -7                                      to aColumnType[i].iSQLType
92245>>>>            Move False                                   to aColumnType[i].bCanEditSize
92246>>>>            Move True                                    to aColumnType[i].bNativeDataType
92247>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92248>>>>            Move 0                                       to aColumnType[i].iMinSize
92249>>>>            Move 0                                       to aColumnType[i].nMaxSize
92250>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92251>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92252>>>>            Move 1                                       to aColumnType[i].sPrecision
92253>>>>            Increment i
92254>>>>
92254>>>>            Move "char"                                  to aColumnType[i].sSQLType
92255>>>>            Move 1                                       to aColumnType[i].iSQLType
92256>>>>            Move True                                    to aColumnType[i].bCanEditSize
92257>>>>            Move True                                    to aColumnType[i].bNativeDataType
92258>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92259>>>>            Move 1                                       to aColumnType[i].iMinSize
92260>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92261>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92262>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92263>>>>            Move 8000                                    to aColumnType[i].sPrecision
92264>>>>            Increment i
92265>>>>
92265>>>>            Move "date"                                  to aColumnType[i].sSQLType
92266>>>>            Move 91                                      to aColumnType[i].iSQLType
92267>>>>            Move False                                   to aColumnType[i].bCanEditSize
92268>>>>            Move True                                    to aColumnType[i].bNativeDataType
92269>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92270>>>>            Move 0                                       to aColumnType[i].iMinSize
92271>>>>            Move 0                                       to aColumnType[i].nMaxSize
92272>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92273>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92274>>>>            Move 1                                       to aColumnType[i].sPrecision
92275>>>>            Increment i
92276>>>>
92276>>>>            Move "datetime"                              to aColumnType[i].sSQLType
92277>>>>            Move 93                                      to aColumnType[i].iSQLType
92278>>>>            Move False                                   to aColumnType[i].bCanEditSize
92279>>>>            Move True                                    to aColumnType[i].bNativeDataType
92280>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92281>>>>            Move -1                                      to aColumnType[i].iMinSize
92282>>>>            Move -1                                      to aColumnType[i].nMaxSize
92283>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92284>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92285>>>>            Move 23                                      to aColumnType[i].sPrecision
92286>>>>            Increment i
92287>>>>
92287>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
92288>>>>            Move -200                                    to aColumnType[i].iSQLType
92289>>>>            Move True                                    to aColumnType[i].bCanEditSize
92290>>>>            Move True                                    to aColumnType[i].bNativeDataType
92291>>>>            Move 23                                      to aColumnType[i].iDefaultSize
92292>>>>            Move 23                                      to aColumnType[i].iMinSize
92293>>>>            Move 23                                      to aColumnType[i].nMaxSize
92294>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92295>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92296>>>>            Move 23                                      to aColumnType[i].sPrecision
92297>>>>            Increment i
92298>>>>
92298>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
92299>>>>            Move -155                                    to aColumnType[i].iSQLType
92300>>>>            Move True                                    to aColumnType[i].bCanEditSize
92301>>>>            Move True                                    to aColumnType[i].bNativeDataType
92302>>>>            Move 34                                      to aColumnType[i].iDefaultSize
92303>>>>            Move 34                                      to aColumnType[i].iMinSize
92304>>>>            Move 34                                      to aColumnType[i].nMaxSize
92305>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92306>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92307>>>>            Move 34                                      to aColumnType[i].sPrecision
92308>>>>            Increment i
92309>>>>
92309>>>>            Move "decimal"                               to aColumnType[i].sSQLType
92310>>>>            Move 3                                       to aColumnType[i].iSQLType
92311>>>>            Move True                                    to aColumnType[i].bCanEditSize
92312>>>>            Move True                                    to aColumnType[i].bNativeDataType
92313>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92314>>>>            Move 1                                       to aColumnType[i].iMinSize
92315>>>>            Move 14                                      to aColumnType[i].nMaxSize
92316>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92317>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92318>>>>            Move 14                                      to aColumnType[i].sPrecision
92319>>>>            Increment i
92320>>>>
92320>>>>            Move "float"                                 to aColumnType[i].sSQLType
92321>>>>            Move 6                                       to aColumnType[i].iSQLType
92322>>>>            Move True                                    to aColumnType[i].bCanEditSize
92323>>>>            Move True                                    to aColumnType[i].bNativeDataType
92324>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92325>>>>            Move 1                                       to aColumnType[i].iMinSize
92326>>>>            Move 14                                      to aColumnType[i].nMaxSize
92327>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
92328>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
92329>>>>            Move 14                                      to aColumnType[i].sPrecision
92330>>>>            Increment i
92331>>>>
92331>>>>            Move "image"                                 to aColumnType[i].sSQLType
92332>>>>            Move -4                                      to aColumnType[i].iSQLType
92333>>>>            Move True                                    to aColumnType[i].bCanEditSize
92334>>>>            Move True                                    to aColumnType[i].bNativeDataType
92335>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92336>>>>            Move 1                                       to aColumnType[i].iMinSize
92337>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92338>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92339>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92340>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92341>>>>            Increment i
92342>>>>
92342>>>>            Move "int"                                   to aColumnType[i].sSQLType
92343>>>>            Move 4                                       to aColumnType[i].iSQLType
92344>>>>            Move True                                    to aColumnType[i].bCanEditSize
92345>>>>            Move True                                    to aColumnType[i].bNativeDataType
92346>>>>            Move 10                                      to aColumnType[i].iDefaultSize
92347>>>>            Move 1                                       to aColumnType[i].iMinSize
92348>>>>            Move 10                                      to aColumnType[i].nMaxSize
92349>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92350>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92351>>>>            Move 10                                      to aColumnType[i].sPrecision
92352>>>>            Increment i
92353>>>>
92353>>>>            Move "money"                                 to aColumnType[i].sSQLType
92354>>>>            Move -204                                    to aColumnType[i].iSQLType
92355>>>>            Move False                                   to aColumnType[i].bCanEditSize
92356>>>>            Move True                                    to aColumnType[i].bNativeDataType
92357>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92358>>>>            Move 0                                       to aColumnType[i].iMinSize
92359>>>>            Move 0                                       to aColumnType[i].nMaxSize
92360>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92361>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92362>>>>            Move 1                                       to aColumnType[i].sPrecision
92363>>>>            Increment i
92364>>>>
92364>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
92365>>>>            Move -8                                      to aColumnType[i].iSQLType
92366>>>>            Move True                                    to aColumnType[i].bCanEditSize
92367>>>>            Move True                                    to aColumnType[i].bNativeDataType
92368>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92369>>>>            Move 1                                       to aColumnType[i].iMinSize
92370>>>>            Move 4000                                    to aColumnType[i].nMaxSize
92371>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92372>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92373>>>>            Move 4000                                    to aColumnType[i].sPrecision
92374>>>>            Increment i
92375>>>>
92375>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
92376>>>>            Move -10                                     to aColumnType[i].iSQLType
92377>>>>            Move True                                    to aColumnType[i].bCanEditSize
92378>>>>            Move True                                    to aColumnType[i].bNativeDataType
92379>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92380>>>>            Move 1                                       to aColumnType[i].iMinSize
92381>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92382>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92383>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92384>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92385>>>>            Increment i
92386>>>>
92386>>>>            Move "numeric"                               to aColumnType[i].sSQLType
92387>>>>            Move 2                                       to aColumnType[i].iSQLType
92388>>>>            Move True                                    to aColumnType[i].bCanEditSize
92389>>>>            Move True                                    to aColumnType[i].bNativeDataType
92390>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92391>>>>            Move 1                                       to aColumnType[i].iMinSize
92392>>>>            Move 14                                      to aColumnType[i].nMaxSize
92393>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
92394>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
92395>>>>            Move 6                                       to aColumnType[i].sPrecision
92396>>>>            Increment i
92397>>>>
92397>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
92398>>>>            Move -9                                      to aColumnType[i].iSQLType
92399>>>>            Move True                                    to aColumnType[i].bCanEditSize
92400>>>>            Move True                                    to aColumnType[i].bNativeDataType
92401>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92402>>>>            Move 1                                       to aColumnType[i].iMinSize
92403>>>>            Move 4000                                    to aColumnType[i].nMaxSize
92404>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92405>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92406>>>>            Move 4000                                    to aColumnType[i].sPrecision
92407>>>>            Increment i
92408>>>>
92408>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
92409>>>>            Move -202                                    to aColumnType[i].iSQLType
92410>>>>            Move True                                    to aColumnType[i].bCanEditSize
92411>>>>            Move True                                    to aColumnType[i].bNativeDataType
92412>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92413>>>>            Move 1                                       to aColumnType[i].iMinSize
92414>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92415>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92416>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92417>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92418>>>>            Increment i
92419>>>>
92419>>>>            Move "real"                                  to aColumnType[i].sSQLType
92420>>>>            Move 7                                       to aColumnType[i].iSQLType
92421>>>>            Move True                                    to aColumnType[i].bCanEditSize
92422>>>>            Move True                                    to aColumnType[i].bNativeDataType
92423>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92424>>>>            Move 1                                       to aColumnType[i].iMinSize
92425>>>>            Move 14                                      to aColumnType[i].nMaxSize
92426>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92427>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92428>>>>            Move 14                                      to aColumnType[i].sPrecision
92429>>>>            Increment i
92430>>>>
92430>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
92431>>>>            Move -206                                    to aColumnType[i].iSQLType
92432>>>>            Move False                                   to aColumnType[i].bCanEditSize
92433>>>>            Move True                                    to aColumnType[i].bNativeDataType
92434>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92435>>>>            Move 0                                       to aColumnType[i].iMinSize
92436>>>>            Move 0                                       to aColumnType[i].nMaxSize
92437>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92438>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92439>>>>            Move 1                                       to aColumnType[i].sPrecision
92440>>>>            Increment i
92441>>>>
92441>>>>            Move "smallint"                              to aColumnType[i].sSQLType
92442>>>>            Move 5                                       to aColumnType[i].iSQLType
92443>>>>            Move True                                    to aColumnType[i].bCanEditSize
92444>>>>            Move True                                    to aColumnType[i].bNativeDataType
92445>>>>            Move 5                                       to aColumnType[i].iDefaultSize
92446>>>>            Move 1                                       to aColumnType[i].iMinSize
92447>>>>            Move 5                                       to aColumnType[i].nMaxSize
92448>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92449>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92450>>>>            Move 5                                       to aColumnType[i].sPrecision
92451>>>>            Increment i
92452>>>>
92452>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
92453>>>>            Move -205                                    to aColumnType[i].iSQLType
92454>>>>            Move False                                   to aColumnType[i].bCanEditSize
92455>>>>            Move True                                    to aColumnType[i].bNativeDataType
92456>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92457>>>>            Move 0                                       to aColumnType[i].iMinSize
92458>>>>            Move 0                                       to aColumnType[i].nMaxSize
92459>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92460>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92461>>>>            Move 1                                       to aColumnType[i].sPrecision
92462>>>>            Increment i
92463>>>>
92463>>>>            Move "text"                                  to aColumnType[i].sSQLType
92464>>>>            Move -1                                      to aColumnType[i].iSQLType
92465>>>>            Move True                                    to aColumnType[i].bCanEditSize
92466>>>>            Move True                                    to aColumnType[i].bNativeDataType
92467>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92468>>>>            Move 1                                       to aColumnType[i].iMinSize
92469>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92470>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92471>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92472>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92473>>>>            Increment i
92474>>>>
92474>>>>            Move "time"                                  to aColumnType[i].sSQLType
92475>>>>            Move -154                                    to aColumnType[i].iSQLType
92476>>>>            Move True                                    to aColumnType[i].bCanEditSize
92477>>>>            Move True                                    to aColumnType[i].bNativeDataType
92478>>>>            Move 10                                      to aColumnType[i].iDefaultSize
92479>>>>            Move 10                                      to aColumnType[i].iMinSize
92480>>>>            Move 19                                      to aColumnType[i].nMaxSize
92481>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92482>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92483>>>>            Move 19                                      to aColumnType[i].sPrecision
92484>>>>            Increment i
92485>>>>
92485>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
92486>>>>            Move -6                                      to aColumnType[i].iSQLType
92487>>>>            Move True                                    to aColumnType[i].bCanEditSize
92488>>>>            Move True                                    to aColumnType[i].bNativeDataType
92489>>>>            Move 3                                       to aColumnType[i].iDefaultSize
92490>>>>            Move 1                                       to aColumnType[i].iMinSize
92491>>>>            Move 3                                       to aColumnType[i].nMaxSize
92492>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92493>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92494>>>>            Move 3                                       to aColumnType[i].sPrecision
92495>>>>            Increment i
92496>>>>
92496>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
92497>>>>            Move -11                                     to aColumnType[i].iSQLType
92498>>>>            Move False                                   to aColumnType[i].bCanEditSize
92499>>>>            Move True                                    to aColumnType[i].bNativeDataType
92500>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92501>>>>            Move 0                                       to aColumnType[i].iMinSize
92502>>>>            Move 0                                       to aColumnType[i].nMaxSize
92503>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92504>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92505>>>>            Move 1                                       to aColumnType[i].sPrecision
92506>>>>            Increment i
92507>>>>
92507>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
92508>>>>            Move -3                                      to aColumnType[i].iSQLType
92509>>>>            Move True                                    to aColumnType[i].bCanEditSize
92510>>>>            Move True                                    to aColumnType[i].bNativeDataType
92511>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
92512>>>>            Move 1                                       to aColumnType[i].iMinSize
92513>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92514>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92515>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92516>>>>            Move 8000                                    to aColumnType[i].sPrecision
92517>>>>            Increment i
92518>>>>
92518>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
92519>>>>            Move -203                                    to aColumnType[i].iSQLType
92520>>>>            Move True                                    to aColumnType[i].bCanEditSize
92521>>>>            Move True                                    to aColumnType[i].bNativeDataType
92522>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92523>>>>            Move 1                                       to aColumnType[i].iMinSize
92524>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92525>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92526>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92527>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92528>>>>            Increment i
92529>>>>
92529>>>>            Move "varchar"                               to aColumnType[i].sSQLType
92530>>>>            Move 12                                      to aColumnType[i].iSQLType
92531>>>>            Move True                                    to aColumnType[i].bCanEditSize
92532>>>>            Move True                                    to aColumnType[i].bNativeDataType
92533>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92534>>>>            Move 1                                       to aColumnType[i].iMinSize
92535>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92536>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92537>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92538>>>>            Move 8000                                    to aColumnType[i].sPrecision
92539>>>>            Increment i
92540>>>>
92540>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
92541>>>>            Move -201                                    to aColumnType[i].iSQLType
92542>>>>            Move True                                    to aColumnType[i].bCanEditSize
92543>>>>            Move True                                    to aColumnType[i].bNativeDataType
92544>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92545>>>>            Move 1                                       to aColumnType[i].iMinSize
92546>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92547>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92548>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92549>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92550>>>>            Increment i
92551>>>>
92551>>>>            Move "xml"                                   to aColumnType[i].sSQLType
92552>>>>            Move -152                                    to aColumnType[i].iSQLType
92553>>>>            Move True                                    to aColumnType[i].bCanEditSize
92554>>>>            Move True                                    to aColumnType[i].bNativeDataType
92555>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92556>>>>            Move 1                                       to aColumnType[i].iMinSize
92557>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92558>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92559>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92560>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92561>>>>            Increment i
92562>>>>
92562>>>>
92562>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
92562>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
92562>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92562>>>//        Move "Text"             to ColumnType[i].sDataFlexType
92562>>>//        Move "16384"            to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
92562>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
92562>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92562>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
92562>>>//        Move "14.0"             to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
92562>>>//        Move "BLOB"             to ColumnType[i].sSQLType
92562>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
92562>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
92562>>>//        Move "16384"            to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
92562>>>//        Move "CHAR"             to ColumnType[i].sSQLType
92562>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
92562>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
92562>>>//        Move "254"              to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        // ToDo: We need to change the sType when using this!
92562>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
92562>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
92562>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
92562>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
92562>>>//        Move "254"                  to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
92562>>>//        Move "DATE"             to ColumnType[i].sSQLType
92562>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
92562>>>//        Move "Date"             to ColumnType[i].sDataFlexType
92562>>>//        Move "6.0"              to ColumnType[i].sPrecision
92562>>>//        Move True               to ColumnType[i].bCanEditSize
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
92562>>>//        Move "CLOB"             to ColumnType[i].sSQLType
92562>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92562>>>//        Move "Text"             to ColumnType[i].sDataFlexType
92562>>>//        Move "16384"            to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
92562>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
92562>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92562>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
92562>>>//        Move "14.8"             to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
92562>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
92562>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92562>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
92562>>>//        Move "14.8"             to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
92562>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
92562>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92562>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
92562>>>//        Move "14.8"             to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
92562>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
92562>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
92562>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
92562>>>//        Move "255"              to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
92562>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
92562>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92562>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
92562>>>//        Move "9.0"              to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
92562>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
92562>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92562>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
92562>>>//        Move "32000"            to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
92562>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
92562>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92562>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
92562>>>//        Move "32000"            to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
92562>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
92562>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92562>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
92562>>>//        Move "32000"            to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
92562>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
92562>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92562>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
92562>>>//        Move "14.8"             to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
92562>>>//        Move "REAL"             to ColumnType[i].sSQLType
92562>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92562>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
92562>>>//        Move "14.8"             to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
92562>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
92562>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92562>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
92562>>>//        Move "5.0"              to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
92562>>>//        Move "TIME"             to ColumnType[i].sSQLType
92562>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
92562>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
92562>>>//        Move "19.0"             to ColumnType[i].sPrecision
92562>>>//        Move True               to ColumnType[i].bCanEditSize
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
92562>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
92562>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
92562>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
92562>>>//        Move "23.6"             to ColumnType[i].sPrecision
92562>>>//        Move True               to ColumnType[i].bCanEditSize
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
92562>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
92562>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92562>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
92562>>>//        Move "16384"            to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        // ToDo: We need to change the sType when using this!
92562>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
92562>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
92562>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
92562>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
92562>>>//        Move "16384"                to ColumnType[i].sPrecision
92562>>>//        Increment i
92562>>>//
92562>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
92562>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
92562>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92562>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
92562>>>//        Move "16384"            to ColumnType[i].sPrecision
92562>>>//
92562>>>//        Move SQL_XML            to ColumnType[i].iSQLType
92562>>>//        Move "XML"              to ColumnType[i].sSQLType
92562>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92562>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
92562>>>//        Move "16384"            to ColumnType[i].sPrecision
92562>>>
92562>>>        Function_Return aColumnType
92563>>>    End_Function
92564>>>
92564>>>    // Microsoft SQL Server Database Data Types:
92564>>>    // Helper function for UtilEnumerateColumnTypes
92564>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
92566>>>        tColumnType[] aColumnType
92566>>>        tColumnType[] aColumnType
92567>>>        Integer i
92567>>>
92567>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
92569>>>>// Generated By The Database Update Framework
92569>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
92569>>>>// Driver COLUMN DATA TYPES
92569>>>>//
92569>>>>// Created: 2019-11-15 21:57:51.001
92569>>>>
92569>>>>            Move "bigint"                                to aColumnType[i].sSQLType
92570>>>>            Move -5                                      to aColumnType[i].iSQLType
92571>>>>            Move True                                    to aColumnType[i].bCanEditSize
92572>>>>            Move True                                    to aColumnType[i].bNativeDataType
92573>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92574>>>>            Move 1                                       to aColumnType[i].iMinSize
92575>>>>            Move 14                                      to aColumnType[i].nMaxSize
92576>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92577>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92578>>>>            Move 14                                      to aColumnType[i].sPrecision
92579>>>>            Increment i
92580>>>>
92580>>>>            Move "binary"                                to aColumnType[i].sSQLType
92581>>>>            Move -2                                      to aColumnType[i].iSQLType
92582>>>>            Move True                                    to aColumnType[i].bCanEditSize
92583>>>>            Move True                                    to aColumnType[i].bNativeDataType
92584>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92585>>>>            Move 1                                       to aColumnType[i].iMinSize
92586>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92587>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
92588>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
92589>>>>            Move 8000                                    to aColumnType[i].sPrecision
92590>>>>            Increment i
92591>>>>
92591>>>>            Move "bit"                                   to aColumnType[i].sSQLType
92592>>>>            Move -7                                      to aColumnType[i].iSQLType
92593>>>>            Move False                                   to aColumnType[i].bCanEditSize
92594>>>>            Move True                                    to aColumnType[i].bNativeDataType
92595>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92596>>>>            Move 0                                       to aColumnType[i].iMinSize
92597>>>>            Move 0                                       to aColumnType[i].nMaxSize
92598>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92599>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92600>>>>            Move 1                                       to aColumnType[i].sPrecision
92601>>>>            Increment i
92602>>>>
92602>>>>            Move "char"                                  to aColumnType[i].sSQLType
92603>>>>            Move 1                                       to aColumnType[i].iSQLType
92604>>>>            Move True                                    to aColumnType[i].bCanEditSize
92605>>>>            Move True                                    to aColumnType[i].bNativeDataType
92606>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92607>>>>            Move 1                                       to aColumnType[i].iMinSize
92608>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92609>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92610>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92611>>>>            Move 8000                                    to aColumnType[i].sPrecision
92612>>>>            Increment i
92613>>>>
92613>>>>            Move "date"                                  to aColumnType[i].sSQLType
92614>>>>            Move 91                                      to aColumnType[i].iSQLType
92615>>>>            Move False                                   to aColumnType[i].bCanEditSize
92616>>>>            Move True                                    to aColumnType[i].bNativeDataType
92617>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92618>>>>            Move 0                                       to aColumnType[i].iMinSize
92619>>>>            Move 0                                       to aColumnType[i].nMaxSize
92620>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
92621>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
92622>>>>            Move 6                                       to aColumnType[i].sPrecision
92623>>>>            Increment i
92624>>>>
92624>>>>            Move "datetime"                              to aColumnType[i].sSQLType
92625>>>>            Move 93                                      to aColumnType[i].iSQLType
92626>>>>            Move False                                   to aColumnType[i].bCanEditSize
92627>>>>            Move True                                    to aColumnType[i].bNativeDataType
92628>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92629>>>>            Move -1                                      to aColumnType[i].iMinSize
92630>>>>            Move -1                                      to aColumnType[i].nMaxSize
92631>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
92632>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
92633>>>>            Move 23                                      to aColumnType[i].sPrecision
92634>>>>            Increment i
92635>>>>
92635>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
92636>>>>            Move -200                                    to aColumnType[i].iSQLType
92637>>>>            Move True                                    to aColumnType[i].bCanEditSize
92638>>>>            Move True                                    to aColumnType[i].bNativeDataType
92639>>>>            Move 23                                      to aColumnType[i].iDefaultSize
92640>>>>            Move 23                                      to aColumnType[i].iMinSize
92641>>>>            Move 23                                      to aColumnType[i].nMaxSize
92642>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
92643>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
92644>>>>            Move 23                                      to aColumnType[i].sPrecision
92645>>>>            Increment i
92646>>>>
92646>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
92647>>>>            Move -155                                    to aColumnType[i].iSQLType
92648>>>>            Move True                                    to aColumnType[i].bCanEditSize
92649>>>>            Move True                                    to aColumnType[i].bNativeDataType
92650>>>>            Move 34                                      to aColumnType[i].iDefaultSize
92651>>>>            Move 34                                      to aColumnType[i].iMinSize
92652>>>>            Move 34                                      to aColumnType[i].nMaxSize
92653>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
92654>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
92655>>>>            Move 34                                      to aColumnType[i].sPrecision
92656>>>>            Increment i
92657>>>>
92657>>>>            Move "decimal"                               to aColumnType[i].sSQLType
92658>>>>            Move 3                                       to aColumnType[i].iSQLType
92659>>>>            Move True                                    to aColumnType[i].bCanEditSize
92660>>>>            Move True                                    to aColumnType[i].bNativeDataType
92661>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92662>>>>            Move 1                                       to aColumnType[i].iMinSize
92663>>>>            Move 14                                      to aColumnType[i].nMaxSize
92664>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92665>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92666>>>>            Move 14                                      to aColumnType[i].sPrecision
92667>>>>            Increment i
92668>>>>
92668>>>>            Move "float"                                 to aColumnType[i].sSQLType
92669>>>>            Move 6                                       to aColumnType[i].iSQLType
92670>>>>            Move True                                    to aColumnType[i].bCanEditSize
92671>>>>            Move True                                    to aColumnType[i].bNativeDataType
92672>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92673>>>>            Move 1                                       to aColumnType[i].iMinSize
92674>>>>            Move 14                                      to aColumnType[i].nMaxSize
92675>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92676>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92677>>>>            Move 14                                      to aColumnType[i].sPrecision
92678>>>>            Increment i
92679>>>>
92679>>>>            Move "image"                                 to aColumnType[i].sSQLType
92680>>>>            Move -4                                      to aColumnType[i].iSQLType
92681>>>>            Move True                                    to aColumnType[i].bCanEditSize
92682>>>>            Move True                                    to aColumnType[i].bNativeDataType
92683>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92684>>>>            Move 1                                       to aColumnType[i].iMinSize
92685>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92686>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
92687>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
92688>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92689>>>>            Increment i
92690>>>>
92690>>>>            Move "int"                                   to aColumnType[i].sSQLType
92691>>>>            Move 4                                       to aColumnType[i].iSQLType
92692>>>>            Move True                                    to aColumnType[i].bCanEditSize
92693>>>>            Move True                                    to aColumnType[i].bNativeDataType
92694>>>>            Move 10                                      to aColumnType[i].iDefaultSize
92695>>>>            Move 1                                       to aColumnType[i].iMinSize
92696>>>>            Move 10                                      to aColumnType[i].nMaxSize
92697>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92698>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92699>>>>            Move 10                                      to aColumnType[i].sPrecision
92700>>>>            Increment i
92701>>>>
92701>>>>            Move "money"                                 to aColumnType[i].sSQLType
92702>>>>            Move -204                                    to aColumnType[i].iSQLType
92703>>>>            Move False                                   to aColumnType[i].bCanEditSize
92704>>>>            Move True                                    to aColumnType[i].bNativeDataType
92705>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92706>>>>            Move 0                                       to aColumnType[i].iMinSize
92707>>>>            Move 0                                       to aColumnType[i].nMaxSize
92708>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92709>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92710>>>>            Move 1                                       to aColumnType[i].sPrecision
92711>>>>            Increment i
92712>>>>
92712>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
92713>>>>            Move -8                                      to aColumnType[i].iSQLType
92714>>>>            Move True                                    to aColumnType[i].bCanEditSize
92715>>>>            Move True                                    to aColumnType[i].bNativeDataType
92716>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92717>>>>            Move 1                                       to aColumnType[i].iMinSize
92718>>>>            Move 4000                                    to aColumnType[i].nMaxSize
92719>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92720>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92721>>>>            Move 4000                                    to aColumnType[i].sPrecision
92722>>>>            Increment i
92723>>>>
92723>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
92724>>>>            Move -10                                     to aColumnType[i].iSQLType
92725>>>>            Move True                                    to aColumnType[i].bCanEditSize
92726>>>>            Move True                                    to aColumnType[i].bNativeDataType
92727>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92728>>>>            Move 1                                       to aColumnType[i].iMinSize
92729>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92730>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
92731>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
92732>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92733>>>>            Increment i
92734>>>>
92734>>>>            Move "numeric"                               to aColumnType[i].sSQLType
92735>>>>            Move 2                                       to aColumnType[i].iSQLType
92736>>>>            Move True                                    to aColumnType[i].bCanEditSize
92737>>>>            Move True                                    to aColumnType[i].bNativeDataType
92738>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92739>>>>            Move 1                                       to aColumnType[i].iMinSize
92740>>>>            Move 14                                      to aColumnType[i].nMaxSize
92741>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92742>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92743>>>>            Move 14                                      to aColumnType[i].sPrecision
92744>>>>            Increment i
92745>>>>
92745>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
92746>>>>            Move -9                                      to aColumnType[i].iSQLType
92747>>>>            Move True                                    to aColumnType[i].bCanEditSize
92748>>>>            Move True                                    to aColumnType[i].bNativeDataType
92749>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92750>>>>            Move 1                                       to aColumnType[i].iMinSize
92751>>>>            Move 4000                                    to aColumnType[i].nMaxSize
92752>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92753>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92754>>>>            Move 4000                                    to aColumnType[i].sPrecision
92755>>>>            Increment i
92756>>>>
92756>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
92757>>>>            Move -202                                    to aColumnType[i].iSQLType
92758>>>>            Move True                                    to aColumnType[i].bCanEditSize
92759>>>>            Move True                                    to aColumnType[i].bNativeDataType
92760>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92761>>>>            Move 1                                       to aColumnType[i].iMinSize
92762>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92763>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92764>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92765>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92766>>>>            Increment i
92767>>>>
92767>>>>            Move "real"                                  to aColumnType[i].sSQLType
92768>>>>            Move 7                                       to aColumnType[i].iSQLType
92769>>>>            Move True                                    to aColumnType[i].bCanEditSize
92770>>>>            Move True                                    to aColumnType[i].bNativeDataType
92771>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92772>>>>            Move 1                                       to aColumnType[i].iMinSize
92773>>>>            Move 14                                      to aColumnType[i].nMaxSize
92774>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92775>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92776>>>>            Move 14                                      to aColumnType[i].sPrecision
92777>>>>            Increment i
92778>>>>
92778>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
92779>>>>            Move -206                                    to aColumnType[i].iSQLType
92780>>>>            Move False                                   to aColumnType[i].bCanEditSize
92781>>>>            Move True                                    to aColumnType[i].bNativeDataType
92782>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92783>>>>            Move 0                                       to aColumnType[i].iMinSize
92784>>>>            Move 0                                       to aColumnType[i].nMaxSize
92785>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
92786>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
92787>>>>            Move 1                                       to aColumnType[i].sPrecision
92788>>>>            Increment i
92789>>>>
92789>>>>            Move "smallint"                              to aColumnType[i].sSQLType
92790>>>>            Move 5                                       to aColumnType[i].iSQLType
92791>>>>            Move True                                    to aColumnType[i].bCanEditSize
92792>>>>            Move True                                    to aColumnType[i].bNativeDataType
92793>>>>            Move 5                                       to aColumnType[i].iDefaultSize
92794>>>>            Move 1                                       to aColumnType[i].iMinSize
92795>>>>            Move 5                                       to aColumnType[i].nMaxSize
92796>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92797>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92798>>>>            Move 5                                       to aColumnType[i].sPrecision
92799>>>>            Increment i
92800>>>>
92800>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
92801>>>>            Move -205                                    to aColumnType[i].iSQLType
92802>>>>            Move False                                   to aColumnType[i].bCanEditSize
92803>>>>            Move True                                    to aColumnType[i].bNativeDataType
92804>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92805>>>>            Move 0                                       to aColumnType[i].iMinSize
92806>>>>            Move 0                                       to aColumnType[i].nMaxSize
92807>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92808>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92809>>>>            Move 1                                       to aColumnType[i].sPrecision
92810>>>>            Increment i
92811>>>>
92811>>>>            Move "text"                                  to aColumnType[i].sSQLType
92812>>>>            Move -1                                      to aColumnType[i].iSQLType
92813>>>>            Move True                                    to aColumnType[i].bCanEditSize
92814>>>>            Move True                                    to aColumnType[i].bNativeDataType
92815>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92816>>>>            Move 1                                       to aColumnType[i].iMinSize
92817>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92818>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
92819>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
92820>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92821>>>>            Increment i
92822>>>>
92822>>>>            Move "time"                                  to aColumnType[i].sSQLType
92823>>>>            Move -154                                    to aColumnType[i].iSQLType
92824>>>>            Move True                                    to aColumnType[i].bCanEditSize
92825>>>>            Move True                                    to aColumnType[i].bNativeDataType
92826>>>>            Move 10                                      to aColumnType[i].iDefaultSize
92827>>>>            Move 10                                      to aColumnType[i].iMinSize
92828>>>>            Move 19                                      to aColumnType[i].nMaxSize
92829>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92830>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92831>>>>            Move 19                                      to aColumnType[i].sPrecision
92832>>>>            Increment i
92833>>>>
92833>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
92834>>>>            Move -6                                      to aColumnType[i].iSQLType
92835>>>>            Move True                                    to aColumnType[i].bCanEditSize
92836>>>>            Move True                                    to aColumnType[i].bNativeDataType
92837>>>>            Move 3                                       to aColumnType[i].iDefaultSize
92838>>>>            Move 1                                       to aColumnType[i].iMinSize
92839>>>>            Move 3                                       to aColumnType[i].nMaxSize
92840>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92841>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92842>>>>            Move 3                                       to aColumnType[i].sPrecision
92843>>>>            Increment i
92844>>>>
92844>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
92845>>>>            Move -11                                     to aColumnType[i].iSQLType
92846>>>>            Move False                                   to aColumnType[i].bCanEditSize
92847>>>>            Move True                                    to aColumnType[i].bNativeDataType
92848>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92849>>>>            Move 0                                       to aColumnType[i].iMinSize
92850>>>>            Move 0                                       to aColumnType[i].nMaxSize
92851>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92852>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92853>>>>            Move 1                                       to aColumnType[i].sPrecision
92854>>>>            Increment i
92855>>>>
92855>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
92856>>>>            Move -3                                      to aColumnType[i].iSQLType
92857>>>>            Move True                                    to aColumnType[i].bCanEditSize
92858>>>>            Move True                                    to aColumnType[i].bNativeDataType
92859>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
92860>>>>            Move 1                                       to aColumnType[i].iMinSize
92861>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92862>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
92863>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
92864>>>>            Move 8000                                    to aColumnType[i].sPrecision
92865>>>>            Increment i
92866>>>>
92866>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
92867>>>>            Move -203                                    to aColumnType[i].iSQLType
92868>>>>            Move True                                    to aColumnType[i].bCanEditSize
92869>>>>            Move True                                    to aColumnType[i].bNativeDataType
92870>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92871>>>>            Move 1                                       to aColumnType[i].iMinSize
92872>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92873>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92874>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92875>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92876>>>>            Increment i
92877>>>>
92877>>>>            Move "varchar"                               to aColumnType[i].sSQLType
92878>>>>            Move 12                                      to aColumnType[i].iSQLType
92879>>>>            Move True                                    to aColumnType[i].bCanEditSize
92880>>>>            Move True                                    to aColumnType[i].bNativeDataType
92881>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92882>>>>            Move 1                                       to aColumnType[i].iMinSize
92883>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92884>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92885>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92886>>>>            Move 8000                                    to aColumnType[i].sPrecision
92887>>>>            Increment i
92888>>>>
92888>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
92889>>>>            Move -201                                    to aColumnType[i].iSQLType
92890>>>>            Move True                                    to aColumnType[i].bCanEditSize
92891>>>>            Move True                                    to aColumnType[i].bNativeDataType
92892>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92893>>>>            Move 1                                       to aColumnType[i].iMinSize
92894>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92895>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
92896>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
92897>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92898>>>>            Increment i
92899>>>>
92899>>>>            Move "xml"                                   to aColumnType[i].sSQLType
92900>>>>            Move -152                                    to aColumnType[i].iSQLType
92901>>>>            Move True                                    to aColumnType[i].bCanEditSize
92902>>>>            Move True                                    to aColumnType[i].bNativeDataType
92903>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92904>>>>            Move 1                                       to aColumnType[i].iMinSize
92905>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92906>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
92907>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
92908>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92909>>>>            Increment i
92910>>>>
92910>>>>
92910>>>
92910>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
92910>>>//            Move "bigint"           to ColumnType[i].sSQLType
92910>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
92910>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
92910>>>//            Move "14.0"             to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
92910>>>//            Move "binary"           to ColumnType[i].sSQLType
92910>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
92910>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
92910>>>//            Move "8000"             to ColumnType[i].sPrecision
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
92910>>>//            Move "bit"              to ColumnType[i].sSQLType
92910>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
92910>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
92910>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
92910>>>//            Move "char"             to ColumnType[i].sSQLType
92910>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
92910>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
92910>>>//            Move "8000"             to ColumnType[i].sPrecision
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
92910>>>//            Move "date"             to ColumnType[i].sSQLType
92910>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
92910>>>//            Move "Date"             to ColumnType[i].sDataFlexType
92910>>>//            Move "6.0"              to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
92910>>>//            Move "datetime"         to ColumnType[i].sSQLType
92910>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
92910>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
92910>>>//            Move "23.3"             to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
92910>>>//            Move "datetime2"         to ColumnType[i].sSQLType
92910>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
92910>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
92910>>>//            Move "23.6"              to ColumnType[i].sPrecision
92910>>>//            Move True                to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
92910>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
92910>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
92910>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
92910>>>//            Move "34.0"                 to ColumnType[i].sPrecision
92910>>>//            Move True                   to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
92910>>>//            Move "decimal"          to ColumnType[i].sSQLType
92910>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
92910>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
92910>>>//            Move "14.8"             to ColumnType[i].sPrecision
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
92910>>>//            Move "float"            to ColumnType[i].sSQLType
92910>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
92910>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
92910>>>//            Move "14.8"             to ColumnType[i].sPrecision
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
92910>>>//            Move "int"              to ColumnType[i].sSQLType
92910>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
92910>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
92910>>>//            Move "8.0"              to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
92910>>>//            Move "money"            to ColumnType[i].sSQLType
92910>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
92910>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
92910>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
92910>>>//            Move "nchar"            to ColumnType[i].sSQLType
92910>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
92910>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
92910>>>//            Move "4000"             to ColumnType[i].sPrecision
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
92910>>>//            Move "ntext"            to ColumnType[i].sSQLType
92910>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
92910>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
92910>>>//            Move "16384"            to ColumnType[i].sPrecision
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
92910>>>//            Move "numeric"          to ColumnType[i].sSQLType
92910>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
92910>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
92910>>>//            Move "14.8"             to ColumnType[i].sPrecision
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
92910>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
92910>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
92910>>>//            Move "Text"             to ColumnType[i].sDataFlexType
92910>>>//            Move "4000"             to ColumnType[i].sPrecision
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
92910>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
92910>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
92910>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
92910>>>//            Move "16384"            to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
92910>>>//            Move "real"             to ColumnType[i].sSQLType
92910>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
92910>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
92910>>>//            Move "14.8"             to ColumnType[i].sPrecision
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
92910>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
92910>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
92910>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
92910>>>//            Move "23.0"                 to ColumnType[i].sPrecision
92910>>>//            Move True                   to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
92910>>>//            Move "smallint"         to ColumnType[i].sSQLType
92910>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
92910>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
92910>>>//            Move "4.0"              to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
92910>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
92910>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
92910>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
92910>>>//            Move "10.0"              to ColumnType[i].sPrecision
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
92910>>>//            Move "text"             to ColumnType[i].sSQLType
92910>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
92910>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
92910>>>//            Move "8000"             to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
92910>>>//            Move "time"             to ColumnType[i].sSQLType
92910>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
92910>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
92910>>>//            Move "19.0"             to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
92910>>>//            Move "tinyint"          to ColumnType[i].sSQLType
92910>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
92910>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
92910>>>//            Move "2.0"              to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
92910>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
92910>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
92910>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
92910>>>//            Move "36"               to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
92910>>>//            Move "varbinary"        to ColumnType[i].sSQLType
92910>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
92910>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
92910>>>//            Move "16384"            to ColumnType[i].sPrecision
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
92910>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
92910>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
92910>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
92910>>>//            Move "16384"            to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
92910>>>//            Move "varchar"          to ColumnType[i].sSQLType
92910>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
92910>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
92910>>>//            Move "8000"             to ColumnType[i].sPrecision
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
92910>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
92910>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
92910>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
92910>>>//            Move "16384"            to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
92910>>>//            Move "xml"              to ColumnType[i].sSQLType
92910>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
92910>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
92910>>>//            Move "16384"            to ColumnType[i].sPrecision
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
92910>>>//            Move "DATE"             to ColumnType[i].sSQLType
92910>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
92910>>>//            Move "date"             to ColumnType[i].sDataFlexType
92910>>>//            Move "6.0"              to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
92910>>>//            Move "time"             to ColumnType[i].sSQLType
92910>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
92910>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
92910>>>//            Move "8.7"              to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>//
92910>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
92910>>>//            Move "datetime"         to ColumnType[i].sSQLType
92910>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
92910>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
92910>>>//            Move "23.6"             to ColumnType[i].sPrecision
92910>>>//            Move True               to ColumnType[i].bCanEditSize
92910>>>//            Increment i
92910>>>
92910>>>        End
92910>>>>
92910>>>
92910>>>        // Mertech SQLFlex driver
92910>>>        If (sDriverID = SQLFLEX) Begin
92912>>>
Including file: sql_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\sql_drv_DriverDef.inc)
92912>>>>// Generated By The Database Update Framework
92912>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\sql_drv_DriverDef.xml
92912>>>>// Driver COLUMN DATA TYPES
92912>>>>//
92912>>>>// Created: 2018-03-14 23:47:46.885
92912>>>>
92912>>>>            Move "bigint"                                to aColumnType[i].sSQLType
92913>>>>            Move -5                                      to aColumnType[i].iSQLType
92914>>>>            Move True                                    to aColumnType[i].bCanEditSize
92915>>>>            Move True                                    to aColumnType[i].bNativeDataType
92916>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92917>>>>            Move 1                                       to aColumnType[i].iMinSize
92918>>>>            Move 14                                      to aColumnType[i].nMaxSize
92919>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92920>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92921>>>>            Move 14                                      to aColumnType[i].sPrecision
92922>>>>            Increment i
92923>>>>
92923>>>>            Move "binary"                                to aColumnType[i].sSQLType
92924>>>>            Move -2                                      to aColumnType[i].iSQLType
92925>>>>            Move True                                    to aColumnType[i].bCanEditSize
92926>>>>            Move True                                    to aColumnType[i].bNativeDataType
92927>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92928>>>>            Move 1                                       to aColumnType[i].iMinSize
92929>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92930>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
92931>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
92932>>>>            Move 8000                                    to aColumnType[i].sPrecision
92933>>>>            Increment i
92934>>>>
92934>>>>            Move "bit"                                   to aColumnType[i].sSQLType
92935>>>>            Move -7                                      to aColumnType[i].iSQLType
92936>>>>            Move False                                   to aColumnType[i].bCanEditSize
92937>>>>            Move True                                    to aColumnType[i].bNativeDataType
92938>>>>            Move 1                                       to aColumnType[i].iDefaultSize
92939>>>>            Move -1                                      to aColumnType[i].iMinSize
92940>>>>            Move -1                                      to aColumnType[i].nMaxSize
92941>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92942>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92943>>>>            Move -1                                      to aColumnType[i].sPrecision
92944>>>>            Increment i
92945>>>>
92945>>>>            Move "char"                                  to aColumnType[i].sSQLType
92946>>>>            Move 1                                       to aColumnType[i].iSQLType
92947>>>>            Move True                                    to aColumnType[i].bCanEditSize
92948>>>>            Move True                                    to aColumnType[i].bNativeDataType
92949>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92950>>>>            Move 1                                       to aColumnType[i].iMinSize
92951>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92952>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92953>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92954>>>>            Move 8000                                    to aColumnType[i].sPrecision
92955>>>>            Increment i
92956>>>>
92956>>>>            Move "date"                                  to aColumnType[i].sSQLType
92957>>>>            Move 40                                      to aColumnType[i].iSQLType
92958>>>>            Move False                                   to aColumnType[i].bCanEditSize
92959>>>>            Move True                                    to aColumnType[i].bNativeDataType
92960>>>>            Move 12                                      to aColumnType[i].iDefaultSize
92961>>>>            Move -1                                      to aColumnType[i].iMinSize
92962>>>>            Move -1                                      to aColumnType[i].nMaxSize
92963>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92964>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92965>>>>            Move -1                                      to aColumnType[i].sPrecision
92966>>>>            Increment i
92967>>>>
92967>>>>            Move "datetime"                              to aColumnType[i].sSQLType
92968>>>>            Move 11                                      to aColumnType[i].iSQLType
92969>>>>            Move True                                    to aColumnType[i].bCanEditSize
92970>>>>            Move True                                    to aColumnType[i].bNativeDataType
92971>>>>            Move 6                                       to aColumnType[i].iDefaultSize
92972>>>>            Move 6                                       to aColumnType[i].iMinSize
92973>>>>            Move 23                                      to aColumnType[i].nMaxSize
92974>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92975>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92976>>>>            Move 23                                      to aColumnType[i].sPrecision
92977>>>>            Increment i
92978>>>>
92978>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
92979>>>>            Move 42                                      to aColumnType[i].iSQLType
92980>>>>            Move True                                    to aColumnType[i].bCanEditSize
92981>>>>            Move True                                    to aColumnType[i].bNativeDataType
92982>>>>            Move 6                                       to aColumnType[i].iDefaultSize
92983>>>>            Move 6                                       to aColumnType[i].iMinSize
92984>>>>            Move 23                                      to aColumnType[i].nMaxSize
92985>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92986>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92987>>>>            Move 23                                      to aColumnType[i].sPrecision
92988>>>>            Increment i
92989>>>>
92989>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
92990>>>>            Move 43                                      to aColumnType[i].iSQLType
92991>>>>            Move True                                    to aColumnType[i].bCanEditSize
92992>>>>            Move True                                    to aColumnType[i].bNativeDataType
92993>>>>            Move 12                                      to aColumnType[i].iDefaultSize
92994>>>>            Move 12                                      to aColumnType[i].iMinSize
92995>>>>            Move 23                                      to aColumnType[i].nMaxSize
92996>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92997>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92998>>>>            Move 23                                      to aColumnType[i].sPrecision
92999>>>>            Increment i
93000>>>>
93000>>>>            Move "decimal"                               to aColumnType[i].sSQLType
93001>>>>            Move 3                                       to aColumnType[i].iSQLType
93002>>>>            Move True                                    to aColumnType[i].bCanEditSize
93003>>>>            Move True                                    to aColumnType[i].bNativeDataType
93004>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93005>>>>            Move 1                                       to aColumnType[i].iMinSize
93006>>>>            Move 14                                      to aColumnType[i].nMaxSize
93007>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93008>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93009>>>>            Move 14                                      to aColumnType[i].sPrecision
93010>>>>            Increment i
93011>>>>
93011>>>>            Move "float"                                 to aColumnType[i].sSQLType
93012>>>>            Move 6                                       to aColumnType[i].iSQLType
93013>>>>            Move True                                    to aColumnType[i].bCanEditSize
93014>>>>            Move True                                    to aColumnType[i].bNativeDataType
93015>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93016>>>>            Move 1                                       to aColumnType[i].iMinSize
93017>>>>            Move 14                                      to aColumnType[i].nMaxSize
93018>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93019>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93020>>>>            Move 14                                      to aColumnType[i].sPrecision
93021>>>>            Increment i
93022>>>>
93022>>>>            Move "geography"                             to aColumnType[i].sSQLType
93023>>>>            Move 130                                     to aColumnType[i].iSQLType
93024>>>>            Move False                                   to aColumnType[i].bCanEditSize
93025>>>>            Move True                                    to aColumnType[i].bNativeDataType
93026>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93027>>>>            Move -1                                      to aColumnType[i].iMinSize
93028>>>>            Move -1                                      to aColumnType[i].nMaxSize
93029>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93030>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93031>>>>            Move -1                                      to aColumnType[i].sPrecision
93032>>>>            Increment i
93033>>>>
93033>>>>            Move "geometry"                              to aColumnType[i].sSQLType
93034>>>>            Move 129                                     to aColumnType[i].iSQLType
93035>>>>            Move False                                   to aColumnType[i].bCanEditSize
93036>>>>            Move True                                    to aColumnType[i].bNativeDataType
93037>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93038>>>>            Move -1                                      to aColumnType[i].iMinSize
93039>>>>            Move -1                                      to aColumnType[i].nMaxSize
93040>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93041>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93042>>>>            Move -1                                      to aColumnType[i].sPrecision
93043>>>>            Increment i
93044>>>>
93044>>>>            Move "hierarchyid"                           to aColumnType[i].sSQLType
93045>>>>            Move 128                                     to aColumnType[i].iSQLType
93046>>>>            Move False                                   to aColumnType[i].bCanEditSize
93047>>>>            Move True                                    to aColumnType[i].bNativeDataType
93048>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93049>>>>            Move -1                                      to aColumnType[i].iMinSize
93050>>>>            Move -1                                      to aColumnType[i].nMaxSize
93051>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93052>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93053>>>>            Move -1                                      to aColumnType[i].sPrecision
93054>>>>            Increment i
93055>>>>
93055>>>>            Move "image"                                 to aColumnType[i].sSQLType
93056>>>>            Move -4                                      to aColumnType[i].iSQLType
93057>>>>            Move True                                    to aColumnType[i].bCanEditSize
93058>>>>            Move True                                    to aColumnType[i].bNativeDataType
93059>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93060>>>>            Move 1                                       to aColumnType[i].iMinSize
93061>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93062>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93063>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93064>>>>            Move 16384                                   to aColumnType[i].sPrecision
93065>>>>            Increment i
93066>>>>
93066>>>>            Move "int"                                   to aColumnType[i].sSQLType
93067>>>>            Move 4                                       to aColumnType[i].iSQLType
93068>>>>            Move True                                    to aColumnType[i].bCanEditSize
93069>>>>            Move True                                    to aColumnType[i].bNativeDataType
93070>>>>            Move 11                                      to aColumnType[i].iDefaultSize
93071>>>>            Move 1                                       to aColumnType[i].iMinSize
93072>>>>            Move 11                                      to aColumnType[i].nMaxSize
93073>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93074>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93075>>>>            Move 11                                      to aColumnType[i].sPrecision
93076>>>>            Increment i
93077>>>>
93077>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
93078>>>>            Move -8                                      to aColumnType[i].iSQLType
93079>>>>            Move True                                    to aColumnType[i].bCanEditSize
93080>>>>            Move True                                    to aColumnType[i].bNativeDataType
93081>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93082>>>>            Move 1                                       to aColumnType[i].iMinSize
93083>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93084>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93085>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93086>>>>            Move 4000                                    to aColumnType[i].sPrecision
93087>>>>            Increment i
93088>>>>
93088>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
93089>>>>            Move -10                                     to aColumnType[i].iSQLType
93090>>>>            Move True                                    to aColumnType[i].bCanEditSize
93091>>>>            Move True                                    to aColumnType[i].bNativeDataType
93092>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93093>>>>            Move 1                                       to aColumnType[i].iMinSize
93094>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93095>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93096>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93097>>>>            Move 16384                                   to aColumnType[i].sPrecision
93098>>>>            Increment i
93099>>>>
93099>>>>            Move "numeric"                               to aColumnType[i].sSQLType
93100>>>>            Move 2                                       to aColumnType[i].iSQLType
93101>>>>            Move True                                    to aColumnType[i].bCanEditSize
93102>>>>            Move True                                    to aColumnType[i].bNativeDataType
93103>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93104>>>>            Move 1                                       to aColumnType[i].iMinSize
93105>>>>            Move 14                                      to aColumnType[i].nMaxSize
93106>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93107>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93108>>>>            Move 14                                      to aColumnType[i].sPrecision
93109>>>>            Increment i
93110>>>>
93110>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
93111>>>>            Move -9                                      to aColumnType[i].iSQLType
93112>>>>            Move True                                    to aColumnType[i].bCanEditSize
93113>>>>            Move True                                    to aColumnType[i].bNativeDataType
93114>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93115>>>>            Move 1                                       to aColumnType[i].iMinSize
93116>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93117>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93118>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93119>>>>            Move 4000                                    to aColumnType[i].sPrecision
93120>>>>            Increment i
93121>>>>
93121>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
93122>>>>            Move -100                                    to aColumnType[i].iSQLType
93123>>>>            Move True                                    to aColumnType[i].bCanEditSize
93124>>>>            Move True                                    to aColumnType[i].bNativeDataType
93125>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93126>>>>            Move 1                                       to aColumnType[i].iMinSize
93127>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93128>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93129>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93130>>>>            Move 16384                                   to aColumnType[i].sPrecision
93131>>>>            Increment i
93132>>>>
93132>>>>            Move "real"                                  to aColumnType[i].sSQLType
93133>>>>            Move 7                                       to aColumnType[i].iSQLType
93134>>>>            Move True                                    to aColumnType[i].bCanEditSize
93135>>>>            Move True                                    to aColumnType[i].bNativeDataType
93136>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93137>>>>            Move 1                                       to aColumnType[i].iMinSize
93138>>>>            Move 14                                      to aColumnType[i].nMaxSize
93139>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93140>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93141>>>>            Move 14                                      to aColumnType[i].sPrecision
93142>>>>            Increment i
93143>>>>
93143>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
93144>>>>            Move 58                                      to aColumnType[i].iSQLType
93145>>>>            Move True                                    to aColumnType[i].bCanEditSize
93146>>>>            Move True                                    to aColumnType[i].bNativeDataType
93147>>>>            Move 12                                      to aColumnType[i].iDefaultSize
93148>>>>            Move 12                                      to aColumnType[i].iMinSize
93149>>>>            Move 23                                      to aColumnType[i].nMaxSize
93150>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93151>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93152>>>>            Move 23                                      to aColumnType[i].sPrecision
93153>>>>            Increment i
93154>>>>
93154>>>>            Move "smallint"                              to aColumnType[i].sSQLType
93155>>>>            Move 5                                       to aColumnType[i].iSQLType
93156>>>>            Move True                                    to aColumnType[i].bCanEditSize
93157>>>>            Move True                                    to aColumnType[i].bNativeDataType
93158>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93159>>>>            Move -1                                      to aColumnType[i].iMinSize
93160>>>>            Move 6                                       to aColumnType[i].nMaxSize
93161>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93162>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93163>>>>            Move 6                                       to aColumnType[i].sPrecision
93164>>>>            Increment i
93165>>>>
93165>>>>            Move "sql_variant"                           to aColumnType[i].sSQLType
93166>>>>            Move -150                                    to aColumnType[i].iSQLType
93167>>>>            Move False                                   to aColumnType[i].bCanEditSize
93168>>>>            Move True                                    to aColumnType[i].bNativeDataType
93169>>>>            Move 8016                                    to aColumnType[i].iDefaultSize
93170>>>>            Move -1                                      to aColumnType[i].iMinSize
93171>>>>            Move -1                                      to aColumnType[i].nMaxSize
93172>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93173>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93174>>>>            Move -1                                      to aColumnType[i].sPrecision
93175>>>>            Increment i
93176>>>>
93176>>>>            Move "text"                                  to aColumnType[i].sSQLType
93177>>>>            Move -1                                      to aColumnType[i].iSQLType
93178>>>>            Move True                                    to aColumnType[i].bCanEditSize
93179>>>>            Move True                                    to aColumnType[i].bNativeDataType
93180>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93181>>>>            Move 1                                       to aColumnType[i].iMinSize
93182>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93183>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93184>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93185>>>>            Move 16384                                   to aColumnType[i].sPrecision
93186>>>>            Increment i
93187>>>>
93187>>>>            Move "time"                                  to aColumnType[i].sSQLType
93188>>>>            Move 41                                      to aColumnType[i].iSQLType
93189>>>>            Move True                                    to aColumnType[i].bCanEditSize
93190>>>>            Move True                                    to aColumnType[i].bNativeDataType
93191>>>>            Move 8                                       to aColumnType[i].iDefaultSize
93192>>>>            Move 8                                       to aColumnType[i].iMinSize
93193>>>>            Move 16                                      to aColumnType[i].nMaxSize
93194>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93195>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93196>>>>            Move 16                                      to aColumnType[i].sPrecision
93197>>>>            Increment i
93198>>>>
93198>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
93199>>>>            Move 93                                      to aColumnType[i].iSQLType
93200>>>>            Move False                                   to aColumnType[i].bCanEditSize
93201>>>>            Move True                                    to aColumnType[i].bNativeDataType
93202>>>>            Move 8                                       to aColumnType[i].iDefaultSize
93203>>>>            Move -1                                      to aColumnType[i].iMinSize
93204>>>>            Move -1                                      to aColumnType[i].nMaxSize
93205>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93206>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93207>>>>            Move -1                                      to aColumnType[i].sPrecision
93208>>>>            Increment i
93209>>>>
93209>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
93210>>>>            Move -6                                      to aColumnType[i].iSQLType
93211>>>>            Move True                                    to aColumnType[i].bCanEditSize
93212>>>>            Move True                                    to aColumnType[i].bNativeDataType
93213>>>>            Move 3                                       to aColumnType[i].iDefaultSize
93214>>>>            Move -1                                      to aColumnType[i].iMinSize
93215>>>>            Move 3                                       to aColumnType[i].nMaxSize
93216>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93217>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93218>>>>            Move 3                                       to aColumnType[i].sPrecision
93219>>>>            Increment i
93220>>>>
93220>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
93221>>>>            Move -11                                     to aColumnType[i].iSQLType
93222>>>>            Move False                                   to aColumnType[i].bCanEditSize
93223>>>>            Move True                                    to aColumnType[i].bNativeDataType
93224>>>>            Move 38                                      to aColumnType[i].iDefaultSize
93225>>>>            Move -1                                      to aColumnType[i].iMinSize
93226>>>>            Move -1                                      to aColumnType[i].nMaxSize
93227>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93228>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93229>>>>            Move -1                                      to aColumnType[i].sPrecision
93230>>>>            Increment i
93231>>>>
93231>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
93232>>>>            Move -3                                      to aColumnType[i].iSQLType
93233>>>>            Move True                                    to aColumnType[i].bCanEditSize
93234>>>>            Move True                                    to aColumnType[i].bNativeDataType
93235>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
93236>>>>            Move 1                                       to aColumnType[i].iMinSize
93237>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93238>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93239>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93240>>>>            Move 8000                                    to aColumnType[i].sPrecision
93241>>>>            Increment i
93242>>>>
93242>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
93243>>>>            Move -98                                     to aColumnType[i].iSQLType
93244>>>>            Move True                                    to aColumnType[i].bCanEditSize
93245>>>>            Move True                                    to aColumnType[i].bNativeDataType
93246>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93247>>>>            Move 1                                       to aColumnType[i].iMinSize
93248>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93249>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93250>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93251>>>>            Move 16384                                   to aColumnType[i].sPrecision
93252>>>>            Increment i
93253>>>>
93253>>>>            Move "varchar"                               to aColumnType[i].sSQLType
93254>>>>            Move 12                                      to aColumnType[i].iSQLType
93255>>>>            Move True                                    to aColumnType[i].bCanEditSize
93256>>>>            Move True                                    to aColumnType[i].bNativeDataType
93257>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93258>>>>            Move 1                                       to aColumnType[i].iMinSize
93259>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93260>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93261>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93262>>>>            Move 8000                                    to aColumnType[i].sPrecision
93263>>>>            Increment i
93264>>>>
93264>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
93265>>>>            Move -99                                     to aColumnType[i].iSQLType
93266>>>>            Move True                                    to aColumnType[i].bCanEditSize
93267>>>>            Move True                                    to aColumnType[i].bNativeDataType
93268>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93269>>>>            Move 1                                       to aColumnType[i].iMinSize
93270>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93271>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93272>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93273>>>>            Move 16384                                   to aColumnType[i].sPrecision
93274>>>>            Increment i
93275>>>>
93275>>>>            Move "xml"                                   to aColumnType[i].sSQLType
93276>>>>            Move -370                                    to aColumnType[i].iSQLType
93277>>>>            Move True                                    to aColumnType[i].bCanEditSize
93278>>>>            Move True                                    to aColumnType[i].bNativeDataType
93279>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93280>>>>            Move 1                                       to aColumnType[i].iMinSize
93281>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93282>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93283>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93284>>>>            Move 16384                                   to aColumnType[i].sPrecision
93285>>>>            Increment i
93286>>>>
93286>>>>
93286>>>
93286>>>//            Move eSQLServer_BIGINT  to ColumnType[i].iSQLType
93286>>>//            Move "BigInt"           to ColumnType[i].sSQLType
93286>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93286>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93286>>>//            Move "14.0"             to ColumnType[i].sPrecision
93286>>>//            Move True               to ColumnType[i].bCanEditSize
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_BINARY  to ColumnType[i].iSQLType
93286>>>//            Move "Binary"           to ColumnType[i].sSQLType
93286>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
93286>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
93286>>>//            Move "8000"             to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_BIT     to ColumnType[i].iSQLType
93286>>>//            Move "Bit"              to ColumnType[i].sSQLType
93286>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93286>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93286>>>//            Move "1.0"              to ColumnType[i].sPrecision
93286>>>//            Move True               to ColumnType[i].bCanEditSize // In SQL allows 1, 0, or "NULL"
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_CHAR    to ColumnType[i].iSQLType
93286>>>//            Move "Char"             to ColumnType[i].sSQLType
93286>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93286>>>//            Move "Text"             to ColumnType[i].sDataFlexType
93286>>>//            Move "8000"             to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_DATE    to ColumnType[i].iSQLType
93286>>>//            Move "Date"             to ColumnType[i].sSQLType
93286>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
93286>>>//            Move "Date"             to ColumnType[i].sDataFlexType
93286>>>//            Move "6.0"              to ColumnType[i].sPrecision
93286>>>//            Move True               to ColumnType[i].bCanEditSize
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_DATETIME    to ColumnType[i].iSQLType
93286>>>//            Move "DateTime"             to ColumnType[i].sSQLType
93286>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
93286>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
93286>>>//            Move "23.3"                 to ColumnType[i].sPrecision
93286>>>//            Move True                   to ColumnType[i].bCanEditSize
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_DATETIME2   to ColumnType[i].iSQLType
93286>>>//            Move "DateTime2"            to ColumnType[i].sSQLType
93286>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
93286>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
93286>>>//            Move "23.6"                 to ColumnType[i].sPrecision
93286>>>//            Move True                   to ColumnType[i].bCanEditSize
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iSQLType
93286>>>//            Move "DateTimeOffest"           to ColumnType[i].sSQLType
93286>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
93286>>>//            Move "DateTime"                 to ColumnType[i].sDataFlexType
93286>>>//            Move "23.0"                     to ColumnType[i].sPrecision
93286>>>//            Move True                       to ColumnType[i].bCanEditSize
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_DECIMAL to ColumnType[i].iSQLType
93286>>>//            Move "Decimal"          to ColumnType[i].sSQLType
93286>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93286>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93286>>>//            Move "14.8"             to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_DOUBLE  to ColumnType[i].iSQLType
93286>>>//            Move "Double"           to ColumnType[i].sSQLType
93286>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93286>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93286>>>//            Move "14.8"             to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_FLOAT   to ColumnType[i].iSQLType
93286>>>//            Move "Float"            to ColumnType[i].sSQLType
93286>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93286>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93286>>>//            Move "14.8"             to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_INT     to ColumnType[i].iSQLType
93286>>>//            Move "Int"              to ColumnType[i].sSQLType
93286>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93286>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93286>>>//            Move "11.0"             to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_NCHAR   to ColumnType[i].iSQLType
93286>>>//            Move "Nchar"            to ColumnType[i].sSQLType
93286>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93286>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93286>>>//            Move "4000"             to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_NTEXT   to ColumnType[i].iSQLType
93286>>>//            Move "Ntext"            to ColumnType[i].sSQLType
93286>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93286>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93286>>>//            Move "16384"            to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_NUMERIC to ColumnType[i].iSQLType
93286>>>//            Move "Numeric"          to ColumnType[i].sSQLType
93286>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93286>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93286>>>//            Move "14.8"             to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_NVARCHAR    to ColumnType[i].iSQLType
93286>>>//            Move "NvarChar"             to ColumnType[i].sSQLType
93286>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
93286>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
93286>>>//            Move "4000"                 to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_NVARCHARMAX to ColumnType[i].iSQLType
93286>>>//            Move "NvarCharMax"          to ColumnType[i].sSQLType
93286>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
93286>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
93286>>>//            Move "16384"                to ColumnType[i].sPrecision
93286>>>//            Move True                   to ColumnType[i].bCanEditSize
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_REAL    to ColumnType[i].iSQLType
93286>>>//            Move "Real"             to ColumnType[i].sSQLType
93286>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93286>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
93286>>>//            Move "14.8"             to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iSQLType
93286>>>//            Move "SmallDateTime"            to ColumnType[i].sSQLType
93286>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
93286>>>//            Move "DATETIME"                 to ColumnType[i].sDataFlexType
93286>>>//            Move "23.0"                     to ColumnType[i].sPrecision
93286>>>//            Move True                       to ColumnType[i].bCanEditSize
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_SMALLINT    to ColumnType[i].iSQLType
93286>>>//            Move "SmallInt"             to ColumnType[i].sSQLType
93286>>>//            Move DF_BCD                 to ColumnType[i].iDataFlexType
93286>>>//            Move "NUMERIC"              to ColumnType[i].sDataFlexType
93286>>>//            Move "6.0"                  to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_TEXT    to ColumnType[i].iSQLType
93286>>>//            Move "Text"             to ColumnType[i].sSQLType
93286>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93286>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93286>>>//            Move "8000"             to ColumnType[i].sPrecision
93286>>>//            Move True               to ColumnType[i].bCanEditSize
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_TIME    to ColumnType[i].iSQLType
93286>>>//            Move "Time"             to ColumnType[i].sSQLType
93286>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93286>>>//            Move "Date"             to ColumnType[i].sDataFlexType
93286>>>//            Move "16.0"             to ColumnType[i].sPrecision
93286>>>//            Move True               to ColumnType[i].bCanEditSize
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_TIMESTAMP   to ColumnType[i].iSQLType
93286>>>//            Move "TimeStamp"            to ColumnType[i].sSQLType
93286>>>//            Move DF_ASCII               to ColumnType[i].iDataFlexType
93286>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
93286>>>//            Move "8.0"                  to ColumnType[i].sPrecision
93286>>>//            Move True                   to ColumnType[i].bCanEditSize
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_TINYINT to ColumnType[i].iSQLType
93286>>>//            Move "TinyInt"          to ColumnType[i].sSQLType
93286>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93286>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93286>>>//            Move "3.0"              to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_GUID    to ColumnType[i].iSQLType
93286>>>//            Move "UniqueIdentifier" to ColumnType[i].sSQLType
93286>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93286>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93286>>>//            Move "38"               to ColumnType[i].sPrecision
93286>>>//            Move True               to ColumnType[i].bCanEditSize
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_VARBINARY   to ColumnType[i].iSQLType
93286>>>//            Move "VarBinary"            to ColumnType[i].sSQLType
93286>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
93286>>>//            Move "BINARY"               to ColumnType[i].sDataFlexType
93286>>>//            Move "8000"                 to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_VARBINARYMAX to ColumnType[i].iSQLType
93286>>>//            Move "VarBinary(Max)"        to ColumnType[i].sSQLType
93286>>>//            Move DF_BINARY               to ColumnType[i].iDataFlexType
93286>>>//            Move "BINARY"                to ColumnType[i].sDataFlexType
93286>>>//            Move "16384"                 to ColumnType[i].sPrecision
93286>>>//            Move True                    to ColumnType[i].bCanEditSize
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_VARCHAR to ColumnType[i].iSQLType
93286>>>//            Move "VarChar"          to ColumnType[i].sSQLType
93286>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
93286>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93286>>>//            Move "8000"             to ColumnType[i].sPrecision
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_VARCHARMAX  to ColumnType[i].iSQLType
93286>>>//            Move "VarChar(Max)"         to ColumnType[i].sSQLType
93286>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
93286>>>//            Move "TEXT"                 to ColumnType[i].sDataFlexType
93286>>>//            Move "16384"                to ColumnType[i].sPrecision
93286>>>//            Move True                   to ColumnType[i].bCanEditSize
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_SQLVARIANT  to ColumnType[i].iSQLType
93286>>>//            Move "SQL_Variant"          to ColumnType[i].sSQLType
93286>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
93286>>>//            Move "Binary"               to ColumnType[i].sDataFlexType
93286>>>//            Move "8016"                 to ColumnType[i].sPrecision
93286>>>//            Move True                   to ColumnType[i].bCanEditSize
93286>>>//            Increment i
93286>>>//
93286>>>//            Move eSQLServer_XML     to ColumnType[i].iSQLType
93286>>>//            Move "XML"              to ColumnType[i].sSQLType
93286>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93286>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93286>>>//            Move "16384"            to ColumnType[i].sPrecision
93286>>>        End
93286>>>>
93286>>>
93286>>>        Function_Return aColumnType
93287>>>    End_Function
93288>>>
93288>>>    // MySQL Data Types
93288>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
93290>>>        tColumnType[] aColumnType
93290>>>        tColumnType[] aColumnType
93291>>>        Integer i
93291>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
93291>>>>// Generated By The Database Update Framework
93291>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
93291>>>>// Driver COLUMN DATA TYPES
93291>>>>//
93291>>>>// Created: 2018-03-14 23:46:49.593
93291>>>>
93291>>>>            Move "bigint"                                to aColumnType[i].sSQLType
93292>>>>            Move 8                                       to aColumnType[i].iSQLType
93293>>>>            Move True                                    to aColumnType[i].bCanEditSize
93294>>>>            Move True                                    to aColumnType[i].bNativeDataType
93295>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93296>>>>            Move 1                                       to aColumnType[i].iMinSize
93297>>>>            Move 14                                      to aColumnType[i].nMaxSize
93298>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93299>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93300>>>>            Move 14                                      to aColumnType[i].sPrecision
93301>>>>            Increment i
93302>>>>
93302>>>>            Move "bit"                                   to aColumnType[i].sSQLType
93303>>>>            Move 16                                      to aColumnType[i].iSQLType
93304>>>>            Move True                                    to aColumnType[i].bCanEditSize
93305>>>>            Move True                                    to aColumnType[i].bNativeDataType
93306>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93307>>>>            Move -1                                      to aColumnType[i].iMinSize
93308>>>>            Move 64                                      to aColumnType[i].nMaxSize
93309>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93310>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93311>>>>            Move 64                                      to aColumnType[i].sPrecision
93312>>>>            Increment i
93313>>>>
93313>>>>            Move "blob"                                  to aColumnType[i].sSQLType
93314>>>>            Move 252                                     to aColumnType[i].iSQLType
93315>>>>            Move True                                    to aColumnType[i].bCanEditSize
93316>>>>            Move True                                    to aColumnType[i].bNativeDataType
93317>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93318>>>>            Move 1                                       to aColumnType[i].iMinSize
93319>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93320>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93321>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93322>>>>            Move 16384                                   to aColumnType[i].sPrecision
93323>>>>            Increment i
93324>>>>
93324>>>>            Move "char"                                  to aColumnType[i].sSQLType
93325>>>>            Move 254                                     to aColumnType[i].iSQLType
93326>>>>            Move True                                    to aColumnType[i].bCanEditSize
93327>>>>            Move True                                    to aColumnType[i].bNativeDataType
93328>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93329>>>>            Move 1                                       to aColumnType[i].iMinSize
93330>>>>            Move 255                                     to aColumnType[i].nMaxSize
93331>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93332>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93333>>>>            Move 255                                     to aColumnType[i].sPrecision
93334>>>>            Increment i
93335>>>>
93335>>>>            Move "date"                                  to aColumnType[i].sSQLType
93336>>>>            Move 10                                      to aColumnType[i].iSQLType
93337>>>>            Move False                                   to aColumnType[i].bCanEditSize
93338>>>>            Move True                                    to aColumnType[i].bNativeDataType
93339>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93340>>>>            Move -1                                      to aColumnType[i].iMinSize
93341>>>>            Move -1                                      to aColumnType[i].nMaxSize
93342>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
93343>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
93344>>>>            Move 6                                       to aColumnType[i].sPrecision
93345>>>>            Increment i
93346>>>>
93346>>>>            Move "datetime"                              to aColumnType[i].sSQLType
93347>>>>            Move 12                                      to aColumnType[i].iSQLType
93348>>>>            Move True                                    to aColumnType[i].bCanEditSize
93349>>>>            Move True                                    to aColumnType[i].bNativeDataType
93350>>>>            Move 23                                      to aColumnType[i].iDefaultSize
93351>>>>            Move 6                                       to aColumnType[i].iMinSize
93352>>>>            Move 23                                      to aColumnType[i].nMaxSize
93353>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93354>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93355>>>>            Move 23                                      to aColumnType[i].sPrecision
93356>>>>            Increment i
93357>>>>
93357>>>>            Move "decimal"                               to aColumnType[i].sSQLType
93358>>>>            Move 246                                     to aColumnType[i].iSQLType
93359>>>>            Move True                                    to aColumnType[i].bCanEditSize
93360>>>>            Move True                                    to aColumnType[i].bNativeDataType
93361>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93362>>>>            Move -1                                      to aColumnType[i].iMinSize
93363>>>>            Move 14                                      to aColumnType[i].nMaxSize
93364>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93365>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93366>>>>            Move 14                                      to aColumnType[i].sPrecision
93367>>>>            Increment i
93368>>>>
93368>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
93369>>>>            Move 0                                       to aColumnType[i].iSQLType
93370>>>>            Move True                                    to aColumnType[i].bCanEditSize
93371>>>>            Move True                                    to aColumnType[i].bNativeDataType
93372>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93373>>>>            Move -1                                      to aColumnType[i].iMinSize
93374>>>>            Move 14                                      to aColumnType[i].nMaxSize
93375>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93376>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93377>>>>            Move 14                                      to aColumnType[i].sPrecision
93378>>>>            Increment i
93379>>>>
93379>>>>            Move "double"                                to aColumnType[i].sSQLType
93380>>>>            Move 5                                       to aColumnType[i].iSQLType
93381>>>>            Move True                                    to aColumnType[i].bCanEditSize
93382>>>>            Move True                                    to aColumnType[i].bNativeDataType
93383>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93384>>>>            Move -1                                      to aColumnType[i].iMinSize
93385>>>>            Move 14                                      to aColumnType[i].nMaxSize
93386>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93387>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93388>>>>            Move 14                                      to aColumnType[i].sPrecision
93389>>>>            Increment i
93390>>>>
93390>>>>            Move "enum"                                  to aColumnType[i].sSQLType
93391>>>>            Move 247                                     to aColumnType[i].iSQLType
93392>>>>            Move True                                    to aColumnType[i].bCanEditSize
93393>>>>            Move True                                    to aColumnType[i].bNativeDataType
93394>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93395>>>>            Move -1                                      to aColumnType[i].iMinSize
93396>>>>            Move 255                                     to aColumnType[i].nMaxSize
93397>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93398>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93399>>>>            Move 255                                     to aColumnType[i].sPrecision
93400>>>>            Increment i
93401>>>>
93401>>>>            Move "float"                                 to aColumnType[i].sSQLType
93402>>>>            Move 4                                       to aColumnType[i].iSQLType
93403>>>>            Move True                                    to aColumnType[i].bCanEditSize
93404>>>>            Move True                                    to aColumnType[i].bNativeDataType
93405>>>>            Move 4                                       to aColumnType[i].iDefaultSize
93406>>>>            Move -1                                      to aColumnType[i].iMinSize
93407>>>>            Move 14                                      to aColumnType[i].nMaxSize
93408>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93409>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93410>>>>            Move 14                                      to aColumnType[i].sPrecision
93411>>>>            Increment i
93412>>>>
93412>>>>            Move "int"                                   to aColumnType[i].sSQLType
93413>>>>            Move 3                                       to aColumnType[i].iSQLType
93414>>>>            Move True                                    to aColumnType[i].bCanEditSize
93415>>>>            Move True                                    to aColumnType[i].bNativeDataType
93416>>>>            Move 10                                      to aColumnType[i].iDefaultSize
93417>>>>            Move -1                                      to aColumnType[i].iMinSize
93418>>>>            Move 11                                      to aColumnType[i].nMaxSize
93419>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93420>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93421>>>>            Move 11                                      to aColumnType[i].sPrecision
93422>>>>            Increment i
93423>>>>
93423>>>>            Move "longblob"                              to aColumnType[i].sSQLType
93424>>>>            Move 251                                     to aColumnType[i].iSQLType
93425>>>>            Move True                                    to aColumnType[i].bCanEditSize
93426>>>>            Move True                                    to aColumnType[i].bNativeDataType
93427>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93428>>>>            Move 1                                       to aColumnType[i].iMinSize
93429>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93430>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93431>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93432>>>>            Move 16384                                   to aColumnType[i].sPrecision
93433>>>>            Increment i
93434>>>>
93434>>>>            Move "longtext"                              to aColumnType[i].sSQLType
93435>>>>            Move -251                                    to aColumnType[i].iSQLType
93436>>>>            Move True                                    to aColumnType[i].bCanEditSize
93437>>>>            Move True                                    to aColumnType[i].bNativeDataType
93438>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93439>>>>            Move 1                                       to aColumnType[i].iMinSize
93440>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93441>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93442>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93443>>>>            Move 16384                                   to aColumnType[i].sPrecision
93444>>>>            Increment i
93445>>>>
93445>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
93446>>>>            Move 250                                     to aColumnType[i].iSQLType
93447>>>>            Move True                                    to aColumnType[i].bCanEditSize
93448>>>>            Move True                                    to aColumnType[i].bNativeDataType
93449>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93450>>>>            Move 1                                       to aColumnType[i].iMinSize
93451>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93452>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93453>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93454>>>>            Move 16384                                   to aColumnType[i].sPrecision
93455>>>>            Increment i
93456>>>>
93456>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
93457>>>>            Move 9                                       to aColumnType[i].iSQLType
93458>>>>            Move True                                    to aColumnType[i].bCanEditSize
93459>>>>            Move True                                    to aColumnType[i].bNativeDataType
93460>>>>            Move 8                                       to aColumnType[i].iDefaultSize
93461>>>>            Move 1                                       to aColumnType[i].iMinSize
93462>>>>            Move 9                                       to aColumnType[i].nMaxSize
93463>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93464>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93465>>>>            Move 9                                       to aColumnType[i].sPrecision
93466>>>>            Increment i
93467>>>>
93467>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
93468>>>>            Move -250                                    to aColumnType[i].iSQLType
93469>>>>            Move True                                    to aColumnType[i].bCanEditSize
93470>>>>            Move True                                    to aColumnType[i].bNativeDataType
93471>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93472>>>>            Move 1                                       to aColumnType[i].iMinSize
93473>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93474>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93475>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93476>>>>            Move 16384                                   to aColumnType[i].sPrecision
93477>>>>            Increment i
93478>>>>
93478>>>>            Move "set"                                   to aColumnType[i].sSQLType
93479>>>>            Move 248                                     to aColumnType[i].iSQLType
93480>>>>            Move True                                    to aColumnType[i].bCanEditSize
93481>>>>            Move True                                    to aColumnType[i].bNativeDataType
93482>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93483>>>>            Move -1                                      to aColumnType[i].iMinSize
93484>>>>            Move 255                                     to aColumnType[i].nMaxSize
93485>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93486>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93487>>>>            Move 255                                     to aColumnType[i].sPrecision
93488>>>>            Increment i
93489>>>>
93489>>>>            Move "smallint"                              to aColumnType[i].sSQLType
93490>>>>            Move 2                                       to aColumnType[i].iSQLType
93491>>>>            Move True                                    to aColumnType[i].bCanEditSize
93492>>>>            Move True                                    to aColumnType[i].bNativeDataType
93493>>>>            Move 5                                       to aColumnType[i].iDefaultSize
93494>>>>            Move 1                                       to aColumnType[i].iMinSize
93495>>>>            Move 6                                       to aColumnType[i].nMaxSize
93496>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93497>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93498>>>>            Move 6                                       to aColumnType[i].sPrecision
93499>>>>            Increment i
93500>>>>
93500>>>>            Move "text"                                  to aColumnType[i].sSQLType
93501>>>>            Move -252                                    to aColumnType[i].iSQLType
93502>>>>            Move True                                    to aColumnType[i].bCanEditSize
93503>>>>            Move True                                    to aColumnType[i].bNativeDataType
93504>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93505>>>>            Move 1                                       to aColumnType[i].iMinSize
93506>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93507>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93508>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93509>>>>            Move 16384                                   to aColumnType[i].sPrecision
93510>>>>            Increment i
93511>>>>
93511>>>>            Move "time"                                  to aColumnType[i].sSQLType
93512>>>>            Move 11                                      to aColumnType[i].iSQLType
93513>>>>            Move False                                   to aColumnType[i].bCanEditSize
93514>>>>            Move True                                    to aColumnType[i].bNativeDataType
93515>>>>            Move 10                                      to aColumnType[i].iDefaultSize
93516>>>>            Move -1                                      to aColumnType[i].iMinSize
93517>>>>            Move -1                                      to aColumnType[i].nMaxSize
93518>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93519>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93520>>>>            Move -1                                      to aColumnType[i].sPrecision
93521>>>>            Increment i
93522>>>>
93522>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
93523>>>>            Move 7                                       to aColumnType[i].iSQLType
93524>>>>            Move True                                    to aColumnType[i].bCanEditSize
93525>>>>            Move True                                    to aColumnType[i].bNativeDataType
93526>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93527>>>>            Move 6                                       to aColumnType[i].iMinSize
93528>>>>            Move 23                                      to aColumnType[i].nMaxSize
93529>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93530>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93531>>>>            Move 23                                      to aColumnType[i].sPrecision
93532>>>>            Increment i
93533>>>>
93533>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
93534>>>>            Move 249                                     to aColumnType[i].iSQLType
93535>>>>            Move True                                    to aColumnType[i].bCanEditSize
93536>>>>            Move True                                    to aColumnType[i].bNativeDataType
93537>>>>            Move 255                                     to aColumnType[i].iDefaultSize
93538>>>>            Move 1                                       to aColumnType[i].iMinSize
93539>>>>            Move 255                                     to aColumnType[i].nMaxSize
93540>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93541>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93542>>>>            Move 255                                     to aColumnType[i].sPrecision
93543>>>>            Increment i
93544>>>>
93544>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
93545>>>>            Move 1                                       to aColumnType[i].iSQLType
93546>>>>            Move True                                    to aColumnType[i].bCanEditSize
93547>>>>            Move True                                    to aColumnType[i].bNativeDataType
93548>>>>            Move 4                                       to aColumnType[i].iDefaultSize
93549>>>>            Move 1                                       to aColumnType[i].iMinSize
93550>>>>            Move 4                                       to aColumnType[i].nMaxSize
93551>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93552>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93553>>>>            Move 4                                       to aColumnType[i].sPrecision
93554>>>>            Increment i
93555>>>>
93555>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
93556>>>>            Move -249                                    to aColumnType[i].iSQLType
93557>>>>            Move True                                    to aColumnType[i].bCanEditSize
93558>>>>            Move True                                    to aColumnType[i].bNativeDataType
93559>>>>            Move 255                                     to aColumnType[i].iDefaultSize
93560>>>>            Move 1                                       to aColumnType[i].iMinSize
93561>>>>            Move 255                                     to aColumnType[i].nMaxSize
93562>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93563>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93564>>>>            Move 255                                     to aColumnType[i].sPrecision
93565>>>>            Increment i
93566>>>>
93566>>>>            Move "varchar"                               to aColumnType[i].sSQLType
93567>>>>            Move 253                                     to aColumnType[i].iSQLType
93568>>>>            Move True                                    to aColumnType[i].bCanEditSize
93569>>>>            Move True                                    to aColumnType[i].bNativeDataType
93570>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93571>>>>            Move -1                                      to aColumnType[i].iMinSize
93572>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93573>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93574>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93575>>>>            Move 16384                                   to aColumnType[i].sPrecision
93576>>>>            Increment i
93577>>>>
93577>>>>            Move "year"                                  to aColumnType[i].sSQLType
93578>>>>            Move 13                                      to aColumnType[i].iSQLType
93579>>>>            Move False                                   to aColumnType[i].bCanEditSize
93580>>>>            Move True                                    to aColumnType[i].bNativeDataType
93581>>>>            Move 4                                       to aColumnType[i].iDefaultSize
93582>>>>            Move -1                                      to aColumnType[i].iMinSize
93583>>>>            Move -1                                      to aColumnType[i].nMaxSize
93584>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93585>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93586>>>>            Move -1                                      to aColumnType[i].sPrecision
93587>>>>            Increment i
93588>>>>
93588>>>>
93588>>>
93588>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
93588>>>//        Move "bigint"           to ColumnType[i].sSQLType
93588>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93588>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93588>>>//        Move "14.0"             to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
93588>>>//        Move "bit"              to ColumnType[i].sSQLType
93588>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93588>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
93588>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
93588>>>//        Move True               to ColumnType[i].bCanEditSize
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
93588>>>//        Move "blob"             to ColumnType[i].sSQLType
93588>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
93588>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
93588>>>//        Move "16384"            to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
93588>>>//        Move "char"             to ColumnType[i].sSQLType
93588>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93588>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
93588>>>//        Move "254"              to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
93588>>>//        Move "date"             to ColumnType[i].sSQLType
93588>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
93588>>>//        Move "Date"             to ColumnType[i].sDataFlexType
93588>>>//        Move "6.0"              to ColumnType[i].sPrecision
93588>>>//        Move True               to ColumnType[i].bCanEditSize
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
93588>>>//        Move "datetime"         to ColumnType[i].sSQLType
93588>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
93588>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
93588>>>//        Move "23.0"             to ColumnType[i].sPrecision
93588>>>//        Move True               to ColumnType[i].bCanEditSize
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
93588>>>//        Move "decimal"          to ColumnType[i].sSQLType
93588>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93588>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93588>>>//        Move "14.8"             to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
93588>>>//        Move "double"           to ColumnType[i].sSQLType
93588>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93588>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93588>>>//        Move "14.8"             to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
93588>>>//        Move "enum"             to ColumnType[i].sSQLType
93588>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93588>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
93588>>>//        Move "254"              to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
93588>>>//        Move "float"            to ColumnType[i].sSQLType
93588>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93588>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93588>>>//        Move "14.8"             to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
93588>>>//        Move "int"              to ColumnType[i].sSQLType
93588>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93588>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
93588>>>//        Move "11.0"             to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
93588>>>//        Move "longblob"         to ColumnType[i].sSQLType
93588>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
93588>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
93588>>>//        Move "16384"            to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
93588>>>//        Move "longtext"         to ColumnType[i].sSQLType
93588>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93588>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93588>>>//        Move "16384"            to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
93588>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
93588>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
93588>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
93588>>>//        Move "16384"            to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
93588>>>//        Move "mediumint"        to ColumnType[i].sSQLType
93588>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93588>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93588>>>//        Move "9.0"              to ColumnType[i].sPrecision
93588>>>//
93588>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
93588>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
93588>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93588>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93588>>>//        Move "16384"            to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
93588>>>//        Move "set"              to ColumnType[i].sSQLType
93588>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93588>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
93588>>>//        Move "254"              to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
93588>>>//        Move "smallint"         to ColumnType[i].sSQLType
93588>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93588>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93588>>>//        Move "6.0"              to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
93588>>>//        Move "text"             to ColumnType[i].sSQLType
93588>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93588>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93588>>>//        Move "16384"            to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
93588>>>//        Move "time"             to ColumnType[i].sSQLType
93588>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93588>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
93588>>>//        Move "10.0"             to ColumnType[i].sPrecision
93588>>>//        Move True               to ColumnType[i].bCanEditSize
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
93588>>>//        Move "timestamp"        to ColumnType[i].sSQLType
93588>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
93588>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
93588>>>//        Move "23.0"             to ColumnType[i].sPrecision
93588>>>//        Move True               to ColumnType[i].bCanEditSize
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
93588>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
93588>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
93588>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
93588>>>//        Move "254"              to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
93588>>>//        Move "tinyint"          to ColumnType[i].sSQLType
93588>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93588>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93588>>>//        Move "4.0"              to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
93588>>>//        Move "tinytext"         to ColumnType[i].sSQLType
93588>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93588>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93588>>>//        Move "254"              to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
93588>>>//        Move "varchar"          to ColumnType[i].sSQLType
93588>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93588>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93588>>>//        Move "16384"            to ColumnType[i].sPrecision
93588>>>//        Increment i
93588>>>//
93588>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
93588>>>//        Move "year"             to ColumnType[i].sSQLType
93588>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93588>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
93588>>>//        Move "4.0"              to ColumnType[i].sPrecision
93588>>>//        Move True               to ColumnType[i].bCanEditSize
93588>>>//        Increment i
93588>>>
93588>>>        Function_Return aColumnType
93589>>>    End_Function
93590>>>
93590>>>    // Oracle Data Types
93590>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
93592>>>        tColumnType[] aColumnType
93592>>>        tColumnType[] aColumnType
93593>>>        Integer i
93593>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
93593>>>>// Generated By The Database Update Framework
93593>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
93593>>>>// Driver COLUMN DATA TYPES
93593>>>>//
93593>>>>// Created: 2018-03-14 23:47:34.82
93593>>>>
93593>>>>            Move "blob"                                  to aColumnType[i].sSQLType
93594>>>>            Move 113                                     to aColumnType[i].iSQLType
93595>>>>            Move True                                    to aColumnType[i].bCanEditSize
93596>>>>            Move True                                    to aColumnType[i].bNativeDataType
93597>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93598>>>>            Move 1                                       to aColumnType[i].iMinSize
93599>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93600>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93601>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93602>>>>            Move 16384                                   to aColumnType[i].sPrecision
93603>>>>            Increment i
93604>>>>
93604>>>>            Move "char"                                  to aColumnType[i].sSQLType
93605>>>>            Move 96                                      to aColumnType[i].iSQLType
93606>>>>            Move True                                    to aColumnType[i].bCanEditSize
93607>>>>            Move True                                    to aColumnType[i].bNativeDataType
93608>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93609>>>>            Move 1                                       to aColumnType[i].iMinSize
93610>>>>            Move 2000                                    to aColumnType[i].nMaxSize
93611>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93612>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93613>>>>            Move 2000                                    to aColumnType[i].sPrecision
93614>>>>            Increment i
93615>>>>
93615>>>>            Move "clob"                                  to aColumnType[i].sSQLType
93616>>>>            Move 112                                     to aColumnType[i].iSQLType
93617>>>>            Move True                                    to aColumnType[i].bCanEditSize
93618>>>>            Move True                                    to aColumnType[i].bNativeDataType
93619>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93620>>>>            Move 1                                       to aColumnType[i].iMinSize
93621>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93622>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93623>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93624>>>>            Move 16384                                   to aColumnType[i].sPrecision
93625>>>>            Increment i
93626>>>>
93626>>>>            Move "date"                                  to aColumnType[i].sSQLType
93627>>>>            Move 12                                      to aColumnType[i].iSQLType
93628>>>>            Move True                                    to aColumnType[i].bCanEditSize
93629>>>>            Move True                                    to aColumnType[i].bNativeDataType
93630>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93631>>>>            Move 6                                       to aColumnType[i].iMinSize
93632>>>>            Move 23                                      to aColumnType[i].nMaxSize
93633>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
93634>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
93635>>>>            Move 6                                       to aColumnType[i].sPrecision
93636>>>>            Increment i
93637>>>>
93637>>>>            Move "float"                                 to aColumnType[i].sSQLType
93638>>>>            Move 4                                       to aColumnType[i].iSQLType
93639>>>>            Move True                                    to aColumnType[i].bCanEditSize
93640>>>>            Move True                                    to aColumnType[i].bNativeDataType
93641>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93642>>>>            Move 1                                       to aColumnType[i].iMinSize
93643>>>>            Move 14                                      to aColumnType[i].nMaxSize
93644>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93645>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93646>>>>            Move 14                                      to aColumnType[i].sPrecision
93647>>>>            Increment i
93648>>>>
93648>>>>            Move "int"                                   to aColumnType[i].sSQLType
93649>>>>            Move 3                                       to aColumnType[i].iSQLType
93650>>>>            Move True                                    to aColumnType[i].bCanEditSize
93651>>>>            Move True                                    to aColumnType[i].bNativeDataType
93652>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93653>>>>            Move 1                                       to aColumnType[i].iMinSize
93654>>>>            Move 14                                      to aColumnType[i].nMaxSize
93655>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93656>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93657>>>>            Move 14                                      to aColumnType[i].sPrecision
93658>>>>            Increment i
93659>>>>
93659>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
93660>>>>            Move 190                                     to aColumnType[i].iSQLType
93661>>>>            Move False                                   to aColumnType[i].bCanEditSize
93662>>>>            Move True                                    to aColumnType[i].bNativeDataType
93663>>>>            Move 23                                      to aColumnType[i].iDefaultSize
93664>>>>            Move -1                                      to aColumnType[i].iMinSize
93665>>>>            Move -1                                      to aColumnType[i].nMaxSize
93666>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93667>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93668>>>>            Move -1                                      to aColumnType[i].sPrecision
93669>>>>            Increment i
93670>>>>
93670>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
93671>>>>            Move 189                                     to aColumnType[i].iSQLType
93672>>>>            Move False                                   to aColumnType[i].bCanEditSize
93673>>>>            Move True                                    to aColumnType[i].bNativeDataType
93674>>>>            Move 23                                      to aColumnType[i].iDefaultSize
93675>>>>            Move -1                                      to aColumnType[i].iMinSize
93676>>>>            Move -1                                      to aColumnType[i].nMaxSize
93677>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93678>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93679>>>>            Move -1                                      to aColumnType[i].sPrecision
93680>>>>            Increment i
93681>>>>
93681>>>>            Move "long"                                  to aColumnType[i].sSQLType
93682>>>>            Move 8                                       to aColumnType[i].iSQLType
93683>>>>            Move True                                    to aColumnType[i].bCanEditSize
93684>>>>            Move True                                    to aColumnType[i].bNativeDataType
93685>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93686>>>>            Move 1                                       to aColumnType[i].iMinSize
93687>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93688>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93689>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93690>>>>            Move 16384                                   to aColumnType[i].sPrecision
93691>>>>            Increment i
93692>>>>
93692>>>>            Move "longraw"                               to aColumnType[i].sSQLType
93693>>>>            Move 24                                      to aColumnType[i].iSQLType
93694>>>>            Move True                                    to aColumnType[i].bCanEditSize
93695>>>>            Move True                                    to aColumnType[i].bNativeDataType
93696>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93697>>>>            Move 1                                       to aColumnType[i].iMinSize
93698>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93699>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93700>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93701>>>>            Move 16384                                   to aColumnType[i].sPrecision
93702>>>>            Increment i
93703>>>>
93703>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
93704>>>>            Move 286                                     to aColumnType[i].iSQLType
93705>>>>            Move True                                    to aColumnType[i].bCanEditSize
93706>>>>            Move True                                    to aColumnType[i].bNativeDataType
93707>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93708>>>>            Move 1                                       to aColumnType[i].iMinSize
93709>>>>            Move 2000                                    to aColumnType[i].nMaxSize
93710>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93711>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93712>>>>            Move 2000                                    to aColumnType[i].sPrecision
93713>>>>            Increment i
93714>>>>
93714>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
93715>>>>            Move 288                                     to aColumnType[i].iSQLType
93716>>>>            Move True                                    to aColumnType[i].bCanEditSize
93717>>>>            Move True                                    to aColumnType[i].bNativeDataType
93718>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93719>>>>            Move 1                                       to aColumnType[i].iMinSize
93720>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93721>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93722>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93723>>>>            Move 16384                                   to aColumnType[i].sPrecision
93724>>>>            Increment i
93725>>>>
93725>>>>            Move "number"                                to aColumnType[i].sSQLType
93726>>>>            Move 2                                       to aColumnType[i].iSQLType
93727>>>>            Move True                                    to aColumnType[i].bCanEditSize
93728>>>>            Move True                                    to aColumnType[i].bNativeDataType
93729>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93730>>>>            Move 1                                       to aColumnType[i].iMinSize
93731>>>>            Move 14                                      to aColumnType[i].nMaxSize
93732>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93733>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93734>>>>            Move 14                                      to aColumnType[i].sPrecision
93735>>>>            Increment i
93736>>>>
93736>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
93737>>>>            Move 287                                     to aColumnType[i].iSQLType
93738>>>>            Move True                                    to aColumnType[i].bCanEditSize
93739>>>>            Move True                                    to aColumnType[i].bNativeDataType
93740>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93741>>>>            Move 1                                       to aColumnType[i].iMinSize
93742>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93743>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93744>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93745>>>>            Move 4000                                    to aColumnType[i].sPrecision
93746>>>>            Increment i
93747>>>>
93747>>>>            Move "raw"                                   to aColumnType[i].sSQLType
93748>>>>            Move 23                                      to aColumnType[i].iSQLType
93749>>>>            Move True                                    to aColumnType[i].bCanEditSize
93750>>>>            Move True                                    to aColumnType[i].bNativeDataType
93751>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93752>>>>            Move 1                                       to aColumnType[i].iMinSize
93753>>>>            Move 2000                                    to aColumnType[i].nMaxSize
93754>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93755>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93756>>>>            Move 2000                                    to aColumnType[i].sPrecision
93757>>>>            Increment i
93758>>>>
93758>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
93759>>>>            Move 187                                     to aColumnType[i].iSQLType
93760>>>>            Move False                                   to aColumnType[i].bCanEditSize
93761>>>>            Move True                                    to aColumnType[i].bNativeDataType
93762>>>>            Move 23                                      to aColumnType[i].iDefaultSize
93763>>>>            Move -1                                      to aColumnType[i].iMinSize
93764>>>>            Move -1                                      to aColumnType[i].nMaxSize
93765>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93766>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93767>>>>            Move -1                                      to aColumnType[i].sPrecision
93768>>>>            Increment i
93769>>>>
93769>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
93770>>>>            Move 232                                     to aColumnType[i].iSQLType
93771>>>>            Move False                                   to aColumnType[i].bCanEditSize
93772>>>>            Move True                                    to aColumnType[i].bNativeDataType
93773>>>>            Move 23                                      to aColumnType[i].iDefaultSize
93774>>>>            Move -1                                      to aColumnType[i].iMinSize
93775>>>>            Move -1                                      to aColumnType[i].nMaxSize
93776>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93777>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93778>>>>            Move -1                                      to aColumnType[i].sPrecision
93779>>>>            Increment i
93780>>>>
93780>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
93781>>>>            Move 188                                     to aColumnType[i].iSQLType
93782>>>>            Move False                                   to aColumnType[i].bCanEditSize
93783>>>>            Move True                                    to aColumnType[i].bNativeDataType
93784>>>>            Move 23                                      to aColumnType[i].iDefaultSize
93785>>>>            Move -1                                      to aColumnType[i].iMinSize
93786>>>>            Move -1                                      to aColumnType[i].nMaxSize
93787>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93788>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93789>>>>            Move -1                                      to aColumnType[i].sPrecision
93790>>>>            Increment i
93791>>>>
93791>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
93792>>>>            Move 1                                       to aColumnType[i].iSQLType
93793>>>>            Move True                                    to aColumnType[i].bCanEditSize
93794>>>>            Move True                                    to aColumnType[i].bNativeDataType
93795>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93796>>>>            Move 1                                       to aColumnType[i].iMinSize
93797>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93798>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93799>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93800>>>>            Move 4000                                    to aColumnType[i].sPrecision
93801>>>>            Increment i
93802>>>>
93802>>>>
93802>>>
93802>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
93802>>>//        Move "BLOB"             to ColumnType[i].sSQLType
93802>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
93802>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
93802>>>//        Move "16384"            to ColumnType[i].sPrecision
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
93802>>>//        Move "CHAR"             to ColumnType[i].sSQLType
93802>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93802>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93802>>>//        Move "2000"             to ColumnType[i].sPrecision
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
93802>>>//        Move "CLOB"             to ColumnType[i].sSQLType
93802>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93802>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93802>>>//        Move "16384"            to ColumnType[i].sPrecision
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
93802>>>//        Move "DATE"             to ColumnType[i].sSQLType
93802>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
93802>>>//        Move "Date"             to ColumnType[i].sDataFlexType
93802>>>//        Move "6.0"              to ColumnType[i].sPrecision
93802>>>//        Move True               to ColumnType[i].bCanEditSize
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
93802>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
93802>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93802>>>//        Move "Number"           to ColumnType[i].sDataFlexType
93802>>>//        Move "14.8"             to ColumnType[i].sPrecision
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
93802>>>//        Move "INT"              to ColumnType[i].sSQLType
93802>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93802>>>//        Move "Number"           to ColumnType[i].sDataFlexType
93802>>>//        Move "14.0"             to ColumnType[i].sPrecision
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
93802>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
93802>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
93802>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
93802>>>//        Move "23.0"             to ColumnType[i].sPrecision
93802>>>//        Move True               to ColumnType[i].bCanEditSize
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
93802>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
93802>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
93802>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
93802>>>//        Move "23.0"              to ColumnType[i].sPrecision
93802>>>//        Move True                to ColumnType[i].bCanEditSize
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
93802>>>//        Move "LONG"             to ColumnType[i].sSQLType
93802>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
93802>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
93802>>>//        Move "16384"            to ColumnType[i].sPrecision
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
93802>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
93802>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
93802>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
93802>>>//        Move "16384"            to ColumnType[i].sPrecision
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
93802>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
93802>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93802>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93802>>>//        Move "2000"             to ColumnType[i].sPrecision
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
93802>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
93802>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93802>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93802>>>//        Move "16384"            to ColumnType[i].sPrecision
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
93802>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
93802>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93802>>>//        Move "Number"           to ColumnType[i].sDataFlexType
93802>>>//        Move "14.8"             to ColumnType[i].sPrecision
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
93802>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
93802>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93802>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93802>>>//        Move "4000"             to ColumnType[i].sPrecision
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
93802>>>//        Move "RAW"              to ColumnType[i].sSQLType
93802>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
93802>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
93802>>>//        Move "2000"             to ColumnType[i].sPrecision
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
93802>>>//        Move "ROWID"            to ColumnType[i].sSQLType
93802>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93802>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93802>>>//        Move "16384"            to ColumnType[i].sPrecision
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
93802>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
93802>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
93802>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
93802>>>//        Move "11.0"             to ColumnType[i].sPrecision
93802>>>//        Move True               to ColumnType[i].bCanEditSize
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
93802>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
93802>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
93802>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
93802>>>//        Move "13.0"                 to ColumnType[i].sPrecision
93802>>>//        Move True                   to ColumnType[i].bCanEditSize
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
93802>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
93802>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
93802>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
93802>>>//        Move "11.0"                 to ColumnType[i].sPrecision
93802>>>//        Move True                   to ColumnType[i].bCanEditSize
93802>>>//        Increment i
93802>>>//
93802>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
93802>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
93802>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93802>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93802>>>//        Move "16384"            to ColumnType[i].sPrecision
93802>>>
93802>>>        Function_Return aColumnType
93803>>>    End_Function
93804>>>
93804>>>    // PostgreSQL Data Types
93804>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
93806>>>        tColumnType[] aColumnType
93806>>>        tColumnType[] aColumnType
93807>>>        Integer i
93807>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
93807>>>>// Generated By The Database Update Framework
93807>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
93807>>>>// Driver COLUMN DATA TYPES
93807>>>>//
93807>>>>// Created: 2018-03-14 23:47:02.984
93807>>>>
93807>>>>            Move "bigint"                                to aColumnType[i].sSQLType
93808>>>>            Move 20                                      to aColumnType[i].iSQLType
93809>>>>            Move True                                    to aColumnType[i].bCanEditSize
93810>>>>            Move True                                    to aColumnType[i].bNativeDataType
93811>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93812>>>>            Move 1                                       to aColumnType[i].iMinSize
93813>>>>            Move 14                                      to aColumnType[i].nMaxSize
93814>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93815>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93816>>>>            Move 14                                      to aColumnType[i].sPrecision
93817>>>>            Increment i
93818>>>>
93818>>>>            Move "bit"                                   to aColumnType[i].sSQLType
93819>>>>            Move 1560                                    to aColumnType[i].iSQLType
93820>>>>            Move True                                    to aColumnType[i].bCanEditSize
93821>>>>            Move True                                    to aColumnType[i].bNativeDataType
93822>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93823>>>>            Move 1                                       to aColumnType[i].iMinSize
93824>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93825>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93826>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93827>>>>            Move 16384                                   to aColumnType[i].sPrecision
93828>>>>            Increment i
93829>>>>
93829>>>>            Move "boolean"                               to aColumnType[i].sSQLType
93830>>>>            Move 16                                      to aColumnType[i].iSQLType
93831>>>>            Move False                                   to aColumnType[i].bCanEditSize
93832>>>>            Move True                                    to aColumnType[i].bNativeDataType
93833>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93834>>>>            Move -1                                      to aColumnType[i].iMinSize
93835>>>>            Move -1                                      to aColumnType[i].nMaxSize
93836>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93837>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93838>>>>            Move -1                                      to aColumnType[i].sPrecision
93839>>>>            Increment i
93840>>>>
93840>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
93841>>>>            Move 17                                      to aColumnType[i].iSQLType
93842>>>>            Move True                                    to aColumnType[i].bCanEditSize
93843>>>>            Move True                                    to aColumnType[i].bNativeDataType
93844>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93845>>>>            Move 1                                       to aColumnType[i].iMinSize
93846>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93847>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93848>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93849>>>>            Move 16384                                   to aColumnType[i].sPrecision
93850>>>>            Increment i
93851>>>>
93851>>>>            Move "char"                                  to aColumnType[i].sSQLType
93852>>>>            Move 18                                      to aColumnType[i].iSQLType
93853>>>>            Move True                                    to aColumnType[i].bCanEditSize
93854>>>>            Move True                                    to aColumnType[i].bNativeDataType
93855>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93856>>>>            Move 1                                       to aColumnType[i].iMinSize
93857>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93858>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93859>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93860>>>>            Move 16384                                   to aColumnType[i].sPrecision
93861>>>>            Increment i
93862>>>>
93862>>>>            Move "citext"                                to aColumnType[i].sSQLType
93863>>>>            Move -25                                     to aColumnType[i].iSQLType
93864>>>>            Move True                                    to aColumnType[i].bCanEditSize
93865>>>>            Move True                                    to aColumnType[i].bNativeDataType
93866>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93867>>>>            Move 1                                       to aColumnType[i].iMinSize
93868>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93869>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93870>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93871>>>>            Move 16384                                   to aColumnType[i].sPrecision
93872>>>>            Increment i
93873>>>>
93873>>>>            Move "date"                                  to aColumnType[i].sSQLType
93874>>>>            Move 1082                                    to aColumnType[i].iSQLType
93875>>>>            Move False                                   to aColumnType[i].bCanEditSize
93876>>>>            Move True                                    to aColumnType[i].bNativeDataType
93877>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93878>>>>            Move -1                                      to aColumnType[i].iMinSize
93879>>>>            Move -1                                      to aColumnType[i].nMaxSize
93880>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
93881>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
93882>>>>            Move 6                                       to aColumnType[i].sPrecision
93883>>>>            Increment i
93884>>>>
93884>>>>            Move "double"                                to aColumnType[i].sSQLType
93885>>>>            Move 701                                     to aColumnType[i].iSQLType
93886>>>>            Move True                                    to aColumnType[i].bCanEditSize
93887>>>>            Move True                                    to aColumnType[i].bNativeDataType
93888>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93889>>>>            Move 1                                       to aColumnType[i].iMinSize
93890>>>>            Move 14                                      to aColumnType[i].nMaxSize
93891>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93892>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93893>>>>            Move 14                                      to aColumnType[i].sPrecision
93894>>>>            Increment i
93895>>>>
93895>>>>            Move "integer"                               to aColumnType[i].sSQLType
93896>>>>            Move 23                                      to aColumnType[i].iSQLType
93897>>>>            Move True                                    to aColumnType[i].bCanEditSize
93898>>>>            Move True                                    to aColumnType[i].bNativeDataType
93899>>>>            Move 11                                      to aColumnType[i].iDefaultSize
93900>>>>            Move 1                                       to aColumnType[i].iMinSize
93901>>>>            Move 11                                      to aColumnType[i].nMaxSize
93902>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93903>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93904>>>>            Move 11                                      to aColumnType[i].sPrecision
93905>>>>            Increment i
93906>>>>
93906>>>>            Move "money"                                 to aColumnType[i].sSQLType
93907>>>>            Move 790                                     to aColumnType[i].iSQLType
93908>>>>            Move True                                    to aColumnType[i].bCanEditSize
93909>>>>            Move True                                    to aColumnType[i].bNativeDataType
93910>>>>            Move 30                                      to aColumnType[i].iDefaultSize
93911>>>>            Move 1                                       to aColumnType[i].iMinSize
93912>>>>            Move 30                                      to aColumnType[i].nMaxSize
93913>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93914>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93915>>>>            Move 30                                      to aColumnType[i].sPrecision
93916>>>>            Increment i
93917>>>>
93917>>>>            Move "numeric"                               to aColumnType[i].sSQLType
93918>>>>            Move 1700                                    to aColumnType[i].iSQLType
93919>>>>            Move True                                    to aColumnType[i].bCanEditSize
93920>>>>            Move True                                    to aColumnType[i].bNativeDataType
93921>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93922>>>>            Move 1                                       to aColumnType[i].iMinSize
93923>>>>            Move 14                                      to aColumnType[i].nMaxSize
93924>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93925>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93926>>>>            Move 14                                      to aColumnType[i].sPrecision
93927>>>>            Increment i
93928>>>>
93928>>>>            Move "oid"                                   to aColumnType[i].sSQLType
93929>>>>            Move 26                                      to aColumnType[i].iSQLType
93930>>>>            Move False                                   to aColumnType[i].bCanEditSize
93931>>>>            Move True                                    to aColumnType[i].bNativeDataType
93932>>>>            Move 20                                      to aColumnType[i].iDefaultSize
93933>>>>            Move -1                                      to aColumnType[i].iMinSize
93934>>>>            Move -1                                      to aColumnType[i].nMaxSize
93935>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93936>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93937>>>>            Move -1                                      to aColumnType[i].sPrecision
93938>>>>            Increment i
93939>>>>
93939>>>>            Move "real"                                  to aColumnType[i].sSQLType
93940>>>>            Move 700                                     to aColumnType[i].iSQLType
93941>>>>            Move True                                    to aColumnType[i].bCanEditSize
93942>>>>            Move True                                    to aColumnType[i].bNativeDataType
93943>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93944>>>>            Move 1                                       to aColumnType[i].iMinSize
93945>>>>            Move 6                                       to aColumnType[i].nMaxSize
93946>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93947>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93948>>>>            Move 6                                       to aColumnType[i].sPrecision
93949>>>>            Increment i
93950>>>>
93950>>>>            Move "regproc"                               to aColumnType[i].sSQLType
93951>>>>            Move 24                                      to aColumnType[i].iSQLType
93952>>>>            Move False                                   to aColumnType[i].bCanEditSize
93953>>>>            Move True                                    to aColumnType[i].bNativeDataType
93954>>>>            Move 64                                      to aColumnType[i].iDefaultSize
93955>>>>            Move -1                                      to aColumnType[i].iMinSize
93956>>>>            Move -1                                      to aColumnType[i].nMaxSize
93957>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93958>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93959>>>>            Move -1                                      to aColumnType[i].sPrecision
93960>>>>            Increment i
93961>>>>
93961>>>>            Move "smallint"                              to aColumnType[i].sSQLType
93962>>>>            Move 21                                      to aColumnType[i].iSQLType
93963>>>>            Move True                                    to aColumnType[i].bCanEditSize
93964>>>>            Move True                                    to aColumnType[i].bNativeDataType
93965>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93966>>>>            Move 1                                       to aColumnType[i].iMinSize
93967>>>>            Move 6                                       to aColumnType[i].nMaxSize
93968>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93969>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93970>>>>            Move 6                                       to aColumnType[i].sPrecision
93971>>>>            Increment i
93972>>>>
93972>>>>            Move "text"                                  to aColumnType[i].sSQLType
93973>>>>            Move 25                                      to aColumnType[i].iSQLType
93974>>>>            Move True                                    to aColumnType[i].bCanEditSize
93975>>>>            Move True                                    to aColumnType[i].bNativeDataType
93976>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93977>>>>            Move 1                                       to aColumnType[i].iMinSize
93978>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93979>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93980>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93981>>>>            Move 16384                                   to aColumnType[i].sPrecision
93982>>>>            Increment i
93983>>>>
93983>>>>            Move "time"                                  to aColumnType[i].sSQLType
93984>>>>            Move 1083                                    to aColumnType[i].iSQLType
93985>>>>            Move True                                    to aColumnType[i].bCanEditSize
93986>>>>            Move True                                    to aColumnType[i].bNativeDataType
93987>>>>            Move 8                                       to aColumnType[i].iDefaultSize
93988>>>>            Move 8                                       to aColumnType[i].iMinSize
93989>>>>            Move 15                                      to aColumnType[i].nMaxSize
93990>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93991>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93992>>>>            Move 15                                      to aColumnType[i].sPrecision
93993>>>>            Increment i
93994>>>>
93994>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
93995>>>>            Move 1114                                    to aColumnType[i].iSQLType
93996>>>>            Move False                                   to aColumnType[i].bCanEditSize
93997>>>>            Move True                                    to aColumnType[i].bNativeDataType
93998>>>>            Move 23                                      to aColumnType[i].iDefaultSize
93999>>>>            Move -1                                      to aColumnType[i].iMinSize
94000>>>>            Move -1                                      to aColumnType[i].nMaxSize
94001>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94002>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94003>>>>            Move -1                                      to aColumnType[i].sPrecision
94004>>>>            Increment i
94005>>>>
94005>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
94006>>>>            Move 1184                                    to aColumnType[i].iSQLType
94007>>>>            Move False                                   to aColumnType[i].bCanEditSize
94008>>>>            Move True                                    to aColumnType[i].bNativeDataType
94009>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94010>>>>            Move -1                                      to aColumnType[i].iMinSize
94011>>>>            Move -1                                      to aColumnType[i].nMaxSize
94012>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94013>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94014>>>>            Move -1                                      to aColumnType[i].sPrecision
94015>>>>            Increment i
94016>>>>
94016>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
94017>>>>            Move 2950                                    to aColumnType[i].iSQLType
94018>>>>            Move False                                   to aColumnType[i].bCanEditSize
94019>>>>            Move True                                    to aColumnType[i].bNativeDataType
94020>>>>            Move 40                                      to aColumnType[i].iDefaultSize
94021>>>>            Move -1                                      to aColumnType[i].iMinSize
94022>>>>            Move -1                                      to aColumnType[i].nMaxSize
94023>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94024>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94025>>>>            Move -1                                      to aColumnType[i].sPrecision
94026>>>>            Increment i
94027>>>>
94027>>>>            Move "varbit"                                to aColumnType[i].sSQLType
94028>>>>            Move 1562                                    to aColumnType[i].iSQLType
94029>>>>            Move True                                    to aColumnType[i].bCanEditSize
94030>>>>            Move True                                    to aColumnType[i].bNativeDataType
94031>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94032>>>>            Move 1                                       to aColumnType[i].iMinSize
94033>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94034>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94035>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94036>>>>            Move 16384                                   to aColumnType[i].sPrecision
94037>>>>            Increment i
94038>>>>
94038>>>>            Move "varchar"                               to aColumnType[i].sSQLType
94039>>>>            Move 1043                                    to aColumnType[i].iSQLType
94040>>>>            Move True                                    to aColumnType[i].bCanEditSize
94041>>>>            Move True                                    to aColumnType[i].bNativeDataType
94042>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94043>>>>            Move 1                                       to aColumnType[i].iMinSize
94044>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94045>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94046>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94047>>>>            Move 16384                                   to aColumnType[i].sPrecision
94048>>>>            Increment i
94049>>>>
94049>>>>
94049>>>
94049>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
94049>>>//        Move "bigint"           to ColumnType[i].sSQLType
94049>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94049>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94049>>>//        Move "14.0"             to ColumnType[i].sPrecision
94049>>>//        Move True               to ColumnType[i].bCanEditSize
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
94049>>>//        Move "bit"              to ColumnType[i].sSQLType
94049>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94049>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94049>>>//        Move "16384"            to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
94049>>>//        Move "boolean"          to ColumnType[i].sSQLType
94049>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94049>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94049>>>//        Move "1"                to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
94049>>>//        Move "bytea"            to ColumnType[i].sSQLType
94049>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94049>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94049>>>//        Move "16384"            to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
94049>>>//        Move "char"             to ColumnType[i].sSQLType
94049>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94049>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94049>>>//        Move "2000"             to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
94049>>>//        Move "citext"           to ColumnType[i].sSQLType
94049>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94049>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94049>>>//        Move "254"              to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
94049>>>//        Move "date"             to ColumnType[i].sSQLType
94049>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
94049>>>//        Move "Date"             to ColumnType[i].sDataFlexType
94049>>>//        Move "6.0"              to ColumnType[i].sPrecision
94049>>>//        Move True               to ColumnType[i].bCanEditSize
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
94049>>>//        Move "decimal"          to ColumnType[i].sSQLType
94049>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94049>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
94049>>>//        Move "14.8"             to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
94049>>>//        Move "double"           to ColumnType[i].sSQLType
94049>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94049>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94049>>>//        Move "22"               to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
94049>>>//        Move "integer"          to ColumnType[i].sSQLType
94049>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94049>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94049>>>//        Move "8.0"              to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
94049>>>//        Move "money"            to ColumnType[i].sSQLType
94049>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94049>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94049>>>//        Move "8.0"              to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
94049>>>//        Move "oid"              to ColumnType[i].sSQLType
94049>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94049>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94049>>>//        Move "16384"            to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
94049>>>//        Move "real"             to ColumnType[i].sSQLType
94049>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94049>>>//        Move "Real"             to ColumnType[i].sDataFlexType
94049>>>//        Move "6.6"              to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
94049>>>//        Move "regproc"          to ColumnType[i].sSQLType
94049>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94049>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94049>>>//        Move "64"               to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
94049>>>//        Move "smallint"         to ColumnType[i].sSQLType
94049>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94049>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94049>>>//        Move "6.0"              to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
94049>>>//        Move "text"             to ColumnType[i].sSQLType
94049>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94049>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94049>>>//        Move "16384"            to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
94049>>>//        Move "time"             to ColumnType[i].sSQLType
94049>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94049>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94049>>>//        Move "15.0"             to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
94049>>>//        Move "timestamp"        to ColumnType[i].sSQLType
94049>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94049>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94049>>>//        Move "23.0"             to ColumnType[i].sPrecision
94049>>>//        Move True               to ColumnType[i].bCanEditSize
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
94049>>>//        Move "uuid"             to ColumnType[i].sSQLType
94049>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94049>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94049>>>//        Move "40"               to ColumnType[i].sPrecision
94049>>>//        Move True               to ColumnType[i].bCanEditSize
94049>>>//        Increment i
94049>>>//
94049>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
94049>>>//        Move "varchar"          to ColumnType[i].sSQLType
94049>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94049>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
94049>>>//        Move "16384"            to ColumnType[i].sPrecision
94049>>>//        Increment i
94049>>>
94049>>>        Function_Return aColumnType
94050>>>    End_Function
94051>>>
94051>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
94051>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
94053>>>        Integer iValue iSize iCount iStart
94053>>>        tColumnType[] ColumnTypeArray
94053>>>        tColumnType[] ColumnTypeArray
94054>>>        tColumnType RetvalType
94054>>>        tColumnType RetvalType
94054>>>        String sValue
94054>>>        Boolean bFrameworkDataFlexType
94054>>>
94054>>>        Move "Undefined" to RetvalType.sSQLType
94055>>>        Move -1999       to RetvalType.iSQLType
94056>>>
94056>>>        Move 0 to iStart
94057>>>        Move (Uppercase(sType)) to sType
94058>>>        Move (iType <= -1490) to bFrameworkDataFlexType
94059>>>        If (bFrameworkDataFlexType = True) Begin
94061>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
94062>>>            Function_Return RetvalType
94063>>>        End
94063>>>>
94063>>>
94063>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
94064>>>
94064>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
94065>>>        Decrement iSize
94066>>>
94066>>>        for iCount from iStart to iSize
94072>>>>
94072>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
94073>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
94074>>>            If (bIntegerInputType = True) Begin
94076>>>                If (iValue = iType) Begin
94078>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
94079>>>                    Move iType                                  to RetvalType.iSQLType
94080>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
94081>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
94082>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
94083>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
94084>>>                    Move iSize to iCount // We're done!
94085>>>                End
94085>>>>
94085>>>            End
94085>>>>
94085>>>            Else Begin
94086>>>                Move (Uppercase(sValue)) to sValue
94087>>>                If (sValue = sType) Begin
94089>>>                    Move sType                                  to RetvalType.sSQLType
94090>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
94091>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
94092>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
94093>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
94094>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
94095>>>                    Move iSize to iCount // We're done!
94096>>>                End
94096>>>>
94096>>>            End
94096>>>>
94096>>>        Loop
94097>>>>
94097>>>
94097>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
94097>>>        // In which case we search for a match in DataFlex standard types:
94097>>>        If (RetvalType.sSQLType = "Undefined") Begin
94099>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
94100>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
94101>>>            Decrement iSize
94102>>>
94102>>>            for iCount from iStart to iSize
94108>>>>
94108>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
94109>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
94110>>>                If (iValue = iType) Begin
94112>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
94113>>>                    Move iType                                  to RetvalType.iSQLType
94114>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
94115>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
94116>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
94117>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
94118>>>                    Move iSize to iCount // We're done!
94119>>>                End
94119>>>>
94119>>>            Loop
94120>>>>
94120>>>        End
94120>>>>
94120>>>
94120>>>        Function_Return RetvalType
94121>>>    End_Function
94122>>>
94122>>>    Function _AllTablesToConvert Returns Integer[]
94124>>>        Integer[] aTableConvertExceptions iTablesArray
94126>>>        Handle hTable
94126>>>        Integer iIndex
94126>>>        String sTableName
94126>>>        Boolean bFlexErrs
94126>>>
94126>>>        // a) Get the exception table array the developer has specified
94126>>>        Get paTableConvertExceptions to aTableConvertExceptions
94127>>>
94127>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
94127>>>        Repeat
94127>>>>
94127>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94130>>>            If (hTable <> 0) Begin
94132>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94135>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
94136>>>                If (bFlexErrs = False) Begin
94138>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
94140>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
94141>>>                        If (iIndex = -1) Begin
94143>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
94144>>>                        End
94144>>>>
94144>>>                    End
94144>>>>
94144>>>                End
94144>>>>
94144>>>            End
94144>>>>
94144>>>        Until (hTable = 0)
94146>>>
94146>>>        Move 0 to hTable
94147>>>
94147>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
94147>>>        Repeat
94147>>>>
94147>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94150>>>            If (hTable > 0) Begin
94152>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94155>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
94156>>>                If (bFlexErrs = False) Begin
94158>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
94159>>>                    If (iIndex = -1) Begin
94161>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
94162>>>                    End
94162>>>>
94162>>>                End
94162>>>>
94162>>>            End
94162>>>>
94162>>>        Until (hTable = 0)
94164>>>
94164>>>        Function_Return iTablesArray
94165>>>    End_Function
94166>>>
94166>>>    Function _AllTablesDateCorrections Returns Integer[]
94168>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
94170>>>        Handle hTable
94170>>>        Integer iIndex
94170>>>        String sTableName
94170>>>        Boolean bFlexErrs
94170>>>
94170>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
94171>>>        Move 0 to hTable
94172>>>
94172>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
94172>>>        Repeat
94172>>>>
94172>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94175>>>            If (hTable > 0) Begin
94177>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94180>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
94181>>>                If (bFlexErrs = False) Begin
94183>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
94184>>>                    If (iIndex = -1) Begin
94186>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
94187>>>                    End
94187>>>>
94187>>>                End
94187>>>>
94187>>>            End
94187>>>>
94187>>>        Until (hTable = 0)
94189>>>
94189>>>        Function_Return iTablesArray
94190>>>    End_Function
94191>>>
94191>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
94193>>>        tAPIColumn NewAPIColumn
94193>>>        tAPIColumn NewAPIColumn
94193>>>
94193>>>        Move sFieldName to NewAPIColumn.sFieldName
94194>>>        Move iType      to NewAPIColumn.iType
94195>>>        Move iLength    to NewAPIColumn.iLength
94196>>>        Move iPrecision to NewAPIColumn.iPrecision
94197>>>        Move iOptions   to NewAPIColumn.iOptions
94198>>>
94198>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
94199>>>
94199>>>        Function_Return aCurrent
94200>>>    End_Function
94201>>>
94201>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
94203>>>        String sRetval sFieldName
94203>>>        Integer iCount iSize
94203>>>
94203>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
94204>>>        Decrement iSize
94205>>>        for iCount from 0 to iSize
94211>>>>
94211>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
94212>>>            Move (sRetval * (String(sFieldName))) to sRetval
94213>>>        Loop
94214>>>>
94214>>>        Move (Trim(sRetval)) to sRetval
94215>>>
94215>>>        Function_Return sRetval
94216>>>    End_Function
94217>>>
94217>>>    // *** Miscellaneous other functions ***
94217>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
94217>>>    //
94217>>>
94217>>>    // Callback functionality used when e.g. calling driver functions directly.
94217>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
94219>>>        Integer iPerc
94219>>>        Number nReady nTotal
94219>>>
94219>>>        Send DoAdvance of ghoProgressBar
94220>>>
94220>>>        If (sCallback_Text contains "Copy records") Begin
94222>>>            Move CS_DUF_CopyingData to sCallback_Text
94223>>>        End
94223>>>>
94223>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
94225>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94226>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94227>>>        End
94227>>>>
94227>>>        If (sCallback_Text contains "Creating index") Begin
94229>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
94230>>>        End
94230>>>>
94230>>>
94230>>>        Case Begin
94230>>>            Case (iCallback_Type = DF_Message_Text)
94232>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94233>>>                Set Action_Text  of ghoStatusPanel to ""
94234>>>                Case Break
94235>>>            Case (iCallback_Type = DF_Message_Heading_1)
94238>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94239>>>                Set Action_Text  of ghoStatusPanel to ""
94240>>>                Case Break
94241>>>            Case (iCallback_Type = DF_Message_Heading_2)
94244>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94245>>>                Set Action_Text  of ghoStatusPanel to ""
94246>>>                Case Break
94247>>>            Case (iCallback_Type = DF_Message_Heading_3)
94250>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94251>>>                Set Action_Text  of ghoStatusPanel to ""
94252>>>                Case Break
94253>>>            Case (iCallback_Type = DF_Message_Heading_4)
94256>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94257>>>                Set Action_Text  of ghoStatusPanel to ""
94258>>>                Case Break
94259>>>            Case (iCallback_Type = DF_Message_Heading_5)
94262>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94263>>>                Set Action_Text  of ghoStatusPanel to ""
94264>>>                Case Break
94265>>>            Case (iCallback_Type = DF_Message_Warning)
94268>>>                Send None
94269>>>                Case Break
94270>>>            Case (iCallback_Type = DF_Message_Progress_Title)
94273>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94274>>>                Set Action_Text  of ghoStatusPanel to ""
94275>>>                Case Break
94276>>>            Case (iCallback_Type = DF_Message_Progress_Value)
94279>>>                //*** Interpret numbers
94279>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
94280>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
94281>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
94282>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
94283>>>                Case Break
94284>>>            Case Else
94284>>>                Set Message_Text to ""
94285>>>                Set Action_Text  to ""
94286>>>        Case End
94286>>>
94286>>>        Send ProcessEvents of ghoStatusPanel
94287>>>        Function_Return False
94288>>>    End_Function
94289>>>
94289>>>    Procedure IncreaseSortBufferSize
94291>>>        String sNull
94291>>>        Integer iSortBufferSize
94291>>>        Boolean bBufferSet
94291>>>
94291>>>        Move "" to sNull
94292>>>        Move (1024 * 128) to iSortBufferSize
94293>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
94298>>>
94298>>>    End_Procedure
94299>>>
94299>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
94301>>>        Integer iLastIndex iIndex iNumSegments
94301>>>        Boolean bOK
94301>>>        String sDriverID
94301>>>
94301>>>        If (hTable > 0) Begin
94303>>>            Get UtilDriverFromTableNumber hTable to sDriverID
94304>>>            Close hTable
94305>>>            Get OpenTableExclusive hTable to bOK
94306>>>            If (bOK = False) Begin
94308>>>                Procedure_Return
94309>>>            End
94309>>>>
94309>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
94312>>>            Structure_Start hTable sDriverID
94313>>>                for iIndex from 1 to iLastIndex
94319>>>>
94319>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94322>>>                    If (iNumSegments > 0) Begin
94324>>>                        If (bSetToBatch = True) Begin
94326>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
94329>>>                        End
94329>>>>
94329>>>                        Else Begin
94330>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
94333>>>                        End
94333>>>>
94333>>>                    End
94333>>>>
94333>>>                Loop
94334>>>>
94334>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94336>>>        End
94336>>>>
94336>>>    End_Procedure
94337>>>
94337>>>    Function NextFreeFilelistSlot Returns Handle
94339>>>        Handle hTable
94339>>>
94339>>>        Move 0 to hTable
94340>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
94343>>>
94343>>>        Function_Return hTable
94344>>>    End_Function
94345>>>
94345>>>    // For debugging purposes. To print Sql statements as they are build...
94345>>>    Procedure DebugPrint String sStmt String sFileName
94347>>>        Integer iCh
94347>>>        Get Seq_Append_Output_Channel sFileName to iCh
94348>>>            Write channel iCh sStmt
94350>>>        Send Seq_Close_Channel iCh
94351>>>    End_Procedure
94352>>>
94352>>>    // Returns the integer number for the passed Driver ID that is
94352>>>    // needed by some database API calls.
94352>>>    Function DriverIndex String sDriverID Returns Integer
94354>>>        String  sCurrentDriver
94354>>>        Integer iNumberOfDrivers iDriver iCount
94354>>>
94354>>>        Move 0 to iDriver
94355>>>
94355>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
94358>>>        for iCount from 1 to iNumberOfDrivers
94364>>>>
94364>>>
94364>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
94367>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
94369>>>                Move iCount to iDriver
94370>>>            End
94370>>>>
94370>>>        Loop
94371>>>>
94371>>>
94371>>>        // In case it was not found, it wasn't loaded so we do that now.
94371>>>        If (iDriver = 0) Begin
94373>>>            Move False to Err
94374>>>            Load_Driver sDriverID
94375>>>            If (Err = False) Begin
94377>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
94380>>>            End
94380>>>>
94380>>>        End
94380>>>>
94380>>>
94380>>>        Function_Return iDriver
94381>>>    End_Function
94382>>>
94382>>>    
94382>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
94384>>>        String sDriverID sVersion sClient sClientLowest sRetval
94384>>>        Integer iNumberOfDrivers iDriver iClient
94384>>>        Handle hoCLIHandler hoMSSQLHandler   
94384>>>        Boolean bOK
94384>>>        
94384>>>        Move "" to sRetval
94385>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
94386>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
94387>>>        Load_Driver MSSQLDRV_ID
94388>>>
94388>>>        // Loop through all loaded drivers.
94388>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
94391>>>        For iDriver from 1 to iNumberOfDrivers
94397>>>>
94397>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
94400>>>            If (sDriverID = MSSQLDRV_ID) Begin
94402>>>                Set psDriverID of hoCLIHandler to sDriverID
94403>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
94406>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
94407>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
94408>>>                Get CKRevision of hoCLIHandler to sVersion
94409>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
94410>>>                If (sClient <> "" and sRetval <> "") Begin
94412>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
94413>>>                End                                
94413>>>>
94413>>>                Else Begin
94414>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
94415>>>                End
94415>>>>
94415>>>            End
94415>>>>
94415>>>        Loop
94416>>>>
94416>>>        Send Destroy of hoCLIHandler  
94417>>>        Send Destroy of hoMSSQLHandler  
94418>>>        If (bShowErrorDialog = True) Begin
94420>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
94421>>>            If (bOK = False or (iClient < iClientVersion)) Begin
94423>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
94424>>>                If (bExitProgram = True) Begin
94426>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
94427>>>                End
94427>>>>
94427>>>                Send Stop_Box sRetval  
94428>>>                If (bExitProgram = True) Begin
94430>>>                    Send Exit_Application
94431>>>                End
94431>>>>
94431>>>            End
94431>>>>
94431>>>        End
94431>>>>
94431>>>        
94431>>>        Function_Return sRetval
94432>>>    End_Function  
94433>>>    
94433>>>    // Returns True if first "." separated string is greater than the second.
94433>>>    // It checks from left to right, one part of the string at a time.
94433>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
94433>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
94435>>>        String[] asVersion asSQLVersion          
94437>>>        Integer iSize iCount iVersion iSQLVersion
94437>>>        
94437>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
94438>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
94439>>>        Move (SizeOfArray(asVersion)) to iSize
94440>>>        // Make sure the two arrays are of the same size:
94440>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
94442>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
94443>>>        End
94443>>>>
94443>>>        Decrement iSize
94444>>>        for iCount from 0 to iSize
94450>>>>
94450>>>            Move asVersion[iCount]    to iVersion
94451>>>            Move asSQLVersion[iCount] to iSQLVersion
94452>>>            CompilerWarnings Off
94452>>>            If (iVersion > iSQLVersion) Break
94455>>>            CompilerWarnings On
94455>>>        Loop
94456>>>>
94456>>>        
94456>>>        Function_Return (iVersion > iSQLVersion)
94457>>>    End_Function
94458>>>
94458>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
94458>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
94458>>>    //       so in that case we "cheat" and report those tables were opened OK.
94458>>>    Function OpenTableExclusive Handle hTable Returns Boolean
94460>>>        Integer iMode
94460>>>        Boolean bOpened
94460>>>        String sTableName
94460>>>
94460>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94461>>>        // Can't open a table properly if run through the Debugger/Studio,
94461>>>        // so we generate an error here:
94461>>>        If (IsDebuggerPresent()) Begin
94463>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio"
94464>>>>
94464>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
94465>>>            Function_Return False
94466>>>        End
94466>>>>
94466>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
94469>>>        If (bOpened) Begin
94471>>>            If (IsDebuggerPresent()) Begin
94473>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94476>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
94478>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
94479>>>                    Function_Return True
94480>>>                End
94480>>>>
94480>>>            End
94480>>>>
94480>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
94483>>>            If (iMode=DF_EXCLUSIVE) Begin
94485>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
94486>>>                Function_Return True
94487>>>            End
94487>>>>
94487>>>            Close hTable
94488>>>        End
94488>>>>
94488>>>        Else Begin
94489>>>            Open hTable
94491>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
94494>>>            If (bOpened and IsDebuggerPresent()) Begin
94496>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94499>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
94501>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
94502>>>                    Function_Return True
94503>>>                End
94503>>>>
94503>>>            End
94503>>>>
94503>>>
94503>>>        End
94503>>>>
94503>>>
94503>>>        Close hTable
94504>>>        Open hTable Mode DF_EXCLUSIVE
94506>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
94509>>>
94509>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
94510>>>        Function_Return bOpened
94511>>>    End_Function
94512>>>
94512>>>    Function AutoConnectionIDLogin Returns Boolean
94514>>>        String sConnectionID sConnectionString sDriverID
94514>>>        Boolean bExists bOK bSQLDriver bMertech
94514>>>        Handle hoCLI hoDriver
94514>>>        Integer iRetval
94514>>>        tSQLConnection SQLConnection
94514>>>        tSQLConnection SQLConnection
94514>>>
94514>>>        Get psDriverID to sDriverID
94515>>>        Get IsSQLDriver sDriverID to bSQLDriver
94516>>>        If (bSQLDriver = False) Begin
94518>>>            Function_Return True
94519>>>        End
94519>>>>
94519>>>
94519>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94520>>>        Move SQLConnection.sDriverID                  to sDriverID
94521>>>        Move SQLConnection.sConnectionString          to sConnectionString
94522>>>        Get IsMertechDriver sDriverID to bMertech
94523>>>        If (bMertech = True) Begin
94525>>>            Get _MertechSQLManagerHandle to hoCLI
94526>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
94527>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
94528>>>            Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
94529>>>            Send Destroy of hoDriver
94530>>>            Function_Return bOK
94531>>>        End
94531>>>>
94531>>>
94531>>>        Move SQLConnection.sConnectionID to sConnectionID
94532>>>
94532>>>        Get IsConnectionID sConnectionID sDriverID to bExists
94533>>>        If (bExists = False) Begin
94535>>>            // We always start by deleting the current connection - if any - because the
94535>>>            // login details my have changed.
94535>>>            Get phoCLIHandler to hoCLI
94536>>>            Set psDriverID    of hoCLI to sDriverID
94537>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
94538>>>            Get AutoSetConnectionID sConnectionID to bOk
94539>>>            If (bOk = False) Begin
94541>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
94542>>>>
94542>>>                Function_Return False
94543>>>            End
94543>>>>
94543>>>            Move bOK to bExists
94544>>>        End
94544>>>>
94544>>>
94544>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
94545>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
94546>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
94547>>>        Send Destroy of hoDriver
94548>>>
94548>>>        Function_Return (bExists = True)
94549>>>    End_Function
94550>>>
94550>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
94550>>>    // Returns: False if nobody else is running
94550>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
94550>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
94550>>>    //      tables are not locked as DataFlex tables are.
94550>>>    Function IsDatabaseInUse Returns Boolean
94552>>>        Handle  hTable
94552>>>        String  sRootName
94552>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
94552>>>        Integer iCount iTables
94552>>>
94552>>>        Move 0 to iTables
94553>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
94554>>>        Get AutoConnectionIDLogin to bOK
94555>>>        Get UtilFilelistNoOfTables to iTables
94556>>>        Set piPosition   of ghoProgressBar to 0
94557>>>        Set piAdvanceBy  of ghoProgressBar to 1
94558>>>        Set piMaximum    of ghoProgressBar to iTables
94559>>>        Move 0 to hTable
94560>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94563>>>        Move False to bErr
94564>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
94565>>>
94565>>>        Repeat
94565>>>>
94565>>>            Set piPosition of ghoProgressBar to iCount
94566>>>            Increment iCount
94567>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94570>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
94571>>>
94571>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
94571>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
94572>>>            Move False to bOpen
94573>>>            Get UtilTableExists hTable to bExists
94574>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
94574>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
94576>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94577>>>                Open hTable
94579>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94582>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
94583>>>                If (bOpen = True) Begin
94585>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
94585>>>                    Get UtilTableIsAlias hTable to bAlias
94586>>>                    If (bAlias = False) Begin
94588>>>                        Close hTable
94589>>>                        Get OpenTableExclusive hTable to bOpen
94590>>>                        If (bOpen = False) Begin
94592>>>                            Move True to bErr
94593>>>                        End
94593>>>>
94593>>>                    End
94593>>>>
94593>>>                End
94593>>>>
94593>>>                Close hTable
94594>>>            End
94594>>>>
94594>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94597>>>            If (bErr = True ) ;                Break
94600>>>        Until (not(hTable))
94602>>>
94602>>>        Set Action_Text of ghoStatusPanel to ""
94603>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
94604>>>        Move False to Err
94605>>>
94605>>>        Function_Return bErr
94606>>>    End_Function
94607>>>
94607>>>    // Checks if the passed connection id exists in the CLI interface.
94607>>>    // This might be needed by API-methods when a connection id is to be used and
94607>>>    // the connection id hasn't been established with the driver's CLI interface.
94607>>>    // NOTE: Only applicable for DAW drivers.
94607>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
94609>>>        String sID sConnString
94609>>>        Integer iDriver iNumConn iCount
94609>>>        Handle hoCLI
94609>>>        Boolean bOK
94609>>>
94609>>>        Get IsDAWSQLDriver sDriverID to bOK
94610>>>        If (bOK = False) Begin
94612>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
94613>>>>
94613>>>            Function_Return False
94614>>>        End
94614>>>>
94614>>>
94614>>>        Move False to bOK
94615>>>        Get phoCLIHandler to hoCLI
94616>>>        If (hoCLI <> 0) Begin
94618>>>            Set psDriverID of hoCLI to sDriverID
94619>>>            Get DriverIndex of hoCLI sDriverID to iDriver
94620>>>
94620>>>            // If driver not loaded; load it.
94620>>>            If (iDriver = 0) Begin
94622>>>                Load_Driver sDriverID
94623>>>                Get DriverIndex sDriverID to iDriver
94624>>>            End
94624>>>>
94624>>>            If (iDriver <> 0) Begin
94626>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
94629>>>                Decrement iNumConn
94630>>>                for iCount from 0 to iNumConn
94636>>>>
94636>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
94639>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
94642>>>                    If (sID = sConnectionID) Begin
94644>>>                        Move True to bOK
94645>>>                    End
94645>>>>
94645>>>                Loop
94646>>>>
94646>>>            End
94646>>>>
94646>>>        End
94646>>>>
94646>>>
94646>>>        Function_Return bOK
94647>>>    End_Function
94648>>>
94648>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
94650>>>        Boolean bOK
94650>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
94651>>>        Function_Return bOK
94652>>>    End_Function
94653>>>
94653>>>    Function IsMertechDriver String sDriverID Returns Boolean
94655>>>        Boolean bOK
94655>>>        Move False to bOK
94656>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
94657>>>        Function_Return bOK
94658>>>    End_Function
94659>>>
94659>>>    Function IsMSSQLDriver Returns Boolean
94661>>>        Integer iDriverIndex
94661>>>
94661>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
94662>>>
94662>>>        Function_Return (iDriverIndex <> 0)
94663>>>    End_Function
94664>>>
94664>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
94664>>>    // attempt to load the driver.
94664>>>    // Returns true if the passed driver is SQL based.
94664>>>    Function IsSQLDriver String sDriverID Returns Boolean
94666>>>        Boolean bOK
94666>>>
94666>>>        Get IsDAWSQLDriver sDriverID to bOK
94667>>>
94667>>>        If (bOK = False) Begin
94669>>>            Get IsMertechDriver sDriverID to bOK
94670>>>        End
94670>>>>
94670>>>
94670>>>        Function_Return bOK
94671>>>    End_Function
94672>>>
94672>>>    // *** Error Handler ***
94672>>>    //
94672>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
94672>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
94672>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
94674>>>        Integer iSize iErrorMode
94674>>>        tSqlErrorArray aSqlErrorArray
94674>>>        tSqlErrorArray aSqlErrorArray
94674>>>
94674>>>        If (pbProcessingError(Self)) Begin
94676>>>            Procedure_Return
94677>>>        End
94677>>>>
94677>>>
94677>>>        Get Error_Report_Mode to iErrorMode
94678>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
94680>>>            Procedure_Return
94681>>>        End
94681>>>>
94681>>>
94681>>>        Set pbProcessingError to True
94682>>>        Set pbSqlError to True
94683>>>        Get paSqlErrorArray      to aSqlErrorArray
94684>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
94685>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
94686>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
94687>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
94688>>>        Set paSqlErrorArray      to aSqlErrorArray
94689>>>        Set pbProcessingError to False
94690>>>    End_Procedure
94691>>>
94691>>>    // *** Miscellanous Helper Functions ***
94691>>>    //
94691>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
94691>>>    // returns the table name only; stripped of any path or filename extension.
94691>>>    Function _TableNameOnly String sName Returns String
94693>>>        String sPath sExt
94693>>>
94693>>>        Get ParseFolderName sName to sPath
94694>>>        If (sPath <> "") Begin
94696>>>            Move (Replace(sPath, sName, "")) to sName
94697>>>        End
94697>>>>
94697>>>        Get ParseFileExtension sName to sExt
94698>>>        If (sExt <> "") Begin
94700>>>            Move (Replace(("." + sExt), sName, "")) to sName
94701>>>        End
94701>>>>
94701>>>
94701>>>        Function_Return sName
94702>>>    End_Function
94703>>>
94703>>>    // Removes any prefix to a table name.
94703>>>    // Example mssqldrv:mytable returns mytable
94703>>>    //         dbo.mytable returns mytable
94703>>>    Function _TableNoPrefix String sName Returns String
94705>>>        Integer iPos
94705>>>
94705>>>        Move (Pos(":", sName)) to iPos
94706>>>        If (iPos <> 0) Begin
94708>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
94709>>>        End
94709>>>>
94709>>>        Move (Pos(".", sName)) to iPos
94710>>>        If (iPos <> 0) Begin
94712>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
94713>>>        End
94713>>>>
94713>>>
94713>>>        Function_Return sName
94714>>>    End_Function
94715>>>
94715>>>    // Returns the first datapath found in the psDataPath property.
94715>>>    // The returned path always ends with a "\"
94715>>>    Function psDataPathFirstPart Returns String
94717>>>        String sDataPath
94717>>>        Integer iCount
94717>>>
94717>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
94718>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
94719>>>        If (iCount > 1) Begin
94721>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
94722>>>        End
94722>>>>
94722>>>        If (sDataPath <> "") Begin
94724>>>            Get vFolderFormat sDataPath to sDataPath
94725>>>        End
94725>>>>
94725>>>
94725>>>        Function_Return sDataPath
94726>>>    End_Function
94727>>>
94727>>>    Function psLogTextFileWithPath Returns String
94729>>>        String sFileName
94729>>>        Handle hoLogFile
94729>>>        Get phoLogFile to hoLogFile
94730>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
94731>>>        Function_Return sFileName
94732>>>    End_Function
94733>>>
94733>>>    // *** Property Messages ***
94733>>>    //
94733>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
94733>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
94733>>>    //
94733>>>
94733>>>    Function pSQLConnection Returns tSQLConnection
94735>>>        tSQLConnection SQLConnection
94735>>>        tSQLConnection SQLConnection
94735>>>        If (ghoSQLConnectionHandler = 0) Begin
94737>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
94737>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94738>>>>
94738>>>            Function_Return
94739>>>        End
94739>>>>
94739>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94740>>>        Function_Return SQLConnection
94741>>>    End_Function
94742>>>
94742>>>    // * Dummy function for the Studio's Code Explorer *
94742>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
94744>>>        Function_Return False
94745>>>    End_Function
94746>>>
94746>>>    Procedure Set psServer String sValue
94748>>>        If (ghoSQLConnectionHandler = 0) Begin
94750>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
94750>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94751>>>>
94751>>>            Procedure_Return
94752>>>        End
94752>>>>
94752>>>        Set psServer of ghoSQLConnectionHandler to sValue
94753>>>    End_Procedure
94754>>>
94754>>>    Function psServer Returns String
94756>>>        String sValue
94756>>>        If (ghoSQLConnectionHandler = 0) Begin
94758>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94759>>>>
94759>>>            Function_Return
94760>>>        End
94760>>>>
94760>>>        Get psServer of ghoSQLConnectionHandler to sValue
94761>>>        Function_Return sValue
94762>>>    End_Function
94763>>>
94763>>>    Procedure Set psDatabase String sValue
94765>>>        If (ghoSQLConnectionHandler = 0) Begin
94767>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94768>>>>
94768>>>            Procedure_Return
94769>>>        End
94769>>>>
94769>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
94770>>>    End_Procedure
94771>>>
94771>>>    Function psDatabase Returns String
94773>>>        String sValue
94773>>>        If (ghoSQLConnectionHandler = 0) Begin
94775>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94776>>>>
94776>>>            Function_Return
94777>>>        End
94777>>>>
94777>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
94778>>>        Function_Return sValue
94779>>>    End_Function
94780>>>
94780>>>    Procedure Set psUserID String sValue
94782>>>        If (ghoSQLConnectionHandler = 0) Begin
94784>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94785>>>>
94785>>>            Procedure_Return
94786>>>        End
94786>>>>
94786>>>        Set psUserID of ghoSQLConnectionHandler to sValue
94787>>>    End_Procedure
94788>>>
94788>>>    Function psUserID Returns String
94790>>>        String sValue
94790>>>        If (ghoSQLConnectionHandler = 0) Begin
94792>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94793>>>>
94793>>>            Function_Return
94794>>>        End
94794>>>>
94794>>>        Get psUserID of ghoSQLConnectionHandler to sValue
94795>>>        Function_Return sValue
94796>>>    End_Function
94797>>>
94797>>>    Procedure Set psPassword String sValue
94799>>>        If (ghoSQLConnectionHandler = 0) Begin
94801>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94802>>>>
94802>>>            Procedure_Return
94803>>>        End
94803>>>>
94803>>>        Set psPassword of ghoSQLConnectionHandler to sValue
94804>>>    End_Procedure
94805>>>
94805>>>    Function psPassword Returns String
94807>>>        String sValue
94807>>>        If (ghoSQLConnectionHandler = 0) Begin
94809>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94810>>>>
94810>>>            Function_Return
94811>>>        End
94811>>>>
94811>>>        Get psPassword of ghoSQLConnectionHandler to sValue
94812>>>        Function_Return sValue
94813>>>    End_Function
94814>>>
94814>>>    Procedure Set pbTrusted Boolean bValue
94816>>>        If (ghoSQLConnectionHandler = 0) Begin
94818>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94819>>>>
94819>>>            Procedure_Return
94820>>>        End
94820>>>>
94820>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
94821>>>    End_Procedure
94822>>>
94822>>>    Function pbTrusted Returns Boolean
94824>>>        Boolean bValue
94824>>>        If (ghoSQLConnectionHandler = 0) Begin
94826>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94827>>>>
94827>>>            Function_Return
94828>>>        End
94828>>>>
94828>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
94829>>>        Function_Return bValue
94830>>>    End_Function
94831>>>
94831>>>    Procedure Set pbSilentLogin Boolean bValue
94833>>>        If (ghoSQLConnectionHandler = 0) Begin
94835>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94836>>>>
94836>>>            Procedure_Return
94837>>>        End
94837>>>>
94837>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
94838>>>    End_Procedure
94839>>>
94839>>>    Function pbSilentLogin Returns Boolean
94841>>>        Boolean bValue
94841>>>        If (ghoSQLConnectionHandler = 0) Begin
94843>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94844>>>>
94844>>>            Function_Return
94845>>>        End
94845>>>>
94845>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
94846>>>        Function_Return bValue
94847>>>    End_Function
94848>>>
94848>>>    Procedure Set psConnectionID String sValue
94850>>>        If (ghoSQLConnectionHandler = 0) Begin
94852>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94853>>>>
94853>>>            Procedure_Return
94854>>>        End
94854>>>>
94854>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
94855>>>    End_Procedure
94856>>>
94856>>>    Function psConnectionID Returns String
94858>>>        String sValue
94858>>>        If (ghoSQLConnectionHandler = 0) Begin
94860>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94861>>>>
94861>>>            Function_Return
94862>>>        End
94862>>>>
94862>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
94863>>>        Function_Return sValue
94864>>>    End_Function
94865>>>
94865>>>    Procedure Set psConnectionString String sValue
94867>>>        If (ghoSQLConnectionHandler = 0) Begin
94869>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94870>>>>
94870>>>            Procedure_Return
94871>>>        End
94871>>>>
94871>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
94872>>>    End_Procedure
94873>>>
94873>>>    Function psConnectionString Returns String
94875>>>        String sValue
94875>>>        If (ghoSQLConnectionHandler = 0) Begin
94877>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94878>>>>
94878>>>            Function_Return
94879>>>        End
94879>>>>
94879>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
94880>>>        Function_Return sValue
94881>>>    End_Function
94882>>>
94882>>>    // The normal connection string looks something like this;
94882>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
94882>>>    // ...and the full connection string looks like this;
94882>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
94882>>>    Function psFullConnectionString Returns String
94884>>>        String sConnectionID sConnectionString
94884>>>        If (ghoSQLConnectionHandler = 0) Begin
94886>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94887>>>>
94887>>>            Function_Return
94888>>>        End
94888>>>>
94888>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
94889>>>        Move (Trim(sConnectionID)) to sConnectionID
94890>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
94891>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
94892>>>    End_Function
94893>>>
94893>>>    Function piConnectionOptions Returns Integer
94895>>>        Integer iValue
94895>>>        If (ghoSQLConnectionHandler = 0) Begin
94897>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94898>>>>
94898>>>            Function_Return
94899>>>        End
94899>>>>
94899>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
94900>>>        Function_Return iValue
94901>>>    End_Function
94902>>>
94902>>>    Procedure Set psSchema String sValue
94904>>>        tSQLConnection SQLConnection
94904>>>        tSQLConnection SQLConnection
94904>>>        If (ghoSQLConnectionHandler = 0) Begin
94906>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94907>>>>
94907>>>            Procedure_Return
94908>>>        End
94908>>>>
94908>>>        Set psSchema of ghoSQLConnectionHandler to sValue
94909>>>    End_Procedure
94910>>>
94910>>>    Function psSchema Returns String
94912>>>        String sRetval
94912>>>        If (ghoSQLConnectionHandler = 0) Begin
94914>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94915>>>>
94915>>>            Function_Return
94916>>>        End
94916>>>>
94916>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
94917>>>        Function_Return sRetval
94918>>>    End_Function
94919>>>
94919>>>    Procedure Set psBaseTableSpace String sValue
94921>>>        If (ghoSQLConnectionHandler = 0) Begin
94923>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94924>>>>
94924>>>            Procedure_Return
94925>>>        End
94925>>>>
94925>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
94926>>>    End_Procedure
94927>>>
94927>>>    Function psBaseTableSpace Returns String
94929>>>        String sRetval
94929>>>        If (ghoSQLConnectionHandler = 0) Begin
94931>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94932>>>>
94932>>>            Function_Return
94933>>>        End
94933>>>>
94933>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
94934>>>        Function_Return sRetval
94935>>>    End_Function
94936>>>
94936>>>    Procedure Set psLongTableSpace String sValue
94938>>>        If (ghoSQLConnectionHandler = 0) Begin
94940>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94941>>>>
94941>>>            Procedure_Return
94942>>>        End
94942>>>>
94942>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
94943>>>    End_Procedure
94944>>>
94944>>>    Function psLongTableSpace Returns String
94946>>>        String sRetval
94946>>>        If (ghoSQLConnectionHandler = 0) Begin
94948>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94949>>>>
94949>>>            Function_Return
94950>>>        End
94950>>>>
94950>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
94951>>>        Function_Return sRetval
94952>>>    End_Function
94953>>>
94953>>>    Procedure Set psIndexTableSpace String sValue
94955>>>        If (ghoSQLConnectionHandler = 0) Begin
94957>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94958>>>>
94958>>>            Procedure_Return
94959>>>        End
94959>>>>
94959>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
94960>>>    End_Procedure
94961>>>
94961>>>    Function psIndexTableSpace Returns String
94963>>>        String sRetval
94963>>>        If (ghoSQLConnectionHandler = 0) Begin
94965>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94966>>>>
94966>>>            Function_Return
94967>>>        End
94967>>>>
94967>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
94968>>>        Function_Return sRetval
94969>>>    End_Function
94970>>>
94970>>>    Procedure Set pbUseConnectionID Boolean bState
94972>>>        If (ghoSQLConnectionHandler = 0) Begin
94974>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94975>>>>
94975>>>            Procedure_Return
94976>>>        End
94976>>>>
94976>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
94977>>>    End_Procedure
94978>>>
94978>>>    Function pbUseConnectionID Returns Boolean
94980>>>        Boolean bState
94980>>>        If (ghoSQLConnectionHandler = 0) Begin
94982>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94983>>>>
94983>>>            Function_Return
94984>>>        End
94984>>>>
94984>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
94985>>>        Function_Return bState
94986>>>    End_Function
94987>>>
94987>>>    Procedure Set pbToANSI Boolean bState
94989>>>        If (ghoSQLConnectionHandler = 0) Begin
94991>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
94992>>>>
94992>>>            Procedure_Return
94993>>>        End
94993>>>>
94993>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
94994>>>    End_Procedure
94995>>>
94995>>>    Function pbToANSI Returns Boolean
94997>>>        Boolean bState
94997>>>        If (ghoSQLConnectionHandler = 0) Begin
94999>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95000>>>>
95000>>>            Function_Return
95001>>>        End
95001>>>>
95001>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
95002>>>        Function_Return bState
95003>>>    End_Function
95004>>>
95004>>>    Procedure Set pbRecnum Boolean bState
95006>>>        If (ghoSQLConnectionHandler = 0) Begin
95008>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95009>>>>
95009>>>            Procedure_Return
95010>>>        End
95010>>>>
95010>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
95011>>>    End_Procedure
95012>>>
95012>>>    Function pbRecnum Returns Boolean
95014>>>        Boolean bState
95014>>>        If (ghoSQLConnectionHandler = 0) Begin
95016>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95017>>>>
95017>>>            Function_Return
95018>>>        End
95018>>>>
95018>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
95019>>>        Function_Return bState
95020>>>    End_Function
95021>>>
95021>>>    Procedure Set pbCopyData Boolean bState
95023>>>        If (ghoSQLConnectionHandler = 0) Begin
95025>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95026>>>>
95026>>>            Procedure_Return
95027>>>        End
95027>>>>
95027>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
95028>>>    End_Procedure
95029>>>
95029>>>    Function pbCopyData Returns Boolean
95031>>>        Boolean bState
95031>>>        If (ghoSQLConnectionHandler = 0) Begin
95033>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95034>>>>
95034>>>            Function_Return
95035>>>        End
95035>>>>
95035>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
95036>>>        Function_Return bState
95037>>>    End_Function
95038>>>
95038>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
95040>>>        If (ghoSQLConnectionHandler = 0) Begin
95042>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95043>>>>
95043>>>            Procedure_Return
95044>>>        End
95044>>>>
95044>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
95045>>>    End_Procedure
95046>>>
95046>>>    Function pbApiTableUpdateAuto Returns Boolean
95048>>>        Boolean bState
95048>>>        If (ghoSQLConnectionHandler = 0) Begin
95050>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95051>>>>
95051>>>            Function_Return
95052>>>        End
95052>>>>
95052>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
95053>>>        Function_Return bState
95054>>>    End_Function
95055>>>
95055>>>    Procedure Set pbCompareDate_DateTime Boolean bState
95057>>>        If (ghoSQLConnectionHandler = 0) Begin
95059>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95060>>>>
95060>>>            Procedure_Return
95061>>>        End
95061>>>>
95061>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
95062>>>    End_Procedure
95063>>>
95063>>>    Function pbCompareDate_DateTime Returns Boolean
95065>>>        Boolean bState
95065>>>        If (ghoSQLConnectionHandler = 0) Begin
95067>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95068>>>>
95068>>>            Function_Return
95069>>>        End
95069>>>>
95069>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
95070>>>        Function_Return bState
95071>>>    End_Function
95072>>>
95072>>>    Procedure Set pbCompareIndexAscending Boolean bState
95074>>>        If (ghoSQLConnectionHandler = 0) Begin
95076>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95077>>>>
95077>>>            Procedure_Return
95078>>>        End
95078>>>>
95078>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
95079>>>    End_Procedure
95080>>>
95080>>>    Function pbCompareIndexAscending Returns Boolean
95082>>>        Boolean bState
95082>>>        If (ghoSQLConnectionHandler = 0) Begin
95084>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95085>>>>
95085>>>            Function_Return
95086>>>        End
95086>>>>
95086>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
95087>>>        Function_Return bState
95088>>>    End_Function
95089>>>
95089>>>    Procedure Set pbCompareIndexUppercase Boolean bState
95091>>>        If (ghoSQLConnectionHandler = 0) Begin
95093>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95094>>>>
95094>>>            Procedure_Return
95095>>>        End
95095>>>>
95095>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
95096>>>    End_Procedure
95097>>>
95097>>>    Function pbCompareIndexUppercase Returns Boolean
95099>>>        Boolean bState
95099>>>        If (ghoSQLConnectionHandler = 0) Begin
95101>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95102>>>>
95102>>>            Function_Return
95103>>>        End
95103>>>>
95103>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
95104>>>        Function_Return bState
95105>>>    End_Function
95106>>>
95106>>>    Procedure Set psDriverDefaultValueASCII String sValue
95108>>>        If (ghoSQLConnectionHandler = 0) Begin
95110>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95111>>>>
95111>>>            Procedure_Return
95112>>>        End
95112>>>>
95112>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
95113>>>    End_Procedure
95114>>>
95114>>>    Function psDriverDefaultValueASCII Returns String
95116>>>        String sRetval
95116>>>        If (ghoSQLConnectionHandler = 0) Begin
95118>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95119>>>>
95119>>>            Function_Return
95120>>>        End
95120>>>>
95120>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
95121>>>        Function_Return sRetval
95122>>>    End_Function
95123>>>
95123>>>    Procedure Set psDriverDefaultValueBinary String sValue
95125>>>        If (ghoSQLConnectionHandler = 0) Begin
95127>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95128>>>>
95128>>>            Procedure_Return
95129>>>        End
95129>>>>
95129>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
95130>>>    End_Procedure
95131>>>
95131>>>    Function psDriverDefaultValueBinary Returns String
95133>>>        String sRetval
95133>>>        If (ghoSQLConnectionHandler = 0) Begin
95135>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95136>>>>
95136>>>            Function_Return
95137>>>        End
95137>>>>
95137>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
95138>>>        Function_Return sRetval
95139>>>    End_Function
95140>>>
95140>>>    Procedure Set psDriverDefaultValueDate String sValue
95142>>>        If (ghoSQLConnectionHandler = 0) Begin
95144>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95145>>>>
95145>>>            Procedure_Return
95146>>>        End
95146>>>>
95146>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
95147>>>    End_Procedure
95148>>>
95148>>>    Function psDriverDefaultValueDate Returns String
95150>>>        String sRetval
95150>>>        If (ghoSQLConnectionHandler = 0) Begin
95152>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95153>>>>
95153>>>            Function_Return
95154>>>        End
95154>>>>
95154>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
95155>>>        Function_Return sRetval
95156>>>    End_Function
95157>>>
95157>>>    Procedure Set psDriverDefaultValueDateTime String sValue
95159>>>        If (ghoSQLConnectionHandler = 0) Begin
95161>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95162>>>>
95162>>>            Procedure_Return
95163>>>        End
95163>>>>
95163>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
95164>>>    End_Procedure
95165>>>
95165>>>    Function psDriverDefaultValueDateTime Returns String
95167>>>        String sRetval
95167>>>        If (ghoSQLConnectionHandler = 0) Begin
95169>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95170>>>>
95170>>>            Function_Return
95171>>>        End
95171>>>>
95171>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
95172>>>        Function_Return sRetval
95173>>>    End_Function
95174>>>
95174>>>    Procedure Set psDriverDefaultValueNumeric String sValue
95176>>>        If (ghoSQLConnectionHandler = 0) Begin
95178>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95179>>>>
95179>>>            Procedure_Return
95180>>>        End
95180>>>>
95180>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
95181>>>    End_Procedure
95182>>>
95182>>>    Function psDriverDefaultValueNumeric Returns String
95184>>>        String sRetval
95184>>>        If (ghoSQLConnectionHandler = 0) Begin
95186>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95187>>>>
95187>>>            Function_Return
95188>>>        End
95188>>>>
95188>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
95189>>>        Function_Return sRetval
95190>>>    End_Function
95191>>>
95191>>>    Procedure Set psDriverDefaultValueText String sValue
95193>>>        If (ghoSQLConnectionHandler = 0) Begin
95195>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95196>>>>
95196>>>            Procedure_Return
95197>>>        End
95197>>>>
95197>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
95198>>>    End_Procedure
95199>>>
95199>>>    Function psDriverDefaultValueText Returns String
95201>>>        String sRetval
95201>>>        If (ghoSQLConnectionHandler = 0) Begin
95203>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95204>>>>
95204>>>            Function_Return
95205>>>        End
95205>>>>
95205>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
95206>>>        Function_Return sRetval
95207>>>    End_Function
95208>>>
95208>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
95210>>>        If (ghoSQLConnectionHandler = 0) Begin
95212>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95213>>>>
95213>>>            Procedure_Return
95214>>>        End
95214>>>>
95214>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
95215>>>    End_Procedure
95216>>>
95216>>>    Function pbDriverDefaultNullableASCII Returns Boolean
95218>>>        Boolean bState
95218>>>        If (ghoSQLConnectionHandler = 0) Begin
95220>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95221>>>>
95221>>>            Function_Return
95222>>>        End
95222>>>>
95222>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
95223>>>        Function_Return bState
95224>>>    End_Function
95225>>>
95225>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
95227>>>        If (ghoSQLConnectionHandler = 0) Begin
95229>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95230>>>>
95230>>>            Procedure_Return
95231>>>        End
95231>>>>
95231>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
95232>>>    End_Procedure
95233>>>
95233>>>    Function pbDriverDefaultNullableBinary Returns Boolean
95235>>>        Boolean bState
95235>>>        If (ghoSQLConnectionHandler = 0) Begin
95237>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95238>>>>
95238>>>            Function_Return
95239>>>        End
95239>>>>
95239>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
95240>>>        Function_Return bState
95241>>>    End_Function
95242>>>
95242>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
95244>>>        If (ghoSQLConnectionHandler = 0) Begin
95246>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95247>>>>
95247>>>            Procedure_Return
95248>>>        End
95248>>>>
95248>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
95249>>>    End_Procedure
95250>>>
95250>>>    Function pbDriverDefaultNullableDate Returns Boolean
95252>>>        Boolean bState
95252>>>        If (ghoSQLConnectionHandler = 0) Begin
95254>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95255>>>>
95255>>>            Function_Return
95256>>>        End
95256>>>>
95256>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
95257>>>        Function_Return bState
95258>>>    End_Function
95259>>>
95259>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
95261>>>        If (ghoSQLConnectionHandler = 0) Begin
95263>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95264>>>>
95264>>>            Procedure_Return
95265>>>        End
95265>>>>
95265>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
95266>>>    End_Procedure
95267>>>
95267>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
95269>>>        Boolean bState
95269>>>        If (ghoSQLConnectionHandler = 0) Begin
95271>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95272>>>>
95272>>>            Function_Return
95273>>>        End
95273>>>>
95273>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
95274>>>        Function_Return bState
95275>>>    End_Function
95276>>>
95276>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
95278>>>        If (ghoSQLConnectionHandler = 0) Begin
95280>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95281>>>>
95281>>>            Procedure_Return
95282>>>        End
95282>>>>
95282>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
95283>>>    End_Procedure
95284>>>
95284>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
95286>>>        Boolean bState
95286>>>        If (ghoSQLConnectionHandler = 0) Begin
95288>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95289>>>>
95289>>>            Function_Return
95290>>>        End
95290>>>>
95290>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
95291>>>        Function_Return bState
95292>>>    End_Function
95293>>>
95293>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
95295>>>        If (ghoSQLConnectionHandler = 0) Begin
95297>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95298>>>>
95298>>>            Procedure_Return
95299>>>        End
95299>>>>
95299>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
95300>>>    End_Procedure
95301>>>
95301>>>    Function pbDriverDefaultNullableText Returns Boolean
95303>>>        Boolean bState
95303>>>        If (ghoSQLConnectionHandler = 0) Begin
95305>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95306>>>>
95306>>>            Function_Return
95307>>>        End
95307>>>>
95307>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
95308>>>        Function_Return bState
95309>>>    End_Function
95310>>>
95310>>>    // Note: If the psDriverID + other connection properties are to be changed,
95310>>>    //       the psDriverID *must* be the first property that gets changed!
95310>>>    //       Otherwise errors might be raised by the driver when e.g. the format
95310>>>    //       for a connection string has the wrong format for that driver.
95310>>>    Procedure Set psDriverID String sValue
95312>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
95313>>>        Delegate Set psDriverID to sValue
95315>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
95316>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
95317>>>    End_Procedure
95318>>>
95318>>>    Function psDriverID Returns String
95320>>>        String sDriverID
95320>>>
95320>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
95321>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
95321>>>        Delegate Get psDriverID to sDriverID
95323>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
95324>>>        Move False to Err
95325>>>
95325>>>        // ...and in case it didn't use property of this class. Then the library is
95325>>>        // probably used as "utilites" from a special made program and
95325>>>        // the ghoSQLConnectionHandler must have been setup
95325>>>        If (sDriverID = "") Begin
95327>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
95328>>>        End
95328>>>>
95328>>>        Function_Return sDriverID
95329>>>    End_Function
95330>>>
95330>>>    Procedure Set piDbType Integer iValue
95332>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
95333>>>        Delegate Set piDbType to iValue
95335>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
95336>>>        Set piDbType of ghoSQLConnectionHandler to iValue
95337>>>    End_Procedure
95338>>>
95338>>>    Function piDbType Returns Integer
95340>>>        Integer iRetval
95340>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
95341>>>        Function_Return iRetval
95342>>>    End_Function
95343>>>
95343>>>    Function phoLogFile Returns Handle
95345>>>        Handle hoLogFile   
95345>>>        Boolean bErr
95345>>>        
95345>>>        Move Err to bErr
95346>>>        Move 0 to hoLogFile
95347>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
95348>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
95349>>>        Delegate Get phoLogFile to hoLogFile
95351>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
95352>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95353>>>        Move bErr to Err
95354>>>        
95354>>>        Function_Return hoLogFile
95355>>>    End_Function
95356>>>
95356>>>    Function pnCurrentVersionUpdate Returns Number
95358>>>        Number nCurrentVersionUpdate
95358>>>
95358>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95359>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
95361>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95362>>>
95362>>>        Function_Return nCurrentVersionUpdate
95363>>>    End_Function
95364>>>
95364>>>    Procedure LogError String sText Boolean bError
95366>>>        Handle hoLogFile
95366>>>        Number nCurrentVersionUpdate
95366>>>
95366>>>        Get phoLogFile to hoLogFile
95367>>>        If (hoLogFile = 0) Begin
95369>>>            Procedure_Return
95370>>>        End
95370>>>>
95370>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
95371>>>
95371>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95372>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
95373>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95374>>>    End_Procedure
95375>>>
95375>>>    Function pbContinueOnError Returns Boolean
95377>>>        Boolean bContinueOnError
95377>>>        If (ghoDbUpdateHandler > 0) Begin
95379>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
95380>>>        End
95380>>>>
95380>>>        Function_Return bContinueOnError
95381>>>    End_Function
95382>>>
95382>>>    // Latin1_General_CI_AS = General Insensitive collation
95382>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
95382>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
95382>>>    // Good read about which collation to select:
95382>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
95382>>>    Procedure Set psCollation String sCollation
95384>>>        Set private.psCollation to sCollation
95385>>>        If (ghoDbUpdateHandler > 0) Begin
95387>>>            Set psCollation of ghoDbUpdateHandler to sCollation
95388>>>        End
95388>>>>
95388>>>    End_Procedure
95389>>>
95389>>>    Function psCollation Returns String
95391>>>        String sCollation
95391>>>        If (ghoDbUpdateHandler > 0) Begin
95393>>>            Get psCollation of ghoDbUpdateHandler to sCollation
95394>>>        End   
95394>>>>
95394>>>        Else Begin
95395>>>            Get private.psCollation to sCollation
95396>>>        End
95396>>>>
95396>>>        Function_Return sCollation
95397>>>    End_Function
95398>>>
95398>>>
95398>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer
95400>>>        Integer iMax iPos
95400>>>        String sName
95400>>>
95400>>>        Move (Lowercase(sField)) to sField
95401>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
95404>>>        for iPos from 0 to iMax
95410>>>>
95410>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
95413>>>            Move (Lowercase(sName)) to sName
95414>>>            If (sName = sField) Begin
95416>>>                Function_Return iPos
95417>>>            End
95417>>>>
95417>>>        Loop
95418>>>>
95418>>>        Function_Return -1
95419>>>    End_Function
95420>>>
95420>>>
95420>>>    // * Dummy function for the Studio's Code Explorer *
95420>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
95422>>>        Function_Return False
95423>>>    End_Function
95424>>>
95424>>>    // *** Helper functions with compiled sql script code ***
95424>>>    //
95424>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
95424>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
95424>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
95424>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
95424>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
95424>>>    //   ALTER TABLE MyTable
95424>>>    //       REBUILD
95424>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
95426>>>        Boolean bOK
95426>>>
95426>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
95428>>>            Function_Return False
95429>>>        End
95429>>>>
95429>>>
95429>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
95429>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
95430>>>
95430>>>        Function_Return (bOK = True)
95431>>>    End_Function
95432>>>
95432>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
95432>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
95432>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
95432>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
95432>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
95432>>>    //   ALTER TABLE MyTable
95432>>>    //       REBUILD
95432>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
95434>>>        tSQLScriptArray SQLScriptArray
95434>>>        tSQLScriptArray SQLScriptArray
95434>>>        String sDriverID
95434>>>        Boolean bOK
95434>>>        Integer iSize iCount
95434>>>
95434>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
95436>>>            Function_Return False
95437>>>        End
95437>>>>
95437>>>
95437>>>        Get psDriverID to sDriverID
95438>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
95439>>>        If (SQLScriptArray.bError = True) Begin
95441>>>            Function_Return False
95442>>>        End
95442>>>>
95442>>>
95442>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
95443>>>        Decrement iSize
95444>>>
95444>>>        for iCount from 0 to iSize
95450>>>>
95450>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
95452>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
95453>>>            End
95453>>>>
95453>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
95455>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
95456>>>            End
95456>>>>
95456>>>        Loop
95457>>>>
95457>>>
95457>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
95458>>>
95458>>>        Function_Return (bOK = True)
95459>>>    End_Function
95460>>>
95460>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
95462>>>        tSQLScriptArray SQLScriptArray
95462>>>        tSQLScriptArray SQLScriptArray
95462>>>        String sDriverID sCollation
95462>>>        Boolean bOK
95462>>>        Integer iSize iCount
95462>>>
95462>>>        If (Trim(sDatabaseName) = "") Begin
95464>>>            Function_Return False
95465>>>        End
95465>>>>
95465>>>
95465>>>        Get psDriverID  to sDriverID
95466>>>        Get psCollation to sCollation
95467>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
95468>>>        If (SQLScriptArray.bError = True) Begin
95470>>>            Function_Return False
95471>>>        End
95471>>>>
95471>>>
95471>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
95472>>>        Decrement iSize
95473>>>
95473>>>        for iCount from 0 to iSize
95479>>>>
95479>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
95481>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
95482>>>            End
95482>>>>
95482>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
95484>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
95485>>>            End
95485>>>>
95485>>>        Loop
95486>>>>
95486>>>
95486>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
95487>>>
95487>>>        Function_Return (bOK = True)
95488>>>    End_Function
95489>>>
95489>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
95491>>>        tSQLScriptArray SQLScriptArray
95491>>>        tSQLScriptArray SQLScriptArray
95491>>>        String sDriverID sCollation
95491>>>        Boolean bOK
95491>>>        Integer iSize iCount
95491>>>
95491>>>        If (Trim(sDatabaseName) = "") Begin
95493>>>            Function_Return False
95494>>>        End
95494>>>>
95494>>>
95494>>>        Get psDriverID  to sDriverID
95495>>>        Get psCollation to sCollation
95496>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
95497>>>        If (SQLScriptArray.bError = True) Begin
95499>>>            Function_Return False
95500>>>        End
95500>>>>
95500>>>
95500>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
95501>>>        Decrement iSize
95502>>>
95502>>>        for iCount from 0 to iSize
95508>>>>
95508>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
95510>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
95511>>>            End
95511>>>>
95511>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
95513>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
95514>>>            End
95514>>>>
95514>>>        Loop
95515>>>>
95515>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
95515>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
95516>>>
95516>>>        Function_Return (bOK = True)
95517>>>    End_Function
95518>>>
95518>>>    // *** Helper functions for Mertech Drivers ***
95518>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
95518>>>    // and commands that the Studio editor knows nothing about.
95518>>>    Function _MertechDeleteTDFile String sTableName Returns Boolean
95520>>>        Integer iRetval
95520>>>        String sPath
95520>>>
95520>>>            SQL_GET_LOCAL_TD_PATH to sPath
95558>>>>
95558>>>        If (sPath = "" or sTableName = "") Begin
95560>>>            Function_Return True
95561>>>        End
95561>>>>
95561>>>
95561>>>        Get vFolderFormat sPath to sPath
95562>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
95563>>>        Function_Return (iRetval = 0)
95564>>>    End_Function
95565>>>
95565>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sTableName String sDataPath String sPhysicalFileName Returns Boolean
95567>>>        Boolean bOpen bOK
95567>>>        Move False to Err
95568>>>            Close hTable
95569>>>            Get UtilTableOpenAsIntFile hTable sTableName DF_SHARE to bOpen
95570>>>            Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT   of hTable to True
95573>>>            Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of hTable to True
95576>>>            Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT   of hTable to True
95579>>>            Get UtilDeleteCacheFile sTableName to bOK
95580>>>            CLEAR_INT_CACHE
95616>>>>
95616>>>            Move (sDataPath + sPhysicalFileName) to sTableName
95617>>>            OUTPUT_INT_FILE for hTable to sTableName
95662>>>>
95662>>>        Function_Return (Err = False)
95663>>>    End_Function
95664>>>
95664>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
95666>>>        Integer iNumItems iCount
95666>>>        String[] sReturnArray
95667>>>        String sServer
95667>>>
95667>>>        Get SQL_AVAILABLE_SQL_SERVERS to iNumItems
95668>>>        For iCount from 1 to iNumItems
95674>>>>
95674>>>            Get SQL_AVAILABLE_SQL_SERVER_NAME iCount to sServer
95675>>>            Move sServer to sReturnArray[iCount -1]
95676>>>        Loop
95677>>>>
95677>>>
95677>>>        Function_Return sReturnArray
95678>>>    End_Function
95679>>>
95679>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
95681>>>        String[] sReturnArray
95682>>>        String sServer
95682>>>
95682>>>        GET_CURRENT_SQL_SERVER to sServer
95726>>>>
95726>>>        Move sServer to sReturnArray[0]
95727>>>
95727>>>        Function_Return sReturnArray
95728>>>    End_Function
95729>>>
95729>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
95731>>>        Handle hoSQLHandler hoSQLConnect
95731>>>
95731>>>        Move 0 to hoSQLConnect
95732>>>            Get _MertechSQLManagerHandle to hoSQLHandler
95733>>>            Get SQLConnect of hoSqlHandler sDriverID sServer sUserID sPassword to hoSQLConnect
95734>>>
95734>>>        Function_Return hoSQLConnect
95735>>>    End_Function
95736>>>
95736>>>    // Returns the handle of the Mertech SQL handler.
95736>>>    // It also ensures that the correct Server & Database attributes are set both for
95736>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
95736>>>    Function _MertechSQLManagerHandle Returns Handle
95738>>>        Handle hoSQLHandler
95738>>>        String sDriverID sServer sDatabase
95738>>>
95738>>>        Move 0 to hoSQLHandler
95739>>>        Get psDriverID to sDriverID
95740>>>        Get psServer   to sServer
95741>>>        Get psDatabase to sDatabase
95742>>>        // This command is used to set the server to be used when opening tables
95742>>>        SET_CURRENT_SQL_SERVER            to sServer
95785>>>>
95785>>>        // This command is used to specify which server to use for embedded SQL statements,
95785>>>        // but it has been constructed rather studidly as only constants and not variables
95785>>>        // are allowed...
95785>>>        If (sDriverID = MDSPgSQL) Begin
95787>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
95803>>>        End
95803>>>>
95803>>>        If (sDriverID = MDSMySQL) Begin
95805>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
95821>>>        End
95821>>>>
95821>>>        If (sDriverID = ORAFLEX) Begin
95823>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
95839>>>        End
95839>>>>
95839>>>        If (sDriverID = SQLFLEX) Begin
95841>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
95857>>>        End
95857>>>>
95857>>>
95857>>>        // This command is used to specify which database is used for SQL statements only.
95857>>>        SQL_USE_DATABASE sDatabase
95895>>>>
95895>>>        SET_DATABASE_NAME to sDatabase
95933>>>>
95933>>>
95933>>>        Get phoSQLManagerMT to hoSQLHandler
95934>>>
95934>>>        Function_Return hoSQLHandler
95935>>>    End_Function
95936>>>
95936>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
95936>>>    // macro-commands <sigh!>
95936>>>    // Note: The function sets the Err flag.
95936>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bToAnsi Boolean bCopyData Returns Boolean
95938>>>
95938>>>        Move False to Err
95939>>>            SET_DATABASE_NAME to sDatabase
95977>>>>
95977>>>            If (sBaseTableSpace <> "") Begin
95979>>>                SET_DEFAULT_TABLESPACE to sBaseTableSpace
96016>>>>
96016>>>            End
96016>>>>
96016>>>            If (sIndexTableSpace <> "") Begin
96018>>>                SET_DEFAULT_INDEX_TABLESPACE to sIndexTableSpace
96055>>>>
96055>>>            End
96055>>>>
96055>>>
96055>>>            MERTECH_WARNING_MESSAGE Disabled
96088>>>>
96088>>>            CONVERT_DAT_FILE hTable DF_STRUCTEND_OPT_FORCE_INVK sRootName
96126>>>>
96126>>>            MERTECH_WARNING_MESSAGE Enabled
96159>>>>
96159>>>
96159>>>//            Move hTable to iFile
96159>>>//            Structure_Start iFile sDriverID
96159>>>//                Set_Attribute DF_FILE_OEM_TRANSLATION of iFile to (bToAnsi = True)
96159>>>//            Structure_End iFile
96159>>>
96159>>>
96159>>>        Function_Return (Err = False)
96160>>>    End_Function
96161>>>
96161>>>    Function _MertechCopyDataToSQL Handle hTable String sRootName String sDriverID Returns Boolean
96163>>>        Move False to Err
96164>>>            MERTECH_WARNING_MESSAGE Disabled
96197>>>>
96197>>>            COPY_DATA sRootName to (sDriverID + ":" + sRootName) CALLBACK (Callback(Self))
96236>>>>
96236>>>            MERTECH_WARNING_MESSAGE Enabled
96269>>>>
96269>>>        Function_Return (Err = False)
96270>>>    End_Function
96271>>>
96271>>>End_Class
96272>// Needs to be after the cSQLConnectionHandler object
96272>Object oDbUpdateFunctionLibrary is a cDbUpdateFunctionLibrary
96274>End_Object
96275>
96275>Object oToolTipController is a cToolTipController
96277>    Move Self to ghoToolTipController
96278>    Set pbBalloonStyle to False
96279>    Set piIcon to TTI_INFO
96280>    Set psTitle to "Information"
96281>    Set piMaxWidth to 400
96282>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
96283>End_Object
96284>
96284>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\oEditContextMenu.pkg)
96284>>>Use cCJStandardMenuItemClasses.pkg
96284>>>
96284>>>Object oEditContextMenu is a cCJContextMenu
96286>>>    
96286>>>    Move Self to Default_Form_Floating_Menu_ID
96287>>>    
96287>>>    Object oUndoMenuItem is a cCJUndoMenuItem
96289>>>    End_Object
96290>>>    
96290>>>    Object oCutMenuItem is a cCJCutMenuItem
96292>>>        Set pbControlBeginGroup to True
96293>>>    End_Object
96294>>>    
96294>>>    Object oCopyMenuItem is a cCJCopyMenuItem
96296>>>    End_Object
96297>>>
96297>>>    Object oPasteMenuItem is a cCJPasteMenuItem
96299>>>    End_Object
96300>>>
96300>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
96302>>>    End_Object
96303>>>
96303>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
96305>>>        Set pbControlBeginGroup to True
96306>>>    End_Object
96307>>>
96307>>>End_Object
96308>>>
96308>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\oDEOEditContextMenu17.pkg)
96308>>>Use Windows.pkg
96308>>>Use cCJStandardMenuItemClasses.pkg
96308>>>Use cCJDeoMenuItemClasses.pkg
96308>>>
96308>>>
96308>>>Object oDEOEditContextMenu17 is a cCJContextMenu
96310>>>    
96310>>>    Move Self to Default_dbFloating_Menu_ID
96311>>>    
96311>>>    Object oUndoMenuItem is a cCJUndoMenuItem
96313>>>    End_Object
96314>>>    
96314>>>    Object oCutMenuItem is a cCJCutMenuItem
96316>>>        Set pbControlBeginGroup to True
96317>>>    End_Object
96318>>>    
96318>>>    Object oCopyMenuItem is a cCJCopyMenuItem
96320>>>    End_Object
96321>>>
96321>>>    Object oPasteMenuItem is a cCJPasteMenuItem
96323>>>    End_Object
96324>>>
96324>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
96326>>>    End_Object
96327>>>
96327>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
96329>>>        Set pbControlBeginGroup to True
96330>>>    End_Object
96331>>>
96331>>>    Object oPromptMenuItem is a cCJPromptMenuItem
96333>>>        Set pbControlBeginGroup to True
96334>>>    End_Object
96335>>>
96335>>>    Object oFindNextMenu is a cCJFindNextMenuItem
96337>>>        Set pbControlBeginGroup to True
96338>>>    End_Object
96339>>>
96339>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
96341>>>    End_Object
96342>>>
96342>>>    Object oClearMenuItem is a cCJClearMenuItem
96344>>>        Set pbControlBeginGroup to True
96345>>>    End_Object
96346>>>
96346>>>    Object oClearAllMenu is a cCJClearAllMenuItem
96348>>>    End_Object
96349>>>
96349>>>    Object oSaveMenu is a cCJSaveMenuItem
96351>>>    End_Object
96352>>>    
96352>>>    Object oDeleteMenu is a cCJDeleteMenuItem
96354>>>    End_Object
96355>>>
96355>>>    Object oRememberitem is a cCJRememberFieldMenuItem
96357>>>        Set pbControlBeginGroup to True
96358>>>    End_Object
96359>>>
96359>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
96361>>>    End_Object
96362>>>
96362>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
96364>>>    End_Object
96365>>>
96365>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
96367>>>    End_Object
96368>>>
96368>>>End_Object
96369>
96369>Object oMain is a Panel
96371>    Set Label to (psProduct(ghoApplication))
96372>    Set Location to 30 17
96373>    Set Size to 190 450
96374>    Set Icon to "SQLConnections1.ico"
96375>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
96376>
96376>    Object oCommandBarSystem is a cCJCommandBarSystem
96378>        Set pbTimerUpdate to True
96379>        Set pbShowTextBelowIcons to True
96380>            Set pbAutoResizeIcons to True
96381>        Set pbLargeIcons to True
96382>
96382>        Procedure OnCreateCommandBars
96385>            Handle hoOptions
96385>            Integer iSize
96385>
96385>            Send DoChangeToolTipFormat
96386>
96386>            Get OptionsObject to hoOptions
96387>            Move 32 to iSize
96388>            Send ComSetIconSize of hoOptions False iSize iSize  // Set icon size for Toolbar buttons.
96389>            Forward Send OnCreateCommandBars
96391>        End_Procedure
96392>
96392>        Procedure DoChangeToolTipFormat
96395>            Variant vToolTip
96395>            Handle  hoObject
96395>            Integer eTheme iToolTipStyle
96395>            Boolean bIsBalloonStyleSupported
96395>
96395>            Get ComToolTipContext to vTooltip
96396>            Get Create (RefClass(cCJToolTipContext)) to hoObject
96397>            Set pvComObject of hoObject to vTooltip
96398>            Move xtpToolTipStandard to iToolTipStyle
96399>            If (iToolTipStyle = -1) Begin
96401>                Get peVisualTheme to eTheme
96402>                Set ComStyle of hoObject to eTheme
96403>            End
96403>            Else Begin
96404>                // Baloon tooltip style requires IE 5.0 or later, so check if installed.
96404>                // The ComShowTitleAndDescription also requires IE 5.0.
96404>                Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
96405>                If (bIsBalloonStyleSupported = False) Begin
96407>                    // If not supported we cannot show baloon tooltip; use standard style instead.
96407>                    If (iToolTipStyle = xtpToolTipBalloon) Begin
96409>                        Move xtpToolTipStandard to iToolTipStyle
96410>                    End
96410>                End
96410>                Set ComStyle of hoObject to iToolTipStyle
96411>                If (bIsBalloonStyleSupported = True) Begin
96413>                    Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
96414>                End
96414>            End
96414>            Set  ComShowOfficeBorder        of hoObject to True
96415>            Set  ComShowShadow              of hoObject to True
96416>            // Set the max width for a tooltip. 250 just seems to be a good
96416>            // compromise. After 250 pixels the text will wrap to the next line automatically.
96416>            Set  ComMaxTipWidth             of hoObject to 250 // In pixels
96417>            Send Destroy of hoObject
96418>            If (phoStatusBar(ghoCommandBars)) Begin
96420>                Send DoChangeToolTipFormat of (phoStatusBar(Self))
96421>            End
96421>
96421>        End_Procedure
96422>
96422>        Object oOpen_Toolbar is a cCJToolbar     
96424>
96424>            Object oOpen_MenuItem is a cCJMenuItem
96426>                Set psTooltip to "&Open"
96427>                Set psDescription to "Open connection ini-file (Ctrl+O)"
96428>                Set psImage to "ActionOpen1.ico"
96429>                Set pbActiveUpdate to True
96430>                Procedure OnExecute Variant vCommandBarControl
96433>                    Forward Send OnExecute vCommandBarControl
96435>                    Send ActivateOpenDialog of (phoMainView(ghoApplication))
96436>                End_Procedure
96437>            End_Object
96438>
96438>            Object oRefreshMenuItem is a cCJMenuItem
96440>                Set psTooltip to "&Refresh"
96441>                Set psDescription to "Refresh grid - re-read values from ini-file (Alt+R)"
96442>                Set psImage to "ActionRefresh1.ico"
96443>                Set pbActiveUpdate to True
96444>               
96444>                Procedure OnExecute Variant vCommandBarControl
96447>                    Forward Send OnExecute vCommandBarControl
96449>                    Send RefreshIniFile of (phoMainView(ghoApplication))
96450>                End_Procedure
96451>
96451>                Function IsEnabled Returns Boolean
96454>                    Boolean bSave
96454>                    Get Should_Save of (oSQLConnections_grd(phoMainView(ghoApplication))) to bSave
96455>                    Function_Return (bSave = True)
96456>                End_Function
96457>                
96457>            End_Object
96458>
96458>        End_Object
96459>
96459>        Object oEdit_Toolbar is a cCJToolbar     
96461>        
96461>            Object oAddMenuItem is a cCJMenuItem
96463>                Set psTooltip to "&Add"
96464>                Set psDescription to "Add new connection (Alt+A)"
96465>                Set psImage to "ActionAdd1.ico"
96466>                Set pbActiveUpdate to True
96467>                Procedure OnExecute Variant vCommandBarControl
96470>                    Forward Send OnExecute vCommandBarControl
96472>                    Send AddItem of (phoMainView(ghoApplication))
96473>                End_Procedure
96474>            End_Object
96475>
96475>            Object oEditMenuItem is a cCJMenuItem
96477>                Set psTooltip to "&Edit"
96478>                Set psDescription to "Edit selected connection (Alt+E)"
96479>                Set psImage to "ActionEdit1.ico"
96480>                Set pbActiveUpdate to True
96481>
96481>                Procedure OnExecute Variant vCommandBarControl
96484>                    Forward Send OnExecute vCommandBarControl
96486>                    Send EditItem of (phoMainView(ghoApplication))
96487>                End_Procedure
96488>
96488>                Function IsEnabled Returns Boolean
96491>                    Handle ho              
96491>                    Boolean bRecord
96491>                    Move (oSQLConnections_grd(phoMainView(ghoApplication))) to ho
96492>                    Send ChangeHeaderText of ho
96493>                    Get HasRecord of ho to bRecord
96494>                    Function_Return (bRecord = True)
96495>                End_Function
96496>
96496>            End_Object
96497>
96497>            Object oSaveMenuItem is a cCJMenuItem
96499>                Set psTooltip to "Save"
96500>                Set psDescription to "Save changes (Ctrl+S)"
96501>                Set psImage to "ActionSave1.ico"
96502>                Set pbActiveUpdate to True
96503>                Set peControlType to xtpControlSplitButtonPopup
96504>
96504>                Procedure OnExecute Variant vCommandBarControl
96507>                    Forward Send OnExecute vCommandBarControl
96509>                    Send SaveIniFile of (phoMainView(ghoApplication))
96510>                End_Procedure
96511>
96511>                Function IsEnabled Returns Boolean
96514>                    Boolean bSave
96514>                    Get Should_Save of (oSQLConnections_grd(phoMainView(ghoApplication))) to bSave
96515>                    Function_Return (bSave = True)
96516>                End_Function
96517>
96517>                Object oSaveAsMenuItem is a cCJMenuItem
96519>                    Set psTooltip to "Save As"
96520>                    Set psDescription to "Save configuration file as..."  
96521>                    Set psImage to "ActionSaveAs1.ico"
96522>                    
96522>                    Procedure OnExecute Variant vCommandBarControl  
96525>                        String sPath sIniFileName sFileName
96525>
96525>                        Forward Send OnExecute vCommandBarControl
96527>                        
96527>                        Get psIniFilePath of ghoSQLConnectionHandler to sPath
96528>                        Get psIniFileName of ghoSQLConnectionHandler to sIniFileName
96529>                        Get vSelectSaveFile ".int" "Please enter a file name to save to" sPath sIniFileName to sFileName
96530>                        If (sFileName <> "") Begin
96532>                            Get ParseFolderName sFileName to sPath
96533>                            Get ParseFileName   sFileName to sIniFileName
96534>                            Set psIniFilePath of ghoSQLConnectionHandler to sPath
96535>                            Set psIniFileName of ghoSQLConnectionHandler to sIniFileName
96536>                            Send SaveIniFile  of (phoMainView(ghoApplication))
96537>                        End
96537>                    End_Procedure
96538>
96538>                End_Object   
96539>                
96539>            End_Object
96540>
96540>            Object oClearMenuItem is a cCJMenuItem 
96542>                Set psTooltip to "Clear All"
96543>                Set psDescription to "Clear ini-file (Ctrl+F5)"
96544>                Set psImage to "ActionClear1.ico"
96545>                Set pbActiveUpdate to True
96546>                
96546>                Procedure OnExecute Variant vCommandBarControl
96549>                    Forward Send OnExecute vCommandBarControl   
96551>                    Send ClearIniFile of (phoMainView(ghoApplication))
96552>                End_Procedure   
96553>                
96553>                Function IsEnabled Returns Boolean
96556>                    Handle ho              
96556>                    Boolean bRecord
96556>                    Move (oSQLConnections_grd(phoMainView(ghoApplication))) to ho
96557>                    Send ChangeHeaderText of ho
96558>                    Get HasRecord of ho to bRecord
96559>                    Function_Return (bRecord = True)
96560>                End_Function
96561>
96561>            End_Object
96562>    
96562>            Object oDeleteMenuItem is a cCJMenuItem
96564>                Set psTooltip to "Delete"
96565>                Set psDescription to "Delete selected connection (Alt+D)"
96566>                Set psImage to "ActionDelete1.ico"
96567>                Set pbActiveUpdate to True
96568>
96568>                Procedure OnExecute Variant vCommandBarControl
96571>                    Forward Send OnExecute vCommandBarControl
96573>                    Send DeleteItem of (phoMainView(ghoApplication))
96574>                End_Procedure   
96575>                
96575>                Function IsEnabled Returns Boolean
96578>                    Handle ho              
96578>                    Boolean bRecord
96578>                    Move (oSQLConnections_grd(phoMainView(ghoApplication))) to ho
96579>                    Send ChangeHeaderText of ho
96580>                    Get HasRecord of ho to bRecord
96581>                    Function_Return (bRecord = True)
96582>                End_Function
96583>
96583>            End_Object
96584>
96584>        End_Object      
96585>        
96585>        Object oExit_Toolbar is a cCJToolbar
96587>            Set peStretched to stStretchShared
96588>
96588>            Object oAddToStudioMenuItem is a cCJMenuItem
96590>                Set psTooltip to "Add to Studio"
96591>                Set psDescription to "Add program to the Studio's toolbar menu"
96592>                Set psImage to "ActionAddStudio1.ico"
96593>                
96593>                Procedure OnExecute Variant vCommandBarControl
96596>                    Forward Send OnExecute vCommandBarControl
96598>                    Send Popup of (oAddToStudio_dg(Client_Id(phoMainPanel(ghoApplication))))
96599>                End_Procedure
96600>            
96600>            End_Object
96601>
96601>            Object oAbout_MenuItem is a cCJMenuItem
96603>                Set psTooltip to C_$About
96604>                Set psDescription to "Info about the program..."
96605>                Set psImage to "ActionAbout1.ico"
96606>        
96606>                Procedure OnExecute Variant vCommandBarControl
96609>                    Send ChangeStatusRowText of (phoMainView(ghoApplication)) ""
96610>                    Send Activate_About of (Client_Id(phoMainPanel(ghoApplication)))
96611>                End_Procedure
96612>        
96612>            End_Object     
96613>            
96613>            Object oHelpMenuItem is a cCJHelpMenuItem
96615>                Set peControlType to xtpControlSplitButtonPopup
96616>                Set psToolTip to C_$Help
96617>                Set psDescription to "Local HTML Help"
96618>                Set psImage to "ActionHelp1.ico"
96619>
96619>                Procedure OnExecute Variant vCommandBarControl
96622>                    Send ShowProgramHelp
96623>                End_Procedure
96624>
96624>                Object oHelpMenuItemLocal is a cCJMenuItem
96626>                    Set psToolTip to C_$Help
96627>                    Set psCaption to "Local HTML Help"
96628>                    Set psDescription to "Local HTML Help"
96629>                    Set psImage to "ActionHelp1.ico"
96630>                    Procedure OnExecute Variant vCommandBarControl
96633>                        Send ShowProgramHelp
96634>                    End_Procedure
96635>                End_Object
96636>
96636>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
96638>                    Set psToolTip to C_$Help
96639>                    Set psCaption to "Online HTML Help"
96640>                    Set psDescription to "Online HTML Help"
96641>                    Set psImage to "ActionHelpInternet1.ico"
96642>                    Procedure OnExecute Variant vCommandBarControl
96645>                        Runprogram Shell Background "https://www.rdctools.com/HTMLHelpDUF/DUFSQLConnectionsTool.html"
96646>                    End_Procedure
96647>                End_Object
96648>
96648>                Object oCheckforUpdatesMenuItem is a cCJMenuItem
96650>                    Set psToolTip to "Updates"
96651>                    Set psCaption to "Check for Updates..."
96652>                    Set psDescription to "Check for Updates..."
96653>                    Set psImage to "InternetUpdate1.ico"
96654>                    Set pbControlBeginGroup to True
96655>                    
96655>                    Procedure OnExecute Variant vCommandBarControl
96658>                        String sPath sUpdateProgram sParam
96658>                        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
96659>                        Get vFolderFormat sPath to sPath
96660>                        Move "updater.exe" to sUpdateProgram
96661>                        Move "/checknow"   to sParam
96662>                        Runprogram Shell Wait ('"' + sPath + sUpdateProgram + '"') sParam
96663>                    End_Procedure
96664>                
96664>                End_Object
96665>                
96665>            End_Object
96666>
96666>            Object oExit_MenuItem is a cCJExitMenuItem
96668>                Set psToolTip to "Exit"
96669>                Set psDescription to "Exit application (Alt+F4)"   
96670>                Set psImage to "ActionExit1.ico"
96671>            End_Object
96672>
96672>        End_Object
96673>        
96673>        Object oStatusBar is a cCJStatusBar
96675>
96675>            Object oStatusPane1 is a cCJStatusBarPane
96677>                Set pbStyleStretch to True
96678>            End_Object
96679>
96679>            Object oStatusPane2 is a cCJStatusBarPane
96681>                Set phoViewPane to Self
96682>                Set pbStyleStretch to True
96683>                Set piTextColor to clRed
96684>            End_Object
96685>
96685>        End_Object
96686>
96686>    End_Object
96687>
96687>    Object oClientArea is a ClientArea
96689>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\StdAbout.pkg)
96689>>>//************************************************************************
96689>>>// Confidential Trade Secret.
96689>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
96689>>>// as an unpublished work.  All rights reserved.
96689>>>// DataFlex is a registered trademark of Data Access Corporation.
96689>>>//
96689>>>//************************************************************************
96689>>>//************************************************************************
96689>>>//
96689>>>// $File name  : StdAbout.pkg
96689>>>// $File title : Standard about object package for VDF
96689>>>// Notice      :
96689>>>// $Author(s)  : John Tuohy
96689>>>//
96689>>>// $Rev History
96689>>>//
96689>>>// JT 06/27/97   File created
96689>>>//************************************************************************
96689>>>
96689>>>// This provides a quick and simple way to create an about package for a program.
96689>>>// You need to create a message inside you client area called Activate_About.
96689>>>// Within this message you should send the message DoAbout passing needed
96689>>>// string information.
96689>>>//
96689>>>//       Procedure Activate_About
96689>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
96689>>>//       End_Procedure
96689>>>//    where: sTitle =     Name of application. If none provided, uses caption
96689>>>//                        bar title
96689>>>//           sVersion   = Version Line. If none provided, will be blank
96689>>>//           sCopyRight = Copyright Line. If none provided, will be blank
96689>>>//           sAuthor    = Author name, blank if none provided
96689>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
96689>>>//                        is used.
96689>>>// It is expected that you will place this in your own object package. For
96689>>>// example an order about package may look like this:
96689>>>//
96689>>>//   // OrderAbout.pkg
96689>>>//   Use StdAbout.pkg
96689>>>//   Procedure Activate_About
96689>>>//      String sTitle sCopyright sVersion sAuthor
96689>>>//      Move "My Order Entry System" to sTitle
96689>>>//      Move "Version 2.1" to sVersion
96689>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
96689>>>//      Move "John Smith"  to sAuthor
96689>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
96689>>>//   end_procedure
96689>>>//   // end of file.
96689>>>
96689>>>Use DfAbout.pkg
96689>>>
96689>>>// *************************************************************************
96689>>>//  Public message. This is the default message. It is expected that you will
96689>>>//   create your own message to override this
96689>>>// *************************************************************************
96689>>>
96689>>>Procedure Activate_About
96692>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
96693>>>End_Procedure
96694>>>
96694>>>// *************************************************************************
96694>>>//  Public message. It is expected that you will send this message (most
96694>>>//  likely from Activate_About. This creates an about object, activates it
96694>>>//  and destroys it when done. It is not exepected that you will augment this.
96694>>>// *************************************************************************
96694>>>// Sample usage:
96694>>>//   The first two params will automatically be filled from the application settings if not provided.
96694>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
96694>>>
96694>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
96697>>>    Integer hoObj hoMain iArgs
96697>>>    String sValue
96697>>>
96697>>>    // Create object
96697>>>    Object About is an AboutDialog
96699>>>    // Uncomment these two lines if you would like to have a resizable About object.
96699>>>    //            Set Border_Style to Border_Thick
96699>>>    //            Set peAnchors to anAll
96699>>>
96699>>>    // Add checking for the number of arguments passed to avoid runtime errors
96699>>>    // if one of them is not passed. This makes the interface
96699>>>    // more flexible.
96699>>>        Move num_arguments to iArgs
96700>>>
96700>>>        // If no title is passed use the label of the main panel (if a main panel exists).
96700>>>        If (iArgs > 0 and sTitle = "") Begin
96702>>>            Get Main_Window of Desktop to hoMain
96703>>>            If hoMain Begin
96705>>>                Get Label of hoMain to sValue
96706>>>            End
96706>>>>
96706>>>        End
96706>>>>
96706>>>        Else If (iArgs > 0 and sTitle <> "") Begin
96709>>>            Move sTitle to sValue
96710>>>        End
96710>>>>
96710>>>        Else If (iArgs = 0) Begin
96713>>>            Get Main_Window of Desktop to hoMain
96714>>>            If hoMain Begin
96716>>>                Get Label of hoMain to sValue
96717>>>            End
96717>>>>
96717>>>        End
96717>>>>
96717>>>
96717>>>        If (sValue <> "") Begin
96719>>>            Send Add_LineLn sValue
96720>>>        End
96720>>>>
96720>>>        Move "" to sValue
96721>>>
96721>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
96721>>>        // For this to work the Project Properties Version must have been set in the Studio.
96721>>>        If (iArgs < 2) Begin
96723>>>            Move "" to sValue
96724>>>        End
96724>>>>
96724>>>        Else Begin
96725>>>            Move sVersion to sValue
96726>>>        End
96726>>>>
96726>>>        Set Version to sValue
96727>>>
96727>>>        If (iArgs > 2 and sCopyRight <> "") Begin
96729>>>            Send Add_LineLn sCopyRight
96730>>>        End
96730>>>>
96730>>>
96730>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
96730>>>        // else we do.
96730>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
96732>>>            Send Add_Line sAuthor
96733>>>        End
96733>>>>
96733>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
96736>>>            Send Add_LineLn sAuthor
96737>>>        End
96737>>>>
96737>>>
96737>>>        // Square bitmaps of 80x80 works best
96737>>>        If (iArgs > 4 and sBitmap <> "") Begin
96739>>>            Set Logo to sBitMap
96740>>>        End
96740>>>>
96740>>>
96740>>>        // Here starts handling of the five optional params:
96740>>>        If (iArgs = 6 and sParam6  <> "") Begin
96742>>>            Send Add_Line sParam6
96743>>>        End
96743>>>>
96743>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
96746>>>            Send Add_LineLn sParam6
96747>>>        End
96747>>>>
96747>>>
96747>>>        If (iArgs = 7 and sParam7  <> "") Begin
96749>>>            Send Add_Line sParam7
96750>>>        End
96750>>>>
96750>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
96753>>>            Send Add_LineLn sParam7
96754>>>        End
96754>>>>
96754>>>
96754>>>        If (iArgs = 8 and sParam8  <> "") Begin
96756>>>            Send Add_Line sParam8
96757>>>        End
96757>>>>
96757>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
96760>>>            Send Add_LineLn sParam8
96761>>>        End
96761>>>>
96761>>>
96761>>>        If (iArgs = 9 and sParam9  <> "") Begin
96763>>>            Send Add_Line sParam9
96764>>>        End
96764>>>>
96764>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
96767>>>            Send Add_LineLn sParam9
96768>>>        End
96768>>>>
96768>>>
96768>>>        If (iArgs = 10 and sParam10 <> "") Begin
96770>>>            Send Add_Line sParam10
96771>>>        End
96771>>>>
96771>>>
96771>>>        Move Self to hoObj
96772>>>    End_Object
96773>>>
96773>>>    Send Popup   of hoObj // Popup the about object
96774>>>    Send Destroy of hoObj // When done, it will be destroyed
96775>>>End_Procedure
96776>        Use ManageSQLConnections.vw
Including file: ManageSQLConnections.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ManageSQLConnections.vw)
96776>>>Use DFClient.pkg
96776>>>Use cCJCommandBarSystem.pkg
96776>>>Use cCJGrid.pkg
96776>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJGridColumnRowIndicator.pkg)
96776>>>>>Use cCJGridColumn.pkg
96776>>>>>
96776>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
96777>>>>>    
96777>>>>>    Procedure Construct_Object
96779>>>>>        Forward Send Construct_Object
96781>>>>>        
96781>>>>>        Property Integer piImage 0
96782>>>>>        
96782>>>>>        Set psCaption to ""
96783>>>>>        Set piWidth to 20
96784>>>>>        Set pbResizable to False
96785>>>>>        Set pbEditable to False
96786>>>>>        Set pbFocusable to False
96787>>>>>        Set pbAllowDrag to False
96788>>>>>        Set psToolTip to "Row Indicator"
96789>>>>>    End_Procedure
96790>>>>>    
96790>>>>>    Procedure OnCreateColumn
96792>>>>>        Integer iImage
96792>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
96794>>>>>        Set piImage to iImage
96795>>>>>    End_Procedure
96796>>>>>    
96796>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
96798>>>>>        Integer iImage iFocusedRow
96798>>>>>        Handle hoDataSource
96798>>>>>        
96798>>>>>        Get phoDataSource to hoDataSource
96799>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
96800>>>>>        Move -1 to iImage
96801>>>>>        If (iRow = iFocusedRow) Begin
96803>>>>>            Get piImage to iImage
96804>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
96805>>>>>        End
96805>>>>>>
96805>>>>>    End_Procedure
96806>>>>>    
96806>>>>>End_Class
96807>>>Use cCJGridColumn.pkg
96807>>>Use cSQLConnectionButton.pkg
Including file: cSQLConnectionButton.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionButton.pkg)
96807>>>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
96807>>>>>>>//****************************************************************************
96807>>>>>>>// $Module type: Package
96807>>>>>>>// $Module name: cRDCButtonDPI.pkg
96807>>>>>>>//
96807>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
96807>>>>>>>// Copyright (c) 2013 RDC Tools International
96807>>>>>>>// E-mail      : support@rdctools.com
96807>>>>>>>// Web-site    : http://www.rdctools.com
96807>>>>>>>//
96807>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
96807>>>>>>>//
96807>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96807>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96807>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96807>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96807>>>>>>>// in the help folder for more details.
96807>>>>>>>//
96807>>>>>>>//****************************************************************************
96807>>>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
96807>>>>>>>>>//****************************************************************************
96807>>>>>>>>>// $Module type: Package
96807>>>>>>>>>// $Module name: cRDCButton.pkg
96807>>>>>>>>>//
96807>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
96807>>>>>>>>>// Copyright (c) 2013 RDC Tools International
96807>>>>>>>>>// E-mail      : support@rdctools.com
96807>>>>>>>>>// Web-site    : http://www.rdctools.com
96807>>>>>>>>>//
96807>>>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
96807>>>>>>>>>//
96807>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96807>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96807>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96807>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96807>>>>>>>>>// in the help folder for more details.
96807>>>>>>>>>//
96807>>>>>>>>>//****************************************************************************
96807>>>>>>>>>Use Windows.pkg
96807>>>>>>>>>Use Enclient.pkg
96807>>>>>>>>>Use errornum.inc
96807>>>>>>>>>
96807>>>>>>>>>Class cButtonIdleHandler is a cIdleHandler
96808>>>>>>>>>    Procedure Construct_Object
96810>>>>>>>>>        Forward Send Construct_Object
96812>>>>>>>>>
96812>>>>>>>>>    End_Procedure
96813>>>>>>>>>
96813>>>>>>>>>    Procedure OnIdle
96815>>>>>>>>>        Delegate Send DoUpdate
96817>>>>>>>>>    End_Procedure
96818>>>>>>>>>
96818>>>>>>>>>End_Class
96819>>>>>>>>>
96819>>>>>>>>>Class cRDCButton is a Button
96820>>>>>>>>>
96820>>>>>>>>>    Procedure Construct_Object
96822>>>>>>>>>        Forward Send Construct_Object
96824>>>>>>>>>
96824>>>>>>>>>        Property Boolean pbAutoEnable False
96825>>>>>>>>>
96825>>>>>>>>>        Property Boolean pbEnabled True
96826>>>>>>>>>
96826>>>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
96827>>>>>>>>>
96827>>>>>>>>>        On_Key kCancel Send CancelIfPopupObject
96828>>>>>>>>>    End_Procedure
96829>>>>>>>>>
96829>>>>>>>>>    Procedure CancelIfPopupObject
96831>>>>>>>>>        Boolean bIsInPopupObject
96831>>>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
96833>>>>>>>>>        If (bIsInPopupObject = True) Begin
96835>>>>>>>>>            Send Close_Panel
96836>>>>>>>>>        End
96836>>>>>>>>>>
96836>>>>>>>>>    End_Procedure
96837>>>>>>>>>
96837>>>>>>>>>    Procedure End_Construct_Object
96839>>>>>>>>>        String sTooltip sStatus_Help
96839>>>>>>>>>
96839>>>>>>>>>        Forward Send End_Construct_Object
96841>>>>>>>>>
96841>>>>>>>>>        Get psToolTip   to sTooltip
96842>>>>>>>>>        Get Status_Help to sStatus_Help
96843>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
96845>>>>>>>>>            Set psToolTip to sStatus_Help
96846>>>>>>>>>        End
96846>>>>>>>>>>
96846>>>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
96848>>>>>>>>>            Set Status_Help to sToolTip
96849>>>>>>>>>        End
96849>>>>>>>>>>
96849>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
96850>>>>>>>>>    End_Procedure
96851>>>>>>>>>
96851>>>>>>>>>    Procedure DoUpdate
96853>>>>>>>>>        If (pbAutoEnable(Self) = False) Begin
96855>>>>>>>>>            Procedure_Return
96856>>>>>>>>>        End
96856>>>>>>>>>>
96856>>>>>>>>>        Set Enabled_State to (IsEnabled(Self))
96857>>>>>>>>>    End_Procedure
96858>>>>>>>>>
96858>>>>>>>>>    Function IsEnabled Returns Boolean
96860>>>>>>>>>        Boolean bEnabled
96860>>>>>>>>>        Get pbEnabled to bEnabled
96861>>>>>>>>>        Function_Return bEnabled
96862>>>>>>>>>    End_Function
96863>>>>>>>>>
96863>>>>>>>>>    // Enable the idle handler timer when the button is activated
96863>>>>>>>>>    Procedure Activating
96865>>>>>>>>>        Forward Send Activating
96867>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
96868>>>>>>>>>    End_Procedure
96869>>>>>>>>>
96869>>>>>>>>>    // Disable the idle handler when the button is deactivated
96869>>>>>>>>>    Procedure Deactivating
96871>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
96872>>>>>>>>>        Forward Send Deactivating
96874>>>>>>>>>    End_Procedure
96875>>>>>>>>>
96875>>>>>>>>>End_Class
96876>>>>>>>
96876>>>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
96876>>>>>>>Class cRDCButtonDPI is a cRDCButton
96877>>>>>>>    Procedure Construct_Object
96879>>>>>>>        Integer iIconSize
96879>>>>>>>        Forward Send Construct_Object
96881>>>>>>>        Set piImageMarginLeft to 10
96882>>>>>>>    End_Procedure
96883>>>>>>>
96883>>>>>>>    // Returns: DPI setting as an integer.
96883>>>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
96883>>>>>>>    //                      iDPI=120 is "Medium setting" 125%
96883>>>>>>>    //                      iDPI= 144 is "Large setting" 150%
96883>>>>>>>    Function GetCurrentDPI Returns Integer
96885>>>>>>>        Handle hDC
96885>>>>>>>        Integer iPixelsX
96885>>>>>>>        Move (GetDC(0)) to hDC
96886>>>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
96887>>>>>>>        Move (ReleaseDC(0, hDC)) to hDC
96888>>>>>>>        Function_Return iPixelsX
96889>>>>>>>    End_Function
96890>>>>>>>
96890>>>>>>>    Function GetCorrectIconSize Returns Integer
96892>>>>>>>        Integer iPixelsX iIndex iSize
96892>>>>>>>        Integer[] iaSizes
96893>>>>>>>
96893>>>>>>>        Move 16 to iaSizes[0]
96894>>>>>>>        Move 24 to iaSizes[1]
96895>>>>>>>        Move 32 to iaSizes[2]
96896>>>>>>>        Move 48 to iaSizes[3]
96897>>>>>>>        Move 64 to iaSizes[4]
96898>>>>>>>
96898>>>>>>>        Get piImageSize to iSize  // the "100%" size
96899>>>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
96900>>>>>>>        Move (0 max iIndex) to iIndex
96901>>>>>>>        Get GetCurrentDPI to iPixelsX
96902>>>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
96902>>>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
96902>>>>>>>        // will increment iIndex as many times as we need here.
96902>>>>>>>        Case Begin
96902>>>>>>>            Case (iPixelsX > 144)
96904>>>>>>>                Increment iIndex
96905>>>>>>>            Case (iPixelsX = 144)
96908>>>>>>>                Increment iIndex
96909>>>>>>>            Case (iPixelsX = 120)
96912>>>>>>>                Increment iIndex
96913>>>>>>>        Case End
96913>>>>>>>        Move (iIndex min 4) to iIndex
96914>>>>>>>        Function_Return iaSizes[iIndex]
96915>>>>>>>    End_Function
96916>>>>>>>
96916>>>>>>>    Procedure Set psToolTip String sToolTip
96918>>>>>>>        String sStatusHelp
96918>>>>>>>
96918>>>>>>>        Get Status_Help to sStatusHelp
96919>>>>>>>        If (sStatusHelp = "") Begin
96921>>>>>>>            Set Status_Help to sToolTip
96922>>>>>>>        End
96922>>>>>>>>
96922>>>>>>>
96922>>>>>>>        Forward Set psToolTip to sToolTip
96924>>>>>>>    End_Procedure
96925>>>>>>>
96925>>>>>>>End_Class
96926>>>>>
96926>>>>>// New button class so we constantly can display the ini-filename in the status_help area:
96926>>>>>Class cSQLConnectionButton is a cRDCButtonDPI
96927>>>>>    Procedure Construct_Object
96929>>>>>        Forward Send Construct_Object
96931>>>>>    End_Procedure
96932>>>>>
96932>>>>>    Procedure End_Construct_Object
96934>>>>>        String sLabel sImage
96934>>>>>        Forward Send End_Construct_Object
96936>>>>>        Get psImage to sImage
96937>>>>>        If (sImage = "") Begin
96939>>>>>            Get Label to sLabel
96940>>>>>            Move (Replace("&", sLabel, "")) to sLabel
96941>>>>>            Move (Replace("...", sLabel, "")) to sLabel
96942>>>>>            Set psImage to ("Action" + sLabel + "1.ico")
96943>>>>>        End
96943>>>>>>
96943>>>>>    End_Procedure
96944>>>>>
96944>>>>>    Function Status_Help String Item# Returns String
96946>>>>>        String sRetval
96946>>>>>        Get IniFileName to sRetval
96947>>>>>        Function_Return sRetval
96948>>>>>    End_Function
96949>>>>>
96949>>>>>End_Class
96950>>>
96950>>>Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
96950>>>>>Use Windows.pkg
96950>>>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJGridPromptList.pkg)
96950>>>>>>>Use Windows.pkg
96950>>>>>>>Use cCJGrid.pkg
96950>>>>>>>
96950>>>>>>>
96950>>>>>>>
96950>>>>>>>Class cCJGridPromptList is a cCJGrid
96951>>>>>>>    
96951>>>>>>>    Procedure Construct_Object
96953>>>>>>>        Forward Send Construct_Object
96955>>>>>>>        
96955>>>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
96956>>>>>>>        Property Boolean Private_pbAutoOrdering True
96957>>>>>>>        Property Boolean pbAutoSearch True  // pops up search window
96958>>>>>>>        Property Integer peUpdateMode umPromptValue
96959>>>>>>>        Property Integer piUpdateColumn 0
96960>>>>>>>        Property Integer piInitialColumn -1
96961>>>>>>>        Property String  psSeedValue ''
96962>>>>>>>        Property Handle phmPromptUpdateCallback 0
96963>>>>>>>        Property Integer phoInvokingObject
96964>>>>>>>        
96964>>>>>>>        Property Boolean pbStoredAutoSeed
96965>>>>>>>        Property Boolean pbStoredAutoOrdering
96966>>>>>>>        Property Boolean pbStoredAutoSearch
96967>>>>>>>        Property Integer peStoredUpdateMode
96968>>>>>>>        Property Integer piStoredUpdateColumn
96969>>>>>>>        Property Integer piStoredInitialColumn
96970>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
96971>>>>>>>        Property Boolean pbStoredSelectionEnable
96972>>>>>>>        Property Boolean pbStoredMultipleSelection
96973>>>>>>>        
96973>>>>>>>        // internally set by list
96973>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
96973>>>>>>>        Property Boolean pbCanceled
96974>>>>>>>        Property Integer[] pSelectedRows
96975>>>>>>>        
96975>>>>>>>        Property Boolean pbNeedsNewOrdering
96976>>>>>>>        Property Boolean pbRequestSearch
96977>>>>>>>        Property tGridKeyPair[] pSearchKeys
96978>>>>>>>        
96978>>>>>>>        // these properties makes a prompt list a prompt list
96978>>>>>>>        // and should not be changed.
96978>>>>>>>        Set pbEditOnKeyNavigation to False
96979>>>>>>>        Set pbEditOnClick to False
96980>>>>>>>        Set pbReadOnly to True
96981>>>>>>>        Set pbFocusSubItems to True
96982>>>>>>>        
96982>>>>>>>        // these could maybe be changed
96982>>>>>>>        Set pbShadeSortColumn to True
96983>>>>>>>        Set pbHeaderReorders to True
96984>>>>>>>        Set pbHeaderTogglesDirection to True
96985>>>>>>>        Set pbHeaderSelectsColumn to True
96986>>>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
96987>>>>>>>        Set piFocusCellBackColor to clNone
96988>>>>>>>        Set piFocusCellForeColor to clNone
96989>>>>>>>        Set piFocusCellRectangleColor to clBlack
96990>>>>>>>        Set pbUseFocusCellRectangle to False
96991>>>>>>>        Set pbSelectionEnable to True
96992>>>>>>>        
96992>>>>>>>        On_Key kEnter Send Ok
96993>>>>>>>        On_Key kCancel Send Cancel
96994>>>>>>>        
96994>>>>>>>    End_Procedure
96995>>>>>>>    
96995>>>>>>>    // reorder list automatically on column change
96995>>>>>>>    // this also set pbFocusSubItems which is required to make the two states work
96995>>>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
96997>>>>>>>        Set Private_pbAutoOrdering to bAutoOrder
96998>>>>>>>        Set pbFocusSubItems to bAutoOrder
96999>>>>>>>    End_Procedure
97000>>>>>>>    
97000>>>>>>>    Function pbAutoOrdering Returns Boolean
97002>>>>>>>        Boolean bAutoOrder
97002>>>>>>>        Get Private_pbAutoOrdering to bAutoOrder
97003>>>>>>>        Function_Return bAutoOrder
97004>>>>>>>    End_Function
97005>>>>>>>    
97005>>>>>>>    // augmented to handle auto-ordering and invoking the search popup list
97005>>>>>>>    Procedure OnIdle
97007>>>>>>>        Boolean bNeedsReorder bSearch bOldToggle
97007>>>>>>>        Handle hoCol
97007>>>>>>>        Integer iKy1 iKy2 iCol
97007>>>>>>>        
97007>>>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
97008>>>>>>>        If bNeedsReorder Begin
97010>>>>>>>            Get SelectedColumn to iCol
97011>>>>>>>            If (iCol<>-1) Begin
97013>>>>>>>                
97013>>>>>>>                Get pbHeaderTogglesDirection to bOldToggle
97014>>>>>>>                Set pbHeaderTogglesDirection to False
97015>>>>>>>                Send HeaderReorder iCol
97016>>>>>>>                Set pbHeaderTogglesDirection to bOldToggle
97017>>>>>>>                
97017>>>>>>>                Set pbNeedsNewOrdering to False
97018>>>>>>>            End
97018>>>>>>>>
97018>>>>>>>        End
97018>>>>>>>>
97018>>>>>>>        
97018>>>>>>>        Get pbRequestSearch to bSearch
97019>>>>>>>        If bSearch Begin
97021>>>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
97022>>>>>>>        End
97022>>>>>>>>
97022>>>>>>>        
97022>>>>>>>        Forward Send OnIdle
97024>>>>>>>    End_Procedure
97025>>>>>>>    
97025>>>>>>>    Procedure OnStoreDefaults
97027>>>>>>>        Integer iVal
97027>>>>>>>        Boolean bVal
97027>>>>>>>        
97027>>>>>>>        Get pbAutoSeed to bVal
97028>>>>>>>        Set pbStoredAutoSeed to bVal
97029>>>>>>>        
97029>>>>>>>        Get pbAutoOrdering to bVal
97030>>>>>>>        Set pbStoredAutoOrdering to bVal
97031>>>>>>>        
97031>>>>>>>        Get pbAutoSearch to bVal
97032>>>>>>>        Set pbStoredAutoSearch to bVal
97033>>>>>>>        
97033>>>>>>>        Get peUpdateMode to iVal
97034>>>>>>>        Set peStoredUpdateMode to iVal
97035>>>>>>>        
97035>>>>>>>        Get piUpdateColumn to iVal
97036>>>>>>>        Set piStoredUpdateColumn to iVal
97037>>>>>>>        
97037>>>>>>>        Get piInitialColumn to iVal
97038>>>>>>>        Set piStoredInitialColumn to iVal
97039>>>>>>>        
97039>>>>>>>        Get phmPromptUpdateCallback to iVal
97040>>>>>>>        Set phmStoredPromptUpdateCallback to iVal
97041>>>>>>>        
97041>>>>>>>        Get pbSelectionEnable to bVal
97042>>>>>>>        Set pbStoredSelectionEnable to bVal
97043>>>>>>>        
97043>>>>>>>        Get pbMultipleSelection to bVal
97044>>>>>>>        Set pbStoredMultipleSelection to bVal
97045>>>>>>>        
97045>>>>>>>    End_Procedure
97046>>>>>>>    
97046>>>>>>>    Procedure OnRestoreDefaults
97048>>>>>>>        Integer iVal
97048>>>>>>>        Boolean bVal
97048>>>>>>>        
97048>>>>>>>        Get pbStoredAutoSeed to bVal
97049>>>>>>>        Set pbAutoSeed to bVal
97050>>>>>>>        
97050>>>>>>>        Get pbStoredAutoOrdering to bVal
97051>>>>>>>        Set pbAutoOrdering to bVal
97052>>>>>>>        
97052>>>>>>>        Get pbStoredAutoSearch to bVal
97053>>>>>>>        Set pbAutoSearch to bVal
97054>>>>>>>        
97054>>>>>>>        Get peStoredUpdateMode to iVal
97055>>>>>>>        Set peUpdateMode to iVal
97056>>>>>>>        
97056>>>>>>>        Get piStoredInitialColumn to iVal
97057>>>>>>>        Set piInitialColumn to iVal
97058>>>>>>>        
97058>>>>>>>        Get phmStoredPromptUpdateCallback to iVal
97059>>>>>>>        Set phmPromptUpdateCallback to iVal
97060>>>>>>>        
97060>>>>>>>        Get pbStoredSelectionEnable to bVal
97061>>>>>>>        Set pbSelectionEnable to bVal
97062>>>>>>>        
97062>>>>>>>        Get pbStoredMultipleSelection to bVal
97063>>>>>>>        Set pbMultipleSelection to bVal
97064>>>>>>>        
97064>>>>>>>    End_Procedure
97065>>>>>>>    
97065>>>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
97065>>>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
97065>>>>>>>    // Suitable for augmentation
97065>>>>>>>    Procedure OnSeedData
97067>>>>>>>        Integer iUpdateColumn iSortColumn
97067>>>>>>>        Boolean bSeed bAuto
97067>>>>>>>        String sValue
97067>>>>>>>        Handle hoCol
97067>>>>>>>        
97067>>>>>>>        Get piUpdateColumn to iUpdateColumn
97068>>>>>>>        Get psSeedValue to sValue
97069>>>>>>>        Get pbAutoSeed to bSeed
97070>>>>>>>        Get piSortColumn to iSortColumn
97071>>>>>>>        Get pbAutoOrdering to bAuto
97072>>>>>>>        // if not yet sorted and this is auto ordering we will
97072>>>>>>>        // sort the data for the search column. We do this to make the
97072>>>>>>>        // column search GE logic work properly.
97072>>>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
97074>>>>>>>            Get ColumnObject iUpdateColumn to hoCol
97075>>>>>>>            Send SortGridByColumn hoCol False
97076>>>>>>>        End
97076>>>>>>>>
97076>>>>>>>        
97076>>>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
97078>>>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
97079>>>>>>>        End
97079>>>>>>>>
97079>>>>>>>        Else Begin
97080>>>>>>>            Send MovetoFirstRow
97081>>>>>>>        End
97081>>>>>>>>
97081>>>>>>>        
97081>>>>>>>    End_Procedure
97082>>>>>>>    
97082>>>>>>>    Procedure OnMoveValueOutByValue
97084>>>>>>>        String sValue
97084>>>>>>>        Handle hoInvokingObject hoCol  hoDataSource
97084>>>>>>>        Integer iRow iCol
97084>>>>>>>        Integer[] SelRowsIndexes
97085>>>>>>>        
97085>>>>>>>        Get phoInvokingObject to hoInvokingObject
97086>>>>>>>        Get pSelectedRows to SelRowsIndexes
97087>>>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
97089>>>>>>>            Get piUpdateColumn to iCol
97090>>>>>>>            Get ColumnObject iCol to hoCol
97091>>>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
97092>>>>>>>            Set Value of hoInvokingObject to sValue
97093>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
97094>>>>>>>        End
97094>>>>>>>>
97094>>>>>>>    End_Procedure
97095>>>>>>>    
97095>>>>>>>    Procedure OnMoveValueOutByCustom
97097>>>>>>>    End_Procedure
97098>>>>>>>    
97098>>>>>>>    // augment to popup a search window when allowed
97098>>>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
97100>>>>>>>        Boolean bSubFocus bAutoSearch bChar
97100>>>>>>>        Integer iVal
97100>>>>>>>        
97100>>>>>>>        Get pbFocusSubItems to bSubFocus
97101>>>>>>>        Get pbAutoSearch to bAutoSearch
97102>>>>>>>        Forward Send OnComKeyDown llKeyCode llShift
97104>>>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
97106>>>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
97108>>>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
97109>>>>>>>                Move (iVal<>0) to bChar
97110>>>>>>>            End
97110>>>>>>>>
97110>>>>>>>            If bChar Begin
97112>>>>>>>                // this can get called multiple times before a search dialog pops up
97112>>>>>>>                Send AddToSearchKeys llKeyCode llShift
97113>>>>>>>            End
97113>>>>>>>>
97113>>>>>>>        End
97113>>>>>>>>
97113>>>>>>>    End_Procedure
97114>>>>>>>    
97114>>>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
97116>>>>>>>        Boolean bAutoSearch
97116>>>>>>>        Integer iKeyCode iShiftCode
97116>>>>>>>        Get pbAutoSearch to bAutoSearch
97117>>>>>>>        If bAutoSearch Begin
97119>>>>>>>            // this can get called multiple times before a search dialog pops up
97119>>>>>>>            Get piLastKey to iKeyCode
97120>>>>>>>            Get piLastKey2 to iShiftCode
97121>>>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
97122>>>>>>>        End
97122>>>>>>>>
97122>>>>>>>        Move True to llCancel
97123>>>>>>>    End_Procedure
97124>>>>>>>    
97124>>>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
97126>>>>>>>        Send ClearSearchRequest // kill any deferred search popup
97127>>>>>>>        Forward Send OnComRowDblClick llRow llItem
97129>>>>>>>    End_Procedure
97130>>>>>>>    
97130>>>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
97132>>>>>>>        Send Ok
97133>>>>>>>    End_Procedure
97134>>>>>>>    
97134>>>>>>>    
97134>>>>>>>    // we don't want a menu for prompt lists
97134>>>>>>>    Function CreateContextMenu Returns Handle
97136>>>>>>>        Function_Return 0
97137>>>>>>>    End_Function
97138>>>>>>>    
97138>>>>>>>    // if we use auto-ordering, change the order when the column changes
97138>>>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
97140>>>>>>>        Boolean bAutoOrder
97140>>>>>>>        Forward Send ColumnChanged iOld iNew
97142>>>>>>>        Get pbAutoOrdering to bAutoOrder
97143>>>>>>>        If bAutoOrder Begin
97145>>>>>>>            // will be reordered in idle event
97145>>>>>>>            Set pbNeedsNewOrdering to True
97146>>>>>>>        End
97146>>>>>>>>
97146>>>>>>>    End_Procedure
97147>>>>>>>    
97147>>>>>>>    
97147>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
97149>>>>>>>        Integer eMode
97149>>>>>>>        Integer[] SelRowsIndexes
97150>>>>>>>        Set pbCanceled to True // assume cancel unless changed
97151>>>>>>>        Set pSelectedRows to SelRowsIndexes // empty
97152>>>>>>>        Get peUpdateMode to eMode
97153>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
97155>>>>>>>            Send OnStoreDefaults
97156>>>>>>>        End
97156>>>>>>>>
97156>>>>>>>        Send InitializePromptList
97157>>>>>>>        Forward Send Add_Focus hoParent
97159>>>>>>>        Send LoadData
97160>>>>>>>        Set psSeedValue to ""
97161>>>>>>>    End_Procedure
97162>>>>>>>    
97162>>>>>>>    // called before the list is activated.
97162>>>>>>>    Procedure InitializePromptList
97164>>>>>>>        Integer hoInvokingObject
97164>>>>>>>        Boolean bAutoColumn bAutoSeed
97164>>>>>>>        Integer i iOldMode eUpdateMode
97164>>>>>>>        String sValue
97164>>>>>>>        
97164>>>>>>>        Get peUpdateMode to eUpdateMode
97165>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
97167>>>>>>>            Get Focus of Desktop to hoInvokingObject
97168>>>>>>>            If (hoInvokingObject<=Desktop) Begin
97170>>>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
97171>>>>>>>>
97171>>>>>>>                Procedure_Return
97172>>>>>>>            End
97172>>>>>>>>
97172>>>>>>>            
97172>>>>>>>            Set phoInvokingObject to hoInvokingObject
97173>>>>>>>            
97173>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
97174>>>>>>>            Get peUpdateMode to eUpdateMode
97175>>>>>>>        End
97175>>>>>>>>
97175>>>>>>>        
97175>>>>>>>        Send ClearSearchRequest // clear the search keys
97176>>>>>>>        Set pbNeedsNewOrdering to False
97177>>>>>>>        
97177>>>>>>>        Get pbAutoSeed to bAutoSeed
97178>>>>>>>        
97178>>>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
97180>>>>>>>            Get Value of hoInvokingObject to sValue
97181>>>>>>>            Set psSeedValue to sValue
97182>>>>>>>        End
97182>>>>>>>>
97182>>>>>>>        
97182>>>>>>>    End_Procedure
97183>>>>>>>    
97183>>>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
97183>>>>>>>    Procedure LoadData
97185>>>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
97185>>>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
97185>>>>>>>        Integer eUpdateMode
97185>>>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
97185>>>>>>>        
97185>>>>>>>        Get phoDataSource to hoDataSource
97186>>>>>>>        Get peUpdateMode to eUpdateMode
97187>>>>>>>        Get phoInvokingObject to hoInvokingObject
97188>>>>>>>        Get pbAutoSeed to bAutoSeed
97189>>>>>>>        Get piInitialColumn to iInitialColumn
97190>>>>>>>        Get piUpdateColumn to iUpdateColumn
97191>>>>>>>        Get RowCount of hoDataSource to iRows
97192>>>>>>>        
97192>>>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
97192>>>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
97192>>>>>>>        If (iInitialColumn=-1) Begin
97194>>>>>>>            Move iUpdateColumn to iInitialColumn
97195>>>>>>>        End
97195>>>>>>>>
97195>>>>>>>        If (iInitialColumn>=0) Begin
97197>>>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
97198>>>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
97199>>>>>>>        End
97199>>>>>>>>
97199>>>>>>>        Send OnSeedData // find a good starting place for the row
97200>>>>>>>        Get pbFocusSubItems to bSubFocus
97201>>>>>>>        If bSubFocus Begin
97203>>>>>>>            // if column focus, which is normal, go to initialcolumn
97203>>>>>>>            If hoInitialColumn Begin
97205>>>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
97206>>>>>>>            End
97206>>>>>>>>
97206>>>>>>>            Else Begin
97207>>>>>>>                Send MoveToFirstEnterableColumn
97208>>>>>>>            End
97208>>>>>>>>
97208>>>>>>>        End
97208>>>>>>>>
97208>>>>>>>        
97208>>>>>>>    End_Procedure
97209>>>>>>>    
97209>>>>>>>    // This is only called in a successful close
97209>>>>>>>    Procedure ClosePromptList
97211>>>>>>>        Handle hoDataSource hoInvokingObject
97211>>>>>>>        Handle hmCallBack
97211>>>>>>>        Integer iRow eUpdateMode
97211>>>>>>>        Integer[] SelRowsIndexes
97212>>>>>>>        
97212>>>>>>>        Get phoDataSource to hoDataSource
97213>>>>>>>        Get phoInvokingObject to hoInvokingObject
97214>>>>>>>        
97214>>>>>>>        If (pbMultipleSelection(Self)) Begin
97216>>>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
97217>>>>>>>        End
97217>>>>>>>>
97217>>>>>>>        Else Begin
97218>>>>>>>            Get SelectedRow of hoDataSource to iRow
97219>>>>>>>            If (iRow<>-1) Begin
97221>>>>>>>                Move iRow to SelRowsIndexes[0]
97222>>>>>>>            End
97222>>>>>>>>
97222>>>>>>>        End
97222>>>>>>>>
97222>>>>>>>        
97222>>>>>>>        Set pbCanceled to False
97223>>>>>>>        Set pSelectedRows to SelRowsIndexes
97224>>>>>>>        
97224>>>>>>>        Get peUpdateMode to eUpdateMode
97225>>>>>>>        // if non-invoking there is by definition, no move value out
97225>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
97227>>>>>>>            
97227>>>>>>>            If (eUpdateMode=umPromptValue) Begin
97229>>>>>>>                Send OnMoveValueOutByValue
97230>>>>>>>            End
97230>>>>>>>>
97230>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
97233>>>>>>>                Send OnMoveValueOutByCustom
97234>>>>>>>            End
97234>>>>>>>>
97234>>>>>>>            Get phmPromptUpdateCallback to hmCallBack
97235>>>>>>>            If hmCallBack Begin
97237>>>>>>>                Send hmCallBack of hoInvokingObject Self
97238>>>>>>>            End
97238>>>>>>>>
97238>>>>>>>        End
97238>>>>>>>>
97238>>>>>>>        
97238>>>>>>>        Send Close_Panel
97239>>>>>>>    End_Procedure
97240>>>>>>>    
97240>>>>>>>    // augment to send OnRestoreDefaults.
97240>>>>>>>    Procedure Release_Focus
97242>>>>>>>        Integer eUpdateMode
97242>>>>>>>        Get peUpdateMode to eUpdateMode
97243>>>>>>>        Forward Send Release_Focus
97245>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
97247>>>>>>>            Send OnRestoreDefaults
97248>>>>>>>        End
97248>>>>>>>>
97248>>>>>>>    End_Procedure
97249>>>>>>>    
97249>>>>>>>    Function SelectedRowIds Returns RowID[]
97251>>>>>>>        RowID[] SelectedRowids
97252>>>>>>>        Integer[] SelectedRows
97253>>>>>>>        Integer i iRows
97253>>>>>>>        Handle hoDataSource
97253>>>>>>>        Get phoDataSource to hoDataSource
97254>>>>>>>        Get pSelectedRows to SelectedRows
97255>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
97256>>>>>>>        For i from 0 to (iRows-1)
97262>>>>>>>>
97262>>>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
97263>>>>>>>        Loop
97264>>>>>>>>
97264>>>>>>>        Function_Return SelectedRowids
97265>>>>>>>    End_Function
97266>>>>>>>    
97266>>>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
97268>>>>>>>        String[] SelectedValues
97269>>>>>>>        Integer[] SelectedRows
97270>>>>>>>        Integer i iRows
97270>>>>>>>        Handle hoCol
97270>>>>>>>        Get ColumnObject iCol to hoCol
97271>>>>>>>        Get pSelectedRows to SelectedRows
97272>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
97273>>>>>>>        For i from 0 to (iRows-1)
97279>>>>>>>>
97279>>>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
97280>>>>>>>        Loop
97281>>>>>>>>
97281>>>>>>>        Function_Return SelectedValues
97282>>>>>>>    End_Function
97283>>>>>>>    
97283>>>>>>>    Procedure Ok Returns Integer
97285>>>>>>>        Send ClosePromptList
97286>>>>>>>    End_Procedure
97287>>>>>>>    
97287>>>>>>>    Procedure Cancel Returns Integer
97289>>>>>>>        Send Close_Panel
97290>>>>>>>    End_Procedure
97291>>>>>>>    
97291>>>>>>>    Procedure Search
97293>>>>>>>        Send Activate // give focus back to list so focus things are correct
97294>>>>>>>        Send Request_Search 0 0
97295>>>>>>>    End_Procedure
97296>>>>>>>    
97296>>>>>>>    // do a search using the current keys in the search key buffer for the sort column.
97296>>>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
97296>>>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
97296>>>>>>>    Procedure Request_SearchEx
97298>>>>>>>        tGridKeyPair[] Keys
97298>>>>>>>        tGridKeyPair[] Keys
97299>>>>>>>        Integer iCol
97299>>>>>>>        Handle hoCol hoSearchDialog
97299>>>>>>>        Boolean bOk
97299>>>>>>>        String sValue
97299>>>>>>>        
97299>>>>>>>        Get piSortColumn to iCol
97300>>>>>>>        If (iCol<>-1) Begin
97302>>>>>>>            Get ColumnObject iCol to hoCol
97303>>>>>>>            Get pSearchKeys to Keys
97304>>>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
97305>>>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
97306>>>>>>>            If bOk Begin
97308>>>>>>>                Send RequestFindColumnValue iCol sValue True 0
97309>>>>>>>            End
97309>>>>>>>>
97309>>>>>>>            Send Destroy of hoSearchDialog
97310>>>>>>>        End
97310>>>>>>>>
97310>>>>>>>        Send ClearSearchRequest // clear the search keys
97311>>>>>>>    End_Procedure
97312>>>>>>>    
97312>>>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
97312>>>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
97314>>>>>>>        tGridKeyPair[] Keys
97314>>>>>>>        tGridKeyPair[] Keys
97315>>>>>>>        tGridKeyPair KeyPair
97315>>>>>>>        tGridKeyPair KeyPair
97315>>>>>>>        Set pbRequestSearch to True
97316>>>>>>>        Move iKeyCode to KeyPair.KeyCode
97317>>>>>>>        Move iShiftCode to KeyPair.ShiftCode
97318>>>>>>>        Get pSearchKeys to Keys
97319>>>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
97320>>>>>>>        Set pSearchKeys to Keys
97321>>>>>>>    End_Procedure
97322>>>>>>>    
97322>>>>>>>    Procedure ClearSearchRequest
97324>>>>>>>        tGridKeyPair[] SearchKeys
97324>>>>>>>        tGridKeyPair[] SearchKeys
97325>>>>>>>        Set pSearchKeys to SearchKeys
97326>>>>>>>        Set pbRequestSearch to False
97327>>>>>>>    End_Procedure
97328>>>>>>>    
97328>>>>>>>End_Class
97329>>>>>>>
97329>>>>>Use cDbUpdateFunctionLibrary.pkg
97329>>>>>Use MSSqldrv.pkg
97329>>>>>Use db2_drv.pkg
97329>>>>>Use odbc_drv.pkg
97329>>>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\cRDCModalPanel.pkg)
97329>>>>>>>//****************************************************************************
97329>>>>>>>// $Module type: Class
97329>>>>>>>// $Module name: cRDCModalPanel
97329>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
97329>>>>>>>// Created     : 2014-03-17 @ 12:33
97329>>>>>>>//
97329>>>>>>>// Description :
97329>>>>>>>//
97329>>>>>>>// $Rev History:
97329>>>>>>>//    2014-03-17  Module header created
97329>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97329>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97329>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97329>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97329>>>>>>>// in the help folder for more details.
97329>>>>>>>//
97329>>>>>>>//****************************************************************************
97329>>>>>>>Use Windows.pkg
97329>>>>>>>Use cCJCommandBarSystem.pkg   
97329>>>>>>>Use cCJSkinFramework.pkg
97329>>>>>>>
97329>>>>>>>Class cRDCModalPanel is a ModalPanel
97330>>>>>>>
97330>>>>>>>    Procedure Construct_Object
97332>>>>>>>        Forward Send Construct_Object
97334>>>>>>>
97334>>>>>>>        Set Maximize_Icon to True
97335>>>>>>>        Set Minimize_Icon to False
97336>>>>>>>        Set Border_Style to Border_Thick
97337>>>>>>>        Set Locate_Mode to Center_On_Parent
97338>>>>>>>
97338>>>>>>>        Property String Private_Icon
97339>>>>>>>        Property Handle phoDialogCommandbar
97340>>>>>>>    End_Procedure
97341>>>>>>>
97341>>>>>>>    Procedure Set Icon String sIcon
97343>>>>>>>        Forward Set Icon to sIcon
97345>>>>>>>        Set Private_Icon to sIcon
97346>>>>>>>    End_Procedure
97347>>>>>>>
97347>>>>>>>    Function Icon Returns String
97349>>>>>>>        String sIcon
97349>>>>>>>        Get Private_Icon to sIcon
97350>>>>>>>        Function_Return sIcon
97351>>>>>>>    End_Function
97352>>>>>>>
97352>>>>>>>    Procedure Page Integer iPageObject
97354>>>>>>>        String sIcon
97354>>>>>>>        Integer hWnd
97354>>>>>>>        
97354>>>>>>>        Forward Send Page iPageObject
97356>>>>>>>        Get Private_Icon to sIcon
97357>>>>>>>        If (sIcon <> "") Begin
97359>>>>>>>            Set Icon to sIcon
97360>>>>>>>        End
97360>>>>>>>>
97360>>>>>>>
97360>>>>>>>        Get Window_Handle to hWnd
97361>>>>>>>
97361>>>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
97363>>>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
97364>>>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
97365>>>>>>>        End
97365>>>>>>>>
97365>>>>>>>    End_Procedure
97366>>>>>>>
97366>>>>>>>    // Put a status bar at the bottom of the panel, which makes
97366>>>>>>>    // status_help work and puts a gripper in the lower right corner.
97366>>>>>>>    Procedure End_Construct_Object
97368>>>>>>>        Integer iStyle iSize iOffset
97368>>>>>>>
97368>>>>>>>        Forward Send End_Construct_Object
97370>>>>>>>
97370>>>>>>>        Get Border_Style to iStyle
97371>>>>>>>        Move 8 to iOffset
97372>>>>>>>        If (iStyle = Border_Thick) Begin
97374>>>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
97376>>>>>>>                Object oStatusBar is a cCJStatusBar
97378>>>>>>>                    Set phoDialogCommandbar to Self
97379>>>>>>>                    Object oStatusIdle is a cCJStatusBarPane
97381>>>>>>>                        Set piId to sbpIDIdlePane
97382>>>>>>>                        Set pbStyleStretch to True
97383>>>>>>>                    End_Object
97384>>>>>>>                End_Object
97385>>>>>>>            End_Object
97386>>>>>>>            Get Size to iSize
97387>>>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
97388>>>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
97389>>>>>>>        End
97389>>>>>>>>
97389>>>>>>>
97389>>>>>>>    End_Procedure
97390>>>>>>>
97390>>>>>>>    Procedure Popup
97392>>>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
97393>>>>>>>        Forward Send Popup
97395>>>>>>>    End_Procedure
97396>>>>>>>
97396>>>>>>>End_Class
97397>>>>>
97397>>>>>Object oDatabaseSelection_sl is a cRDCModalPanel
97399>>>>>    Set Label to "SQL Database Selection"
97400>>>>>    Set Size to 119 183
97401>>>>>    Set piMinSize to 89 170
97402>>>>>    Set Location to 2 2
97403>>>>>    Set Border_Style to Border_Thick
97404>>>>>    Set Icon to "DatabaseLookup1.ico"
97405>>>>>
97405>>>>>    Property String[] psTheData
97407>>>>>
97407>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
97409>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
97411>>>>>        End_Object
97412>>>>>    End
97412>>>>>>
97412>>>>>
97412>>>>>    Object oSelList is a cCJGridPromptList
97414>>>>>        Set Size to 89 167
97415>>>>>        Set Location to 6 6
97416>>>>>        Set peAnchors to anAll
97417>>>>>        Set pbAllowColumnRemove to False
97418>>>>>        Set pbUseAlternateRowBackgroundColor to True
97419>>>>>        Set pbGrayIfDisable to False
97420>>>>>        Set pbHeaderReorders to False
97421>>>>>        Set pbHeaderSelectsColumn to False
97422>>>>>        Set pbHeaderTogglesDirection to False
97423>>>>>        Set pbShadeSortColumn to False
97424>>>>>        Set piFocusCellBackColor to clDkGray
97425>>>>>
97425>>>>>        Object oName is a cCJGridColumn
97427>>>>>            Set piWidth to 334
97428>>>>>            Set psCaption to "Database Name"
97429>>>>>        End_Object
97430>>>>>
97430>>>>>        Procedure Activating
97433>>>>>            tDataSourceRow[] MyData
97433>>>>>            tDataSourceRow[] MyData
97434>>>>>            Handle hoDataSource
97434>>>>>            String[] sTheData
97435>>>>>            Integer iCount iSize
97435>>>>>
97435>>>>>            Send Cursor_Wait of Cursor_Control
97436>>>>>            Forward Send Activating
97438>>>>>
97438>>>>>            Get psTheData to sTheData
97439>>>>>            Move (SizeOfArray(sTheData)) to iSize
97440>>>>>            Decrement iSize
97441>>>>>            For iCount from 0 to iSize
97447>>>>>>
97447>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
97448>>>>>            Loop
97449>>>>>>
97449>>>>>
97449>>>>>            Get phoDataSource to hoDataSource
97450>>>>>            Send InitializeData of hoDataSource MyData
97451>>>>>            Send Cursor_Ready of Cursor_Control
97452>>>>>        End_Procedure
97453>>>>>
97453>>>>>    End_Object
97454>>>>>
97454>>>>>    Object oOK_Btn is a Button
97456>>>>>        Set Size to 14 50
97457>>>>>        Set Label    to "&OK"
97458>>>>>        Set Location to 98 68
97459>>>>>        Set peAnchors To anBottomRight
97460>>>>>
97460>>>>>        Procedure OnClick
97463>>>>>            Send Ok of oSelList
97464>>>>>        End_Procedure
97465>>>>>
97465>>>>>    End_Object
97466>>>>>
97466>>>>>    Object oCancel_Btn is a Button
97468>>>>>        Set Size to 14 50
97469>>>>>        Set Label    to "&Cancel"
97470>>>>>        Set Location to 98 123
97471>>>>>        Set peAnchors to anBottomRight
97472>>>>>
97472>>>>>        Procedure OnClick
97475>>>>>            Send Close_Panel
97476>>>>>        End_Procedure
97477>>>>>
97477>>>>>    End_Object
97478>>>>>
97478>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97479>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97480>>>>>End_Object
97481>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
97481>>>>>Use Windows.pkg
97481>>>>>Use cCJGridPromptList.pkg
97481>>>>>Use MSSqldrv.pkg
97481>>>>>Use db2_drv.pkg
97481>>>>>Use odbc_drv.pkg    
97481>>>>>Use cRDCModalPanel.pkg
97481>>>>>Use cDbUpdateFunctionLibrary.pkg
97481>>>>>
97481>>>>>Object oServerSelection_sl is a cRDCModalPanel
97483>>>>>    Set Size to 105 225
97484>>>>>    Set Label to "Database Server/DSN Selection"
97485>>>>>    Set piMinSize to 89 211
97486>>>>>    Set Location to 2 2
97487>>>>>    Set Icon to "ServerLookup1.ico"
97488>>>>>
97488>>>>>    Property String[] psTheData
97490>>>>>
97490>>>>>    Object oSelList is a cCJGridPromptList
97492>>>>>        Set Size to 72 215
97493>>>>>        Set Location to 6 6
97494>>>>>        Set peAnchors to anAll
97495>>>>>        Set pbAllowColumnRemove to False
97496>>>>>        Set pbUseAlternateRowBackgroundColor to True
97497>>>>>        Set pbGrayIfDisable to False
97498>>>>>        Set pbHeaderReorders to False
97499>>>>>        Set pbHeaderSelectsColumn to False
97500>>>>>        Set pbHeaderTogglesDirection to False
97501>>>>>        Set pbShadeSortColumn to False
97502>>>>>        Set piFocusCellBackColor to clDkGray
97503>>>>>
97503>>>>>        Object oName is a cCJGridColumn
97505>>>>>            Set piWidth to 358
97506>>>>>            Set psCaption to "Name"
97507>>>>>        End_Object
97508>>>>>
97508>>>>>        Procedure Activating
97511>>>>>            tDataSourceRow[] MyData
97511>>>>>            tDataSourceRow[] MyData
97512>>>>>            Handle hoDataSource
97512>>>>>            String[] sTheData
97513>>>>>            Integer iCount iSize
97513>>>>>
97513>>>>>            Send Cursor_Wait of Cursor_Control
97514>>>>>            Get psTheData to sTheData
97515>>>>>            Move (SizeOfArray(sTheData)) to iSize
97516>>>>>            Decrement iSize
97517>>>>>            For iCount from 0 to iSize
97523>>>>>>
97523>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
97524>>>>>            Loop
97525>>>>>>
97525>>>>>
97525>>>>>            Forward Send Activating
97527>>>>>
97527>>>>>            Get phoDataSource to hoDataSource
97528>>>>>            Send InitializeData of hoDataSource MyData
97529>>>>>            Send Cursor_Ready of Cursor_Control
97530>>>>>        End_Procedure
97531>>>>>
97531>>>>>    End_Object
97532>>>>>
97532>>>>>    Object oOK_Btn is a Button
97534>>>>>        Set Size to 14 50
97535>>>>>        Set Label    to "&OK"
97536>>>>>        Set Location to 85 116
97537>>>>>        Set peAnchors To anBottomRight
97538>>>>>
97538>>>>>        Procedure OnClick
97541>>>>>            Send Ok of oSelList
97542>>>>>        End_Procedure
97543>>>>>
97543>>>>>    End_Object
97544>>>>>
97544>>>>>    Object oCancel_Btn is a Button
97546>>>>>        Set Size to 14 50
97547>>>>>        Set Label    to "&Cancel"
97548>>>>>        Set Location to 85 171
97549>>>>>        Set peAnchors to anBottomRight
97550>>>>>
97550>>>>>        Procedure OnClick
97553>>>>>            Send Close_Panel
97554>>>>>        End_Procedure
97555>>>>>
97555>>>>>    End_Object
97556>>>>>
97556>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97557>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97558>>>>>End_Object
97559>>>Use ManageSQLConnections.dg
Including file: ManageSQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ManageSQLConnections.dg)
97559>>>>>Use Windows.pkg
97559>>>>>Use Cursor.pkg
97559>>>>>Use cCJCommandBarSystem.pkg
97559>>>>>Use cRDCButtonDPI.pkg
97559>>>>>Use cSQLCheckBox.pkg
Including file: cSQLCheckBox.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLCheckBox.pkg)
97559>>>>>>>Use Windows.pkg
97559>>>>>>>
97559>>>>>>>// Used by the "Page" message below to show
97559>>>>>>>// a rectangle around ComboForm and Checkbox objects.
97559>>>>>>>    Define WM_CHANGEUISTATE for |CI$0127
97559>>>>>>>    Define WM_UPDATEUISTATE for |CI$0128
97559>>>>>>>    Define WM_QUERYUISTATE  for |CI$0129
97559>>>>>>>    Define UIS_SET          for 1
97559>>>>>>>    Define UIS_CLEAR        for 2
97559>>>>>>>    Define UIS_INITIALIZE   for 3
97559>>>>>>>    Define UISF_HIDEFOCUS   for |CI$1
97559>>>>>>>    Define UISF_HIDEACCEL   for |CI$2
97559>>>>>>>    Define UISF_ACTIVE      for |CI$4
97559>>>>>>>
97559>>>>>>>// Note: Can't use cRDCCheckbox as then the OnChange event isn't called (Don't know why)
97559>>>>>>>Class cSQLCheckBox is a CheckBox
97560>>>>>>>    Procedure Construct_Object
97562>>>>>>>        Forward Send Construct_Object
97564>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
97564>>>>>>>        Property Integer piItem
97565>>>>>>>    End_Procedure
97566>>>>>>>
97566>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
97568>>>>>>>    End_Procedure
97569>>>>>>>
97569>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
97571>>>>>>>        Integer iItem
97571>>>>>>>        Get piItem to iItem
97572>>>>>>>        Set Checked_State to (sConnectionData[iItem] = "1")
97573>>>>>>>    End_Procedure
97574>>>>>>>
97574>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
97576>>>>>>>        Boolean bState
97576>>>>>>>        Integer iItem
97576>>>>>>>        Get piItem to iItem
97577>>>>>>>        Get Checked_State to bState
97578>>>>>>>        Move bState to sConnectionData[iItem]
97579>>>>>>>    End_Procedure
97580>>>>>>>
97580>>>>>>>    Procedure Set psToolTip String sToolTip
97582>>>>>>>        String sStatusHelp
97582>>>>>>>
97582>>>>>>>        Get Status_Help to sStatusHelp
97583>>>>>>>        If (sStatusHelp = "") Begin
97585>>>>>>>            Set Status_Help to sToolTip
97586>>>>>>>        End
97586>>>>>>>>
97586>>>>>>>
97586>>>>>>>        Forward Set psToolTip to sToolTip
97588>>>>>>>    End_Procedure
97589>>>>>>>
97589>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
97589>>>>>>>    // The bug being that the focus rectangle doesn't show.
97589>>>>>>>    Procedure Page Integer iPageObject
97591>>>>>>>        Handle hWnd
97591>>>>>>>        Integer iRet iState
97591>>>>>>>
97591>>>>>>>        Forward Send Page iPageObject
97593>>>>>>>
97593>>>>>>>        If (iPageObject) Begin
97595>>>>>>>            Get Window_Handle to hWnd
97596>>>>>>>            If (hWnd) Begin
97598>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
97599>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
97601>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
97602>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
97603>>>>>>>                End
97603>>>>>>>>
97603>>>>>>>            End
97603>>>>>>>>
97603>>>>>>>        End
97603>>>>>>>>
97603>>>>>>>    End_Procedure
97604>>>>>>>
97604>>>>>>>End_Class
97605>>>>>Use cSQLComboForm.pkg
Including file: cSQLComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLComboForm.pkg)
97605>>>>>>>Use Windows.pkg
97605>>>>>>>Use cRDCComboForm.pkg
Including file: cRDCComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCComboForm.pkg)
97605>>>>>>>>>//****************************************************************************
97605>>>>>>>>>// $Module type: Package
97605>>>>>>>>>// $Module name: cRDCComboform.pkg
97605>>>>>>>>>//
97605>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97605>>>>>>>>>// Copyright (c) 2014 RDC Tools International
97605>>>>>>>>>// E-mail      : support@rdctools.com
97605>>>>>>>>>// Web-site    : http://www.rdctools.com
97605>>>>>>>>>//
97605>>>>>>>>>// Created     : 2014-03-17 @ 12:35 (Military date format - Year-Month-Day)
97605>>>>>>>>>//
97605>>>>>>>>>// Portions by : Raveen Sundram, Excellent Software Ltd
97605>>>>>>>>>//               The auto-size combo width logic was developed by Raveen.
97605>>>>>>>>>//
97605>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97605>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97605>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97605>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97605>>>>>>>>>// in the help folder for more details.
97605>>>>>>>>>//
97605>>>>>>>>>//****************************************************************************
97605>>>>>>>>>Use Windows.pkg
97605>>>>>>>>>
97605>>>>>>>>>// Used by the "Page" message below to show
97605>>>>>>>>>// a focus rectangle around ComboForm and Checkbox objects.
97605>>>>>>>>>
97605>>>>>>>>>Class cComboFormIdleHandler is a cIdleHandler
97606>>>>>>>>>    Procedure Construct_Object
97608>>>>>>>>>        Forward Send Construct_Object
97610>>>>>>>>>
97610>>>>>>>>>    End_Procedure
97611>>>>>>>>>
97611>>>>>>>>>    Procedure OnIdle
97613>>>>>>>>>        Delegate Send DoUpdate
97615>>>>>>>>>    End_Procedure
97616>>>>>>>>>
97616>>>>>>>>>End_Class
97617>>>>>>>>>
97617>>>>>>>>>Class cRDCComboForm is a ComboForm
97618>>>>>>>>>    Procedure Construct_Object
97620>>>>>>>>>        Forward Send Construct_Object
97622>>>>>>>>>
97622>>>>>>>>>        Property Boolean pbAutoListWidth True
97623>>>>>>>>>
97623>>>>>>>>>        Property Boolean pbAutoShadowLabelObject True
97624>>>>>>>>>
97624>>>>>>>>>        Property Boolean pbAutoEnable False
97625>>>>>>>>>        Set Label_Col_Offset to 2
97626>>>>>>>>>        Property Boolean pbEnabled True
97627>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
97628>>>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cComboFormIdleHandler)))
97629>>>>>>>>>
97629>>>>>>>>>    End_Procedure
97630>>>>>>>>>
97630>>>>>>>>>    Procedure End_Construct_Object
97632>>>>>>>>>        Boolean bAutoShadowLabelObject
97632>>>>>>>>>        String sTooltip sStatus_Help
97632>>>>>>>>>
97632>>>>>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
97633>>>>>>>>>        If (bAutoShadowLabelObject = True) Begin
97635>>>>>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
97636>>>>>>>>>        End
97636>>>>>>>>>>
97636>>>>>>>>>
97636>>>>>>>>>        Forward Send End_Construct_Object
97638>>>>>>>>>
97638>>>>>>>>>        Get psToolTip   to sTooltip
97639>>>>>>>>>        Get Status_Help to sStatus_Help
97640>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
97642>>>>>>>>>            Set psToolTip to sStatus_Help
97643>>>>>>>>>        End
97643>>>>>>>>>>
97643>>>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
97646>>>>>>>>>            Set Status_Help to sTooltip
97647>>>>>>>>>        End
97647>>>>>>>>>>
97647>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
97648>>>>>>>>>
97648>>>>>>>>>    End_Procedure
97649>>>>>>>>>
97649>>>>>>>>>    Procedure DoUpdate
97651>>>>>>>>>        If (pbAutoEnable(Self) = False) Begin
97653>>>>>>>>>            Procedure_Return
97654>>>>>>>>>        End
97654>>>>>>>>>>
97654>>>>>>>>>        Set Enabled_State to (IsEnabled(Self))
97655>>>>>>>>>    End_Procedure
97656>>>>>>>>>
97656>>>>>>>>>    Function IsEnabled Returns Boolean
97658>>>>>>>>>        Boolean bEnabled
97658>>>>>>>>>        Get pbEnabled to bEnabled
97659>>>>>>>>>        Function_Return bEnabled
97660>>>>>>>>>    End_Function
97661>>>>>>>>>
97661>>>>>>>>>    // Enable the idle handler timer when the object is activated
97661>>>>>>>>>    Procedure Activating
97663>>>>>>>>>        Forward Send Activating
97665>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
97666>>>>>>>>>    End_Procedure
97667>>>>>>>>>
97667>>>>>>>>>    // Disable the idle handler when the object is deactivated
97667>>>>>>>>>    Procedure Deactivating
97669>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
97670>>>>>>>>>        Forward Send Deactivating
97672>>>>>>>>>    End_Procedure
97673>>>>>>>>>
97673>>>>>>>>>    // To "un-select" the text in the comboform on startup
97673>>>>>>>>>    Procedure DoApplyAnchors Integer Arg1 Integer Arg2
97675>>>>>>>>>        Integer iStart iEnd
97675>>>>>>>>>
97675>>>>>>>>>        If (Focus(Desktop)=Self) Begin
97677>>>>>>>>>            Get SelStart to iStart
97678>>>>>>>>>            Get SelEnd   to iEnd
97679>>>>>>>>>        End
97679>>>>>>>>>>
97679>>>>>>>>>        Forward Send DoApplyAnchors Arg1 Arg2
97681>>>>>>>>>        Send SetSel iStart iEnd
97682>>>>>>>>>    End_Procedure
97683>>>>>>>>>
97683>>>>>>>>>    // Message that will drop down the list without the user clicking it,
97683>>>>>>>>>    // so you can send "DropDownList" to the combo to show the list.
97683>>>>>>>>>    Procedure DropDownList
97685>>>>>>>>>        Send Windows_Message CB_SHOWDROPDOWN 1 0
97686>>>>>>>>>    End_Procedure
97687>>>>>>>>>
97687>>>>>>>>>    Procedure SizeComboWidth
97689>>>>>>>>>        Integer iCount iItem iTextExt iRows iWd iNewWd iVertAdj
97689>>>>>>>>>        String sVal
97689>>>>>>>>>
97689>>>>>>>>>        // Initialise Width
97689>>>>>>>>>        Set ListWidth to 0
97690>>>>>>>>>        Send DoSetListWidth
97691>>>>>>>>>
97691>>>>>>>>>        Get ListRowCount     to iRows
97692>>>>>>>>>        Get Combo_Item_Count to iCount
97693>>>>>>>>>
97693>>>>>>>>>        // Vertical scroll-bar adjustment is needed
97693>>>>>>>>>        Move (iRows > 0 and iCount > iRows) to iVertAdj
97694>>>>>>>>>        If (iVertAdj) Begin
97696>>>>>>>>>            Move (GetSystemMetrics(SM_CXVSCROLL)+GetSystemMetrics(SM_CXEDGE)) to iVertAdj
97697>>>>>>>>>        End
97697>>>>>>>>>>
97697>>>>>>>>>        Else Begin
97698>>>>>>>>>            Move (GetSystemMetrics(SM_CXEDGE)) to iVertAdj
97699>>>>>>>>>        End
97699>>>>>>>>>>
97699>>>>>>>>>
97699>>>>>>>>>        // Calculate New Width
97699>>>>>>>>>        Decrement iCount
97700>>>>>>>>>        For iItem from 0 to iCount
97706>>>>>>>>>>
97706>>>>>>>>>            Get Combo_Value iItem to sVal
97707>>>>>>>>>            If (sVal <> "") Begin
97709>>>>>>>>>                Get Text_Extent sVal to iTextExt
97710>>>>>>>>>                Move (Low(iTextExt) + iVertAdj) to iWd
97711>>>>>>>>>                If (iWd > iNewWd) Begin
97713>>>>>>>>>                    Move (iWd + GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CXEDGE)) to iNewWd
97714>>>>>>>>>                End
97714>>>>>>>>>>
97714>>>>>>>>>            End
97714>>>>>>>>>>
97714>>>>>>>>>        Loop
97715>>>>>>>>>>
97715>>>>>>>>>
97715>>>>>>>>>        // Set New Width
97715>>>>>>>>>        Set ListWidth to iNewWd
97716>>>>>>>>>        Send DoSetListWidth
97717>>>>>>>>>    End_Procedure
97718>>>>>>>>>
97718>>>>>>>>>    Procedure Combo_Add_Item String sValue
97720>>>>>>>>>        Forward Send Combo_Add_Item sValue
97722>>>>>>>>>        If (pbAutoListWidth(Self)) Begin
97724>>>>>>>>>            Send SizeComboWidth
97725>>>>>>>>>        End
97725>>>>>>>>>>
97725>>>>>>>>>    End_Procedure
97726>>>>>>>>>
97726>>>>>>>>>    Procedure Combo_Fill_List
97728>>>>>>>>>        Forward Send Combo_Fill_List
97730>>>>>>>>>        If (pbAutoListWidth(Self)) Begin
97732>>>>>>>>>            Send SizeComboWidth
97733>>>>>>>>>        End
97733>>>>>>>>>>
97733>>>>>>>>>    End_Procedure
97734>>>>>>>>>
97734>>>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
97734>>>>>>>>>    // The bug being that the focus rectangle doesn't show.
97734>>>>>>>>>    Procedure Page Integer iPageObject
97736>>>>>>>>>        Handle hWnd
97736>>>>>>>>>        Integer iRet iState
97736>>>>>>>>>
97736>>>>>>>>>        Forward Send Page iPageObject
97738>>>>>>>>>
97738>>>>>>>>>        If (iPageObject) Begin
97740>>>>>>>>>            Get Window_Handle to hWnd
97741>>>>>>>>>            If (hWnd) Begin
97743>>>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
97744>>>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
97746>>>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
97747>>>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
97748>>>>>>>>>                End
97748>>>>>>>>>>
97748>>>>>>>>>            End
97748>>>>>>>>>>
97748>>>>>>>>>        End
97748>>>>>>>>>>
97748>>>>>>>>>
97748>>>>>>>>>        // To "un-select" the text in the comboform
97748>>>>>>>>>        If (iPageObject = 1 and Focus(Desktop) <> Self) Begin
97750>>>>>>>>>            Send SetSel 0 0
97751>>>>>>>>>        End
97751>>>>>>>>>>
97751>>>>>>>>>    End_Procedure
97752>>>>>>>>>
97752>>>>>>>>>End_Class
97753>>>>>>>
97753>>>>>>>// Used by the "Page" message below to show
97753>>>>>>>// a rectangle around ComboForm and Checkbox objects.
97753>>>>>>>//#IFNDEF WM_CHANGEUISTATE
97753>>>>>>>//    Define WM_CHANGEUISTATE for |CI$0127
97753>>>>>>>//    Define WM_UPDATEUISTATE for |CI$0128
97753>>>>>>>//    Define WM_QUERYUISTATE  for |CI$0129
97753>>>>>>>//    Define UIS_SET          for 1
97753>>>>>>>//    Define UIS_CLEAR        for 2
97753>>>>>>>//    Define UIS_INITIALIZE   for 3
97753>>>>>>>//    Define UISF_HIDEFOCUS   for |CI$1
97753>>>>>>>//    Define UISF_HIDEACCEL   for |CI$2
97753>>>>>>>//    Define UISF_ACTIVE      for |CI$4
97753>>>>>>>//#ENDIF
97753>>>>>>>
97753>>>>>>>Class cSQLComboForm is a cRDCComboForm
97754>>>>>>>    Procedure Construct_Object
97756>>>>>>>        Forward Send Construct_Object
97758>>>>>>>
97758>>>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
97758>>>>>>>//        Property Boolean pbAutoShadowLabelObject True
97758>>>>>>>
97758>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
97758>>>>>>>        Property Integer piItem
97759>>>>>>>
97759>>>>>>>//        Set Label_Col_Offset to 2
97759>>>>>>>//        Set Label_Justification_Mode to JMode_Right
97759>>>>>>>    End_Procedure
97760>>>>>>>
97760>>>>>>>    Procedure End_Construct_Object
97762>>>>>>>//        Boolean bAutoShadowLabelObject
97762>>>>>>>//        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
97762>>>>>>>//        If (bAutoShadowLabelObject = True) Begin
97762>>>>>>>//            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
97762>>>>>>>//        End
97762>>>>>>>        Forward Send End_Construct_Object
97764>>>>>>>    End_Procedure
97765>>>>>>>
97765>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
97767>>>>>>>    End_Procedure
97768>>>>>>>
97768>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
97770>>>>>>>        Integer iItem
97770>>>>>>>        Get piItem to iItem
97771>>>>>>>        Set Value to sConnectionData[iItem]
97772>>>>>>>    End_Procedure
97773>>>>>>>
97773>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
97775>>>>>>>        String sValue
97775>>>>>>>        Integer iItem
97775>>>>>>>        Get piItem to iItem
97776>>>>>>>        Get Value to sValue
97777>>>>>>>        Move sValue to sConnectionData[iItem]
97778>>>>>>>    End_Procedure
97779>>>>>>>
97779>>>>>>>//    Procedure Set psToolTip String sToolTip
97779>>>>>>>//        String sStatusHelp
97779>>>>>>>//
97779>>>>>>>//        Get Status_Help to sStatusHelp
97779>>>>>>>//        If (sStatusHelp = "") Begin
97779>>>>>>>//            Set Status_Help to sToolTip
97779>>>>>>>//        End
97779>>>>>>>//
97779>>>>>>>//        Forward Set psToolTip to sToolTip
97779>>>>>>>//    End_Procedure
97779>>>>>>>//
97779>>>>>>>//    // Fix for a bug when using manifest files & running Vista and above.
97779>>>>>>>//    // The bug being that the focus rectangle doesn't show.
97779>>>>>>>//    Procedure Page Integer iPageObject
97779>>>>>>>//        Handle hWnd
97779>>>>>>>//        Integer iRet iState
97779>>>>>>>//
97779>>>>>>>//        Forward Send Page iPageObject
97779>>>>>>>//
97779>>>>>>>//        If (iPageObject) Begin
97779>>>>>>>//            Get Window_Handle to hWnd
97779>>>>>>>//            If (hWnd) Begin
97779>>>>>>>//                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
97779>>>>>>>//                If (iRet iand UISF_HIDEFOCUS) Begin
97779>>>>>>>//                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
97779>>>>>>>//                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
97779>>>>>>>//                End
97779>>>>>>>//            End
97779>>>>>>>//        End
97779>>>>>>>//    End_Procedure
97779>>>>>>>
97779>>>>>>>End_Class
97780>>>>>Use cSQLForm.pkg
Including file: cSQLForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLForm.pkg)
97780>>>>>>>Use Windows.pkg
97780>>>>>>>
97780>>>>>>>Class cSQLForm is a Form
97781>>>>>>>    Procedure Construct_Object
97783>>>>>>>        Forward Send Construct_Object
97785>>>>>>>
97785>>>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
97785>>>>>>>        Property Boolean pbAutoShadowLabelObject True
97786>>>>>>>
97786>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
97786>>>>>>>        Property Integer piItem
97787>>>>>>>
97787>>>>>>>        Set Label_Justification_Mode to JMode_Right
97788>>>>>>>        Set Label_Col_Offset to 2
97789>>>>>>>    End_Procedure
97790>>>>>>>
97790>>>>>>>    Procedure End_Construct_Object
97792>>>>>>>        Boolean bAutoShadowLabelObject
97792>>>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
97793>>>>>>>        If (bAutoShadowLabelObject = True) Begin
97795>>>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
97796>>>>>>>        End
97796>>>>>>>>
97796>>>>>>>        Forward Send End_Construct_Object
97798>>>>>>>    End_Procedure
97799>>>>>>>
97799>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
97801>>>>>>>    End_Procedure
97802>>>>>>>
97802>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
97804>>>>>>>        Integer iItem
97804>>>>>>>        Get piItem to iItem
97805>>>>>>>        Set Value to sConnectionData[iItem]
97806>>>>>>>    End_Procedure
97807>>>>>>>
97807>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
97809>>>>>>>        String sValue
97809>>>>>>>        Integer iItem
97809>>>>>>>        Get piItem to iItem
97810>>>>>>>        Get Value to sValue
97811>>>>>>>        Move sValue to sConnectionData[iItem]
97812>>>>>>>    End_Procedure
97813>>>>>>>
97813>>>>>>>    Procedure Set psToolTip String sToolTip
97815>>>>>>>        String sStatusHelp
97815>>>>>>>
97815>>>>>>>        Get Status_Help to sStatusHelp
97816>>>>>>>        If (sStatusHelp = "") Begin
97818>>>>>>>            Set Status_Help to sToolTip
97819>>>>>>>        End
97819>>>>>>>>
97819>>>>>>>
97819>>>>>>>        Forward Set psToolTip to sToolTip
97821>>>>>>>    End_Procedure
97822>>>>>>>
97822>>>>>>>End_Class
97823>>>>>Use cSQLConnectionHandler.pkg
97823>>>>>Use cDbUpdateFunctionLibrary.pkg
97823>>>>>Use cDbUpdateDatabaseDriver.pkg
97823>>>>>Use DatabaseSelection.dg
97823>>>>>Use ServerSelection.dg
97823>>>>>Use TableSpaceSelection.dg
Including file: TableSpaceSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\TableSpaceSelection.dg)
97823>>>>>>>Use Windows.pkg
97823>>>>>>>Use cCJGridPromptList.pkg     
97823>>>>>>>Use cRDCModalPanel.pkg
97823>>>>>>>Use cDbUpdateFunctionLibrary.pkg
97823>>>>>>>
97823>>>>>>>Object oTableSpaceSelection_sl is a cRDCModalPanel
97825>>>>>>>    Set Size to 118 177
97826>>>>>>>    Set Label to "SQL Tablespace Selection"
97827>>>>>>>    Set piMinSize to 89 177
97828>>>>>>>    Set Location to 2 2
97829>>>>>>>    Set Icon to "DatabaseLookup1.ico"
97830>>>>>>>
97830>>>>>>>    Property String[] psTheData
97832>>>>>>>
97832>>>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
97834>>>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
97836>>>>>>>        End_Object
97837>>>>>>>    End
97837>>>>>>>>
97837>>>>>>>
97837>>>>>>>    Object oSelList is a cCJGridPromptList
97839>>>>>>>        Set Size to 89 167
97840>>>>>>>        Set Location to 6 6
97841>>>>>>>        Set peAnchors to anAll
97842>>>>>>>        Set pbAllowColumnRemove to False
97843>>>>>>>        Set pbUseAlternateRowBackgroundColor to True
97844>>>>>>>        Set pbGrayIfDisable to False
97845>>>>>>>        Set pbHeaderReorders to False
97846>>>>>>>        Set pbHeaderSelectsColumn to False
97847>>>>>>>        Set pbHeaderTogglesDirection to False
97848>>>>>>>        Set pbShadeSortColumn to False
97849>>>>>>>        Set piFocusCellBackColor to clDkGray
97850>>>>>>>
97850>>>>>>>        Object oName is a cCJGridColumn
97852>>>>>>>            Set piWidth to 334
97853>>>>>>>            Set psCaption to "Table Space Name"
97854>>>>>>>        End_Object
97855>>>>>>>
97855>>>>>>>        Procedure Activating
97858>>>>>>>            tDataSourceRow[] MyData
97858>>>>>>>            tDataSourceRow[] MyData
97859>>>>>>>            Handle hoDataSource
97859>>>>>>>            String[] sTheData
97860>>>>>>>            Integer iCount iSize
97860>>>>>>>
97860>>>>>>>            Send Cursor_Wait of Cursor_Control
97861>>>>>>>            Forward Send Activating
97863>>>>>>>
97863>>>>>>>            Get psTheData to sTheData
97864>>>>>>>            Move (SizeOfArray(sTheData)) to iSize
97865>>>>>>>            Decrement iSize
97866>>>>>>>            For iCount from 0 to iSize
97872>>>>>>>>
97872>>>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
97873>>>>>>>            Loop
97874>>>>>>>>
97874>>>>>>>
97874>>>>>>>            Get phoDataSource to hoDataSource
97875>>>>>>>            Send InitializeData of hoDataSource MyData
97876>>>>>>>            Send Cursor_Ready of Cursor_Control
97877>>>>>>>        End_Procedure
97878>>>>>>>
97878>>>>>>>    End_Object
97879>>>>>>>
97879>>>>>>>    Object oOK_Btn is a Button
97881>>>>>>>        Set Size to 14 50
97882>>>>>>>        Set Label    to "&OK"
97883>>>>>>>        Set Location to 98 68
97884>>>>>>>        Set peAnchors To anBottomRight
97885>>>>>>>
97885>>>>>>>        Procedure OnClick
97888>>>>>>>            Send Ok of oSelList
97889>>>>>>>        End_Procedure
97890>>>>>>>
97890>>>>>>>    End_Object
97891>>>>>>>
97891>>>>>>>    Object oCancel_Btn is a Button
97893>>>>>>>        Set Size to 14 50
97894>>>>>>>        Set Label    to "&Cancel"
97895>>>>>>>        Set Location to 98 123
97896>>>>>>>        Set peAnchors to anBottomRight
97897>>>>>>>
97897>>>>>>>        Procedure OnClick
97900>>>>>>>            Send Close_Panel
97901>>>>>>>        End_Procedure
97902>>>>>>>
97902>>>>>>>    End_Object
97903>>>>>>>
97903>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97904>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97905>>>>>>>End_Object
97906>>>>>Use SchemasSelection.dg
Including file: SchemasSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SchemasSelection.dg)
97906>>>>>>>Use Windows.pkg
97906>>>>>>>Use cCJGridPromptList.pkg  
97906>>>>>>>Use cRDCModalPanel.pkg
97906>>>>>>>Use cDbUpdateFunctionLibrary.pkg
97906>>>>>>>
97906>>>>>>>Object oSchemasSelection_sl is a cRDCModalPanel
97908>>>>>>>    Set Size to 118 177
97909>>>>>>>    Set Label to "SQL Schemas Selection"
97910>>>>>>>    Set piMinSize to 89 177
97911>>>>>>>    Set Location to 2 2
97912>>>>>>>    Set Icon to "DatabaseLookup1.ico"
97913>>>>>>>
97913>>>>>>>    Property String[] psTheData
97915>>>>>>>
97915>>>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
97917>>>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
97919>>>>>>>        End_Object
97920>>>>>>>    End
97920>>>>>>>>
97920>>>>>>>
97920>>>>>>>    Object oSelList is a cCJGridPromptList
97922>>>>>>>        Set Size to 89 167
97923>>>>>>>        Set Location to 6 6
97924>>>>>>>        Set peAnchors to anAll
97925>>>>>>>        Set pbAllowColumnRemove to False
97926>>>>>>>        Set pbUseAlternateRowBackgroundColor to True
97927>>>>>>>        Set pbGrayIfDisable to False
97928>>>>>>>        Set pbHeaderReorders to False
97929>>>>>>>        Set pbHeaderSelectsColumn to False
97930>>>>>>>        Set pbHeaderTogglesDirection to False
97931>>>>>>>        Set pbShadeSortColumn to False
97932>>>>>>>        Set piFocusCellBackColor to clDkGray
97933>>>>>>>
97933>>>>>>>        Object oName is a cCJGridColumn
97935>>>>>>>            Set piWidth to 334
97936>>>>>>>            Set psCaption to "Schema Name"
97937>>>>>>>        End_Object
97938>>>>>>>
97938>>>>>>>        Procedure Activating
97941>>>>>>>            tDataSourceRow[] MyData
97941>>>>>>>            tDataSourceRow[] MyData
97942>>>>>>>            Handle hoDataSource
97942>>>>>>>            String[] sTheData
97943>>>>>>>            Integer iCount iSize
97943>>>>>>>
97943>>>>>>>            Send Cursor_Wait of Cursor_Control
97944>>>>>>>            Forward Send Activating
97946>>>>>>>
97946>>>>>>>            Get psTheData to sTheData
97947>>>>>>>
97947>>>>>>>            Move (SizeOfArray(sTheData)) to iSize
97948>>>>>>>            Decrement iSize
97949>>>>>>>            For iCount from 0 to iSize
97955>>>>>>>>
97955>>>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
97956>>>>>>>            Loop
97957>>>>>>>>
97957>>>>>>>
97957>>>>>>>            Get phoDataSource to hoDataSource
97958>>>>>>>            Send InitializeData of hoDataSource MyData
97959>>>>>>>            Send Cursor_Ready of Cursor_Control
97960>>>>>>>        End_Procedure
97961>>>>>>>
97961>>>>>>>    End_Object
97962>>>>>>>
97962>>>>>>>    Object oOK_Btn is a Button
97964>>>>>>>        Set Size to 14 50
97965>>>>>>>        Set Label    to "&OK"
97966>>>>>>>        Set Location to 98 68
97967>>>>>>>        Set peAnchors To anBottomRight
97968>>>>>>>
97968>>>>>>>        Procedure OnClick
97971>>>>>>>            Send Ok of oSelList
97972>>>>>>>        End_Procedure
97973>>>>>>>
97973>>>>>>>    End_Object
97974>>>>>>>
97974>>>>>>>    Object oCancel_Btn is a Button
97976>>>>>>>        Set Size to 14 50
97977>>>>>>>        Set Label    to "&Cancel"
97978>>>>>>>        Set Location to 98 123
97979>>>>>>>        Set peAnchors to anBottomRight
97980>>>>>>>
97980>>>>>>>        Procedure OnClick
97983>>>>>>>            Send Close_Panel
97984>>>>>>>        End_Procedure
97985>>>>>>>
97985>>>>>>>    End_Object
97986>>>>>>>
97986>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97987>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97988>>>>>>>End_Object
97989>>>>>Use cRDCHeaderGroup.pkg  
Including file: cRDCHeaderGroup.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCHeaderGroup.pkg)
97989>>>>>>>//****************************************************************************
97989>>>>>>>// $Module type: Package
97989>>>>>>>// $Module name: cRDCHeaderGroup.pkg
97989>>>>>>>//
97989>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97989>>>>>>>// Copyright (c) 2017 RDC Tools International
97989>>>>>>>// E-mail      : support@rdctools.com
97989>>>>>>>// Web-site    : http://www.rdctools.com
97989>>>>>>>//
97989>>>>>>>// Created     : 2017-01-05 @ 19:04 (Military date format - Year-Month-Day)
97989>>>>>>>//
97989>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97989>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97989>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97989>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97989>>>>>>>// in the help folder for more details.
97989>>>>>>>//
97989>>>>>>>//****************************************************************************
97989>>>>>>>Use Windows.pkg
97989>>>>>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCommandLinkButton.pkg)
97989>>>>>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
97989>>>>>>>>>// older versions you will just get a regular great big button.
97989>>>>>>>>>
97989>>>>>>>>>Use Windows.pkg
97989>>>>>>>>>Use CharTranslate.pkg
97989>>>>>>>>>
97989>>>>>>>>>Class cCommandLinkButton is a Button
97990>>>>>>>>>    
97990>>>>>>>>>    Procedure Construct_Object
97992>>>>>>>>>        Forward Send Construct_Object
97994>>>>>>>>>        Property String psPrivateNote
97995>>>>>>>>>    End_Procedure
97996>>>>>>>>>    
97996>>>>>>>>>    Procedure Set psNote String sNote
97998>>>>>>>>>        Boolean bSupported
97998>>>>>>>>>        Set psPrivateNote to sNote
97999>>>>>>>>>        Get IsExControlSupported to bSupported
98000>>>>>>>>>        If bSupported Begin
98002>>>>>>>>>            Send SetWinNote
98003>>>>>>>>>        End
98003>>>>>>>>>>
98003>>>>>>>>>    End_Procedure
98004>>>>>>>>>    
98004>>>>>>>>>    Procedure SetWinNote
98006>>>>>>>>>        String sNote
98006>>>>>>>>>        Handle hWnd
98006>>>>>>>>>        Integer i
98006>>>>>>>>>        Address aVar
98006>>>>>>>>>        Get Form_Window_Handle 0 to hWnd
98007>>>>>>>>>        If hWnd Begin
98009>>>>>>>>>            Get psNote to sNote
98010>>>>>>>>>            Move (OemToUtf16Buffer(AddressOf(sNote),Length(sNote))) to aVar
98011>>>>>>>>>            Move (SendMessage(hwnd, BCM_SETNOTE, 0, aVar)) to i
98012>>>>>>>>>            Move (Free(aVar)) to i
98013>>>>>>>>>        End
98013>>>>>>>>>>
98013>>>>>>>>>    End_Procedure
98014>>>>>>>>>    
98014>>>>>>>>>    
98014>>>>>>>>>    Function psNote Returns String
98016>>>>>>>>>        Function_Return (psPrivateNote(Self))
98017>>>>>>>>>    End_Function
98018>>>>>>>>>    
98018>>>>>>>>>    
98018>>>>>>>>>    Procedure Page Integer iState
98020>>>>>>>>>        Integer i hWnd
98020>>>>>>>>>        Boolean bSupported
98020>>>>>>>>>        Get IsExControlSupported to bSupported
98021>>>>>>>>>        If (iState=1 and bSupported) Begin
98023>>>>>>>>>            Get form_style i to i
98024>>>>>>>>>            Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
98025>>>>>>>>>            Forward Send Page iState
98027>>>>>>>>>            Send SetWinNote
98028>>>>>>>>>        End
98028>>>>>>>>>>
98028>>>>>>>>>        Else Begin
98029>>>>>>>>>            Forward Send Page iState
98031>>>>>>>>>        End
98031>>>>>>>>>>
98031>>>>>>>>>    End_Procedure
98032>>>>>>>>>    
98032>>>>>>>>>End_Class
98033>>>>>>>
98033>>>>>>>Define clGreenGrey      for (RGB(64, 84, 93))
98033>>>>>>>Define clGreenGreyLight for (RGB(7, 117, 104))
98033>>>>>>>
98033>>>>>>>Class cRDCHeaderGroupImage is a cCommandLinkButton
98034>>>>>>>    Procedure Construct_Object
98036>>>>>>>        Forward Send Construct_Object
98038>>>>>>>
98038>>>>>>>        Set Size to 18 19
98039>>>>>>>        Set Focus_Mode to NonFocusable
98040>>>>>>>        Set peImageAlign to Button_ImageList_Align_Top
98041>>>>>>>        Set pbAutoResizeIcons to True
98042>>>>>>>    End_Procedure
98043>>>>>>>
98043>>>>>>>    Procedure OnClick
98045>>>>>>>        Broadcast Send Prompt of (Parent(Self))
98047>>>>>>>    End_Procedure
98048>>>>>>>
98048>>>>>>>    Procedure Set Bitmap String sBitmapName
98050>>>>>>>        Forward Set psImage to sBitmapName
98052>>>>>>>    End_Procedure
98053>>>>>>>
98053>>>>>>>    Procedure End_Construct_Object
98055>>>>>>>        Set pbShield to False
98056>>>>>>>        Forward Send End_Construct_Object
98058>>>>>>>    End_Procedure
98059>>>>>>>
98059>>>>>>>End_Class
98060>>>>>>>
98060>>>>>>>// Intermediate class - don't use.
98060>>>>>>>Class _cRDCHeaderGroup is a Container3d
98061>>>>>>>
98061>>>>>>>    Procedure Construct_Object
98063>>>>>>>        Forward Send Construct_Object
98065>>>>>>>
98065>>>>>>>        Property String private.psImage
98066>>>>>>>        Property String private.psLabel
98067>>>>>>>
98067>>>>>>>    End_Procedure
98068>>>>>>>
98068>>>>>>>    Procedure Set psImage String sImage
98070>>>>>>>        Set private.psImage to sImage
98071>>>>>>>    End_Procedure
98072>>>>>>>
98072>>>>>>>    Function psImage Returns String
98074>>>>>>>        Function_Return (private.psImage(Self))
98075>>>>>>>    End_Function
98076>>>>>>>
98076>>>>>>>    Procedure Set psLabel String sLabel
98078>>>>>>>        Set private.psLabel to sLabel
98079>>>>>>>    End_Procedure
98080>>>>>>>
98080>>>>>>>    Function psLabel Returns String
98082>>>>>>>        Function_Return (private.psLabel(Self))
98083>>>>>>>    End_Function
98084>>>>>>>
98084>>>>>>>    // Don't display but allow to use old "Label" syntax to set the value of the oInfo_tb object (header text)
98084>>>>>>>    Procedure Set Label String sLabel
98086>>>>>>>        Set psLabel to sLabel
98087>>>>>>>    End_Procedure
98088>>>>>>>
98088>>>>>>>    Function Label Returns String
98090>>>>>>>        Function_Return (private.psLabel(Self))
98091>>>>>>>    End_Function
98092>>>>>>>
98092>>>>>>>End_Class
98093>>>>>>>
98093>>>>>>>Register_Procedure NavigatePrevious
98093>>>>>>>Register_Procedure NavigateNext
98093>>>>>>>
98093>>>>>>>Class cRDCHeaderGroup is a _cRDCHeaderGroup
98094>>>>>>>
98094>>>>>>>    Procedure Construct_Object
98096>>>>>>>        Forward Send Construct_Object
98098>>>>>>>
98098>>>>>>>        Set peAnchors to anTopLeftRight
98099>>>>>>>        Set pbAcceptDropFiles to True
98100>>>>>>>        Set Border_Style to Border_Normal
98101>>>>>>>
98101>>>>>>>        Property Integer private.piColorOrg
98102>>>>>>>        Property Boolean private.pbIsHeaderGroup True // Don't touch!
98103>>>>>>>        Property String private.psToolTip ""
98104>>>>>>>
98104>>>>>>>        Property Integer piImageColOffset 4
98105>>>>>>>        Property Integer piImageRowOffset 0
98106>>>>>>>        Property String psNote ""
98107>>>>>>>        Property Boolean pbLargeImageSize True
98108>>>>>>>        Property Integer private.piLargeImageSize 24
98109>>>>>>>        Property Integer private.piSmallImageSize 16
98110>>>>>>>        Property Boolean pbUseHotspotColor False
98111>>>>>>>        Property Integer piHeaderHotspotColor clAqua
98112>>>>>>>        Property String private.psLabel ""
98113>>>>>>>        Property Integer piLabelColor clGreenGrey
98114>>>>>>>        Property Boolean pbLabelFontItalics False
98115>>>>>>>        Property Integer piLabelLargeFontHeight 12
98116>>>>>>>        Property Integer piLabelSmallFontHeight 10
98117>>>>>>>        Property Boolean pbUseLargeFontHeight False
98118>>>>>>>
98118>>>>>>>        Property Integer piLabelFontPointWeight fw_Bold
98119>>>>>>>        Property Integer piLabelColOffset 28
98120>>>>>>>        Property Integer piLabelRowOffset 4
98121>>>>>>>        Property Boolean pbCreateTooltipItem True
98122>>>>>>>
98122>>>>>>>        Set pbAcceptDropFiles to True
98123>>>>>>>
98123>>>>>>>        Send Define_ToolTip_Support_Mixin
98124>>>>>>>
98124>>>>>>>        // For the Studio to render the header image
98124>>>>>>>        Set Bitmap to "Default32x32.bmp"
98125>>>>>>>        // This doesn't work... I wonder if there's a way to "trick" the Studio
98125>>>>>>>        // to render some text in the header when in design mode?
98125>>>>>>>        Set Label to "HEADER TEXT"
98126>>>>>>>
98126>>>>>>>        On_Key kLeftArrow  Send NavigatePrevious
98127>>>>>>>        On_Key kUpArrow    Send NavigatePrevious
98128>>>>>>>        On_Key kRightArrow Send NavigateNext
98129>>>>>>>        On_Key kDownArrow  Send NavigateNext
98130>>>>>>>        On_Key kSwitch     Send Switch_Next_Area
98131>>>>>>>    End_Procedure
98132>>>>>>>
98132>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
98133>>>>>>>
98133>>>>>>>    Procedure Set psImage String sImage
98135>>>>>>>        Set Bitmap to ""
98136>>>>>>>        Forward Set psImage to sImage
98138>>>>>>>    End_Procedure
98139>>>>>>>
98139>>>>>>>    Function psImage Returns String
98141>>>>>>>        Function_Return (psImage(Self))
98142>>>>>>>    End_Function
98143>>>>>>>
98143>>>>>>>    Procedure Set Label String sLabel
98145>>>>>>>        Forward Set psLabel to sLabel
98147>>>>>>>    End_Procedure
98148>>>>>>>
98148>>>>>>>    Procedure Set psToolTip String sToolTip
98150>>>>>>>        Set private.psToolTip to sToolTip
98151>>>>>>>    End_Procedure
98152>>>>>>>
98152>>>>>>>    Function psToolTip Returns String
98154>>>>>>>        Function_Return (private.psToolTip(Self))
98155>>>>>>>    End_Function
98156>>>>>>>
98156>>>>>>>    Procedure End_Construct_Object
98158>>>>>>>        String sNote sLabel
98158>>>>>>>        Boolean bUseLargeFontHeight bLargeImageSize bCreateTooltipItem
98158>>>>>>>        Integer iFontHeight iImageSize iLabelRowOffset iLabelColOffset iSize iTextOffset
98158>>>>>>>
98158>>>>>>>        Forward Send End_Construct_Object
98160>>>>>>>
98160>>>>>>>        Get piLabelColOffset to iLabelColOffset
98161>>>>>>>        Get pbUseLargeFontHeight to bUseLargeFontHeight
98162>>>>>>>        If (bUseLargeFontHeight = True) Begin
98164>>>>>>>            Get piLabelLargeFontHeight to iFontHeight
98165>>>>>>>            Move 8 to iLabelRowOffset
98166>>>>>>>        End
98166>>>>>>>>
98166>>>>>>>        Else Begin
98167>>>>>>>            Get piLabelSmallFontHeight to iFontHeight
98168>>>>>>>            Move 6 to iLabelRowOffset
98169>>>>>>>        End
98169>>>>>>>>
98169>>>>>>>
98169>>>>>>>        Get pbLargeImageSize to bLargeImageSize
98170>>>>>>>        If (bLargeImageSize = True) Begin
98172>>>>>>>            Get private.piLargeImageSize to iImageSize
98173>>>>>>>        End
98173>>>>>>>>
98173>>>>>>>        Else Begin
98174>>>>>>>            Get private.piSmallImageSize to iImageSize
98175>>>>>>>            Move (iLabelColOffset - 6) to iLabelColOffset
98176>>>>>>>        End
98176>>>>>>>>
98176>>>>>>>
98176>>>>>>>        Object oHeaderGroupImage is a cRDCHeaderGroupImage
98178>>>>>>>            Set piImageSize to iImageSize
98179>>>>>>>            Set Location to (piImageRowOffset(Self)) (piImageColOffset(Self))
98180>>>>>>>            Set psImage to (private.psImage(Self))
98181>>>>>>>            Set peImageAlign to Button_ImageList_Align_Center
98182>>>>>>>            Set psToolTip to (private.psToolTip(Self))
98183>>>>>>>        End_Object
98184>>>>>>>
98184>>>>>>>        Object oHeaderGroupInfo_tb is a TextBox
98186>>>>>>>            Set Size to 12 100
98187>>>>>>>            Set Location to (piLabelRowOffset(Self)) iLabelColOffset
98188>>>>>>>            Set FontWeight to (piLabelFontPointWeight(Self))
98189>>>>>>>            Set FontItalics to (pbLabelFontItalics(Self))
98190>>>>>>>            Set FontPointHeight to iFontHeight
98191>>>>>>>            Set Label to (private.psLabel(Self))
98192>>>>>>>            Set TextColor to (piLabelColor(Self))
98193>>>>>>>            Set psToolTip to (private.psToolTip(Self))
98194>>>>>>>            Get Size to iSize
98195>>>>>>>        End_Object
98196>>>>>>>
98196>>>>>>>        // ToDo: The positioning logic for placing the info image to the right of the header text is flawed.
98196>>>>>>>        // How can it be improved?
98196>>>>>>>        Get pbCreateTooltipItem to bCreateTooltipItem
98197>>>>>>>        If (bCreateTooltipItem = True and private.psToolTip(Self) <> "") Begin
98199>>>>>>>            Get private.psLabel to sLabel
98200>>>>>>>            Get Text_Extent sLabel to iTextOffset
98201>>>>>>>            Move (Low(iTextOffset) -0)  to iTextOffset
98202>>>>>>>            Object oHeaderGroupTooltip_tb is a TextBox
98204>>>>>>>                Set Size to 10 10
98205>>>>>>>                If (bUseLargeFontHeight = True) Begin
98207>>>>>>>//                    Set Location to (piLabelRowOffset(Self)) iTextOffset //(Low(iSize) + (iTextOffset))
98207>>>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + (iLabelColOffset * 2) + 10)
98208>>>>>>>                End
98208>>>>>>>>
98208>>>>>>>                Else Begin
98209>>>>>>>//                    Set Location to (piLabelRowOffset(Self)) iTextOffset
98209>>>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + iLabelColOffset + 25)
98210>>>>>>>                End
98210>>>>>>>>
98210>>>>>>>                Set psToolTip to (private.psToolTip(Self))
98211>>>>>>>                Set Bitmap to "ActionAbout.bmp"
98212>>>>>>>            End_Object
98213>>>>>>>        End
98213>>>>>>>>
98213>>>>>>>
98213>>>>>>>        Get psNote to sNote
98214>>>>>>>        If (Trim(sNote) <> "") Begin
98216>>>>>>>            Object oHeaderGroupNote_tb is a TextBox
98218>>>>>>>                Set Size to 12 100
98219>>>>>>>                Set Location to (Hi(iSize) + iLabelRowOffset) (iLabelColOffset + 8)
98220>>>>>>>                Set Label to ("-" * String(sNote))
98221>>>>>>>                Set TextColor to (piLabelColor(Self))
98222>>>>>>>                Set FontPointHeight to 9
98223>>>>>>>                Set psToolTip to (private.psToolTip(Self))
98224>>>>>>>            End_Object
98225>>>>>>>        End
98225>>>>>>>>
98225>>>>>>>
98225>>>>>>>    End_Procedure
98226>>>>>>>
98226>>>>>>>    Function Popup_State Returns Boolean
98228>>>>>>>        Boolean bIsPopup
98228>>>>>>>        Get Popup_State of (Parent(Self)) to bIsPopup
98229>>>>>>>        Function_Return bIsPopup
98230>>>>>>>    End_Function
98231>>>>>>>
98231>>>>>>>    Procedure OnEnterArea Handle hoFrom
98233>>>>>>>        Integer iColor
98233>>>>>>>        Forward Send OnEnterArea hoFrom
98235>>>>>>>        // Not ideal, but works most of the time.
98235>>>>>>>        //       When navigating to i.e a popup we don't want
98235>>>>>>>        //       the coloring to appear. Else there will be 2
98235>>>>>>>        //       cRDCHeaderGroup's with the highlight color...
98235>>>>>>>        // Is there a better way?
98235>>>>>>>        If (hoFrom <> Desktop and hoFrom < Parent(Self)) Begin
98237>>>>>>>            Procedure_Return
98238>>>>>>>        End
98238>>>>>>>>
98238>>>>>>>        If (pbUseHotspotColor(Self) = True) Begin
98240>>>>>>>            Get Color to iColor
98241>>>>>>>            Set private.piColorOrg to iColor
98242>>>>>>>            Get piHeaderHotspotColor to iColor
98243>>>>>>>            Set Color to iColor
98244>>>>>>>            Broadcast Recursive Set Color to iColor
98246>>>>>>>        End
98246>>>>>>>>
98246>>>>>>>    End_Procedure
98247>>>>>>>
98247>>>>>>>    Procedure OnExitArea Handle hoFrom
98249>>>>>>>        Integer iColor
98249>>>>>>>        Forward Send OnExitArea hoFrom
98251>>>>>>>        If (pbUseHotspotColor(Self) = True) Begin
98253>>>>>>>            Get private.piColorOrg to iColor
98254>>>>>>>            Set Color to iColor
98255>>>>>>>            Broadcast Recursive Set Color to iColor
98257>>>>>>>        End
98257>>>>>>>>
98257>>>>>>>    End_Procedure
98258>>>>>>>
98258>>>>>>>    // Public access message to change the group header text color at runtime.
98258>>>>>>>    Procedure Set Label_Color Integer iColor
98260>>>>>>>        Set TextColor of (oHeaderGroupInfo_tb(Self)) to iColor
98261>>>>>>>    End_Procedure
98262>>>>>>>
98262>>>>>>>    Procedure NavigatePrevious
98264>>>>>>>        Integer iMulti ivoid iLastErr
98264>>>>>>>        Handle hWnd
98264>>>>>>>        Boolean bErr
98264>>>>>>>
98264>>>>>>>        Move Err to bErr
98265>>>>>>>        Move LastErr to iLastErr
98266>>>>>>>
98266>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
98267>>>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
98268>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
98269>>>>>>>        If (Err) Begin
98271>>>>>>>            Move bErr to Err
98272>>>>>>>            Move iLastErr to LastErr
98273>>>>>>>            Procedure_Return
98274>>>>>>>        End
98274>>>>>>>>
98274>>>>>>>
98274>>>>>>>        Move bErr to Err
98275>>>>>>>        Move iLastErr to LastErr
98276>>>>>>>        If (iMulti = Multi_Select) Begin
98278>>>>>>>            Send Previous
98279>>>>>>>        End
98279>>>>>>>>
98279>>>>>>>        Else Begin
98280>>>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
98281>>>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
98282>>>>>>>        End
98282>>>>>>>>
98282>>>>>>>    End_Procedure
98283>>>>>>>
98283>>>>>>>    Procedure NavigateNext
98285>>>>>>>        Integer iMulti iVoid iLastErr
98285>>>>>>>        Handle hWnd
98285>>>>>>>        Boolean bErr
98285>>>>>>>
98285>>>>>>>        Move Err to bErr
98286>>>>>>>        Move LastErr to iLastErr
98287>>>>>>>
98287>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
98288>>>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
98289>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
98290>>>>>>>        If (Err) Begin
98292>>>>>>>            Move bErr to Err
98293>>>>>>>            Move iLastErr to LastErr
98294>>>>>>>            Procedure_Return
98295>>>>>>>        End
98295>>>>>>>>
98295>>>>>>>
98295>>>>>>>        Move bErr to Err
98296>>>>>>>        Move iLastErr to LastErr
98297>>>>>>>        If (iMulti = Multi_Select) Begin
98299>>>>>>>            Send Next
98300>>>>>>>        End
98300>>>>>>>>
98300>>>>>>>        Else Begin
98301>>>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
98302>>>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
98303>>>>>>>        End
98303>>>>>>>>
98303>>>>>>>
98303>>>>>>>    End_Procedure
98304>>>>>>>
98304>>>>>>>    Procedure Enable_Window Integer iState
98306>>>>>>>        Handle hWnd
98306>>>>>>>        Get Window_Handle to hWnd
98307>>>>>>>        If hWnd Begin
98309>>>>>>>            Move (EnableWindow(hWnd, iState)) to hWnd
98310>>>>>>>        End
98310>>>>>>>>
98310>>>>>>>    End_Procedure
98311>>>>>>>
98311>>>>>>>    Procedure Page_Object Integer iState
98313>>>>>>>        Handle hWnd
98313>>>>>>>        Get Window_Handle to hWnd
98314>>>>>>>        Forward Send Page_Object iState
98316>>>>>>>        If (hWnd = 0 and iState) Begin
98318>>>>>>>            Send Shadow_Display
98319>>>>>>>        End
98319>>>>>>>>
98319>>>>>>>    End_Procedure
98320>>>>>>>
98320>>>>>>>    Procedure Shadow_Display
98322>>>>>>>        Send Enable_Window (not(Object_Shadow_State(Self)))
98323>>>>>>>    End_Procedure
98324>>>>>>>
98324>>>>>>>    Function Explicit_Shadow_State Returns Boolean
98326>>>>>>>        Function_Return (Private.Explicit_Shadow_State(Self))
98327>>>>>>>    End_Function
98328>>>>>>>
98328>>>>>>>    // For some reason we need to augment this event to allow
98328>>>>>>>    // files to be dropped on a cRDCHeaderGroup object; else nothing will
98328>>>>>>>    // happen.
98328>>>>>>>    Procedure OnFileDropped String sFilename Boolean bLast
98330>>>>>>>        Delegate Send OnFileDropped sFilename bLast
98332>>>>>>>    End_Procedure
98333>>>>>>>
98333>>>>>>>End_Class
98334>>>>>>>
98334>>>>>>>// We don't want the broadcast of setting color to set the background
98334>>>>>>>// color for forms that are within a cRDCHeaderGroup object.
98334>>>>>>>// If the Form is not within a cRDCHeaderGroup the Form class should
98334>>>>>>>// behave as it always has. But if you don't like this; just comment
98334>>>>>>>// it out.
98334>>>>>>>//Procedure Set Color for Form Integer eColor
98334>>>>>>>//    Boolean bIsHeaderGroup bErr bEnabled_State
98334>>>>>>>//    Integer iLastErr
98334>>>>>>>//
98334>>>>>>>//    Move Err to bErr
98334>>>>>>>//    Move LastErr to iLastErr
98334>>>>>>>//
98334>>>>>>>//    Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
98334>>>>>>>//    Delegate Get private.pbIsHeaderGroup to bIsHeaderGroup
98334>>>>>>>//    Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
98334>>>>>>>//    Move bErr to Err
98334>>>>>>>//    Move iLastErr to LastErr
98334>>>>>>>//    If (bIsHeaderGroup = False) Begin
98334>>>>>>>//        Forward Set Color to eColor
98334>>>>>>>//    End
98334>>>>>>>//End_Procedure
98334>>>>>Use DriverSettings.dg
Including file: DriverSettings.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DriverSettings.dg)
98334>>>>>>>Use cApplication.pkg
98334>>>>>>>Use Dfline.pkg
98334>>>>>>>Use cRichEdit.pkg
98334>>>>>>>Use cScrollingContainer.pkg
Including file: cScrollingContainer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cScrollingContainer.pkg)
98334>>>>>>>>>// Provides support for scrolling containers.
98334>>>>>>>>>// Scrolling containers is provided by creating two objects,
98334>>>>>>>>>// a host (cScrollingContainer) and a scrolling clientarea (cScrollingClientArea)
98334>>>>>>>>>// The host has no public interface, you just drop the object. It should have only one child object
98334>>>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
98334>>>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
98334>>>>>>>>>
98334>>>>>>>>>Use Windows.pkg
98334>>>>>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cScrollingContainerMixin.pkg)
98334>>>>>>>>>>>// Mixin classes for scrolling container support:
98334>>>>>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
98334>>>>>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
98334>>>>>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
98334>>>>>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
98334>>>>>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
98334>>>>>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
98334>>>>>>>>>>>
98334>>>>>>>>>>>Use Windows.pkg
98334>>>>>>>>>>>Use Winuser.pkg
98334>>>>>>>>>>>Use tWinStructs.pkg
98334>>>>>>>>>>>
98334>>>>>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
98334>>>>>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
98334>>>>>>>>>>>// support for the scrolling client area mixin object.
98334>>>>>>>>>>>
98334>>>>>>>>>>>Class cScrollingClientAreaMixin is a Mixin
98335>>>>>>>>>>>    
98335>>>>>>>>>>>    Procedure Define_cScrollingClientAreaMixin
98337>>>>>>>>>>>        
98337>>>>>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
98338>>>>>>>>>>>        Set Border_Style to Border_None
98339>>>>>>>>>>>        
98339>>>>>>>>>>>        Property Boolean pbAutoScroll True
98340>>>>>>>>>>>        Property Boolean pbAutoScrollFocus True
98341>>>>>>>>>>>        Property Integer piAutoScrollMarginX 5
98342>>>>>>>>>>>        Property Integer piAutoScrollMarginY 5
98343>>>>>>>>>>>        Property Integer piAutoScrollMinX 0
98344>>>>>>>>>>>        Property Integer piAutoScrollMinY 0
98345>>>>>>>>>>>        Property Boolean pbShowDisabledScrollBar False
98346>>>>>>>>>>>        
98346>>>>>>>>>>>        
98346>>>>>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
98347>>>>>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
98348>>>>>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
98349>>>>>>>>>>>        // keeps track of scrolling
98349>>>>>>>>>>>        Property Integer piCurrentVertScrolled 0
98350>>>>>>>>>>>        Property Integer piCurrentHorzScrolled 0
98351>>>>>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
98352>>>>>>>>>>>        Delegate Set phoScrollingClientArea to Self
98354>>>>>>>>>>>        
98354>>>>>>>>>>>        // set this true to make this a tabbed workspace view (design time)
98354>>>>>>>>>>>        Property Boolean pbTabWorkspaceView False
98355>>>>>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
98355>>>>>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
98356>>>>>>>>>>>    End_Procedure
98357>>>>>>>>>>>    
98357>>>>>>>>>>>    // low level event sent from windows.
98357>>>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
98359>>>>>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
98359>>>>>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
98360>>>>>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
98361>>>>>>>>>>>        If (wParam<0) Begin
98363>>>>>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
98364>>>>>>>>>>>        End
98364>>>>>>>>>>>>
98364>>>>>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
98365>>>>>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
98366>>>>>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
98366>>>>>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
98367>>>>>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
98368>>>>>>>>>>>        // If we have enough Clicks send OnMouseWheel
98368>>>>>>>>>>>        If (iClicks<>0) Begin
98370>>>>>>>>>>>            Send OnMouseWheel iClicks iKeys
98371>>>>>>>>>>>        End
98371>>>>>>>>>>>>
98371>>>>>>>>>>>        // tell windows that we've handled the event.
98371>>>>>>>>>>>        Set Windows_Override_State to True
98372>>>>>>>>>>>    End_Procedure
98373>>>>>>>>>>>    
98373>>>>>>>>>>>    
98373>>>>>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
98373>>>>>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
98375>>>>>>>>>>>        Integer iLineScrollUnit
98375>>>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
98376>>>>>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
98377>>>>>>>>>>>    End_Procedure
98378>>>>>>>>>>>    
98378>>>>>>>>>>>    // should be sent by WM_VSCROLL
98378>>>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
98380>>>>>>>>>>>        Boolean bOk
98380>>>>>>>>>>>        tWinScrollInfo ScrollInfo
98380>>>>>>>>>>>        tWinScrollInfo ScrollInfo
98380>>>>>>>>>>>        Integer iLineScrollUnit
98380>>>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
98381>>>>>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
98382>>>>>>>>>>>        If bOk Begin
98384>>>>>>>>>>>            
98384>>>>>>>>>>>            Case Begin
98384>>>>>>>>>>>                Case (iType=SB_PAGEDOWN)
98386>>>>>>>>>>>                    Send VScroll ScrollInfo.nPage
98387>>>>>>>>>>>                    Case Break
98388>>>>>>>>>>>                
98388>>>>>>>>>>>                Case (iType=SB_PAGEUP)
98391>>>>>>>>>>>                    Send VScroll (-ScrollInfo.nPage)
98392>>>>>>>>>>>                    Case Break
98393>>>>>>>>>>>                
98393>>>>>>>>>>>                Case (iType=SB_LINEDOWN)
98396>>>>>>>>>>>                    Send VScroll iLineScrollUnit
98397>>>>>>>>>>>                    Case Break
98398>>>>>>>>>>>                
98398>>>>>>>>>>>                Case (iType=SB_LINEUP)
98401>>>>>>>>>>>                    Send VScroll (-iLineScrollUnit)
98402>>>>>>>>>>>                    Case Break
98403>>>>>>>>>>>                
98403>>>>>>>>>>>                Case (iType=SB_BOTTOM)
98406>>>>>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
98407>>>>>>>>>>>                    Case Break
98408>>>>>>>>>>>                
98408>>>>>>>>>>>                Case (iType=SB_Top)
98411>>>>>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
98412>>>>>>>>>>>                    Case Break
98413>>>>>>>>>>>                
98413>>>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
98416>>>>>>>>>>>                    Case Break
98417>>>>>>>>>>>                
98417>>>>>>>>>>>                Case (iType=SB_THUMBTRACK)
98420>>>>>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
98421>>>>>>>>>>>                    Case Break
98422>>>>>>>>>>>            Case End
98422>>>>>>>>>>>        End
98422>>>>>>>>>>>>
98422>>>>>>>>>>>    End_Procedure
98423>>>>>>>>>>>    
98423>>>>>>>>>>>    // should be sent by WM_HSCROLL
98423>>>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
98425>>>>>>>>>>>        Boolean bOk
98425>>>>>>>>>>>        tWinScrollInfo ScrollInfo
98425>>>>>>>>>>>        tWinScrollInfo ScrollInfo
98425>>>>>>>>>>>        Integer iLineScrollUnit
98425>>>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
98426>>>>>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
98427>>>>>>>>>>>        If bOk Begin
98429>>>>>>>>>>>            
98429>>>>>>>>>>>            Case Begin
98429>>>>>>>>>>>                Case (iType=SB_PAGEDOWN)
98431>>>>>>>>>>>                    Send hScroll ScrollInfo.nPage
98432>>>>>>>>>>>                    Case Break
98433>>>>>>>>>>>                
98433>>>>>>>>>>>                Case (iType=SB_PAGEUP)
98436>>>>>>>>>>>                    Send hScroll (-ScrollInfo.nPage)
98437>>>>>>>>>>>                    Case Break
98438>>>>>>>>>>>                
98438>>>>>>>>>>>                Case (iType=SB_LINEDOWN)
98441>>>>>>>>>>>                    Send hScroll iLineScrollUnit
98442>>>>>>>>>>>                    Case Break
98443>>>>>>>>>>>                
98443>>>>>>>>>>>                Case (iType=SB_LINEUP)
98446>>>>>>>>>>>                    Send hScroll (-iLineScrollUnit)
98447>>>>>>>>>>>                    Case Break
98448>>>>>>>>>>>                
98448>>>>>>>>>>>                Case (iType=SB_BOTTOM)
98451>>>>>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
98452>>>>>>>>>>>                    Case Break
98453>>>>>>>>>>>                
98453>>>>>>>>>>>                Case (iType=SB_Top)
98456>>>>>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
98457>>>>>>>>>>>                    Case Break
98458>>>>>>>>>>>                
98458>>>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
98461>>>>>>>>>>>                    Case Break
98462>>>>>>>>>>>                
98462>>>>>>>>>>>                Case (iType=SB_THUMBTRACK)
98465>>>>>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
98466>>>>>>>>>>>                    Case Break
98467>>>>>>>>>>>            Case End
98467>>>>>>>>>>>        End
98467>>>>>>>>>>>>
98467>>>>>>>>>>>    End_Procedure
98468>>>>>>>>>>>    
98468>>>>>>>>>>>    
98468>>>>>>>>>>>    // this calls SetScrollInfo with proper info
98468>>>>>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
98470>>>>>>>>>>>        tWinScrollInfo ScrollInfo
98470>>>>>>>>>>>        tWinScrollInfo ScrollInfo
98470>>>>>>>>>>>        Integer iVoid
98470>>>>>>>>>>>        Handle hWnd
98470>>>>>>>>>>>        Boolean bShow
98470>>>>>>>>>>>        
98470>>>>>>>>>>>        Delegate Get Window_Handle to hWnd
98472>>>>>>>>>>>        If (hWnd <> 0) Begin
98474>>>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
98475>>>>>>>>>>>            
98475>>>>>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
98476>>>>>>>>>>>            Get pbShowDisabledScrollBar to bShow
98477>>>>>>>>>>>            If bShow Begin
98479>>>>>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
98480>>>>>>>>>>>            End
98480>>>>>>>>>>>>
98480>>>>>>>>>>>            Move iRangeMin to ScrollInfo.nMin
98481>>>>>>>>>>>            Move iRangeMax to ScrollInfo.nMax
98482>>>>>>>>>>>            Move iPageSize to ScrollInfo.nPage
98483>>>>>>>>>>>            Move 0 to ScrollInfo.nPos
98484>>>>>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
98485>>>>>>>>>>>            
98485>>>>>>>>>>>        End
98485>>>>>>>>>>>>
98485>>>>>>>>>>>    End_Procedure
98486>>>>>>>>>>>    
98486>>>>>>>>>>>    // this wraps GetScrollInfo
98486>>>>>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
98488>>>>>>>>>>>        Boolean bOk
98488>>>>>>>>>>>        Handle hWnd
98488>>>>>>>>>>>        
98488>>>>>>>>>>>        Delegate Get Window_Handle to hWnd
98490>>>>>>>>>>>        If (hWnd <> 0) Begin
98492>>>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
98493>>>>>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
98494>>>>>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
98495>>>>>>>>>>>        End
98495>>>>>>>>>>>>
98495>>>>>>>>>>>        Function_Return bOk
98496>>>>>>>>>>>    End_Function
98497>>>>>>>>>>>    
98497>>>>>>>>>>>    // this wraps SetScrollPos
98497>>>>>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
98499>>>>>>>>>>>        Integer iVoid
98499>>>>>>>>>>>        Handle hWnd
98499>>>>>>>>>>>        
98499>>>>>>>>>>>        Delegate Get Window_Handle to hWnd
98501>>>>>>>>>>>        If (hWnd <> 0) Begin
98503>>>>>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
98504>>>>>>>>>>>        End
98504>>>>>>>>>>>>
98504>>>>>>>>>>>    End_Procedure
98505>>>>>>>>>>>    
98505>>>>>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
98505>>>>>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
98505>>>>>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
98507>>>>>>>>>>>        Send ScrollClientArea
98508>>>>>>>>>>>    End_Procedure
98509>>>>>>>>>>>    
98509>>>>>>>>>>>    // augment to handle the scrolling area initialization.
98509>>>>>>>>>>>    Procedure Add_Focus Handle hoParent
98511>>>>>>>>>>>        Forward Send Add_Focus hoParent
98513>>>>>>>>>>>        // at this the scrolling container and client area should both be paged.
98513>>>>>>>>>>>        // child objects ae also paged with initial anchors applied
98513>>>>>>>>>>>        Send CalculateAutoScrollMinimums
98514>>>>>>>>>>>    End_Procedure
98515>>>>>>>>>>>    
98515>>>>>>>>>>>    Procedure Page Integer iPage
98517>>>>>>>>>>>        Forward Send Page iPage
98519>>>>>>>>>>>        If iPage Begin
98521>>>>>>>>>>>            // at this the scrolling container and client area should both be paged
98521>>>>>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
98521>>>>>>>>>>>            // the child items are paged (else they may get anchored oddly)
98521>>>>>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
98521>>>>>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
98521>>>>>>>>>>>            // before they were really needed. This should be more accurate
98521>>>>>>>>>>>            Send SetScrollBarInfo True 0 0 0
98522>>>>>>>>>>>            Send SetScrollBarInfo False 0 0 0
98523>>>>>>>>>>>        End
98523>>>>>>>>>>>>
98523>>>>>>>>>>>    End_Procedure
98524>>>>>>>>>>>    
98524>>>>>>>>>>>    // determine scrolling minimums and set the client area as required.
98524>>>>>>>>>>>    
98524>>>>>>>>>>>    Procedure CalculateAutoScrollMinimums
98526>>>>>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
98526>>>>>>>>>>>        Integer iAutoMinX iAutoMinY
98526>>>>>>>>>>>        Boolean bAutoScroll
98526>>>>>>>>>>>        Handle hoNext hoFirst
98526>>>>>>>>>>>        
98526>>>>>>>>>>>        Get pbAutoScroll to bAutoScroll
98527>>>>>>>>>>>        Get piAutoScrollMinX to iAutoMinX
98528>>>>>>>>>>>        Get piAutoScrollMinY to iAutoMinY
98529>>>>>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
98530>>>>>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
98531>>>>>>>>>>>        Move (Low(iSiz)) to iAutoMinX
98532>>>>>>>>>>>        Set piMinimumHeight to iAutoMinY
98533>>>>>>>>>>>        Set piMinimumWidth to iAutoMinX
98534>>>>>>>>>>>        
98534>>>>>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
98536>>>>>>>>>>>            
98536>>>>>>>>>>>            Get Next_Level to hoFirst
98537>>>>>>>>>>>            Move hoFirst to hoNext
98538>>>>>>>>>>>            If (hoFirst) Begin
98540>>>>>>>>>>>                Repeat
98540>>>>>>>>>>>>
98540>>>>>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
98541>>>>>>>>>>>                    Get GuiLocation of hoNext to iLoc
98542>>>>>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
98543>>>>>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
98544>>>>>>>>>>>                    Get Next_Focus of hoNext to hoNext
98545>>>>>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
98547>>>>>>>>>>>                
98547>>>>>>>>>>>                If (iAutoMinY=0) Begin
98549>>>>>>>>>>>                    Get piAutoScrollMarginY to iMargin
98550>>>>>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
98551>>>>>>>>>>>                End
98551>>>>>>>>>>>>
98551>>>>>>>>>>>                
98551>>>>>>>>>>>                If (iAutoMinX=0) Begin
98553>>>>>>>>>>>                    Get piAutoScrollMarginX to iMargin
98554>>>>>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
98555>>>>>>>>>>>                    
98555>>>>>>>>>>>                End
98555>>>>>>>>>>>>
98555>>>>>>>>>>>            End
98555>>>>>>>>>>>>
98555>>>>>>>>>>>        End
98555>>>>>>>>>>>>
98555>>>>>>>>>>>        
98555>>>>>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
98555>>>>>>>>>>>        Broadcast Set pbAnchorCreated to False
98557>>>>>>>>>>>        Send ScrollClientArea
98558>>>>>>>>>>>        // after the scroll set up, reinitialize all anchors.
98558>>>>>>>>>>>        Broadcast Send DoCreateAnchors
98560>>>>>>>>>>>    End_Procedure
98561>>>>>>>>>>>    
98561>>>>>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
98561>>>>>>>>>>>    // work of scrolling.
98561>>>>>>>>>>>    
98561>>>>>>>>>>>    Procedure ScrollClientArea
98563>>>>>>>>>>>        Integer iSiz
98563>>>>>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
98563>>>>>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
98563>>>>>>>>>>>        Integer iSzY iSzX iLocX iLocY
98563>>>>>>>>>>>        
98563>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
98565>>>>>>>>>>>        Move (Hi(iSiz)) to iHeight
98566>>>>>>>>>>>        Move (Low(iSiz)) to iWidth
98567>>>>>>>>>>>        
98567>>>>>>>>>>>        // Vertical scrolling
98567>>>>>>>>>>>        
98567>>>>>>>>>>>        Get piMinimumHeight to iOrig
98568>>>>>>>>>>>        Get piMinimumWidth to iWOrig
98569>>>>>>>>>>>        
98569>>>>>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
98571>>>>>>>>>>>            
98571>>>>>>>>>>>            If (iOrig<>0) Begin
98573>>>>>>>>>>>                Get piCurrentVertScrolled to iHCur
98574>>>>>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
98574>>>>>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
98576>>>>>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
98577>>>>>>>>>>>                    Set piCurrentVertScrolled to iHCur
98578>>>>>>>>>>>                End
98578>>>>>>>>>>>>
98578>>>>>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
98580>>>>>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
98581>>>>>>>>>>>                    Send SetScrollBarPosInfo True iHCur
98582>>>>>>>>>>>                End
98582>>>>>>>>>>>>
98582>>>>>>>>>>>                Else Begin
98583>>>>>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
98584>>>>>>>>>>>                End
98584>>>>>>>>>>>>
98584>>>>>>>>>>>            End
98584>>>>>>>>>>>>
98584>>>>>>>>>>>            
98584>>>>>>>>>>>            // Horiz scrolling
98584>>>>>>>>>>>            
98584>>>>>>>>>>>            Get piCurrentHorzScrolled to iWCur
98585>>>>>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
98585>>>>>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
98587>>>>>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
98588>>>>>>>>>>>                Set piCurrentHorzScrolled to iWCur
98589>>>>>>>>>>>            End
98589>>>>>>>>>>>>
98589>>>>>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
98591>>>>>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
98592>>>>>>>>>>>                Send SetScrollBarPosInfo False iWCur
98593>>>>>>>>>>>            End
98593>>>>>>>>>>>>
98593>>>>>>>>>>>            Else Begin
98594>>>>>>>>>>>                Send SetScrollBarInfo False 0 0 0
98595>>>>>>>>>>>            End
98595>>>>>>>>>>>>
98595>>>>>>>>>>>        End
98595>>>>>>>>>>>>
98595>>>>>>>>>>>        
98595>>>>>>>>>>>        // this could change depending on scrollbars appearing or not
98595>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
98597>>>>>>>>>>>        
98597>>>>>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
98597>>>>>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
98597>>>>>>>>>>>        // This is required to make anchors work sensibly
98597>>>>>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
98598>>>>>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
98599>>>>>>>>>>>        Move (-iHCur) to iLocY
98600>>>>>>>>>>>        Move (-iWCur) to iLocX
98601>>>>>>>>>>>        
98601>>>>>>>>>>>        // Allow chance to make modifications
98601>>>>>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
98602>>>>>>>>>>>        
98602>>>>>>>>>>>        Set GuiSize to iSzY iSzX
98603>>>>>>>>>>>        // if we've scrolled, we need to reposition the container
98603>>>>>>>>>>>        Set GuiLocation to iLocY iLocX
98604>>>>>>>>>>>    End_Procedure
98605>>>>>>>>>>>    
98605>>>>>>>>>>>    // note that scrolling never changes the size of the scrolling client.
98605>>>>>>>>>>>    // this way, it does not interfere with anchors.
98605>>>>>>>>>>>    
98605>>>>>>>>>>>    Procedure VScroll Integer iDelta
98607>>>>>>>>>>>        Integer iHeight iCur iOrig iSiz
98607>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
98609>>>>>>>>>>>        Move (hi(iSiz)) to iHeight
98610>>>>>>>>>>>        Get piCurrentVertScrolled to iCur
98611>>>>>>>>>>>        Get piMinimumHeight to iOrig
98612>>>>>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
98614>>>>>>>>>>>            Procedure_Return
98615>>>>>>>>>>>        End
98615>>>>>>>>>>>>
98615>>>>>>>>>>>        // make sure delta is within range
98615>>>>>>>>>>>        If (iDelta+iCur<0) Begin
98617>>>>>>>>>>>            Move (-iCur) to iDelta
98618>>>>>>>>>>>        End
98618>>>>>>>>>>>>
98618>>>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
98621>>>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
98622>>>>>>>>>>>        End
98622>>>>>>>>>>>>
98622>>>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
98625>>>>>>>>>>>        
98625>>>>>>>>>>>        Move (iCur + iDelta) to iCur
98626>>>>>>>>>>>        Set piCurrentVertScrolled to iCur
98627>>>>>>>>>>>        Send SetScrollBarPosInfo True iCur
98628>>>>>>>>>>>        Get GuiLocation to iSiz
98629>>>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)-iDelta) (cast(low(iSiz),Short))
98630>>>>>>>>>>>        Send ScrollClientArea
98631>>>>>>>>>>>    End_Procedure
98632>>>>>>>>>>>    
98632>>>>>>>>>>>    
98632>>>>>>>>>>>    Procedure HScroll Integer iDelta
98634>>>>>>>>>>>        Integer iHeight iCur iOrig iSiz
98634>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
98636>>>>>>>>>>>        Move (low(iSiz)) to iHeight
98637>>>>>>>>>>>        Get piCurrentHorzScrolled to iCur
98638>>>>>>>>>>>        Get piMinimumWidth to iOrig
98639>>>>>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
98641>>>>>>>>>>>            Procedure_Return
98642>>>>>>>>>>>        End
98642>>>>>>>>>>>>
98642>>>>>>>>>>>        If (iDelta+iCur<0) Begin
98644>>>>>>>>>>>            Move (-iCur) to iDelta
98645>>>>>>>>>>>        End
98645>>>>>>>>>>>>
98645>>>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
98648>>>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
98649>>>>>>>>>>>        End
98649>>>>>>>>>>>>
98649>>>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
98652>>>>>>>>>>>        
98652>>>>>>>>>>>        Move (iCur + iDelta) to iCur
98653>>>>>>>>>>>        Set piCurrentHorzScrolled to iCur
98654>>>>>>>>>>>        Send SetScrollBarPosInfo False iCur
98655>>>>>>>>>>>        Get GuiLocation to iSiz
98656>>>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
98657>>>>>>>>>>>        Send ScrollClientArea
98658>>>>>>>>>>>    End_Procedure
98659>>>>>>>>>>>    
98659>>>>>>>>>>>    // make sure client is a 0,0
98659>>>>>>>>>>>    Procedure ScrollHome
98661>>>>>>>>>>>        Send SetVScrollbox SB_TOP 0
98662>>>>>>>>>>>        Send SetHScrollbox SB_TOP 0
98663>>>>>>>>>>>    End_Procedure
98664>>>>>>>>>>>    
98664>>>>>>>>>>>    // get relative GUI location of this object to the parent one passed.
98664>>>>>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
98666>>>>>>>>>>>        Integer ivoid
98666>>>>>>>>>>>        tWinRect Rect0 Rect1
98666>>>>>>>>>>>        tWinRect Rect0 Rect1
98666>>>>>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
98667>>>>>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
98668>>>>>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
98669>>>>>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
98670>>>>>>>>>>>    End_Procedure
98671>>>>>>>>>>>    
98671>>>>>>>>>>>    // This scrolls this object into visual range.
98671>>>>>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
98673>>>>>>>>>>>        Handle hoScrollingContainer
98673>>>>>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
98673>>>>>>>>>>>        Integer iViewHeight iViewWidth
98673>>>>>>>>>>>        Integer iRelLocHeight iRelLocWidth
98673>>>>>>>>>>>        Integer iSize iControlHeight iControlWidth
98673>>>>>>>>>>>        Integer iScroll
98673>>>>>>>>>>>        Integer iMarginX iMarginY
98673>>>>>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
98673>>>>>>>>>>>        
98673>>>>>>>>>>>        Get piAutoScrollMarginX to iMarginX
98674>>>>>>>>>>>        Get piAutoScrollMarginY to iMarginY
98675>>>>>>>>>>>        
98675>>>>>>>>>>>        // the scrolling container
98675>>>>>>>>>>>        Move Self to hoScrollingContainer
98676>>>>>>>>>>>        // the amount the SC is currently scrolled
98676>>>>>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
98677>>>>>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
98678>>>>>>>>>>>        
98678>>>>>>>>>>>        // size of view's client area (this is the viewport area)
98678>>>>>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
98679>>>>>>>>>>>        Move (hi(iSize)) to iViewHeight
98680>>>>>>>>>>>        Move (low(iSize)) to iViewWidth
98681>>>>>>>>>>>        
98681>>>>>>>>>>>        // get this object's location relative to the scrolling container
98681>>>>>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
98682>>>>>>>>>>>        
98682>>>>>>>>>>>        // we expect that the client size is the window size but just in case
98682>>>>>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
98683>>>>>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
98684>>>>>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
98685>>>>>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
98686>>>>>>>>>>>        
98686>>>>>>>>>>>        // the outer size of the control object
98686>>>>>>>>>>>        Get GUIWindowSize of hoControl to iSize
98687>>>>>>>>>>>        Move (hi(iSize)) to iControlHeight
98688>>>>>>>>>>>        Move (low(iSize)) to iControlWidth
98689>>>>>>>>>>>        
98689>>>>>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
98689>>>>>>>>>>>        
98689>>>>>>>>>>>        // Vertical Scroll
98689>>>>>>>>>>>        
98689>>>>>>>>>>>        // Vertical Scroll down
98689>>>>>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
98689>>>>>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
98691>>>>>>>>>>>            
98691>>>>>>>>>>>            // set scroll amount so that the bottom of the control is visible
98691>>>>>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
98692>>>>>>>>>>>            
98692>>>>>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
98692>>>>>>>>>>>            // top of the object appears at the bottom
98692>>>>>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
98694>>>>>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
98695>>>>>>>>>>>            End
98695>>>>>>>>>>>>
98695>>>>>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
98695>>>>>>>>>>>            If (iScroll>0) Begin
98697>>>>>>>>>>>                Send VScroll of hoScrollingContainer iScroll
98698>>>>>>>>>>>            End
98698>>>>>>>>>>>>
98698>>>>>>>>>>>        End
98698>>>>>>>>>>>>
98698>>>>>>>>>>>        // else vertical scroll up
98698>>>>>>>>>>>        // We scroll if the top of the object is not visible.
98698>>>>>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
98701>>>>>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
98701>>>>>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
98702>>>>>>>>>>>            If (iScroll<0) Begin
98704>>>>>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
98705>>>>>>>>>>>            End
98705>>>>>>>>>>>>
98705>>>>>>>>>>>        End
98705>>>>>>>>>>>>
98705>>>>>>>>>>>        
98705>>>>>>>>>>>        // Horizonal Scroll
98705>>>>>>>>>>>        
98705>>>>>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
98705>>>>>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
98707>>>>>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
98708>>>>>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
98710>>>>>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
98711>>>>>>>>>>>            End
98711>>>>>>>>>>>>
98711>>>>>>>>>>>            If (iScroll>0) Begin
98713>>>>>>>>>>>                Send HScroll of hoScrollingContainer iScroll
98714>>>>>>>>>>>            End
98714>>>>>>>>>>>>
98714>>>>>>>>>>>        End
98714>>>>>>>>>>>>
98714>>>>>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
98716>>>>>>>>>>>            // if this can fit by moving all the way to left, do so.
98716>>>>>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
98718>>>>>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
98719>>>>>>>>>>>            End
98719>>>>>>>>>>>>
98719>>>>>>>>>>>            Else Begin
98720>>>>>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
98721>>>>>>>>>>>            End
98721>>>>>>>>>>>>
98721>>>>>>>>>>>            If (iScroll<0) Begin
98723>>>>>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
98724>>>>>>>>>>>            End
98724>>>>>>>>>>>>
98724>>>>>>>>>>>        End
98724>>>>>>>>>>>>
98724>>>>>>>>>>>        
98724>>>>>>>>>>>        
98724>>>>>>>>>>>    End_Procedure
98725>>>>>>>>>>>    
98725>>>>>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
98725>>>>>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
98727>>>>>>>>>>>        Boolean bScrollOnFocus
98727>>>>>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
98728>>>>>>>>>>>        If bScrollOnFocus Begin
98730>>>>>>>>>>>            Send ScrollObjectInRange hoControl
98731>>>>>>>>>>>        End
98731>>>>>>>>>>>>
98731>>>>>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
98733>>>>>>>>>>>    End_Procedure
98734>>>>>>>>>>>    
98734>>>>>>>>>>>    
98734>>>>>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
98736>>>>>>>>>>>        Boolean bCenter
98736>>>>>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
98737>>>>>>>>>>>        Function_Return bCenter
98738>>>>>>>>>>>    End_Function
98739>>>>>>>>>>>    
98739>>>>>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
98741>>>>>>>>>>>        Boolean bTabWorkspaceView
98741>>>>>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
98742>>>>>>>>>>>        If bTabWorkspaceView Begin
98744>>>>>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
98745>>>>>>>>>>>        End
98745>>>>>>>>>>>>
98745>>>>>>>>>>>    End_Procedure
98746>>>>>>>>>>>    
98746>>>>>>>>>>>    Function ParentView Returns Handle
98748>>>>>>>>>>>        Function_Return (Parent(Parent(Self)))
98749>>>>>>>>>>>    End_Function
98750>>>>>>>>>>>    
98750>>>>>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
98752>>>>>>>>>>>        Integer iSize iMax iDiff
98752>>>>>>>>>>>        Handle hoView
98752>>>>>>>>>>>        Boolean bCenter bModal
98752>>>>>>>>>>>        Get ParentView to hoView
98753>>>>>>>>>>>        Get Block_Mouse_State of hoView to bModal
98754>>>>>>>>>>>        If not bModal Begin
98756>>>>>>>>>>>            Get CenterTabWorkspaceView to bCenter
98757>>>>>>>>>>>            Get GuiSize of hoView to iSize
98758>>>>>>>>>>>            Get piMaxSize of hoView to iMax
98759>>>>>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
98760>>>>>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
98762>>>>>>>>>>>                If bCenter Begin
98764>>>>>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
98765>>>>>>>>>>>                End
98765>>>>>>>>>>>>
98765>>>>>>>>>>>                Move (Low(iMax)) to iWidth
98766>>>>>>>>>>>            End
98766>>>>>>>>>>>>
98766>>>>>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
98768>>>>>>>>>>>                If bCenter Begin
98770>>>>>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
98771>>>>>>>>>>>                    Move (iLocy min 25) to  iLocY
98772>>>>>>>>>>>                End
98772>>>>>>>>>>>>
98772>>>>>>>>>>>                Move (Hi(imax)) to iHeight
98773>>>>>>>>>>>            End
98773>>>>>>>>>>>>
98773>>>>>>>>>>>        End
98773>>>>>>>>>>>>
98773>>>>>>>>>>>    End_Procedure
98774>>>>>>>>>>>    
98774>>>>>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
98774>>>>>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
98774>>>>>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
98774>>>>>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
98774>>>>>>>>>>>    // This should almost always yield the right answer.
98774>>>>>>>>>>>    // This is called by the scrolling container's end_constructor
98774>>>>>>>>>>>    Procedure AutoSetTabWorkspaceView
98776>>>>>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
98776>>>>>>>>>>>        Handle hoParent
98776>>>>>>>>>>>        Integer iSize
98776>>>>>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
98777>>>>>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
98779>>>>>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
98780>>>>>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
98780>>>>>>>>>>>            // change this after the commandbar is paged.
98780>>>>>>>>>>>            If (bTabView) Begin
98782>>>>>>>>>>>                Get ParentView to hoParent
98783>>>>>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
98784>>>>>>>>>>>                If (bIsView) Begin
98786>>>>>>>>>>>                    // set this as a tab workspace view
98786>>>>>>>>>>>                    Set pbTabWorkspaceView to True
98787>>>>>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
98787>>>>>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
98787>>>>>>>>>>>                    Set pbAutoScroll to True
98788>>>>>>>>>>>                    
98788>>>>>>>>>>>                End
98788>>>>>>>>>>>>
98788>>>>>>>>>>>            End
98788>>>>>>>>>>>>
98788>>>>>>>>>>>        End
98788>>>>>>>>>>>>
98788>>>>>>>>>>>    End_Procedure
98789>>>>>>>>>>>    
98789>>>>>>>>>>>End_Class
98790>>>>>>>>>>>
98790>>>>>>>>>>>// Container scrolling class support. Nothing in here is public
98790>>>>>>>>>>>Class cScrollingContainerMixin is a Mixin
98791>>>>>>>>>>>    
98791>>>>>>>>>>>    Procedure Define_cScrollingContainerMixin
98793>>>>>>>>>>>        Forward Set Border_Style to Border_None
98795>>>>>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
98796>>>>>>>>>>>        Forward Set peAnchors to anAll
98798>>>>>>>>>>>        
98798>>>>>>>>>>>        // forcing scrollbars right away seems to make painting better
98798>>>>>>>>>>>        Set Window_Style WS_HSCROLL to True
98799>>>>>>>>>>>        Set Window_Style WS_VSCROLL to True
98800>>>>>>>>>>>        
98800>>>>>>>>>>>        Property Handle phoScrollingClientArea 0
98801>>>>>>>>>>>    End_Procedure
98802>>>>>>>>>>>    
98802>>>>>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
98802>>>>>>>>>>>    Procedure Set peAnchors Integer eAnchors
98804>>>>>>>>>>>    End_Procedure
98805>>>>>>>>>>>    
98805>>>>>>>>>>>    // if a border style is set, it will not work. We won't let that happen
98805>>>>>>>>>>>    Procedure Set Border_Style Integer eStyle
98807>>>>>>>>>>>    End_Procedure
98808>>>>>>>>>>>    
98808>>>>>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
98808>>>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
98810>>>>>>>>>>>        Handle hoClient
98810>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
98811>>>>>>>>>>>        If hoClient Begin
98813>>>>>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
98814>>>>>>>>>>>        End
98814>>>>>>>>>>>>
98814>>>>>>>>>>>    End_Procedure
98815>>>>>>>>>>>    
98815>>>>>>>>>>>    // should be sent by WM_VSCROLL
98815>>>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
98817>>>>>>>>>>>        Handle hoClient
98817>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
98818>>>>>>>>>>>        If hoClient Begin
98820>>>>>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
98821>>>>>>>>>>>        End
98821>>>>>>>>>>>>
98821>>>>>>>>>>>    End_Procedure
98822>>>>>>>>>>>    
98822>>>>>>>>>>>    // should be sent by WM_HSCROLL
98822>>>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
98824>>>>>>>>>>>        Handle hoClient
98824>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
98825>>>>>>>>>>>        If hoClient Begin
98827>>>>>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
98828>>>>>>>>>>>        End
98828>>>>>>>>>>>>
98828>>>>>>>>>>>    End_Procedure
98829>>>>>>>>>>>    
98829>>>>>>>>>>>    // augmented to adjust its size to the size of the parent client area.
98829>>>>>>>>>>>    // After this is set, anchors will handle any further resizing.
98829>>>>>>>>>>>    Procedure Page Integer iState
98831>>>>>>>>>>>        Integer iSiz iHeight iWidth
98831>>>>>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
98831>>>>>>>>>>>        Boolean bGroup
98831>>>>>>>>>>>        Handle hoClient
98831>>>>>>>>>>>        If (iState =1) Begin
98833>>>>>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
98835>>>>>>>>>>>            // We have special code to support groups because they
98835>>>>>>>>>>>            // draw a border inside of the client rectangle
98835>>>>>>>>>>>            If bGroup Begin
98837>>>>>>>>>>>                Get Physical_FontSize to iFontSize
98838>>>>>>>>>>>                Move (Hi(iFontSize)) to iTop
98839>>>>>>>>>>>                Move 2 to iLeft
98840>>>>>>>>>>>                Move 2 to iRight
98841>>>>>>>>>>>                Move 2 to iBottom
98842>>>>>>>>>>>            End
98842>>>>>>>>>>>>
98842>>>>>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
98842>>>>>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
98842>>>>>>>>>>>            // makes anchors work properly with unpaged tab-pages
98842>>>>>>>>>>>            Delegate Get GetContainerClientSize to iSiz
98844>>>>>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
98845>>>>>>>>>>>            Set GuiLocation to iTop iLeft
98846>>>>>>>>>>>            Send Adjust_Logicals
98847>>>>>>>>>>>        End
98847>>>>>>>>>>>>
98847>>>>>>>>>>>        Forward Send Page iState
98849>>>>>>>>>>>    End_Procedure
98850>>>>>>>>>>>    
98850>>>>>>>>>>>    Procedure End_Construct_Object
98852>>>>>>>>>>>        Handle hoClient
98852>>>>>>>>>>>        Forward Send End_Construct_Object
98854>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
98855>>>>>>>>>>>        If (hoClient) Begin
98857>>>>>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
98858>>>>>>>>>>>        End
98858>>>>>>>>>>>>
98858>>>>>>>>>>>    End_Procedure
98859>>>>>>>>>>>    
98859>>>>>>>>>>>End_Class
98860>>>>>>>>>
98860>>>>>>>>>Class cScrollingClientArea is a Container3d
98861>>>>>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
98862>>>>>>>>>    Procedure Construct_Object
98864>>>>>>>>>        Forward Send Construct_Object
98866>>>>>>>>>        Send Define_cScrollingClientAreaMixin
98867>>>>>>>>>    End_Procedure
98868>>>>>>>>>End_Class
98869>>>>>>>>>
98869>>>>>>>>>
98869>>>>>>>>>
98869>>>>>>>>>Class cScrollingContainer is a Container3d
98870>>>>>>>>>    Import_Class_Protocol cScrollingContainerMixin
98871>>>>>>>>>    Procedure Construct_Object
98873>>>>>>>>>        Forward Send Construct_Object
98875>>>>>>>>>        Send Define_cScrollingContainerMixin
98876>>>>>>>>>    End_Procedure
98877>>>>>>>>>End_Class
98878>>>>>>>Use cRDCModalPanel.pkg
98878>>>>>>>Use cRDCForm.pkg
Including file: cRDCForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCForm.pkg)
98878>>>>>>>>>//****************************************************************************
98878>>>>>>>>>// $Module type: Class
98878>>>>>>>>>// $Module name: cForm
98878>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
98878>>>>>>>>>// Created     : 2014-03-17 @ 12:34
98878>>>>>>>>>//
98878>>>>>>>>>// Description :
98878>>>>>>>>>//
98878>>>>>>>>>// $Rev History:
98878>>>>>>>>>//    2014-03-17  Module header created
98878>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
98878>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
98878>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
98878>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
98878>>>>>>>>>// in the help folder for more details.
98878>>>>>>>>>//
98878>>>>>>>>>//****************************************************************************
98878>>>>>>>>>Use Windows.pkg
98878>>>>>>>>>
98878>>>>>>>>>Class cFormIdleHandler is a cIdleHandler
98879>>>>>>>>>    Procedure Construct_Object
98881>>>>>>>>>        Forward Send Construct_Object
98883>>>>>>>>>
98883>>>>>>>>>    End_Procedure
98884>>>>>>>>>
98884>>>>>>>>>    Procedure OnIdle
98886>>>>>>>>>        Delegate Send DoUpdate
98888>>>>>>>>>    End_Procedure
98889>>>>>>>>>
98889>>>>>>>>>End_Class
98890>>>>>>>>>
98890>>>>>>>>>Class cRDCForm is a Form
98891>>>>>>>>>
98891>>>>>>>>>    Procedure Construct_Object
98893>>>>>>>>>        Forward Send Construct_Object
98895>>>>>>>>>
98895>>>>>>>>>        Property Boolean pbAutoEnable False
98896>>>>>>>>>
98896>>>>>>>>>        Property Boolean pbEnabled True
98897>>>>>>>>>
98897>>>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cFormIdleHandler)))
98898>>>>>>>>>
98898>>>>>>>>>        Set Label_Justification_mode to JMode_Right
98899>>>>>>>>>        Set Label_Col_Offset to 2
98900>>>>>>>>>        Set Label_Row_Offset to 0
98901>>>>>>>>>    End_Procedure
98902>>>>>>>>>
98902>>>>>>>>>    Procedure End_Construct_Object
98904>>>>>>>>>        String sTooltip sStatus_Help
98904>>>>>>>>>
98904>>>>>>>>>        Forward Send End_Construct_Object
98906>>>>>>>>>
98906>>>>>>>>>        Get psToolTip   to sTooltip
98907>>>>>>>>>        Get Status_Help to sStatus_Help
98908>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
98910>>>>>>>>>            Set psToolTip to sStatus_Help
98911>>>>>>>>>        End
98911>>>>>>>>>>
98911>>>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
98914>>>>>>>>>            Set Status_Help to sTooltip
98915>>>>>>>>>        End
98915>>>>>>>>>>
98915>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
98916>>>>>>>>>    End_Procedure
98917>>>>>>>>>
98917>>>>>>>>>    Procedure DoUpdate
98919>>>>>>>>>        If (pbAutoEnable(Self) = False) Begin
98921>>>>>>>>>            Procedure_Return
98922>>>>>>>>>        End
98922>>>>>>>>>>
98922>>>>>>>>>        Set Enabled_State to (IsEnabled(Self))
98923>>>>>>>>>    End_Procedure
98924>>>>>>>>>
98924>>>>>>>>>    Function IsEnabled Returns Boolean
98926>>>>>>>>>        Boolean bEnabled
98926>>>>>>>>>        Get pbEnabled to bEnabled
98927>>>>>>>>>        Function_Return bEnabled
98928>>>>>>>>>    End_Function
98929>>>>>>>>>
98929>>>>>>>>>    // Enable the idle handler timer when the object is activated
98929>>>>>>>>>    Procedure Activating
98931>>>>>>>>>        Forward Send Activating
98933>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
98934>>>>>>>>>    End_Procedure
98935>>>>>>>>>
98935>>>>>>>>>    // Disable the idle handler when the object is deactivated
98935>>>>>>>>>    Procedure Deactivating
98937>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
98938>>>>>>>>>        Forward Send Deactivating
98940>>>>>>>>>    End_Procedure
98941>>>>>>>>>
98941>>>>>>>>>End_Class
98942>>>>>>>Use cRDCComboForm.pkg
98942>>>>>>>Use cRDCButton.pkg
98942>>>>>>>Use cRDCHeaderGroup.pkg
98942>>>>>>>Use cDbDriverSettingsForm.pkg
Including file: cDbDriverSettingsForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbDriverSettingsForm.pkg)
98942>>>>>>>>>//****************************************************************************
98942>>>>>>>>>// $Module type: Class
98942>>>>>>>>>// $Module name: cDbDriverSettingsForm
98942>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International
98942>>>>>>>>>// Created     : 2014-03-17 @ 12:34
98942>>>>>>>>>//
98942>>>>>>>>>// Description :
98942>>>>>>>>>//
98942>>>>>>>>>// $Rev History:
98942>>>>>>>>>//    2014-03-17  Module header created
98942>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
98942>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
98942>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
98942>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
98942>>>>>>>>>// in the help folder for more details.
98942>>>>>>>>>//
98942>>>>>>>>>//****************************************************************************
98942>>>>>>>>>Use Windows.pkg
98942>>>>>>>>>Use seq_chnl.pkg
98942>>>>>>>>>
98942>>>>>>>>>Class cDbDriverSettingsForm is a Form
98943>>>>>>>>>
98943>>>>>>>>>    Procedure Construct_Object
98945>>>>>>>>>        Forward Send Construct_Object
98947>>>>>>>>>
98947>>>>>>>>>        Property Boolean private.pbDriverLoadingError False
98948>>>>>>>>>        
98948>>>>>>>>>        Set Label_Col_Offset to 2
98949>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
98950>>>>>>>>>        Set Size to 11 125 
98951>>>>>>>>>        // We use these settings and not enabled_state to be able
98951>>>>>>>>>        // to show tooltips.
98951>>>>>>>>>        Set Color to clBtnFace
98952>>>>>>>>>        Set Focus_Mode to NonFocusable
98953>>>>>>>>>        Set peAnchors to anTopLeftRight
98954>>>>>>>>>
98954>>>>>>>>>        Property String psDriverIniFile ""
98955>>>>>>>>>    End_Procedure
98956>>>>>>>>>
98956>>>>>>>>>    Procedure Set psToolTip String sText
98958>>>>>>>>>        If (Trim(sText) = "") Begin
98960>>>>>>>>>            Move "No info available" to sText
98961>>>>>>>>>        End
98961>>>>>>>>>>
98961>>>>>>>>>        Forward Set psToolTip to sText
98963>>>>>>>>>    End_Procedure
98964>>>>>>>>>
98964>>>>>>>>>    Function psToolTip Returns String
98966>>>>>>>>>        String sTooltip sSearchValue
98966>>>>>>>>>
98966>>>>>>>>>        Get Label to sSearchValue
98967>>>>>>>>>        Get ExtractIniFileComment sSearchValue to sTooltip
98968>>>>>>>>>
98968>>>>>>>>>        Function_Return sTooltip
98969>>>>>>>>>    End_Function
98970>>>>>>>>>
98970>>>>>>>>>    Procedure SetValue String sDriver String sLabel Integer iAttribute
98972>>>>>>>>>        Integer iDriver
98972>>>>>>>>>        String sValue
98972>>>>>>>>>
98972>>>>>>>>>        // Sadly driver API attributes are only supported by the CLI-drivers,
98972>>>>>>>>>        // and the Pervasive driver is not amongst them. So do nothing if Pervasive.
98972>>>>>>>>>        If (sDriver <> DFBTRDRV_ID and sDriver <> DATAFLEX_ID) Begin
98974>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
98975>>>>>>>>>            Get DriverIndex of ghoSQLConnectionHandler sDriver to iDriver
98976>>>>>>>>>            Set private.pbDriverLoadingError to (iDriver = -1)
98977>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
98978>>>>>>>>>            If (iDriver <= 0) Begin
98980>>>>>>>>>                Procedure_Return
98981>>>>>>>>>            End
98981>>>>>>>>>>
98981>>>>>>>>>            // Set indicator to false prior asking for the driver attribute.
98981>>>>>>>>>            // This way we can decide to show the object or not, based on success/failure.
98981>>>>>>>>>            Move False to Err
98982>>>>>>>>>            Get_Attribute iAttribute of iDriver to sValue
98985>>>>>>>>>            If (sValue = "0") Begin
98987>>>>>>>>>                Move "0 (False)" to sValue
98988>>>>>>>>>            End
98988>>>>>>>>>>
98988>>>>>>>>>            If (sValue = "1") Begin
98990>>>>>>>>>                Move "1 (True)"  to sValue
98991>>>>>>>>>            End
98991>>>>>>>>>>
98991>>>>>>>>>            Set Value to sValue
98992>>>>>>>>>
98992>>>>>>>>>            Move (Replace("DF_DRIVER_", Uppercase(sLabel), "")) to sLabel
98993>>>>>>>>>            // Its a bit annoying reading all caps, so "proper" case
98993>>>>>>>>>            // all labels (DF_DRIVER_XXX values).
98993>>>>>>>>>            Get Propercase sLabel to sLabel
98994>>>>>>>>>            Set Label to sLabel
98995>>>>>>>>>
98995>>>>>>>>>            Get ExtractIniFileComment sLabel to sValue
98996>>>>>>>>>            Set Status_Help to sValue
98997>>>>>>>>>            Set psToolTip to sValue
98998>>>>>>>>>        End
98998>>>>>>>>>>
98998>>>>>>>>>    End_Procedure
98999>>>>>>>>>
98999>>>>>>>>>    // Pass a driver ini filename with path & a comment value to search for.
98999>>>>>>>>>    // Returns: The comments in the file as a string.
98999>>>>>>>>>    Function ExtractIniFileComment String sSearchValue Returns String
99001>>>>>>>>>        String sIniFile sValue sRetval sComment sCommentMarker
99001>>>>>>>>>        Boolean bCommentRow bStart
99001>>>>>>>>>        Integer iCh
99001>>>>>>>>>
99001>>>>>>>>>        Get psDriverIniFile to sIniFile
99002>>>>>>>>>        Move ";" to sCommentMarker
99003>>>>>>>>>        Get Seq_Open_Input_Channel sIniFile to iCh
99004>>>>>>>>>        While (SeqEof = False)
99008>>>>>>>>>            Readln channel iCh sValue
99010>>>>>>>>>            Move (Trim(sValue)) to sValue
99011>>>>>>>>>
99011>>>>>>>>>            // Check for a ";" at pos 1 & if the line contains the passed search value (driver attribute).
99011>>>>>>>>>            Move (Left(sValue, 1)) to sComment
99012>>>>>>>>>            If (bStart = False) Begin
99014>>>>>>>>>                Move (sComment = sCommentMarker and Lowercase(sValue) contains Lowercase(sSearchValue)) to bStart
99015>>>>>>>>>            End
99015>>>>>>>>>>
99015>>>>>>>>>            If (bStart = True) Begin
99017>>>>>>>>>                // Have we read past end of the comment for the driver attribute? If so, quit.
99017>>>>>>>>>                If (sComment <> sCommentMarker) Begin
99019>>>>>>>>>                    Move True to SeqEof
99020>>>>>>>>>                End
99020>>>>>>>>>>
99020>>>>>>>>>                Else Begin
99021>>>>>>>>>                    Move (sComment = sCommentMarker) to bCommentRow
99022>>>>>>>>>                    If (bCommentRow = True) Begin
99024>>>>>>>>>                        Move (Replace(sCommentMarker, sValue, "")) to sValue
99025>>>>>>>>>
99025>>>>>>>>>                        // Replace all double spaces with a single space character.
99025>>>>>>>>>                        Move (Replaces("  ", sValue, " ")) to sValue
99026>>>>>>>>>
99026>>>>>>>>>                        If (sRetval = "") Begin
99028>>>>>>>>>                            Move sValue to sRetval
99029>>>>>>>>>                        End
99029>>>>>>>>>>
99029>>>>>>>>>                        Else Begin
99030>>>>>>>>>                            Move (sRetval + " " + sValue) to sRetval
99031>>>>>>>>>                        End
99031>>>>>>>>>>
99031>>>>>>>>>                    End
99031>>>>>>>>>>
99031>>>>>>>>>                End
99031>>>>>>>>>>
99031>>>>>>>>>            End
99031>>>>>>>>>>
99031>>>>>>>>>        Loop
99032>>>>>>>>>>
99032>>>>>>>>>        Send Seq_Close_Channel iCh
99033>>>>>>>>>
99033>>>>>>>>>CompilerWarnings Off
99033>>>>>>>>>        // Replaces all double spaces with a single space character.
99033>>>>>>>>>        // The Replaces function doesn't quite work for this.
99033>>>>>>>>>        Repeat
99033>>>>>>>>>>
99033>>>>>>>>>            Replace "  " in sRetval with " "
99035>>>>>>>>>        Until (FindErr)
99037>>>>>>>>>        
99037>>>>>>>>>        Function_Return sRetval
99038>>>>>>>>>    End_Function
99039>>>>>>>>>CompilerWarnings On
99039>>>>>>>>>
99039>>>>>>>>>    Function Propercase String sText Returns String 
99041>>>>>>>>>        String[] sDelimiters
99042>>>>>>>>>        Integer iPos
99042>>>>>>>>>        
99042>>>>>>>>>        //Lowercase everything and we'll handle uppercase by exception
99042>>>>>>>>>        Move (Lowercase(sText)) to sText
99043>>>>>>>>>        
99043>>>>>>>>>        Move " " to sDelimiters[SizeOfArray(sDelimiters)]
99044>>>>>>>>>        Move "-" to sDelimiters[SizeOfArray(sDelimiters)]
99045>>>>>>>>>        Move "_" to sDelimiters[SizeOfArray(sDelimiters)]
99046>>>>>>>>>        
99046>>>>>>>>>        For iPos from 1 to (Length(sText)) // 1 based loop to match MID and OVERSTRIKE
99052>>>>>>>>>>
99052>>>>>>>>>            //If the previous character is a space, uppercase the current one (alway upper the first char)
99052>>>>>>>>>            If ((iPos = 1) or (SearchArray( Mid(sText, 1, (iPos - 1)), sDelimiters) <> -1)) ;                Move (Overstrike( Uppercase(Mid(sText, 1, iPos)), sText, iPos )) to sText
99055>>>>>>>>>        Loop
99056>>>>>>>>>>
99056>>>>>>>>>        
99056>>>>>>>>>        Function_Return sText
99057>>>>>>>>>    End_Function
99058>>>>>>>>>
99058>>>>>>>>>End_Class
99059>>>>>>>Use cDbUpdateFunctionLibrary.pkg
99059>>>>>>>
99059>>>>>>>Register_Procedure psOrgToolTip String sTooltip
99059>>>>>>>
99059>>>>>>>Object oDriverSettings_dg is a cRDCModalPanel
99061>>>>>>>    Set Size to 291 345
99062>>>>>>>    Set Label to "Driver Configuration File Info"
99063>>>>>>>    Set Location to 2 2
99064>>>>>>>    Set Maximize_Icon to False
99065>>>>>>>    Set Locate_Mode to CENTER_ON_PARENT
99066>>>>>>>    Set Icon to "DriverSettings1.ico"
99067>>>>>>>    
99067>>>>>>>    Property String psDriverID MSSQLDRV_ID
99069>>>>>>>    Property Boolean pbDriverLoadingError False
99071>>>>>>>    
99071>>>>>>>    Object oCancel_Btn is a cRDCButton
99073>>>>>>>        Set Label    to "&Close"
99074>>>>>>>        Set Location to 269 287
99075>>>>>>>        Set peAnchors to anBottomRight
99076>>>>>>>
99076>>>>>>>        Procedure OnClick
99079>>>>>>>            Send Close_Panel
99080>>>>>>>        End_Procedure
99081>>>>>>>
99081>>>>>>>    End_Object
99082>>>>>>>
99082>>>>>>>    Object oDriver_cf is a cRDCComboForm
99084>>>>>>>        Set Label to "Database Driver"
99085>>>>>>>        Set Size to 13 80
99086>>>>>>>        Set Location to 8 90
99087>>>>>>>        Set Form_Border to 0
99088>>>>>>>        Set Label_Col_Offset to 2
99089>>>>>>>        Set Label_Justification_Mode to JMode_Right
99090>>>>>>>        Set Status_Help to "Database driver."
99091>>>>>>>        Set Enabled_State to False
99092>>>>>>>        Set Skip_State to True
99093>>>>>>>
99093>>>>>>>        Procedure Combo_Fill_List
99096>>>>>>>            Send Combo_Add_Item DATAFLEX_ID
99097>>>>>>>            Send Combo_Add_Item DFBTRDRV_ID
99098>>>>>>>            Send Combo_Add_Item ODBC_DRV_ID
99099>>>>>>>            Send Combo_Add_Item MSSQLDRV_ID
99100>>>>>>>            Send Combo_Add_Item DB2_DRV_ID
99101>>>>>>>        End_Procedure
99102>>>>>>>
99102>>>>>>>    End_Object
99103>>>>>>>
99103>>>>>>>    Object oDriverFileName_cf is a cRDCForm
99105>>>>>>>        Set Label to "Database Driver File"
99106>>>>>>>        Set Size to 12 193
99107>>>>>>>        Set Location to 24 90
99108>>>>>>>        Set Label_Col_Offset to 2
99109>>>>>>>        Set Label_Justification_Mode to JMode_Right
99110>>>>>>>        Set Status_Help to "Database driver to be used when creating new tables."
99111>>>>>>>        Set Color to clBtnFace
99112>>>>>>>        Set Focus_Mode to NonFocusable
99113>>>>>>>        Set peAnchors to anTopLeftRight
99114>>>>>>>
99114>>>>>>>        Procedure OnChange
99117>>>>>>>            String sDriverID sValue sDriverIntFileName sTooltip sPath
99117>>>>>>>
99117>>>>>>>            Forward Send OnChange
99119>>>>>>>            Get Value to sValue
99120>>>>>>>            Set Status_Help to sValue
99121>>>>>>>
99121>>>>>>>            Get psDriverID to sDriverID
99122>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
99124>>>>>>>                Get DatabaseDriverIniFilePath sDriverID to sPath
99125>>>>>>>                If (sPath <> "") Begin
99127>>>>>>>                    Move (sPath + sDriverID + ".int") to sDriverIntFileName
99128>>>>>>>                End
99128>>>>>>>>
99128>>>>>>>            End
99128>>>>>>>>
99128>>>>>>>            Else Begin
99129>>>>>>>                Move sDriverID to sDriverIntFileName
99130>>>>>>>            End
99130>>>>>>>>
99130>>>>>>>
99130>>>>>>>            Set Value of oDriverIniFile_fm to sDriverIntFileName
99131>>>>>>>            Get psOrgToolTip of oDriverIniFile_fm to sTooltip
99132>>>>>>>            Set Status_Help of oDriverIniFile_fm to (sTooltip * sDriverIntFileName)
99133>>>>>>>
99133>>>>>>>            // In case driver attribute objects already exists; destroy them
99133>>>>>>>            Broadcast Send Destroy    of oScrollingClientArea
99135>>>>>>>            // Then recreate them to show driver attributes
99135>>>>>>>            Send DoReadDriverSettings of oScrollingClientArea sDriverID
99136>>>>>>>        End_Procedure  
99137>>>>>>>        
99137>>>>>>>    End_Object
99138>>>>>>>
99138>>>>>>>    Object oDriverInfo_btn is a cRDCButton
99140>>>>>>>        Set Size to 13 50
99141>>>>>>>        Set Location to 24 287
99142>>>>>>>        Set Label to "Version Info"
99143>>>>>>>        Set Status_Help to "Shows a dialog with driver properties and SQL client software version(s), license info and more."
99144>>>>>>>        Set peAnchors to anTopRight
99145>>>>>>>
99145>>>>>>>        Procedure OnClick
99148>>>>>>>            Object oSysInfoDialog is a SysInfoDialog
99150>>>>>>>            End_Object
99151>>>>>>>
99151>>>>>>>            Send Popup of oSysInfoDialog
99152>>>>>>>        End_Procedure
99153>>>>>>>    End_Object
99154>>>>>>>
99154>>>>>>>    Object oDriverIniFile_fm is a cRDCForm
99156>>>>>>>        Set Size to 13 193
99157>>>>>>>        Set Location to 39 90
99158>>>>>>>        Set Label_Col_Offset to 2
99159>>>>>>>        Set Label_Justification_Mode to JMode_Right
99160>>>>>>>        Set Label to "Driver Configuration File"
99161>>>>>>>        Set peAnchors to anTopLeftRight
99162>>>>>>>        Set Color to clBtnFace
99163>>>>>>>        Set Focus_Mode to NonFocusable
99164>>>>>>>        Property String psOrgToolTip "The file is the first found in the DF_OPEN_PATH path string."
99166>>>>>>>        Set Status_Help to (psOrgToolTip(Self))
99167>>>>>>>    End_Object
99168>>>>>>>
99168>>>>>>>    Object oOpenDriverFile_Btn is a cRDCButton
99170>>>>>>>        Set Size to 13 50
99171>>>>>>>        Set Label to "Edit File"
99172>>>>>>>        Set Location to 39 287
99173>>>>>>>        Set Status_Help to "Opens the driver configuration file that contains configuration settings that are used when tables are restructured, in Notepad."
99174>>>>>>>        Set psImage to "ActionEdit1.ico"
99175>>>>>>>        Set peAnchors to anTopRight
99176>>>>>>>        Set pbAutoEnable to True
99177>>>>>>>
99177>>>>>>>        Procedure OnClick
99180>>>>>>>            String sFileName
99180>>>>>>>            Get Value of oDriverIniFile_fm to sFileName
99181>>>>>>>            If (sFileName <> DATAFLEX_ID) Begin
99183>>>>>>>                Runprogram Background "Notepad.exe" sFileName
99184>>>>>>>            End
99184>>>>>>>>
99184>>>>>>>            Else Begin
99185>>>>>>>                Send Info_Box "Sorry, there exist no driver ini file for the DataFlex database driver, so nothing to show here."
99186>>>>>>>            End
99186>>>>>>>>
99186>>>>>>>        End_Procedure   
99187>>>>>>>        
99187>>>>>>>        Function IsEnabled Returns Boolean
99190>>>>>>>            String sFileName
99190>>>>>>>            Get Value of oDriverFileName_cf to sFileName
99191>>>>>>>            Function_Return (sFileName <> "")
99192>>>>>>>        End_Function
99193>>>>>>>
99193>>>>>>>    End_Object
99194>>>>>>>
99194>>>>>>>    Object oDumpDriverData_Btn is a cRDCButton
99196>>>>>>>        Set Size to 13 50
99197>>>>>>>        Set Label to "Dump"
99198>>>>>>>        Set Location to 54 233
99199>>>>>>>        Set peAnchors to anTopRight
99200>>>>>>>        Set psToolTip to "Dumps the current status of the Connectivity Kit driver to an ASCII disk file."
99201>>>>>>>        Set psImage to "ActionExport1.ico"
99202>>>>>>>        Set pbAutoEnable to True
99203>>>>>>>        
99203>>>>>>>        Procedure OnClick
99206>>>>>>>            Handle hoCLI
99206>>>>>>>            String sDriver sPath sFileName
99206>>>>>>>            Integer iRetval
99206>>>>>>>
99206>>>>>>>            Get psDriverID to sDriver
99207>>>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLI
99208>>>>>>>            Set psDriverID of hoCLI  to sDriver
99209>>>>>>>            If (sDriver = DATAFLEX_ID or sDriver = DFBTRDRV_ID) Begin
99211>>>>>>>                Send Destroy of hoCLI
99212>>>>>>>                Send Info_Box "Sorry, no attributes can be shown for the selected database driver."
99213>>>>>>>                Procedure_Return
99214>>>>>>>            End
99214>>>>>>>>
99214>>>>>>>
99214>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
99215>>>>>>>            Get vFolderFormat sPath to sPath
99216>>>>>>>            Move (sDriver + "dump.txt") to sFileName
99217>>>>>>>            Send DumpStatus of hoCLI (sPath + sFileName)
99218>>>>>>>            Send Destroy of hoCLI
99219>>>>>>>
99219>>>>>>>            Send vShellExecute "open" sFileName "" sPath
99220>>>>>>>            Sleep 1
99221>>>>>>>            Get vDeleteFile (sPath + sFileName) to iRetval
99222>>>>>>>        End_Procedure
99223>>>>>>>
99223>>>>>>>        Function IsEnabled Returns Boolean
99226>>>>>>>            String sFileName
99226>>>>>>>            Boolean bDriverLoadingError 
99226>>>>>>>            Get pbDriverLoadingError to bDriverLoadingError
99227>>>>>>>            Get Value of oDriverFileName_cf to sFileName
99228>>>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
99229>>>>>>>        End_Function
99230>>>>>>>
99230>>>>>>>    End_Object
99231>>>>>>>
99231>>>>>>>    Object oReset_Btn is a cRDCButton
99233>>>>>>>        Set Size to 13 50
99234>>>>>>>        Set Label to "Refresh"
99235>>>>>>>        Set Status_Help to "If you edit the driver configuration file, the display of attributes above needs to be refreshed. Click here to refresh."
99236>>>>>>>        Set Location to 54 287
99237>>>>>>>        Set psImage to "ActionRefresh1.ico"
99238>>>>>>>        Set peAnchors to anTopRight
99239>>>>>>>        Set pbAutoEnable to True
99240>>>>>>>
99240>>>>>>>        Procedure OnClick
99243>>>>>>>            String sDriver
99243>>>>>>>            Get psDriverID to sDriver
99244>>>>>>>            Unload_Driver sDriver
99245>>>>>>>            Load_Driver sDriver
99246>>>>>>>            Send Info_Box "This dialog needs to be re-opened to display the refreshed values. Dialog will now close and you need to re-open it manually."
99247>>>>>>>            Send Close_Panel
99248>>>>>>>        End_Procedure
99249>>>>>>>
99249>>>>>>>        Function IsEnabled Returns Boolean
99252>>>>>>>            String sFileName
99252>>>>>>>            Boolean bDriverLoadingError 
99252>>>>>>>            Get pbDriverLoadingError to bDriverLoadingError
99253>>>>>>>            Get Value of oDriverFileName_cf to sFileName
99254>>>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
99255>>>>>>>        End_Function
99256>>>>>>>
99256>>>>>>>    End_Object
99257>>>>>>>
99257>>>>>>>    Object oDriverSetings_grp is a cRDCHeaderGroup
99259>>>>>>>        Set Size to 125 328
99260>>>>>>>        Set Location to 74 9
99261>>>>>>>        Set psImage to "DriverSettings1.ico"
99262>>>>>>>        Set Label to "Driver Configuration File Settings"   
99263>>>>>>>        Set psNote to "Hover the mouse over an attribute field to read information about it."
99264>>>>>>>        Set peAnchors to anAll
99265>>>>>>>
99265>>>>>>>        Object oInvisible_Container is a Container3d
99267>>>>>>>            Set Size to 100 327
99268>>>>>>>            Set Location to 24 0
99269>>>>>>>            Set Border_Style to Border_None
99270>>>>>>>            Set peAnchors to anAll
99271>>>>>>>    
99271>>>>>>>            Object oScrollingContainer is a cScrollingContainer
99273>>>>>>>               
99273>>>>>>>                Object oScrollingClientArea is a cScrollingClientArea
99275>>>>>>>
99275>>>>>>>                    // Just fill the array with all available driver attributes from Cli.pkg,
99275>>>>>>>                    // and one object will automatically be created for each attribute
99275>>>>>>>                    // for the current driver by the DoReadDriverSettings procedure.
99275>>>>>>>                    Function GeneralDriverAttributes Returns String[]
99278>>>>>>>                        String[] sAttributesArray
99279>>>>>>>    
99279>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_ASCII             |CI1101" to sAttributesArray[SizeOfArray(sAttributesArray)]
99280>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_ASCII            |CI1102" to sAttributesArray[SizeOfArray(sAttributesArray)]
99281>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_NUMERIC           |CI1103" to sAttributesArray[SizeOfArray(sAttributesArray)]
99282>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_NUMERIC          |CI1104" to sAttributesArray[SizeOfArray(sAttributesArray)]
99283>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATE              |CI1105" to sAttributesArray[SizeOfArray(sAttributesArray)]
99284>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATE             |CI1106" to sAttributesArray[SizeOfArray(sAttributesArray)]
99285>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_TEXT              |CI1107" to sAttributesArray[SizeOfArray(sAttributesArray)]
99286>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_TEXT             |CI1108" to sAttributesArray[SizeOfArray(sAttributesArray)]
99287>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_BINARY            |CI1109" to sAttributesArray[SizeOfArray(sAttributesArray)]
99288>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_BINARY           |CI1110" to sAttributesArray[SizeOfArray(sAttributesArray)]
99289>>>>>>>                        Move "DF_DRIVER_DUMMY_ZERO_DATE_VALUE             |CI1111" to sAttributesArray[SizeOfArray(sAttributesArray)]
99290>>>>>>>                        Move "DF_DRIVER_MAX_ACTIVE_STATEMENTS             |CI1112" to sAttributesArray[SizeOfArray(sAttributesArray)]
99291>>>>>>>                        Move "DF_DRIVER_CACHE_PATH                        |CI1113" to sAttributesArray[SizeOfArray(sAttributesArray)]
99292>>>>>>>                        Move "DF_DRIVER_DRIVER_DECIMAL_SEPARATOR          |CI1114" to sAttributesArray[SizeOfArray(sAttributesArray)]
99293>>>>>>>                        Move "DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT    |CI1115" to sAttributesArray[SizeOfArray(sAttributesArray)]
99294>>>>>>>                        Move "DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR        |CI1116" to sAttributesArray[SizeOfArray(sAttributesArray)]
99295>>>>>>>                        Move "DF_DRIVER_APPLICATION_CHARACTER_FORMAT      |CI1117" to sAttributesArray[SizeOfArray(sAttributesArray)]
99296>>>>>>>                        Move "DF_DRIVER_DRIVER_DATE_FORMAT                |CI1118" to sAttributesArray[SizeOfArray(sAttributesArray)]
99297>>>>>>>                        Move "DF_DRIVER_LAST_ERROR_TEXT                   |CI1119" to sAttributesArray[SizeOfArray(sAttributesArray)]
99298>>>>>>>                        Move "DF_DRIVER_DRIVER_DATE_SEPARATOR             |CI1120" to sAttributesArray[SizeOfArray(sAttributesArray)]
99299>>>>>>>    
99299>>>>>>>                        // Exception to the rule!
99299>>>>>>>                        // Someone - in its infinite wisdome - decided that the keyword in the ini file should be "DFConnectionId",
99299>>>>>>>                        // and not "Connection_ID" that is the API attribute name. This brakes the cDriverSettingsForm tooltip logic.
99299>>>>>>>                        // We fix it by changing the attribute constant string here (removed the _ (underscore) before the "ID" part.
99299>>>>>>>                        Move "DF_DRIVER_CONNECTIONID                      |CI1121" to sAttributesArray[SizeOfArray(sAttributesArray)]
99300>>>>>>>                        Move "DF_DRIVER_IGNORE_UCASE_SUPPORT              |CI1122" to sAttributesArray[SizeOfArray(sAttributesArray)]
99301>>>>>>>                        Move "DF_DRIVER_CONNECTION_ID_STRING              |CI1123" to sAttributesArray[SizeOfArray(sAttributesArray)]
99302>>>>>>>    
99302>>>>>>>                        Move "DF_DRIVER_IGNORE_WARNINGS                   |CI1124" to sAttributesArray[SizeOfArray(sAttributesArray)]
99303>>>>>>>                        Move "DF_DRIVER_USE_DF_LOCKERROR                  |CI1126" to sAttributesArray[SizeOfArray(sAttributesArray)]
99304>>>>>>>                        Move "DF_DRIVER_FIND_CACHE_TIMEOUT                |CI1128" to sAttributesArray[SizeOfArray(sAttributesArray)]
99305>>>>>>>                        Move "DF_DRIVER_JIT_TRESHOLD                      |CI1130" to sAttributesArray[SizeOfArray(sAttributesArray)]
99306>>>>>>>                        Move "DF_DRIVER_TRUNCATE_BINARY_ZEROES            |CI1132" to sAttributesArray[SizeOfArray(sAttributesArray)]
99307>>>>>>>                        Move "DF_DRIVER_ERROR_DEBUG_MODE                  |CI1134" to sAttributesArray[SizeOfArray(sAttributesArray)]
99308>>>>>>>                        Move "DF_DRIVER_USE_CACHE                         |CI1136" to sAttributesArray[SizeOfArray(sAttributesArray)]
99309>>>>>>>                        Move "DF_DRIVER_REPORT_CACHE_ERRORS               |CI1138" to sAttributesArray[SizeOfArray(sAttributesArray)]
99310>>>>>>>                        Move "DF_DRIVER_USE_CACHE_EXPIRATION              |CI1140" to sAttributesArray[SizeOfArray(sAttributesArray)]
99311>>>>>>>                        Move "DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE       |CI1142" to sAttributesArray[SizeOfArray(sAttributesArray)]
99312>>>>>>>                        Move "DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING    |CI1144" to sAttributesArray[SizeOfArray(sAttributesArray)]
99313>>>>>>>                        Move "DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS       |CI1146" to sAttributesArray[SizeOfArray(sAttributesArray)]
99314>>>>>>>                        Move "DF_DRIVER_SILENT_LOGIN                      |CI1148" to sAttributesArray[SizeOfArray(sAttributesArray)]
99315>>>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_TO_RECNUM             |CI1150" to sAttributesArray[SizeOfArray(sAttributesArray)]
99316>>>>>>>                        Move "DF_DRIVER_CONNECTION_ID_OPTIONS             |CI1152" to sAttributesArray[SizeOfArray(sAttributesArray)]
99317>>>>>>>                        Move "DF_DRIVER_NUMBER_CONNECTION_IDS             |CI1154" to sAttributesArray[SizeOfArray(sAttributesArray)]
99318>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATETIME          |CI1155" to sAttributesArray[SizeOfArray(sAttributesArray)]
99319>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATETIME         |CI1156" to sAttributesArray[SizeOfArray(sAttributesArray)]
99320>>>>>>>                        Move "DF_DRIVER_MATCH_CLIENT_SERVER_VERSION       |CI1158" to sAttributesArray[SizeOfArray(sAttributesArray)]
99321>>>>>>>                        Move "DF_DRIVER_SQLSERVER_CLIENT_VERSION          |CI1160" to sAttributesArray[SizeOfArray(sAttributesArray)]
99322>>>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE            |CI1168" to sAttributesArray[SizeOfArray(sAttributesArray)]
99323>>>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_SQLTYPE             |CI1169" to sAttributesArray[SizeOfArray(sAttributesArray)]
99324>>>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE        |CI1170" to sAttributesArray[SizeOfArray(sAttributesArray)]
99325>>>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE         |CI1171" to sAttributesArray[SizeOfArray(sAttributesArray)]
99326>>>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE           |CI1172" to sAttributesArray[SizeOfArray(sAttributesArray)]
99327>>>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_SQLTYPE            |CI1173" to sAttributesArray[SizeOfArray(sAttributesArray)]
99328>>>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE            |CI1174" to sAttributesArray[SizeOfArray(sAttributesArray)]
99329>>>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE             |CI1175" to sAttributesArray[SizeOfArray(sAttributesArray)]
99330>>>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE          |CI1176" to sAttributesArray[SizeOfArray(sAttributesArray)]
99331>>>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE           |CI1177" to sAttributesArray[SizeOfArray(sAttributesArray)]
99332>>>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA |CI1178" to sAttributesArray[SizeOfArray(sAttributesArray)]
99333>>>>>>>                        Move "DF_DRIVER_LOGIN_ON_OPEN                     |CI1180" to sAttributesArray[SizeOfArray(sAttributesArray)]
99334>>>>>>>                        Move "DF_DRIVER_MINIMUM_CLIENT_VERSION            |CI1182" to sAttributesArray[SizeOfArray(sAttributesArray)]
99335>>>>>>>    
99335>>>>>>>                        // Sort items alphabetically
99335>>>>>>>                        Move (SortArray(sAttributesArray)) to sAttributesArray
99336>>>>>>>                        Function_Return sAttributesArray
99337>>>>>>>                    End_Function
99338>>>>>>>    
99338>>>>>>>                    Function SplitValue String sValue Integer ByRef iAttribute Returns String
99341>>>>>>>                        String sAttribute sTmp
99341>>>>>>>                        Integer iPos
99341>>>>>>>    
99341>>>>>>>                        Move (Pos("|", sValue)) to iPos
99342>>>>>>>                        Move (Left(sValue, (iPos -1))) to sAttribute
99343>>>>>>>                        Move (Mid(sValue, Length(sValue), iPos)) to sTmp
99344>>>>>>>                        Move (Trim(sAttribute)) to sAttribute
99345>>>>>>>                        Move (Eval(sTmp)) to iAttribute
99346>>>>>>>    
99346>>>>>>>                        Function_Return sAttribute
99347>>>>>>>                    End_Function
99348>>>>>>>    
99348>>>>>>>                    // Note: Creates dynamic objects.
99348>>>>>>>                    // They are not being destroyed by this method.
99348>>>>>>>                    // It is the reponsibility of the calling method to do that,
99348>>>>>>>                    // prior calling this method.
99348>>>>>>>                    Procedure DoReadDriverSettings String sDriver
99351>>>>>>>                        Integer iLocW iLocH iHfactor iFirstLineOffset iCount iItems iAttribute
99351>>>>>>>                        Handle ho hoParent
99351>>>>>>>                        String[] sAttributesArray
99352>>>>>>>                        String sValue sAttribute sDriverIniFile 
99352>>>>>>>                        Boolean bDriverLoadingError
99352>>>>>>>    
99352>>>>>>>                        Move (Self) to hoParent
99353>>>>>>>                        Move 13  to iHfactor // Height offset between form
99354>>>>>>>                        Move 120 to iLocW
99355>>>>>>>                        Move 10  to iLocH                            
99356>>>>>>>                        Move  0  to iFirstLineOffset // Offset from the top for the very first object.
99357>>>>>>>    
99357>>>>>>>                        Get Value of oDriverIniFile_fm to sDriverIniFile
99358>>>>>>>                        If (Trim(sDriverIniFile) = "") Begin
99360>>>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
99361>>>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
99362>>>>>>>                            Set Location of ho to iLocH (iLocW + 30)
99363>>>>>>>                            Set Label of ho to "No Driver Configuration File found!"
99364>>>>>>>                            Set Value of ho to "No attributes to display..."   
99365>>>>>>>                            Procedure_Return
99366>>>>>>>                        End
99366>>>>>>>>
99366>>>>>>>                            
99366>>>>>>>                        // Driver attributes aren't supported by the Pervasive driver,
99366>>>>>>>                        // so notify and quite.
99366>>>>>>>                        If (sDriver = DFBTRDRV_ID or sDriver = DATAFLEX_ID) Begin
99368>>>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
99369>>>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
99370>>>>>>>                            Set Location of ho to iLocH (iLocW + 30)
99371>>>>>>>                            Set Label of ho to "Query of driver attributes unsupported!"
99372>>>>>>>                            Set Value of ho to "Sorry, no attributes to display"
99373>>>>>>>                            Procedure_Return
99374>>>>>>>                        End
99374>>>>>>>>
99374>>>>>>>    
99374>>>>>>>                        Get GeneralDriverAttributes to sAttributesArray
99375>>>>>>>                        Move (SizeOfArray(sAttributesArray)) to iItems
99376>>>>>>>                        Decrement iItems
99377>>>>>>>                        Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE 
99378>>>>>>>                        Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE  // Invalid driver value
99379>>>>>>>    
99379>>>>>>>                        For iCount from 0 to iItems
99385>>>>>>>>
99385>>>>>>>                            Move sAttributesArray[iCount] to sValue
99386>>>>>>>                            Get SplitValue sValue (&iAttribute) to sAttribute
99387>>>>>>>    
99387>>>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho 
99388>>>>>>>                            Set psDriverIniFile of ho to sDriverIniFile
99389>>>>>>>                            Send SetValue of ho sDriver sAttribute iAttribute
99390>>>>>>>                            Get private.pbDriverLoadingError of ho to bDriverLoadingError
99391>>>>>>>                            If (bDriverLoadingError = True) Begin
99393>>>>>>>                                Set Label of ho to "Driver could not be loaded!"   
99394>>>>>>>                                If (Trim(sDriverIniFile) = "") Begin
99396>>>>>>>                                    Set Value of ho to "Driver .dll file not found!"
99397>>>>>>>                                End
99397>>>>>>>>
99397>>>>>>>                                Else Begin
99398>>>>>>>                                    Set Value of ho to "No attributes to display..."   
99399>>>>>>>                                End
99399>>>>>>>>
99399>>>>>>>                                Set psToolTip of ho to "Check that the database engine for the selected driver is installed and is running correctly!"  
99400>>>>>>>                                Delegate Set pbDriverLoadingError to True
99402>>>>>>>                                Move iItems to iCount // We're out of here.   
99403>>>>>>>                                Move False to Err
99404>>>>>>>                            End
99404>>>>>>>>
99404>>>>>>>                            If (Err = True) Begin
99406>>>>>>>                                Send Destroy of ho
99407>>>>>>>                            End
99407>>>>>>>>
99407>>>>>>>                            Else Begin
99408>>>>>>>                                If (iCount = 0) Begin
99410>>>>>>>                                    Move (iFirstLineOffset + iLocH) to iLocH
99411>>>>>>>                                End
99411>>>>>>>>
99411>>>>>>>                                Set Location of ho to iLocH (iLocW + 30)
99412>>>>>>>                                Move (iLocH + iHfactor) to iLocH
99413>>>>>>>                            End
99413>>>>>>>>
99413>>>>>>>                        Loop
99414>>>>>>>>
99414>>>>>>>    
99414>>>>>>>                        Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE
99415>>>>>>>                        Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
99416>>>>>>>                    End_Procedure
99417>>>>>>>    
99417>>>>>>>                End_Object
99418>>>>>>>
99418>>>>>>>            End_Object
99419>>>>>>>    
99419>>>>>>>        End_Object
99420>>>>>>>
99420>>>>>>>    End_Object
99421>>>>>>>
99421>>>>>>>    Object oInfo_edt is a cRichEdit
99423>>>>>>>        Set Size to 49 328
99424>>>>>>>        Set Location to 213 9
99425>>>>>>>        Set Label to "General Connectivity Kit Information:"
99426>>>>>>>        Set Value to "It is possible to configure the behavior of a Connectivity Kit through configuration files. Configuration files can be located anywhere in DFPATH. In general, one configuration file per install is enough. There are situations where there is a need to have different configurations for different deploy environments on one machine/network. In that case the configuration file should be placed in the deployment environment rather than in the overall DataFlex environment."
99427>>>>>>>        Set Skip_State to True
99428>>>>>>>        Set Read_Only_State to True
99429>>>>>>>        Set pbItalics to True
99430>>>>>>>        Set peAnchors to anBottomLeftRight
99431>>>>>>>
99431>>>>>>>        Procedure DoIndent
99434>>>>>>>            Integer iTwipsPerInch iCurrentIndent
99434>>>>>>>        
99434>>>>>>>            // number of twips per inch
99434>>>>>>>            Move 1440 to iTwipsPerInch
99435>>>>>>>        
99435>>>>>>>            Set piSpacingBefore to (1440 * 0.05)
99436>>>>>>>            // indent 0.1 inches from current indentation
99436>>>>>>>            Get piParagraphIndent to iCurrentIndent
99437>>>>>>>            Set piParagraphIndent to (iCurrentIndent + (iTwipsPerInch * 0.1))
99438>>>>>>>        End_Procedure
99439>>>>>>>        Send DoIndent
99440>>>>>>>
99440>>>>>>>    End_Object
99441>>>>>>>
99441>>>>>>>    Procedure Activating
99444>>>>>>>        Forward Send Activating
99446>>>>>>>        Send Cursor_Ready of Cursor_Control
99447>>>>>>>    End_Procedure
99448>>>>>>>
99448>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
99449>>>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
99450>>>>>>>End_Object
99451>>>>>>>
99451>>>>>>>// General purpose access method for the dialog above:
99451>>>>>>>Procedure PopupDriverSettings String sDriverID 
99454>>>>>>>    Handle ho
99454>>>>>>>    String sDriverFile sPath
99454>>>>>>>
99454>>>>>>>    Send Cursor_Wait of Cursor_Control
99455>>>>>>>    Move (oDriverSettings_dg(Self)) to ho
99456>>>>>>>    Set psDriverID of ho to sDriverID
99457>>>>>>>    Set pbDriverLoadingError of ho to False
99458>>>>>>>
99458>>>>>>>    Set Value of (oDriver_cf(ho)) to sDriverID
99459>>>>>>>    Get DatabaseDriverPath sDriverID to sPath
99460>>>>>>>    If (sPath <> "") Begin
99462>>>>>>>        Move (sDriverID + ".dll")  to sDriverFile
99463>>>>>>>    End
99463>>>>>>>>
99463>>>>>>>    Set Value of (oDriverFileName_cf(ho)) to (sPath + sDriverFile)
99464>>>>>>>    Send Cursor_Ready of Cursor_Control
99465>>>>>>>
99465>>>>>>>    Send Popup of ho
99466>>>>>>>End_Procedure
99467>>>>>>>
99467>>>>>>>Function DatabaseDriverPath String sDriverID Returns String
99470>>>>>>>    String sPath sDriverFileName
99470>>>>>>>
99470>>>>>>>    Move "" to sPath
99471>>>>>>>    If (sDriverID = DATAFLEX_ID) Begin
99473>>>>>>>        Function_Return sPath
99474>>>>>>>    End                   
99474>>>>>>>>
99474>>>>>>>    
99474>>>>>>>    Move (sDriverID + ".dll") to sDriverFileName
99475>>>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
99476>>>>>>>    
99476>>>>>>>    Function_Return sPath
99477>>>>>>>End_Function      
99478>>>>>>>
99478>>>>>>>Function DatabaseDriverIniFilePath String sDriverID Returns String
99481>>>>>>>    String sPath sDriverFileName
99481>>>>>>>
99481>>>>>>>    Move "" to sPath
99482>>>>>>>    If (sDriverID = DATAFLEX_ID) Begin
99484>>>>>>>        Function_Return sPath
99485>>>>>>>    End                   
99485>>>>>>>>
99485>>>>>>>    
99485>>>>>>>    Move (sDriverID + ".int") to sDriverFileName
99486>>>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
99487>>>>>>>    
99487>>>>>>>    Function_Return sPath
99488>>>>>>>End_Function      
99489>>>>>Use CreateDatabase.dg
Including file: CreateDatabase.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CreateDatabase.dg)
99489>>>>>>>Use Windows.pkg
99489>>>>>>>Use cRDCModalPanel.pkg
99489>>>>>>>Use cRDCForm.pkg 
99489>>>>>>>Use cRDCComboForm.pkg
99489>>>>>>>Use cRDCSuggestionIniForm.pkg
Including file: cRDCSuggestionIniForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCSuggestionIniForm.pkg)
99489>>>>>>>>>//****************************************************************************
99489>>>>>>>>>// $Module type: Class
99489>>>>>>>>>// $Module name: cRDCSuggestionIniForm
99489>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
99489>>>>>>>>>// Web-site    : http://www.rdctools.com
99489>>>>>>>>>// Created     : 2018-09-05 @ 09:50 (Military date format: YY-MM-DD)
99489>>>>>>>>>//
99489>>>>>>>>>// Description : The class consists of a variant of DataAccess Worldwide's cSuggestionFormList
99489>>>>>>>>>//               It has the added ability to save/retrieve values to the workspace .ws file.
99489>>>>>>>>>//
99489>>>>>>>>>// $Rev History:
99489>>>>>>>>>//    2018-09-05  Module header created
99489>>>>>>>>>//
99489>>>>>>>>>//****************************************************************************
99489>>>>>>>>>Use Windows.pkg
99489>>>>>>>>>Use Windows.pkg
99489>>>>>>>>>Use WinSuggestion.pkg
Including file: WinSuggestion.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\WinSuggestion.pkg)
99489>>>>>>>>>>>Use Windows.pkg
99489>>>>>>>>>>>Use tWinStructs.pkg
99489>>>>>>>>>>>Use tSuggestion.pkg
Including file: tSuggestion.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\tSuggestion.pkg)
99489>>>>>>>>>>>>>// struct used for suggestion forms, representing an item of data
99489>>>>>>>>>>>>>Enum_List 
99489>>>>>>>>>>>>>    Define smFind
99489>>>>>>>>>>>>>    Define smValidationTable
99489>>>>>>>>>>>>>    Define smCustom
99489>>>>>>>>>>>>>End_Enum_List
99489>>>>>>>>>>>>>
99489>>>>>>>>>>>>>Struct tSuggestion
99489>>>>>>>>>>>>>    String sRowId
99489>>>>>>>>>>>>>    String[] aValues
99489>>>>>>>>>>>>>End_Struct
99489>>>>>>>>>>>>>
99489>>>>>>>>>>>Use cTimer.pkg
Including file: cTimer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cTimer.pkg)
99489>>>>>>>>>>>>>// This supercedes the DFTimer class.
99489>>>>>>>>>>>>>// It is simpler and more flexible
99489>>>>>>>>>>>>>
99489>>>>>>>>>>>>>Use Dftimer.pkg // we still use the Timer Manager classes and global objects
Including file: Dftimer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Dftimer.pkg)
99489>>>>>>>>>>>>>>>Use LanguageText.pkg
99489>>>>>>>>>>>>>>>Use Windows.pkg
99489>>>>>>>>>>>>>>>Use WinUser.pkg
99489>>>>>>>>>>>>>>>
99489>>>>>>>>>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Handle  hWnd ;    Longptr idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Longptr     // return type is UINT_PTR
99490>>>>>>>>>>>>>>>
99490>>>>>>>>>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Handle  hWnd ;    Longptr idTimer ;    Returns Integer
99491>>>>>>>>>>>>>>>
99491>>>>>>>>>>>>>>>// This global integer holds the ID of the object
99491>>>>>>>>>>>>>>>// that manages all timers.
99491>>>>>>>>>>>>>>>Integer giTimerManager
99491>>>>>>>>>>>>>>>
99491>>>>>>>>>>>>>>>// This class is used to store the object IDs
99491>>>>>>>>>>>>>>>// of the active timer objects. It augments
99491>>>>>>>>>>>>>>>// the Destroy_Object procedure to notify
99491>>>>>>>>>>>>>>>// the DFTimerManager to kill all its active
99491>>>>>>>>>>>>>>>// timers.
99491>>>>>>>>>>>>>>>// NOTE: This class looks very much like the
99491>>>>>>>>>>>>>>>// Set class. I didn't want to use Set because
99491>>>>>>>>>>>>>>>// Remove_Element shifts items which I don't
99491>>>>>>>>>>>>>>>// want to happen because item numbers are used
99491>>>>>>>>>>>>>>>// as timerIDs.
99491>>>>>>>>>>>>>>>
99491>>>>>>>>>>>>>>>Class TimersArray is an Array
99492>>>>>>>>>>>>>>>    
99492>>>>>>>>>>>>>>>    Function Find_Object Integer iObj Returns Integer
99494>>>>>>>>>>>>>>>        Integer iMax
99494>>>>>>>>>>>>>>>        Integer iItem
99494>>>>>>>>>>>>>>>        Integer iValue
99494>>>>>>>>>>>>>>>        Get Item_count to iMax
99495>>>>>>>>>>>>>>>        Decrement iMax
99496>>>>>>>>>>>>>>>        For iItem from 1 to iMax
99502>>>>>>>>>>>>>>>>
99502>>>>>>>>>>>>>>>            Get Integer_Value iItem to iValue
99503>>>>>>>>>>>>>>>            If (iValue = iObj) ;                Function_Return iItem
99506>>>>>>>>>>>>>>>        Loop
99507>>>>>>>>>>>>>>>>
99507>>>>>>>>>>>>>>>        Function_Return -1
99508>>>>>>>>>>>>>>>    End_Function
99509>>>>>>>>>>>>>>>    
99509>>>>>>>>>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
99511>>>>>>>>>>>>>>>        Integer iItem
99511>>>>>>>>>>>>>>>        Get Find_Object iObj to iItem
99512>>>>>>>>>>>>>>>        If (iItem < 0) Begin
99514>>>>>>>>>>>>>>>            Get Find_Object 0 to iItem
99515>>>>>>>>>>>>>>>            If (iItem < 0) ;                Get Item_Count to iItem
99518>>>>>>>>>>>>>>>        End
99518>>>>>>>>>>>>>>>>
99518>>>>>>>>>>>>>>>        Set Array_Value iItem to iObj
99519>>>>>>>>>>>>>>>        Procedure_Return iItem
99520>>>>>>>>>>>>>>>    End_Procedure
99521>>>>>>>>>>>>>>>    
99521>>>>>>>>>>>>>>>    Procedure Remove_Object Integer iObj
99523>>>>>>>>>>>>>>>        Integer iItem
99523>>>>>>>>>>>>>>>        Get Find_Object iObj to iItem
99524>>>>>>>>>>>>>>>        If (iItem > 0) ;            Set Array_Value iItem to 0
99527>>>>>>>>>>>>>>>    End_Procedure
99528>>>>>>>>>>>>>>>    
99528>>>>>>>>>>>>>>>    Procedure Destroy_Object
99530>>>>>>>>>>>>>>>        Delegate Send Kill_All_Timers
99532>>>>>>>>>>>>>>>        Forward Send Destroy_Object
99534>>>>>>>>>>>>>>>    End_Procedure
99535>>>>>>>>>>>>>>>    
99535>>>>>>>>>>>>>>>End_Class
99536>>>>>>>>>>>>>>>
99536>>>>>>>>>>>>>>>// This class is the actual timer manager
99536>>>>>>>>>>>>>>>// A timer will be created when Message Set_Timer_Active_State
99536>>>>>>>>>>>>>>>// has been send. This message needs two arguments. The first
99536>>>>>>>>>>>>>>>// is the objectID of the object to receive the timer event,
99536>>>>>>>>>>>>>>>// and the second is state. The object which ID has been passed,
99536>>>>>>>>>>>>>>>// needs to have a Timeout property to return the timeout for the
99536>>>>>>>>>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
99536>>>>>>>>>>>>>>>// timer event occurs.
99536>>>>>>>>>>>>>>>// The objectID of the Object will be placed in an array which contains
99536>>>>>>>>>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
99536>>>>>>>>>>>>>>>// is the itemnumber of the object in the array.
99536>>>>>>>>>>>>>>>//
99536>>>>>>>>>>>>>>>Class DFTimerManager is a DfBaseControl
99537>>>>>>>>>>>>>>>    
99537>>>>>>>>>>>>>>>    Procedure Construct_Object
99539>>>>>>>>>>>>>>>        
99539>>>>>>>>>>>>>>>        Forward Send Construct_Object
99541>>>>>>>>>>>>>>>        
99541>>>>>>>>>>>>>>>        Set Visible_State to False
99542>>>>>>>>>>>>>>>        
99542>>>>>>>>>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
99543>>>>>>>>>>>>>>>        Set External_Message WM_TIMER to OnTimer
99544>>>>>>>>>>>>>>>        
99544>>>>>>>>>>>>>>>        Object TimersArray is a TimersArray
99546>>>>>>>>>>>>>>>            Set Array_Value 0 to -9999 // So we don't use item 0
99547>>>>>>>>>>>>>>>        End_Object
99548>>>>>>>>>>>>>>>        
99548>>>>>>>>>>>>>>>        Move Self to giTimerManager
99549>>>>>>>>>>>>>>>        
99549>>>>>>>>>>>>>>>    End_Procedure
99550>>>>>>>>>>>>>>>    
99550>>>>>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
99552>>>>>>>>>>>>>>>        Integer iTimerID
99552>>>>>>>>>>>>>>>        Integer iTimeout
99552>>>>>>>>>>>>>>>        Integer iResult
99552>>>>>>>>>>>>>>>        Integer iSet
99552>>>>>>>>>>>>>>>        DWord   nResult
99552>>>>>>>>>>>>>>>        Handle  hWnd
99552>>>>>>>>>>>>>>>        
99552>>>>>>>>>>>>>>>        // Get the handle of this object
99552>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
99553>>>>>>>>>>>>>>>        If (not(hWnd)) Begin
99555>>>>>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
99556>>>>>>>>>>>>>>>>
99556>>>>>>>>>>>>>>>            Procedure_Return
99557>>>>>>>>>>>>>>>        End
99557>>>>>>>>>>>>>>>>
99557>>>>>>>>>>>>>>>        
99557>>>>>>>>>>>>>>>        // Test if handle is valid. If not, we leave.
99557>>>>>>>>>>>>>>>        If (not(IsWindow(hWnd))) ;            Procedure_Return
99560>>>>>>>>>>>>>>>        
99560>>>>>>>>>>>>>>>        Move (TimersArray(Self)) to iSet
99561>>>>>>>>>>>>>>>        
99561>>>>>>>>>>>>>>>        If (iSet) Begin
99563>>>>>>>>>>>>>>>            
99563>>>>>>>>>>>>>>>            // Let's create or modify a timer
99563>>>>>>>>>>>>>>>            If iState Begin
99565>>>>>>>>>>>>>>>                
99565>>>>>>>>>>>>>>>                // Get the exising to new TimerID
99565>>>>>>>>>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
99566>>>>>>>>>>>>>>>                
99566>>>>>>>>>>>>>>>                // Set/Modify the timer
99566>>>>>>>>>>>>>>>                Get Timeout of iObj to iTimeout
99567>>>>>>>>>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
99568>>>>>>>>>>>>>>>                If not iResult Begin
99570>>>>>>>>>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
99571>>>>>>>>>>>>>>>>
99571>>>>>>>>>>>>>>>                    Procedure_Return
99572>>>>>>>>>>>>>>>                End
99572>>>>>>>>>>>>>>>>
99572>>>>>>>>>>>>>>>                
99572>>>>>>>>>>>>>>>            End
99572>>>>>>>>>>>>>>>>
99572>>>>>>>>>>>>>>>            
99572>>>>>>>>>>>>>>>            // Let's kill an existing timer
99572>>>>>>>>>>>>>>>            Else Begin
99573>>>>>>>>>>>>>>>                
99573>>>>>>>>>>>>>>>                // Look up the object in the set
99573>>>>>>>>>>>>>>>                Get Find_Object of iSet iObj to iTimerID
99574>>>>>>>>>>>>>>>                
99574>>>>>>>>>>>>>>>                If (iTimerID = -1) ;                    Procedure_Return
99577>>>>>>>>>>>>>>>                
99577>>>>>>>>>>>>>>>                // Kill the timer
99577>>>>>>>>>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
99578>>>>>>>>>>>>>>>                If not iResult Begin
99580>>>>>>>>>>>>>>>                    Move (GetLastError()) to nResult
99581>>>>>>>>>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * String(nResult) - "!")
99582>>>>>>>>>>>>>>>>
99582>>>>>>>>>>>>>>>                    Procedure_Return
99583>>>>>>>>>>>>>>>                End
99583>>>>>>>>>>>>>>>>
99583>>>>>>>>>>>>>>>                
99583>>>>>>>>>>>>>>>                // Remove the objectID
99583>>>>>>>>>>>>>>>                Send Remove_Object to iSet iObj
99584>>>>>>>>>>>>>>>            End
99584>>>>>>>>>>>>>>>>
99584>>>>>>>>>>>>>>>        End
99584>>>>>>>>>>>>>>>>
99584>>>>>>>>>>>>>>>    End_Procedure
99585>>>>>>>>>>>>>>>    
99585>>>>>>>>>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
99587>>>>>>>>>>>>>>>        Integer iResult
99587>>>>>>>>>>>>>>>        Get Find_Object of (TimersArray(Self)) iObj to iResult
99588>>>>>>>>>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
99589>>>>>>>>>>>>>>>    End_Function
99590>>>>>>>>>>>>>>>    
99590>>>>>>>>>>>>>>>    // Will be called by the Set when it is being destroyed.
99590>>>>>>>>>>>>>>>    Procedure Kill_All_Timers
99592>>>>>>>>>>>>>>>        Integer iMax
99592>>>>>>>>>>>>>>>        Integer iSet
99592>>>>>>>>>>>>>>>        Integer iItem
99592>>>>>>>>>>>>>>>        Integer iObj
99592>>>>>>>>>>>>>>>        Integer iResult
99592>>>>>>>>>>>>>>>        Handle  hWnd
99592>>>>>>>>>>>>>>>        
99592>>>>>>>>>>>>>>>        // Get the handle of this object
99592>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
99593>>>>>>>>>>>>>>>        If (not(hWnd)) Begin
99595>>>>>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
99596>>>>>>>>>>>>>>>>
99596>>>>>>>>>>>>>>>            Procedure_Return
99597>>>>>>>>>>>>>>>        End
99597>>>>>>>>>>>>>>>>
99597>>>>>>>>>>>>>>>        
99597>>>>>>>>>>>>>>>        // If the window handle is no longer valid, we
99597>>>>>>>>>>>>>>>        // leave this procedure. This can happen when the
99597>>>>>>>>>>>>>>>        // program is begin aborted using Exit_Application
99597>>>>>>>>>>>>>>>        If (not(IsWindow(hWnd))) ;            Procedure_Return
99600>>>>>>>>>>>>>>>        
99600>>>>>>>>>>>>>>>        // Scan the set and kill all known timers
99600>>>>>>>>>>>>>>>        Move (TimersArray(Self)) to iSet
99601>>>>>>>>>>>>>>>        If (iSet) Begin
99603>>>>>>>>>>>>>>>            Get Item_Count of iSet to iMax
99604>>>>>>>>>>>>>>>            Decrement iMax
99605>>>>>>>>>>>>>>>            For iItem from 1 to iMax
99611>>>>>>>>>>>>>>>>
99611>>>>>>>>>>>>>>>                Get Integer_Value of iSet iItem to iObj
99612>>>>>>>>>>>>>>>                If iObj Begin
99614>>>>>>>>>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
99615>>>>>>>>>>>>>>>                    Set Array_Value of iSet iItem to 0
99616>>>>>>>>>>>>>>>                End
99616>>>>>>>>>>>>>>>>
99616>>>>>>>>>>>>>>>            Loop
99617>>>>>>>>>>>>>>>>
99617>>>>>>>>>>>>>>>        End
99617>>>>>>>>>>>>>>>>
99617>>>>>>>>>>>>>>>        
99617>>>>>>>>>>>>>>>    End_Procedure
99618>>>>>>>>>>>>>>>    
99618>>>>>>>>>>>>>>>    Procedure OnTimer Integer wParam Integer lParam
99620>>>>>>>>>>>>>>>        Integer iObj
99620>>>>>>>>>>>>>>>        Get Integer_Value of (TimersArray(Self)) wParam to iObj
99621>>>>>>>>>>>>>>>        If not iObj Begin
99623>>>>>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
99624>>>>>>>>>>>>>>>>
99624>>>>>>>>>>>>>>>            Procedure_Return
99625>>>>>>>>>>>>>>>        End
99625>>>>>>>>>>>>>>>>
99625>>>>>>>>>>>>>>>        Send OnTimer to iObj wParam lParam
99626>>>>>>>>>>>>>>>    End_Procedure
99627>>>>>>>>>>>>>>>    
99627>>>>>>>>>>>>>>>    Procedure Destroy_Object
99629>>>>>>>>>>>>>>>        Send Kill_All_Timers
99630>>>>>>>>>>>>>>>        Forward Send Destroy_Object
99632>>>>>>>>>>>>>>>        Move 0 to giTimerManager
99633>>>>>>>>>>>>>>>    End_Procedure
99634>>>>>>>>>>>>>>>    
99634>>>>>>>>>>>>>>>End_Class
99635>>>>>>>>>>>>>>>
99635>>>>>>>>>>>>>>>
99635>>>>>>>>>>>>>>>
99635>>>>>>>>>>>>>>>
99635>>>>>>>>>>>>>>>// This class acts as a container for the
99635>>>>>>>>>>>>>>>// timer manager object. This is needed because
99635>>>>>>>>>>>>>>>// A DFTimerManager object created directly at the
99635>>>>>>>>>>>>>>>// desktop doesn't have a Window_Handle which we
99635>>>>>>>>>>>>>>>// need to create a Windoows timer. By placing
99635>>>>>>>>>>>>>>>// this non-visual container around the timer
99635>>>>>>>>>>>>>>>// manager, it does get a Window_Handle.
99635>>>>>>>>>>>>>>>// The procedure End_Construct_Object has been
99635>>>>>>>>>>>>>>>// augmented to create a window and also
99635>>>>>>>>>>>>>>>// automatically page all children, which will
99635>>>>>>>>>>>>>>>// be the timer manager.
99635>>>>>>>>>>>>>>>//
99635>>>>>>>>>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
99636>>>>>>>>>>>>>>>    
99636>>>>>>>>>>>>>>>    Procedure Construct_Object
99638>>>>>>>>>>>>>>>        Forward Send Construct_Object
99640>>>>>>>>>>>>>>>        Set Visible_State to False
99641>>>>>>>>>>>>>>>        Object DFTimerManager is a DFTimerManager
99643>>>>>>>>>>>>>>>        End_Object
99644>>>>>>>>>>>>>>>    End_Procedure
99645>>>>>>>>>>>>>>>    
99645>>>>>>>>>>>>>>>    Procedure End_Construct_Object
99647>>>>>>>>>>>>>>>        Forward Send End_Construct_Object
99649>>>>>>>>>>>>>>>        Send Page_Object True
99650>>>>>>>>>>>>>>>        Broadcast Send Page_Object True
99652>>>>>>>>>>>>>>>    End_Procedure
99653>>>>>>>>>>>>>>>    
99653>>>>>>>>>>>>>>>End_Class
99654>>>>>>>>>>>>>>>
99654>>>>>>>>>>>>>>>// This is the class the user uses to create DFTimer objects
99654>>>>>>>>>>>>>>>
99654>>>>>>>>>>>>>>>
99654>>>>>>>>>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
99654>>>>>>>>>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
99654>>>>>>>>>>>>>>>Class DFTimer is a Textbox
99655>>>>>>>>>>>>>>>    
99655>>>>>>>>>>>>>>>    Procedure Construct_Object
99657>>>>>>>>>>>>>>>        Forward Send Construct_Object
99659>>>>>>>>>>>>>>>        
99659>>>>>>>>>>>>>>>        // Make sure this object never appears
99659>>>>>>>>>>>>>>>        Set Visible_State to False
99660>>>>>>>>>>>>>>>        
99660>>>>>>>>>>>>>>>        Property Integer Private.Timeout    1000
99661>>>>>>>>>>>>>>>        
99661>>>>>>>>>>>>>>>        Property Integer Timer_Message      0
99662>>>>>>>>>>>>>>>        Property Integer Timer_Object       0
99663>>>>>>>>>>>>>>>        Property Integer Auto_Start_State   True
99664>>>>>>>>>>>>>>>        Property Integer Auto_Stop_State    True
99665>>>>>>>>>>>>>>>    End_Procedure
99666>>>>>>>>>>>>>>>    
99666>>>>>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iState
99668>>>>>>>>>>>>>>>        Integer iObj
99668>>>>>>>>>>>>>>>        Move Self to iObj
99669>>>>>>>>>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
99672>>>>>>>>>>>>>>>    End_Procedure
99673>>>>>>>>>>>>>>>    
99673>>>>>>>>>>>>>>>    Function Timer_Active_State Returns Integer
99675>>>>>>>>>>>>>>>        Integer iState
99675>>>>>>>>>>>>>>>        Integer iObj
99675>>>>>>>>>>>>>>>        Move Self to iObj
99676>>>>>>>>>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
99679>>>>>>>>>>>>>>>        Function_Return iState
99680>>>>>>>>>>>>>>>    End_Function
99681>>>>>>>>>>>>>>>    
99681>>>>>>>>>>>>>>>    Procedure Set Timeout Integer iTimeout
99683>>>>>>>>>>>>>>>        Integer iActive
99683>>>>>>>>>>>>>>>        Set Private.Timeout to iTimeout
99684>>>>>>>>>>>>>>>        Get Timer_Active_State to iActive
99685>>>>>>>>>>>>>>>        If iActive ;            Set Timer_Active_State to True
99688>>>>>>>>>>>>>>>    End_Procedure
99689>>>>>>>>>>>>>>>    
99689>>>>>>>>>>>>>>>    Function Timeout Returns Integer
99691>>>>>>>>>>>>>>>        Integer iTimeout
99691>>>>>>>>>>>>>>>        Get Private.Timeout to iTimeout
99692>>>>>>>>>>>>>>>        Function_Return iTimeout
99693>>>>>>>>>>>>>>>    End_Function
99694>>>>>>>>>>>>>>>    
99694>>>>>>>>>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
99696>>>>>>>>>>>>>>>        Integer iMsg
99696>>>>>>>>>>>>>>>        Integer iObj
99696>>>>>>>>>>>>>>>        Get Timer_Message to iMsg
99697>>>>>>>>>>>>>>>        If (iMsg) Begin
99699>>>>>>>>>>>>>>>            Get Timer_Object  to iObj
99700>>>>>>>>>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
99703>>>>>>>>>>>>>>>            Else ;                Send iMsg iwParam ilParam
99705>>>>>>>>>>>>>>>        End
99705>>>>>>>>>>>>>>>>
99705>>>>>>>>>>>>>>>    End_Procedure
99706>>>>>>>>>>>>>>>    
99706>>>>>>>>>>>>>>>    // Augmented to Auto_Start a timer
99706>>>>>>>>>>>>>>>    //
99706>>>>>>>>>>>>>>>    Procedure Page_Object Integer iState
99708>>>>>>>>>>>>>>>        Forward Send Page_Object iState
99710>>>>>>>>>>>>>>>        If (iState and Auto_Start_State(Self)) ;            Set Timer_Active_State to True
99713>>>>>>>>>>>>>>>    End_Procedure
99714>>>>>>>>>>>>>>>    
99714>>>>>>>>>>>>>>>    // Augmented to Auto_Stop a timer
99714>>>>>>>>>>>>>>>    //
99714>>>>>>>>>>>>>>>    Procedure Page_Delete
99716>>>>>>>>>>>>>>>        If (Auto_Stop_State(Self)) ;            Set Timer_Active_State to False
99719>>>>>>>>>>>>>>>        Forward Send Page_Delete
99721>>>>>>>>>>>>>>>    End_Procedure
99722>>>>>>>>>>>>>>>    
99722>>>>>>>>>>>>>>>    // Augmented to stop the timer
99722>>>>>>>>>>>>>>>    //
99722>>>>>>>>>>>>>>>    Procedure Destroy_Object
99724>>>>>>>>>>>>>>>        Set Timer_Active_State to False
99725>>>>>>>>>>>>>>>        Forward Send Destroy_Object
99727>>>>>>>>>>>>>>>    End_Procedure
99728>>>>>>>>>>>>>>>    
99728>>>>>>>>>>>>>>>End_Class
99729>>>>>>>>>>>>>>>
99729>>>>>>>>>>>>>>>//
99729>>>>>>>>>>>>>>>// This was moved into a method so it can be reliable created
99729>>>>>>>>>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
99729>>>>>>>>>>>>>>>//
99729>>>>>>>>>>>>>>>Procedure CreateDfTimerManagerPanel for cDesktop
99731>>>>>>>>>>>>>>>    // Create the Desktop Timer Manager Object.
99731>>>>>>>>>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
99733>>>>>>>>>>>>>>>    End_Object
99734>>>>>>>>>>>>>>>End_Procedure
99735>>>>>>>>>>>>>>>
99735>>>>>>>>>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
99736>>>>>>>>>>>>>
99736>>>>>>>>>>>>>Class cTimer is a cObject
99737>>>>>>>>>>>>>    
99737>>>>>>>>>>>>>    Procedure Construct_Object
99739>>>>>>>>>>>>>        Forward Send Construct_Object
99741>>>>>>>>>>>>>        Property Integer piPrivate_Timeout 1000
99742>>>>>>>>>>>>>    End_Procedure
99743>>>>>>>>>>>>>    
99743>>>>>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
99745>>>>>>>>>>>>>        If giTimerManager Begin
99747>>>>>>>>>>>>>            Set Timer_Active_State of giTimerManager Self to bEnabled
99748>>>>>>>>>>>>>        End
99748>>>>>>>>>>>>>>
99748>>>>>>>>>>>>>    End_Procedure
99749>>>>>>>>>>>>>    
99749>>>>>>>>>>>>>    Function pbEnabled Returns Boolean
99751>>>>>>>>>>>>>        Boolean bEnabled
99751>>>>>>>>>>>>>        If giTimerManager Begin
99753>>>>>>>>>>>>>            Get Timer_Active_State of giTimerManager Self to bEnabled
99754>>>>>>>>>>>>>        End
99754>>>>>>>>>>>>>>
99754>>>>>>>>>>>>>        Function_Return bEnabled
99755>>>>>>>>>>>>>    End_Function
99756>>>>>>>>>>>>>    
99756>>>>>>>>>>>>>    Procedure Set piTimeout Integer iTimeout
99758>>>>>>>>>>>>>        Boolean bEnabled
99758>>>>>>>>>>>>>        Set piPrivate_Timeout to iTimeout
99759>>>>>>>>>>>>>        Get pbEnabled to bEnabled
99760>>>>>>>>>>>>>        If bEnabled Begin
99762>>>>>>>>>>>>>            Set pbEnabled to True
99763>>>>>>>>>>>>>        End
99763>>>>>>>>>>>>>>
99763>>>>>>>>>>>>>    End_Procedure
99764>>>>>>>>>>>>>    
99764>>>>>>>>>>>>>    Function piTimeout Returns Integer
99766>>>>>>>>>>>>>        Integer iTimeout
99766>>>>>>>>>>>>>        Get piPrivate_Timeout to iTimeout
99767>>>>>>>>>>>>>        Function_Return iTimeout
99768>>>>>>>>>>>>>    End_Function
99769>>>>>>>>>>>>>    
99769>>>>>>>>>>>>>    Procedure OnTimer
99771>>>>>>>>>>>>>    End_Procedure
99772>>>>>>>>>>>>>    
99772>>>>>>>>>>>>>    // this is needed by the timer manager
99772>>>>>>>>>>>>>    Function Timeout Returns Integer
99774>>>>>>>>>>>>>        Integer iTimeout
99774>>>>>>>>>>>>>        Get piPrivate_Timeout to iTimeout
99775>>>>>>>>>>>>>        Function_Return iTimeout
99776>>>>>>>>>>>>>    End_Function
99777>>>>>>>>>>>>>    
99777>>>>>>>>>>>>>    Procedure Destroy_Object
99779>>>>>>>>>>>>>        Set pbEnabled to False
99780>>>>>>>>>>>>>        Forward Send Destroy_Object
99782>>>>>>>>>>>>>    End_Procedure
99783>>>>>>>>>>>>>    
99783>>>>>>>>>>>>>End_Class
99784>>>>>>>>>>>Use cRichEdit.pkg
99784>>>>>>>>>>>Use sql.pkg
99784>>>>>>>>>>>
99784>>>>>>>>>>>// defines interface for cWindowMesageHook - currently a private runtime class
99784>>>>>>>>>>>Define     U_DFWINDOWSMESSAGEHOOK  for |CI0106
99784>>>>>>>>>>>Define     GET_ENABLEWINDOWSHOOK   for |CI$0542
99784>>>>>>>>>>>Define     MSG_DISABLEWINDOWSHOOK  for |CI$0543
99784>>>>>>>>>>>Define     GET_ONWINDOWSHOOK       for |CI$0544
99784>>>>>>>>>>>Define     WH_MOUSE for 7
99784>>>>>>>>>>>Define     WH_KEYBOARD for 2
99784>>>>>>>>>>>
99784>>>>>>>>>>>
99784>>>>>>>>>>>// suggestion lists use a global timer and a global suggestion list
99784>>>>>>>>>>>Global_Variable Handle ghoSuggestionList
99784>>>>>>>>>>>Move 0 to ghoSuggestionList
99785>>>>>>>>>>>
99785>>>>>>>>>>>Global_Variable Handle ghoSuggestionTimer
99785>>>>>>>>>>>Move 0 to ghoSuggestionTimer
99786>>>>>>>>>>>
99786>>>>>>>>>>>// this will get created the first time it is needed.
99786>>>>>>>>>>>Class cSuggestionTimer is a cTimer
99787>>>>>>>>>>>    
99787>>>>>>>>>>>    Procedure Construct_Object
99789>>>>>>>>>>>        Forward Send Construct_Object
99791>>>>>>>>>>>        Property Handle phoTimerOwner 0
99792>>>>>>>>>>>        Set piTimeout to 50
99793>>>>>>>>>>>    End_Procedure
99794>>>>>>>>>>>    
99794>>>>>>>>>>>    Procedure OnTimer
99796>>>>>>>>>>>        Handle hoOwner
99796>>>>>>>>>>>        Get phoTimerOwner to hoOwner
99797>>>>>>>>>>>        // do this in case progam close destroys owner before timer
99797>>>>>>>>>>>        Get Object_Id of hoOwner to hoOwner
99798>>>>>>>>>>>        If hoOwner Begin
99800>>>>>>>>>>>            Send OnSuggestionTimer to hoOwner
99801>>>>>>>>>>>        End
99801>>>>>>>>>>>>
99801>>>>>>>>>>>        Else Begin
99802>>>>>>>>>>>            // something wrong, shut off timer
99802>>>>>>>>>>>            Set pbEnabled to False
99803>>>>>>>>>>>        End
99803>>>>>>>>>>>>
99803>>>>>>>>>>>    End_Procedure
99804>>>>>>>>>>>    
99804>>>>>>>>>>>End_Class
99805>>>>>>>>>>>
99805>>>>>>>>>>>Class cSuggestionHookMouse is a DFWindowsMessageHook
99806>>>>>>>>>>>    
99806>>>>>>>>>>>    // If mouse not in suggestion list or form, close suggestionlist
99806>>>>>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
99808>>>>>>>>>>>        tWinMouseHookStruct MouseHook
99808>>>>>>>>>>>        tWinMouseHookStruct MouseHook
99808>>>>>>>>>>>        Integer ivoid hObj
99808>>>>>>>>>>>        Handle hoOwner hoParent
99808>>>>>>>>>>>        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;            i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
99810>>>>>>>>>>>            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
99811>>>>>>>>>>>            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
99812>>>>>>>>>>>            Get Parent to hoParent
99813>>>>>>>>>>>            Get phoOwner of hoParent to hoOwner
99814>>>>>>>>>>>            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
99816>>>>>>>>>>>                Send DisableWindowsHook
99817>>>>>>>>>>>                Send DeActivateSuggestionList of hoOwner
99818>>>>>>>>>>>            End
99818>>>>>>>>>>>>
99818>>>>>>>>>>>        End
99818>>>>>>>>>>>>
99818>>>>>>>>>>>    End_Function
99819>>>>>>>>>>>    
99819>>>>>>>>>>>    Procedure End_Construct_Object
99821>>>>>>>>>>>        Boolean bOk
99821>>>>>>>>>>>        Forward Send End_Construct_Object
99823>>>>>>>>>>>        Get EnableWindowsHook WH_MOUSE to bOk
99824>>>>>>>>>>>    End_Procedure
99825>>>>>>>>>>>    
99825>>>>>>>>>>>End_Class
99826>>>>>>>>>>>
99826>>>>>>>>>>>Class cSuggestionHookKbd is a DFWindowsMessageHook
99827>>>>>>>>>>>    
99827>>>>>>>>>>>    // If menu key, close suggestionlist
99827>>>>>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
99829>>>>>>>>>>>        Handle hoOwner
99829>>>>>>>>>>>        If (i1=0 and i2=VK_MENU) Begin
99831>>>>>>>>>>>            Delegate Get phoOwner to hoOwner
99833>>>>>>>>>>>            Send DisableWindowsHook
99834>>>>>>>>>>>            Send DeActivateSuggestionList of hoOwner
99835>>>>>>>>>>>        End
99835>>>>>>>>>>>>
99835>>>>>>>>>>>    End_Function
99836>>>>>>>>>>>    
99836>>>>>>>>>>>    Procedure End_Construct_Object
99838>>>>>>>>>>>        Boolean bOk
99838>>>>>>>>>>>        Forward Send End_Construct_Object
99840>>>>>>>>>>>        Get EnableWindowsHook WH_KEYBOARD  to bOk
99841>>>>>>>>>>>    End_Procedure
99842>>>>>>>>>>>    
99842>>>>>>>>>>>End_Class
99843>>>>>>>>>>>
99843>>>>>>>>>>>Class cSuggestionList is a cRichEdit
99844>>>>>>>>>>>    
99844>>>>>>>>>>>    Procedure Construct_Object
99846>>>>>>>>>>>        Handle hoObj
99846>>>>>>>>>>>        Forward Send Construct_Object
99848>>>>>>>>>>>        Property Handle phoOwner
99849>>>>>>>>>>>        Set Focus_Mode to NonFocusable
99850>>>>>>>>>>>        Set Attach_Parent_State to True
99851>>>>>>>>>>>        Set pbWrap to False
99852>>>>>>>>>>>        If (ghoSuggestionList) Begin
99854>>>>>>>>>>>            Send Destroy of ghoSuggestionList
99855>>>>>>>>>>>        End
99855>>>>>>>>>>>>
99855>>>>>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookMouse)) "oMouseHook" to hoObj
99856>>>>>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookKbd))"oKbdHook" to hoObj
99857>>>>>>>>>>>    End_Procedure
99858>>>>>>>>>>>    
99858>>>>>>>>>>>    Procedure Destroy_Object
99860>>>>>>>>>>>        Forward Send Destroy_Object
99862>>>>>>>>>>>        Move 0 to ghoSuggestionList
99863>>>>>>>>>>>    End_Procedure
99864>>>>>>>>>>>    
99864>>>>>>>>>>>    Procedure DeactivateList
99866>>>>>>>>>>>        Set pbEnabled of ghoSuggestionTimer to False
99867>>>>>>>>>>>        Send Deactivate
99868>>>>>>>>>>>        Send Destroy
99869>>>>>>>>>>>    End_Procedure
99870>>>>>>>>>>>    
99870>>>>>>>>>>>    Procedure InitList Handle hoForm
99872>>>>>>>>>>>        Integer iSize iLoc iLoc2
99872>>>>>>>>>>>        Get GuiSize of hoForm to iSize
99873>>>>>>>>>>>        Set GuiSize to (Hi(iSize)) (1000)
99874>>>>>>>>>>>        Get Absolute_GUIOrigin of hoForm to iLoc
99875>>>>>>>>>>>        Delegate Get Absolute_GUIOrigin to iLoc2
99877>>>>>>>>>>>        Set GuiLocation to (Hi(iLoc)-Hi(iLoc2)+Hi(iSize)+2) (Low(iLoc)+2-Low(iLoc2))
99878>>>>>>>>>>>        Set Visible_State to False
99879>>>>>>>>>>>    End_Procedure
99880>>>>>>>>>>>    
99880>>>>>>>>>>>    // scroll up one line
99880>>>>>>>>>>>    Procedure ScrollUp
99882>>>>>>>>>>>        Integer iLine
99882>>>>>>>>>>>        Get SelectedRow to iLine
99883>>>>>>>>>>>        If (iLine) Begin
99885>>>>>>>>>>>            Send SelectRow (iLine-1)
99886>>>>>>>>>>>        End
99886>>>>>>>>>>>>
99886>>>>>>>>>>>    End_Procedure
99887>>>>>>>>>>>    
99887>>>>>>>>>>>    // scroll down one line
99887>>>>>>>>>>>    Procedure ScrollDown
99889>>>>>>>>>>>        Integer iLine iLines
99889>>>>>>>>>>>        Get Line_Count to iLines
99890>>>>>>>>>>>        Get SelectedRow to iLine
99891>>>>>>>>>>>        // there can be an extra line at the end
99891>>>>>>>>>>>        If (iLine<iLines-1) Begin
99893>>>>>>>>>>>            Send SelectRow (iLine+1)
99894>>>>>>>>>>>        End
99894>>>>>>>>>>>>
99894>>>>>>>>>>>    End_Procedure
99895>>>>>>>>>>>    
99895>>>>>>>>>>>    // sets the current line to iLine and highlights it
99895>>>>>>>>>>>    Procedure SelectRow Integer iLine
99897>>>>>>>>>>>        Integer iPos iLen
99897>>>>>>>>>>>        Get FirstCharInLinePos iLine to iPos
99898>>>>>>>>>>>        Get LineLength iLine to iLen
99899>>>>>>>>>>>        Send SetSel iPos (iPos+iLen)
99900>>>>>>>>>>>    End_Procedure
99901>>>>>>>>>>>    
99901>>>>>>>>>>>    // get the current selected Line
99901>>>>>>>>>>>    Function SelectedRow Returns Integer
99903>>>>>>>>>>>        Integer iLine
99903>>>>>>>>>>>        Get LineFromChar -1 to iLine
99904>>>>>>>>>>>        Function_Return iLine
99905>>>>>>>>>>>    End_Function
99906>>>>>>>>>>>    
99906>>>>>>>>>>>    // select the current row
99906>>>>>>>>>>>    Procedure Mouse_Up Handle hCell Integer iPos
99908>>>>>>>>>>>        Handle hoObj
99908>>>>>>>>>>>        Get phoOwner to hoObj
99909>>>>>>>>>>>        Send Activate of hoObj // move focus to owner, which will close the list
99910>>>>>>>>>>>        Send SelectSuggestion of hoObj
99911>>>>>>>>>>>    End_Procedure
99912>>>>>>>>>>>    
99912>>>>>>>>>>>End_Class
99913>>>>>>>>>>>
99913>>>>>>>>>>>// This contains mixin support for suggestion logic and contains the interface that
99913>>>>>>>>>>>// is accessed publicly. This should be mixed into the form or column DEO object
99913>>>>>>>>>>>Class cSuggestion_mixin is a Mixin
99914>>>>>>>>>>>    
99914>>>>>>>>>>>    Procedure Define_cSuggestion_mixin
99916>>>>>>>>>>>        
99916>>>>>>>>>>>        Property Integer peSuggestionMode smFind
99917>>>>>>>>>>>        Property Boolean pbFullText False
99918>>>>>>>>>>>        Property Boolean pbCaseSensitive False
99919>>>>>>>>>>>        Property Integer piMaxResults 15
99920>>>>>>>>>>>        Property Integer piStartAtChar 2
99921>>>>>>>>>>>        Property Boolean pbFullWidth True
99922>>>>>>>>>>>        Property Integer piFindIndex 0
99923>>>>>>>>>>>        Property Boolean pbFindOnSelect True
99924>>>>>>>>>>>        Property Integer piPopupTimeout 50
99925>>>>>>>>>>>        
99925>>>>>>>>>>>        Property tSuggestion[] pSearchResults
99926>>>>>>>>>>>        
99926>>>>>>>>>>>        Property Handle phcSuggestionListClass (RefClass(cSuggestionList))
99927>>>>>>>>>>>        
99927>>>>>>>>>>>    End_Procedure
99928>>>>>>>>>>>    
99928>>>>>>>>>>>    // Display one Suggestion Line in Suggestion List. Good for augmentation although
99928>>>>>>>>>>>    // this must be done carefully as you must know the suggestionlist interface, which
99928>>>>>>>>>>>    // if private
99928>>>>>>>>>>>    Procedure ShowSuggestion tSuggestion SuggestionData String sSearch
99930>>>>>>>>>>>        Integer i iCols iPos
99930>>>>>>>>>>>        String sValue
99930>>>>>>>>>>>        Integer eSuggestionMode
99930>>>>>>>>>>>        Boolean bFullText
99930>>>>>>>>>>>        
99930>>>>>>>>>>>        Get peSuggestionMode to eSuggestionMode
99931>>>>>>>>>>>        Get pbFullText to bFullText
99932>>>>>>>>>>>        
99932>>>>>>>>>>>        Move SuggestionData.aValues[0] to sValue
99933>>>>>>>>>>>        If (not(bFullText)) Begin
99935>>>>>>>>>>>            Set pbBold of ghoSuggestionList to True
99936>>>>>>>>>>>            Send AppendText of ghoSuggestionList (Left(sValue,Length(sSearch)))
99937>>>>>>>>>>>            Set pbBold of ghoSuggestionList to False
99938>>>>>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,Length(sSearch)+1))
99939>>>>>>>>>>>        End
99939>>>>>>>>>>>>
99939>>>>>>>>>>>        Else Begin
99940>>>>>>>>>>>            Set pbBold of ghoSuggestionList to False
99941>>>>>>>>>>>            Move (Pos(Uppercase(sSearch),Uppercase(sValue))) to iPos
99942>>>>>>>>>>>            If (iPos) Begin
99944>>>>>>>>>>>                Send AppendText of ghoSuggestionList (Left(sValue,iPos-1))
99945>>>>>>>>>>>                Set pbBold of ghoSuggestionList to True
99946>>>>>>>>>>>                Send AppendText of ghoSuggestionList (Mid(sValue,Length(sSearch),iPos))
99947>>>>>>>>>>>                Set pbBold of ghoSuggestionList to False
99948>>>>>>>>>>>            End
99948>>>>>>>>>>>>
99948>>>>>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,iPos+Length(sSearch)))
99949>>>>>>>>>>>        End
99949>>>>>>>>>>>>
99949>>>>>>>>>>>        
99949>>>>>>>>>>>        // if addiitonal columns (usually validation) we assume the first value is the one that is
99949>>>>>>>>>>>        // matched and we display all other values (usually just one) to the
99949>>>>>>>>>>>        // right of it.
99949>>>>>>>>>>>        Move (SizeOfArray(SuggestionData.aValues)) to iCols
99950>>>>>>>>>>>        If (iCols>1) Begin
99952>>>>>>>>>>>            Move "" to sValue
99953>>>>>>>>>>>            For i from 1 to (iCols-1)
99959>>>>>>>>>>>>
99959>>>>>>>>>>>                Move (sValue + If(i=1," - ","  ") + SuggestionData.aValues[i]) to sValue
99960>>>>>>>>>>>            Loop
99961>>>>>>>>>>>>
99961>>>>>>>>>>>            Send AppendText of ghoSuggestionList sValue
99962>>>>>>>>>>>        End
99962>>>>>>>>>>>>
99962>>>>>>>>>>>    End_Procedure
99963>>>>>>>>>>>    
99963>>>>>>>>>>>    // used to catch a set_field_value_Error
99963>>>>>>>>>>>    Procedure Error_Report Integer iError Integer iLine String sErr
99965>>>>>>>>>>>    End_Procedure
99966>>>>>>>>>>>    
99966>>>>>>>>>>>    // does a Set_Field_Value with error testing around it.
99966>>>>>>>>>>>    Function SafeSetFieldValue Integer iFile Integer iField String sValue Returns Boolean
99968>>>>>>>>>>>        Handle hoOldError
99968>>>>>>>>>>>        Boolean bErr
99968>>>>>>>>>>>        Move Error_Object_Id to hoOldError
99969>>>>>>>>>>>        Move Self to Error_Object_Id
99970>>>>>>>>>>>        Move False to Err
99971>>>>>>>>>>>        Set_Field_Value iFile iField to sValue
99974>>>>>>>>>>>        Move Err to bErr
99975>>>>>>>>>>>        Move hoOldError to Error_Object_Id
99976>>>>>>>>>>>        Function_Return bErr
99977>>>>>>>>>>>    End_Function
99978>>>>>>>>>>>    
99978>>>>>>>>>>>    
99978>>>>>>>>>>>    Procedure SuggestionsFindIncremental String sSearch tSuggestion[] ByRef aSuggestions
99980>>>>>>>>>>>        Integer iFile iField iIndex iLen iRow iMax eType iLength iDec
99980>>>>>>>>>>>        Handle hoServer
99980>>>>>>>>>>>        Boolean bContinue bCase bOldRelate bNeedsRelate bInvalid
99980>>>>>>>>>>>        String sVal sLowSearch
99980>>>>>>>>>>>        RowID riTest
99980>>>>>>>>>>>        
99980>>>>>>>>>>>        Get Server to hoServer
99981>>>>>>>>>>>        Get Data_File  to iFile
99982>>>>>>>>>>>        Get Data_Field to iField
99983>>>>>>>>>>>        
99983>>>>>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
99985>>>>>>>>>>>            Get piFindIndex to iIndex
99986>>>>>>>>>>>            Get piMaxResults to iMax
99987>>>>>>>>>>>            Get pbCaseSensitive to bCase
99988>>>>>>>>>>>            
99988>>>>>>>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to eType
99991>>>>>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
99994>>>>>>>>>>>            Get_Attribute DF_FIELD_PRECISION of iFile iField to iDec
99997>>>>>>>>>>>            
99997>>>>>>>>>>>            Move (iLength - iDec) to iLength
99998>>>>>>>>>>>            
99998>>>>>>>>>>>            If (iIndex <= 0) Begin
100000>>>>>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
100003>>>>>>>>>>>            End
100003>>>>>>>>>>>>
100003>>>>>>>>>>>            
100003>>>>>>>>>>>            
100003>>>>>>>>>>>            
100003>>>>>>>>>>>            If (iIndex > 0) Begin
100005>>>>>>>>>>>                Get No_Relate_State of hoServer to bOldRelate
100006>>>>>>>>>>>                Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
100007>>>>>>>>>>>                Set No_Relate_State of hoServer to (not(bNeedsRelate))
100008>>>>>>>>>>>                
100008>>>>>>>>>>>                Move True to bContinue
100009>>>>>>>>>>>                Move (Length(sSearch)) to iLen
100010>>>>>>>>>>>                Move (Lowercase(sSearch)) to sLowSearch
100011>>>>>>>>>>>                Move 0 to iRow
100012>>>>>>>>>>>                
100012>>>>>>>>>>>                //  Find first record
100012>>>>>>>>>>>                Send Request_Read of hoServer FIRST_RECORD iFile iIndex
100013>>>>>>>>>>>                Get SafeSetFieldValue iFile iField sSearch to bInvalid
100014>>>>>>>>>>>                If bInvalid Begin
100016>>>>>>>>>>>                    Move False to bContinue
100017>>>>>>>>>>>                End
100017>>>>>>>>>>>>
100017>>>>>>>>>>>                
100017>>>>>>>>>>>                If (bContinue) Begin
100019>>>>>>>>>>>                    Send Request_Read of hoServer GE iFile iIndex
100020>>>>>>>>>>>                End
100020>>>>>>>>>>>>
100020>>>>>>>>>>>                
100020>>>>>>>>>>>                While (Found and bContinue)
100024>>>>>>>>>>>                    Get_Field_Value iFile iField to sVal
100027>>>>>>>>>>>                    
100027>>>>>>>>>>>                    If ((not(bCase) and Lowercase(Left(sVal, iLen)) = sLowSearch) or (bCase and Left(sVal, iLen) = sSearch)) Begin
100029>>>>>>>>>>>                        
100029>>>>>>>>>>>                        Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
100030>>>>>>>>>>>                        Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
100031>>>>>>>>>>>                        Increment iRow
100032>>>>>>>>>>>                        
100032>>>>>>>>>>>                        Move (iRow < iMax) to bContinue
100033>>>>>>>>>>>                        
100033>>>>>>>>>>>                        Send Request_Read of hoServer GT iFile iIndex
100034>>>>>>>>>>>                    End
100034>>>>>>>>>>>>
100034>>>>>>>>>>>                    Else Begin
100035>>>>>>>>>>>                        If (eType = DF_BCD and Length(sSearch) < iLength) Begin
100037>>>>>>>>>>>                            //  For numeric fields we'll jump in the index to the next possible value (for example from 40 to 400)
100037>>>>>>>>>>>                            
100037>>>>>>>>>>>                            Move (GetRowID(iFile)) to riTest
100038>>>>>>>>>>>                            
100038>>>>>>>>>>>                            Move (sSearch * 10) to sSearch
100039>>>>>>>>>>>                            
100039>>>>>>>>>>>                            Get SafeSetFieldValue iFile iField sSearch to bInvalid
100040>>>>>>>>>>>                            If bInvalid Begin
100042>>>>>>>>>>>                                Move False to bContinue
100043>>>>>>>>>>>                            End
100043>>>>>>>>>>>>
100043>>>>>>>>>>>                            Else Begin
100044>>>>>>>>>>>                                Send Request_Read of hoServer GE iFile iIndex
100045>>>>>>>>>>>                                Move (not(IsSameRowID(riTest, GetRowID(iFile)))) to bContinue
100046>>>>>>>>>>>                            End
100046>>>>>>>>>>>>
100046>>>>>>>>>>>                        End
100046>>>>>>>>>>>>
100046>>>>>>>>>>>                        Else Begin
100047>>>>>>>>>>>                            Move False to bContinue
100048>>>>>>>>>>>                        End
100048>>>>>>>>>>>>
100048>>>>>>>>>>>                    End
100048>>>>>>>>>>>>
100048>>>>>>>>>>>                    
100048>>>>>>>>>>>                Loop
100049>>>>>>>>>>>>
100049>>>>>>>>>>>                Set No_Relate_State of hoServer to bOldRelate
100050>>>>>>>>>>>            End
100050>>>>>>>>>>>>
100050>>>>>>>>>>>        End
100050>>>>>>>>>>>>
100050>>>>>>>>>>>    End_Procedure
100051>>>>>>>>>>>    
100051>>>>>>>>>>>    Procedure SuggestionsFindFullText String sSearch tSuggestion[] ByRef aSuggestions
100053>>>>>>>>>>>        Integer iFile iField iIndex iRow iMax
100053>>>>>>>>>>>        Handle hoServer
100053>>>>>>>>>>>        Boolean bContinue bCase  bOldRelate bNeedsRelate
100053>>>>>>>>>>>        String sVal sLowSearch
100053>>>>>>>>>>>        
100053>>>>>>>>>>>        Get Server to hoServer
100054>>>>>>>>>>>        Get Data_File  to iFile
100055>>>>>>>>>>>        Get Data_Field to iField
100056>>>>>>>>>>>        
100056>>>>>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
100058>>>>>>>>>>>            Get piMaxResults to iMax
100059>>>>>>>>>>>            Get pbCaseSensitive to bCase
100060>>>>>>>>>>>            
100060>>>>>>>>>>>            Get piFindIndex to iIndex
100061>>>>>>>>>>>            If (iIndex <= 0) Begin
100063>>>>>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
100066>>>>>>>>>>>            End
100066>>>>>>>>>>>>
100066>>>>>>>>>>>            
100066>>>>>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
100067>>>>>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
100068>>>>>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
100069>>>>>>>>>>>            
100069>>>>>>>>>>>            
100069>>>>>>>>>>>            Move (Lowercase(sSearch)) to sLowSearch
100070>>>>>>>>>>>            Move True to bContinue
100071>>>>>>>>>>>            Move 0 to iRow
100072>>>>>>>>>>>            
100072>>>>>>>>>>>            //  Find first record
100072>>>>>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
100073>>>>>>>>>>>            
100073>>>>>>>>>>>            While (Found and (iRow < iMax))
100077>>>>>>>>>>>                Get_Field_Value iFile iField to sVal
100080>>>>>>>>>>>                
100080>>>>>>>>>>>                If ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch)) Begin
100082>>>>>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
100083>>>>>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
100084>>>>>>>>>>>                    Increment iRow
100085>>>>>>>>>>>                End
100085>>>>>>>>>>>>
100085>>>>>>>>>>>                
100085>>>>>>>>>>>                Send Request_Read of hoServer GT iFile iIndex
100086>>>>>>>>>>>            Loop
100087>>>>>>>>>>>>
100087>>>>>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
100088>>>>>>>>>>>        End
100088>>>>>>>>>>>>
100088>>>>>>>>>>>    End_Procedure
100089>>>>>>>>>>>    
100089>>>>>>>>>>>    Procedure SuggestionsSQLFullText String sSearch tSuggestion[] ByRef aSuggestions
100091>>>>>>>>>>>        Integer iFile iField iIndex iRow iMax
100091>>>>>>>>>>>        Handle hoServer
100091>>>>>>>>>>>        Boolean bContinue bOrigActive  bOldRelate bNeedsRelate
100091>>>>>>>>>>>        String sVal sOrigFilter sFilter sFile sField
100091>>>>>>>>>>>        
100091>>>>>>>>>>>        Get Server to hoServer
100092>>>>>>>>>>>        Get Data_File  to iFile
100093>>>>>>>>>>>        Get Data_Field to iField
100094>>>>>>>>>>>        
100094>>>>>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
100096>>>>>>>>>>>            
100096>>>>>>>>>>>            // make sure we send DD messages to owner DDO
100096>>>>>>>>>>>            Get Which_Data_Set of hoServer iFile to hoServer
100097>>>>>>>>>>>            If (hoServer=0) Begin
100099>>>>>>>>>>>                Procedure_Return
100100>>>>>>>>>>>            End
100100>>>>>>>>>>>>
100100>>>>>>>>>>>            
100100>>>>>>>>>>>            Get piMaxResults to iMax
100101>>>>>>>>>>>            Get piFindIndex to iIndex
100102>>>>>>>>>>>            If (iIndex <= 0) Begin
100104>>>>>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
100107>>>>>>>>>>>            End
100107>>>>>>>>>>>>
100107>>>>>>>>>>>            
100107>>>>>>>>>>>            //  Determine current filter settings
100107>>>>>>>>>>>            Get psSQLFilter of hoServer to sOrigFilter
100108>>>>>>>>>>>            Get pbUseDDSqlFilters of hoServer to bOrigActive
100109>>>>>>>>>>>            
100109>>>>>>>>>>>            // generate the Like filter string
100109>>>>>>>>>>>            Get SQLStrLike of hoServer iField sSearch to sFilter
100110>>>>>>>>>>>            // If filtering was active append this to what's there
100110>>>>>>>>>>>            If (bOrigActive) Begin
100112>>>>>>>>>>>                Get SQLStrAppend of hoServer sOrigFilter sFilter to sFilter
100113>>>>>>>>>>>            End
100113>>>>>>>>>>>>
100113>>>>>>>>>>>            
100113>>>>>>>>>>>            //  Set filter
100113>>>>>>>>>>>            Set psSQLFilter of hoServer to sFilter
100114>>>>>>>>>>>            Set pbUseDDSqlFilters of hoServer to True
100115>>>>>>>>>>>            
100115>>>>>>>>>>>            
100115>>>>>>>>>>>            // this will optimize No_relate. If your DF constraint does not
100115>>>>>>>>>>>            // need a post-relate test, we will disabled relates for this
100115>>>>>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
100116>>>>>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
100117>>>>>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
100118>>>>>>>>>>>            
100118>>>>>>>>>>>            //  Find records
100118>>>>>>>>>>>            Move True to bContinue
100119>>>>>>>>>>>            Move 0 to iRow
100120>>>>>>>>>>>            
100120>>>>>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
100121>>>>>>>>>>>            
100121>>>>>>>>>>>            While (bContinue)
100125>>>>>>>>>>>                Get_Field_Value iFile iField to sVal
100128>>>>>>>>>>>                
100128>>>>>>>>>>>                If (Found) Begin // and ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch))) Begin
100130>>>>>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
100131>>>>>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
100132>>>>>>>>>>>                    Increment iRow
100133>>>>>>>>>>>                    
100133>>>>>>>>>>>                    Move (iRow < iMax) to bContinue
100134>>>>>>>>>>>                    
100134>>>>>>>>>>>                    Send Request_Read of hoServer GT iFile iIndex
100135>>>>>>>>>>>                End
100135>>>>>>>>>>>>
100135>>>>>>>>>>>                Else Begin
100136>>>>>>>>>>>                    Move False to bContinue
100137>>>>>>>>>>>                End
100137>>>>>>>>>>>>
100137>>>>>>>>>>>                
100137>>>>>>>>>>>            Loop
100138>>>>>>>>>>>>
100138>>>>>>>>>>>            
100138>>>>>>>>>>>            //  Restore filters
100138>>>>>>>>>>>            Set psSQLFilter of hoServer to sOrigFilter
100139>>>>>>>>>>>            Set pbUseDDSqlFilters of hoServer to bOrigActive
100140>>>>>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
100141>>>>>>>>>>>        End
100141>>>>>>>>>>>>
100141>>>>>>>>>>>    End_Procedure
100142>>>>>>>>>>>    
100142>>>>>>>>>>>    Procedure SuggestionsValidation String sSearch tSuggestion[] ByRef aSuggestions Boolean bFullText
100144>>>>>>>>>>>        Handle hoServer hoTable
100144>>>>>>>>>>>        Integer iFile iField iRow iCount iFound iMax iLen
100144>>>>>>>>>>>        Variant[][] aData
100145>>>>>>>>>>>        Boolean bCaseSensitive bContinue
100145>>>>>>>>>>>        String sDescr sVal
100145>>>>>>>>>>>        
100145>>>>>>>>>>>        Get Server to hoServer
100146>>>>>>>>>>>        Get Data_File  to iFile
100147>>>>>>>>>>>        Get Data_Field to iField
100148>>>>>>>>>>>        
100148>>>>>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
100150>>>>>>>>>>>            Get File_Field_Table_Object of hoServer iFile iField to hoTable
100151>>>>>>>>>>>            If (hoTable <> 0) Begin
100153>>>>>>>>>>>                Get tabledata of hoTable to aData
100154>>>>>>>>>>>                
100154>>>>>>>>>>>                Get piMaxResults to iMax
100155>>>>>>>>>>>                Get pbCaseSensitive to bCaseSensitive
100156>>>>>>>>>>>                
100156>>>>>>>>>>>                If (not(bCaseSensitive)) Begin
100158>>>>>>>>>>>                    Move (Lowercase(sSearch)) to sSearch
100159>>>>>>>>>>>                End
100159>>>>>>>>>>>>
100159>>>>>>>>>>>                
100159>>>>>>>>>>>                
100159>>>>>>>>>>>                Move (SizeOfArray(aData)) to iCount
100160>>>>>>>>>>>                Move 0 to iRow
100161>>>>>>>>>>>                Move (Length(sSearch)) to iLen
100162>>>>>>>>>>>                Move True to bContinue
100163>>>>>>>>>>>                
100163>>>>>>>>>>>                
100163>>>>>>>>>>>                While (iFound < iMax and iRow < iCount and bContinue)
100167>>>>>>>>>>>                    If (not(bCaseSensitive)) Begin
100169>>>>>>>>>>>                        Move (Lowercase(aData[iRow][0])) to sVal
100170>>>>>>>>>>>                        Move (Lowercase(aData[iRow][1])) to sDescr
100171>>>>>>>>>>>                    End
100171>>>>>>>>>>>>
100171>>>>>>>>>>>                    Else Begin
100172>>>>>>>>>>>                        Move aData[iRow][0] to sVal
100173>>>>>>>>>>>                        Move aData[iRow][1] to sDescr
100174>>>>>>>>>>>                    End
100174>>>>>>>>>>>>
100174>>>>>>>>>>>                    
100174>>>>>>>>>>>                    If ((bFullText and (sVal contains sSearch)) or (not(bFullText) and (Left(sVal, iLen) = sSearch))) Begin
100176>>>>>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].sRowId
100177>>>>>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].aValues[0]
100178>>>>>>>>>>>                        Move aData[iRow][1] to aSuggestions[iFound].aValues[1]
100179>>>>>>>>>>>                        Increment iFound
100180>>>>>>>>>>>                    End
100180>>>>>>>>>>>>
100180>>>>>>>>>>>                    Else Begin
100181>>>>>>>>>>>                        Move (bFullText or iFound = 0) to bContinue
100182>>>>>>>>>>>                    End
100182>>>>>>>>>>>>
100182>>>>>>>>>>>                    
100182>>>>>>>>>>>                    Increment iRow
100183>>>>>>>>>>>                Loop
100184>>>>>>>>>>>>
100184>>>>>>>>>>>            End
100184>>>>>>>>>>>>
100184>>>>>>>>>>>        End
100184>>>>>>>>>>>>
100184>>>>>>>>>>>        
100184>>>>>>>>>>>    End_Procedure
100185>>>>>>>>>>>    
100185>>>>>>>>>>>    
100185>>>>>>>>>>>    Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
100187>>>>>>>>>>>        Integer iMode iFile
100187>>>>>>>>>>>        Boolean bFullText bResult bSupportsSQL
100187>>>>>>>>>>>        Handle hoServer
100187>>>>>>>>>>>        
100187>>>>>>>>>>>        Get Server to hoServer
100188>>>>>>>>>>>        Get Data_File  to iFile
100189>>>>>>>>>>>        
100189>>>>>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
100191>>>>>>>>>>>            
100191>>>>>>>>>>>            Get peSuggestionMode to iMode
100192>>>>>>>>>>>            Get pbFullText to bFullText
100193>>>>>>>>>>>            
100193>>>>>>>>>>>            If (iMode = smFind) Begin
100195>>>>>>>>>>>                If (not(bFullText)) Begin
100197>>>>>>>>>>>                    Send SuggestionsFindIncremental sSearch (&aSuggestions)
100198>>>>>>>>>>>                End
100198>>>>>>>>>>>>
100198>>>>>>>>>>>                Else Begin
100199>>>>>>>>>>>                    Get SupportsSQLFilters of hoServer to bSupportsSQL
100200>>>>>>>>>>>                    If (bSupportsSQL) Begin
100202>>>>>>>>>>>                        Send SuggestionsSQLFullText sSearch (&aSuggestions)
100203>>>>>>>>>>>                    End
100203>>>>>>>>>>>>
100203>>>>>>>>>>>                    Else Begin
100204>>>>>>>>>>>                        Send SuggestionsFindFullText sSearch (&aSuggestions)
100205>>>>>>>>>>>                    End
100205>>>>>>>>>>>>
100205>>>>>>>>>>>                End
100205>>>>>>>>>>>>
100205>>>>>>>>>>>            End
100205>>>>>>>>>>>>
100205>>>>>>>>>>>            Else If (iMode = smValidationTable) Begin
100208>>>>>>>>>>>                Send SuggestionsValidation sSearch (&aSuggestions) bFullText
100209>>>>>>>>>>>            End
100209>>>>>>>>>>>>
100209>>>>>>>>>>>        End
100209>>>>>>>>>>>>
100209>>>>>>>>>>>    End_Procedure
100210>>>>>>>>>>>    
100210>>>>>>>>>>>    Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
100212>>>>>>>>>>>        Handle hoServer
100212>>>>>>>>>>>        Integer iFile iField iMode
100212>>>>>>>>>>>        Boolean bFind
100212>>>>>>>>>>>        RowID rRowId
100212>>>>>>>>>>>        
100212>>>>>>>>>>>        Get Server to hoServer
100213>>>>>>>>>>>        Get Data_File  to iFile
100214>>>>>>>>>>>        Get Data_Field to iField
100215>>>>>>>>>>>        
100215>>>>>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
100217>>>>>>>>>>>            Get peSuggestionMode to iMode
100218>>>>>>>>>>>            
100218>>>>>>>>>>>            If (iMode = smFind) Begin
100220>>>>>>>>>>>                Get pbFindOnSelect to bFind
100221>>>>>>>>>>>                If (bFind) Begin
100223>>>>>>>>>>>                    Move (DeserializeRowID(Suggestion.sRowId)) to rRowId
100224>>>>>>>>>>>                    
100224>>>>>>>>>>>                    If (not(IsNullRowID(rRowId))) Begin
100226>>>>>>>>>>>                        Send FindByRowId of hoServer iFile rRowId
100227>>>>>>>>>>>                    End
100227>>>>>>>>>>>>
100227>>>>>>>>>>>                End
100227>>>>>>>>>>>>
100227>>>>>>>>>>>                Else Begin
100228>>>>>>>>>>>                    Set Value to Suggestion.aValues[0]
100229>>>>>>>>>>>                    Set Item_Changed_State to True
100230>>>>>>>>>>>                End
100230>>>>>>>>>>>>
100230>>>>>>>>>>>            End
100230>>>>>>>>>>>>
100230>>>>>>>>>>>            Else If (imode = smValidationTable) Begin
100233>>>>>>>>>>>                Set Value to Suggestion.sRowId
100234>>>>>>>>>>>                Set Item_Changed_State to True
100235>>>>>>>>>>>            End
100235>>>>>>>>>>>>
100235>>>>>>>>>>>            
100235>>>>>>>>>>>        End
100235>>>>>>>>>>>>
100235>>>>>>>>>>>    End_Procedure
100236>>>>>>>>>>>    
100236>>>>>>>>>>>    // Return true if Suggestion should be invoked. Can be augmented
100236>>>>>>>>>>>    Function ShouldSuggestion String sValue Boolean bChanged Returns Boolean
100238>>>>>>>>>>>        Integer iStartAtChar
100238>>>>>>>>>>>        Get piStartAtChar to iStartAtChar
100239>>>>>>>>>>>        Function_Return (bChanged and Length(sValue)>=iStartAtChar)
100240>>>>>>>>>>>    End_Function
100241>>>>>>>>>>>    
100241>>>>>>>>>>>    
100241>>>>>>>>>>>End_Class
100242>>>>>>>>>>>
100242>>>>>>>>>>>
100242>>>>>>>>>>>// This contains logic that deals with the Windows object. It relies on the interface in
100242>>>>>>>>>>>// sSuggestion_mixin, which means it must be mixed in as a sibling of this object (as is done
100242>>>>>>>>>>>// in dbSuggestionForm or as a child of this object (as is done in cDbCJGridColumnSuggestion), which
100242>>>>>>>>>>>// means messages are resolved via delegation. sSuggestion_mixin does not send messages to this class.
100242>>>>>>>>>>>// Note that cSuggestion_mixin and cSuggestionControl_mixin are designed so they can be mixed in at
100242>>>>>>>>>>>// the same level or mixed in such that cSuggestionControl_mixin is in the child object and cSuggestion_mixin
100242>>>>>>>>>>>// is in the parent
100242>>>>>>>>>>>
100242>>>>>>>>>>>Class cSuggestionControl_mixin is a Mixin
100243>>>>>>>>>>>    
100243>>>>>>>>>>>    Procedure Define_cSuggestionControl_mixin
100245>>>>>>>>>>>        
100245>>>>>>>>>>>        Property Integer piTimeOutTicks 0
100246>>>>>>>>>>>        
100246>>>>>>>>>>>        On_Key kEnter Send SelectSuggestion
100247>>>>>>>>>>>        On_Key Key_Escape Send DeActivateSuggestionList
100248>>>>>>>>>>>        On_Key Key_Up_Arrow Send Up
100249>>>>>>>>>>>        On_Key Key_Down_Arrow Send Down
100250>>>>>>>>>>>        
100250>>>>>>>>>>>    End_Procedure
100251>>>>>>>>>>>    
100251>>>>>>>>>>>    Procedure AdjustSuggestionListSize Integer iLines
100253>>>>>>>>>>>        Integer i  iX iMax iY
100253>>>>>>>>>>>        String sTxt
100253>>>>>>>>>>>        Boolean bFullWidth
100253>>>>>>>>>>>        For i from 0 to (iLines-1)
100259>>>>>>>>>>>>
100259>>>>>>>>>>>            Get Line of ghoSuggestionList i to sTxt
100260>>>>>>>>>>>            Get Text_Extent of ghoSuggestionList sTxt to iX
100261>>>>>>>>>>>            Move (Low(iX) max iMax) to iMax
100262>>>>>>>>>>>            Move (Hi(iX)) to iY
100263>>>>>>>>>>>        Loop
100264>>>>>>>>>>>>
100264>>>>>>>>>>>        Move (iMax + 20) to imax
100265>>>>>>>>>>>        Get pbFullWidth to bFullWidth
100266>>>>>>>>>>>        If bFullWidth Begin
100268>>>>>>>>>>>            Move (iMax max (Low(GuiSize(Self)))) to iMax
100269>>>>>>>>>>>        End
100269>>>>>>>>>>>>
100269>>>>>>>>>>>        If (iLines) Begin
100271>>>>>>>>>>>            Set GuiSize of ghoSuggestionList to (iY*(iLines)+8) iMax
100272>>>>>>>>>>>            Send SelectRow of ghoSuggestionList 0 // go to first line
100273>>>>>>>>>>>        End
100273>>>>>>>>>>>>
100273>>>>>>>>>>>        Else Begin
100274>>>>>>>>>>>            Set GuiSize of ghoSuggestionList to (Hi(GuiSize(Self))) (low(GuiSize(Self)))
100275>>>>>>>>>>>        End
100275>>>>>>>>>>>>
100275>>>>>>>>>>>    End_Procedure
100276>>>>>>>>>>>    
100276>>>>>>>>>>>    // show all suggestions
100276>>>>>>>>>>>    Procedure ShowSuggestions
100278>>>>>>>>>>>        tSuggestion[] aResults
100278>>>>>>>>>>>        tSuggestion[] aResults
100279>>>>>>>>>>>        Integer i iLines
100279>>>>>>>>>>>        String sSearch
100279>>>>>>>>>>>        Get pSearchResults to aResults
100280>>>>>>>>>>>        Get Value to sSearch
100281>>>>>>>>>>>        Send Delete_Data of ghoSuggestionList
100282>>>>>>>>>>>        Move (SizeOfArray(aResults)) to iLines
100283>>>>>>>>>>>        For i from 0 to (iLines-1)
100289>>>>>>>>>>>>
100289>>>>>>>>>>>            Send ShowSuggestion aResults[i] sSearch
100290>>>>>>>>>>>            If ((iLines-1)<>i) Begin
100292>>>>>>>>>>>                Send AppendTextLn of ghoSuggestionList ""
100293>>>>>>>>>>>            End
100293>>>>>>>>>>>>
100293>>>>>>>>>>>        Loop
100294>>>>>>>>>>>>
100294>>>>>>>>>>>        Send AdjustSuggestionListSize iLines
100295>>>>>>>>>>>    End_Procedure
100296>>>>>>>>>>>    
100296>>>>>>>>>>>    Procedure FindSuggestions
100298>>>>>>>>>>>        String sSearch
100298>>>>>>>>>>>        tSuggestion[] aResults
100298>>>>>>>>>>>        tSuggestion[] aResults
100299>>>>>>>>>>>        String[] aParams
100300>>>>>>>>>>>        Get Value to sSearch
100301>>>>>>>>>>>        Send OnFindSuggestions sSearch (&aResults)
100302>>>>>>>>>>>        Set pSearchResults to aResults
100303>>>>>>>>>>>        // if an error was raised, the suggestion list will be gone
100303>>>>>>>>>>>        If (ghoSuggestionList) Begin
100305>>>>>>>>>>>            Send ShowSuggestions
100306>>>>>>>>>>>        End
100306>>>>>>>>>>>>
100306>>>>>>>>>>>    End_Procedure
100307>>>>>>>>>>>    
100307>>>>>>>>>>>    Procedure SelectSuggestion
100309>>>>>>>>>>>        String sSearch
100309>>>>>>>>>>>        tSuggestion[] aData
100309>>>>>>>>>>>        tSuggestion[] aData
100310>>>>>>>>>>>        Integer iSelRow
100310>>>>>>>>>>>        If ghoSuggestionList Begin
100312>>>>>>>>>>>            Get SelectedRow of ghoSuggestionList to iSelRow
100313>>>>>>>>>>>            Get Value to sSearch
100314>>>>>>>>>>>            Get pSearchResults to aData
100315>>>>>>>>>>>            Send DeActivateSuggestionList
100316>>>>>>>>>>>            Send CancelEditIfGrid
100317>>>>>>>>>>>            If (iSelRow>=0 and SizeOfArray(aData)>iSelRow) Begin
100319>>>>>>>>>>>                Send OnSelectSuggestion sSearch aData[iSelRow]
100320>>>>>>>>>>>            End
100320>>>>>>>>>>>>
100320>>>>>>>>>>>        End
100320>>>>>>>>>>>>
100320>>>>>>>>>>>        Else Begin
100321>>>>>>>>>>>            Send Default_Action
100322>>>>>>>>>>>        End
100322>>>>>>>>>>>>
100322>>>>>>>>>>>    End_Procedure
100323>>>>>>>>>>>    
100323>>>>>>>>>>>    Procedure CancelEditIfGrid
100325>>>>>>>>>>>        // do nothing with forms, remember
100325>>>>>>>>>>>        // to replace or augment with grid to
100325>>>>>>>>>>>        // cancel the edit control
100325>>>>>>>>>>>    End_Procedure
100326>>>>>>>>>>>    
100326>>>>>>>>>>>    
100326>>>>>>>>>>>    Function ParentForSuggestion Returns Handle
100328>>>>>>>>>>>        Handle hoMain hoMainPanel
100328>>>>>>>>>>>        
100328>>>>>>>>>>>        // we must have an application object and a main panel object
100328>>>>>>>>>>>        If ghoApplication Begin
100330>>>>>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
100331>>>>>>>>>>>        End
100331>>>>>>>>>>>>
100331>>>>>>>>>>>        If (hoMainPanel=0 or Self<=Desktop) Begin
100333>>>>>>>>>>>            Function_Return 0
100334>>>>>>>>>>>        End
100334>>>>>>>>>>>>
100334>>>>>>>>>>>        
100334>>>>>>>>>>>        Move Self to hoMain
100335>>>>>>>>>>>        Repeat
100335>>>>>>>>>>>>
100335>>>>>>>>>>>            Get Parent of hoMain to hoMain
100336>>>>>>>>>>>        Until (hoMain=Desktop or Block_Mouse_State(hoMain) or hoMainPanel=hoMain)
100338>>>>>>>>>>>        
100338>>>>>>>>>>>        Function_Return (If(hoMain>Desktop,hoMain,0))
100339>>>>>>>>>>>        
100339>>>>>>>>>>>    End_Function
100340>>>>>>>>>>>    
100340>>>>>>>>>>>    Procedure ActivateSuggestionList
100342>>>>>>>>>>>        Handle hoView hcSuggest
100342>>>>>>>>>>>        Get ParentForSuggestion to hoView
100343>>>>>>>>>>>        If hoView Begin
100345>>>>>>>>>>>            Get phcSuggestionListClass to hcSuggest
100346>>>>>>>>>>>            Get CreateNamed of hoView hcSuggest "oSuggestList" to ghoSuggestionList
100347>>>>>>>>>>>            Send InitList of ghoSuggestionList Self
100348>>>>>>>>>>>            Set Focus_Mode of ghoSuggestionList to Focusable
100349>>>>>>>>>>>            Set phoOwner of ghoSuggestionList to Self
100350>>>>>>>>>>>            Send Add_Focus of ghoSuggestionList hoView
100351>>>>>>>>>>>        End
100351>>>>>>>>>>>>
100351>>>>>>>>>>>    End_Procedure
100352>>>>>>>>>>>    
100352>>>>>>>>>>>    Procedure DeActivateSuggestionList
100354>>>>>>>>>>>        If ghoSuggestionList Begin
100356>>>>>>>>>>>            Send DeactivateList of ghoSuggestionList
100357>>>>>>>>>>>        End
100357>>>>>>>>>>>>
100357>>>>>>>>>>>    End_Procedure
100358>>>>>>>>>>>    
100358>>>>>>>>>>>    // augment to kill suggest list if focus is not moving to it
100358>>>>>>>>>>>    // customized for grid
100358>>>>>>>>>>>    Procedure OnKillFocus
100360>>>>>>>>>>>        // note focus has already changed here
100360>>>>>>>>>>>        If (ghoSuggestionList) Begin
100362>>>>>>>>>>>            If (Focus(Self)<>ghoSuggestionList) Begin
100364>>>>>>>>>>>                Send DeActivateSuggestionList
100365>>>>>>>>>>>                Forward Send OnKillFocus
100367>>>>>>>>>>>            End
100367>>>>>>>>>>>>
100367>>>>>>>>>>>            Else Begin
100368>>>>>>>>>>>                // giving focus to the suggestion list here
100368>>>>>>>>>>>            End
100368>>>>>>>>>>>>
100368>>>>>>>>>>>        End
100368>>>>>>>>>>>>
100368>>>>>>>>>>>        Else Begin
100369>>>>>>>>>>>            Forward Send OnKillFocus
100371>>>>>>>>>>>        End
100371>>>>>>>>>>>>
100371>>>>>>>>>>>    End_Procedure
100372>>>>>>>>>>>    
100372>>>>>>>>>>>    Procedure Up
100374>>>>>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
100376>>>>>>>>>>>            Send ScrollUp of ghoSuggestionList
100377>>>>>>>>>>>        End
100377>>>>>>>>>>>>
100377>>>>>>>>>>>    End_Procedure
100378>>>>>>>>>>>    
100378>>>>>>>>>>>    Procedure Down
100380>>>>>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
100382>>>>>>>>>>>            Send ScrollDown of ghoSuggestionList
100383>>>>>>>>>>>        End
100383>>>>>>>>>>>>
100383>>>>>>>>>>>    End_Procedure
100384>>>>>>>>>>>    
100384>>>>>>>>>>>    
100384>>>>>>>>>>>    Procedure Key Integer iKey
100386>>>>>>>>>>>        Integer iEndTicks
100386>>>>>>>>>>>        
100386>>>>>>>>>>>        If (Focus(Desktop) <> Self) Begin
100388>>>>>>>>>>>            Forward Send Key iKey
100390>>>>>>>>>>>            Procedure_Return
100391>>>>>>>>>>>        End
100391>>>>>>>>>>>>
100391>>>>>>>>>>>        
100391>>>>>>>>>>>        Send DeActivateSuggestionList
100392>>>>>>>>>>>        Move (GetTickCount()) to iEndTicks
100393>>>>>>>>>>>        // record the time of key press
100393>>>>>>>>>>>        If (piTimeOutTicks(Self) = 0) Begin
100395>>>>>>>>>>>            
100395>>>>>>>>>>>            If (ghoSuggestionTimer=0) Begin
100397>>>>>>>>>>>                Send CreateSuggestionTimer
100398>>>>>>>>>>>            End
100398>>>>>>>>>>>>
100398>>>>>>>>>>>            
100398>>>>>>>>>>>            Set pbEnabled of ghoSuggestionTimer to True
100399>>>>>>>>>>>            Set phoTimerOwner of ghoSuggestionTimer to Self
100400>>>>>>>>>>>        End
100400>>>>>>>>>>>>
100400>>>>>>>>>>>        Set piTimeOutTicks to iEndTicks
100401>>>>>>>>>>>        
100401>>>>>>>>>>>        Forward Send Key iKey
100403>>>>>>>>>>>    End_Procedure
100404>>>>>>>>>>>    
100404>>>>>>>>>>>    Procedure CreateSuggestionTimer
100406>>>>>>>>>>>        Handle hoMainPanel
100406>>>>>>>>>>>        // we must have an application object and a main panel object
100406>>>>>>>>>>>        If ghoApplication Begin
100408>>>>>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
100409>>>>>>>>>>>        End
100409>>>>>>>>>>>>
100409>>>>>>>>>>>        If (hoMainPanel=0) Begin
100411>>>>>>>>>>>            Error DFERR_PROGRAM "Auto-suggest requires an application object and a main panel object"
100412>>>>>>>>>>>>
100412>>>>>>>>>>>            Procedure_Return
100413>>>>>>>>>>>        End
100413>>>>>>>>>>>>
100413>>>>>>>>>>>        Get CreateNamed of hoMainPanel (RefClass(cSuggestionTimer)) "oSuggestionTimer" to ghoSuggestionTimer
100414>>>>>>>>>>>    End_Procedure
100415>>>>>>>>>>>    
100415>>>>>>>>>>>    // sent by Auto Suggest Timer. Invoke suggestion list as needed
100415>>>>>>>>>>>    Procedure OnSuggestionTimer
100417>>>>>>>>>>>        Boolean bDoIt
100417>>>>>>>>>>>        Integer iEndTicks iStartTicks iTicks iTimeOut iChanged
100417>>>>>>>>>>>        String sValue
100417>>>>>>>>>>>        
100417>>>>>>>>>>>        If (Focus(Desktop) <> Self) Begin
100419>>>>>>>>>>>            // focus out of whack. Stop the timer
100419>>>>>>>>>>>            Set pbEnabled of ghoSuggestionTimer to False
100420>>>>>>>>>>>            Send DeActivateSuggestionList
100421>>>>>>>>>>>            Procedure_Return
100422>>>>>>>>>>>        End
100422>>>>>>>>>>>>
100422>>>>>>>>>>>        
100422>>>>>>>>>>>        Get piTimeOutTicks to iStartTicks
100423>>>>>>>>>>>        If (iStartTicks <> 0) Begin
100425>>>>>>>>>>>            Move (GetTickCount()) to iEndTicks
100426>>>>>>>>>>>            Move (iEndTicks - iStartTicks) to iTicks
100427>>>>>>>>>>>            // If tick count rolled over
100427>>>>>>>>>>>            If (iTicks < 0) Begin
100429>>>>>>>>>>>                Move (-iTicks) to iTicks
100430>>>>>>>>>>>            End
100430>>>>>>>>>>>>
100430>>>>>>>>>>>        End
100430>>>>>>>>>>>>
100430>>>>>>>>>>>        Get piPopupTimeout to iTimeOut
100431>>>>>>>>>>>        If (iTicks >= iTimeOut) Begin
100433>>>>>>>>>>>            // If time delay has been met, launch autocomplete
100433>>>>>>>>>>>            Set pbEnabled  of ghoSuggestionTimer to False
100434>>>>>>>>>>>            Get Value to sValue
100435>>>>>>>>>>>            Get Item_Changed_State 0 to iChanged
100436>>>>>>>>>>>            Get ShouldSuggestion sValue iChanged to bDoIt
100437>>>>>>>>>>>            If bDoIt Begin
100439>>>>>>>>>>>                Send ActivateSuggestionList
100440>>>>>>>>>>>                Send FindSuggestions
100441>>>>>>>>>>>                Set Visible_State of ghoSuggestionList to True
100442>>>>>>>>>>>            End
100442>>>>>>>>>>>>
100442>>>>>>>>>>>            Set piTimeOutTicks to 0
100443>>>>>>>>>>>        End
100443>>>>>>>>>>>>
100443>>>>>>>>>>>    End_Procedure
100444>>>>>>>>>>>    
100444>>>>>>>>>>>End_Class
100445>>>>>>>>>>>
100445>>>>>>>>>>>
100445>>>>>>>>>Use cIniFile.pkg            
100445>>>>>>>>>Use cRDCForm.pkg
100445>>>>>>>>>Use vWin32fh.pkg
100445>>>>>>>>>
100445>>>>>>>>>    Define CS_cRDCSuggestionFormList       for "Suggestion Form List"  // [Section Name]
100445>>>>>>>>>    Define CS_cRDCSuggestionSaveItem       for "Saved Item"            // Key=Value
100445>>>>>>>>>    Define CS_cRDCSuggestionFormTooltip    for "This is a suggestion form - start typing what you're looking for. Previously entered values are saved automatically."
100445>>>>>>>>>
100445>>>>>>>>>Class cRDCSuggestionIniForm is a cRDCForm
100446>>>>>>>>>
100446>>>>>>>>>    Procedure Define_cRDCSuggestionControl_mixin
100448>>>>>>>>>
100448>>>>>>>>>        Property Integer piTimeOutTicks 0
100449>>>>>>>>>
100449>>>>>>>>>        On_Key kEnter            Send SelectSuggestion
100450>>>>>>>>>        On_Key Key_Escape        Send DeActivateSuggestionList
100451>>>>>>>>>        On_Key Key_Up_Arrow      Send Up
100452>>>>>>>>>        On_Key Key_Down_Arrow    Send Down
100453>>>>>>>>>
100453>>>>>>>>>        // Added 'Home' & 'End' navigation keys for the drop-down list and the form object (and Ctrl+Home & Ctrl+End).
100453>>>>>>>>>        On_Key Key_Home          Send Home
100454>>>>>>>>>        On_Key Key_Ctrl+Key_Home Send Home
100455>>>>>>>>>        On_Key Key_End           Send End
100456>>>>>>>>>        On_Key Key_Ctrl+Key_End  Send End // Need this as well; else the Ctrl+Home/End keys generates a runtime error (always has).
100457>>>>>>>>>
100457>>>>>>>>>        // Just can't seem to get the popup of the suggestion list with F4 to work.
100457>>>>>>>>>        On_Key kPrompt           Send Prompt
100458>>>>>>>>>    End_Procedure
100459>>>>>>>>>
100459>>>>>>>>>    Import_Class_Protocol cSuggestionControl_mixin
100460>>>>>>>>>    Import_Class_Protocol cSuggestion_mixin
100461>>>>>>>>>
100461>>>>>>>>>    Procedure Construct_Object
100463>>>>>>>>>        Forward Send Construct_Object
100465>>>>>>>>>        Send Define_cRDCSuggestionControl_mixin
100466>>>>>>>>>        Send Define_cSuggestion_mixin
100467>>>>>>>>>
100467>>>>>>>>>        Set peSuggestionMode to smCustom
100468>>>>>>>>>        Set pbFullText to True
100469>>>>>>>>>        Set piStartAtChar to 1
100470>>>>>>>>>
100470>>>>>>>>>        Property String[] psSavedFormValues
100471>>>>>>>>>        Property String psIniFileSection
100472>>>>>>>>>        Property Integer piSuggestionListMaxItems 99 // Max no of values saved/read to ini file
100473>>>>>>>>>        Property Boolean pbUseWorkspaceIniFile True
100474>>>>>>>>>        Property Boolean pbAutoCheckValueExistsAsFile True
100475>>>>>>>>>        Property Boolean pbAskToRemoveMissingFile True
100476>>>>>>>>>        // Note: pbUseWorkspaceIniFile has presedence over the psIniFileName setting.
100476>>>>>>>>>        //       That means that if pbUseWorkspaceIniFile=True, psIniFilename will be set to the
100476>>>>>>>>>        //       worspace .ws file on program startup.
100476>>>>>>>>>        Property String psIniFileName "RDCSuggestionForm.ini"
100477>>>>>>>>>    End_Procedure
100478>>>>>>>>>
100478>>>>>>>>>    Procedure ShowSuggestions
100480>>>>>>>>>        tSuggestion[] aResults
100480>>>>>>>>>        tSuggestion[] aResults
100481>>>>>>>>>        Integer i iLines
100481>>>>>>>>>        String sSearch
100481>>>>>>>>>
100481>>>>>>>>>
100481>>>>>>>>>        Get pSearchResults to aResults
100482>>>>>>>>>        Get Value to sSearch
100483>>>>>>>>>
100483>>>>>>>>>        If (ghoSuggestionList <> 0) Begin
100485>>>>>>>>>            Send Delete_Data of ghoSuggestionList
100486>>>>>>>>>            Move (SizeOfArray(aResults)) to iLines
100487>>>>>>>>>            For i from 0 to (iLines-1)
100493>>>>>>>>>>
100493>>>>>>>>>                Send ShowSuggestion aResults[i] sSearch
100494>>>>>>>>>                If ((iLines-1)<>i) Begin
100496>>>>>>>>>                    Send AppendTextLn of ghoSuggestionList ""
100497>>>>>>>>>                End
100497>>>>>>>>>>
100497>>>>>>>>>            Loop
100498>>>>>>>>>>
100498>>>>>>>>>            Send AdjustSuggestionListSize iLines
100499>>>>>>>>>        End
100499>>>>>>>>>>
100499>>>>>>>>>
100499>>>>>>>>>        Set Cursor of Cursor_Control to IDC_ARROW
100500>>>>>>>>>        Send Activate of (Self)
100501>>>>>>>>>        Send Release_Mouse_Capture
100502>>>>>>>>>    End_Procedure
100503>>>>>>>>>
100503>>>>>>>>>    Procedure Home
100505>>>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
100507>>>>>>>>>           Send ScrollHome
100508>>>>>>>>>        End
100508>>>>>>>>>>
100508>>>>>>>>>        Else Begin
100509>>>>>>>>>            Send Key VK_HOME
100510>>>>>>>>>        End
100510>>>>>>>>>>
100510>>>>>>>>>    End_Procedure
100511>>>>>>>>>
100511>>>>>>>>>    Procedure ScrollHome
100513>>>>>>>>>        Send SelectRow of ghoSuggestionList 0
100514>>>>>>>>>    End_Procedure
100515>>>>>>>>>
100515>>>>>>>>>    Procedure End
100517>>>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
100519>>>>>>>>>           Send ScrollEnd
100520>>>>>>>>>        End
100520>>>>>>>>>>
100520>>>>>>>>>        Else Begin
100521>>>>>>>>>            Send Key VK_END
100522>>>>>>>>>        End
100522>>>>>>>>>>
100522>>>>>>>>>    End_Procedure
100523>>>>>>>>>
100523>>>>>>>>>    Procedure ScrollEnd
100525>>>>>>>>>        Integer iLine iLines
100525>>>>>>>>>        Get Line_Count of ghoSuggestionList  to iLines
100526>>>>>>>>>        Get SelectedRow of ghoSuggestionList to iLine
100527>>>>>>>>>        // there can be an extra line at the end
100527>>>>>>>>>        If (iLine < iLines - 1) Begin
100529>>>>>>>>>            Send SelectRow of ghoSuggestionList (iLines - 1)
100530>>>>>>>>>        End
100530>>>>>>>>>>
100530>>>>>>>>>    End_Procedure
100531>>>>>>>>>
100531>>>>>>>>>    Procedure Activating
100533>>>>>>>>>        String[] sSavedFormValues
100534>>>>>>>>>        If (pbUseWorkspaceIniFile(Self) = True) Begin
100536>>>>>>>>>            Get ReadWorkspaceIniFile to sSavedFormValues
100537>>>>>>>>>            Set psSavedFormValues    to sSavedFormValues
100538>>>>>>>>>        End
100538>>>>>>>>>>
100538>>>>>>>>>    End_Procedure
100539>>>>>>>>>
100539>>>>>>>>>    Procedure Set psToolTip String sToolTip
100541>>>>>>>>>        String sStatusHelp
100541>>>>>>>>>
100541>>>>>>>>>        Get Status_Help to sStatusHelp
100542>>>>>>>>>        If (sStatusHelp = "") Begin
100544>>>>>>>>>            Set Status_Help to sToolTip
100545>>>>>>>>>        End
100545>>>>>>>>>>
100545>>>>>>>>>
100545>>>>>>>>>        Move (sToolTip + String(Character(10)) + String(CS_cRDCSuggestionFormTooltip)) to sToolTip
100546>>>>>>>>>        Forward Set psToolTip to sToolTip
100548>>>>>>>>>    End_Procedure
100549>>>>>>>>>
100549>>>>>>>>>    Function ReadWorkspaceIniFile Returns String[]
100551>>>>>>>>>        String sWorkspaceFile sObjectName sValue
100551>>>>>>>>>        String[] sSavedFormValues
100552>>>>>>>>>        Handle hoIniFile
100552>>>>>>>>>        Integer iItem iCount iSize
100552>>>>>>>>>        Boolean bExists
100552>>>>>>>>>
100552>>>>>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
100554>>>>>>>>>            Function_Return sSavedFormValues
100555>>>>>>>>>        End
100555>>>>>>>>>>
100555>>>>>>>>>
100555>>>>>>>>>        Move 0 to iItem
100556>>>>>>>>>        Get Object_Label to sObjectName
100557>>>>>>>>>        Move (psWorkspaceWSFile(phoWorkspace(ghoApplication))) to sWorkspaceFile
100558>>>>>>>>>        Set psIniFileName to sWorkspaceFile
100559>>>>>>>>>        Get Create (RefClass(cIniFile)) to hoIniFile
100560>>>>>>>>>        Set psFileName of hoIniFile to sWorkspaceFile
100561>>>>>>>>>        Get piSuggestionListMaxItems to iSize
100562>>>>>>>>>
100562>>>>>>>>>        For iCount from 0 to iSize
100568>>>>>>>>>>
100568>>>>>>>>>            Get KeyExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) to bExists
100569>>>>>>>>>            // We need to loop through all possible values because the list of items may not start at zero.
100569>>>>>>>>>            Get ReadString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) "" to sValue
100570>>>>>>>>>            If (Trim(sValue) <> "") Begin
100572>>>>>>>>>                Move sValue to sSavedFormValues[iItem]
100573>>>>>>>>>                Increment iItem
100574>>>>>>>>>            End
100574>>>>>>>>>>
100574>>>>>>>>>        Loop
100575>>>>>>>>>>
100575>>>>>>>>>
100575>>>>>>>>>        Send Destroy of hoIniFile
100576>>>>>>>>>        Function_Return sSavedFormValues
100577>>>>>>>>>    End_Function
100578>>>>>>>>>
100578>>>>>>>>>    Procedure WriteWorkspaceIniFile
100580>>>>>>>>>        String sWorkspaceFile sObjectName sValue
100580>>>>>>>>>        String[] sSavedFormValues
100581>>>>>>>>>        Handle hoIniFile
100581>>>>>>>>>        Integer iSize iCount
100581>>>>>>>>>        Boolean bExists
100581>>>>>>>>>
100581>>>>>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
100583>>>>>>>>>            Procedure_Return
100584>>>>>>>>>        End
100584>>>>>>>>>>
100584>>>>>>>>>
100584>>>>>>>>>        Get Object_Label  to sObjectName
100585>>>>>>>>>        Get psIniFileName to sWorkspaceFile
100586>>>>>>>>>        Get Create (RefClass(cIniFile)) to hoIniFile
100587>>>>>>>>>        Set psFileName    of hoIniFile to sWorkspaceFile
100588>>>>>>>>>        Get SectionExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) to bExists
100589>>>>>>>>>        If (bExists = True) Begin
100591>>>>>>>>>            Send DeleteSection of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName))
100592>>>>>>>>>        End
100592>>>>>>>>>>
100592>>>>>>>>>
100592>>>>>>>>>        Get psSavedFormValues to sSavedFormValues
100593>>>>>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
100594>>>>>>>>>        Decrement iSize
100595>>>>>>>>>
100595>>>>>>>>>        For iCount from 0 to iSize
100601>>>>>>>>>>
100601>>>>>>>>>            Move sSavedFormValues[iCount] to sValue
100602>>>>>>>>>            Move (Trim(sValue)) to sValue
100603>>>>>>>>>            Get vFilePathExists sValue to bExists
100604>>>>>>>>>            If (bExists = True) Begin
100606>>>>>>>>>                Send WriteString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) sSavedFormValues[iCount]
100607>>>>>>>>>            End
100607>>>>>>>>>>
100607>>>>>>>>>        Loop
100608>>>>>>>>>>
100608>>>>>>>>>
100608>>>>>>>>>        Send Destroy of hoIniFile
100609>>>>>>>>>    End_Procedure
100610>>>>>>>>>
100610>>>>>>>>>    Procedure Prompt      
100612>>>>>>>>>        If (ghoSuggestionTimer=0) Begin
100614>>>>>>>>>            Send CreateSuggestionTimer
100615>>>>>>>>>        End
100615>>>>>>>>>>
100615>>>>>>>>>        Send ActivateSuggestionList
100616>>>>>>>>>        Send FindSuggestions
100617>>>>>>>>>        Set Visible_State of ghoSuggestionList to True
100618>>>>>>>>>    End_Procedure 
100619>>>>>>>>>    
100619>>>>>>>>>    Procedure OnExitObject
100621>>>>>>>>>        String sValue
100621>>>>>>>>>        Boolean bExists
100621>>>>>>>>>        String[] sSavedFormValues
100622>>>>>>>>>        Integer iSize iIndex
100622>>>>>>>>>
100622>>>>>>>>>        Forward Send OnExitObject
100624>>>>>>>>>
100624>>>>>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
100626>>>>>>>>>            Procedure_Return
100627>>>>>>>>>        End
100627>>>>>>>>>>
100627>>>>>>>>>
100627>>>>>>>>>        Get Value to sValue
100628>>>>>>>>>        Move (Trim(sValue)) to sValue
100629>>>>>>>>>        Get psSavedFormValues to sSavedFormValues
100630>>>>>>>>>        Move (SearchArray(sValue, sSavedFormValues)) to iIndex
100631>>>>>>>>>        // Does it exist in the array already?
100631>>>>>>>>>        If (iIndex <> -1) Begin
100633>>>>>>>>>            Procedure_Return
100634>>>>>>>>>        End
100634>>>>>>>>>>
100634>>>>>>>>>        Get vFilePathExists sValue to bExists
100635>>>>>>>>>        If (bExists = False) Begin
100637>>>>>>>>>            Procedure_Return
100638>>>>>>>>>        End
100638>>>>>>>>>>
100638>>>>>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
100639>>>>>>>>>        Move sValue to sSavedFormValues[iSize]
100640>>>>>>>>>        Set psSavedFormValues to sSavedFormValues
100641>>>>>>>>>        Send WriteWorkspaceIniFile
100642>>>>>>>>>    End_Procedure
100643>>>>>>>>>
100643>>>>>>>>>    // Custom code to find all matches for the search
100643>>>>>>>>>    Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
100645>>>>>>>>>        String[] sSavedFormValues
100646>>>>>>>>>        Integer i iLen iSize iCount
100646>>>>>>>>>
100646>>>>>>>>>        Move (Lowercase(sSearch)) to sSearch
100647>>>>>>>>>        Move (Length(sSearch)) to iLen
100648>>>>>>>>>        Get psSavedFormValues to sSavedFormValues
100649>>>>>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
100650>>>>>>>>>        Decrement iSize
100651>>>>>>>>>        For i from 0 to iSize
100657>>>>>>>>>>
100657>>>>>>>>>            If (Lowercase(sSavedFormValues[i]) contains sSearch) Begin
100659>>>>>>>>>                Move sSavedFormValues[i] to aSuggestions[iCount].sRowId
100660>>>>>>>>>                Move sSavedFormValues[i] to aSuggestions[iCount].aValues[0]
100661>>>>>>>>>                Increment iCount
100662>>>>>>>>>            End
100662>>>>>>>>>>
100662>>>>>>>>>        Loop
100663>>>>>>>>>>
100663>>>>>>>>>    End_Procedure
100664>>>>>>>>>
100664>>>>>>>>>    Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
100666>>>>>>>>>        Boolean bExists bAutoCheckValueExistsAsFile bAskToRemoveMissingFile
100666>>>>>>>>>        Integer iRetval iIndex
100666>>>>>>>>>        String[] sSavedFormValues
100667>>>>>>>>>        String sValue
100667>>>>>>>>>
100667>>>>>>>>>//        Send Release_Mouse_Capture
100667>>>>>>>>>        Move Suggestion.sRowId to sValue
100668>>>>>>>>>        Move (Trim(sValue)) to sValue
100669>>>>>>>>>        Get pbAutoCheckValueExistsAsFile to bAutoCheckValueExistsAsFile
100670>>>>>>>>>
100670>>>>>>>>>        If (bAutoCheckValueExistsAsFile = True) Begin
100672>>>>>>>>>            Get pbAskToRemoveMissingFile to bAskToRemoveMissingFile
100673>>>>>>>>>            Get vFilePathExists sValue to bExists
100674>>>>>>>>>            If (bExists = False) Begin
100676>>>>>>>>>                If (bAskToRemoveMissingFile = True) Begin
100678>>>>>>>>>                    Get YesNo_Box ("The file" * String(sValue) + "\nDoesn't exist. Do you want to remove it from the suggestion list?") to iRetval
100679>>>>>>>>>                End
100679>>>>>>>>>>
100679>>>>>>>>>                // This will happen if bAskToRemoveMissingFile = False, and bAutoCheckValueExistsAsFile = True.
100679>>>>>>>>>                // Then the missing file will just be removed from the saved list.
100679>>>>>>>>>                Else Begin
100680>>>>>>>>>                    Move MBR_Yes to iRetval
100681>>>>>>>>>                End
100681>>>>>>>>>>
100681>>>>>>>>>
100681>>>>>>>>>                If (iRetval = MBR_Yes) Begin
100683>>>>>>>>>                    Get psSavedFormValues to sSavedFormValues
100684>>>>>>>>>                    Move (SearchArray(sValue, sSavedFormValues)) to iIndex
100685>>>>>>>>>                    If (iIndex <> -1) Begin
100687>>>>>>>>>                        Move (RemoveFromArray(sSavedFormValues, iIndex)) to sSavedFormValues
100688>>>>>>>>>                        Set psSavedFormValues to sSavedFormValues
100689>>>>>>>>>                        Send WriteWorkspaceIniFile
100690>>>>>>>>>                        Set Value to ""
100691>>>>>>>>>                        Procedure_Return
100692>>>>>>>>>                    End
100692>>>>>>>>>>
100692>>>>>>>>>                End
100692>>>>>>>>>>
100692>>>>>>>>>            End
100692>>>>>>>>>>
100692>>>>>>>>>        End
100692>>>>>>>>>>
100692>>>>>>>>>
100692>>>>>>>>>        Set Value to Suggestion.sRowId
100693>>>>>>>>>        Set Item_Changed_State to False
100694>>>>>>>>>    End_Procedure
100695>>>>>>>>>
100695>>>>>>>>>//    { MethodType=Event  NoDoc=True }
100695>>>>>>>>>//    Procedure Mouse_Click Integer i1 Integer i2
100695>>>>>>>>>//        Send Release_Mouse_Capture
100695>>>>>>>>>//        Forward Send Mouse_click i1 i2
100695>>>>>>>>>//    End_Procedure
100695>>>>>>>>>
100695>>>>>>>>>End_Class
100696>>>>>>>>>
100696>>>>>>>>>//    Procedure Mouse_Up for cRDCSuggestionList Integer iWindowNumber Integer iPosition
100696>>>>>>>>>//        Handle hoObj
100696>>>>>>>>>//        Send Release_Mouse_Capture
100696>>>>>>>>>//        Get phoOwner to hoObj
100696>>>>>>>>>//        Send Activate of hoObj // move focus to owner, which will close the list
100696>>>>>>>>>//        Send SelectSuggestion of hoObj
100696>>>>>>>>>//    End_Procedure // Mouse_Up
100696>>>>>>>>>
100696>>>>>>>>>//    Function OnWindowsHook for cRDCSuggestionHookMouse Integer i1 Integer i2 Integer i3 Returns Integer
100696>>>>>>>>>//        tWinMouseHookStruct MouseHook
100696>>>>>>>>>//        Integer ivoid hObj
100696>>>>>>>>>//        Handle hoOwner hoParent
100696>>>>>>>>>//        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;
100696>>>>>>>>>//                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
100696>>>>>>>>>//            Send Release_Mouse_Capture
100696>>>>>>>>>//            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
100696>>>>>>>>>//            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
100696>>>>>>>>>//            If (hObj = Cursor_Control) Begin
100696>>>>>>>>>//                Move (Focus(Desktop)) to hObj
100696>>>>>>>>>//            End
100696>>>>>>>>>//            Get Parent to hoParent
100696>>>>>>>>>//            Get phoOwner of hoParent to hoOwner
100696>>>>>>>>>//            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
100696>>>>>>>>>//                Send DisableWindowsHook
100696>>>>>>>>>//                Send DeActivateSuggestionList of hoOwner
100696>>>>>>>>>//            End
100696>>>>>>>>>//        End
100696>>>>>>>>>//    End_Function
100696>>>>>>>>>
100696>>>>>>>Use cDbUpdateFunctionLibrary.pkg
100696>>>>>>>Use cRDCHeaderGroup.pkg
100696>>>>>>>Use cCommandLinkButton.pkg
100696>>>>>>>
100696>>>>>>>Object oCreateDatabase_dg is a cRDCModalPanel
100698>>>>>>>    Set Size to 151 312
100699>>>>>>>    Set Label to "Create New Database"
100700>>>>>>>    Set piMinSize to 53 211
100701>>>>>>>    Set Location to 2 2
100702>>>>>>>    Set Icon to "ActionCreateDatabase1.ico"
100703>>>>>>>    
100703>>>>>>>    Property String psDriverID                   
100705>>>>>>>    Property String psCollation 
100707>>>>>>>    Property String psDatabaseName 
100709>>>>>>>
100709>>>>>>>//    Object oCollate_cf is a cRDCComboForm
100709>>>>>>>//        Set Size to 13 216
100709>>>>>>>//        Set Location to 42 63
100709>>>>>>>//        Set Label to "Use Collation:"  
100709>>>>>>>//        Set psToolTip to "Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
100709>>>>>>>//        // This must be set to False; else the filling takes for ever.
100709>>>>>>>//        Set pbAutoListWidth to False
100709>>>>>>>//        
100709>>>>>>>//        Procedure Combo_Fill_List
100709>>>>>>>//            String[] asCollations   
100709>>>>>>>//            Integer iCount iSize      
100709>>>>>>>//            String sDriverID sCollation
100709>>>>>>>//            
100709>>>>>>>//            Get psDriverID to sDriverID      
100709>>>>>>>//            
100709>>>>>>>//            // The SqlEnumerateDatabaseCollations function is *at current* for MSSQLDRV_ID only.
100709>>>>>>>//            If (sDriverID = MSSQLDRV_ID) Begin
100709>>>>>>>//                Send Cursor_Wait of Cursor_Control
100709>>>>>>>//                Get SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
100709>>>>>>>//                Move (SizeOfArray(asCollations)) to iSize
100709>>>>>>>//                Decrement iSize
100709>>>>>>>//                For iCount from 0 to iSize
100709>>>>>>>//                    Send Combo_Add_Item asCollations[iCount]
100709>>>>>>>//                Loop
100709>>>>>>>//                
100709>>>>>>>//                Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
100709>>>>>>>//                Set Value to sCollation
100709>>>>>>>//                Send Cursor_Ready of Cursor_Control
100709>>>>>>>//            End
100709>>>>>>>//        End_Procedure
100709>>>>>>>//    
100709>>>>>>>//        Procedure OnChange
100709>>>>>>>//            String sValue
100709>>>>>>>//            Get Value to sValue
100709>>>>>>>//            Set psCollation to sValue
100709>>>>>>>//        End_Procedure
100709>>>>>>>//     
100709>>>>>>>//    End_Object
100709>>>>>>>
100709>>>>>>>    Object oInfo_tb is a TextBox
100711>>>>>>>        Set Auto_Size_State to False
100712>>>>>>>        Set Size to 8 50
100713>>>>>>>        Set Location to 133 120
100714>>>>>>>        Set TextColor to clGreen
100715>>>>>>>        Set Justification_Mode to JMode_Right
100716>>>>>>>        Set peAnchors to anBottomRight
100717>>>>>>>    End_Object
100718>>>>>>>
100718>>>>>>>    Object oMain_RDCHeaderGroup is a cRDCHeaderGroup
100720>>>>>>>        Set Size to 108 293
100721>>>>>>>        Set Location to 8 10
100722>>>>>>>        Set psImage to "ActionCreateDatabase1.ico"
100723>>>>>>>        Set Label to "Create Database"
100724>>>>>>>        Set psNote to "Enter collation and database name"
100725>>>>>>>        Set peAnchors to anTopBottom
100726>>>>>>>
100726>>>>>>>        Object oDriver_fm is a cRDCForm
100728>>>>>>>            Set Size to 13 100
100729>>>>>>>            Set Location to 34 63
100730>>>>>>>            Set Label to "Driver"
100731>>>>>>>            Set Enabled_State to False  
100732>>>>>>>        End_Object  
100733>>>>>>>        
100733>>>>>>>        Object oServerCurrentCollating_fm is a cRDCForm
100735>>>>>>>            Set Size to 13 216
100736>>>>>>>            Set Location to 49 63
100737>>>>>>>            Set Label to "Default Collation"
100738>>>>>>>            Set psToolTip to "The SQL server's default collation. It will be used when creating a new database, if nothing else is specified."
100739>>>>>>>            Set Enabled_State to False  
100740>>>>>>>            
100740>>>>>>>            Procedure InitializeCollation 
100743>>>>>>>                String sCollation
100743>>>>>>>                
100743>>>>>>>                Move False to Err
100744>>>>>>>                Send Ignore_All of Error_Object_Id
100745>>>>>>>                // Fetch the SQL server's default collation:
100745>>>>>>>                // It will be used when creating a new database, if nothing else is specified.
100745>>>>>>>                Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary "master" False to sCollation
100746>>>>>>>                Send Trap_All of Error_Object_Id
100747>>>>>>>                If (Err = True) Begin
100749>>>>>>>                    Move "" to sCollation
100750>>>>>>>                End
100750>>>>>>>>
100750>>>>>>>                Set Value to sCollation
100751>>>>>>>            End_Procedure     
100752>>>>>>>    
100752>>>>>>>        End_Object  
100753>>>>>>>        
100753>>>>>>>        Object oCollate_fm is a cRDCSuggestionIniForm 
100755>>>>>>>            Set Size to 13 216
100756>>>>>>>            Set Location to 65 63
100757>>>>>>>            Set Label to "Collation"
100758>>>>>>>            Set psToolTip to "Suggestion list. Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
100759>>>>>>>            Set pbAskToRemoveMissingFile to False
100760>>>>>>>            Set pbAutoCheckValueExistsAsFile to False
100761>>>>>>>            Set pbUseWorkspaceIniFile to True
100762>>>>>>>            Set piStartAtChar to 3
100763>>>>>>>            Set Prompt_Button_Mode to PB_PromptOn
100764>>>>>>>            
100764>>>>>>>            Function ReadWorkspaceIniFile Returns String[]
100767>>>>>>>                String[] asCollations   
100768>>>>>>>                Integer iCount iSize      
100768>>>>>>>                String sDriverID sCollation
100768>>>>>>>                
100768>>>>>>>                Get psDriverID to sDriverID      
100769>>>>>>>                // The SqlEnumerateDatabaseCollations function is at current for MSSQLDRV_ID only.
100769>>>>>>>                If (sDriverID <> MSSQLDRV_ID) Begin
100771>>>>>>>                    Function_Return asCollations
100772>>>>>>>                End                 
100772>>>>>>>>
100772>>>>>>>                
100772>>>>>>>                Send Cursor_Wait of Cursor_Control
100773>>>>>>>                Get SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
100774>>>>>>>                Set psSavedFormValues to asCollations
100775>>>>>>>                    
100775>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
100777>>>>>>>                    Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
100778>>>>>>>                    Set Value to sCollation
100779>>>>>>>                End
100779>>>>>>>>
100779>>>>>>>                Send Cursor_Ready of Cursor_Control
100780>>>>>>>                Function_Return asCollations
100781>>>>>>>            End_Function
100782>>>>>>>    
100782>>>>>>>            Procedure OnChange
100785>>>>>>>                String sValue
100785>>>>>>>                Get Value to sValue
100786>>>>>>>                Set psCollation to sValue
100787>>>>>>>            End_Procedure
100788>>>>>>>         
100788>>>>>>>            Procedure WriteWorkspaceIniFile
100791>>>>>>>            End_Procedure             
100792>>>>>>>            
100792>>>>>>>//            Procedure Prompt      
100792>>>>>>>//                If (ghoSuggestionTimer=0) Begin
100792>>>>>>>//                    Send CreateSuggestionTimer
100792>>>>>>>//                End
100792>>>>>>>//                Send ActivateSuggestionList
100792>>>>>>>//                Send FindSuggestions
100792>>>>>>>//                Set Visible_State of ghoSuggestionList to True
100792>>>>>>>//            End_Procedure 
100792>>>>>>>            
100792>>>>>>>            Procedure OnEnterObject
100795>>>>>>>                Set pbUseWorkspaceIniFile to True
100796>>>>>>>                Forward Send OnEnterObject
100798>>>>>>>            End_Procedure
100799>>>>>>>
100799>>>>>>>            Procedure OnExitObject
100802>>>>>>>                Set pbUseWorkspaceIniFile to False
100803>>>>>>>                Forward Send OnExitObject
100805>>>>>>>            End_Procedure
100806>>>>>>>        
100806>>>>>>>            On_Key kCancel Send KeyAction of oCancel_Btn   
100807>>>>>>>//            On_Key kPrompt Send Prompt
100807>>>>>>>        End_Object   
100808>>>>>>>        
100808>>>>>>>        Object oDatabaseName_fm is a cRDCForm
100810>>>>>>>            Set Size to 13 216
100811>>>>>>>            Set Location to 81 63
100812>>>>>>>            Set Label_Col_Offset to 2
100813>>>>>>>            Set Label_Justification_Mode to JMode_Right
100814>>>>>>>            Set Label to "Database Name"
100815>>>>>>>            Set psToolTip to "Specify the name of the database to be created."
100816>>>>>>>        End_Object
100817>>>>>>>    
100817>>>>>>>    End_Object
100818>>>>>>>
100818>>>>>>>    Object oOK_Btn is a Button
100820>>>>>>>        Set Label    to "&OK"
100821>>>>>>>        Set Location to 130 198
100822>>>>>>>        Set peAnchors to anBottomRight   
100823>>>>>>>        
100823>>>>>>>        Property String psWorkingText "Working..."
100825>>>>>>>        Property String psIdleText    ""
100827>>>>>>>
100827>>>>>>>        Procedure OnClick
100830>>>>>>>            String sDatabase sDriverID sCollation
100830>>>>>>>            Boolean bOK bExists
100830>>>>>>>        
100830>>>>>>>            Get Value of oDatabaseName_fm to sDatabase    
100831>>>>>>>            Get psDriverID to sDriverID
100832>>>>>>>            Set psDatabaseName to ""
100833>>>>>>>
100833>>>>>>>            If (sDatabase <> "" and sDriverID <> "") Begin    
100835>>>>>>>                Set Value of oInfo_tb to (psWorkingText(Self))
100836>>>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
100838>>>>>>>                    Get psCollation to sCollation
100839>>>>>>>                    Set psCollation of ghoDbUpdateFunctionLibrary to sCollation
100840>>>>>>>                End
100840>>>>>>>>
100840>>>>>>>
100840>>>>>>>                Get SqlUtilCheckIfDatabaseExists of ghoDbUpdateFunctionLibrary sDatabase to bExists
100841>>>>>>>                If (bExists = True) Begin
100843>>>>>>>                    Set Value of oInfo_tb to ""
100844>>>>>>>                    Send Info_Box "The database already exists. No changes made."
100845>>>>>>>                    Procedure_Return
100846>>>>>>>                End
100846>>>>>>>>
100846>>>>>>>                Send Cursor_Wait of Cursor_Control     
100847>>>>>>>                Get SqlDatabaseCreate of ghoDbUpdateFunctionLibrary sDriverID sDatabase False False to bOK
100848>>>>>>>                Send Cursor_Ready of Cursor_Control
100849>>>>>>>                Set Value of oInfo_tb to (psIdleText(Self))
100850>>>>>>>                If (bOK = False) Begin
100852>>>>>>>                    Send Info_Box ("Something went wrong and the database could NOT be created. Please check your database manager.")
100853>>>>>>>                    Procedure_Return
100854>>>>>>>                End 
100854>>>>>>>>
100854>>>>>>>                Set psDatabaseName to sDatabase
100855>>>>>>>                Send Close_Panel
100856>>>>>>>            End                                 
100856>>>>>>>>
100856>>>>>>>            Else If (sDatabase = "") Begin
100859>>>>>>>                Send Info_Box ("Please enter a database name and try again.")
100860>>>>>>>            End
100860>>>>>>>>
100860>>>>>>>        End_Procedure
100861>>>>>>>
100861>>>>>>>    End_Object
100862>>>>>>>
100862>>>>>>>    Object oCancel_Btn is a Button
100864>>>>>>>        Set Label    to "&Cancel"
100865>>>>>>>        Set Location to 130 253
100866>>>>>>>        Set peAnchors to anBottomRight
100867>>>>>>>
100867>>>>>>>        Procedure OnClick
100870>>>>>>>            Send Close_Panel
100871>>>>>>>        End_Procedure
100872>>>>>>>
100872>>>>>>>    End_Object
100873>>>>>>>
100873>>>>>>>    Object oHelp_btn is a Button
100875>>>>>>>        Set Location to 130 75
100876>>>>>>>        Set Label to "Help"
100877>>>>>>>        Set psImage to "ActionHelpInternet1.ico"
100878>>>>>>>        Set psToolTip to "Show a Full List of Collations Supported in SQL Server 2017"
100879>>>>>>>        Set peAnchors to anBottomLeft
100880>>>>>>>    
100880>>>>>>>        Procedure OnClick
100883>>>>>>>            Runprogram Shell Background "https://database.guide/full-list-of-collations-supported-in-sql-server-2017/"
100884>>>>>>>        End_Procedure
100885>>>>>>>    
100885>>>>>>>    End_Object
100886>>>>>>>    
100886>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
100887>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
100888>>>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
100889>>>>>>>End_Object
100890>>>>>>>
100890>>>>>>>Function Create_DataBase_Dialog String sDriverID Returns String
100893>>>>>>>    String sDatabaseName         
100893>>>>>>>    Handle ho
100893>>>>>>>    
100893>>>>>>>    Move (oCreateDatabase_dg(Self)) to ho
100894>>>>>>>    Set psDriverID of ho to sDriverID
100895>>>>>>>    Set Value of (oDriver_fm(ho)) to sDriverID
100896>>>>>>>    Set Value of (oDatabaseName_fm(ho)) to ""
100897>>>>>>>    Send InitializeCollation of (oServerCurrentCollating_fm(ho))
100898>>>>>>>    Send Popup of ho
100899>>>>>>>    
100899>>>>>>>    Get psDatabaseName of ho to sDatabaseName
100900>>>>>>>    Function_Return sDatabaseName
100901>>>>>>>End_Function                         
100902>>>>>
100902>>>>>Define CS_LoadingServers        for "Enumerating servers..."
100902>>>>>Define CS_LoadingDatabases      for "Enumerating databases..."
100902>>>>>Define CS_LoadingTableSpaces    for "Enumerating table spaces..."
100902>>>>>Define CS_LoadingSchemas        for "Enumerating schemas..."
100902>>>>>Define CS_LoginAttempt          for "Connecting..."
100902>>>>>Define CS_LoginSuccessful       for "Login successful!"
100902>>>>>Define CS_LoginFailed           for "Login failed!"
100902>>>>>Define CS_DF_File_Schema        for "Schema"
100902>>>>>Define CS_DF_File_Owner         for "Owner"
100902>>>>>
100902>>>>>Object oSQLMaintainConnections_dg is a ModalPanel
100904>>>>>    Set Label to "Edit SQL Connection"
100905>>>>>    Set Size to 315 324 //309 324
100906>>>>>    Set Location to 4 6
100907>>>>>    Set piMaxSize to (Hi(Size(Self))) (Low(Size(Self)) + 300)
100908>>>>>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
100909>>>>>    Set Locate_Mode to CENTER_ON_PARENT
100910>>>>>    Set Border_Style to Border_Thick
100911>>>>>    
100911>>>>>    Property Boolean pbReadOnly  False
100913>>>>>    Property Boolean pbNew       False // First time for a workspace, which means the .ini-file is empty.
100915>>>>>    Property Integer piCurrentRow -1   // The current row of the grid that was passed to this dialog.
100917>>>>>    Property Boolean pbChanged   False // If any change was made to the data.
100919>>>>>    Property Handle phoDialogCommandbar
100921>>>>>    Property tSQLConnection pSQLConnectionData
100923>>>>>    Property tDataSourceRow[] pTheData
100925>>>>>    Property Boolean pbDFConnId  False // Is set to True if this is a DAW "DFConnId.ini" file; in which case we warn to not encrypt/decrypt password. (different algorithms and don't touch password)
100927>>>>>    Property String psUncryptedPw      // Used if  pbDFConnId = True to temporary save the un-encrypted password.
100929>>>>>
100929>>>>>    Object oSettings_grp is a cRDCHeaderGroup
100931>>>>>        Set Size to 202 303
100932>>>>>        Set Location to 77 11 //71 11
100933>>>>>        Set psImage to "Settings1.ico"
100934>>>>>        Set psLabel to "SQL Connection Settings"
100935>>>>>        Set peAnchors to anTopLeftRight
100936>>>>>        Set psToolTip to "Setup the SQL connection."
100937>>>>>
100937>>>>>        Object oConnectionID_fm is a cSQLForm
100939>>>>>            Set Size to 13 115
100940>>>>>            Set Location to 22 82
100941>>>>>            Set Label to "Connection ID"
100942>>>>>            Set psToolTip to "The DFConnectionID keyword to set a default connection id for the driver. This is the connection ID that appear in database table .int files with the format; 'SERVER_NAME DFCONNID=MyConnID'"
100943>>>>>            Set piItem to 2
100944>>>>>            Set peAnchors to anTopLeftRight
100945>>>>>        End_Object
100946>>>>>
100946>>>>>        Object oEnabled_cb is a cSQLCheckBox
100948>>>>>            Set Size to 10 36
100949>>>>>            Set Location to 25 210
100950>>>>>            Set Label to "Enabled"
100951>>>>>            Set psToolTip to "Check to indicate that this is the enabled connection. Note: There can only be one enabled connection at a time."
100952>>>>>            Set piItem to 1
100953>>>>>            Set peAnchors to anTopRight
100954>>>>>
100954>>>>>            Procedure OnChange
100957>>>>>                Boolean bChecked bNew
100957>>>>>                tSQLConnection SQLConnection
100957>>>>>                tSQLConnection SQLConnection
100957>>>>>
100957>>>>>                Get pbNew to bNew
100958>>>>>                Get Checked_State to bChecked
100959>>>>>                If (bNew = False and bChecked = True) Begin
100961>>>>>                    Get pSQLConnectionData to SQLConnection
100962>>>>>                    Move True to SQLConnection.bEnabled
100963>>>>>                End
100963>>>>>>
100963>>>>>
100963>>>>>            End_Procedure
100964>>>>>
100964>>>>>        End_Object
100965>>>>>
100965>>>>>        Object oODBC_rgp is a RadioGroup
100967>>>>>            Set Location to 38 24
100968>>>>>            Set Size to 32 173
100969>>>>>//            Set psToolTip to "Only available if the ODBC_DRV has been selected. Depending on the radio button that is selected the 'Server/DSN' selection list shows different values."
100969>>>>>            Set peAnchors to anTopLeftRight
100970>>>>>            Set Label to "ODBC Source Type"
100971>>>>>
100971>>>>>            Object oRadio0 is a Radio
100973>>>>>                Set Label to "User data"
100974>>>>>                Set Size to 10 44
100975>>>>>                Set Location to 12 5
100976>>>>>            End_Object
100977>>>>>
100977>>>>>            Object oRadio1 is a Radio
100979>>>>>                Set Label to "System data"
100980>>>>>                Set Size to 10 52
100981>>>>>                Set Location to 12 52
100982>>>>>            End_Object
100983>>>>>
100983>>>>>            Object oRadio2 is a Radio
100985>>>>>                Set Label to "Both"
100986>>>>>                Set Size to 10 26
100987>>>>>                Set Location to 13 109
100988>>>>>            End_Object
100989>>>>>
100989>>>>>            Object oRadio3 is a Radio
100991>>>>>                Set Label to "File"
100992>>>>>                Set Size to 10 25
100993>>>>>                Set Location to 13 141
100994>>>>>            End_Object
100995>>>>>
100995>>>>>            Procedure Notify_Select_State Integer iToItem Integer iFromItem
100998>>>>>                Forward Send Notify_Select_State iToItem iFromItem 
101000>>>>>                If (oFileDSN_btn(Self) <> 0) Begin
101002>>>>>                    Set Enabled_State of oFileDSN_btn to (iToItem = 3)
101003>>>>>                End
101003>>>>>>
101003>>>>>            End_Procedure
101004>>>>>
101004>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
101007>>>>>                Set Enabled_State to (sDriverID = ODBC_DRV_ID)
101008>>>>>                Set Enabled_State of oODBC_rgp to (sDriverID = ODBC_DRV_ID)
101009>>>>>            End_Procedure
101010>>>>>
101010>>>>>            Set Current_Radio to 2
101011>>>>>        End_Object
101012>>>>>
101012>>>>>        Object oFileDSN_btn is a cRDCButton
101014>>>>>            Set Size to 13 78
101015>>>>>            Set Location to 42 210
101016>>>>>            Set Label to "Select File DSN..."
101017>>>>>            Set pbAutoEnable to True
101018>>>>>            Set peAnchors to anTopRight
101019>>>>>
101019>>>>>            Procedure OnClick
101022>>>>>                String sFileName
101022>>>>>                Get vSelect_File ("Data Sources (*.dsn)|*.dsn|All Files (*.*)|*.*") "Select a file data source" "" to sFileName
101023>>>>>                If (sFileName <> "") Begin
101025>>>>>                    Set Value of oServer_fm to sFileName
101026>>>>>                End
101026>>>>>>
101026>>>>>            End_Procedure     
101027>>>>>            
101027>>>>>            Function IsEnabled Returns Boolean
101030>>>>>                String sDriverID
101030>>>>>                Integer iRadio
101030>>>>>                Get Value of oDriverID_cf to sDriverID
101031>>>>>                Get Current_Radio of oODBC_rgp to iRadio
101032>>>>>                Function_Return (sDriverID = ODBC_DRV_ID and iRadio = 3)
101033>>>>>            End_Function
101034>>>>>
101034>>>>>        End_Object
101035>>>>>
101035>>>>>        Object oODBCAdmin_btn is a cRDCButton
101037>>>>>            Set Size to 13 78
101038>>>>>            Set Location to 57 210
101039>>>>>            Set Label to "ODBC Admin" 
101040>>>>>            Set psImage to "ODBCAD32.ico"
101041>>>>>            Set pbAutoEnable to True
101042>>>>>            Set peAnchors to anTopRight
101043>>>>>            
101043>>>>>            Procedure OnClick
101046>>>>>                Handle hWnd
101046>>>>>                Get Window_Handle to hWnd
101047>>>>>                If (hWnd <> 0) Begin
101049>>>>>                    Call_Driver 0 ODBC_DRV_ID Function ODBC_MANAGE_DATA_SOURCES Callback 0 Passing CLI$StrDummy CLI$StrDummy !1 Result CLI$IntDummy
101054>>>>>                End
101054>>>>>>
101054>>>>>                Else Begin
101055>>>>>                    Send Stop_Box "Could not get a Windows handle.."
101056>>>>>                End
101056>>>>>>
101056>>>>>            End_Procedure
101057>>>>>
101057>>>>>            Function IsEnabled Returns Boolean
101060>>>>>                String sDriverID
101060>>>>>                Get Value of oDriverID_cf to sDriverID
101061>>>>>                Function_Return (sDriverID = ODBC_DRV_ID)
101062>>>>>            End_Function
101063>>>>>
101063>>>>>        End_Object
101064>>>>>
101064>>>>>        Object oServer_fm is a cSQLForm
101066>>>>>            Set Size to 13 114
101067>>>>>            Set Location to 74 82
101068>>>>>            Set Label to "Server"
101069>>>>>            Set psToolTip to "Server/DSN: Depending on the selected database type the label can either display as 'Server' or 'DSN'. Either enter the name - if you know it - or by using the selection list (F4). Tip: If you are using Microsoft SQL Server and you are testing on the same machine as the MS SQL Server instance is running and you are using SQLEXPRESS you can enter e.g. '.\SQLEXPRESS'. That will mean use the SQLEXPRESS instance of Microsoft SQL Server running on this machine. If you press [F4] and the selection list comes up empty for Microsoft SQL Server it probably is because the service hasn't been started. Type 'Services' in Windows menu system to start Windows Services app. Type 'SQL' to jump to the SQL Server services. Check that the 'SQL Server Browser' service is started and set to 'Automatic'."
101070>>>>>            Set piItem to 5
101071>>>>>            Set peAnchors to anTopLeftRight
101072>>>>>
101072>>>>>            Property Handle phoPromptObject (oServerSelection_sl(Self))
101074>>>>>
101074>>>>>            Procedure Prompt
101077>>>>>                String sDriverID sValue
101077>>>>>                String[] sTheData
101078>>>>>                Integer iDbType iODBCType iRadio iPos
101078>>>>>                Handle ho
101078>>>>>
101078>>>>>                Get Prompt_Object to ho
101079>>>>>                If (ho = 0) Begin
101081>>>>>                    Procedure_Return
101082>>>>>                End
101082>>>>>>
101082>>>>>
101082>>>>>                Set Label of oShowInfo_tb to CS_LoadingServers
101083>>>>>                Send Cursor_Wait of Cursor_Control
101084>>>>>                Get SelectedDbType of oDbType_cf to iDbType
101085>>>>>                Get Value of oDriverID_cf to sDriverID
101086>>>>>                Move (Trim(sDriverID)) to sDriverID
101087>>>>>                Get Current_Radio of oODBC_rgp to iRadio
101088>>>>>                If (iRadio = 0) Begin
101090>>>>>                    Move SQL_FETCH_USER   to iODBCType
101091>>>>>                End
101091>>>>>>
101091>>>>>                If (iRadio = 1) Begin
101093>>>>>                    Move SQL_FETCH_SYSTEM to iODBCType
101094>>>>>                End
101094>>>>>>
101094>>>>>                If (iRadio = 2) Begin
101096>>>>>                    Move SQL_FETCH_ALL    to iODBCType
101097>>>>>                End
101097>>>>>>
101097>>>>>
101097>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
101098>>>>>                Load_Driver sDriverID
101099>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
101100>>>>>                If (LastErr = DFERR_CANT_LOAD_DLL) Begin
101102>>>>>                    Send Cursor_Ready of Cursor_Control
101103>>>>>                    Send Info_Box ("Can't display any items because the database driver could not be loaded. (" + sDriverID + ")")
101104>>>>>                    Procedure_Return
101105>>>>>                End
101105>>>>>>
101105>>>>>
101105>>>>>                Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID iODBCType to sTheData
101106>>>>>                Set psTheData  of ho to sTheData
101107>>>>>                Set Label of oShowInfo_tb to ""
101108>>>>>
101108>>>>>                Forward Send Prompt
101110>>>>>
101110>>>>>                // The selection list will show the ODBC DataSource name + a comma (,) + a description.
101110>>>>>                // We need to remove those parts from the comma and to the end of string.
101110>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
101112>>>>>                    Get Value to sValue
101113>>>>>                    Move (Pos(",", sValue)) to iPos
101114>>>>>                    Move (Left(sValue, (iPos - 1))) to sValue
101115>>>>>                    Set Value to sValue
101116>>>>>                End
101116>>>>>>
101116>>>>>            End_Procedure
101117>>>>>
101117>>>>>            Procedure OnChange
101120>>>>>                tSQLIntTableInfo[] sReturnStructArray
101120>>>>>                tSQLIntTableInfo[] sReturnStructArray
101121>>>>>                String sServer sDatabaseName sVal sDriverID
101121>>>>>                Integer iSize iCount iPos 
101121>>>>>                Boolean bFileDSN
101121>>>>>                
101121>>>>>                Move False to bFileDSN
101122>>>>>                Get Value of oDriverID_cf to sDriverID
101123>>>>>                If (sDriverID = "") Begin
101125>>>>>                    Procedure_Return
101126>>>>>                End
101126>>>>>>
101126>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
101128>>>>>                    Move "" to sDatabaseName
101129>>>>>                    Get Value to sServer 
101130>>>>>                    Move (Pos(",", sServer)) to iPos
101131>>>>>                    If (iPos <> 0) Begin
101133>>>>>                        Move (Left(sServer, (iPos -1))) to sServer
101134>>>>>                    End
101134>>>>>>
101134>>>>>                    If (sServer <> "") Begin
101136>>>>>                        Set psServer of ghoDbUpdateFunctionLibrary to sServer
101137>>>>>                    End
101137>>>>>>
101137>>>>>                    Get _SqlDatabasesArrayODBC of ghoDbUpdateFunctionLibrary to sReturnStructArray
101138>>>>>                    If (SizeOfArray(sReturnStructArray)) Begin
101140>>>>>                        If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
101142>>>>>                            // If a FILEDSN: (can only be one database name)
101142>>>>>                            Move sReturnStructArray[0].sDatabaseName to sDatabaseName
101143>>>>>                            Move True to bFileDSN
101144>>>>>                        End
101144>>>>>>
101144>>>>>                        Else Begin
101145>>>>>                            // Else the DSN's were read from the registry.
101145>>>>>                            Move (SizeOfArray(sReturnStructArray)) to iSize
101146>>>>>                            Decrement iSize
101147>>>>>                            For iCount from 0 to iSize
101153>>>>>>
101153>>>>>                                Move (sReturnStructArray[iCount].sServerName) to sVal
101154>>>>>                                If (Uppercase(sServer) = Uppercase(sVal)) Begin
101156>>>>>                                    Move sReturnStructArray[iCount].sDatabaseName to sDatabaseName
101157>>>>>                                    Move iSize to iCount // We're done.
101158>>>>>                                End
101158>>>>>>
101158>>>>>                            Loop
101159>>>>>>
101159>>>>>                        End
101159>>>>>>
101159>>>>>                    End
101159>>>>>>
101159>>>>>                    Set Value of oDatabase_fm to sDatabaseName
101160>>>>>                    If (bFileDSN = True) Begin
101162>>>>>                        Set Current_Radio of oODBC_rgp to 3
101163>>>>>                    End    
101163>>>>>>
101163>>>>>                    Else Begin
101164>>>>>                        Set Current_Radio of oODBC_rgp to 2
101165>>>>>                    End
101165>>>>>>
101165>>>>>                End
101165>>>>>>
101165>>>>>
101165>>>>>            End_Procedure
101166>>>>>
101166>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
101169>>>>>                String sLabel
101169>>>>>                Handle ho
101169>>>>>
101169>>>>>                Get phoPromptObject to ho
101170>>>>>                Set Prompt_Button_Mode to PB_PromptOn
101171>>>>>                Case Begin
101171>>>>>                    Case (iDbType = EN_dbTypeDB2)
101173>>>>>                        Move "DSN" to sLabel
101174>>>>>                        Case Break
101175>>>>>                    Case (iDbType = EN_dbTypeMSSQL)
101178>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
101180>>>>>                            Move "ODBC Data Source" to sLabel
101181>>>>>                        End
101181>>>>>>
101181>>>>>                        Else Begin
101182>>>>>                            Move "Server" to sLabel
101183>>>>>                        End
101183>>>>>>
101183>>>>>                        Case Break
101184>>>>>                    Case (iDbType = EN_dbTypeMySQL)
101187>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
101189>>>>>                            Move "ODBC Data Source" to sLabel
101190>>>>>                        End
101190>>>>>>
101190>>>>>                        Else Begin
101191>>>>>                            Move "DSN" to sLabel
101192>>>>>                        End
101192>>>>>>
101192>>>>>                        Case Break
101193>>>>>                    Case (iDbType = EN_dbTypeOracle)
101196>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
101198>>>>>                            Move "ODBC Data Source" to sLabel
101199>>>>>                        End
101199>>>>>>
101199>>>>>                        Else Begin
101200>>>>>                            Move "Server" to sLabel
101201>>>>>                        End
101201>>>>>>
101201>>>>>                        Case Break
101202>>>>>                    Case (iDbType = EN_dbTypePostgre)
101205>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
101207>>>>>                            Move "ODBC Data Source" to sLabel
101208>>>>>                        End
101208>>>>>>
101208>>>>>                        Else Begin
101209>>>>>                            Move "Server" to sLabel
101210>>>>>                        End
101210>>>>>>
101210>>>>>                        Case Break
101211>>>>>                    Case Else
101211>>>>>                Case End
101211>>>>>
101211>>>>>                Set Prompt_Object to ho
101212>>>>>                Set Label to sLabel
101213>>>>>            End_Procedure
101214>>>>>
101214>>>>>        End_Object
101215>>>>>
101215>>>>>        Object oSilentLogin_fm is a cSQLCheckBox
101217>>>>>            Set Size to 10 48
101218>>>>>            Set Location to 76 210
101219>>>>>            Set Label to "Silent Login"
101220>>>>>            Set psToolTip to "Silent login to database is to not show error if login was unsuccessive."
101221>>>>>            Set peAnchors to anTopRight
101222>>>>>            Set piItem to 15
101223>>>>>        End_Object
101224>>>>>
101224>>>>>        Object oTrusted_cb is a cSQLCheckbox
101226>>>>>            Set Size to 12 85
101227>>>>>            Set Location to 91 82
101228>>>>>            Set Label to "Use Trusted Connection"
101229>>>>>            Set psToolTip to "(Windows Authentication) When selected, SQL Server uses integrated login (Windows login information) security to establish connections using this data source, regardless of the current login security mode at the server."
101230>>>>>            Set piItem to 8
101231>>>>>
101231>>>>>            Procedure OnChange
101234>>>>>                Boolean bChecked
101234>>>>>                Get Checked_State to bChecked
101235>>>>>                Set Enabled_State of oUserID_fm   to (bChecked = False)
101236>>>>>                Set Enabled_State of oPassword_fm to (bChecked = False)
101237>>>>>                Set Enabled_State of oViewPassword_btn to (bChecked = False)
101238>>>>>            End_Procedure
101239>>>>>
101239>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
101242>>>>>                Boolean bChecked
101242>>>>>
101242>>>>>                Get Checked_State to bChecked
101243>>>>>                If (iDbType <> EN_dbTypeMSSQL) Begin
101245>>>>>                    Set Enabled_State to (iDbType = EN_dbTypeMSSQL)
101246>>>>>                    If (bChecked = True) Begin
101248>>>>>                        Set Checked_State to False
101249>>>>>                    End
101249>>>>>>
101249>>>>>                End
101249>>>>>>
101249>>>>>                Else Begin
101250>>>>>                    Set Enabled_State to True
101251>>>>>                End
101251>>>>>>
101251>>>>>
101251>>>>>                Send OnChange
101252>>>>>            End_Procedure
101253>>>>>
101253>>>>>        End_Object
101254>>>>>
101254>>>>>        Object oUserID_fm is a cSQLForm
101256>>>>>            Set Size to 13 114
101257>>>>>            Set Location to 103 82
101258>>>>>            Set Label to "User ID"
101259>>>>>            Set psToolTip to "Enter the user name to use for authentication when you log on to the database."
101260>>>>>            Set piItem to 9
101261>>>>>            Set peAnchors to anTopLeftRight
101262>>>>>        End_Object
101263>>>>>
101263>>>>>        Object oPassword_fm is a cSQLForm
101265>>>>>            Set Size to 13 61
101266>>>>>            Set Location to 103 210
101267>>>>>            Set Label to "Password"
101268>>>>>            Set psToolTip to "Enter the password for your user name. The password will automatically be encrypted & decrypted when writing/reading from the ini file. Of Special Note: If the cConnection class is used with DataFlex 19 or later and such an .ini file is edited with this program you will get a question if you would like the program to 'touch' the password or not. If you answer No, the ini-file will keep working with the DataFlex tools. You should probably never try to change the password with this program for a DFConnid.ini file as the two programs uses different encryption/decryption algorithms."
101269>>>>>            Set piItem to 10
101270>>>>>            Set Password_State to True
101271>>>>>            Set peAnchors to anTopRight
101272>>>>>            Set Label_Col_Offset to 0
101273>>>>>            Set Label_Justification_Mode to JMode_Top
101274>>>>>        End_Object
101275>>>>>
101275>>>>>        Object oShowInfo_tb is a TextBox
101277>>>>>            Set Auto_Size_State to False
101278>>>>>            Set Size to 10 114
101279>>>>>            Set Location to 119 82
101280>>>>>            Set TextColor to clGreen
101281>>>>>            Set Justification_Mode to JMode_Center
101282>>>>>            Set peAnchors to anTopRight
101283>>>>>        End_Object
101284>>>>>
101284>>>>>        Object oViewPassword_btn is a cRDCButton
101286>>>>>            Set Size to 13 15
101287>>>>>            Set Location to 103 273
101288>>>>>            Set psToolTip to "View/hide password"
101289>>>>>            Set psImage to "ViewPassword1.ico"
101290>>>>>            Set piImageMarginLeft to 2
101291>>>>>            Set peAnchors to anTopRight
101292>>>>>
101292>>>>>            Procedure OnClick
101295>>>>>                Handle ho
101295>>>>>                Boolean bState
101295>>>>>
101295>>>>>                Move (oPassword_fm(Self)) to ho
101296>>>>>                Get Password_State of ho 0 to bState
101297>>>>>                Send Deactivate of ho
101298>>>>>                Set Password_State of ho to (not(bState))
101299>>>>>                // Finally we need to re-add the object to the focus tree or it will be invisible.
101299>>>>>                Send Activate of ho (Parent(Self))
101300>>>>>            End_Procedure
101301>>>>>
101301>>>>>        End_Object
101302>>>>>
101302>>>>>        Object oCheckLogin_btn is a cRDCButton
101304>>>>>            Set Size to 13 78
101305>>>>>            Set Location to 119 210
101306>>>>>            Set Label to "Check &Login"
101307>>>>>            Set psImage to "ActionLogin1.ico"
101308>>>>>            Set psToolTip to "You should always use this button when adding a new SQL Connection to ensure that the entered credentials are correct. (Ctrl+L)"
101309>>>>>            Set piImageMarginLeft to 3
101310>>>>>            Set peAnchors to anTopRight
101311>>>>>
101311>>>>>            Procedure OnClick
101314>>>>>                String sConnectionString sDriverID sError //sServer sDatabase sUserId sPassword 
101314>>>>>                Boolean bLoginSuccessful bMertechDriver // bTrusted 
101314>>>>>                Integer iDriverID
101314>>>>>                Handle hoErrorObj
101314>>>>>
101314>>>>>                Send Cursor_Wait of Cursor_Control // Note: The Cursor_Wait changes the Err flag!
101315>>>>>                Move Error_Object_Id to hoErrorObj
101316>>>>>                Move Self to Error_Object_Id
101317>>>>>                Move False to Err
101318>>>>>
101318>>>>>                Set Value of oLoginInfo_tb to CS_LoginAttempt
101319>>>>>                Send PumpMsgQueue
101320>>>>>                
101320>>>>>                Get Value of oDriverID_cf to sDriverID
101321>>>>>                Move "" to sError
101322>>>>>                Get LoginString (&sError) to sConnectionString
101323>>>>>                If (sError <> "") Begin
101325>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
101326>>>>>                    Send Info_Box sError
101327>>>>>                    Procedure_Return
101328>>>>>                End
101328>>>>>>
101328>>>>>                
101328>>>>>                Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriverID
101329>>>>>                If (iDriverID = 0) Begin
101331>>>>>                    Set TextColor of oLoginInfo_tb to clRed
101332>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
101333>>>>>                    Send Info_Box ("The driver" * sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
101334>>>>>                    Procedure_Return
101335>>>>>                End
101335>>>>>>
101335>>>>>
101335>>>>>                Get IsMertechDriver of ghoSQLConnectionHandler sDriverID to bMertechDriver
101336>>>>>                If (bMertechDriver = False) Begin
101338>>>>>                    Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
101341>>>>>                End
101341>>>>>>
101341>>>>>
101341>>>>>                Move False to Err
101342>>>>>                Send CreateConnParamsFromConnectionString of ghoSQLConnectionHandler sDriverID sConnectionString
101343>>>>>
101343>>>>>                Move (Err = False) to bLoginSuccessful
101344>>>>>                If bLoginSuccessful Begin
101346>>>>>                    Set TextColor of oLoginInfo_tb to clGreen
101347>>>>>                    Set Value of oLoginInfo_tb to CS_LoginSuccessful 
101348>>>>>                    Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
101349>>>>>                    Set psConnectionString of ghoDbUpdateFunctionLibrary to sConnectionString
101350>>>>>                End
101350>>>>>>
101350>>>>>                Else Begin
101351>>>>>                    Set TextColor of oLoginInfo_tb to clRed
101352>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
101353>>>>>                End
101353>>>>>>
101353>>>>>
101353>>>>>                Move hoErrorObj to Error_Object_Id
101354>>>>>                Send Cursor_Ready of Cursor_Control
101355>>>>>            End_Procedure
101356>>>>>
101356>>>>>            // This method is here simply to intercept any error that may occur while logging in
101356>>>>>            // it does not have to do anything with the error, but it suppresses the normal error display
101356>>>>>            Procedure Error_Report Integer iErrNum Integer iErrLine String sErrMsg
101359>>>>>                    If (LastErr = 25000) Begin
101361>>>>>                        If (Trim(sErrMsg) <> "") Begin
101363>>>>>                            Send Info_Box sErrMsg
101364>>>>>                        End
101364>>>>>>
101364>>>>>                    End  
101364>>>>>>
101364>>>>>            End_Procedure   
101365>>>>>            
101365>>>>>        End_Object
101366>>>>>
101366>>>>>        Object oIndexTableSpace_fm is a cSQLForm
101368>>>>>            Set Size to 13 114
101369>>>>>            Set Location to 133 82
101370>>>>>            Set Label to "Index Table Space"
101371>>>>>            Set piItem to 14
101372>>>>>            Set psToolTip to "To set the name of the table space where indexes will be stored. Only applicable for IBM DB2, Oracle and PostgreSQL databases."
101373>>>>>            Set Prompt_Button_Mode to PB_PromptOn
101374>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
101375>>>>>            Set peAnchors to anTopLeftRight
101376>>>>>
101376>>>>>            Procedure Prompt
101379>>>>>                String[] sTheData
101380>>>>>                Handle ho
101380>>>>>                tSQLConnection SQLConnection
101380>>>>>                tSQLConnection SQLConnection
101380>>>>>
101380>>>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
101381>>>>>                Get ReadCurrentSQLSettings to SQLConnection
101382>>>>>
101382>>>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
101383>>>>>
101383>>>>>                Get Prompt_Object to ho
101384>>>>>                Set psTheData     of ho to sTheData
101385>>>>>                Set Label of oShowInfo_tb to ""
101386>>>>>
101386>>>>>                Forward Send Prompt
101388>>>>>            End_Procedure
101389>>>>>
101389>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
101392>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
101393>>>>>            End_Procedure
101394>>>>>
101394>>>>>        End_Object
101395>>>>>
101395>>>>>        Object oLoginInfo_tb is a TextBox
101397>>>>>            Set Auto_Size_State to False
101398>>>>>            Set Size to 9 78
101399>>>>>            Set Location to 135 210
101400>>>>>            Set TextColor to clGreen
101401>>>>>            Set peAnchors to anTopRight
101402>>>>>            Set Justification_Mode to JMode_Left
101403>>>>>        End_Object
101404>>>>>
101404>>>>>        Object oBaseTableSpace_fm is a cSQLForm
101406>>>>>            Set Size to 13 114
101407>>>>>            Set Location to 148 82
101408>>>>>            Set Label to "Table Space"
101409>>>>>            Set piItem to 12
101410>>>>>            Set psToolTip to "Sets the name of the table space where the data will be stored. Applicable for IBM DB2, Oracle and PostgreSQL databases. Table spaces allow you to assign a physical location to logical objects (tables). They can be used to improve performance or to increase the page size, thus increasing the maximum size of a record that can be stored in the table space. You can specify what table space must be used to store table, index or long data. The index and long data table space will only be set when the table tables pace is also set."
101411>>>>>            Set Prompt_Button_Mode to PB_PromptOn
101412>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
101413>>>>>            Set peAnchors to anTopLeftRight
101414>>>>>
101414>>>>>            Procedure Prompt
101417>>>>>                String[] sTheData
101418>>>>>                Handle ho
101418>>>>>                tSQLConnection SQLConnection
101418>>>>>                tSQLConnection SQLConnection
101418>>>>>
101418>>>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
101419>>>>>                Get ReadCurrentSQLSettings to SQLConnection
101420>>>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
101421>>>>>
101421>>>>>                Get Prompt_Object to ho
101422>>>>>                Set psTheData  of ho to sTheData
101423>>>>>                Set Label of oShowInfo_tb to ""
101424>>>>>
101424>>>>>                Forward Send Prompt
101426>>>>>            End_Procedure
101427>>>>>
101427>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
101430>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
101431>>>>>            End_Procedure
101432>>>>>
101432>>>>>        End_Object
101433>>>>>
101433>>>>>        Object oLongTableSpace_fm is a cSQLForm
101435>>>>>            Set Size to 13 114
101436>>>>>            Set Location to 163 82
101437>>>>>            Set Label to "Long Table Space"
101438>>>>>            Set piItem to 13
101439>>>>>            Set psToolTip to "Only applicable for IBM DB2 databases. If you are unsure on what to enter your best bet is to use the same value as for the 'Table Space' above."
101440>>>>>            Set Prompt_Button_Mode to PB_PromptOn
101441>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
101442>>>>>            Set peAnchors to anTopLeftRight
101443>>>>>
101443>>>>>            Procedure Prompt
101446>>>>>                String[] sTheData
101447>>>>>                Handle ho
101447>>>>>                tSQLConnection SQLConnection
101447>>>>>                tSQLConnection SQLConnection
101447>>>>>
101447>>>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
101448>>>>>                Get ReadCurrentSQLSettings to SQLConnection
101449>>>>>
101449>>>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
101450>>>>>
101450>>>>>                Get Prompt_Object to ho
101451>>>>>                Set psTheData     of ho to sTheData
101452>>>>>                Set Label of oShowInfo_tb to ""
101453>>>>>
101453>>>>>                Forward Send Prompt
101455>>>>>            End_Procedure
101456>>>>>
101456>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
101459>>>>>                Set Enabled_State to (iDbType = EN_dbTypeDB2)
101460>>>>>            End_Procedure
101461>>>>>
101461>>>>>        End_Object
101462>>>>>
101462>>>>>        Object oSchema_fm is a cSQLForm
101464>>>>>            Set Size to 13 78
101465>>>>>            Set Location to 163 210
101466>>>>>            Set Label to "Schema"
101467>>>>>            Set psToolTip to "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult your database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
101468>>>>>            Set piItem to 11
101469>>>>>            Set Enabled_State to False
101470>>>>>
101470>>>>>            Property String psSchemaToolTip "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult a database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
101472>>>>>            Property String psOwnerTooltip  "The owner name to use within the database where the tables must be placed. If you want to specify an owner of the table that will be converted you can do so, not specifying an owner will result in the default owner being used. The suggested owner name to use is 'dbo'"
101474>>>>>
101474>>>>>            Set peAnchors to anTopRight
101475>>>>>            Set Label_Justification_Mode to JMode_Top
101476>>>>>            Set Label_Col_Offset to 0
101477>>>>>
101477>>>>>            Procedure Prompt
101480>>>>>                String[] sTheData
101481>>>>>                Handle ho
101481>>>>>                tSQLConnection SQLConnection
101481>>>>>                tSQLConnection SQLConnection
101481>>>>>
101481>>>>>                Set Label of oShowInfo_tb to CS_LoadingSchemas
101482>>>>>                Get ReadCurrentSQLSettings to SQLConnection
101483>>>>>
101483>>>>>                Get SqlUtilEnumerateSchemas of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
101484>>>>>
101484>>>>>                Get Prompt_Object to ho
101485>>>>>                Set psTheData     of ho to sTheData
101486>>>>>                Set Label of oShowInfo_tb to ""
101487>>>>>
101487>>>>>                Forward Send Prompt
101489>>>>>            End_Procedure
101490>>>>>
101490>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
101493>>>>>                String sValue
101493>>>>>
101493>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeMSSQL or iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
101494>>>>>                If (iDbType = EN_dbTypeMSSQL) Begin
101496>>>>>                    Set Label to CS_DF_File_Owner
101497>>>>>                    Set Prompt_Button_Mode to PB_PromptOff
101498>>>>>                    Set Prompt_Object to 0
101499>>>>>                    Set psToolTip to (psOwnerTooltip(Self))
101500>>>>>                    Get Value to sValue
101501>>>>>                    If (Trim(sValue) = "") Begin
101503>>>>>                        Set Value to "dbo"
101504>>>>>                    End
101504>>>>>>
101504>>>>>                End
101504>>>>>>
101504>>>>>                Else Begin
101505>>>>>                    Set Label to CS_DF_File_Schema
101506>>>>>                    Set Prompt_Button_Mode to PB_PromptOn
101507>>>>>                    Set Prompt_Object to (oSchemasSelection_sl(Self))
101508>>>>>                    Set psToolTip to (psSchemaToolTip(Self))
101509>>>>>                    If (Trim(sValue) = "dbo") Begin
101511>>>>>                        Set Value to ""
101512>>>>>                    End
101512>>>>>>
101512>>>>>                End
101512>>>>>>
101512>>>>>                If (Enabled_State(Self) = False) Begin
101514>>>>>                    Set Value to ""
101515>>>>>                End
101515>>>>>>
101515>>>>>            End_Procedure
101516>>>>>
101516>>>>>        End_Object
101517>>>>>
101517>>>>>        Object oDatabase_fm is a cSQLForm
101519>>>>>            Set Size to 13 114
101520>>>>>            Set Location to 178 82
101521>>>>>            Set Label to "Database"
101522>>>>>            Set peAnchors to anTopLeftRight
101523>>>>>            Set psToolTip to "Name of the SQL database. Note: If you are setting up your first connection for a workspace and your SQL database doesn't exist yet, leave the default 'Master' as it is always available. The 'SqlDatabaseCreate' function will take care of the rest when creating your new SQL database."
101524>>>>>            Set piItem to 6
101525>>>>>            Set Prompt_Button_Mode to PB_PromptOn
101526>>>>>
101526>>>>>            Procedure Prompt
101529>>>>>                String[] sTheData
101530>>>>>                Handle ho
101530>>>>>                tSQLConnection SQLConnection
101530>>>>>                tSQLConnection SQLConnection
101530>>>>>
101530>>>>>                Set Label of oShowInfo_tb to CS_LoadingDatabases
101531>>>>>                Get ReadCurrentSQLSettings to SQLConnection
101532>>>>>
101532>>>>>                Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID to sTheData
101533>>>>>
101533>>>>>                Get Prompt_Object to ho
101534>>>>>                Set psTheData     of ho to sTheData
101535>>>>>                Set Label of oShowInfo_tb to ""
101536>>>>>
101536>>>>>                Forward Send Prompt
101538>>>>>            End_Procedure
101539>>>>>
101539>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
101542>>>>>                Boolean bAdd
101542>>>>>                String sValue
101542>>>>>
101542>>>>>                If (sDriverID <> "") Begin
101544>>>>>                    Set Enabled_State to (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX or sDriverID = MDSMySQL or sDriverID = MDSPgSQL or sDriverID = ORAFLEX or (sDriverID = ODBC_DRV_ID and iDbType <> EN_DbTypeOracle))
101545>>>>>                    If (Enabled_State(Self) = True) Begin
101547>>>>>                        Move (piCurrentRow(Self) = -1) to bAdd
101548>>>>>                        Get Value to sValue
101549>>>>>                        If (bAdd = True and sValue = "" and iDbType = EN_dbTypeMSSQL) Begin
101551>>>>>                            Set Value to "master"
101552>>>>>                        End
101552>>>>>>
101552>>>>>                        Else Begin
101553>>>>>                            Set Prompt_Button_Mode to PB_PromptOn
101554>>>>>                            Set Prompt_Object to (oDatabaseSelection_sl(Self))
101555>>>>>                            If (Value(Self) = "master") Begin
101557>>>>>                                Set Value to ""
101558>>>>>                            End
101558>>>>>>
101558>>>>>                        End
101558>>>>>>
101558>>>>>                    End
101558>>>>>>
101558>>>>>                    If (Enabled_State(Self) = False) Begin
101560>>>>>                        Set Value to ""
101561>>>>>                    End
101561>>>>>>
101561>>>>>                End
101561>>>>>>
101561>>>>>            End_Procedure
101562>>>>>
101562>>>>>        End_Object
101563>>>>>
101563>>>>>        Object oCreateDatabase_btn is a cRDCButton
101565>>>>>            Set Size to 13 78
101566>>>>>            Set Location to 178 210
101567>>>>>            Set Label to "Create Database..."
101568>>>>>            Set psImage to "ActionCreateDatabase1.ico"
101569>>>>>            Set pbAutoEnable to True
101570>>>>>            Set peAnchors to anTopRight
101571>>>>>        
101571>>>>>            Procedure OnClick                                                              
101574>>>>>                String sConnectionString sError sDriverID sLoginText sDatabaseName
101574>>>>>                
101574>>>>>                Get LoginString (&sError) to sConnectionString
101575>>>>>                If (sError <> "") Begin
101577>>>>>                    Send Info_Box sError
101578>>>>>                    Procedure_Return
101579>>>>>                End                         
101579>>>>>>
101579>>>>>                
101579>>>>>                Get Value of oDriverID_cf to sDriverID
101580>>>>>                Get Create_DataBase_Dialog of (Client_Id(phoMainPanel(ghoApplication))) sDriverID to sDatabaseName
101581>>>>>                If (sDatabaseName <> "") Begin
101583>>>>>                    Set Value of oDatabase_fm to sDatabaseName
101584>>>>>                End
101584>>>>>>
101584>>>>>            End_Procedure                
101585>>>>>            
101585>>>>>            Function IsEnabled Returns Boolean
101588>>>>>                Integer iDbType    
101588>>>>>                Boolean bReadOnly
101588>>>>>                Get SelectedDbType of oDbType_cf to iDbType
101589>>>>>                Get pbReadOnly to bReadOnly
101590>>>>>                Function_Return (bReadOnly = False and (iDbType = EN_DbTypeMSSQL or iDbType = EN_DbTypeDB2 or iDbType = EN_DbTypeMySQL or iDbType = EN_DbTypePostgre))
101591>>>>>            End_Function
101592>>>>>        
101592>>>>>        End_Object
101593>>>>>
101593>>>>>        Procedure DbTypeUpdate Integer iDbType String sDriverID
101596>>>>>            String sDbType
101596>>>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sDbType
101597>>>>>            Set Label to (sDbType * "Connection Details")
101598>>>>>        End_Procedure
101599>>>>>
101599>>>>>    End_Object
101600>>>>>
101600>>>>>    Object oOK_Btn is a cRDCButton
101602>>>>>        Set Label    to C_$OK
101603>>>>>        Set Location to 287 208 //281 208
101604>>>>>        Set peAnchors to anBottomRight
101605>>>>>
101605>>>>>        Procedure OnClick
101608>>>>>            String sLoginText
101608>>>>>            String[] sConnectionData
101609>>>>>            tSQLConnection SQLIniFileConnection
101609>>>>>            tSQLConnection SQLIniFileConnection
101609>>>>>            Boolean bNew bOK bShouldSave
101609>>>>>            Integer iRetval
101609>>>>>
101609>>>>>            Delegate Get Should_Save to bShouldSave
101611>>>>>            If (bShouldSave = False) Begin
101613>>>>>                Set pbChanged to False
101614>>>>>                Send Close_Panel
101615>>>>>                Procedure_Return
101616>>>>>            End
101616>>>>>>
101616>>>>>
101616>>>>>            Broadcast Recursive Send WriteConnectionData of (Parent(Self)) (&sConnectionData)
101618>>>>>
101618>>>>>            Get pbNew to bNew
101619>>>>>            Get MoveStringArrayToSQLConnection sConnectionData to SQLIniFileConnection
101620>>>>>            Case Begin
101620>>>>>                Case (SQLIniFileConnection.sDriverID = DB2_DRV_ID or SQLIniFileConnection.sDriverID = ODBC_DRV_ID)
101622>>>>>                    If (SQLIniFileConnection.sDriverID = DB2_DRV_ID) Begin
101624>>>>>                        Move "" to SQLIniFileConnection.sDatabase
101625>>>>>                    End
101625>>>>>>
101625>>>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
101627>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
101629>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "") to bOK
101630>>>>>                        End
101630>>>>>>
101630>>>>>                        Else Begin
101631>>>>>                            Move (SQLIniFileConnection.sServer <> "") to bOK
101632>>>>>                        End
101632>>>>>>
101632>>>>>                    End
101632>>>>>>
101632>>>>>                    Else Begin
101633>>>>>                        // It should probably be allowed to use an UID but no password...
101633>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
101635>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
101636>>>>>                        End
101636>>>>>>
101636>>>>>                        Else Begin
101637>>>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
101638>>>>>                        End
101638>>>>>>
101638>>>>>                    End
101638>>>>>>
101638>>>>>                    Case Break
101639>>>>>                Case (SQLIniFileConnection.sDriverID = MSSQLDRV_ID or SQLIniFileConnection.sDriverID = SQLFLEX)
101642>>>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
101644>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
101646>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
101647>>>>>                        End
101647>>>>>>
101647>>>>>                        Else Begin
101648>>>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
101649>>>>>                        End
101649>>>>>>
101649>>>>>                    End
101649>>>>>>
101649>>>>>                    Else Begin
101650>>>>>                        // It should probably be allowed to use an UID but no password...
101650>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
101652>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
101653>>>>>                        End
101653>>>>>>
101653>>>>>                        Else Begin
101654>>>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
101655>>>>>                        End
101655>>>>>>
101655>>>>>                    End
101655>>>>>>
101655>>>>>                    Case Break
101656>>>>>                Case (SQLIniFileConnection.sDriverID = ORAFLEX or SQLIniFileConnection.sDriverID = MDSPgSQL)
101659>>>>>                    // It should probably be allowed to use an UID but no password...
101659>>>>>                    If (SQLIniFileConnection.bEnabled = True) Begin
101661>>>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
101662>>>>>                    End
101662>>>>>>
101662>>>>>                    Else Begin
101663>>>>>                        Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
101664>>>>>                    End
101664>>>>>>
101664>>>>>                    Case Break
101665>>>>>                Case (SQLIniFileConnection.sDriverID = MDSPgSQL)
101668>>>>>                    // It should probably be allowed to use an UID but no password...
101668>>>>>                    If (SQLIniFileConnection.bEnabled = True) Begin
101670>>>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
101671>>>>>                    End
101671>>>>>>
101671>>>>>                    Else Begin
101672>>>>>                        Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
101673>>>>>                    End
101673>>>>>>
101673>>>>>                    Case Break
101674>>>>>                Case (SQLIniFileConnection.sDriverID = MDSMySQL)
101677>>>>>                    // It should probably be allowed to use an UID but no password...
101677>>>>>                    If (SQLIniFileConnection.bEnabled = True) Begin
101679>>>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
101680>>>>>                    End
101680>>>>>>
101680>>>>>                    Else Begin
101681>>>>>                        Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
101682>>>>>                    End
101682>>>>>>
101682>>>>>                    Case Break
101683>>>>>            Case End
101683>>>>>
101683>>>>>            If (bOK = False) Begin
101685>>>>>                Send Info_Box "Please fill in all connection data."
101686>>>>>                Procedure_Return
101687>>>>>            End
101687>>>>>>
101687>>>>>
101687>>>>>            Move MBR_Yes to iRetval
101688>>>>>            Get Label of oLoginInfo_tb to sLoginText
101689>>>>>            If (sLoginText = CS_LoginFailed) Begin
101691>>>>>                Get YesNo_Box "The login failed. Are you sure you want to use these connection settings?" to iRetval
101692>>>>>            End
101692>>>>>>
101692>>>>>            Else If (sLoginText = "") Begin
101695>>>>>                Get YesNo_Box "The login has not been tested. Are you sure you want to use these connection settings?" to iRetval
101696>>>>>            End
101696>>>>>>
101696>>>>>            If (iRetval <> MBR_Yes) Begin
101698>>>>>                Procedure_Return
101699>>>>>            End
101699>>>>>>
101699>>>>>
101699>>>>>            Set pSQLConnectionData to SQLIniFileConnection
101700>>>>>            Set pbChanged to True
101701>>>>>            Send Close_Panel
101702>>>>>        End_Procedure
101703>>>>>
101703>>>>>    End_Object
101704>>>>>
101704>>>>>    Object oCancel_Btn is a cRDCButton
101706>>>>>        Set Label    to C_$Cancel
101707>>>>>        Set Location to 287 264 //281 264
101708>>>>>        Set peAnchors to anBottomRight
101709>>>>>
101709>>>>>        Procedure OnClick
101712>>>>>            Set pbChanged to False
101713>>>>>            Send Close_Panel
101714>>>>>        End_Procedure
101715>>>>>
101715>>>>>    End_Object
101716>>>>>
101716>>>>>    Object oHelp_Btn is a cRDCButton
101718>>>>>        Set Label to C_$Help
101719>>>>>        Set Location to 287 11 //281 11
101720>>>>>        Set peAnchors to anBottomLeft
101721>>>>>        Set psImage to "ActionHelp1.ico"
101722>>>>>
101722>>>>>        Procedure OnClick
101725>>>>>            Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
101726>>>>>        End_Procedure
101727>>>>>    End_Object
101728>>>>>
101728>>>>>    Object oConnectionType_grp is a cRDCHeaderGroup
101730>>>>>        Set Size to 60 303
101731>>>>>        Set Location to 8 11 //2 11
101732>>>>>        Set psImage to "SQLSettings1.ico"
101733>>>>>        Set psLabel to "Database Type Settings"
101734>>>>>
101734>>>>>        Object oDbType_cf is a cSQLComboForm
101736>>>>>            Set Size to 13 115
101737>>>>>            Set Location to 22 82
101738>>>>>            Set Label to "Database Type"
101739>>>>>            Set Entry_State to False
101740>>>>>            Set Combo_Sort_State to False
101741>>>>>            Set psToolTip to "Select a database type, then select a driver to use for the database"
101742>>>>>            Set piItem to 3
101743>>>>>            
101743>>>>>            Procedure Combo_Fill_List
101746>>>>>                Send Combo_Add_Item CS_dbTypeMSSQL
101747>>>>>                Send Combo_Add_Item CS_dbTypeMySQL
101748>>>>>                Send Combo_Add_Item CS_dbTypeOracle
101749>>>>>                Send Combo_Add_Item CS_dbTypeDB2
101750>>>>>                Send Combo_Add_Item CS_dbTypePostgre
101751>>>>>            End_Procedure
101752>>>>>
101752>>>>>            Procedure OnChange
101755>>>>>                Integer iDbType
101755>>>>>                String sDriverID
101755>>>>>    
101755>>>>>                Get SelectedDbType to iDbType
101756>>>>>                Send Refill_Comboform of oDriverID_cf iDbType
101757>>>>>                Get Value of oDriverID_cf to sDriverID
101758>>>>>                If (sDriverID = "") Begin
101760>>>>>                    Move MSSQLDRV_ID to sDriverID
101761>>>>>                End
101761>>>>>>
101761>>>>>                Send DbTypeUpdate of oSettings_grp iDbType sDriverID
101762>>>>>            End_Procedure
101763>>>>>    
101763>>>>>            Function SelectedDbType Returns Integer
101766>>>>>                Integer iRetval
101766>>>>>                String sDbType
101766>>>>>    
101766>>>>>                Get Value to sDbType
101767>>>>>                Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sDbType to iRetval
101768>>>>>    
101768>>>>>                Function_Return iRetval
101769>>>>>            End_Function
101770>>>>>
101770>>>>>        End_Object
101771>>>>>
101771>>>>>        Object oStartSQLManager_btn is a cRDCButton
101773>>>>>            Set Size to 13 78
101774>>>>>            Set Location to 22 210
101775>>>>>            Set Label to "SQL Manager"
101776>>>>>            Set pbAutoEnable to True  
101777>>>>>            Set psImage to "SSMS1.ico" 
101778>>>>>            Set psToolTip to "Start Microsoft SQL Server Management Studio"
101779>>>>>            Set peAnchors to anTopRight
101780>>>>>        
101780>>>>>            Procedure OnClick
101783>>>>>                Runprogram Shell Background "Ssms.exe"    
101784>>>>>            End_Procedure  
101785>>>>>            
101785>>>>>            Function IsEnabled Returns Boolean
101788>>>>>                String sDbType
101788>>>>>                Get Value of oDbType_cf to sDbType
101789>>>>>                Function_Return (sDbType = CS_dbTypeMSSQL)
101790>>>>>            End_Function
101791>>>>>        
101791>>>>>        End_Object
101792>>>>>
101792>>>>>        Object oDriverID_cf is a cSQLComboForm
101794>>>>>            Set Size to 13 115
101795>>>>>            Set Location to 37 82
101796>>>>>            Set Label to "Driver ID"
101797>>>>>            Set Entry_State to False
101798>>>>>            Set Combo_Sort_State to False
101799>>>>>            Set psToolTip to "Depending on the database type selected and if Mertech drivers have been installed, the comboform list will vary."
101800>>>>>            Set piItem to 4
101801>>>>>
101801>>>>>            Procedure Refill_Comboform Integer iDbType
101804>>>>>                String sValue
101804>>>>>
101804>>>>>                Send Combo_Delete_Data
101805>>>>>                Send Combo_Add_Item MSSQLDRV_ID
101806>>>>>                Send Combo_Add_Item ODBC_DRV_ID
101807>>>>>                Send Combo_Add_Item SQLFLEX
101808>>>>>                Send Combo_Add_Item ODBC_DRV_ID
101809>>>>>                Send Combo_Add_Item MDSMySQL
101810>>>>>                Send Combo_Add_Item ODBC_DRV_ID
101811>>>>>                Send Combo_Add_Item ORAFLEX
101812>>>>>                Send Combo_Add_Item DB2_DRV_ID
101813>>>>>                Send Combo_Add_Item ODBC_DRV_ID
101814>>>>>                Send Combo_Add_Item MDSPgSQL
101815>>>>>                Send Combo_Add_Item DATAFLEX_ID
101816>>>>>
101816>>>>>                Case Begin
101816>>>>>                    Case (iDbType = EN_dbTypeMSSQL)
101818>>>>>                        Move MSSQLDRV_ID to sValue
101819>>>>>                        Case Break
101820>>>>>                    Case (iDbType = EN_dbTypeMySQL)
101823>>>>>                        Move ODBC_DRV_ID to sValue
101824>>>>>                        Case Break
101825>>>>>                    Case (iDbType = EN_dbTypeOracle)
101828>>>>>                        Move ODBC_DRV_ID to sValue
101829>>>>>                        Case Break
101830>>>>>                    Case (iDbType = EN_dbTypeDB2)
101833>>>>>                        Move DB2_DRV_ID to sValue
101834>>>>>                        Case Break
101835>>>>>                    Case (iDbType = EN_dbTypePostgre)
101838>>>>>                        Move ODBC_DRV_ID to sValue
101839>>>>>                        Case Break
101840>>>>>                    Case Else
101840>>>>>                        Move DATAFLEX_ID to sValue
101841>>>>>                Case End
101841>>>>>                Set Value to sValue
101842>>>>>            End_Procedure
101843>>>>>
101843>>>>>            Procedure OnChange
101846>>>>>                String sDriverID
101846>>>>>                Integer iDbType
101846>>>>>
101846>>>>>                Get Value to sDriverID
101847>>>>>                If (sDriverID = "") Begin
101849>>>>>//                    Move MSSQLDRV_ID to sDriverID 
101849>>>>>                    Procedure_Return
101850>>>>>                End
101850>>>>>>
101850>>>>>                Get SelectedDbType of oDbType_cf to iDbType
101851>>>>>                Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
101853>>>>>            End_Procedure
101854>>>>>
101854>>>>>        End_Object
101855>>>>>
101855>>>>>        Object oShowDriverSettings_btn is a cRDCButton
101857>>>>>            Set Size to 13 78
101858>>>>>            Set Location to 37 210
101859>>>>>            Set Label to "Driver Settings"
101860>>>>>            Set Status_Help to "Shows settings for the selected driver."
101861>>>>>            Set psImage to "DriverSettings1.ico"
101862>>>>>            Set peAnchors to anTopRight
101863>>>>>
101863>>>>>            Procedure OnClick
101866>>>>>                String sDriver sPath 
101866>>>>>                
101866>>>>>                Get Value of oDriverID_cf to sDriver
101867>>>>>                Send PopupDriverSettings sDriver 
101868>>>>>            End_Procedure
101869>>>>>    
101869>>>>>        End_Object
101870>>>>>
101870>>>>>    End_Object
101871>>>>>
101871>>>>>    Function ReadCurrentSQLSettings Returns tSQLConnection
101874>>>>>        tSQLConnection SQLConnection
101874>>>>>        tSQLConnection SQLConnection
101874>>>>>
101874>>>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
101875>>>>>        Get SelectedDbType of oDbType_cf to SQLConnection.iDbType
101876>>>>>
101876>>>>>        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
101877>>>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
101878>>>>>        Get Value of oServer_fm          to SQLConnection.sServer
101879>>>>>        Get Value of oUserID_fm          to SQLConnection.sUserID
101880>>>>>        Get Value of oPassword_fm        to SQLConnection.sPassword     
101881>>>>>        Move False to Err
101882>>>>>        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) ;            SQLConnection.sDriverID SQLConnection.sServer "" SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
101883>>>>>        Set pSQLConnection of ghoSQLConnectionHandler to SQLConnection
101884>>>>>        Move Err to SQLConnection.bError
101885>>>>>        
101885>>>>>        Function_Return SQLConnection
101886>>>>>    End_Function
101887>>>>>
101887>>>>>    Function LoginString String ByRef sError Returns String
101890>>>>>        String sDriverID sServer sDatabase
101890>>>>>        tSQLConnection SQLConnection
101890>>>>>        tSQLConnection SQLConnection
101890>>>>>        
101890>>>>>        Get Value of oDriverID_cf to sDriverID
101891>>>>>        If (sDriverID = "") Begin
101893>>>>>            Move "Please select a driver first, then try again." to sError
101894>>>>>            Function_Return ""
101895>>>>>        End
101895>>>>>>
101895>>>>>
101895>>>>>        Get Value of oServer_fm   to sServer
101896>>>>>        If (sServer = "") Begin
101898>>>>>            Move "Please select a server first, then try again." to sError
101899>>>>>            Function_Return ""
101900>>>>>        End
101900>>>>>>
101900>>>>>
101900>>>>>        Get Value of oDatabase_fm to sDatabase
101901>>>>>        If (sDatabase = "" and sDriverID = MSSQLDRV_ID) Begin
101903>>>>>            Move "master" to sDatabase
101904>>>>>        End
101904>>>>>>
101904>>>>>
101904>>>>>        Get ReadCurrentSQLSettings to SQLConnection
101905>>>>>        If (SQLConnection.bError = True) Begin
101907>>>>>            Move "Login Error" to sError
101908>>>>>        End
101908>>>>>>
101908>>>>>
101908>>>>>        Function_Return SQLConnection.sConnectionString
101909>>>>>    End_Function
101910>>>>>
101910>>>>>    // Returns True if anything has changed.
101910>>>>>    Function Should_Save Returns Boolean
101913>>>>>        String[] sConnectionData sConnectionData2
101915>>>>>        tSQLConnection SQLConnectionData
101915>>>>>        tSQLConnection SQLConnectionData
101915>>>>>        Boolean bState
101915>>>>>
101915>>>>>        Broadcast Recursive Send WriteConnectionData (&sConnectionData)
101917>>>>>        Get pSQLConnectionData to SQLConnectionData
101918>>>>>        Get MoveSQLConnectionToStringArray SQLConnectionData to sConnectionData2
101919>>>>>        // We don't have a form here for the sConnectionString, so we "blank it out"
101919>>>>>        // to be able to compare properly.
101919>>>>>        Move "" to sConnectionData2[7]
101920>>>>>
101920>>>>>            Move (IsSameArray(sConnectionData, sConnectionData2)) to bState
101921>>>>>        Function_Return (bState = False)
101922>>>>>    End_Function
101923>>>>>
101923>>>>>    Function IsConnectionIDDuplicate tSQLConnection SQLConnection Returns Boolean
101926>>>>>        Integer iCount iSize iItems iCurrentRow
101926>>>>>        String sValue sConnectionID
101926>>>>>        Boolean bExists
101926>>>>>        tDataSourceRow[] TheData
101926>>>>>        tDataSourceRow[] TheData
101927>>>>>        tDataSourceRow TheRow
101927>>>>>        tDataSourceRow TheRow
101927>>>>>
101927>>>>>        Move 0 to iItems
101928>>>>>        Get piCurrentRow to iCurrentRow
101929>>>>>        Move SQLConnection.sConnectionID to sConnectionID
101930>>>>>        Get MoveSQLConnectionToGridRow SQLConnection to TheRow
101931>>>>>        Get pTheData to TheData
101932>>>>>        Move (SizeOfArray(TheData)) to iSize
101933>>>>>        If (iCurrentRow <> -1) Begin
101935>>>>>            // This is the sConnectionID:
101935>>>>>            Move TheRow.sValue[2] to TheData[iCurrentRow].sValue[2]
101936>>>>>        End
101936>>>>>>
101936>>>>>        Else Begin
101937>>>>>            Move TheRow to TheData[iSize]
101938>>>>>        End
101938>>>>>>
101938>>>>>        Move (SizeOfArray(TheData)) to iSize
101939>>>>>        Decrement iSize
101940>>>>>        For iCount from 0 to iSize
101946>>>>>>
101946>>>>>            Move TheData[iCount].sValue[2] to sValue
101947>>>>>            Move (sValue = sConnectionID) to bExists
101948>>>>>            If (bExists) Begin
101950>>>>>                Increment iItems
101951>>>>>            End
101951>>>>>>
101951>>>>>        Loop
101952>>>>>>
101952>>>>>
101952>>>>>        Function_Return (iItems > 1)
101953>>>>>    End_Function
101954>>>>>
101954>>>>>    // Transfers data between a tSQLConnection struct and a grid data row.
101954>>>>>    Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
101957>>>>>        tDataSourceRow TheRow
101957>>>>>        tDataSourceRow TheRow
101957>>>>>        Integer iDbType
101957>>>>>        String sValue
101957>>>>>
101957>>>>>        Move 0                                  to TheRow.sValue[0]
101958>>>>>        Move SQLConnection.bEnabled             to TheRow.sValue[1]
101959>>>>>        Move SQLConnection.sConnectionID        to TheRow.sValue[2]
101960>>>>>        Move SQLConnection.sDriverID            to TheRow.sValue[3]
101961>>>>>
101961>>>>>        // We only show three asterisks ("***") instead of the password in the grid.
101961>>>>>        Move (Replace(SQLConnection.sPassword, SQLConnection.sConnectionString, "***")) to sValue
101962>>>>>        Move sValue                             to TheRow.sValue[4]
101963>>>>>
101963>>>>>        Move SQLConnection.iDbType to iDbType
101964>>>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
101965>>>>>        Move sValue                             to TheRow.sValue[5]
101966>>>>>        Move SQLConnection.sServer              to TheRow.sValue[6]
101967>>>>>        Move SQLConnection.sDatabase            to TheRow.sValue[7]
101968>>>>>
101968>>>>>        // Hidden columns (to make Should_Save function work)
101968>>>>>        Move SQLConnection.sConnectionString    to TheRow.sValue[8] // "Untouched" connection string.
101969>>>>>        Move SQLConnection.bTrusted             to TheRow.sValue[9]
101970>>>>>        Move SQLConnection.sUserID              to TheRow.sValue[10]
101971>>>>>        Move SQLConnection.sPassword            to TheRow.sValue[11]
101972>>>>>        Move SQLConnection.sSchema              to TheRow.sValue[12]
101973>>>>>        Move SQLConnection.sBaseTableSpace      to TheRow.sValue[13]
101974>>>>>        Move SQLConnection.sLongTableSpace      to TheRow.sValue[14]
101975>>>>>        Move SQLConnection.sIndexTableSpace     to TheRow.sValue[15]
101976>>>>>        Move SQLConnection.bSilentLogin         to TheRow.sValue[16]
101977>>>>>//        Move SQLConnection.bDisabled            to TheRow.sValue[17]
101977>>>>>//        Move SQLConnection.iDriverIndex         to TheRow.sValue[18]
101977>>>>>
101977>>>>>        Function_Return TheRow
101978>>>>>    End_Function
101979>>>>>
101979>>>>>    Function MoveSQLConnectionToStringArray tSQLConnection SQLConnection Returns String[]
101982>>>>>        String[] sConnectionData
101983>>>>>        Integer iRetval
101983>>>>>
101983>>>>>        Move SQLConnection.bEnabled          to sConnectionData[1]
101984>>>>>        Move SQLConnection.sConnectionID     to sConnectionData[2]
101985>>>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary SQLConnection.iDbType to sConnectionData[3]
101986>>>>>        Move SQLConnection.sDriverID         to sConnectionData[4]
101987>>>>>        Move SQLConnection.sServer           to sConnectionData[5]
101988>>>>>        Move SQLConnection.sDatabase         to sConnectionData[6]
101989>>>>>        Move SQLConnection.sConnectionString to sConnectionData[7]
101990>>>>>        Move SQLConnection.bTrusted          to sConnectionData[8]
101991>>>>>        Move SQLConnection.sUserID           to sConnectionData[9]
101992>>>>>
101992>>>>>        If (SQLConnection.sPassword <> "") Begin
101994>>>>>            Move MBR_Yes to iRetval
101995>>>>>            If (pbDFConnId(Self) = True) Begin
101997>>>>>                Get YesNo_Box "You are working with a DAW 'DFConnId.ini' file. Although this program can both read/write to such a file, the password encryption/decryption algorithms are (obviously) different. Thus the password will not be touched. Continue?" to iRetval
101998>>>>>                If (iRetval = MBR_Yes) Begin
102000>>>>>                    Set psUncryptedPw to SQLConnection.sPassword
102001>>>>>                    Move "" to SQLConnection.sPassword 
102002>>>>>//                    Set Enabled_State of oCheckLogin_btn to False
102002>>>>>                End
102002>>>>>>
102002>>>>>                Else Begin
102003>>>>>                    Send Stop_UI
102004>>>>>                End
102004>>>>>>
102004>>>>>            End
102004>>>>>>
102004>>>>>            Else Begin
102005>>>>>                Move SQLConnection.sPassword to sConnectionData[10]
102006>>>>>            End
102006>>>>>>
102006>>>>>        End
102006>>>>>>
102006>>>>>
102006>>>>>        Move SQLConnection.sSchema           to sConnectionData[11]
102007>>>>>        Move SQLConnection.sBaseTableSpace   to sConnectionData[12]
102008>>>>>        Move SQLConnection.sLongTableSpace   to sConnectionData[13]
102009>>>>>        Move SQLConnection.sIndexTableSpace  to sConnectionData[14]
102010>>>>>        Move SQLConnection.bSilentLogin      to sConnectionData[15]
102011>>>>>
102011>>>>>        Function_Return sConnectionData
102012>>>>>    End_Function
102013>>>>>
102013>>>>>    Function MoveStringArrayToSQLConnection String[] sConnectionData Returns tSQLConnection
102016>>>>>        tSQLConnection SQLConnection
102016>>>>>        tSQLConnection SQLConnection
102016>>>>>
102016>>>>>        Move sConnectionData[1]  to SQLConnection.bEnabled
102017>>>>>        Move sConnectionData[2]  to SQLConnection.sConnectionID
102018>>>>>        Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sConnectionData[3] to SQLConnection.iDbType
102019>>>>>        Move sConnectionData[4]  to SQLConnection.sDriverID
102020>>>>>        Move sConnectionData[5]  to SQLConnection.sServer
102021>>>>>        Move sConnectionData[6]  to SQLConnection.sDatabase
102022>>>>>
102022>>>>>        Move sConnectionData[8]  to SQLConnection.bTrusted
102023>>>>>        Move sConnectionData[9]  to SQLConnection.sUserID
102024>>>>>
102024>>>>>        If (sConnectionData[10] <> "" and pbDFConnId(Self) = False) Begin
102026>>>>>            Move sConnectionData[10] to SQLConnection.sPassword
102027>>>>>        End
102027>>>>>>
102027>>>>>        // In case of we're dealing with a DfConnID.ini file (DF 19+) we don't want to change the password
102027>>>>>        // as DAW's 'Managed Connections' program has a different password encryption/decryption algorithm.
102027>>>>>        If (pbDFConnId(Self) = True) Begin
102029>>>>>            Get psUncryptedPw to SQLConnection.sPassword
102030>>>>>        End
102030>>>>>>
102030>>>>>
102030>>>>>        Move sConnectionData[11] to SQLConnection.sSchema
102031>>>>>        Move sConnectionData[12] to SQLConnection.sBaseTableSpace
102032>>>>>        Move sConnectionData[13] to SQLConnection.sLongTableSpace
102033>>>>>        Move sConnectionData[14] to SQLConnection.sIndexTableSpace
102034>>>>>        Move sConnectionData[15] to SQLConnection.bSilentLogin
102035>>>>>
102035>>>>>        // Connection string:
102035>>>>>        Get ConstructConnectionString of ghoSQLConnectionHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase ;                                                                 SQLConnection.bTrusted  SQLConnection.sUserID SQLConnection.sPassword ;                                      to SQLConnection.sConnectionString
102036>>>>>
102036>>>>>        Function_Return SQLConnection
102037>>>>>    End_Function
102038>>>>>
102038>>>>>    Procedure Popup
102041>>>>>        tSQLConnection SQLIniFileConnection
102041>>>>>        tSQLConnection SQLIniFileConnection
102041>>>>>        String[] sConnectionData
102042>>>>>        String sDriverID
102042>>>>>        Integer iDbType
102042>>>>>        Boolean bAdd
102042>>>>>
102042>>>>>        Move (piCurrentRow(Self) = -1) to bAdd
102043>>>>>        Get pSQLConnectionData to SQLIniFileConnection             
102044>>>>>        // we need these as the oConnectionType_grp has been moved to be the last object(s) in the dialog.
102044>>>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
102045>>>>>        Set Value of oDriverID_cf to ""
102046>>>>>        If (SQLIniFileConnection.bEnabled = False and bAdd = True) Begin
102048>>>>>            Move True to SQLIniFileConnection.bEnabled
102049>>>>>        End
102049>>>>>>
102049>>>>>        Get MoveSQLConnectionToStringArray SQLIniFileConnection to sConnectionData
102050>>>>>
102050>>>>>        Set Value of oDriverID_cf to SQLIniFileConnection.sDriverID
102051>>>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
102052>>>>>        Broadcast Recursive Send ReadConnectionData sConnectionData
102054>>>>>
102054>>>>>        // We need this message to "auto-default" certain fields.
102054>>>>>        If (bAdd = True) Begin
102056>>>>>            Get SelectedDbType of oDbType_cf to iDbType
102057>>>>>            Get Value of oDriverID_cf to sDriverID
102058>>>>>            If (sDriverID = "") Begin
102060>>>>>                Move MSSQLDRV_ID to sDriverID
102061>>>>>            End
102061>>>>>>
102061>>>>>            Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
102063>>>>>        End
102063>>>>>>
102063>>>>>
102063>>>>>        Set Password_State of oPassword_fm to True
102064>>>>>        Set Value of oLoginInfo_tb to ""
102065>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
102066>>>>>
102066>>>>>        Forward Send Popup
102068>>>>>    End_Procedure
102069>>>>>
102069>>>>>    Procedure Page Integer iPageObject
102072>>>>>        Boolean bNew bReadOnly
102072>>>>>        String sText
102072>>>>>        Handle hWnd
102072>>>>>
102072>>>>>        Send Cursor_Ready of Cursor_Control
102073>>>>>        Forward Send Page iPageObject
102075>>>>>
102075>>>>>        Set Icon to "SQLConnections1.ico"
102076>>>>>
102076>>>>>        Get pbNew to bNew
102077>>>>>        If (bNew = True) Begin
102079>>>>>            Move ("The" * CS_SQLIniFileName * "file doesn't exist yet for this workspace and needs to be created. Here's what you need to do:\n\n") to sText
102080>>>>>            Move (sText * "1. Enter a Connection ID (the same that is being used by your workspace .int files) and other data that is used to login to the database.\n") to sText
102081>>>>>            Move (sText * "2. Press the 'Test Login' button to ensure entered details are correct.\n") to sText
102082>>>>>            Move (sText * "3. Press the 'OK' button and then save your changes.\n") to sText
102083>>>>>            Send Info_Box sText
102084>>>>>        End
102084>>>>>>
102084>>>>>
102084>>>>>        If (ghoSkinFramework <> 0 and hWnd <> 0) Begin
102086>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
102087>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
102088>>>>>        End
102088>>>>>>
102088>>>>>
102088>>>>>        Get pbReadOnly to bReadOnly
102089>>>>>        If (bReadOnly = True) Begin
102091>>>>>            Broadcast Recursive Set Enabled_State    to (not(bReadOnly))
102093>>>>>            Set Enabled_State of oConnectionType_grp to True
102094>>>>>            Set Enabled_State of oSettings_grp       to True
102095>>>>>            Set Enabled_State of oPassword_fm        to True
102096>>>>>            Set Enabled_State of oViewPassword_btn   to True
102097>>>>>            Set Enabled_State of oCheckLogin_btn     to True
102098>>>>>            Set Enabled_State of oCancel_Btn         to True
102099>>>>>            Set Enabled_State of oHelp_Btn           to True
102100>>>>>            Set Enabled_State of oShowDriverSettings_btn to True
102101>>>>>            Set Enabled_State of oCreateDatabase_btn to False
102102>>>>>            Send Activate of oCancel_Btn
102103>>>>>        End
102103>>>>>>
102103>>>>>    End_Procedure
102104>>>>>
102104>>>>>    Function IniFileName Returns String
102107>>>>>        String sRetval
102107>>>>>        Function_Return sRetval
102108>>>>>    End_Function
102109>>>>>
102109>>>>>    // Put a status bar at the bottom of the panel, which makes
102109>>>>>    // status_help work and puts a gripper in the lower right corner.
102109>>>>>    Procedure End_Construct_Object
102112>>>>>        Integer iStyle iSize iOffset
102112>>>>>
102112>>>>>        Forward Send End_Construct_Object
102114>>>>>
102114>>>>>        Get Border_Style to iStyle
102115>>>>>        Move 8 to iOffset
102116>>>>>        If (iStyle = Border_Thick) Begin
102118>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
102120>>>>>                Object oStatusBar is a cCJStatusBar
102122>>>>>                    Set phoDialogCommandbar to Self
102123>>>>>                    Object oStatusIdle is a cCJStatusBarPane
102125>>>>>                        Set piId to sbpIDIdlePane
102126>>>>>                        Set pbStyleStretch to True
102127>>>>>                    End_Object
102128>>>>>                End_Object
102129>>>>>            End_Object
102130>>>>>
102130>>>>>            Get Size to iSize
102131>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
102132>>>>>        End
102132>>>>>>
102132>>>>>    End_Procedure
102133>>>>>
102133>>>>>    Procedure ShowProgramHelp
102136>>>>>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
102137>>>>>    End_Procedure
102138>>>>>
102138>>>>>    On_Key Key_F1         Send ShowProgramHelp
102139>>>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oCheckLogin_btn
102140>>>>>    On_Key kCancel        Send KeyAction of oCancel_Btn
102141>>>>>End_Object
102142>>>>>
102142>>>>>// General purpose access message                                                                                                           // If ini-file= "DFConnId.ini" (DAW file)
102142>>>>>Procedure Activate_SQLMaintainConnections_dg Boolean bNew Integer iCurrentRow tSQLConnection ByRef SQLConnectionData Boolean ByRef bChanged Boolean bDFConnId tDataSourceRow[] TheData
102145>>>>>    Handle ho
102145>>>>>    String sPath sSQLConnectionsFileName
102145>>>>>    Boolean bExists
102145>>>>>    
102145>>>>>    Send Cursor_Wait of Cursor_Control
102146>>>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
102147>>>>>    Set pbReadOnly              of ho to False
102148>>>>>    Set pbNew                   of ho to bNew
102149>>>>>    Set piCurrentRow            of ho to iCurrentRow
102150>>>>>    Set pbDFConnId              of ho to bDFConnId
102151>>>>>    Set pSQLConnectionData      of ho to SQLConnectionData
102152>>>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
102153>>>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
102154>>>>>    File_Exist (sPath + sSQLConnectionsFileName) bExists
102155>>>>>    If (bExists = True) Begin
102157>>>>>     Set Label  of ho to ("Connection Properties" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
102158>>>>>    End
102158>>>>>>
102158>>>>>    
102158>>>>>    Set pTheData                of ho to TheData
102159>>>>>
102159>>>>>    Send Popup                  of ho
102160>>>>>
102160>>>>>    Get pSQLConnectionData      of ho to SQLConnectionData
102161>>>>>    Get pbChanged               of ho to bChanged
102162>>>>>End_Procedure
102163>>>>>
102163>>>>>// Read-only access message
102163>>>>>Procedure Activate_ReadOnlySQLMaintainConnections_dg tSQLConnection SQLConnectionData
102166>>>>>    Handle ho
102166>>>>>    String sPath sSQLConnectionsFileName
102166>>>>>
102166>>>>>    Send Cursor_Wait of Cursor_Control
102167>>>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
102168>>>>>    Set pbReadOnly              of ho to True
102169>>>>>
102169>>>>>    Set pSQLConnectionData      of ho to SQLConnectionData
102170>>>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
102171>>>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
102172>>>>>    Set Label  of ho to ("Connection Properties (Read-Only)" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
102173>>>>>
102173>>>>>    Send Popup of ho
102174>>>>>End_Procedure
102175>>>>>
102175>>>
102175>>>Activate_View Activate_oSQLMaintainConnection for oSQLMaintainConnection
102185>>>>
102185>>>Object oSQLMaintainConnection is a dbView
102187>>>    Set Size to 135 538
102188>>>    Set Location to 2 2
102189>>>    Set Maximize_Icon to True
102190>>>    Set Minimize_Icon to False
102191>>>    Set Border_Style to Border_Thick
102192>>>    Set View_Mode to Viewmode_Zoom
102193>>>    Set pbAutoActivate to True
102194>>>    Set pbAcceptDropFiles to True
102195>>>
102195>>>    Set phoMainView of ghoApplication to Self
102196>>>    
102196>>>    Property Boolean pbEnabled False
102198>>>    Property Boolean pbNew False
102200>>>    Property tDataSourceRow[] pTheData
102202>>>
102202>>>    Function IniFileName Returns String
102205>>>        String sRetval
102205>>>        Get InfileName of oSQLConnections_grd to sRetval
102206>>>        Function_Return sRetval
102207>>>    End_Function
102208>>>
102208>>>    Object oGridInfo_tb is a TextBox
102210>>>        Set Auto_Size_State to False
102211>>>        Set Size to 9 368
102212>>>        Set Location to 10 34
102213>>>        Set Label to "Note: You can drag and drop a connection file on to the grid."
102214>>>        Set FontItalics to True
102215>>>        Set peAnchors to anTopLeftRight
102216>>>        Set Justification_Mode to JMode_Left
102217>>>    End_Object
102218>>>
102218>>>    Object oSQLConnections_grd is a cCJGrid
102220>>>        Set Size to 98 503
102221>>>        Set Location to 25 19
102222>>>        Set peAnchors to anAll
102223>>>        Set pbShowRowFocus to True
102224>>>        Set pbUseAlternateRowBackgroundColor to True
102225>>>        Set pbSelectionEnable to True
102226>>>        Set pbRestoreLayout to True
102227>>>        Set psLayoutSection to "oSQLConnections_grd"
102228>>>        Set piLayoutBuild to 13
102229>>>        Set pbShowFooter to True
102230>>>        Set pbAllowAppendRow to False
102231>>>        Set pbAllowEdit to False
102232>>>        Set pbAllowInsertRow to False
102233>>>        Set pbAutoAppend to False
102234>>>        Set pbAutoSave to False
102235>>>        Set pbEditOnTyping to False
102236>>>            Set peVisualTheme to xtpReportThemeOffice2003
102237>>>            Set peTooltipStyle to xtpToolTipOffice2013
102238>>>        
102238>>>        Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
102240>>>            Set piWidth to 18
102241>>>        End_Object
102242>>>
102242>>>        Object oActive_Col is a cCJGridColumn
102244>>>            Set piWidth to 81
102245>>>            Set psCaption to "Enabled"
102246>>>            Set pbCheckbox to True
102247>>>            Set psToolTip to "Only one connection can be the active one at any time. Press the 'Edit' button or double-click on a row to edit."
102248>>>        End_Object
102249>>>
102249>>>        Object oConnectionID_Col is a cCJGridColumn
102251>>>            Set piWidth to 90
102252>>>            Set psCaption to "ID"
102253>>>        End_Object
102254>>>
102254>>>        Object oDbType_Col is a cCJGridColumn
102256>>>            Set piWidth to 150
102257>>>            Set psCaption to "Database Type"
102258>>>        End_Object
102259>>>
102259>>>        Object oServer_Col is a cCJGridColumn
102261>>>            Set piWidth to 138
102262>>>            Set psCaption to "Server"
102263>>>        End_Object
102264>>>
102264>>>        Object oDatabase_Col is a cCJGridColumn
102266>>>            Set piWidth to 92
102267>>>            Set psCaption to "Database"
102268>>>        End_Object
102269>>>
102269>>>        Object oDriver_Col is a cCJGridColumn
102271>>>            Set piWidth to 101
102272>>>            Set psCaption to "Driver ID"
102273>>>        End_Object
102274>>>
102274>>>        Object oConnectionString_Col is a cCJGridColumn
102276>>>            Set piWidth to 372
102277>>>            Set psCaption to "Connection String"
102278>>>            Set psTooltip to "The full connection string as read from the connections ini-file. Press the 'Edit' button or double-click on a row to edit."
102279>>>        End_Object
102280>>>
102280>>>        // The following columns are all hidden. The only reason they are here is to make the grid data exactly the same
102280>>>        // as the tSQLConnection data.
102280>>>        // See the "Should_Save" function
102280>>>        //
102280>>>        // "Untouched" connection string column. Needed when passing data between grid and popup dialog as we mask pw in connection string.
102280>>>        Object oConnectionStringFull_Col is a cCJGridColumn
102282>>>            Set piWidth to 50
102283>>>            Set psCaption to "Connection String (Untouched)"
102284>>>            Set pbVisible to False   
102285>>>            Set pbShowInFieldChooser to False
102286>>>        End_Object
102287>>>
102287>>>        Object oTrusted_Col is a cCJGridColumn
102289>>>            Set piWidth to 50
102290>>>            Set psCaption to "Trusted"
102291>>>            Set pbCheckbox to True
102292>>>            Set pbVisible to False
102293>>>        End_Object
102294>>>
102294>>>        Object oUserID_Col is a cCJGridColumn
102296>>>            Set piWidth to 50
102297>>>            Set psCaption to "UserID"
102298>>>            Set pbVisible to False
102299>>>        End_Object
102300>>>
102300>>>        Object oPassword_Col is a cCJGridColumn
102302>>>            Set piWidth to 50
102303>>>            Set psCaption to "Password"
102304>>>            Set pbVisible to False
102305>>>            Set pbShowInFieldChooser to False
102306>>>        End_Object
102307>>>
102307>>>        Object oSchema_Col is a cCJGridColumn
102309>>>            Set piWidth to 50
102310>>>            Set psCaption to "Schema"
102311>>>            Set pbVisible to False
102312>>>        End_Object
102313>>>
102313>>>        Object oBaseTableSpace_Col is a cCJGridColumn
102315>>>            Set piWidth to 50
102316>>>            Set psCaption to "Base Table Space"
102317>>>            Set pbVisible to False
102318>>>        End_Object
102319>>>
102319>>>        Object oLongTableSpace_Col is a cCJGridColumn
102321>>>            Set piWidth to 50
102322>>>            Set psCaption to "Long Table Space"
102323>>>            Set pbVisible to False
102324>>>        End_Object
102325>>>
102325>>>        Object oIndexTableSpace_Col is a cCJGridColumn
102327>>>            Set piWidth to 50
102328>>>            Set psCaption to "Index Table Space"
102329>>>            Set pbVisible to False
102330>>>        End_Object
102331>>>
102331>>>        Object oSilentLogin_Col is a cCJGridColumn
102333>>>            Set piWidth to 50
102334>>>            Set psCaption to "Silent Login"
102335>>>            Set pbCheckbox to True
102336>>>            Set pbVisible to False
102337>>>        End_Object
102338>>>
102338>>>//        Object oDisabled_Col is a cCJGridColumn
102338>>>//            Set piWidth to 50
102338>>>//            Set psCaption to "Disabled"
102338>>>//            Set pbVisible to False
102338>>>//        End_Object
102338>>>
102338>>>        Object oCJContextMenu is a cCJContextMenu
102340>>>            Set pbShowPopupBarToolTips of ghoCommandBars to True
102341>>>
102341>>>            Object oAddMenuItem is a cCJMenuItem
102343>>>                Set psCaption to "Add"
102344>>>                Set psTooltip to "Add new connection"
102345>>>                Set psImage to "ActionAdd1.ico"
102346>>>                Set psShortcut to "Ctrl+A"
102347>>>                Procedure OnExecute Variant vCommandBarControl
102350>>>                    Forward Send OnExecute vCommandBarControl
102352>>>                    Send AddItem
102353>>>                End_Procedure
102354>>>            End_Object
102355>>>
102355>>>            Object oEditMenuItem is a cCJMenuItem
102357>>>                Set psCaption to "Edit"
102358>>>                Set psTooltip to "Edit existing connection"
102359>>>                Set psImage to "ActionEdit1.ico"
102360>>>                Set psShortcut to "Ctrl+E"
102361>>>                Procedure OnExecute Variant vCommandBarControl
102364>>>                    Forward Send OnExecute vCommandBarControl
102366>>>                    Send EditItem
102367>>>                End_Procedure
102368>>>            End_Object
102369>>>
102369>>>            Object oDeleteMenuItem is a cCJMenuItem
102371>>>                Set psCaption to "Delete"
102372>>>                Set psTooltip to "Delete current connection"
102373>>>                Set psImage to "ActionDelete1.ico"
102374>>>                Set psShortcut to "Del"
102375>>>                Procedure OnExecute Variant vCommandBarControl
102378>>>                    Forward Send OnExecute vCommandBarControl
102380>>>                    Send DeleteItem 
102381>>>                End_Procedure
102382>>>            End_Object
102383>>>
102383>>>            Object oSaveMenuItem is a cCJMenuItem
102385>>>                Set pbControlBeginGroup to True
102386>>>                Set psCaption to "Save"
102387>>>                Set psTooltip to "Save changes"
102388>>>                Set psImage to "ActionSave1.ico" 
102389>>>                Set psShortcut to "Ctrl+S"
102390>>>                
102390>>>                Procedure OnExecute Variant vCommandBarControl
102393>>>                    Forward Send OnExecute vCommandBarControl
102395>>>                    Send SaveIniFile 
102396>>>                End_Procedure
102397>>>
102397>>>                Function IsEnabled Returns Boolean
102400>>>                    Boolean bState
102400>>>                    Get Should_Save to bState
102401>>>                    Function_Return (bState = True)
102402>>>                End_Function
102403>>>            End_Object
102404>>>
102404>>>            Object oSaveAsMenuItem is a cCJMenuItem
102406>>>                Set psCaption to "Save As"
102407>>>                Set psTooltip to "Save SQL Configuration File As"  
102408>>>                Set psImage to "ActionSaveAs1.ico"
102409>>>                
102409>>>                Procedure OnExecute Variant vCommandBarControl  
102412>>>                    String sPath sIniFileName sFileName
102412>>>
102412>>>                    Forward Send OnExecute vCommandBarControl
102414>>>                    
102414>>>                    Get psIniFilePath of ghoSQLConnectionHandler to sPath
102415>>>                    Get psIniFileName of ghoSQLConnectionHandler to sIniFileName
102416>>>                    Get vSelectSaveFile ".int" "Please enter a file name to save to" sPath sIniFileName to sFileName
102417>>>                    If (sFileName <> "") Begin
102419>>>                        Get ParseFolderName sFileName to sPath
102420>>>                        Get ParseFileName   sFileName to sIniFileName
102421>>>                        Set psIniFilePath of ghoSQLConnectionHandler to sPath
102422>>>                        Set psIniFileName of ghoSQLConnectionHandler to sIniFileName
102423>>>                        Send SaveIniFile  of (phoMainView(ghoApplication))
102424>>>                    End
102424>>>>
102424>>>                End_Procedure
102425>>>
102425>>>            End_Object   
102426>>>
102426>>>            Object oOpenMenuItem is a cCJMenuItem
102428>>>                Set pbControlBeginGroup to True
102429>>>                Set psCaption to "Open"
102430>>>                Set psTooltip to "Open SQL Connection ini-file"
102431>>>                Set psImage to "ActionOpen1.ico"
102432>>>                Set psShortcut to "Ctrl+O"
102433>>>                Procedure OnExecute Variant vCommandBarControl
102436>>>                    Forward Send OnExecute vCommandBarControl
102438>>>                    Send ActivateOpenDialog
102439>>>                End_Procedure
102440>>>            End_Object
102441>>>
102441>>>            Object oRefreshMenuItem is a cCJMenuItem
102443>>>                Set psCaption to "Refresh"
102444>>>                Set psTooltip to "Refresh grid (re-read values from ini-file)"
102445>>>                Set psImage to "ActionRefresh1.ico"
102446>>>                Set psShortcut to "Ctrl+R"
102447>>>
102447>>>                Procedure OnExecute Variant vCommandBarControl
102450>>>                    Forward Send OnExecute vCommandBarControl
102452>>>                    Send RefreshIniFile
102453>>>                End_Procedure
102454>>>
102454>>>                Function IsEnabled Returns Boolean
102457>>>                    Boolean bSave
102457>>>                    Get Should_Save to bSave
102458>>>                    Function_Return (bSave = True)
102459>>>                End_Function
102460>>>                
102460>>>            End_Object
102461>>>
102461>>>            Set phoContextMenu to Self
102462>>>        End_Object
102463>>>
102463>>>        Function Should_Save Returns Boolean
102466>>>            tDataSourceRow[] TheData1 TheData2
102466>>>            tDataSourceRow[] TheData1 TheData2
102468>>>            Handle hoDataSource
102468>>>            Boolean bShouldSave
102468>>>
102468>>>            Move True to bShouldSave
102469>>>            Get pTheData to TheData1
102470>>>            Get phoDataSource to hoDataSource
102471>>>            Get DataSource    of hoDataSource to TheData2
102472>>>                Move (not(IsSameArray(TheData1, TheData2))) to bShouldSave
102473>>>
102473>>>            Function_Return bShouldSave
102474>>>        End_Function
102475>>>
102475>>>        Function HasRecord Returns Boolean
102478>>>            tDataSourceRow[] TheData
102478>>>            tDataSourceRow[] TheData
102479>>>            Handle hoDataSource
102479>>>            Integer iSize
102479>>>
102479>>>            Get phoDataSource to hoDataSource
102480>>>            Get DataSource    of hoDataSource to TheData
102481>>>            Move (SizeOfArray(TheData)) to iSize
102482>>>
102482>>>            Function_Return (iSize > 0)
102483>>>        End_Function
102484>>>
102484>>>        Procedure ChangeHeaderText
102487>>>            Handle[] hoPanels
102488>>>            String sFileName
102488>>>
102488>>>            Send ChangeStatusRowText ""
102489>>>            Get IniFileName to sFileName
102490>>>            // Not sure why, but if the oStatusPane1 was set to "Set piID to sbpIDIdlePane",
102490>>>            // it wasn't always updated when this message was send. So instead change the
102490>>>            // text explicitly:
102490>>>            Get PaneObjects of (phoStatusBar(ghoCommandBars)) to hoPanels
102491>>>            Set psText of hoPanels[0] to sFileName
102492>>>        End_Procedure
102493>>>        
102493>>>        Function InFileName Returns String
102496>>>            String sFileName sPath
102496>>>            Handle ho
102496>>>            Boolean bChangesExist
102496>>>
102496>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
102497>>>            Get psIniFilePath of ho to sPath
102498>>>            Get psIniFileName of ho to sFileName
102499>>>            If (sFileName = "") Begin
102501>>>                Move "" to sPath
102502>>>            End                 
102502>>>>
102502>>>            Else Begin
102503>>>                Get Should_Save to bChangesExist
102504>>>                If (bChangesExist = True) Begin
102506>>>                    Move (sFileName + "*") to sFileName
102507>>>                End
102507>>>>
102507>>>            End
102507>>>>
102507>>>            Function_Return (sPath + sFileName)
102508>>>        End_Function
102509>>>
102509>>>        Procedure LoadData
102512>>>            Handle hoDataSource ho
102512>>>            tDataSourceRow[] TheData
102512>>>            tDataSourceRow[] TheData
102513>>>            tDataSourceRow TheRow
102513>>>            tDataSourceRow TheRow
102513>>>            Integer iCount iSize
102513>>>            tSQLConnection[] SQLConnectionsArray
102513>>>            tSQLConnection[] SQLConnectionsArray
102514>>>
102514>>>            Send ChangeHeaderText
102515>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
102516>>>
102516>>>            Get phoDataSource to hoDataSource
102517>>>            Send Reset of hoDataSource
102518>>>
102518>>>            Get ReadIniFile to SQLConnectionsArray
102519>>>            Move (SizeOfArray(SQLConnectionsArray)) to iSize
102520>>>            Decrement iSize
102521>>>
102521>>>            // Load data to the grid datasource array
102521>>>            For iCount from 0 to iSize
102527>>>>
102527>>>                Get MoveSQLConnectionToGridRow SQLConnectionsArray[iCount] to TheRow
102528>>>                Move TheRow to TheData[iCount]
102529>>>            Loop
102530>>>>
102530>>>
102530>>>            Set pTheData to TheData
102531>>>
102531>>>            // Initialize Grid with new data
102531>>>            Send InitializeData TheData
102532>>>
102532>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize +1))
102533>>>            Send MovetoFirstRow
102534>>>        End_Procedure    
102535>>>        
102535>>>        Procedure ClearData    
102538>>>            Handle hoDataSource
102538>>>            tDataSourceRow[] TheData
102538>>>            tDataSourceRow[] TheData
102539>>>
102539>>>            Send ChangeHeaderText
102540>>>            Set pTheData to TheData
102541>>>            Get phoDataSource to hoDataSource 
102542>>>            Send InitializeData TheData
102543>>>        End_Procedure
102544>>>
102544>>>        // Transfers data between a tSQLConnection struct and a grid data row.
102544>>>        Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
102547>>>            tDataSourceRow TheRow
102547>>>            tDataSourceRow TheRow
102547>>>            Integer iDbType
102547>>>            String sValue
102547>>>
102547>>>            Move SQLConnection.bEnabled             to TheRow.sValue[piColumnId(oActive_Col(Self))]
102548>>>            Move SQLConnection.sConnectionID        to TheRow.sValue[piColumnId(oConnectionID_Col(Self))]
102549>>>            Move SQLConnection.sDriverID            to TheRow.sValue[piColumnId(oDriver_Col(Self))]
102550>>>
102550>>>            // We only show three asterisks ("***") instead of the password in the grid.
102550>>>            Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
102551>>>            Move sValue                             to TheRow.sValue[piColumnId(oConnectionString_Col(Self))]
102552>>>
102552>>>            Move SQLConnection.iDbType to iDbType
102553>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
102554>>>            Move sValue                             to TheRow.sValue[piColumnId(oDbType_Col(Self))]
102555>>>            Move SQLConnection.sServer              to TheRow.sValue[piColumnId(oServer_Col(Self))]
102556>>>            Move SQLConnection.sDatabase            to TheRow.sValue[piColumnId(oDatabase_Col(Self))]
102557>>>
102557>>>            // Hidden columns (to make Should_Save function work)
102557>>>            Move SQLConnection.sConnectionString    to TheRow.sValue[piColumnId(oConnectionStringFull_Col(Self))] // "Untouched" connection string.
102558>>>            Move SQLConnection.bTrusted             to TheRow.sValue[piColumnId(oTrusted_Col(Self))]
102559>>>            Move SQLConnection.sUserID              to TheRow.sValue[piColumnId(oUserID_Col(Self))]
102560>>>            Move SQLConnection.sPassword            to TheRow.sValue[piColumnId(oPassword_Col(Self))]
102561>>>            Move SQLConnection.sSchema              to TheRow.sValue[piColumnId(oSchema_Col(Self))]
102562>>>            Move SQLConnection.sBaseTableSpace      to TheRow.sValue[piColumnId(oBaseTableSpace_Col(Self))]
102563>>>            Move SQLConnection.sLongTableSpace      to TheRow.sValue[piColumnId(oLongTableSpace_Col(Self))]
102564>>>            Move SQLConnection.sIndexTableSpace     to TheRow.sValue[piColumnId(oIndexTableSpace_Col(Self))]
102565>>>            Move SQLConnection.bSilentLogin         to TheRow.sValue[piColumnId(oSilentLogin_Col(Self))]
102566>>>//            Move SQLConnection.bDisabled            to TheRow.sValue[piColumnId(oDisabled_Col(Self))]
102566>>>
102566>>>            Function_Return TheRow
102567>>>        End_Function
102568>>>
102568>>>        // Transfers data between a grid data row and a tSQLConnection struct.
102568>>>        Function MoveGridRowToSQLConnection tDataSourceRow TheRow Returns tSQLConnection
102571>>>            tSQLConnection SQLConnection
102571>>>            tSQLConnection SQLConnection
102571>>>            String sValue
102571>>>
102571>>>            Move TheRow.sValue[piColumnId(oActive_Col(Self))]               to SQLConnection.bEnabled
102572>>>            Move TheRow.sValue[piColumnId(oConnectionID_Col(Self))]         to SQLConnection.sConnectionID
102573>>>
102573>>>            Move TheRow.sValue[piColumnId(oDbType_Col(Self))]               to sValue
102574>>>            Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sValue to SQLConnection.iDbType
102575>>>            Move TheRow.sValue[piColumnId(oServer_Col(Self))]               to SQLConnection.sServer
102576>>>            Move TheRow.sValue[piColumnId(oDatabase_Col(Self))]             to SQLConnection.sDatabase
102577>>>            Move TheRow.sValue[piColumnId(oDriver_Col(Self))]               to SQLConnection.sDriverID
102578>>>
102578>>>            // Hidden columns (to make Should_Save function work)
102578>>>            Move TheRow.sValue[piColumnId(oConnectionStringFull_Col(Self))] to SQLConnection.sConnectionString
102579>>>            Move TheRow.sValue[piColumnId(oTrusted_Col(Self))]              to SQLConnection.bTrusted
102580>>>            Move TheRow.sValue[piColumnId(oUserID_Col(Self))]               to SQLConnection.sUserID
102581>>>            Move TheRow.sValue[piColumnId(oPassword_Col(Self))]             to SQLConnection.sPassword
102582>>>            Move TheRow.sValue[piColumnId(oSchema_Col(Self))]               to SQLConnection.sSchema
102583>>>            Move TheRow.sValue[piColumnId(oBaseTableSpace_Col(Self))]       to SQLConnection.sBaseTableSpace
102584>>>            Move TheRow.sValue[piColumnId(oLongTableSpace_Col(Self))]       to SQLConnection.sLongTableSpace
102585>>>            Move TheRow.sValue[piColumnId(oIndexTableSpace_Col(Self))]      to SQLConnection.sIndexTableSpace
102586>>>            Move TheRow.sValue[piColumnId(oSilentLogin_Col(Self))]          to SQLConnection.bSilentLogin
102587>>>//            Move TheRow.sValue[piColumnId(oDisabled_Col(Self))]             to SQLConnection.bDisabled
102587>>>
102587>>>            Function_Return SQLConnection
102588>>>        End_Function
102589>>>
102589>>>        // Called when the grid object is created:
102589>>>        Procedure Activating
102592>>>            Forward Send Activating
102594>>>            Send LoadData
102595>>>        End_Procedure
102596>>>
102596>>>        Function CurrentRow Returns Integer
102599>>>            Handle hoDataSource
102599>>>            Integer iRow
102599>>>
102599>>>            Get phoDataSource to hoDataSource
102600>>>            Get SelectedRow   of hoDataSource to iRow
102601>>>            Function_Return iRow
102602>>>        End_Function
102603>>>
102603>>>        Function CurrentRowData Returns tDataSourceRow
102606>>>            tDataSourceRow[] TheData
102606>>>            tDataSourceRow[] TheData
102607>>>            tDataSourceRow TheRow
102607>>>            tDataSourceRow TheRow
102607>>>            Handle ho hoDataSource
102607>>>            Integer iRow
102607>>>
102607>>>            Get phoDataSource  to hoDataSource
102608>>>            Get DataSource     of hoDataSource to TheData
102609>>>            Get SelectedRow    of hoDataSource to iRow
102610>>>            Move TheData[iRow] to TheRow
102611>>>
102611>>>            Function_Return TheRow
102612>>>        End_Function
102613>>>
102613>>>        Procedure OnRowChanged Integer iOldRow Integer iNewSelectedRow
102616>>>            Integer iRow
102616>>>            Handle hoDataSource
102616>>>            tDataSourceRow[] RowData
102616>>>            tDataSourceRow[] RowData
102617>>>
102617>>>            Forward Send OnRowChanged iOldRow iNewSelectedRow
102619>>>            Send ChangeHeaderText
102620>>>
102620>>>            Get phoDataSource to hoDataSource
102621>>>
102621>>>            Get SelectedRow of hoDataSource to iRow
102622>>>            If (iRow <> -1) Begin
102624>>>                Get DataSource of hoDataSource to RowData
102625>>>                Set pbEnabled to RowData[iRow].sValue[piColumnid(oActive_Col(Self))]
102626>>>            End
102626>>>>
102626>>>        End_Procedure
102627>>>
102627>>>        Procedure OnComRowDblClick Variant llRow Variant llItem
102630>>>            Forward Send OnComRowDblClick llRow llItem
102632>>>            Delegate Send EditItem 
102634>>>        End_Procedure
102635>>>
102635>>>        Procedure OnEnterKey
102638>>>            Forward Send OnEnterKey
102640>>>            Delegate Send EditItem 
102642>>>        End_Procedure
102643>>>
102643>>>        Procedure AddConnection tDataSourceRow TheRow
102646>>>            Integer iSize iCount
102646>>>            Handle hoDataSource
102646>>>            tDataSourceRow[] TheData
102646>>>            tDataSourceRow[] TheData
102647>>>            Boolean bEnabled
102647>>>
102647>>>            Get phoDataSource to hoDataSource
102648>>>            Get DataSource    of hoDataSource to TheData
102649>>>
102649>>>            Move (SizeOfArray(TheData)) to iSize
102650>>>            Move (TheRow.sValue[piColumnid(oActive_Col(Self))]) to bEnabled
102651>>>            If (bEnabled = True) Begin
102653>>>                // Then bEnabled state have changed; deactivate all current rows.
102653>>>                For iCount from 0 to (iSize -1)
102659>>>>
102659>>>                    Move False to TheData[iCount].sValue[piColumnId(oActive_Col(Self))]
102660>>>                Loop
102661>>>>
102661>>>            End
102661>>>>
102661>>>
102661>>>            Move TheRow to TheData[iSize]
102662>>>
102662>>>            // Initialize Grid with new data
102662>>>            Send InitializeData TheData True
102663>>>            Move (SizeOfArray(TheData)) to iSize
102664>>>            Send MoveToLastRow
102665>>>
102665>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
102666>>>        End_Procedure
102667>>>
102667>>>        Procedure UpdateConnection tDataSourceRow TheRow
102670>>>            Integer iRow iSize iCount
102670>>>            Handle hoDataSource
102670>>>            tDataSourceRow[] TheData
102670>>>            tDataSourceRow[] TheData
102671>>>            Boolean bEnabled
102671>>>
102671>>>            Get phoDataSource to hoDataSource
102672>>>            Get SelectedRow of hoDataSource to iRow
102673>>>            If (iRow <> -1) Begin
102675>>>                Get DataSource of hoDataSource to TheData
102676>>>
102676>>>                // If bEnabled state has changed; deactivate all rows.
102676>>>                Move (TheRow.sValue[piColumnId(oActive_Col(Self))]) to bEnabled
102677>>>                If (bEnabled = True) Begin
102679>>>                    Move (SizeOfArray(TheData)) to iSize
102680>>>                    Decrement iSize
102681>>>                    For iCount from 0 to iSize
102687>>>>
102687>>>                        Move False to TheData[iCount].sValue[piColumnId(oActive_Col(Self))]
102688>>>                    Loop
102689>>>>
102689>>>                End
102689>>>>
102689>>>
102689>>>                Move TheRow to TheData[iRow]
102690>>>            End
102690>>>>
102690>>>
102690>>>            // Initialize Grid with new data
102690>>>            Send ReInitializeData TheData True
102691>>>            Move (SizeOfArray(TheData)) to iSize
102692>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
102693>>>        End_Procedure
102694>>>
102694>>>        Procedure RemoveCurrentConnection
102697>>>            Integer iSize iRow iItem
102697>>>            Handle hoDataSource
102697>>>            tDataSourceRow[] TheData
102697>>>            tDataSourceRow[] TheData
102698>>>
102698>>>            Move 0 to iItem
102699>>>            Get phoDataSource to hoDataSource
102700>>>            Get DataSource of hoDataSource to TheData
102701>>>
102701>>>            Get SelectedRow of hoDataSource to iRow
102702>>>            If (iRow = -1) Begin
102704>>>                Procedure_Return
102705>>>            End
102705>>>>
102705>>>
102705>>>            Move False to Err
102706>>>            Send Request_Delete
102707>>>
102707>>>            Get DataSource of hoDataSource to TheData
102708>>>            Move (SizeOfArray(TheData)) to iSize
102709>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
102710>>>        End_Procedure
102711>>>
102711>>>        Function IsOneItemActive Returns Boolean
102714>>>            Handle hoDataSource ho
102714>>>            tDataSourceRow[] TheData
102714>>>            tDataSourceRow[] TheData
102715>>>            Integer iSize iCount
102715>>>            Boolean bRetval bExists
102715>>>            String sSection
102715>>>
102715>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
102716>>>            Get psIniSectionName of ho to sSection
102717>>>            Get SectionExists    of ho sSection to bExists
102718>>>
102718>>>            Get phoDataSource to hoDataSource
102719>>>            Get DataSource of hoDataSource to TheData
102720>>>
102720>>>            Move (SizeOfArray(TheData)) to iSize
102721>>>            If (iSize = 0) Begin
102723>>>                Function_Return True
102724>>>            End
102724>>>>
102724>>>
102724>>>            Decrement iSize
102725>>>            For iCount from 0 to iSize
102731>>>>
102731>>>                If (TheData[iCount].sValue[piColumnId(oActive_Col(Self))] = True) Begin
102733>>>                    Move True to bRetval
102734>>>                End
102734>>>>
102734>>>            Loop
102735>>>>
102735>>>
102735>>>            Function_Return bRetval
102736>>>        End_Function
102737>>>
102737>>>        Function ReadIniFile Returns tSQLConnection[]
102740>>>            tSQLConnection[] SQLConnectionsArray
102740>>>            tSQLConnection[] SQLConnectionsArray
102741>>>            Handle ho
102741>>>
102741>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
102742>>>            Get SQLIniFileReadConnections of ho to SQLConnectionsArray
102743>>>
102743>>>            Function_Return SQLConnectionsArray
102744>>>        End_Function
102745>>>
102745>>>        Procedure WriteIniFile
102748>>>            Integer iCount iSize iRetval
102748>>>            Handle hoDataSource ho
102748>>>            tDataSourceRow[] TheData
102748>>>            tDataSourceRow[] TheData
102749>>>            tDataSourceRow TheRow
102749>>>            tDataSourceRow TheRow
102749>>>            tSQLConnection[] SQLConnectionArray
102749>>>            tSQLConnection[] SQLConnectionArray
102750>>>            tSQLConnection SQLConnection
102750>>>            tSQLConnection SQLConnection
102750>>>            Boolean bIsOneActive bOK
102750>>>            String sPath sIniFileName
102750>>>            
102750>>>            Get psIniFileName of ghoSQLConnectionHandler to sIniFileName
102751>>>            If (sIniFileName = "") Begin
102753>>>                Get vSelectSaveFile ("SQLConnections ini-files (*.ini)|" + CS_SQLIniFileName + "|All Ini Files (*.ini)|*.ini|All Files (*.*)|*.*") "Select a connection ini-file" "" to sIniFileName
102754>>>                If (sIniFileName <> "") Begin
102756>>>                    Get ParseFolderName sIniFileName to sPath
102757>>>                    Set psIniFilePath of ghoSQLConnectionHandler to sPath
102758>>>                    Get ParseFileName sIniFileName to sIniFileName
102759>>>                    Set psIniFileName of ghoSQLConnectionHandler to sIniFileName
102760>>>                End  
102760>>>>
102760>>>                Else Begin
102761>>>                    Procedure_Return
102762>>>                End
102762>>>>
102762>>>            End
102762>>>>
102762>>>            
102762>>>            // 2018-07-14 I don't think this is necessary. In fact it can be quite practical in
102762>>>            // testing to disable all connections, or if e.g. customer's connections has been tested,
102762>>>            // that no longer are available locally.
102762>>>            Get IsOneItemActive to bIsOneActive
102763>>>//            If (bIsOneActive = False) Begin
102763>>>//                Send Info_Box "Sorry, you need to set one connection as active before changes can be saved."
102763>>>//                Procedure_Return
102763>>>//            End
102763>>>            If (bIsOneActive = False) Begin
102765>>>                Get YesNo_Box "Warning, no connection has been set to 'Enabled'. That means that the Database Framework will not read any information from here when initialized.\n\nAre you sure you want to continue to save without any connection Enabled?" to iRetval
102766>>>                If (iRetval = MBR_No) Begin
102768>>>                    Procedure_Return
102769>>>                End
102769>>>>
102769>>>            End
102769>>>>
102769>>>
102769>>>            Move 0 to iCount
102770>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
102771>>>            Get phoDataSource to hoDataSource
102772>>>            Get DataSource of hoDataSource to TheData
102773>>>            Move (SizeOfArray(TheData)) to iSize
102774>>>            Decrement iSize
102775>>>
102775>>>            // Load data from the grid datasource array to SQLConnection array
102775>>>            For iCount from 0 to iSize
102781>>>>
102781>>>                Move TheData[iCount] to TheRow
102782>>>                Get MoveGridRowToSQLConnection TheRow to SQLConnection
102783>>>                Move SQLConnection to SQLConnectionArray[iCount]
102784>>>            Loop
102785>>>>
102785>>>
102785>>>            Get SQLIniFileWriteConnections of ho SQLConnectionArray to bOK
102786>>>            If (bOK = False) Begin
102788>>>                Send ChangeStatusRowText "Sorry, an error occured while saving the file and changes were not saved."
102789>>>                Procedure_Return
102790>>>            End
102790>>>>
102790>>>
102790>>>            // Update the view property with the newly saved values. (Used to check if anything has changed)
102790>>>            Set pTheData to TheData
102791>>>            Send ChangeHeaderText
102792>>>            Send ChangeStatusRowText "Ready! File saved."
102793>>>        End_Procedure
102794>>>
102794>>>        Procedure OnHeaderClick Integer iCol
102797>>>            String sPath sFileName
102797>>>            Handle ho
102797>>>
102797>>>            Forward Send OnHeaderClick iCol
102799>>>
102799>>>            Get vSelect_File ("SQLConnections ini-files (*.ini)|" + CS_SQLIniFileName + "|All Ini Files (*.ini)|*.ini|All Files (*.*)|*.*") "Select a connection ini-file" "" to sFileName
102800>>>            If (sFileName <> "") Begin
102802>>>                Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
102803>>>                Get ParseFolderName sFileName to sPath
102804>>>                Set psIniFilePath of ho to sPath
102805>>>                Get ParseFileName sFileName to sFileName
102806>>>                Set psIniFileName of ho to sFilename
102807>>>                Set pbDFConnId of ho to (sFileName <> CS_SQLIniFileName)
102808>>>                Send LoadData of oSQLConnections_grd
102809>>>            End
102809>>>>
102809>>>        End_Procedure
102810>>>
102810>>>        Procedure OnCreateGridControl 
102813>>>            Handle hoObject  
102813>>>            Integer iToolTipStyle      
102813>>>            Boolean bIsBalloonStyleSupported
102813>>>            
102813>>>            Forward Send OnCreateGridControl
102815>>>    
102815>>>            Get phoToolTipContext to hoObject
102816>>>            If (hoObject <> 0) Begin
102818>>>                Move xtpToolTipStandard to iToolTipStyle    
102819>>>                // Baloon tooltip style requires IE 5.0 or later, so check if installed.
102819>>>                // The ComShowTitleAndDescription also requires IE 5.0.
102819>>>                Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
102820>>>                If (bIsBalloonStyleSupported = True) Begin
102822>>>                    Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
102823>>>                End                                                   
102823>>>>
102823>>>                Set ComStyle             of hoObject to iToolTipStyle
102824>>>                Set ComShowOfficeBorder  of hoObject to True
102825>>>                Set ComShowShadow        of hoObject to True
102826>>>                // Set the max width for a tooltip. 250 just seems to be a good
102826>>>                // compromise. After 250 pixels the text will wrap to the next line automatically.
102826>>>                Set ComMaxTipWidth       of hoObject to 250 // In pixels
102827>>>            End 
102827>>>>
102827>>>        End_Procedure
102828>>>
102828>>>        // These overrides the grid standar behaviour
102828>>>        On_Key kSave_Record Send SaveIniFile
102829>>>        On_Key Key_F5       Send RefreshIniFile
102830>>>    End_Object
102831>>>
102831>>>    // Public access methods: (used by menu/toolbar system)
102831>>>    Procedure ActivateOpenDialog
102834>>>        Send OnHeaderClick of oSQLConnections_grd 1
102835>>>    End_Procedure
102836>>>
102836>>>    Procedure RefreshIniFile
102839>>>        Boolean bChanged
102839>>>        Handle ho
102839>>>        Integer iRetval
102839>>>
102839>>>        Move (oSQLConnections_grd(Self)) to ho
102840>>>        Get Should_Save of ho to bChanged
102841>>>        If (bChanged = True) Begin
102843>>>            Get YesNo_Box "Changes exists! Press 'Yes' to refresh (changes will be lost)." "Refresh Question" to iRetval
102844>>>            If (iRetval <> MBR_Yes) Begin
102846>>>                Procedure_Return
102847>>>            End
102847>>>>
102847>>>        End
102847>>>>
102847>>>        Send ChangeStatusRowText ""
102848>>>        Send LoadData of oSQLConnections_grd
102849>>>    End_Procedure
102850>>>
102850>>>    Procedure AddItem
102853>>>        Boolean bChanged bDFConnId
102853>>>        tSQLConnection SQLConnection
102853>>>        tSQLConnection SQLConnection
102853>>>        tDataSourceRow[] TheData
102853>>>        tDataSourceRow[] TheData
102854>>>        tDataSourceRow   TheRow
102854>>>        tDataSourceRow   TheRow
102854>>>        Handle hoDataSource
102854>>>
102854>>>        Send ChangeStatusRowText ""
102855>>>        Get IsDFConnId to bDFConnId
102856>>>        Move EN_DbTypeMSSQL to SQLConnection.iDbType
102857>>>        Move MSSQLDRV_ID    to SQLConnection.sDriverID
102858>>>        Get phoDataSource of oSQLConnections_grd to hoDataSource
102859>>>        Get DataSource of hoDataSource to TheData
102860>>>        Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) -1 (&SQLConnection) (&bChanged) bDFConnId TheData
102861>>>        If (bChanged = True) Begin
102863>>>            Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
102864>>>            Send AddConnection of oSQLConnections_grd TheRow
102865>>>        End
102865>>>>
102865>>>    End_Procedure
102866>>>
102866>>>    Procedure EditItem
102869>>>        Boolean bEnabled bChanged bDFConnId
102869>>>        tSQLConnection SQLConnection
102869>>>        tSQLConnection SQLConnection
102869>>>        tDataSourceRow TheRow
102869>>>        tDataSourceRow TheRow
102869>>>        tDataSourceRow[] TheData
102869>>>        tDataSourceRow[] TheData
102870>>>        Handle hoDataSource
102870>>>        Integer iCurrentRow
102870>>>
102870>>>        Get CurrentRowData of oSQLConnections_grd to TheRow
102871>>>        Get MoveGridRowToSQLConnection of oSQLConnections_grd TheRow to SQLConnection
102872>>>        Send ChangeStatusRowText ""
102873>>>        Get pbEnabled to bEnabled
102874>>>        Get IsDFConnId to bDFConnId
102875>>>
102875>>>        Get phoDataSource of oSQLConnections_grd to hoDataSource
102876>>>        Get DataSource of hoDataSource to TheData
102877>>>        Get CurrentRow of oSQLConnections_grd to iCurrentRow
102878>>>
102878>>>        Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) iCurrentRow (&SQLConnection) (&bChanged) bDFConnId TheData
102879>>>        If (bChanged = True) Begin
102881>>>            Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
102882>>>            Send UpdateConnection of oSQLConnections_grd TheRow
102883>>>        End
102883>>>>
102883>>>    End_Procedure
102884>>>
102884>>>    Procedure SaveIniFile
102887>>>        Send ChangeStatusRowText ""
102888>>>        Send WriteIniFile of oSQLConnections_grd
102889>>>    End_Procedure
102890>>>
102890>>>    Procedure ClearIniFile
102893>>>        Handle ho
102893>>>        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
102894>>>        Set psIniFilePath of ho to ""
102895>>>        Set psIniFileName of ho to ""
102896>>>        Set pbDFConnId of ho to False
102897>>>        Send ClearData of (oSQLConnections_grd(phoMainView(ghoApplication))) 
102898>>>    End_Procedure   
102899>>>                
102899>>>    Procedure DeleteItem
102902>>>        Send ChangeStatusRowText ""
102903>>>        Send RemoveCurrentConnection of oSQLConnections_grd
102904>>>    End_Procedure
102905>>>
102905>>>    Procedure ExitApplication
102908>>>        Send Exit_Application of ghoApplication
102909>>>    End_Procedure
102910>>>    
102910>>>    // Other messages used by the view:
102910>>>    Function IsDFConnId Returns Boolean
102913>>>        Boolean bDFConnId
102913>>>        Handle ho
102913>>>        String sFileName
102913>>>
102913>>>        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
102914>>>        Get psIniFileName of ho to sFileName
102915>>>        Move (Uppercase(sFileName) = Uppercase(CS_SQLDF19IniFileName)) to bDFConnId
102916>>>        Set pbDFConnId of ho to bDFConnId
102917>>>
102917>>>        Function_Return bDFConnId
102918>>>    End_Function
102919>>>
102919>>>    Procedure OnFileDropped String sFilename Boolean bLast
102922>>>        Boolean bHasChange
102922>>>        Handle ho hoGrid
102922>>>        Integer iRetval
102922>>>        String sPath
102922>>>
102922>>>        Forward Send OnFileDropped sFilename bLast
102924>>>
102924>>>        If (bLast = True) Begin
102926>>>            Move (oSQLConnections_grd(Self)) to hoGrid
102927>>>            Get ParseFolderName sFilename to sPath
102928>>>            Get ParseFileName   sFilename to sFilename
102929>>>            If (Uppercase(sFilename) <> Uppercase(CS_SQLIniFileName) and Uppercase(sFilename) <> Uppercase(CS_SQLDF19IniFileName)) Begin
102931>>>                Send Info_Box ("Sorry, only" * CS_SQLIniFileName * "files can be dropped!")
102932>>>                Procedure_Return
102933>>>            End
102933>>>>
102933>>>            Get Should_Save of hoGrid to bHasChange
102934>>>            If (bHasChange = True) Begin
102936>>>                Get YesNo_Box "Changes exist! Do you still want to load the new file?" to iRetval
102937>>>                If (iRetval <> MBR_Yes) Begin
102939>>>                    Procedure_Return
102940>>>                End
102940>>>>
102940>>>            End
102940>>>>
102940>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
102941>>>            Set psIniFilePath of ho to sPath
102942>>>            Set psIniFileName of ho to sFilename
102943>>>            Send LoadData of oSQLConnections_grd
102944>>>        End
102944>>>>
102944>>>    End_Procedure
102945>>>
102945>>>    // This is only being called when there is no SQLConnections.ini file;
102945>>>    // thus a new active/enabled DFConnection ID needs to be established.
102945>>>    Procedure ConnectionDoesNotExist
102948>>>        tSQLConnection SQLConnection
102948>>>        tSQLConnection SQLConnection
102948>>>        Boolean bChanged bDFConnId bEnabled
102948>>>        Handle ho
102948>>>        tDataSourceRow TheRow
102948>>>        tDataSourceRow TheRow
102948>>>        Handle hoDataSource
102948>>>        tDataSourceRow[] TheData
102948>>>        tDataSourceRow[] TheData
102949>>>
102949>>>        Get IsDFConnId to bDFConnId
102950>>>
102950>>>        Move (oSQLMaintainConnections_dg(Self)) to ho
102951>>>        Move True to bEnabled
102952>>>        Set pbNew to True
102953>>>        Set pbNew of ho to True
102954>>>
102954>>>        Get phoDataSource of oSQLConnections_grd to hoDataSource
102955>>>        Get DataSource of hoDataSource to TheData
102956>>>
102956>>>        Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) -1 (&SQLConnection) (&bChanged) bDFConnId TheData
102957>>>        If (bChanged = True) Begin
102959>>>            // We also need to tell the main connection object that we now have
102959>>>            // created a connection.
102959>>>            Set pSQLConnection            of ghoSQLConnectionHandler to SQLConnection
102960>>>            // And add the data to the grid.
102960>>>            Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
102961>>>            Send AddConnection of oSQLConnections_grd TheRow
102962>>>            // Not new anymore.
102962>>>            Set pbNew to False
102963>>>            Set pbNew of ho to False
102964>>>        End
102964>>>>
102964>>>    End_Procedure
102965>>>
102965>>>    Procedure ChangeStatusRowText String sText
102968>>>        Handle[] hoPanels
102969>>>        Get PaneObjects of (phoStatusBar(ghoCommandBars)) to hoPanels
102970>>>        Set psText of hoPanels[1] to sText
102971>>>    End_Procedure
102972>>>
102972>>>    // On idle handling:
102972>>>    Object oIdle is a cIdleHandler
102974>>>        Procedure OnIdle
102977>>>          Delegate Send OnIdle
102979>>>        End_Procedure
102980>>>    End_Object
102981>>>
102981>>>    Procedure OnIdle
102984>>>        Handle ho
102984>>>
102984>>>        Move (oSQLConnections_grd(Self)) to ho
102985>>>        Send ChangeHeaderText of ho
102986>>>    End_Procedure
102987>>>
102987>>>    Procedure Activating
102990>>>        Handle ho
102990>>>
102990>>>        Set Maximize_Icon to True
102991>>>        Set Minimize_Icon to False
102992>>>        Set Border_Style to Border_Thick
102993>>>        Set View_Mode to Viewmode_Zoom
102994>>>
102994>>>        // Note: The following line is essential for the resizing logic
102994>>>        // to work when starting the program.
102994>>>        Move (Client_Id(ghoCommandBars)) to ho
102995>>>        Set Border_Style of ho to Border_ClientEdge
102996>>>
102996>>>        Set pbEnabled of oIdle to True
102997>>>    End_Procedure
102998>>>
102998>>>    Procedure Deactivating
103001>>>        Set pbEnabled of oIdle to False
103002>>>        Forward Send Deactivating
103004>>>    End_Procedure
103005>>>
103005>>>    Function Verify_Exit_Application Returns Integer
103008>>>        Integer iRetval
103008>>>        Boolean bChanged
103008>>>
103008>>>        Get Should_Save of oSQLConnections_grd to bChanged
103009>>>        If (bChanged = False) Begin
103011>>>            Function_Return False
103012>>>        End
103012>>>>
103012>>>        Else Begin
103013>>>            Get YesNoCancel_Box "Changes exists. Save changes first?" to iRetval
103014>>>            If (iRetval = MBR_Cancel) Begin
103016>>>                Function_Return True
103017>>>            End
103017>>>>
103017>>>            If (iRetval = MBR_Yes) Begin
103019>>>                Send SaveIniFile //KeyAction of oSave_btn
103020>>>                Send Exit_Application
103021>>>            End
103021>>>>
103021>>>            If (iRetval = MBR_No) Begin
103023>>>                Function_Return False
103024>>>            End
103024>>>>
103024>>>        End
103024>>>>
103024>>>        Function_Return True
103025>>>    End_Function
103026>>>
103026>>>    On_Key kDelete_Character Send DeleteItem 
103027>>>    On_Key Key_Ctrl+Key_D    Send DeleteItem 
103028>>>    On_Key Key_Alt+Key_D     Send DeleteItem 
103029>>>    On_Key Key_Ctrl+Key_E    Send EditItem   
103030>>>    On_Key Key_Alt+Key_E     Send EditItem   
103031>>>    On_Key Key_Ctrl+Key_A    Send AddItem    
103032>>>    On_Key Key_Alt+Key_A     Send AddItem    
103033>>>    On_Key Key_F5            Send RefreshIniFile 
103034>>>    On_Key Key_Ctrl+Key_R    Send RefreshIniFile 
103035>>>    On_Key Key_Alt+Key_R     Send RefreshIniFile 
103036>>>    On_Key Key_Ctrl+Key_F5   Send ClearIniFile
103037>>>    On_Key kSave_Record      Send SaveIniFile    
103038>>>    On_Key Key_Ctrl+Key_S    Send SaveIniFile    
103039>>>    On_Key Key_F2            Send SaveIniFile    
103040>>>    On_Key Key_Ctrl+Key_X    Send ExitApplication
103041>>>    On_Key Key_Ctrl+Key_O    Send ActivateOpenDialog
103042>>>    On_Key Key_Alt+Key_O     Send ActivateOpenDialog
103043>>>    On_Key kCancel           Send None
103044>>>    On_Key Key_Ctrl+Key_F4   Send None
103045>>>End_Object
103046>        Use ManageSQLConnections.dg
103046>        Use AddToStudio.dg
Including file: AddToStudio.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\AddToStudio.dg)
103046>>>Use Windows.pkg
103046>>>Use Dfspnfrm.pkg
103046>>>Use cRegistry.pkg
103046>>>Use vWin32fh.pkg
103046>>>
103046>>>Enum_List
103046>>>    Define cx_RegKeyAlreadyExist
103046>>>    Define cx_RegKeyCreated
103046>>>    Define cx_RegkeyFailed
103046>>>    Define cx_RegKeyVDFKeyDoesNotExist
103046>>>    Define CX_InstalledOkVdfUnder16
103046>>>End_Enum_List
103046>>>
103046>>>// Note: The "Visual" part will automatically be removed if
103046>>>// the current DataFlex version is above 17.
103046>>>Define CS_StudioPath        for "Software\Data Access Worldwide\Visual DataFlex Tools\"
103046>>>Define CS_StudioTools       for "\Studio\Tools"
103046>>>Define CS_RegApplication    for "<application>"
103046>>>Define CS_RegWorkspace      for "<workspace>"
103046>>>Define CS_CommandLine       for "CommandLine"
103046>>>Define CS_Name              for "Name"
103046>>>Define CS_Separator         for "Separator"
103046>>>Define CS_Command           for "Command"
103046>>>
103046>>>Object oAddToStudio_dg is a ModalPanel
103048>>>    Set Size to 79 330
103049>>>    Set Label to "Add Program To DataFlex Studio's Tools Menu"
103050>>>    Set piMinSize to 79 211
103051>>>    Set Location to 5 4
103052>>>    Set Locate_Mode to Center_On_Parent
103053>>>
103053>>>    Property String psTag CS_RegApplication
103055>>>
103055>>>    Object oStudioIntegration_grp is a Group
103057>>>        Set Size to 45 299
103058>>>        Set Location to 8 15
103059>>>        Set Label to "DataFlex Studio Integration"
103060>>>
103060>>>        Object oStudioMajorVersion_sf is a SpinForm
103062>>>            Set Size to 12 27
103063>>>            Set Location to 18 168
103064>>>            Set Maximum_Position to 30
103065>>>            Set Minimum_Position to 14
103066>>>            Set Label_Col_Offset to 2
103067>>>            Set Label_Justification_Mode to JMode_Right
103068>>>            Set Label to "Add to Studio's Tools Menu:     Major Version"
103069>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
103070>>>            Set Value to FMAC_VERSION
103071>>>            Set peAnchors to anNone
103072>>>        End_Object
103073>>>
103073>>>        Object oStudioMinorVersion_sf is a SpinForm
103075>>>            Set Size to 12 27
103076>>>            Set Location to 18 254
103077>>>            Set Label_Col_Offset to 2
103078>>>            Set Label to "Minor Version"
103079>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
103080>>>            Set Maximum_Position to 9
103081>>>            Set Minimum_Position to 0
103082>>>            Set Value to FMAC_REVISION
103083>>>            Set Label_Justification_Mode to JMode_Right
103084>>>            Set peAnchors to anNone
103085>>>        End_Object
103086>>>
103086>>>    End_Object
103087>>>
103087>>>    Object oOK_btn is a Button
103089>>>        Set Location to 59 207
103090>>>        Set Label to "Add Now"
103091>>>        Set Status_Help to "Add to DataFlex Studio's Tools menu. The Studio version can be selected with the two spinforms. The program gets added to the Studios Tools menu."
103092>>>        Set peAnchors to anTopRight
103093>>>
103093>>>        Procedure OnClick
103096>>>            Integer iRetval iMajorVersion iMinorVersion
103096>>>            String sText sStudioVersion
103096>>>            Get Value of oStudioMajorVersion_sf to iMajorVersion
103097>>>            Get Value of oStudioMinorVersion_sf to iMinorVersion
103098>>>            Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
103099>>>            Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
103100>>>            Case Begin
103100>>>                Case (iRetval = cx_RegKeyAlreadyExist)
103102>>>                    Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
103103>>>                    Break
103104>>>                Case (iRetval = cx_RegKeyCreated)
103107>>>                    Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
103108>>>                    Break
103109>>>                Case (iRetval = cx_RegkeyFailed)
103112>>>                    Move "Failed. Could not create the registry key for adding the program to the DataFlex Studio's Tools menu." to sText
103113>>>                    Break
103114>>>                Case (iRetval = cx_RegKeyVDFKeyDoesNotExist)
103117>>>                    Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
103118>>>                    Break
103119>>>                Case (iRetval = CX_InstalledOkVdfUnder16)
103122>>>                    Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed for an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
103123>>>                    Break
103124>>>            Case End
103124>>>
103124>>>            Send Info_Box sText
103125>>>        End_Procedure
103126>>>    End_Object
103127>>>
103127>>>    Object oCancel_Btn is a Button
103129>>>        Set Label to C_$Close
103130>>>        Set Location to 59 264
103131>>>        Set peAnchors to anBottomRight
103132>>>
103132>>>        Procedure OnClick
103135>>>            Send Close_Panel
103136>>>        End_Procedure
103137>>>
103137>>>    End_Object
103138>>>
103138>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
103141>>>        Boolean bOk bExists bOpen
103141>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath
103141>>>        Handle hoReg hoArray
103141>>>        Integer i iItems iCreated iRetval
103141>>>
103141>>>        Move False to bOk
103142>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
103143>>>        If (sStudioVersion > "17.1") Begin
103145>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
103146>>>        End
103146>>>>
103146>>>
103146>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
103147>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
103148>>>        Get vFolderFormat sProgramPath to sProgramPath
103149>>>        Get psProduct     of (phoWorkspace(ghoApplication)) to sProduct
103150>>>        Get Module_Name to sProgram
103151>>>        Get Create (RefClass(cRegistry)) to hoReg
103152>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
103153>>>
103153>>>        // First check if the VDF version is installed
103153>>>        Get KeyExists of hoReg sStudioPath to bExists
103154>>>        If (bExists = False) Begin
103156>>>            Send Destroy of hoReg
103157>>>            Function_Return cx_RegKeyVDFKeyDoesNotExist
103158>>>        End
103158>>>>
103158>>>
103158>>>        // Then check if any tools have been installed in the Tools Menu.
103158>>>        // If no tools created yet, create the Tools registry key.
103158>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
103159>>>        Get KeyExists of hoReg sStudioPath to bExists
103160>>>        If (bExists = False) Begin
103162>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
103163>>>            Get CreateKey of hoReg sStudioPath to iCreated
103164>>>            If (iCreated <> 0) Begin
103166>>>                Move cx_RegkeyFailed to iRetval
103167>>>            End
103167>>>>
103167>>>            Else Begin
103168>>>                Move True to bExists
103169>>>            End
103169>>>>
103169>>>        End
103169>>>>
103169>>>
103169>>>        If (bExists = True) Begin
103171>>>            Get OpenKey of hoReg sStudioPath to bOk
103172>>>            If (bOk = True) Begin
103174>>>                Get Create (RefClass(Array)) to hoArray
103175>>>                Get GetSubkeys of hoReg hoArray to iItems
103176>>>                Decrement iItems
103177>>>                Move False to bExists
103178>>>                Set pfAccessRights of hoReg to KEY_READ
103179>>>                // Check if the key already exists:
103179>>>                For i from 0 to iItems
103185>>>>
103185>>>                    Get Value of hoArray i to sKey
103186>>>                    Move (sStudioPath + "\" + sKey) to sKey
103187>>>                    Get OpenKey of hoReg sKey to bOpen
103188>>>                    If (bOpen = True) Begin
103190>>>                        Get ReadString of hoReg CS_Name to sValue
103191>>>                        If (sValue = sProduct) Begin
103193>>>                            Move True to bExists
103194>>>                        End
103194>>>>
103194>>>                    End
103194>>>>
103194>>>                Loop
103195>>>>
103195>>>                Send Destroy of hoArray
103196>>>                If (bExists = False) Begin
103198>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
103199>>>                    // We need to create the next key number:
103199>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
103199>>>                    Increment iItems
103200>>>                    Increment iItems
103201>>>                    Get CreateKey of hoReg (sStudioPath + "\" + String(iItems)) to iCreated
103202>>>                    If (iCreated = 0) Begin
103204>>>                        Send WriteString of hoReg CS_Name sProduct
103205>>>                        // From DataFlex 16 and up the params for the Studio's Tools menu changed slightly:
103205>>>                        If (sStudioVersion >= "16.0") Begin
103207>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
103208>>>                            Send WriteString of hoReg CS_CommandLine (psTag(Self))
103209>>>                        End
103209>>>>
103209>>>                        Else Begin
103210>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * psTag(Self))
103211>>>                            Move CX_InstalledOkVdfUnder16 to iRetval
103212>>>                        End
103212>>>>
103212>>>                        Send WriteDword  of hoReg CS_Separator 1
103213>>>                        Move cx_RegKeyCreated to iRetval
103214>>>                    End
103214>>>>
103214>>>                    Else Begin
103215>>>                        Move cx_RegkeyFailed to iRetval
103216>>>                    End
103216>>>>
103216>>>                End
103216>>>>
103216>>>                Else Begin
103217>>>                    Move cx_RegKeyAlreadyExist to iRetval
103218>>>                End
103218>>>>
103218>>>                Send CloseKey of hoReg
103219>>>            End
103219>>>>
103219>>>        End
103219>>>>
103219>>>
103219>>>        Send Destroy of hoReg
103220>>>        Function_Return iRetval
103221>>>    End_Function
103222>>>
103222>>>    Procedure Page Integer iPageObject
103225>>>        Forward Send Page iPageObject
103227>>>        Set Icon to "ActionAddStudio1.ico"
103228>>>    End_Procedure
103229>>>
103229>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
103230>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
103231>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
103232>>>End_Object
103233>        Use CreateDatabase.dg
103233>
103233>        Procedure Activate_About
103236>            Send DoAbout "" "" ("Copyright 2016-2020" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "SQLConnections.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
103237>        End_Procedure
103238>
103238>    End_Object
103239>
103239>    Procedure ShowProgramHelp
103242>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
103243>    End_Procedure
103244>
103244>    On_Key Key_F1 Send ShowProgramHelp
103245>End_Object
103246>
103246>// Check if a SQLConnections.ini file exists;
103246>// else the user needs to setup a Connection ID and login info & save the new connection file.
103246>Procedure CheckIfConnectionExists
103248>    Boolean bIniFileExists
103248>    Get pbIniFileExists of ghoApplication to bIniFileExists
103249>    If (bIniFileExists = False) Begin
103251>        Send ConnectionDoesNotExist of (oSQLMaintainConnection(Client_Id(phoMainPanel(ghoApplication))))
103252>    End
103252>End_Procedure
103253>Send CheckIfConnectionExists
103254>
103254>Start_UI
103255>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 53323
Total Resources: 6
Total Commands : 103254
Total Windows  : 0
Total Pages    : 0
Static Data    : 813441
Message area   : 616830
Total Blocks   : 36375
