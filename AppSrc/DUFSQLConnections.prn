Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFSQLConnections.src
Memory Available: 2147483646
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files\DataFlex 23.0\Pkg\dfallent.pkd)
73414>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJStandardCommandBarSystem.pkg)
73414>>>// these are all the packages used in a standard MDI menubar/toolbar system
73414>>>
73414>>>Use cCJCommandBarSystem.pkg
73414>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJStandardMenuItemClasses.pkg)
73414>>>>>Use Dfpanel.pkg
73414>>>>>Use cCJCommandBarSystem.pkg
73414>>>>>Use LanguageText.pkg
73414>>>>>
73414>>>>>
73414>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73415>>>>>    
73415>>>>>    Procedure Construct_Object
73417>>>>>        Forward Send Construct_Object
73419>>>>>        Set psCaption   to C_$CaptionUndo
73420>>>>>        Set psToolTip to C_$ToolTipUndo
73421>>>>>        Set psDescription to C_$DescUndo
73422>>>>>        Set psImage to "ActionUndo.ico"
73423>>>>>        Set pbActiveUpdate to True
73424>>>>>        Set psCategory to C_$CategoryEdit
73425>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73426>>>>>    End_Procedure
73427>>>>>    
73427>>>>>    Procedure OnExecute Variant vCommandBarControl
73429>>>>>        Send Undo of (focus(Self))
73430>>>>>    End_Procedure
73431>>>>>    
73431>>>>>    Function IsEnabled Returns Boolean
73433>>>>>        Boolean bEnabled
73433>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73434>>>>>        Function_Return bEnabled
73435>>>>>    End_Function
73436>>>>>    
73436>>>>>End_Class
73437>>>>>
73437>>>>>
73437>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73438>>>>>    
73438>>>>>    Procedure Construct_Object
73440>>>>>        Forward Send Construct_Object
73442>>>>>        Set psCaption   to C_$CaptionDelete
73443>>>>>        Set psToolTip to C_$ToolTipDelete
73444>>>>>        Set psDescription to C_$DescDelete
73445>>>>>        Set psImage to "actionDelete.ico"
73446>>>>>        Set psShortcut to C_$Key_Delete
73447>>>>>        Set pbActiveUpdate to True
73448>>>>>        Set psCategory to C_$CategoryEdit
73449>>>>>    End_Procedure
73450>>>>>    
73450>>>>>    
73450>>>>>    Procedure OnExecute Variant vCommandBarControl
73452>>>>>        Send Delete of (focus(Self))
73453>>>>>    End_Procedure
73454>>>>>    
73454>>>>>    Function IsEnabled Returns Boolean
73456>>>>>        Boolean bEnabled
73456>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73457>>>>>        Function_Return bEnabled
73458>>>>>    End_Function
73459>>>>>    
73459>>>>>End_Class
73460>>>>>
73460>>>>>
73460>>>>>Class cCJCutMenuItem is a cCJMenuItem
73461>>>>>    
73461>>>>>    Procedure Construct_Object
73463>>>>>        Forward Send Construct_Object
73465>>>>>        Set psCaption   to C_$CaptionCut
73466>>>>>        Set psToolTip to C_$TooltipCut
73467>>>>>        Set psDescription to C_$DescCut
73468>>>>>        Set psImage to "actionCut.ico"
73469>>>>>        Set psShortcut to C_$Key_Ctrl_X
73470>>>>>        Set pbActiveUpdate to True
73471>>>>>        Set psCategory to C_$CategoryEdit
73472>>>>>    End_Procedure
73473>>>>>    
73473>>>>>    
73473>>>>>    Procedure OnExecute Variant vCommandBarControl
73475>>>>>        Send Cut of (focus(Self))
73476>>>>>    End_Procedure
73477>>>>>    
73477>>>>>    Function IsEnabled Returns Boolean
73479>>>>>        Boolean bEnabled
73479>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73480>>>>>        Function_Return bEnabled
73481>>>>>    End_Function
73482>>>>>    
73482>>>>>End_Class
73483>>>>>
73483>>>>>
73483>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73484>>>>>    
73484>>>>>    Procedure Construct_Object
73486>>>>>        Forward Send Construct_Object
73488>>>>>        Set psCaption   to C_$CaptionCopy
73489>>>>>        Set psToolTip to C_$ToolTipCopy
73490>>>>>        Set psDescription to C_$DescCopy
73491>>>>>        Set psImage to "actionCopy.ico"
73492>>>>>        Set psShortcut to C_$Key_Ctrl_C
73493>>>>>        Set pbActiveUpdate to True
73494>>>>>        Set psCategory to C_$CategoryEdit
73495>>>>>    End_Procedure
73496>>>>>    
73496>>>>>    
73496>>>>>    Procedure OnExecute Variant vCommandBarControl
73498>>>>>        Send Copy of (focus(Self))
73499>>>>>    End_Procedure
73500>>>>>    
73500>>>>>    Function IsEnabled Returns Boolean
73502>>>>>        Boolean bEnabled
73502>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73503>>>>>        Function_Return bEnabled
73504>>>>>    End_Function
73505>>>>>    
73505>>>>>End_Class
73506>>>>>
73506>>>>>
73506>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73507>>>>>    
73507>>>>>    Procedure Construct_Object
73509>>>>>        Forward Send Construct_Object
73511>>>>>        Set psCaption   to C_$CaptionPaste
73512>>>>>        Set psToolTip to C_$ToolTipPaste
73513>>>>>        Set psDescription to C_$DescPaste
73514>>>>>        Set psImage to "actionPaste.ico"
73515>>>>>        Set pbActiveUpdate to True
73516>>>>>        Set psShortcut to C_$Key_Ctrl_V
73517>>>>>        Set psCategory to C_$CategoryEdit
73518>>>>>    End_Procedure
73519>>>>>    
73519>>>>>    
73519>>>>>    Procedure OnExecute Variant vCommandBarControl
73521>>>>>        Send Paste of (focus(Self))
73522>>>>>    End_Procedure
73523>>>>>    
73523>>>>>    Function IsEnabled Returns Boolean
73525>>>>>        Boolean bEnabled
73525>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73526>>>>>        Function_Return bEnabled
73527>>>>>    End_Function
73528>>>>>    
73528>>>>>End_Class
73529>>>>>
73529>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73530>>>>>    
73530>>>>>    Procedure Construct_Object
73532>>>>>        Forward Send Construct_Object
73534>>>>>        Set psCaption   to C_$CaptionSelectAll
73535>>>>>        Set psToolTip to C_$ToolTipSelectAll
73536>>>>>        Set psDescription to C_$DescSelectAll
73537>>>>>        Set pbActiveUpdate to True
73538>>>>>        Set psShortcut to C_$Key_Ctrl_A
73539>>>>>        Set psCategory to C_$CategoryEdit
73540>>>>>    End_Procedure
73541>>>>>    
73541>>>>>    
73541>>>>>    Procedure OnExecute Variant vCommandBarControl
73543>>>>>        Send Select_All of (focus(Self))
73544>>>>>    End_Procedure
73545>>>>>    
73545>>>>>    Function IsEnabled Returns Boolean
73547>>>>>        Boolean bEnabled
73547>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73548>>>>>        Function_Return bEnabled
73549>>>>>    End_Function
73550>>>>>    
73550>>>>>End_Class
73551>>>>>
73551>>>>>
73551>>>>>Class cCJExitMenuItem is a cCJMenuItem
73552>>>>>    
73552>>>>>    Procedure Construct_Object
73554>>>>>        Forward Send Construct_Object
73556>>>>>        Set psCaption to C_$CaptionExit
73557>>>>>        Set psToolTip to C_$ToolTipExit
73558>>>>>        Set psDescription to C_$ToolTipExit
73559>>>>>        Set psShortcut to C_$Key_Alt_F4
73560>>>>>        Set psCategory to C_$CategoryFile
73561>>>>>    End_Procedure
73562>>>>>    
73562>>>>>    Procedure OnExecute Variant vCommandBarControl
73564>>>>>        Send Exit_Application of Desktop
73565>>>>>    End_Procedure
73566>>>>>    
73566>>>>>End_Class
73567>>>>>
73567>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73568>>>>>    
73568>>>>>    Procedure Construct_Object
73570>>>>>        Forward Send Construct_Object
73572>>>>>        Set psCaption to C_$CaptionHelp
73573>>>>>        Set psDescription to C_$ToolTipHelp
73574>>>>>        Set psToolTip to C_$DescHelp
73575>>>>>        Set psImage to "ActionHelp.ico"
73576>>>>>        Set psShortcut to "F1"
73577>>>>>        Set psCategory to C_$CategoryHelp
73578>>>>>    End_Procedure
73579>>>>>    
73579>>>>>    Procedure OnExecute Variant vCommandBarControl
73581>>>>>        Send Help of (Focus(Self))
73582>>>>>    End_Procedure
73583>>>>>    
73583>>>>>End_Class
73584>>>>>
73584>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73585>>>>>    
73585>>>>>    Procedure Construct_Object
73587>>>>>        Forward Send Construct_Object
73589>>>>>        Set psCaption to C_$CaptionAddStatusbar
73590>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73591>>>>>        Set psDescription to  C_$DescAddStatusbar
73592>>>>>        Set psCategory to C_$CategoryWindow
73593>>>>>    End_Procedure
73594>>>>>    
73594>>>>>    Procedure OnExecute Variant vCommandBarControl
73596>>>>>        Handle hoCommandBars hoClientArea
73596>>>>>        Get CommandBarSystemObject to hoCommandBars
73597>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73598>>>>>        If hoClientArea Begin
73600>>>>>            // the clientarea's parent panel has message
73600>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73601>>>>>        End
73601>>>>>>
73601>>>>>    End_Procedure
73602>>>>>    
73602>>>>>    Function IsChecked Returns Boolean
73604>>>>>        Boolean bOn
73604>>>>>        Handle hoCommandBars hoClientArea
73604>>>>>        Get CommandBarSystemObject to hoCommandBars
73605>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73606>>>>>        If hoClientArea Begin
73608>>>>>            // the clientarea's parent panel has message
73608>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73609>>>>>        End
73609>>>>>>
73609>>>>>        Function_Return bOn
73610>>>>>    End_Function
73611>>>>>End_Class
73612>>>>>
73612>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73613>>>>>    
73613>>>>>    Procedure Construct_Object
73615>>>>>        Forward Send Construct_Object
73617>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73618>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73619>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73620>>>>>        Set psCategory to C_$CategoryWindow
73621>>>>>    End_Procedure
73622>>>>>    
73622>>>>>    Procedure OnExecute Variant vCommandBarControl
73624>>>>>        Handle hoCommandBars hoClientArea
73624>>>>>        Get CommandBarSystemObject to hoCommandBars
73625>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73626>>>>>        If hoClientArea Begin
73628>>>>>            // the clientarea's parent panel has message
73628>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73629>>>>>        End
73629>>>>>>
73629>>>>>    End_Procedure
73630>>>>>    
73630>>>>>    Function IsChecked Returns Boolean
73632>>>>>        Boolean bOn
73632>>>>>        Handle hoCommandBars hoClientArea
73632>>>>>        Get CommandBarSystemObject to hoCommandBars
73633>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73634>>>>>        If hoClientArea Begin
73636>>>>>            // the clientarea's parent panel has message
73636>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73637>>>>>        End
73637>>>>>>
73637>>>>>        Function_Return bOn
73638>>>>>    End_Function
73639>>>>>End_Class
73640>>>>>
73640>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73641>>>>>    
73641>>>>>    Procedure Construct_Object
73643>>>>>        Forward Send Construct_Object
73645>>>>>        Set psCaption to C_$CaptionRestoreMenus
73646>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73647>>>>>        Set psDescription to C_$DescRestoreMenus
73648>>>>>        Set psCategory to C_$CategoryWindow
73649>>>>>    End_Procedure
73650>>>>>    
73650>>>>>    Procedure OnExecute Variant vCommandBarControl
73652>>>>>        Handle hoCommandBars
73652>>>>>        Get CommandBarSystemObject to hoCommandBars
73653>>>>>        Send RestoreLayout of hoCommandBars
73654>>>>>    End_Procedure
73655>>>>>    
73655>>>>>End_Class
73656>>>>>
73656>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73657>>>>>    
73657>>>>>    Procedure Construct_Object
73659>>>>>        Forward Send Construct_Object
73661>>>>>        Set psCaption to C_$CaptionCascade
73662>>>>>        Set psToolTip to C_$ToolTipCascade
73663>>>>>        Set psDescription to  C_$DescCascade
73664>>>>>        Set psImage to "ActionCascade.ico"
73665>>>>>        Set psCategory to C_$CategoryWindow
73666>>>>>    End_Procedure
73667>>>>>    
73667>>>>>    Procedure OnExecute Variant vCommandBarControl
73669>>>>>        Handle hoCommandBars hoClientArea
73669>>>>>        Get CommandBarSystemObject to hoCommandBars
73670>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73671>>>>>        If hoClientArea Begin
73673>>>>>            Send Cascade_Windows of hoClientArea
73674>>>>>        End
73674>>>>>>
73674>>>>>    End_Procedure
73675>>>>>End_Class
73676>>>>>
73676>>>>>Class cCJTileHorizontally is a cCJMenuItem
73677>>>>>    
73677>>>>>    Procedure Construct_Object
73679>>>>>        Forward Send Construct_Object
73681>>>>>        Set psCaption to C_$CaptionTileHorizontally
73682>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73683>>>>>        Set psDescription to  C_$DescTileHorizontally
73684>>>>>        Set psImage to "ActionTileHorizontally.ico"
73685>>>>>        Set psCategory to C_$CategoryWindow
73686>>>>>    End_Procedure
73687>>>>>    
73687>>>>>    Procedure OnExecute Variant vCommandBarControl
73689>>>>>        Handle hoCommandBars hoClientArea
73689>>>>>        Get CommandBarSystemObject to hoCommandBars
73690>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73691>>>>>        If hoClientArea Begin
73693>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73694>>>>>        End
73694>>>>>>
73694>>>>>    End_Procedure
73695>>>>>End_Class
73696>>>>>
73696>>>>>Class cCJTileVertically is a cCJMenuItem
73697>>>>>    
73697>>>>>    Procedure Construct_Object
73699>>>>>        Forward Send Construct_Object
73701>>>>>        Set psCaption to C_$CaptionTileVertically
73702>>>>>        Set psToolTip to C_$ToolTipTileVertically
73703>>>>>        Set psDescription to  C_$DescTileVertically
73704>>>>>        Set psImage to "ActionTileVertically.ico"
73705>>>>>        Set psCategory to C_$CategoryWindow
73706>>>>>    End_Procedure
73707>>>>>    
73707>>>>>    Procedure OnExecute Variant vCommandBarControl
73709>>>>>        Handle hoCommandBars hoClientArea
73709>>>>>        Get CommandBarSystemObject to hoCommandBars
73710>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73711>>>>>        If hoClientArea Begin
73713>>>>>            Send Tile_Windows_Vertical of hoClientArea
73714>>>>>        End
73714>>>>>>
73714>>>>>    End_Procedure
73715>>>>>End_Class
73716>>>>>
73716>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73717>>>>>    
73717>>>>>    Procedure Construct_Object
73719>>>>>        Forward Send Construct_Object
73721>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73722>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73723>>>>>        Set psDescription to  C_$DescMinimizeWindows
73724>>>>>        Set psCategory to C_$CategoryWindow
73725>>>>>    End_Procedure
73726>>>>>    
73726>>>>>    Procedure OnExecute Variant vCommandBarControl
73728>>>>>        Handle hoCommandBars hoClientArea
73728>>>>>        Get CommandBarSystemObject to hoCommandBars
73729>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73730>>>>>        If hoClientArea Begin
73732>>>>>            // the clientarea's parent panel has message
73732>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73733>>>>>        End
73733>>>>>>
73733>>>>>    End_Procedure
73734>>>>>End_Class
73735>>>>>
73735>>>>>
73735>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73736>>>>>    
73736>>>>>    Procedure Construct_Object
73738>>>>>        Forward Send Construct_Object
73740>>>>>        Set psCaption to C_$CaptionRestoreWindows
73741>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73742>>>>>        Set psDescription to  C_$DescRestoreWindows
73743>>>>>        Set psCategory to C_$CategoryWindow
73744>>>>>    End_Procedure
73745>>>>>    
73745>>>>>    Procedure OnExecute Variant vCommandBarControl
73747>>>>>        Handle hoCommandBars hoClientArea
73747>>>>>        Get CommandBarSystemObject to hoCommandBars
73748>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73749>>>>>        If hoClientArea Begin
73751>>>>>            // the clientarea's parent panel has message
73751>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73752>>>>>        End
73752>>>>>>
73752>>>>>    End_Procedure
73753>>>>>End_Class
73754>>>>>
73754>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73755>>>>>    
73755>>>>>    Procedure Construct_Object
73757>>>>>        Forward Send Construct_Object
73759>>>>>        Set psCaption to C_$CaptionArrangeIcons
73760>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73761>>>>>        Set psDescription to  C_$DescArrangeIcons
73762>>>>>        Set psCategory to C_$CategoryWindow
73763>>>>>    End_Procedure
73764>>>>>    
73764>>>>>    Procedure OnExecute Variant vCommandBarControl
73766>>>>>        Handle hoCommandBars hoClientArea
73766>>>>>        Get CommandBarSystemObject to hoCommandBars
73767>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73768>>>>>        If hoClientArea Begin
73770>>>>>            Send Arrange_Icons of hoClientArea
73771>>>>>        End
73771>>>>>>
73771>>>>>    End_Procedure
73772>>>>>    
73772>>>>>End_Class
73773>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJAboutMenuItem.pkg)
73773>>>>>Use cCJCommandBarSystem.pkg
73773>>>>>Use LanguageText.pkg
73773>>>>>
73773>>>>>// It is expected that if you use this class that you provide an about object that is
73773>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73773>>>>>// because you may wish to create your own custom about package.
73773>>>>>
73773>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73774>>>>>
73774>>>>>    Procedure Construct_Object
73776>>>>>        Forward Send Construct_Object
73778>>>>>        Set psCaption to C_$CaptionAbout
73779>>>>>        Set psDescription to C_$ToolTipAbout
73780>>>>>        Set psToolTip to C_$DescAbout
73781>>>>>        Set psImage to "ActionAbout.ico"
73782>>>>>        Set psCategory to C_$CategoryHelp
73783>>>>>    End_Procedure
73784>>>>>    
73784>>>>>    Procedure OnExecute Variant vCommandBarControl
73786>>>>>        Handle hoCommandBars hoClientArea
73786>>>>>        Get CommandBarSystemObject to hoCommandBars
73787>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73788>>>>>        If hoClientArea Begin
73790>>>>>            Send Activate_About of hoClientArea
73791>>>>>        End
73791>>>>>>
73791>>>>>    End_Procedure
73792>>>>>
73792>>>>>End_Class
73793>>>>>
73793>>>>>
73793>>>Use cCJDeoMenuItemClasses.pkg
73793>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJMDIWindowsMenuItem.pkg)
73793>>>>>Use cCJCommandBarSystem.pkg
73793>>>>>
73793>>>>>Register_Function Client_ID Returns Integer
73793>>>>>
73793>>>>>// only used by cCJMDIWIndowsMenuItem
73793>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73794>>>>>    
73794>>>>>    Procedure Construct_Object
73796>>>>>        Forward Send Construct_Object
73798>>>>>        Property Handle phWindow 0 // object id of view
73799>>>>>        Set pbControlFlagNoMovable to True
73800>>>>>        Set pbActiveUpdate to True
73801>>>>>    End_Procedure
73802>>>>>    
73802>>>>>    Procedure OnExecute Variant vCommandBarControl
73804>>>>>        Handle hWindow
73804>>>>>        Get phWindow to hWindow
73805>>>>>        Send Activate_View of hWindow
73806>>>>>    End_Procedure
73807>>>>>    
73807>>>>>End_Class
73808>>>>>
73808>>>>>
73808>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73809>>>>>    
73809>>>>>    Procedure Construct_Object
73811>>>>>        Forward Send Construct_Object
73813>>>>>        Property Handle[] phArrayOfWindows
73814>>>>>        Set peControlType to xtpControlPopup
73815>>>>>        Set psCategory to C_$CategoryWindow
73816>>>>>    End_Procedure
73817>>>>>    
73817>>>>>    // This adds MDI windows to the existing menu items.
73817>>>>>    // This removes any existing windows menus and always adds a new set to the end
73817>>>>>    
73817>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73819>>>>>        Handle  hClientArea hView
73819>>>>>        String  sLabel
73819>>>>>        Integer i iWindows
73819>>>>>        Handle[] hArrayOfWindows
73820>>>>>        Variant vItem
73820>>>>>        
73820>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73820>>>>>        // also assume that destroying an action removes all menu instances of that action
73820>>>>>        Get phArrayOfWindows to hArrayOfWindows
73821>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73822>>>>>        For i from 0 to (iWindows-1)
73828>>>>>>
73828>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73829>>>>>        Loop
73830>>>>>>
73830>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73831>>>>>        
73831>>>>>        // Add all views to this menu. Create the action and add the item
73831>>>>>        Move 0 to i
73832>>>>>        Get Client_Id to hClientArea // object id of client area
73833>>>>>        If (hClientArea > 0) Begin
73835>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73836>>>>>            While (hView <> 0)
73840>>>>>                If (Active_State(hView)) Begin
73842>>>>>                    // create the action
73842>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73843>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73844>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73845>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73846>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73848>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73849>>>>>                    End
73849>>>>>>
73849>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73850>>>>>                    If (i=0) Begin
73852>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73853>>>>>                    End
73853>>>>>>
73853>>>>>                    // Create a menu item for this action
73853>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73854>>>>>                    Increment i
73855>>>>>                End
73855>>>>>>
73855>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73856>>>>>            Loop
73857>>>>>>
73857>>>>>        End
73857>>>>>>
73857>>>>>        
73857>>>>>        Set phArrayOfWindows to hArrayOfWindows
73858>>>>>        
73858>>>>>    End_Procedure
73859>>>>>    
73859>>>>>End_Class
73860>Use vWin32fh.pkg
Including file: vwin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fh.pkg)
73860>>>// This code is part of VDF GUIdance
73860>>>// Visit us @ http://www.vdf-guidance.com
73860>>>// e-Mail us @ info@vdf-guidance.com
73860>>>// VDF GUIdance is a mutual project of
73860>>>// Frank Vandervelpen - Vandervelpen Systems and
73860>>>// Wil van Antwerpen  - Antwise Solutions
73860>>>// All software source code should be used <<AS IS>> without any warranty.
73860>>>//
73860>>>//
73860>>>// *** Windows 32bit file handling wrapper class ***
73860>>>//
73860>>>
73860>>>
73860>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
73860>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\cvFileDialogs.pkg)
73860>>>>>//***************************************************************************
73860>>>>>//*
73860>>>>>//* Class:        cvSaveAsDialog
73860>>>>>//* Package Name: cvFileDialogs.pkg
73860>>>>>//*
73860>>>>>//***************************************************************************
73860>>>>>
73860>>>>>Use File_dlg.pkg
73860>>>>>
73860>>>>>// *WvA: 13-01-1999 Created
73860>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
73860>>>>>// This function opens the Windows standard file open dialog and returns the selected
73860>>>>>// file_name.
73860>>>>>Class cvSelectFile_Dialog is an OpenDialog
73861>>>>>
73861>>>>>    Procedure Construct_Object Integer iImage_Id
73863>>>>>        Forward Send Construct_Object iImage_Id
73865>>>>>        Set HideReadOnly_State to True
73866>>>>>    End_Procedure
73867>>>>>
73867>>>>>    Function SelectedFileName Returns String
73869>>>>>        String sFileName
73869>>>>>        Move "" to sFileName
73870>>>>>        If (Show_Dialog(Self)) Begin
73872>>>>>            Move (RTrim(File_Name(Self))) to sFileName
73873>>>>>        End
73873>>>>>>
73873>>>>>        Function_Return sFileName
73874>>>>>    End_Function
73875>>>>>End_Class
73876>>>>>
73876>>>>>// *WvA: 13-01-1999 Created
73876>>>>>// This function opens the Windows standard file open dialog and returns the selected
73876>>>>>// file_name. Returns '' if the user didn't make a selection.
73876>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
73876>>>>>//                   file-open dialog
73876>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
73878>>>>>    String sSelectedFile
73878>>>>>    Integer hoOpenFileDialog
73878>>>>>
73878>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
73880>>>>>
73880>>>>>        Set Dialog_Caption    to sCaptionText
73881>>>>>        Set Filter_String     to sSupportedFileTypes
73882>>>>>        Set Initial_Folder    to sInitialFolder
73883>>>>>
73883>>>>>        Move Self       to hoOpenFileDialog
73884>>>>>    End_Object
73885>>>>>
73885>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
73886>>>>>    Send Destroy_Object to hoOpenFileDialog
73887>>>>>    Function_Return sSelectedFile
73888>>>>>End_Function
73889>>>>>
73889>>>>>Class cvSaveAsDialog is a SaveAsDialog
73890>>>>>
73890>>>>>    Procedure Construct_Object
73892>>>>>        Forward Send Construct_Object
73894>>>>>        Set HideReadOnly_State to True
73895>>>>>    End_Procedure
73896>>>>>
73896>>>>>    Function SelectedFileName Returns String
73898>>>>>        String sFileName
73898>>>>>        Move "" to sFileName
73899>>>>>        If (Show_Dialog(Self)) Begin
73901>>>>>            Move (RTrim(File_Name(Self))) to sFileName
73902>>>>>        End
73902>>>>>>
73902>>>>>        Function_Return sFileName
73903>>>>>    End_Function
73904>>>>>
73904>>>>>End_Class
73905>>>>>
73905>>>>>// Added optional default filename as suggested by Nils
73905>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
73907>>>>>    String sSelectedFile
73907>>>>>    Integer hoDialog
73907>>>>>
73907>>>>>    Move "" to sSelectedFile
73908>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
73909>>>>>    If (hoDialog) Begin
73911>>>>>    //Set NoChangeDir_State Of hoDialog To True
73911>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
73912>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
73913>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
73914>>>>>        If (Num_Arguments = 4) Begin
73916>>>>>            Set File_Title        of hoDialog to sDefaultFileName
73917>>>>>        End
73917>>>>>>
73917>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
73918>>>>>        Send Destroy of hoDialog
73919>>>>>    End
73919>>>>>>
73919>>>>>    Function_Return sSelectedFile
73920>>>>>End_Function
73921>>>Use Seq_chnl.pkg
73921>>>
73921>>>Use windows.pkg
73921>>>Use Dll.pkg
73921>>>
73921>>>Use vWin32fhW.pkg     // WinAPI Unicode version
Including file: vwin32fhW.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fhW.pkg)
73921>>>>>// This code is part of VDF GUIdance
73921>>>>>// Visit us @ http://www.vdf-guidance.com
73921>>>>>// e-Mail us @ info@vdf-guidance.com
73921>>>>>// VDF GUIdance is a mutual project of
73921>>>>>// Frank Vandervelpen - Vandervelpen Systems and
73921>>>>>// Wil van Antwerpen  - Antwise Solutions
73921>>>>>// All software source code should be used <<AS IS>> without any warranty.
73921>>>>>//
73921>>>>>//
73921>>>>>// *** Windows 32bit file handling wrapper class ***
73921>>>>>// Unicode variant
73921>>>>>
73921>>>>>Use vWin32fhW.h       // Header file with WinAPI Unicode declarations
Including file: vwin32fhW.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fhW.h)
73921>>>>>>>//TH-Header
73921>>>>>>>//*****************************************************************************************
73921>>>>>>>// Copyright (c)  2004 KURANT Project
73921>>>>>>>// All rights reserved.
73921>>>>>>>//
73921>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
73921>>>>>>>// $ProjectName : Windows 32 bits file handling
73921>>>>>>>// $Authors     : Wil van Antwerpen
73921>>>>>>>// $Created     : 19.02.2004  19:25
73921>>>>>>>// $Type        : BSD (as in do with it whatever you like)
73921>>>>>>>//
73921>>>>>>>// Contents:
73921>>>>>>>//  This file contains the Windows API external function call definitions and
73921>>>>>>>//  constants as they are used in the vWin32fh package.
73921>>>>>>>//*****************************************************************************************
73921>>>>>>>//TH-RevisionStart
73921>>>>>>>//TH-RevisionEnd
73921>>>>>>>
73921>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
73921>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
73921>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
73921>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
73921>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
73921>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
73921>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
73921>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
73921>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
73921>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
73921>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
73921>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
73921>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
73921>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
73921>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
73921>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
73921>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
73921>>>>>>>
73921>>>>>>>
73921>>>>>>>Define vMax_Path     For |CI260
73921>>>>>>>Define vMinChar      For |CI$80
73921>>>>>>>Define vMaxChar      For |CI$7F
73921>>>>>>>Define vMinShort     For |CI$8000
73921>>>>>>>Define vMaxShort     For |CI$7FFF
73921>>>>>>>Define vMinLong      For |CI$80000000
73921>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
73921>>>>>>>Define vMaxByte      For |CI$FF
73921>>>>>>>Define vMaxWord      For |CI$FFFF
73921>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
73921>>>>>>>
73921>>>>>>>
73921>>>>>>>
73921>>>>>>>// For FindFirstFile
73921>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
73921>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
73921>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
73921>>>>>>>
73921>>>>>>>// The defines below can be used to find out what kind of error has occurred if
73921>>>>>>>// the API-call ShellExecute is used.
73921>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
73921>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
73921>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
73921>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
73921>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
73921>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
73921>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
73921>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
73921>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
73921>>>>>>>Define vSE_ERR_FNF             For |CI0002
73921>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
73921>>>>>>>Define vSE_ERR_OOM             For |CI0008
73921>>>>>>>Define vSE_ERR_PNF             For |CI0003
73921>>>>>>>Define vSE_ERR_SHARE           For |CI0026
73921>>>>>>>
73921>>>>>>>
73921>>>>>>>// C-Structure
73921>>>>>>>//typedef struct _browseinfo {
73921>>>>>>>//    HWND hwndOwner;
73921>>>>>>>//    LPCITEMIDLIST pidlRoot;
73921>>>>>>>//    LPSTR pszDisplayName;
73921>>>>>>>//    LPCSTR lpszTitle;
73921>>>>>>>//    UINT ulFlags;
73921>>>>>>>//    BFFCALLBACK lpfn;
73921>>>>>>>//    LPARAM lParam;
73921>>>>>>>//    int iImage;
73921>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
73921>>>>>>>
73921>>>>>>>//declare C structure struct_browseinfo
73921>>>>>>>//as documented in MSDN under Windows Shell API
73921>>>>>>>Struct tvBrowseInfo
73921>>>>>>>  Handle    hWndOwner
73921>>>>>>>  Pointer   pIDLRoot
73921>>>>>>>  Pointer   pszDisplayName
73921>>>>>>>  Pointer   lpszTitle
73921>>>>>>>  DWord     ulFlags
73921>>>>>>>  Pointer   lpfnCallback
73921>>>>>>>  LongPtr   lParam
73921>>>>>>>  DWord     iImage
73921>>>>>>>End_Struct // tvBrowseInfo
73921>>>>>>>
73921>>>>>>>// Browsing for directory.
73921>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
73921>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
73921>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
73921>>>>>>>                                            // The callback function can set the status text by
73921>>>>>>>                                            // sending messages to the dialog box.
73921>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
73921>>>>>>>
73921>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
73921>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
73921>>>>>>>
73921>>>>>>>// message from browser
73921>>>>>>>//Define BFFM_INITIALIZED        1
73921>>>>>>>//Define BFFM_SELCHANGED         2
73921>>>>>>>
73921>>>>>>>// messages to browser
73921>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
73921>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
73921>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
73921>>>>>>>
73921>>>>>>>
73921>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolderW" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
73922>>>>>>>
73922>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDListW" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
73923>>>>>>>
73923>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
73924>>>>>>>
73924>>>>>>>
73924>>>>>>>
73924>>>>>>>
73924>>>>>>>Struct tvSecurity_attributes
73924>>>>>>>  DWord   nLength
73924>>>>>>>  Pointer lpDescriptor
73924>>>>>>>  Integer bInheritHandle
73924>>>>>>>End_Struct // tvSecurity_attributes
73924>>>>>>>
73924>>>>>>>//nLength:
73924>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
73924>>>>>>>// SECURITY_ATTRIBUTES structure.
73924>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
73924>>>>>>>// value of the nLength member. However, an application should still set it properly.
73924>>>>>>>// That ensures current, future, and cross-platform compatibility.
73924>>>>>>>//
73924>>>>>>>//lpSecurityDescriptor:
73924>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
73924>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
73924>>>>>>>// descriptor of the calling process.
73924>>>>>>>//
73924>>>>>>>//bInheritHandle:
73924>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
73924>>>>>>>// If this member is TRUE, the new process inherits the handle.
73924>>>>>>>
73924>>>>>>>
73924>>>>>>>// BOOL CreateDirectory(
73924>>>>>>>//    LPCTSTR lpPathName,
73924>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
73924>>>>>>>//   );
73924>>>>>>>//
73924>>>>>>>// lpPathName
73924>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
73924>>>>>>>//  to be created.
73924>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
73924>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
73924>>>>>>>// lpSecurityAttributes
73924>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
73924>>>>>>>//  determines whether the returned handle can be inherited by child processes.
73924>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
73924>>>>>>>// Returns:
73924>>>>>>>//  If the function succeeds, the return value is nonzero.
73924>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
73924>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryW" kernel32.dll ;  WString sPathName Pointer lpSecurity_Attributes Returns Integer
73925>>>>>>>
73925>>>>>>>
73925>>>>>>>// lpPathName
73925>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
73925>>>>>>>//  to be removed.
73925>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
73925>>>>>>>// Returns:
73925>>>>>>>//  If the function succeeds, the return value is nonzero.
73925>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
73925>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryW" kernel32.dll ;  WString sPathName Returns Integer
73926>>>>>>>
73926>>>>>>>
73926>>>>>>>
73926>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
73926>>>>>>>// executable file or a document file.
73926>>>>>>>//
73926>>>>>>>// Operation can be one of the following:
73926>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
73926>>>>>>>//            The file can be an executable file or a document file.
73926>>>>>>>//            The file can be a folder to open.
73926>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
73926>>>>>>>//            The file should be a document file. If the file is an executable file,
73926>>>>>>>//            the function opens the file, as if "open" had been specified.
73926>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
73926>>>>>>>//
73926>>>>>>>// Return Values:
73926>>>>>>>//
73926>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
73926>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
73926>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
73926>>>>>>>//
73926>>>>>>>// The following table lists these error values:
73926>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
73926>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
73926>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
73926>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
73926>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
73926>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
73926>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
73926>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
73926>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
73926>>>>>>>// Public Const SE_ERR_FNF = 2
73926>>>>>>>// Public Const SE_ERR_NOASSOC = 31
73926>>>>>>>// Public Const SE_ERR_OOM = 8
73926>>>>>>>// Public Const SE_ERR_PNF = 3
73926>>>>>>>// Public Const SE_ERR_SHARE = 26
73926>>>>>>>
73926>>>>>>>
73926>>>>>>>
73926>>>>>>>// Code to open the program that is associated with the selected file.
73926>>>>>>>//
73926>>>>>>>// External function call used in Procedure DoStartDocument
73926>>>>>>>External_function vWin32_ShellExecute "ShellExecuteW" shell32.dll ;  Handle  hWnd ;  WString wsOperation ;  WString wsFile ;  WString wsParameters ;  WString wsDirectory ;  Dword   iShowCmd Returns Handle
73927>>>>>>>
73927>>>>>>>
73927>>>>>>>
73927>>>>>>>
73927>>>>>>>Define vFO_MOVE                For |CI$0001
73927>>>>>>>Define vFO_COPY                For |CI$0002
73927>>>>>>>Define vFO_DELETE              For |CI$0003
73927>>>>>>>Define vFO_RENAME              For |CI$0004
73927>>>>>>>
73927>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
73927>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
73927>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
73927>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
73927>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
73927>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
73927>>>>>>>                                          // Must be freed using SHFreeNameMappings
73927>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
73927>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
73927>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
73927>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
73927>>>>>>>
73927>>>>>>>Struct tvShFileOpStruct
73927>>>>>>>  Handle   hWnd
73927>>>>>>>  UInteger wFunc
73927>>>>>>>  Pointer  pFrom
73927>>>>>>>  Pointer  pTo
73927>>>>>>>  Short    fFlags
73927>>>>>>>  Integer  fAnyOperationsAborted
73927>>>>>>>  Pointer  hNameMappings
73927>>>>>>>  Pointer  lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
73927>>>>>>>End_Struct // tvShFileOpStruct
73927>>>>>>>
73927>>>>>>>// hwnd
73927>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
73927>>>>>>>
73927>>>>>>>// wFunc
73927>>>>>>>//   Operation to perform. This member can be one of the following values:
73927>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
73927>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
73927>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
73927>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
73927>>>>>>>
73927>>>>>>>// pFrom
73927>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
73927>>>>>>>//   be null-separated. The list of names must be double null-terminated.
73927>>>>>>>
73927>>>>>>>// pTo
73927>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
73927>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
73927>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
73927>>>>>>>//   double null-terminated.
73927>>>>>>>
73927>>>>>>>// fAnyOperationsAborted
73927>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
73927>>>>>>>//   were completed or FALSE otherwise.
73927>>>>>>>
73927>>>>>>>
73927>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
73927>>>>>>>// This can be a file or a folder.
73927>>>>>>>// With thanks to Andrew S Kaplan
73927>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationW" Shell32.dll ;        Pointer lpFileOp Returns Integer
73928>>>>>>>
73928>>>>>>>
73928>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
73928>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryW" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
73929>>>>>>>
73929>>>>>>>
73929>>>>>>>
73929>>>>>>>// Courtesy Of Vincent Oorsprong
73929>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
73929>>>>>>>//   Pointer lpPathName ;
73929>>>>>>>//   Pointer lpPrefixString ;
73929>>>>>>>//   Integer uUnique ;
73929>>>>>>>//   Pointer lpTempFileName ;
73929>>>>>>>//   Returns Integer
73929>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
73929>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameW" kernel32.dll WString sPath ;        WString sPrefix Integer iUnique Pointer lpTempFileName Returns Integer
73930>>>>>>>
73930>>>>>>>External_function vWin32_GetTempPath "GetTempPathW" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
73931>>>>>>>
73931>>>>>>>External_function vWin32_DeleteFile "DeleteFileW" Kernel32.Dll ;   WString sFileName ;   Returns Integer
73932>>>>>>>
73932>>>>>>>// from:
73932>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
73932>>>>>>>//
73932>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
73932>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
73932>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
73932>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
73932>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
73932>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
73932>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
73932>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
73932>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
73932>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
73932>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
73932>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
73932>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
73932>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
73932>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
73932>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
73932>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
73932>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
73932>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
73932>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
73932>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
73932>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
73932>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
73932>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
73932>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
73932>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
73932>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
73932>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
73932>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
73932>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
73932>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
73932>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
73932>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
73932>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
73932>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
73932>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
73932>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
73932>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
73932>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
73932>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
73932>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
73932>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
73932>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
73932>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
73932>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
73932>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
73932>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
73932>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
73932>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
73932>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
73932>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
73932>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
73932>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
73932>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
73932>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
73932>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
73932>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
73932>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
73932>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
73932>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
73932>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
73932>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
73932>>>>>>>
73932>>>>>>>
73932>>>>>>>//HRESULT SHGetFolderPath(
73932>>>>>>>//    HWND hwndOwner,
73932>>>>>>>//    int nFolder,
73932>>>>>>>//    HANDLE hToken,
73932>>>>>>>//    DWORD dwFlags,
73932>>>>>>>//    LPTSTR pszPath
73932>>>>>>>//);
73932>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
73932>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
73932>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
73932>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
73932>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
73932>>>>>>>//
73932>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathW" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
73933>>>>>>>
73933>>>>>>>
73933>>>>>>>
73933>>>>>>>Struct tvWin32FindData
73933>>>>>>> Dword            dwFileAttributes
73933>>>>>>> Dword            ftCreationLowDateTime
73933>>>>>>> Dword            ftCreationHighDateTime
73933>>>>>>> dword            ftLastAccessLowDateTime
73933>>>>>>> Dword            ftLastAccessHighDateTime
73933>>>>>>> Dword            ftLastWriteLowDateTime
73933>>>>>>> Dword            ftLastWriteHighDateTime
73933>>>>>>> Dword            nFileSizeHigh
73933>>>>>>> Dword            nFileSizeLow
73933>>>>>>> Dword            dwReserved0
73933>>>>>>> Dword            dwReserved1
73933>>>>>>> Short[vMax_Path] cFileName
73933>>>>>>> Short[14]        cAlternateFileName
73933>>>>>>>End_Struct
73933>>>>>>>
73933>>>>>>>// Courtesy Of Vincent Oorsprong
73933>>>>>>>// lpFileName      : address of name of file to search for
73933>>>>>>>// lpFindFileData  : address of returned information
73933>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileW"  Kernel32.dll WString sFileName ;          Pointer lpFindFileData Returns Handle
73934>>>>>>>
73934>>>>>>>// Courtesy Of Vincent Oorsprong
73934>>>>>>>// hFindFile       : handle of search
73934>>>>>>>// lpFindFileData  : address of structure for data on found file
73934>>>>>>>External_function vWin32_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
73935>>>>>>>
73935>>>>>>>
73935>>>>>>>// Courtesy Of Vincent Oorsprong
73935>>>>>>>//  hFindFile      : file search handle
73935>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
73936>>>>>>>
73936>>>>>>>
73936>>>>>>>
73936>>>>>>>Struct tvFileTime
73936>>>>>>>  DWord dwLowDateTime
73936>>>>>>>  DWord dwHighDateTime
73936>>>>>>>End_Struct
73936>>>>>>>
73936>>>>>>>
73936>>>>>>>Struct tvSystemTime
73936>>>>>>>  UShort wYear
73936>>>>>>>  UShort wMonth
73936>>>>>>>  UShort wDayOfWeek
73936>>>>>>>  UShort wDay
73936>>>>>>>  UShort wHour
73936>>>>>>>  UShort wMinute
73936>>>>>>>  UShort wSecond
73936>>>>>>>  UShort wMilliSeconds
73936>>>>>>>End_Struct
73936>>>>>>>
73936>>>>>>>
73936>>>>>>>// Courtesy Of Vincent Oorsprong
73936>>>>>>>//  lpFileTime     : pointer to file time to convert
73936>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
73936>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
73937>>>>>>>
73937>>>>>>>// Courtesy Of Vincent Oorsprong
73937>>>>>>>// This function formats the time in a picture-string passed
73937>>>>>>>//
73937>>>>>>>// Picture      Meaning
73937>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
73937>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
73937>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
73937>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
73937>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
73937>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
73937>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
73937>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
73937>>>>>>>//    t         One character time marker string, such as A or P
73937>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
73937>>>>>>>//
73937>>>>>>>// For example, to get the time string  "11:29:40 PM"
73937>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
73937>>>>>>>
73937>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
73938>>>>>>>
73938>>>>>>>
73938>>>>>>>// Courtesy Of Vincent Oorsprong
73938>>>>>>>// This function formats the date in a picture-string passed
73938>>>>>>>//
73938>>>>>>>// Picture      Meaning
73938>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
73938>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
73938>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
73938>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
73938>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
73938>>>>>>>//              value associated with the specified locale.
73938>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
73938>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
73938>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
73938>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
73938>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
73938>>>>>>>//              associated with the specified locale.
73938>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
73938>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
73938>>>>>>>//    yyyy      Year represented hy full four digits.
73938>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
73938>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
73938>>>>>>>//              does not have an associated era or period string.
73938>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
73938>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
73938>>>>>>>
73938>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
73939>>>>>>>
73939>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
73939>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
73939>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
73939>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
73939>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
73939>>>>>>>
73939>>>>>>>//  Date Flags for GetDateFormatW.
73939>>>>>>>//
73939>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
73939>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
73939>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
73939>>>>>>>
73939>>>>>>>
73939>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
73940>>>>>>>
73940>>>>>>>
73940>>>>>>>// **WvA: 20-02-2004
73940>>>>>>>// While i was testing the format capabilities i stumbled over a very
73940>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
73940>>>>>>>// incorrectly into an unsigned integer.
73940>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
73940>>>>>>>// It does smell a bit fishy though
73940>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
73940>>>>>>>
73940>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
73940>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
73940>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
73940>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
73940>>>>>>>
73940>>>>>>>// Possible errors that can be returned by the shellformat function
73940>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
73940>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
73940>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
73940>>>>>>>
73940>>>>>>>
73940>>>>>>> // Courtesy Of Steve Walter,
73940>>>>>>> // USA Software, Inc
73940>>>>>>> // Format a disk
73940>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
73940>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
73941>>>>>>>
73941>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
73941>>>>>>>
73941>>>>>>>// SHCreateDirectoryEx
73941>>>>>>>
73941>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
73941>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
73941>>>>>>>//
73941>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
73941>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
73941>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
73941>>>>>>>//
73941>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
73941>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
73941>>>>>>>//        ERROR_CANCELLED.
73941>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
73941>>>>>>>
73941>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
73941>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
73941>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
73941>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
73941>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
73941>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
73941>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
73941>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
73941>>>>>>>
73941>>>>>>>//        int SHCreateDirectoryEx(
73941>>>>>>>//            HWND hwnd,
73941>>>>>>>//            LPCTSTR pszPath,
73941>>>>>>>//            const SECURITY_ATTRIBUTES *psa
73941>>>>>>>//        );
73941>>>>>>>
73941>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExW" shell32.dll Handle hWnd;                  WString wPath  Pointer lpSecurity_Attributes Returns Integer
73942>>>>>>>
73942>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryW" SHLWAPI.DLL WString wPath Returns Integer
73943>>>>>
73943>>>>>
73943>>>>>
73943>>>>>// Does the directory exist? - No = false, Yes = True
73943>>>>>// This also works with UNC path encoding and wildcards
73943>>>>>Function vFolderExists Global String sFolderName Returns Boolean
73945>>>>>    Boolean bFolderExists
73945>>>>>    Boolean bStop
73945>>>>>    String  sFolder sTmp
73945>>>>>    Integer iCh
73945>>>>>
73945>>>>>    If (sFolderName = "") Begin
73947>>>>>        Function_Return False
73948>>>>>    End
73948>>>>>>
73948>>>>>
73948>>>>>    Move True  to bFolderExists
73949>>>>>    Move False to bStop
73950>>>>>    Move "dir:" to sFolder
73951>>>>>    Append sFolder sFolderName
73952>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
73953>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
73955>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
73956>>>>>>
73956>>>>>        Function_Return False
73957>>>>>    End
73957>>>>>>
73957>>>>>    Direct_Input channel iCh sFolder
73959>>>>>    Repeat
73959>>>>>>
73959>>>>>        Readln channel iCh sTmp
73961>>>>>        Move (SeqEof) to bStop
73962>>>>>        If (Trim(sTmp)="") Begin
73964>>>>>            Move False to bFolderExists
73965>>>>>        End
73965>>>>>>
73965>>>>>        Else Begin
73966>>>>>            Move True to bFolderExists
73967>>>>>            Move True to bStop
73968>>>>>        End
73968>>>>>>
73968>>>>>    Until (bStop)
73970>>>>>    Close_Input channel iCh
73972>>>>>    Send Seq_Release_Channel iCh
73973>>>>>    Function_Return bFolderExists
73974>>>>>End_Function
73975>>>>>
73975>>>>>// returns folder name if a folder was selected, otherwise returns ""
73975>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
73977>>>>>    String  sPath
73977>>>>>    WString sFolder sTitle
73977>>>>>    Pointer lpItemIdList
73977>>>>>    Integer iFolderSelected iRetval
73977>>>>>    tvBrowseInfo BrowseInfo
73977>>>>>    tvBrowseInfo BrowseInfo
73977>>>>>
73977>>>>>    Move "" to sPath
73978>>>>>    If (sDialogTitle<>"") Begin
73980>>>>>        Move sDialogTitle to sTitle
73981>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
73981>>>>>        // disables showing some commonly used ascii characters like ascii 137 (ë)
73981>>>>>        // These chars are correctly shown if no toansi is used.
73981>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
73981>>>>>        // selected it will always be valid.
73981>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
73982>>>>>    End
73982>>>>>>
73982>>>>>
73982>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
73983>>>>>
73983>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
73983>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
73983>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
73984>>>>>
73984>>>>>    // null 128 chars into var (make space)
73984>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
73985>>>>>
73985>>>>>    // select folder
73985>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
73986>>>>>    // get selected folder name
73986>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
73987>>>>>
73987>>>>>    // release memory resources that are used by the ItemIdList
73987>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
73988>>>>>
73988>>>>>    If (iFolderSelected<>0) Begin
73990>>>>>        Move (CString(sFolder)) to sPath
73991>>>>>    End
73991>>>>>>
73991>>>>>    Function_Return  sPath
73992>>>>>End_Function
73993>>>>>
73993>>>>>// returns 0 if the folder is created.
73993>>>>>//         1 if the API-call returned an error.
73993>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
73995>>>>>    Integer  iRetval bFolderCreated
73995>>>>>    WString  sFolder
73995>>>>>    tvSecurity_attributes SA
73995>>>>>    tvSecurity_attributes SA
73995>>>>>
73995>>>>>    Move False to bFolderCreated
73996>>>>>    If (sNewFolder <> "") Begin
73998>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
73999>>>>>        Move  0                                  to SA.lpDescriptor
74000>>>>>        Move  1                                  to SA.bInheritHandle
74001>>>>>        Move (sNewFolder+Character(0)) to sFolder
74002>>>>>        Move (vWin32_CreateDirectory(sFolder, AddressOf(SA))) to bFolderCreated
74003>>>>>    End
74003>>>>>>
74003>>>>>
74003>>>>>    If (bFolderCreated=false) Begin
74005>>>>>        Move 1 to iRetVal
74006>>>>>    End
74006>>>>>>
74006>>>>>    Function_Return iRetVal
74007>>>>>End_Function
74008>>>>>
74008>>>>>// **WvA: 03-02-2002 Function created.
74008>>>>>// With this function one can remove a directory.
74008>>>>>// returns 0 if the folder is removed.
74008>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
74008>>>>>//         2 if the folder did not exist
74008>>>>>//         3 if the sFolder parameter passed is equal to ""
74008>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
74010>>>>>    Boolean bRemoved
74010>>>>>    WString sPath
74010>>>>>    Integer iRetval
74010>>>>>
74010>>>>>    Move 0     to iRetVal
74011>>>>>    Move False to bRemoved
74012>>>>>    Move (Trim(sFolder)) to sFolder
74013>>>>>    If (sFolder="") Begin
74015>>>>>        Move 3 to iRetVal
74016>>>>>    End
74016>>>>>>
74016>>>>>    If (vFolderExists(sFolder)=False) Begin
74018>>>>>        Move 2 to iRetVal
74019>>>>>    End
74019>>>>>>
74019>>>>>    If (iRetVal=0) Begin
74021>>>>>        // null MAX_PATH chars into var (make space)
74021>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
74022>>>>>        //
74022>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
74023>>>>>        Move (vWin32_RemoveDirectory(sPath)) to bRemoved
74024>>>>>    End
74024>>>>>>
74024>>>>>
74024>>>>>    If (iRetVal=0 And bRemoved=False) Begin
74026>>>>>        Move 1 to iRetVal
74027>>>>>    End
74027>>>>>>
74027>>>>>    Function_Return iRetVal
74028>>>>>End_Function
74029>>>>>
74029>>>>>// This will perform an operation on a file (e.g. open) with the application
74029>>>>>// registered in the Windows Registry to open that type of file (via its extension)
74029>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
74029>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
74031>>>>>    Handle  hInstance hWnd
74031>>>>>    // remove any leading/trailing spaces in the string
74031>>>>>    Move (Trim(sDocument)) to sDocument
74032>>>>>    Move (Trim(sPath))     to sPath
74033>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
74033>>>>>    Append sOperation   (Character(0))
74034>>>>>    Append sDocument    (Character(0))
74035>>>>>    Append sParameters  (Character(0))
74036>>>>>    Append sPath        (Character(0))
74037>>>>>
74037>>>>>    Get Window_Handle to hWnd
74038>>>>>    Move (vWin32_ShellExecute (hWnd, sOperation, sDocument, sParameters, sPath, 1)) to hInstance
74039>>>>>    If (hInstance <= 32) Begin
74041>>>>>        Send vDDE_Error_Handler hInstance
74042>>>>>    End
74042>>>>>>
74042>>>>>End_Procedure
74043>>>>>
74043>>>>>Class cShellFileOperations is a Array
74044>>>>>
74044>>>>>    Procedure Construct_Object
74046>>>>>        Forward Send Construct_Object
74048>>>>>        Property Integer piDeleteFlags        0
74049>>>>>        Property Integer piCopyFlags          0
74050>>>>>        Property Integer piMoveFlags          0
74051>>>>>        Property Integer piRenameFlags        0
74052>>>>>
74052>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
74053>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
74054>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
74055>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
74056>>>>>    End_Procedure
74057>>>>>
74057>>>>>    // This function uses the shell API to perform a file operation on the
74057>>>>>    // files supplied.
74057>>>>>    //
74057>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
74059>>>>>        Integer  iRetVal
74059>>>>>        Integer  iUserAbort
74059>>>>>        WString  wsSource wsDestination
74059>>>>>        tvShFileOpStruct FOS
74059>>>>>        tvShFileOpStruct FOS
74059>>>>>
74059>>>>>        Move (sSource+Character(0)+Character(0))      to wsSource
74060>>>>>        Move (sDestination+Character(0)+Character(0)) to wsDestination
74061>>>>>
74061>>>>>        If (eOperation <> vFO_DELETE) Begin
74063>>>>>            Move (AddressOf(wsDestination)) to FOS.pTo
74064>>>>>        End
74064>>>>>>
74064>>>>>
74064>>>>>        Move eOperation            to FOS.wFunc
74065>>>>>        Move (AddressOf(wsSource)) to FOS.pFrom
74066>>>>>        Move iFlags                to FOS.fFlags
74067>>>>>
74067>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
74068>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
74069>>>>>        If (iUserAbort <> 0) Begin
74071>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
74072>>>>>        End
74072>>>>>>
74072>>>>>        Function_Return (iRetVal)
74073>>>>>    End_Function
74074>>>>>
74074>>>>>    Function sfoDeleteFile String sFileName Returns Integer
74076>>>>>        Integer  iRetVal
74076>>>>>        Integer  iFlags
74076>>>>>
74076>>>>>        Get piDeleteFlags to iFlags
74077>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
74078>>>>>        Function_Return iRetVal
74079>>>>>    End_Function
74080>>>>>
74080>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
74082>>>>>        Integer  iRetVal
74082>>>>>        Integer  iFlags
74082>>>>>
74082>>>>>        Get piCopyFlags to iFlags
74083>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
74084>>>>>        Function_Return iRetVal
74085>>>>>    End_Function
74086>>>>>
74086>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
74088>>>>>        Integer  iRetVal
74088>>>>>        Integer  iFlags
74088>>>>>
74088>>>>>        Get piMoveFlags to iFlags
74089>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
74090>>>>>        Function_Return iRetVal
74091>>>>>    End_Function
74092>>>>>
74092>>>>>    // Rename a file or folder
74092>>>>>    // Returns a nonzero value if the operation failed.
74092>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
74094>>>>>        Integer  iRetVal
74094>>>>>        Integer  iFlags
74094>>>>>
74094>>>>>        Get piRenameFlags to iFlags
74095>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
74096>>>>>        Function_Return iRetVal
74097>>>>>    End_Function
74098>>>>>
74098>>>>>
74098>>>>>    //Example:
74098>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
74098>>>>>    //                                          mode.
74098>>>>>
74098>>>>>End_Class
74099>>>>>
74099>>>>>Object oShellFileOperations is a cShellFileOperations
74101>>>>>End_Object
74102>>>>>
74102>>>>>// Restore to the old way of working with the shell file operations.
74102>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
74102>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
74102>>>>>Procedure vWin32fhCompatibilityMode
74104>>>>>    Integer hoSFO
74104>>>>>    Integer iFlags
74104>>>>>
74104>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
74105>>>>>    Move (oShellFileOperations(Self)) to hoSFO
74106>>>>>
74106>>>>>    Set piDeleteFlags of hoSFO to iFlags
74107>>>>>    Set piCopyFlags   of hoSFO to iFlags
74108>>>>>    Set piMoveFlags   of hoSFO to iFlags
74109>>>>>    Set piRenameFlags of hoSFO to iFlags
74110>>>>>End_Procedure
74111>>>>>
74111>>>>>// Delete a file or folder
74111>>>>>// Returns a nonzero value if the operation failed.
74111>>>>>Function vDeleteFile Global String sFileName Returns Integer
74113>>>>>    Integer  iRetVal
74113>>>>>
74113>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
74114>>>>>    Function_Return iRetVal
74115>>>>>End_Function
74116>>>>>
74116>>>>>// Copy a file or folder
74116>>>>>// Returns a nonzero value if the operation failed.
74116>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
74118>>>>>    Integer  iRetVal
74118>>>>>
74118>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
74119>>>>>    Function_Return iRetVal
74120>>>>>End_Function
74121>>>>>
74121>>>>>// Move a file or folder
74121>>>>>// Returns a nonzero value if the operation failed.
74121>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
74123>>>>>    Integer  iRetVal
74123>>>>>
74123>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
74124>>>>>    Function_Return iRetVal
74125>>>>>End_Function
74126>>>>>
74126>>>>>// Rename a file or folder
74126>>>>>// Returns a nonzero value if the operation failed.
74126>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
74128>>>>>    Integer  iRetVal
74128>>>>>
74128>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
74129>>>>>    Function_Return iRetVal
74130>>>>>End_Function
74131>>>>>
74131>>>>>Function vGetWindowsDirectory Returns String
74133>>>>>    WString wDirectory
74133>>>>>    Integer iRetVal
74133>>>>>
74133>>>>>    Move (ZeroString(vMAX_PATH)) to wDirectory
74134>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), vMAX_PATH)) to iRetVal
74135>>>>>    If (iRetVal > vMAX_PATH) Begin
74137>>>>>        Move (ZeroString(iRetval)) to wDirectory
74138>>>>>        Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), iRetVal)) to iRetVal
74139>>>>>    End
74139>>>>>>
74139>>>>>    Function_Return (CString(wDirectory))
74140>>>>>End_Function
74141>>>>>
74141>>>>>Function vGetTempPath Returns String
74143>>>>>    Integer iRetVal
74143>>>>>    WString wTempPath
74143>>>>>
74143>>>>>    Move (ZeroString(vMAX_PATH)) to wTempPath
74144>>>>>    Move (vWin32_GetTempPath(vMAX_PATH, AddressOf(wTempPath))) to iRetVal
74145>>>>>    If (iRetVal > vMAX_PATH) Begin
74147>>>>>        Move (ZeroString(iRetval)) to wTempPath
74148>>>>>        Move (vWin32_GetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
74149>>>>>    End
74149>>>>>>
74149>>>>>    Function_Return (CString(wTempPath))
74150>>>>>End_Function
74151>>>>>
74151>>>>>// Courtesy of Marco Kuipers
74151>>>>>Function vMakeTempFile Returns String
74153>>>>>    Integer iRetval
74153>>>>>    String  sTempPath
74153>>>>>    String  sTempFileName
74153>>>>>    String  sPrefixString
74153>>>>>    WString wsTempFileName
74153>>>>>
74153>>>>>    Get vGetTempPath to sTempPath
74154>>>>>    If (sTempPath = "") Begin
74156>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
74157>>>>>        If (sTempPath<>"") Begin
74159>>>>>            Move (sTempPath+"\Temp\") to sTempPath
74160>>>>>        End
74160>>>>>>
74160>>>>>    End
74160>>>>>>
74160>>>>>
74160>>>>>    If (sTempPath = "") Begin
74162>>>>>        // second fallback we really do not want to get here as to be fair using current folder as temp
74162>>>>>        // makes little sense. Leaving this in as it was old behavior.
74162>>>>>        Get_Current_Directory to sTempPath
74163>>>>>    End
74163>>>>>>
74163>>>>>
74163>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
74164>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
74166>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
74167>>>>>>
74167>>>>>    End
74167>>>>>>
74167>>>>>
74167>>>>>    Move (ZeroString(vMax_Path)) to wsTempFileName
74168>>>>>    Move ("tmp"+Character(0))    to sPrefixString
74169>>>>>    Move (vWin32_GetTempFileName (sTempPath, sPrefixString, 0, AddressOf(wsTempFileName))) to iRetval
74170>>>>>    If (iRetval = 0) Begin  // The api call returns 0 if an error occurs
74172>>>>>    //Get ShowLastError to iRetval
74172>>>>>        Move "" to sTempFileName
74173>>>>>    End
74173>>>>>>
74173>>>>>    Move (Cstring(wsTempFileName)) to sTempFileName
74174>>>>>    Function_Return sTempFileName
74175>>>>>End_Function
74176>>>>>
74176>>>>>// This function creates a uniquely named temporary file in folder sPath
74176>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
74176>>>>>// Note that you will have to cleanup the tempfile yourself as the function
74176>>>>>// does not take care of that.
74176>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
74178>>>>>    Integer iRetVal
74178>>>>>    String  sTempFileName
74178>>>>>    WString wTempFileName
74178>>>>>
74178>>>>>    Move (sPath+Character(0))   to sPath
74179>>>>>    Move (sPrefix+Character(0)) to sPrefix
74180>>>>>    Move (Pad("", vMAX_PATH))   to wTempFileName
74181>>>>>
74181>>>>>    Move (vWin32_GetTempFileName(sPath, sPrefix, 0, AddressOf(wTempFileName))) to iRetVal
74182>>>>>    Move (Trim(Cstring(wTempFileName))) to sTempFileName
74183>>>>>    Function_Return sTempFileName
74184>>>>>End_Function
74185>>>>>
74185>>>>>//
74185>>>>>// Get a specific shell folder for example to get the desktop folder
74185>>>>>// simply call this function and pass it vCSIDL_DESKTOP
74185>>>>>//
74185>>>>>Function vSHGetFolderPath Integer eFolder Returns String
74187>>>>>    Integer iVoid
74187>>>>>    Handle  hWnd
74187>>>>>    String  sFolder
74187>>>>>    WString wFolder
74187>>>>>
74187>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
74188>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to wFolder
74189>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(wFolder))) To iVoid
74190>>>>>    Move (CString(wFolder)) to sFolder
74191>>>>>    Function_Return sFolder
74192>>>>>End_Function
74193>>>>>
74193>>>>>// Courtesy Of Vincent Oorsprong
74193>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
74195>>>>>    String  sFileDateTime
74195>>>>>    WString wFormattedTime wFormattedDate
74195>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
74195>>>>>    tvFileTime   FileTime
74195>>>>>    tvFileTime   FileTime
74195>>>>>    tvSystemTime SystemTime
74195>>>>>    tvSystemTime SystemTime
74195>>>>>
74195>>>>>    Move "" to sFileDateTime
74196>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
74197>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
74198>>>>>
74198>>>>>    Move 0 to SystemTime.wYear
74199>>>>>
74199>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
74200>>>>>    If (iSuccess = 1) Begin
74202>>>>>        Move (ZeroString(255))               to wFormattedTime
74203>>>>>        Move (SizeOfWString(wFormattedTime)) to iLenCcTime
74204>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedTime), iLenCcTime)) to iDataLength
74205>>>>>        Move (ZeroString(255))               to wFormattedDate
74206>>>>>        Move (SizeOfWString(wFormattedDate)) to iLenCcDate
74207>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedDate), iLenCcDate)) to iDataLength
74208>>>>>        Move (Cstring (wFormattedDate)  * Cstring (wFormattedTime)) to sFileDateTime
74209>>>>>    End
74209>>>>>>
74209>>>>>    Function_Return sFileDateTime
74210>>>>>End_Function
74211>>>>>
74211>>>>>// **WvA:
74211>>>>>// A windows replacement for the standard function FileExists.
74211>>>>>// This version will also return (true) for a file when it is open by an application.
74211>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
74211>>>>>// Example: Get vFilePathExists "C:\config.sy?"
74211>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
74211>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
74213>>>>>    String  sDirSep
74213>>>>>    Handle  hFindFile
74213>>>>>    Integer iVoid
74213>>>>>    tvWin32FindData FindData
74213>>>>>    tvWin32FindData FindData
74213>>>>>
74213>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
74214>>>>>    Move (Trim(sFilePathMask)) to sFilePathMask
74215>>>>>
74215>>>>>    If (Length(sFilePathMask)>0) Begin
74217>>>>>        // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
74217>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74218>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
74222>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
74223>>>>>        Loop
74224>>>>>>
74224>>>>>
74224>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
74225>>>>>        Move (vWin32_FindFirstFile (sFilePathMask, AddressOf(FindData))) to hFindFile
74226>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
74227>>>>>    End
74227>>>>>>
74227>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
74228>>>>>End_Function
74229>>>>>
74229>>>>>
74229>>>>>//
74229>>>>>// Returns the amount of files in the folder (if it exists)
74229>>>>>// Returns -1 if folder doesn't exist.
74229>>>>>// The files "." and ".." are not counted.
74229>>>>>//
74229>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
74231>>>>>    Boolean bFound
74231>>>>>    Handle  hFindFile
74231>>>>>    Integer iCount  iVoid
74231>>>>>    Integer iSuccess
74231>>>>>    String  sFileName
74231>>>>>    tvWin32FindData FindData
74231>>>>>    tvWin32FindData FindData
74231>>>>>
74231>>>>>    Move -1 to iCount
74232>>>>>    Get vFolderFormat sFolderName to sFolderName
74233>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
74234>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
74235>>>>>    Move (vWin32_FindFirstFile (sFolderName, AddressOf(FindData))) to hFindFile
74236>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
74237>>>>>    If (bFound) Begin
74239>>>>>        Move 0 to iCount
74240>>>>>    End
74240>>>>>>
74240>>>>>    While (bFound)
74244>>>>>        Increment iCount
74245>>>>>        Move (PointerToWString(AddressOf(FindData.cFileName))) to sFileName
74246>>>>>        If (sFileName="." or sFileName="..") Begin
74248>>>>>            Decrement iCount
74249>>>>>        End
74249>>>>>>
74249>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
74250>>>>>        Move (iSuccess<>0) to bFound
74251>>>>>    Loop
74252>>>>>>
74252>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
74253>>>>>    Function_Return iCount
74254>>>>>End_Function
74255>>>>>
74255>>>>>// Create the folder, including intermediate directories.
74255>>>>>// Don't panic if the folder already exists.
74255>>>>>// Michael Mullan June 2009.
74255>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
74257>>>>>    String  sFolder
74257>>>>>    Integer iRetval iFolderCreated
74257>>>>>    tvSecurity_attributes SA
74257>>>>>    tvSecurity_attributes SA
74257>>>>>
74257>>>>>    Move 0 to iFolderCreated
74258>>>>>
74258>>>>>    // null MAX_PATH chars into var (make space)
74258>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
74259>>>>>    If (sNewFolder <> "") Begin
74261>>>>>
74261>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
74262>>>>>        Move  0  to SA.lpDescriptor
74263>>>>>        Move  1  to SA.bInheritHandle
74264>>>>>
74264>>>>>        //
74264>>>>>        Move (sNewFolder+"") to sFolder
74265>>>>>        Move (vWin32_SHCreateDirectoryEx(0,sFolder, AddressOf(SA))) to iFolderCreated
74266>>>>>    End
74266>>>>>>
74266>>>>>
74266>>>>>    If (iFolderCreated <> 0) Begin
74268>>>>>        Move 1 to iRetVal
74269>>>>>        Case Begin
74269>>>>>            Case (iFolderCreated = 161)
74271>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
74272>>>>>>
74272>>>>>                Case Break
74273>>>>>            Case (iFolderCreated = 206)
74276>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
74277>>>>>>
74277>>>>>                Case Break
74278>>>>>            Case (iFolderCreated = 3)
74281>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
74282>>>>>>
74282>>>>>                Case Break
74283>>>>>            Case (iFolderCreated = 80)
74286>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
74287>>>>>                Case Break
74288>>>>>            Case (iFolderCreated = 183)
74291>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
74292>>>>>                Case Break
74293>>>>>            Case (iFolderCreated = 1223)
74296>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
74297>>>>>>
74297>>>>>                Case Break
74298>>>>>            Case Else
74298>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
74299>>>>>>
74299>>>>>        Case End
74299>>>>>    End
74299>>>>>>
74299>>>>>    Function_Return iRetVal
74300>>>>>End_Function
74301>>>>>
74301>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
74303>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
74303>>>>>    Integer iFileSize iVoid
74303>>>>>    Handle  hFindFile
74303>>>>>    tvWin32FindData FindData
74303>>>>>    tvWin32FindData FindData
74303>>>>>
74303>>>>>    Move (sFileName+"") to sFileName
74304>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
74305>>>>>    Move (vWin32_FindFirstFile (sFileName, AddressOf(FindData))) to hFindFile
74306>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
74308>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
74309>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
74310>>>>>    End
74310>>>>>>
74310>>>>>    Move (vWin32_FindClose(hFindFile)) to iVoid
74311>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
74312>>>>>
74312>>>>>    Function_Return iFileSize
74313>>>>>End_Function
74314>>>>>
74314>>>>>//
74314>>>>>// Based on code in Peter Crook's Browse folder workspace
74314>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
74314>>>>>//
74314>>>>>//=============================================================================
74314>>>>>// Verifies that a path is a valid directory.
74314>>>>>//
74314>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
74314>>>>>//
74314>>>>>// Parameters:
74314>>>>>//      sPath - Address of the path to verify.
74314>>>>>//=============================================================================
74314>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
74316>>>>>    Integer iResult
74316>>>>>    Boolean bRetVal
74316>>>>>
74316>>>>>    Move false to bRetVal
74317>>>>>    Move (sPath - Character (0)) to sPath
74318>>>>>    Move (vWin32_PathIsDirectory (sPath)) to iResult
74319>>>>>    If (iResult<>0) Begin
74321>>>>>        Move True to bRetVal
74322>>>>>    End
74322>>>>>>
74322>>>>>
74322>>>>>    Function_Return bRetVal
74323>>>>>End_Function
74324>>>>>
74324>>>
74324>>>//
74324>>>// Gets the string from the right of the last sStopChar in sFrom
74324>>>// If sStopChar has no occurences in the string an empty string is
74324>>>// returned.
74324>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
74326>>>    String  sRetVal
74326>>>    String  sChar
74326>>>    Integer iLength
74326>>>    Integer iPos
74326>>>    Boolean bStopChar
74326>>>    Move "" to sRetval
74327>>>    Move (Length(sFrom)) to iLength
74328>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
74330>>>        Move iLength   to iPos
74331>>>        Move (False)   to bStopChar
74332>>>        While Not bStopChar
74336>>>            Move (Mid(sFrom,1,iPos)) to sChar
74337>>>            Decrement iPos
74338>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
74340>>>                Move (True) to bStopChar
74341>>>            End
74341>>>>
74341>>>            Else Begin
74342>>>                Move (sChar+sRetVal) to sRetVal
74343>>>            End
74343>>>>
74343>>>        Loop
74344>>>>
74344>>>    End
74344>>>>
74344>>>    Function_Return sRetVal
74345>>>End_Function
74346>>>
74346>>>// Pre:  sFileName contains the complete path of the file.
74346>>>// Post: returns the complete path of the file.
74346>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
74346>>>Function ParseFolderName Global String sFileName Returns String
74348>>>    String sFile
74348>>>    String sFolderName
74348>>>    String sDirSep // this is "\" for windows, or "/" for unix
74348>>>
74348>>>    Move "" to sFolderName
74349>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74350>>>    If sDirSep In sFileName Begin
74352>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
74353>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
74354>>>    End
74354>>>>
74354>>>    Else If ":" In sFileName Begin
74357>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
74358>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
74359>>>    End
74359>>>>
74359>>>    Function_Return sFolderName
74360>>>End_Function
74361>>>
74361>>>// Pre:  sFileName contains the complete path of the file.
74361>>>// post: The returned filename has it's path removed, but will have a extension
74361>>>Function ParseFileName Global String sFileName Returns String
74363>>>    String sFolderName
74363>>>    String sDirSep // this is "\" for windows, or "/" for unix
74363>>>
74363>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74364>>>    Get ParseFolderName sFileName to sFolderName
74365>>>    If (sFolderName <> "") Begin
74367>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
74368>>>    End
74368>>>>
74368>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
74369>>>    Function_Return sFilename
74370>>>End_Function
74371>>>
74371>>>// Pre:  sFileName may contain the complete path of the file.
74371>>>//       or contain multiple dots in the filename, so temp.gif.bak will
74371>>>//       return "bak" as the extension and not "gif"
74371>>>// Post: returns the extension only, this extension can be a valid unixlike extension
74371>>>//       such as "html" or "java"
74371>>>Function ParseFileExtension Global String sFileName Returns String
74373>>>    String  sFileExtension
74373>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
74374>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
74375>>>    Function_Return sFileExtension
74376>>>End_Function
74377>>>
74377>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
74377>>>
74377>>>Function DDE_Error_To_String Integer iErrorID Returns String
74379>>>    String sMessage
74379>>>    Case Begin
74379>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
74381>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
74382>>>            Case Break
74383>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
74386>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
74387>>>            Case Break
74388>>>        Case (iErrorID = vERROR_BAD_FORMAT)
74391>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
74392>>>            Case Break
74393>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
74396>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
74397>>>            Case Break
74398>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
74401>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
74402>>>            Case Break
74403>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
74406>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
74407>>>            Case Break
74408>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
74411>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
74412>>>            Case Break
74413>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
74416>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
74417>>>            Case Break
74418>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
74421>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
74422>>>            Case Break
74423>>>        Case (iErrorID = vSE_ERR_NOASSOC)
74426>>>            Move CS_DDE_ERR_NOASSOC to sMessage
74427>>>            Case Break
74428>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
74431>>>            Move CS_DDE_ERR_OOM to sMessage
74432>>>            Case Break
74433>>>        Case (iErrorID = vSE_ERR_PNF)
74436>>>            Move CS_DDE_ERR_PNF to sMessage
74437>>>            Case Break
74438>>>        Case (iErrorID = vSE_ERR_SHARE)
74441>>>            Move CS_DDE_ERR_SHARE to sMessage
74442>>>            Case Break
74443>>>        Case Else
74443>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
74444>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
74445>>>            Case Break
74446>>>    Case End
74446>>>    Function_Return sMessage
74447>>>End_Function
74448>>>
74448>>>Procedure vDDE_Error_Handler Integer iErrorID
74450>>>    String sMessage
74450>>>    Get DDE_Error_To_String iErrorID to sMessage
74451>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
74452>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
74453>>>End_Procedure
74454>>>
74454>>>
74454>>>// This function informs the user that he entered a yet unknown folder and
74454>>>// asks if he/she wants to create the folder (Yes/No)
74454>>>// Choice: "Yes" - this creates the folder
74454>>>//                 if successful, the function returns false
74454>>>//                 else it will be true.
74454>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
74454>>>//                 For example: to stop a save
74454>>>// Precondition: A foldername must be entered. We do not check for empty paths
74454>>>// This function returns a non-zero value if the folder isn't created afterwards
74454>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
74456>>>    Integer bIsNotValid
74456>>>    Integer iUsers_Choice
74456>>>    String  sMessage
74456>>>
74456>>>    If (vFolderExists(sFolderName) Eq 0) Begin
74458>>>        Move "The folder '" to sMessage
74459>>>        Append sMessage sFolderName
74460>>>        Append sMessage "' does not yet exist,\n"
74461>>>        Append sMessage "Do you want to create it now?"
74462>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
74463>>>        Case Begin
74463>>>            Case (iUsers_Choice = MBR_Yes)
74465>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
74466>>>                If bIsNotValid Begin
74468>>>                    Move "An error occurred while trying to create folder '" to sMessage
74469>>>                    Append sMessage sFolderName "'.\n\n"
74471>>>                    Send Info_Box sMessage "Info"
74472>>>                End
74472>>>>
74472>>>                Case Break
74473>>>            Case (iUsers_Choice = MBR_No)
74476>>>                Move dfTrue to bIsNotValid // Cancel the save
74477>>>                Case Break
74478>>>        Case End
74478>>>    End
74478>>>>
74478>>>    Function_Return bIsNotValid
74479>>>End_Function
74480>>>
74480>>>// **WvA
74480>>>// Formats a foldername by first trimming it and after that by sticking a
74480>>>// directory separator (/\) to the end if it doesn't have one there already.
74480>>>// The folder may contain a drive letter or UNC encoding.
74480>>>Function vFolderFormat Global String sFolderName Returns String
74482>>>    String sDirSep
74482>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
74483>>>    Move (Trim(sFolderName)) to sFolderName
74484>>>    If (Right(sFolderName,1)<>sDirSep) Begin
74486>>>        Move (sFolderName+sDirSep) to sFolderName
74487>>>    End
74487>>>>
74487>>>    Function_Return sFolderName
74488>>>End_Function
74489>>>
74489>>>//
74489>>>// Gets the parent path of the currently supplied path
74489>>>// Returns "" when we are at the root folder.
74489>>>//
74489>>>Function vParentPath Global String sPath Returns String
74491>>>    String sStrip sDirSep
74491>>>
74491>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74492>>>    Move (Trim(sPath)) to sPath
74493>>>    If (Right(sPath,1) = sDirSep) Begin
74495>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
74496>>>    End
74496>>>>
74496>>>    If (Pos(sDirSep, sPath)) Begin
74498>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
74499>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
74500>>>    End
74500>>>>
74500>>>    Else Begin
74501>>>        Move "" to sPath
74502>>>    End
74502>>>>
74502>>>    Function_Return sPath
74503>>>End_Function
74504>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJSkinFramework.pkg)
74504>>>Use windows.pkg
74504>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJComSkinFramework.pkg)
74504>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v22.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v22.0.0.ocx
74504>>>>>Use FlexCom20.pkg
74504>>>>>
74504>>>>>// Changes to Imported package
74504>>>>>//     OLEXTPxx to XTPxx
74504>>>>>//     OLExtpxx to xtpxx
74504>>>>>//     OLESkinFramework to SkinFramework
74504>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
74504>>>>>//     cCom classes to cCJ
74504>>>>>//     cCJAutomationObject back to cComAutomationObject
74504>>>>>//     cCJActiveXControl back to cComActiveXControl
74504>>>>>//     cCJSkinFramework to cCJComSkinFramework
74504>>>>>//     Use statements as noted below (classes moved to these files)
74504>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
74504>>>>>
74504>>>>>// These have been extracted from this class and moved into seperate packages
74504>>>>>// because other Codejock classes use these.
74504>>>>>Use cCJColorManager.pkg     // cCJColorManager
74504>>>>>
74504>>>>>
74504>>>>>Define SkinFrameworkApplyOptions for Integer
74504>>>>>    Define xtpSkinApplyMetrics for 1
74504>>>>>    Define xtpSkinApplyFrame for 2
74504>>>>>    Define xtpSkinApplyColors for 4
74504>>>>>    Define xtpSkinApplyMenus for 8
74504>>>>>
74504>>>>>// CLSID: {C0DE2200-28D7-4F2C-87A7-7266367B4655}
74504>>>>>// Dispatch interface for SkinFramework Control
74504>>>>>Class cCJ_DSkinFramework is a Mixin
74505>>>>>
74505>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
74507>>>>>        SkinFrameworkApplyOptions retVal
74507>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
74508>>>>>        Function_Return retVal
74509>>>>>    End_Function
74510>>>>>
74510>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
74512>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
74513>>>>>    End_Procedure
74514>>>>>
74514>>>>>    Function ComAutoApplyNewWindows Returns Boolean
74516>>>>>        Boolean retVal
74516>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
74517>>>>>        Function_Return retVal
74518>>>>>    End_Function
74519>>>>>
74519>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
74521>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
74522>>>>>    End_Procedure
74523>>>>>
74523>>>>>    Function ComAutoApplyNewThreads Returns Boolean
74525>>>>>        Boolean retVal
74525>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
74526>>>>>        Function_Return retVal
74527>>>>>    End_Function
74528>>>>>
74528>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
74530>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
74531>>>>>    End_Procedure
74532>>>>>
74532>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
74534>>>>>        Handle hDispatchDriver
74534>>>>>        Boolean retVal
74534>>>>>        Get phDispatchDriver to hDispatchDriver
74535>>>>>        Send PrepareParams to hDispatchDriver 2
74536>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74537>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74538>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
74539>>>>>        Function_Return retVal
74540>>>>>    End_Function
74541>>>>>
74541>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
74543>>>>>        Handle hDispatchDriver
74543>>>>>        Get phDispatchDriver to hDispatchDriver
74544>>>>>        Send PrepareParams to hDispatchDriver 1
74545>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74546>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
74547>>>>>    End_Procedure
74548>>>>>
74548>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
74550>>>>>        Handle hDispatchDriver
74550>>>>>        Get phDispatchDriver to hDispatchDriver
74551>>>>>        Send PrepareParams to hDispatchDriver 2
74552>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74553>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
74554>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
74555>>>>>    End_Procedure
74556>>>>>
74556>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
74558>>>>>        Handle hDispatchDriver
74558>>>>>        Get phDispatchDriver to hDispatchDriver
74559>>>>>        Send PrepareParams to hDispatchDriver 1
74560>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74561>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
74562>>>>>    End_Procedure
74563>>>>>
74563>>>>>    Procedure ComRemoveAllWindows
74565>>>>>        Handle hDispatchDriver
74565>>>>>        Get phDispatchDriver to hDispatchDriver
74566>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
74567>>>>>    End_Procedure
74568>>>>>
74568>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
74570>>>>>        Handle hDispatchDriver
74570>>>>>        Get phDispatchDriver to hDispatchDriver
74571>>>>>        Send PrepareParams to hDispatchDriver 2
74572>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
74573>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
74574>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
74575>>>>>    End_Procedure
74576>>>>>
74576>>>>>    Procedure ComRemoveWindowClass String llClassName
74578>>>>>        Handle hDispatchDriver
74578>>>>>        Get phDispatchDriver to hDispatchDriver
74579>>>>>        Send PrepareParams to hDispatchDriver 1
74580>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
74581>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
74582>>>>>    End_Procedure
74583>>>>>
74583>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
74585>>>>>        Handle hDispatchDriver
74585>>>>>        Variant retVal
74585>>>>>        Get phDispatchDriver to hDispatchDriver
74586>>>>>        Send PrepareParams to hDispatchDriver 2
74587>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
74588>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
74589>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
74590>>>>>        Function_Return retVal
74591>>>>>    End_Function
74592>>>>>
74592>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
74594>>>>>        Handle hDispatchDriver
74594>>>>>        Variant retVal
74594>>>>>        Get phDispatchDriver to hDispatchDriver
74595>>>>>        Send PrepareParams to hDispatchDriver 1
74596>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
74597>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
74598>>>>>        Function_Return retVal
74599>>>>>    End_Function
74600>>>>>
74600>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74602>>>>>        Handle hDispatchDriver
74602>>>>>        OLE_COLOR retVal
74602>>>>>        Get phDispatchDriver to hDispatchDriver
74603>>>>>        Send PrepareParams to hDispatchDriver 1
74604>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74605>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
74606>>>>>        Function_Return retVal
74607>>>>>    End_Function
74608>>>>>
74608>>>>>    Procedure ComExcludeModule String llModuleName
74610>>>>>        Handle hDispatchDriver
74610>>>>>        Get phDispatchDriver to hDispatchDriver
74611>>>>>        Send PrepareParams to hDispatchDriver 1
74612>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
74613>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
74614>>>>>    End_Procedure
74615>>>>>
74615>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
74617>>>>>        Handle hDispatchDriver
74617>>>>>        Variant retVal
74617>>>>>        Get phDispatchDriver to hDispatchDriver
74618>>>>>        Send PrepareParams to hDispatchDriver 2
74619>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74620>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74621>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
74622>>>>>        Function_Return retVal
74623>>>>>    End_Function
74624>>>>>
74624>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
74626>>>>>        Handle hDispatchDriver
74626>>>>>        Get phDispatchDriver to hDispatchDriver
74627>>>>>        Send PrepareParams to hDispatchDriver 2
74628>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74629>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
74630>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
74631>>>>>    End_Procedure
74632>>>>>
74632>>>>>    Procedure ComAboutBox
74634>>>>>        Handle hDispatchDriver
74634>>>>>        Get phDispatchDriver to hDispatchDriver
74635>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
74636>>>>>    End_Procedure
74637>>>>>End_Class
74638>>>>>
74638>>>>>// CLSID: {C0DE2200-4463-4030-B324-AC6A8075FEC8}
74638>>>>>// Event interface for SkinFramework Control
74638>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
74639>>>>>
74639>>>>>    Procedure RegisterComEvents
74641>>>>>    End_Procedure
74642>>>>>End_Class
74643>>>>>
74643>>>>>// CoClass
74643>>>>>// ProgID: Codejock.SkinFramework.22.0.0
74643>>>>>// CLSID: {C0DE2200-2217-42EE-B1B0-82C890431F17}
74643>>>>>// SkinFramework Control
74643>>>>>Class cCJComSkinFramework is a cComActiveXControl
74644>>>>>    Import_Class_Protocol cCJ_DSkinFramework
74645>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
74646>>>>>
74646>>>>>    Procedure Construct_Object
74648>>>>>        Forward Send Construct_Object
74650>>>>>        Set psProgID to "{C0DE2200-2217-42EE-B1B0-82C890431F17}"
74651>>>>>        Set psEventId to "{C0DE2200-4463-4030-B324-AC6A8075FEC8}"
74652>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2022 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v22.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
74653>>>>>        Set peAutoCreate to acAutoCreate
74654>>>>>    End_Procedure
74655>>>>>End_Class
74656>>>>>
74656>>>>>// CLSID: {C0DE2200-CA9A-4AA9-8601-0AB7F551AA3D}
74656>>>>>// SkinFramework Global Settings
74656>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
74657>>>>>
74657>>>>>    Function ComLicense Returns String
74659>>>>>        String retVal
74659>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
74660>>>>>        Function_Return retVal
74661>>>>>    End_Function
74662>>>>>
74662>>>>>    Procedure Set ComLicense String value
74664>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
74665>>>>>    End_Procedure
74666>>>>>
74666>>>>>    Function ComTitle Returns String
74668>>>>>        String retVal
74668>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
74669>>>>>        Function_Return retVal
74670>>>>>    End_Function
74671>>>>>
74671>>>>>    Procedure Set ComTitle String value
74673>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
74674>>>>>    End_Procedure
74675>>>>>
74675>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74675>>>>>    Function ComUseLegacyCore Returns Boolean
74677>>>>>        Boolean retVal
74677>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
74678>>>>>        Function_Return retVal
74679>>>>>    End_Function
74680>>>>>
74680>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74680>>>>>    Procedure Set ComUseLegacyCore Boolean value
74682>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
74683>>>>>    End_Procedure
74684>>>>>
74684>>>>>    Function ComVersion Returns String
74686>>>>>        Handle hDispatchDriver
74686>>>>>        String retVal
74686>>>>>        Get phDispatchDriver to hDispatchDriver
74687>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
74688>>>>>        Function_Return retVal
74689>>>>>    End_Function
74690>>>>>
74690>>>>>    Function ComUnicode Returns Boolean
74692>>>>>        Handle hDispatchDriver
74692>>>>>        Boolean retVal
74692>>>>>        Get phDispatchDriver to hDispatchDriver
74693>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
74694>>>>>        Function_Return retVal
74695>>>>>    End_Function
74696>>>>>
74696>>>>>    Function ComOcxPath Returns String
74698>>>>>        Handle hDispatchDriver
74698>>>>>        String retVal
74698>>>>>        Get phDispatchDriver to hDispatchDriver
74699>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
74700>>>>>        Function_Return retVal
74701>>>>>    End_Function
74702>>>>>End_Class
74703>>>>>
74703>>>>>// CoClass
74703>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.22.0.0
74703>>>>>// CLSID: {C0DE2200-F744-4373-B38D-29CE83EF0EE5}
74703>>>>>// SkinFramework Global Settings
74703>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
74704>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
74705>>>>>
74705>>>>>    Procedure Construct_Object
74707>>>>>        Forward Send Construct_Object
74709>>>>>        Set psProgID to "{C0DE2200-F744-4373-B38D-29CE83EF0EE5}"
74710>>>>>        Set peAutoCreate to acNoAutoCreate
74711>>>>>    End_Procedure
74712>>>>>End_Class
74713>>>>>
74713>>>>>// CLSID: {C0DE2200-1038-498E-A936-361F08B4C4AA}
74713>>>>>Class cCJSkinIniFile is a cComAutomationObject
74714>>>>>
74714>>>>>    Function ComColorScheme Returns String
74716>>>>>        String retVal
74716>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74717>>>>>        Function_Return retVal
74718>>>>>    End_Function
74719>>>>>
74719>>>>>    Procedure Set ComColorScheme String value
74721>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74722>>>>>    End_Procedure
74723>>>>>
74723>>>>>    Function ComFontSize Returns String
74725>>>>>        String retVal
74725>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74726>>>>>        Function_Return retVal
74727>>>>>    End_Function
74728>>>>>
74728>>>>>    Procedure Set ComFontSize String value
74730>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74731>>>>>    End_Procedure
74732>>>>>
74732>>>>>    Function ComIniFileName Returns String
74734>>>>>        String retVal
74734>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
74735>>>>>        Function_Return retVal
74736>>>>>    End_Function
74737>>>>>
74737>>>>>    Procedure Set ComIniFileName String value
74739>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
74740>>>>>    End_Procedure
74741>>>>>End_Class
74742>>>>>
74742>>>>>// CLSID: {C0DE2200-4834-499E-95B4-30E0C3F43A10}
74742>>>>>Class cCJSkinDescription is a cComAutomationObject
74743>>>>>
74743>>>>>    Function ComName Returns String
74745>>>>>        String retVal
74745>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74746>>>>>        Function_Return retVal
74747>>>>>    End_Function
74748>>>>>
74748>>>>>    Procedure Set ComName String value
74750>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74751>>>>>    End_Procedure
74752>>>>>
74752>>>>>    Function ComPath Returns String
74754>>>>>        String retVal
74754>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74755>>>>>        Function_Return retVal
74756>>>>>    End_Function
74757>>>>>
74757>>>>>    Procedure Set ComPath String value
74759>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74760>>>>>    End_Procedure
74761>>>>>
74761>>>>>    Function ComCount Returns Integer
74763>>>>>        Handle hDispatchDriver
74763>>>>>        Integer retVal
74763>>>>>        Get phDispatchDriver to hDispatchDriver
74764>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74765>>>>>        Function_Return retVal
74766>>>>>    End_Function
74767>>>>>
74767>>>>>    Function ComIniFile Integer llIndex Returns Variant
74769>>>>>        Handle hDispatchDriver
74769>>>>>        Variant retVal
74769>>>>>        Get phDispatchDriver to hDispatchDriver
74770>>>>>        Send PrepareParams to hDispatchDriver 1
74771>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74772>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74773>>>>>        Function_Return retVal
74774>>>>>    End_Function
74775>>>>>
74775>>>>>    Function Com_NewEnum Returns Variant
74777>>>>>        Handle hDispatchDriver
74777>>>>>        Variant retVal
74777>>>>>        Get phDispatchDriver to hDispatchDriver
74778>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74779>>>>>        Function_Return retVal
74780>>>>>    End_Function
74781>>>>>End_Class
74782>>>>>
74782>>>>>// CLSID: {C0DE2200-FB37-4B08-A2B9-F6F8B253D697}
74782>>>>>Class cCJSkinDescriptions is a cComAutomationObject
74783>>>>>
74783>>>>>    Function ComCount Returns Integer
74785>>>>>        Handle hDispatchDriver
74785>>>>>        Integer retVal
74785>>>>>        Get phDispatchDriver to hDispatchDriver
74786>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74787>>>>>        Function_Return retVal
74788>>>>>    End_Function
74789>>>>>
74789>>>>>    Function ComSkin Integer llIndex Returns Variant
74791>>>>>        Handle hDispatchDriver
74791>>>>>        Variant retVal
74791>>>>>        Get phDispatchDriver to hDispatchDriver
74792>>>>>        Send PrepareParams to hDispatchDriver 1
74793>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74794>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74795>>>>>        Function_Return retVal
74796>>>>>    End_Function
74797>>>>>
74797>>>>>    Function Com_NewEnum Returns Variant
74799>>>>>        Handle hDispatchDriver
74799>>>>>        Variant retVal
74799>>>>>        Get phDispatchDriver to hDispatchDriver
74800>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74801>>>>>        Function_Return retVal
74802>>>>>    End_Function
74803>>>>>End_Class
74804>>>>>
74804>>>>>// CLSID: {C0DE2200-C56F-43C0-BCF1-8193B35FE4C4}
74804>>>>>Class cCJSkinSchema is a cComAutomationObject
74805>>>>>
74805>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74807>>>>>        Handle hDispatchDriver
74807>>>>>        OLE_COLOR retVal
74807>>>>>        Get phDispatchDriver to hDispatchDriver
74808>>>>>        Send PrepareParams to hDispatchDriver 1
74809>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74810>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
74811>>>>>        Function_Return retVal
74812>>>>>    End_Function
74813>>>>>End_Class
74814>>>Use cApplication.pkg
74814>>>
74814>>>Struct tSkinInformation
74814>>>    String sName     // description of the skin
74814>>>    String sSkinfile // file path. Can be relative or full
74814>>>    String sSkinIni  // section name
74814>>>End_Struct
74814>>>
74814>>>
74814>>>Class cCJSkinFramework is a cCJComSkinFramework
74815>>>    
74815>>>    Procedure Construct_Object
74817>>>        Forward Send Construct_Object
74819>>>        
74819>>>        Property String psSkinFile ""
74820>>>        Property String psSkinIni ""
74821>>>        Property Boolean pbLoadPreference False
74822>>>        
74822>>>        Set peAutoCreate to acAutoCreate
74823>>>        
74823>>>        Move Self to ghoSkinFramework
74824>>>    End_Procedure
74825>>>    
74825>>>    // return the default skin path, which is the programs directory.
74825>>>    // This requires an application object.
74825>>>    // If you want to different skin path, override this.
74825>>>    Function SkinPath Returns String
74827>>>        String sPath sPaths
74827>>>        Handle hoWorkspace
74827>>>        If ghoApplication Begin
74829>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74830>>>            Get psProgramPath of hoWorkspace to sPaths
74831>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
74832>>>        End
74832>>>>
74832>>>        Else Begin
74833>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74834>>>>
74834>>>        End
74834>>>>
74834>>>        Function_Return sPath
74835>>>    End_Function
74836>>>    
74836>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
74836>>>    // returns itself. If it is not, it uses SkinPath to get the path.
74836>>>    Function SkinQFile Returns String
74838>>>        String sFile sPath sSep
74838>>>        Boolean bQualified
74838>>>        Get psSkinFile to sFile
74839>>>        If not (IsFileNameQualified(sFile)) Begin
74841>>>            Get SkinPath to sPath
74842>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74843>>>            Move (sPath - sSep - sFile) to sFile
74844>>>        End
74844>>>>
74844>>>        Function_Return sFile
74845>>>    End_Function
74846>>>    
74846>>>    // defines the default VDF window class mapping.
74846>>>    Procedure OnAddVDFWindowClasses
74848>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
74849>>>        Send ComAddWindowClass "DFentry"                 "Edit"
74850>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
74851>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
74852>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
74853>>>        Send ComAddWindowClass "DFformlist"              "Edit"
74854>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
74855>>>        Send ComAddWindowClass "DFbutton"                "Button"
74856>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
74857>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
74858>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
74859>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
74860>>>        Send ComAddWindowClass "DFedit"                  "edit"
74861>>>        Send ComAddWindowClass "DFlistedit"              "edit"
74862>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
74863>>>        Send ComAddWindowClass "DFgroup"                 "Button"
74864>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74865>>>        // External class
74865>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74866>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74867>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74868>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74869>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74870>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74871>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74872>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74873>>>    End_Procedure
74874>>>    
74874>>>    // Used to support developer designed class mappings (e.g. COM controls)
74874>>>    Procedure OnAddCustomWindowClasses
74876>>>    End_Procedure
74877>>>    
74877>>>    // called when object is created during end_construct_object.
74877>>>    Procedure OnCreate
74879>>>        Integer iOpts
74879>>>        Boolean bUseWindowsFont
74879>>>        Forward Send OnCreate
74881>>>        
74881>>>        // if we are using the windows fonts we will disable the apply metrics which
74881>>>        // never really looked good anyway. This test only exists or legacy purposes
74881>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74882>>>        If bUseWindowsFont Begin
74884>>>            Get ComApplyOptions to iOpts
74885>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74886>>>        End
74886>>>>
74886>>>        
74886>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74886>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74886>>>        // and this was the suggested workaround.
74886>>>        Set ComAutoApplyNewThreads to False
74887>>>        
74887>>>        Send OnAddVDFWindowClasses
74888>>>        Send OnAddCustomWindowClasses
74889>>>        
74889>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74889>>>        If (pbLoadPreference(Self)) Begin
74891>>>            Send LoadSkinPreference
74892>>>        End
74892>>>>
74892>>>        // if a skin file name exists, we apply the skin.
74892>>>        If (psSkinFile(Self)<>"") Begin
74894>>>            Send ApplySkin
74895>>>        End
74895>>>>
74895>>>    End_Procedure
74896>>>    
74896>>>    // called by framework as part of application exit.
74896>>>    Procedure Broadcast_Notify_Exit_Application
74898>>>        Send Notify_Exit_Application
74899>>>    End_Procedure
74900>>>    
74900>>>    Procedure Notify_Exit_Application
74902>>>        If (pbLoadPreference(Self)) Begin
74904>>>            Send SaveSkinPreference
74905>>>        End
74905>>>>
74905>>>    End_Procedure
74906>>>    
74906>>>    Procedure NotifyPreApplySkin
74908>>>        Broadcast Send OnPreApplySkin of Desktop True
74910>>>    End_Procedure
74911>>>    
74911>>>    Procedure NotifyPostApplySkin
74913>>>        Broadcast Send OnPostApplySkin of Desktop True
74915>>>    End_Procedure
74916>>>    
74916>>>    // returns an array of all skins in the path. If path is "", use the default path.
74916>>>    // If the default path is used, returns the file names as relative names, else use full path.
74916>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74918>>>        tSkinInformation[] Skins
74918>>>        tSkinInformation[] Skins
74919>>>        String sSkinName sSkinFile sDefaultPath sSep
74919>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74919>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74919>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74919>>>        Integer iPos iDfltLen
74919>>>        Boolean bUseRelativePath
74919>>>        
74919>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74920>>>        
74920>>>        Get SkinPath to sDefaultPath
74921>>>        If (sPath="") Begin
74923>>>            Move sDefaultPath to sPath
74924>>>        End
74924>>>>
74924>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74925>>>        Move (Length(sDefaultPath)) to iDfltLen
74926>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74927>>>        
74927>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74928>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74930>>>            
74930>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74931>>>            Get Create U_cCJSkinDescription to hSkinDescription
74932>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74933>>>            
74933>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74934>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74935>>>            
74935>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74941>>>>
74941>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74942>>>                Set pvComObject of hSkinDescription to vSkinDescription
74943>>>                
74943>>>                Get ComCount of hSkinDescription to iNumSkins
74944>>>                
74944>>>                For iSkinsCount from 0 to (iNumSkins-1)
74950>>>>
74950>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74951>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74952>>>                    
74952>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74953>>>                    Get ComPath of hSkinDescription to sSkinFile
74954>>>                    If bUseRelativePath Begin
74956>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74957>>>                        If iPos Begin
74959>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74960>>>                            While (Left(sSkinFile,1)=sSep)
74964>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74965>>>                            Loop
74966>>>>
74966>>>                        End
74966>>>>
74966>>>                    End
74966>>>>
74966>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74967>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74968>>>                    
74968>>>                    Increment iArrayItem
74969>>>                Loop
74970>>>>
74970>>>            Loop
74971>>>>
74971>>>            
74971>>>            Send Destroy of hSkinDescriptions
74972>>>            Send Destroy of hSkinDescription
74973>>>            Send Destroy of hSkinIniFile
74974>>>            
74974>>>        End
74974>>>>
74974>>>        Function_Return Skins
74975>>>    End_Function
74976>>>    
74976>>>    // Save the skin preference. This requires an application object.
74976>>>    // Only do this if the application object allows it.
74976>>>    // This is called during startup if pbLoadPreference is True
74976>>>    // Suitable for override
74976>>>    Procedure SaveSkinPreference
74978>>>        String sSkin sIni
74978>>>        If ghoApplication Begin
74980>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74982>>>                Get psSkinFile to sSkin
74983>>>                Get psSkinIni to sIni
74984>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74985>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74986>>>            End
74986>>>>
74986>>>        End
74986>>>>
74986>>>        Else Begin
74987>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74988>>>>
74988>>>        End
74988>>>>
74988>>>    End_Procedure
74989>>>    
74989>>>    // Load the skin preference. This requires an application object.
74989>>>    // Only do this if the application object allows it.
74989>>>    // This is called during startup if pbLoadPreference is True
74989>>>    // Suitable for override
74989>>>    Procedure LoadSkinPreference
74991>>>        String sSkin sIni
74991>>>        Boolean bExists
74991>>>        If ghoApplication Begin
74993>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74995>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74996>>>                If bExists Begin
74998>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74999>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
75000>>>                    Set psSkinFile to sSkin
75001>>>                    Set psSkinIni to sIni
75002>>>                End
75002>>>>
75002>>>            End
75002>>>>
75002>>>        End
75002>>>>
75002>>>        Else Begin
75003>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
75004>>>>
75004>>>        End
75004>>>>
75004>>>    End_Procedure
75005>>>    
75005>>>    // Can be called to apply the current skin.
75005>>>    Procedure ApplySkin
75007>>>        Boolean bOk
75007>>>        String sSkin sIni
75007>>>        If (IsComObjectCreated(Self)) Begin
75009>>>            Get SkinQFile to sSkin
75010>>>            Get psSkinIni to sIni
75011>>>            
75011>>>            Send NotifyPreApplySkin
75012>>>            // when skins are used we don't want to use built in Visual Styles
75012>>>            Send EnableVisualStyles of Desktop (sSkin="")
75013>>>            Get ComLoadSkin sSkin sIni to bOK
75014>>>            If (sSkin<>"" and not(bOk)) Begin
75016>>>                // if not ok, no skin was appied. Enable visual styles
75016>>>                Send EnableVisualStyles of Desktop True
75017>>>            End
75017>>>>
75017>>>            Send NotifyPostApplySkin
75018>>>        End
75018>>>>
75018>>>    End_Procedure
75019>>>    
75019>>>    
75019>>>End_Class
75020>Use cCJCommandBarSystem.pkg                      
75020>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
75020>>>//****************************************************************************
75020>>>// $Module type: Class
75020>>>// $Module name: cSQLConnectionIniFile.pkg
75020>>>//
75020>>>// $Author     : Nils Svedmyr, RDC Tools International.
75020>>>// Copyright (c) 2012 RDC Tools International
75020>>>// E-mail      : support@rdctools.com
75020>>>// Web-site    : http://www.rdctools.com
75020>>>//
75020>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
75020>>>//
75020>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
75020>>>//               properties of that object.
75020>>>//
75020>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
75020>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
75020>>>// This is free software; you can redistribute it and/or modify it under the terms of the
75020>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
75020>>>// in the help folder for more details.
75020>>>//
75020>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
75020>>>>>//****************************************************************************
75020>>>>>// $Module type: Include file
75020>>>>>// $Module name: cSQLConnectionIniFile.inc
75020>>>>>//
75020>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
75020>>>>>// Copyright (c) 2012 RDC Tools International
75020>>>>>// E-mail      : support@rdctools.com
75020>>>>>// Web-site    : http://www.rdctools.com
75020>>>>>//
75020>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
75020>>>>>//
75020>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
75020>>>>>//
75020>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
75020>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
75020>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
75020>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
75020>>>>>// in the help folder for more details.
75020>>>>>//
75020>>>>>Use Winkern.pkg
75020>>>>>Use cIniFile.pkg
75020>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCryptographerEx.pkg)
75020>>>>>>>Use VdfBase.pkg
75020>>>>>>>
75020>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 23.0\Pkg\CryptographerConstants.pkg)
75020>>>>>>>>>//   Author  : Ulbe Stellema
75020>>>>>>>>>// Algorithm classes
75020>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
75020>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
75020>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
75020>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
75020>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
75020>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
75020>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
75020>>>>>>>>>
75020>>>>>>>>>// Algorithm types
75020>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
75020>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
75020>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
75020>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
75020>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
75020>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
75020>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
75020>>>>>>>>>
75020>>>>>>>>>// Generic sub-ids
75020>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
75020>>>>>>>>>
75020>>>>>>>>>// RSA sub-ids
75020>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
75020>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
75020>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
75020>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
75020>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
75020>>>>>>>>>
75020>>>>>>>>>// DSS sub-ids
75020>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
75020>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
75020>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
75020>>>>>>>>>
75020>>>>>>>>>// DES sub_ids
75020>>>>>>>>>Define ALG_SID_DES                      for 1
75020>>>>>>>>>Define ALG_SID_3DES                     for 3
75020>>>>>>>>>Define ALG_SID_DESX                     for 4
75020>>>>>>>>>Define ALG_SID_IDEA                     for 5
75020>>>>>>>>>Define ALG_SID_CAST                     for 6
75020>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
75020>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
75020>>>>>>>>>Define ALG_SID_3DES_112                 for 9
75020>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
75020>>>>>>>>>Define ALG_SID_RC5                      for 13
75020>>>>>>>>>Define ALG_SID_AES_128                  for 14
75020>>>>>>>>>Define ALG_SID_AES_192                  for 15
75020>>>>>>>>>Define ALG_SID_AES_256                  for 16
75020>>>>>>>>>Define ALG_SID_AES                      for 17
75020>>>>>>>>>
75020>>>>>>>>>// Fortezza sub-ids
75020>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
75020>>>>>>>>>Define ALG_SID_TEK                      for 11
75020>>>>>>>>>
75020>>>>>>>>>// RC2 sub-ids
75020>>>>>>>>>Define ALG_SID_RC2                      for 2
75020>>>>>>>>>
75020>>>>>>>>>// Stream cipher sub-ids
75020>>>>>>>>>Define ALG_SID_RC4                      for 1
75020>>>>>>>>>Define ALG_SID_SEAL                     for 2
75020>>>>>>>>>
75020>>>>>>>>>// Diffie-Hellman sub-ids
75020>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
75020>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
75020>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
75020>>>>>>>>>Define ALG_SID_KEA                      for 4
75020>>>>>>>>>
75020>>>>>>>>>// Hash sub ids
75020>>>>>>>>>Define ALG_SID_MD2                      for 1
75020>>>>>>>>>Define ALG_SID_MD4                      for 2
75020>>>>>>>>>Define ALG_SID_MD5                      for 3
75020>>>>>>>>>Define ALG_SID_SHA                      for 4
75020>>>>>>>>>Define ALG_SID_SHA1                     for 4
75020>>>>>>>>>Define ALG_SID_MAC                      for 5
75020>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
75020>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
75020>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
75020>>>>>>>>>Define ALG_SID_HMAC                     for 9
75020>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
75020>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
75020>>>>>>>>>Define ALG_SID_SHA_256                  for 12
75020>>>>>>>>>Define ALG_SID_SHA_384                  for 13
75020>>>>>>>>>Define ALG_SID_SHA_512                  for 14
75020>>>>>>>>>
75020>>>>>>>>>// secure channel sub ids
75020>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
75020>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
75020>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
75020>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
75020>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
75020>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
75020>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
75020>>>>>>>>>
75020>>>>>>>>>// algorithm identifier definitions
75020>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
75020>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
75020>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
75020>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
75020>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
75020>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
75020>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
75020>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
75020>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
75020>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
75020>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
75020>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
75020>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
75020>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
75020>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
75020>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
75020>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
75020>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
75020>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
75020>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
75020>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
75020>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
75020>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
75020>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
75020>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
75020>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
75020>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
75020>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
75020>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
75020>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
75020>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
75020>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
75020>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
75020>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
75020>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
75020>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
75020>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
75020>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
75020>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
75020>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
75020>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
75020>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
75020>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
75020>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
75020>>>>>>>>>
75020>>>>>>>>>// Providers
75020>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
75020>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
75020>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
75020>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
75020>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
75020>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
75020>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
75020>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
75020>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
75020>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
75020>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
75020>>>>>>>>>
75020>>>>>>>>>// dwFlags definitions for CryptAcquireContext
75020>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
75020>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
75020>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
75020>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
75020>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
75020>>>>>>>>>
75020>>>>>>>>>// dwFlag definitions for CryptGenKey
75020>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
75020>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
75020>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
75020>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
75020>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
75020>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
75020>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
75020>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
75020>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
75020>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
75020>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
75020>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
75020>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
75020>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
75020>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
75020>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
75020>>>>>>>>>
75020>>>>>>>>>// Provider types
75020>>>>>>>>>Define PROV_RSA_FULL                    for 1
75020>>>>>>>>>Define PROV_RSA_SIG                     for 2
75020>>>>>>>>>Define PROV_DSS                         for 3
75020>>>>>>>>>Define PROV_FORTEZZA                    for 4
75020>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
75020>>>>>>>>>Define PROV_SSL                         for 6
75020>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
75020>>>>>>>>>Define PROV_DSS_DH                      for 13
75020>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
75020>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
75020>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
75020>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
75020>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
75020>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
75020>>>>>>>>>Define PROV_RNG                         for 21
75020>>>>>>>>>Define PROV_INTEL_SEC                   for 22
75020>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
75020>>>>>>>>>Define PROV_RSA_AES                     for 24
75020>>>>>>>>>
75020>>>>>>>>>// KP_MODE
75020>>>>>>>>>// KP_MODE
75020>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
75020>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
75020>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
75020>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
75020>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
75020>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
75020>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
75020>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
75020>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
75020>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
75020>>>>>>>>>
75020>>>>>>>>>// dwParam definitions for CryptGetKeyParam
75020>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
75020>>>>>>>>>Define KP_SALT                          for 2       // Salt value
75020>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
75020>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
75020>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
75020>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
75020>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
75020>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
75020>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
75020>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
75020>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
75020>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
75020>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
75020>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
75020>>>>>>>>>Define KP_Y                             for 15      // Y value
75020>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
75020>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
75020>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
75020>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
75020>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
75020>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
75020>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
75020>>>>>>>>>Define KP_RP                            for 23
75020>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
75020>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
75020>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
75020>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
75020>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
75020>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
75020>>>>>>>>>Define KP_KEYVAL                        for 30
75020>>>>>>>>>Define KP_ADMIN_PIN                     for 31
75020>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
75020>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
75020>>>>>>>>>Define KP_PREHASH                       for 34
75020>>>>>>>>>Define KP_ROUNDS                        for 35
75020>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
75020>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
75020>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
75020>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
75020>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
75020>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
75020>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
75020>>>>>>>>>
75020>>>>>>>>>// dwParam definitions for CryptGetHashParam
75020>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
75020>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
75020>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
75020>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
75020>>>>>>>>>
75020>>>>>>>>>// key BLOB types
75020>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
75020>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
75020>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
75020>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
75020>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
75020>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
75020>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
75020>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
75020>>>>>>>>>
75020>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
75020>>>>>>>>>
75020>>>>>>>>>// KP_PADDING
75020>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
75020>>>>>>>>>Define RANDOM_PADDING                   for 2
75020>>>>>>>>>Define ZERO_PADDING                     for 3
75020>>>>>>>>>
75020>>>>>>>>>//  Structure cryptimportkey
75020>>>>>>>>>Struct PUBLICKEYSTRUC
75020>>>>>>>>>    UChar    bType
75020>>>>>>>>>    UChar    bVersion
75020>>>>>>>>>    UShort   reserved
75020>>>>>>>>>    UInteger aiKeyAlg
75020>>>>>>>>>End_Struct
75020>>>>>>>>>
75020>>>>>>>>>Struct tPLAINTEXTKEYBLOB
75020>>>>>>>>>    PUBLICKEYSTRUC hdr
75020>>>>>>>>>    PUBLICKEYSTRUC hdr
75020>>>>>>>>>    UInteger       dwKeySize
75020>>>>>>>>>//    UChar[]        rgbKeyData
75020>>>>>>>>>End_Struct
75020>>>>>>>>>
75020>>>>>>>>>
75020>>>>>>>>>
75020>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
75020>>>>>>>>>Struct HMAC_INFO
75020>>>>>>>>>    UInteger HashAlgid
75020>>>>>>>>>    Pointer pbInnerString
75020>>>>>>>>>    DWord cbInnerString
75020>>>>>>>>>    Pointer pbOuterString
75020>>>>>>>>>    DWord cbOuterString
75020>>>>>>>>>End_Struct
75020>>>>>>>>>
75020>>>>>>>>>Struct BLOBHEADER
75020>>>>>>>>>    UChar   bType
75020>>>>>>>>>    UChar   bVersion
75020>>>>>>>>>    Short   reserved
75020>>>>>>>>>    Integer aiKeyAlg
75020>>>>>>>>>End_Struct
75020>>>>>>>>>
75020>>>>>>>>>Struct CryptoBlob
75020>>>>>>>>>    BLOBHEADER  header
75020>>>>>>>>>    BLOBHEADER  header
75020>>>>>>>>>    Integer     cbKeySize
75020>>>>>>>>>    UChar[32]   rgbKeyData
75020>>>>>>>>>End_Struct
75020>>>>>>>>>
75020>>>>>>>>>
75020>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
75020>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
75021>>>>>>>>>
75021>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
75021>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
75023>>>>>>>>>    
75023>>>>>>>>>    Boolean bResult
75023>>>>>>>>>    UWide   uwContainer uwProvider
75023>>>>>>>>>    UWide   uwContainer uwProvider
75023>>>>>>>>>
75023>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
75024>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
75025>>>>>>>>>    
75025>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
75026>>>>>>>>>
75026>>>>>>>>>    Function_Return bResult
75027>>>>>>>>>End_Function
75028>>>>>>>>>
75028>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
75029>>>>>>>>>
75029>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
75030>>>>>>>>>
75030>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
75031>>>>>>>>>
75031>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
75032>>>>>>>>>
75032>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
75033>>>>>>>>>
75033>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
75034>>>>>>>>>
75034>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
75035>>>>>>>>>
75035>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
75036>>>>>>>>>
75036>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
75037>>>>>>>>>    
75037>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
75038>>>>>>>>>
75038>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
75039>>>>>>>>>
75039>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
75040>>>>>>>>>
75040>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
75041>>>>>>>>>    
75041>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
75042>>>>>>>>>    
75042>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
75043>>>>>>>>>    
75043>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
75044>>>>>>>
75044>>>>>>>Class cCryptographerEx is a cObject
75045>>>>>>>    
75045>>>>>>>    Procedure Construct_Object
75047>>>>>>>        Forward Send Construct_Object
75049>>>>>>>        
75049>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
75050>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
75051>>>>>>>        Property Integer    piCipher    CALG_RC4
75052>>>>>>>        Property Integer    piHash      CALG_MD5
75053>>>>>>>        
75053>>>>>>>        // Private properties
75053>>>>>>>        Property Handle     Private_phProv
75054>>>>>>>        
75054>>>>>>>        // Block cipher properties
75054>>>>>>>        Property UChar[]    paKey
75055>>>>>>>        Property UChar[]    paIV
75056>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
75057>>>>>>>        Property Integer    piKeyType       CALG_AES_256
75058>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
75059>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
75060>>>>>>>        Property Integer    piBlockSize     16
75061>>>>>>>    End_Procedure
75062>>>>>>>    
75062>>>>>>>    
75062>>>>>>>    // Acquire key container handle
75062>>>>>>>    Function AcquireContext Returns Handle
75064>>>>>>>        Integer iProvider
75064>>>>>>>        WString wProvider
75064>>>>>>>        Handle hProv
75064>>>>>>>        Boolean bOk
75064>>>>>>>        Pointer pProv
75064>>>>>>>        
75064>>>>>>>        Move 0 to hProv
75065>>>>>>>        Get piProvider to iProvider
75066>>>>>>>        Get psProvider to wProvider
75067>>>>>>>        
75067>>>>>>>        //  Determine address to be passed as provider
75067>>>>>>>        If (Trim(wProvider) <> "") Begin
75069>>>>>>>            Move (AddressOf(wProvider)) to pProv
75070>>>>>>>        End
75070>>>>>>>>
75070>>>>>>>        Else Begin
75071>>>>>>>            Move 0 to pProv
75072>>>>>>>        End
75072>>>>>>>>
75072>>>>>>>        
75072>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
75072>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
75073>>>>>>>        If (not(bOk) or hProv = 0) Begin
75075>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
75076>>>>>>>        End
75076>>>>>>>>
75076>>>>>>>        
75076>>>>>>>        If (not(bOk) or hProv = 0) Begin
75078>>>>>>>            // Fallback to original
75078>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
75079>>>>>>>            
75079>>>>>>>            If (not(bOk) or hProv = 0) Begin
75081>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
75082>>>>>>>            End
75082>>>>>>>>
75082>>>>>>>        End
75082>>>>>>>>
75082>>>>>>>        Set Private_phProv to hProv
75083>>>>>>>        
75083>>>>>>>        Function_Return hProv
75084>>>>>>>    End_Function
75085>>>>>>>    
75085>>>>>>>    // Releases key container handle
75085>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
75087>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
75088>>>>>>>    End_Function
75089>>>>>>>    
75089>>>>>>>    // Creates hash object
75089>>>>>>>    Function CreateHash Handle hProv Returns Handle
75091>>>>>>>        Integer iAlgorithm
75091>>>>>>>        Handle hHash
75091>>>>>>>        Boolean bOk
75091>>>>>>>        
75091>>>>>>>        Move 0 to hHash
75092>>>>>>>        Get piHash to iAlgorithm
75093>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
75094>>>>>>>        
75094>>>>>>>        Function_Return hHash
75095>>>>>>>    End_Function
75096>>>>>>>    
75096>>>>>>>    // Destroys the hash object
75096>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
75098>>>>>>>        Function_Return (CryptDestroyHash(hHash))
75099>>>>>>>    End_Function
75100>>>>>>>    
75100>>>>>>>    // Adds data to hash object
75100>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
75102>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
75103>>>>>>>    End_Function
75104>>>>>>>    
75104>>>>>>>    // Generates session key
75104>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
75106>>>>>>>        Integer iAlgorithm
75106>>>>>>>        Handle hKey
75106>>>>>>>        Boolean bOk
75106>>>>>>>        
75106>>>>>>>        Move 0 to hKey
75107>>>>>>>        Get piCipher to iAlgorithm
75108>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
75109>>>>>>>        
75109>>>>>>>        Function_Return hKey
75110>>>>>>>    End_Function
75111>>>>>>>    
75111>>>>>>>    // Imports a plain text key
75111>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
75113>>>>>>>        tPLAINTEXTKEYBLOB blobhead
75113>>>>>>>        tPLAINTEXTKEYBLOB blobhead
75113>>>>>>>        Boolean   bSuccess
75113>>>>>>>        Handle    hKey
75113>>>>>>>        Integer   iHeadSize iKeySize
75113>>>>>>>        UChar[]   ucaKeyblob
75114>>>>>>>        Integer iVoid
75114>>>>>>>        
75114>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
75115>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
75116>>>>>>>        
75116>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
75117>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
75118>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
75119>>>>>>>        Move iKeySize           to blobhead.dwKeySize
75120>>>>>>>        
75120>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
75121>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
75122>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
75123>>>>>>>        
75123>>>>>>>        Move 0 to hKey
75124>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
75125>>>>>>>        If (not(bSuccess)) Begin
75127>>>>>>>            Move (ShowLastError()) to iVoid
75128>>>>>>>        End
75128>>>>>>>>
75128>>>>>>>        
75128>>>>>>>        Function_Return hKey
75129>>>>>>>    End_Function
75130>>>>>>>    
75130>>>>>>>    // Destroys the key
75130>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
75132>>>>>>>        Function_Return (CryptDestroyKey(hKey))
75133>>>>>>>    End_Function
75134>>>>>>>    
75134>>>>>>>    // Retrieves key data
75134>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
75136>>>>>>>        Integer iBuffer iLen
75136>>>>>>>        Boolean bOk
75136>>>>>>>        
75136>>>>>>>        Move (SizeOfType(Integer)) to iLen
75137>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
75138>>>>>>>        Function_Return iBuffer
75139>>>>>>>    End_Function
75140>>>>>>>    
75140>>>>>>>    // Retrieves a hash value
75140>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
75142>>>>>>>        UChar[] ucHash
75143>>>>>>>        Integer liResult
75143>>>>>>>        DWord   dwDataLen
75143>>>>>>>        
75143>>>>>>>        Move 0 to dwDataLen
75144>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
75145>>>>>>>        If (liResult = 0) ;            Function_Return ""
75148>>>>>>>        
75148>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
75149>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
75150>>>>>>>        If (liResult = 0) ;            Function_Return ""
75153>>>>>>>        
75153>>>>>>>        Function_Return ucHash
75154>>>>>>>    End_Function
75155>>>>>>>
75155>>>>>>>    // Encrypts data
75155>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
75157>>>>>>>        Handle hProv hHash hKey
75157>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
75157>>>>>>>        Boolean bOk
75157>>>>>>>        
75157>>>>>>>        Get AcquireContext to hProv
75158>>>>>>>        If (hProv) Begin
75160>>>>>>>            Get CreateHash hProv to hHash
75161>>>>>>>            If (hHash) Begin
75163>>>>>>>                Get HashData hHash ucPassword to bOk
75164>>>>>>>                If (bOk) Begin
75166>>>>>>>                    Get piCipher to iAlgorithm
75167>>>>>>>                    Get DeriveKey hProv hHash to hKey
75168>>>>>>>                End
75168>>>>>>>>
75168>>>>>>>                Get DestroyHash hHash to bOk
75169>>>>>>>            End
75169>>>>>>>>
75169>>>>>>>            
75169>>>>>>>            If (hKey) Begin
75171>>>>>>>                //  First call to determine resulting data size
75171>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
75172>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
75173>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
75174>>>>>>>                
75174>>>>>>>                //  Reserve space in string
75174>>>>>>>                If (iDataLen < iCipherLen) Begin
75176>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
75177>>>>>>>                End
75177>>>>>>>>
75177>>>>>>>                
75177>>>>>>>                //  Call to really decrypt
75177>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
75178>>>>>>>                //If (not(bOk)) Begin
75178>>>>>>>                //Move "" to sData
75178>>>>>>>                //Move (GetLastError()) to iErr
75178>>>>>>>                //End
75178>>>>>>>                
75178>>>>>>>                Get DestroyKey hKey to bOk
75179>>>>>>>            End 
75179>>>>>>>>
75179>>>>>>>            Get ReleaseContext hProv to bOk
75180>>>>>>>        End 
75180>>>>>>>>
75180>>>>>>>        Function_Return ucData
75181>>>>>>>    End_Function
75182>>>>>>>    
75182>>>>>>>    // Decrypts data
75182>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
75184>>>>>>>        Handle hProv hHash hKey
75184>>>>>>>        Integer iAlgorithm iDataLen
75184>>>>>>>        Boolean bOk
75184>>>>>>>        
75184>>>>>>>        Get AcquireContext to hProv
75185>>>>>>>        If (hProv) Begin
75187>>>>>>>            Get CreateHash hProv to hHash
75188>>>>>>>            If (hHash) Begin
75190>>>>>>>                Get HashData hHash ucPassword to bOk
75191>>>>>>>                If (bOk) Begin
75193>>>>>>>                    Get piCipher to iAlgorithm
75194>>>>>>>                    Get DeriveKey hProv hHash to hKey
75195>>>>>>>                End
75195>>>>>>>>
75195>>>>>>>                Get DestroyHash hHash to bOk
75196>>>>>>>            End
75196>>>>>>>>
75196>>>>>>>            
75196>>>>>>>            If (hKey) Begin
75198>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
75199>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
75200>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
75200>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
75202>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
75203>>>>>>>                End
75203>>>>>>>>
75203>>>>>>>                
75203>>>>>>>                Get DestroyKey hKey to bOk
75204>>>>>>>            End
75204>>>>>>>>
75204>>>>>>>            Get ReleaseContext hProv to bOk
75205>>>>>>>        End
75205>>>>>>>>
75205>>>>>>>        Function_Return ucData
75206>>>>>>>    End_Function
75207>>>>>>>    
75207>>>>>>>    // Creates a key
75207>>>>>>>    Function CreateKey Handle hProv Returns Handle
75209>>>>>>>        Integer iAlg iType iByte iLength iSize
75209>>>>>>>        CryptoBlob keyBlob
75209>>>>>>>        CryptoBlob keyBlob
75209>>>>>>>        Boolean bOk
75209>>>>>>>        Handle hKey
75209>>>>>>>        UChar[] aKey
75210>>>>>>>
75210>>>>>>>        Get paKey to aKey
75211>>>>>>>        Get piKeyAlg to iAlg
75212>>>>>>>        Get piKeyType to iType
75213>>>>>>>        Move iAlg                   to keyBlob.header.bType
75214>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
75215>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
75216>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
75217>>>>>>>        
75217>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
75218>>>>>>>        For iByte from 0 to iLength
75224>>>>>>>>
75224>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
75225>>>>>>>        Loop
75226>>>>>>>>
75226>>>>>>>        
75226>>>>>>>        Move 0 to hKey
75227>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
75228>>>>>>>        Function_Return hKey
75229>>>>>>>    End_Function
75230>>>>>>>    
75230>>>>>>>    // Sets the key parameters
75230>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
75232>>>>>>>        Integer iPadding iMode
75232>>>>>>>        Boolean bOk
75232>>>>>>>        UChar[] aIV
75233>>>>>>>        
75233>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
75233>>>>>>>        //For iByte from 0 to iLength
75233>>>>>>>        //    Move iByte to aIV[iByte]
75233>>>>>>>        //Loop
75233>>>>>>>
75233>>>>>>>        // Set initialization vector
75233>>>>>>>        Get paIV to aIV
75234>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
75235>>>>>>>        If (bOk) Begin
75237>>>>>>>            // Set padding
75237>>>>>>>            Get piKeyPadding to iPadding
75238>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
75239>>>>>>>            If (bOk) Begin
75241>>>>>>>                // Set move
75241>>>>>>>                Get piKeyMode to iMode
75242>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
75243>>>>>>>            End
75243>>>>>>>>
75243>>>>>>>        End
75243>>>>>>>>
75243>>>>>>>        Function_Return bOk        
75244>>>>>>>    End_Function
75245>>>>>>>    
75245>>>>>>>    // Encrypts using block cipher
75245>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
75247>>>>>>>        Handle hProv hKey
75247>>>>>>>        Integer iLen iSize iBlocks
75247>>>>>>>        Boolean bOk
75247>>>>>>>        
75247>>>>>>>        Get AcquireContext to hProv
75248>>>>>>>        If (hProv) Begin
75250>>>>>>>            // Create key
75250>>>>>>>            Get CreateKey hProv to hKey
75251>>>>>>>            If (hKey) Begin
75253>>>>>>>                Get SetKeyParameters hKey to bOk
75254>>>>>>>                If (bOk) Begin
75256>>>>>>>                    // Buffer for block ciphers can be up to block length larger
75256>>>>>>>                    Get piBlockSize to iSize
75257>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
75258>>>>>>>                    
75258>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
75259>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
75260>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
75261>>>>>>>                End
75261>>>>>>>>
75261>>>>>>>                Get DestroyKey hKey to bOk
75262>>>>>>>            End
75262>>>>>>>>
75262>>>>>>>            Get ReleaseContext hProv to bOk
75263>>>>>>>        End
75263>>>>>>>>
75263>>>>>>>        Function_Return ucData
75264>>>>>>>    End_Function
75265>>>>>>>    
75265>>>>>>>    // Decrypts using block cipher
75265>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
75267>>>>>>>        Handle hProv hKey
75267>>>>>>>        Integer iLen
75267>>>>>>>        Boolean bOk
75267>>>>>>>        
75267>>>>>>>        Get AcquireContext to hProv
75268>>>>>>>        If (hProv) Begin
75270>>>>>>>            // Create key
75270>>>>>>>            Get CreateKey hProv to hKey
75271>>>>>>>            If (hKey) Begin
75273>>>>>>>                Get SetKeyParameters hKey to bOk
75274>>>>>>>                If (bOk) Begin
75276>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
75277>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
75278>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
75279>>>>>>>                End
75279>>>>>>>>
75279>>>>>>>                Get DestroyKey hKey to bOk
75280>>>>>>>            End
75280>>>>>>>>
75280>>>>>>>            Get ReleaseContext hProv to bOk
75281>>>>>>>        End
75281>>>>>>>>
75281>>>>>>>        Function_Return ucData
75282>>>>>>>    End_Function
75283>>>>>>>    
75283>>>>>>>    
75283>>>>>>>    //  Generates random data.
75283>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
75285>>>>>>>        Handle hProv
75285>>>>>>>        UChar[] uaResult
75286>>>>>>>        Boolean bRes
75286>>>>>>>        
75286>>>>>>>        Get AcquireContext to hProv
75287>>>>>>>        
75287>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
75288>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
75289>>>>>>>        
75289>>>>>>>        Get ReleaseContext hProv to bRes
75290>>>>>>>        
75290>>>>>>>        Function_Return uaResult
75291>>>>>>>    End_Function
75292>>>>>>>    
75292>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
75292>>>>>>>    Function GenerateRandomString Integer iLength Returns String
75294>>>>>>>        String sResult
75294>>>>>>>        UChar[] ucData
75295>>>>>>>        Pointer pBase64
75295>>>>>>>        Integer iVoid
75295>>>>>>>        
75295>>>>>>>        Get GenerateRandom iLength to ucData
75296>>>>>>>        
75296>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
75297>>>>>>>        Move (PointerToString(pBase64)) to sResult
75298>>>>>>>        Move (Free(pBase64)) to iVoid
75299>>>>>>>        
75299>>>>>>>        Function_Return (Left(sResult, iLength))
75300>>>>>>>    End_Function
75301>>>>>>>    
75301>>>>>>>End_Class
75302>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
75302>>>>>>>//> This package enables base64 encoding and decoding of strings:
75302>>>>>>>//>
75302>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
75302>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
75302>>>>>>>//>
75302>>>>>>>//> Remember to set the "max argument size" if dealing with very large
75302>>>>>>>//> strings.
75302>>>>>>>//>
75302>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
75302>>>>>>>//> Base64Decode) that are built into the runtime.
75302>>>>>>>//>
75302>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
75302>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
75302>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
75302>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
75302>>>>>>>
75302>>>>>>>Use VdfBase.pkg
75302>>>>>>>
75302>>>>>>>// Functions in vdfBase64.dll
75302>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
75303>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
75304>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
75305>>>>>>>
75305>>>>>>>// Structure
75305>>>>>>>Struct txxfBase64Buffer
75305>>>>>>>    Pointer pData
75305>>>>>>>    Integer iLength
75305>>>>>>>End_Struct 
75305>>>>>>>
75305>>>>>>>Global_Variable Integer oBase64Functions
75305>>>>>>>
75305>>>>>>>Object _oBase64Functions is a cObject
75307>>>>>>>    Move Self to oBase64Functions
75308>>>>>>>
75308>>>>>>>
75308>>>>>>>    Function EncodeString String sValue Returns String
75311>>>>>>>        Address pBase64
75311>>>>>>>        String sResult
75311>>>>>>>        Integer iVoid
75311>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
75312>>>>>>>        Move (PointerToString(pBase64)) to sResult
75313>>>>>>>        Move (Free(pBase64)) to iVoid
75314>>>>>>>        Function_Return sResult
75315>>>>>>>    End_Function
75316>>>>>>>
75316>>>>>>>    Function DecodeString String sValue Returns String
75319>>>>>>>        Address pBinary
75319>>>>>>>        String sBinary
75319>>>>>>>        Integer iVoid iLen
75319>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
75320>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
75321>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
75322>>>>>>>        Move (Free(pBinary)) to iVoid
75323>>>>>>>        Function_Return sBinary
75324>>>>>>>    End_Function
75325>>>>>>>
75325>>>>>>>End_Object
75326>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\MSSqldrv.pkg)
75326>>>>>>>//     Package that declares MS SQL driver constants and functions.
75326>>>>>>>//     This package can be used by developers who want to add Data Access
75326>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75326>>>>>>>
75326>>>>>>>Use Cli.pkg
75326>>>>>>>Use SQL.pkg
75326>>>>>>>
75326>>>>>>>//   Driver Indentification
75326>>>>>>>
75326>>>>>>>//   Error number constants
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>// SQL Server spcific types.
75326>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75326>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75326>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75326>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75326>>>>>>>
75326>>>>>>>// SQL Server spcific types.
75326>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75326>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75326>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75326>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75326>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75326>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75326>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75326>>>>>>>//
75326>>>>>>>//     Setup a constraint for a file.
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>Class cMSSQLHandler is a cCLIHandler
75327>>>>>>>    
75327>>>>>>>    Procedure Construct_Object
75329>>>>>>>        Forward Send Construct_Object
75331>>>>>>>        
75331>>>>>>>        Set psDriverID to MSSQLDRV_ID
75332>>>>>>>    End_Procedure
75333>>>>>>>    
75333>>>>>>>    
75333>>>>>>>    
75333>>>>>>>    //   Extract the list from the out connect string.
75333>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75335>>>>>>>        String  sItem
75335>>>>>>>        Integer iStart
75335>>>>>>>        Integer iEnd
75335>>>>>>>        
75335>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75338>>>>>>>        
75338>>>>>>>        Send Delete_Data to hoStore
75339>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75340>>>>>>>        While (iStart > 0)
75344>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75345>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75348>>>>>>>            Else Begin
75349>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75350>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75351>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75354>>>>>>>                
75354>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75357>>>>>>>                
75357>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75360>>>>>>>            End
75360>>>>>>>>
75360>>>>>>>        Loop
75361>>>>>>>>
75361>>>>>>>        
75361>>>>>>>        Function_Return (Item_Count(hoStore))
75362>>>>>>>    End_Procedure
75363>>>>>>>    
75363>>>>>>>    
75363>>>>>>>    
75363>>>>>>>    //   Call the driver's browse connect function
75363>>>>>>>    Function BrowseConnect String sInConnStr Returns String
75365>>>>>>>        String  sDriver
75365>>>>>>>        String  sOutConnStr
75365>>>>>>>        Integer iArg
75365>>>>>>>        Integer iRetval
75365>>>>>>>        
75365>>>>>>>        Get psDriverID to sDriver
75366>>>>>>>        If (sDriver <> "") Begin
75368>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75369>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75374>>>>>>>        End
75374>>>>>>>>
75374>>>>>>>        
75374>>>>>>>        Function_Return sOutConnStr
75375>>>>>>>    End_Function// BrowseConnect
75376>>>>>>>    
75376>>>>>>>    
75376>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
75378>>>>>>>        String  sDriver
75378>>>>>>>        String  sOutConnStr
75378>>>>>>>        Integer iArg
75378>>>>>>>        Integer iRetval
75378>>>>>>>        
75378>>>>>>>        Move 1 to iArg // Browses only local
75379>>>>>>>        
75379>>>>>>>        Get psDriverID to sDriver
75380>>>>>>>        If (sDriver <> "") Begin
75382>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75383>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75388>>>>>>>        End
75388>>>>>>>>
75388>>>>>>>        
75388>>>>>>>        Function_Return sOutConnStr
75389>>>>>>>    End_Function// BrowseConnect
75390>>>>>>>    
75390>>>>>>>    
75390>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
75392>>>>>>>        
75392>>>>>>>        String  sServerList
75392>>>>>>>        Integer iNumServers
75392>>>>>>>        Integer iDriver
75392>>>>>>>        Integer iClientVersion
75392>>>>>>>        String  sDriver
75392>>>>>>>        
75392>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75393>>>>>>>        
75393>>>>>>>        If (iDriver) Begin
75395>>>>>>>            
75395>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75398>>>>>>>            
75398>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
75399>>>>>>>            
75399>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
75400>>>>>>>            If (iNetworkLocal = 0) Begin
75402>>>>>>>                Get BrowseConnect sDriver to sServerList
75403>>>>>>>            End
75403>>>>>>>>
75403>>>>>>>            Else Begin
75404>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
75405>>>>>>>            End
75405>>>>>>>>
75405>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
75406>>>>>>>        End
75406>>>>>>>>
75406>>>>>>>        
75406>>>>>>>        Function_Return iNumServers
75407>>>>>>>        
75407>>>>>>>    End_Function
75408>>>>>>>    
75408>>>>>>>    //   Enumerate the available SQL Server database servers
75408>>>>>>>    //   This function will return all SQL Server instances on the network.
75408>>>>>>>    //   This may take a long time.
75408>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
75408>>>>>>>    Function EnumerateServers Returns Integer
75410>>>>>>>        
75410>>>>>>>        Integer iNumServers
75410>>>>>>>        Integer iNetworkLocal
75410>>>>>>>        
75410>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
75411>>>>>>>        
75411>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75412>>>>>>>        
75412>>>>>>>        Function_Return iNumServers
75413>>>>>>>        
75413>>>>>>>    End_Function
75414>>>>>>>    
75414>>>>>>>    
75414>>>>>>>    //   Enumerate the available SQL Server database servers
75414>>>>>>>    //   This function will return only return SQL Server instance on the local machine
75414>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
75414>>>>>>>    Function EnumerateServersLocal Returns Integer
75416>>>>>>>        
75416>>>>>>>        Integer iNumServers
75416>>>>>>>        Integer iNetworkLocal
75416>>>>>>>        
75416>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
75417>>>>>>>        
75417>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75418>>>>>>>        
75418>>>>>>>        Function_Return iNumServers
75419>>>>>>>        
75419>>>>>>>    End_Function
75420>>>>>>>    
75420>>>>>>>    
75420>>>>>>>    
75420>>>>>>>    //   Enumerate database in a given server.
75420>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
75422>>>>>>>        Integer hoSQL
75422>>>>>>>        String  sConnect
75422>>>>>>>        String  sDatabase
75422>>>>>>>        Integer hdbc
75422>>>>>>>        Integer hstmt
75422>>>>>>>        Integer iFetchResult
75422>>>>>>>        
75422>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
75425>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
75428>>>>>>>        
75428>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
75431>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
75433>>>>>>>        
75433>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
75435>>>>>>>            Move Current_Object to hoSQL
75436>>>>>>>        End_Object
75437>>>>>>>        
75437>>>>>>>        If (hoSQL <> 0) Begin
75439>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
75440>>>>>>>            If (hdbc <> 0) Begin
75442>>>>>>>                Get SQLOpen of hdbc to hstmt
75443>>>>>>>                If (hstmt <> 0) Begin
75445>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
75445>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
75445>>>>>>>                    //   approach in case meta data might change, the stored procedure will
75445>>>>>>>                    //   stay the same.
75445>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
75446>>>>>>>                    Send SQLCall to hstmt
75447>>>>>>>                    Repeat
75447>>>>>>>>
75447>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
75448>>>>>>>                        If (iFetchResult <> 0) Begin
75450>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
75451>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
75452>>>>>>>                        End
75452>>>>>>>>
75452>>>>>>>                    Until (iFetchResult = 0)
75454>>>>>>>                    
75454>>>>>>>                    Send SQLClose to hstmt
75455>>>>>>>                End
75455>>>>>>>>
75455>>>>>>>                Send SQLDisconnect to hdbc
75456>>>>>>>            End
75456>>>>>>>>
75456>>>>>>>        End
75456>>>>>>>>
75456>>>>>>>        Send Destroy_Object to hoSQL
75457>>>>>>>        
75457>>>>>>>        Function_Return (Item_Count(Current_Object))
75458>>>>>>>    End_Function
75459>>>>>>>    
75459>>>>>>>    
75459>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
75461>>>>>>>        
75461>>>>>>>        String  sSqlServerClientVersionName
75461>>>>>>>        
75461>>>>>>>        
75461>>>>>>>        Case Begin
75461>>>>>>>
75461>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
75463>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
75464>>>>>>>                Case Break
75465>>>>>>>            
75465>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
75468>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
75469>>>>>>>                Case Break
75470>>>>>>>                
75470>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
75473>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
75474>>>>>>>                Case Break
75475>>>>>>>            
75475>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
75478>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
75479>>>>>>>                Case Break
75480>>>>>>>            
75480>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
75483>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
75484>>>>>>>                Case Break
75485>>>>>>>            
75485>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
75488>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
75489>>>>>>>                Case Break
75490>>>>>>>            
75490>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
75493>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
75494>>>>>>>                Case Break
75495>>>>>>>            
75495>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
75498>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
75499>>>>>>>                Case Break
75500>>>>>>>            
75500>>>>>>>            Case Else
75500>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
75501>>>>>>>                
75501>>>>>>>        Case End
75501>>>>>>>        
75501>>>>>>>        
75501>>>>>>>        Function_Return sSqlServerClientVersionName
75502>>>>>>>        
75502>>>>>>>    End_Function
75503>>>>>>>
75503>>>>>>>
75503>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
75505>>>>>>>        
75505>>>>>>>        String  sSqlServerClientDriverName
75505>>>>>>>        
75505>>>>>>>        Case Begin
75505>>>>>>>
75505>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
75507>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
75508>>>>>>>                Case Break
75509>>>>>>>
75509>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
75512>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
75513>>>>>>>                Case Break
75514>>>>>>>                
75514>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
75517>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
75518>>>>>>>                Case Break
75519>>>>>>>            
75519>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
75522>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
75523>>>>>>>                Case Break
75524>>>>>>>            
75524>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
75527>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
75528>>>>>>>                Case Break
75529>>>>>>>            
75529>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
75532>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
75533>>>>>>>                Case Break
75534>>>>>>>            
75534>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
75537>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
75538>>>>>>>                Case Break
75539>>>>>>>            
75539>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
75542>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
75543>>>>>>>                Case Break
75544>>>>>>>            
75544>>>>>>>            Case Else
75544>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
75545>>>>>>>                
75545>>>>>>>        Case End
75545>>>>>>>        
75545>>>>>>>        
75545>>>>>>>        Function_Return sSqlServerClientDriverName
75546>>>>>>>        
75546>>>>>>>    End_Function
75547>>>>>>>    
75547>>>>>>>    
75547>>>>>>>End_Class
75548>>>>>>>
75548>>>>>>>
75548>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\db2_drv.pkg)
75548>>>>>>>// DB2_DRV.PKG                                                          
75548>>>>>>>//   Package that declares DB2 driver constants and functions.          
75548>>>>>>>//   This package can be used by developers who want to add DB2 driver  
75548>>>>>>>//   specific code to a DataFlex application.                           
75548>>>>>>>
75548>>>>>>>Use Cli.pkg
75548>>>>>>>
75548>>>>>>>// Driver attributes
75548>>>>>>>
75548>>>>>>>
75548>>>>>>>// Driver Indentification
75548>>>>>>>
75548>>>>>>>// Error number constants
75548>>>>>>>
75548>>>>>>>// Call driver function identifiers
75548>>>>>>>
75548>>>>>>>// DB2 specific data types
75548>>>>>>>Define SQL_CLOB           for   (-99)
75548>>>>>>>Define SQL_BLOB           for   (-98)
75548>>>>>>>Define SQL_XML            for   (-370)
75548>>>>>>>// DB2 Graphic types are Unicode types
75548>>>>>>>Define SQL_GRAPHIC        for   (-95)
75548>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
75548>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
75548>>>>>>>Define SQL_DBCLOB         for   (-350)
75548>>>>>>>
75548>>>>>>>
75548>>>>>>>// Extra DB2 commands
75548>>>>>>>
75548>>>>>>>
75548>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
75548>>>>>>>//   Setup a constraint for a file.                                     
75548>>>>>>>
75548>>>>>>>
75548>>>>>>>
75548>>>>>>>Class cDB2Handler is a cCLIHandler
75549>>>>>>>    
75549>>>>>>>    Procedure Construct_Object
75551>>>>>>>        Forward Send Construct_Object
75553>>>>>>>        
75553>>>>>>>        Set psDriverID to DB2_DRV_ID
75554>>>>>>>    End_Procedure
75555>>>>>>>    
75555>>>>>>>    
75555>>>>>>>    
75555>>>>>>>    // Reset the datasource list to the beginning
75555>>>>>>>    Procedure SeedDataSources
75557>>>>>>>        String  sDriver
75557>>>>>>>        String  sVoid
75557>>>>>>>        Integer iRetval
75557>>>>>>>        
75557>>>>>>>        Get psDriverID to sDriver
75558>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
75565>>>>>>>    End_Procedure
75566>>>>>>>    
75566>>>>>>>    
75566>>>>>>>    
75566>>>>>>>    // Call the driver's data sources function
75566>>>>>>>    Function DataSources Returns String
75568>>>>>>>        String  sDriver
75568>>>>>>>        String  sDataSource
75568>>>>>>>        String  sDescription
75568>>>>>>>        Integer iLength
75568>>>>>>>        Integer iRetval
75568>>>>>>>        
75568>>>>>>>        Get psDriverID to sDriver
75569>>>>>>>        If (sDriver <> "") Begin
75571>>>>>>>            Move 8192 to iLength
75572>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
75573>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
75574>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
75579>>>>>>>        End
75579>>>>>>>>
75579>>>>>>>        
75579>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
75582>>>>>>>        Else ;            Function_Return ""
75584>>>>>>>    End_Function
75585>>>>>>>    
75585>>>>>>>End_Class
75586>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\odbc_drv.pkg)
75586>>>>>>>//   Package that declares ODBC driver constants and functions.         
75586>>>>>>>//   This package can be used by developers who want to add Data Access 
75586>>>>>>>//   ODBC Client specific code to a DataFlex application.               
75586>>>>>>>
75586>>>>>>>Use Cli.pkg
75586>>>>>>>
75586>>>>>>>// Driver Indentification
75586>>>>>>>
75586>>>>>>>// Error number constants
75586>>>>>>>
75586>>>>>>>// Call driver function identifiers
75586>>>>>>>
75586>>>>>>>Class cODBCHandler is a cCLIHandler
75587>>>>>>>    
75587>>>>>>>    Procedure Construct_Object
75589>>>>>>>        Forward Send Construct_Object
75591>>>>>>>        
75591>>>>>>>        Set psDriverID to ODBC_DRV_ID
75592>>>>>>>    End_Procedure
75593>>>>>>>    
75593>>>>>>>    
75593>>>>>>>    
75593>>>>>>>    // Setup the type of data sources returned by the datasources function
75593>>>>>>>    Procedure Set DataSourceType Integer iNewType
75595>>>>>>>        String  sDriver
75595>>>>>>>        String  sVoid
75595>>>>>>>        Integer iRetval
75595>>>>>>>        
75595>>>>>>>        Get psDriverID to sDriver
75596>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
75603>>>>>>>    End_Procedure
75604>>>>>>>    
75604>>>>>>>    
75604>>>>>>>    // Call the driver's data sources function
75604>>>>>>>    Function DataSources Returns String
75606>>>>>>>        String  sDriver
75606>>>>>>>        String  sDataSource
75606>>>>>>>        String  sDescription
75606>>>>>>>        Integer iLength
75606>>>>>>>        Integer iRetval
75606>>>>>>>        
75606>>>>>>>        Get psDriverID to sDriver
75607>>>>>>>        If (sDriver <> "") Begin
75609>>>>>>>            Move 8192 to iLength
75610>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
75611>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
75612>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
75617>>>>>>>        End
75617>>>>>>>>
75617>>>>>>>        
75617>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
75620>>>>>>>        Else ;            Function_Return ""
75622>>>>>>>    End_Function
75623>>>>>>>    
75623>>>>>>>End_Class
75624>>>>>>>
75624>>>>>Use DFBtrDrv.pkg
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 23.0\Pkg\DFBTRDRV.PKG)
75624>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
75624>>>>>>>// Notice      : This package contains constants and commands, used to call
75624>>>>>>>//               specific functions in the DFBTRDRV.
75624>>>>>>>Use Ui
75624>>>>>>>//
75624>>>>>>>// Driver Indentification
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>// Driver attributes
75624>>>>>>>//
75624>>>>>>>// Call_Driver functions ID's
75624>>>>>>>//
75624>>>>>>>//
75624>>>>>>>// DFBTRFN_CONVERT_FILE options
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// DFBTRFN_SET_OWNER options
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to create all vars which may be needed
75624>>>>>>>// in other commands.
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to set the owner of a Btrieve file.
75624>>>>>>>// File must have been opened.
75624>>>>>>>// Filenumber needs to be passed.
75624>>>>>>>// To clear set the owner to "".
75624>>>>>>>// Examples:
75624>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
75624>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
75624>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
75624>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
75624>>>>>>>// To clear:
75624>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to parse DFBTR_SET_OWNVER
75624>>>>>>>// options.
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to parse for Callback
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to clear the owner of a Btrieve file.
75624>>>>>>>// File must have been opened.
75624>>>>>>>// Filenumber needs to be passed.
75624>>>>>>>// Examples:
75624>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to add a owner name to the internal list of ownernames
75624>>>>>>>// which will be tries when opening files.
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to remove all owners from the internal list of ownernames
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to set the owner name to be used when opening the DDF files.
75624>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
75624>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
75624>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to change the transaction type.
75624>>>>>>>// Valid types are:
75624>>>>>>>//     DFBTRTT_NONE
75624>>>>>>>//     DFBTRTT_EXCLUSIVE
75624>>>>>>>//     DFBTRTT_CONCURRENT
75624>>>>>>>//
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to get the current transaction type.
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to set explicit_locking
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to get explicit locking
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>// Purpose: An instance of this class can be used as a broker object to
75624>>>>>>>//          call several Dfbtrdrv releated methods.
75624>>>>>>>
75624>>>>>>>Class cDFBtrDrvHandler is an Array
75625>>>>>>>    
75625>>>>>>>    Procedure Construct_Object Integer iImage
75627>>>>>>>        Forward Send Construct_object iImage
75629>>>>>>>        
75629>>>>>>>        Property String  psDriverID "DFBTRDRV"
75630>>>>>>>    End_Procedure
75631>>>>>>>    
75631>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
75631>>>>>>>    //
75631>>>>>>>    
75631>>>>>>>    Function CKRevision Returns String
75633>>>>>>>        String  sDriverID
75633>>>>>>>        String  sRevision
75633>>>>>>>        String  sVoid
75633>>>>>>>        Integer iRetval
75633>>>>>>>        
75633>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75633>>>>>>>        // This error would otherwise be raised when we have an older
75633>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75633>>>>>>>        Send Ignore_error to Error_object_Id 20491
75634>>>>>>>        Get psDriverID to sDriverID
75635>>>>>>>        Move (Repeat(" ", 255)) to sRevision
75636>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
75641>>>>>>>        Send Trap_Error to Error_object_Id 20491
75642>>>>>>>        If (Trim(sRevision) = "") Begin
75644>>>>>>>            // Unable to get the revision. return all zeroes.
75644>>>>>>>            Move "0.0.0.0" to sRevision
75645>>>>>>>        End
75645>>>>>>>>
75645>>>>>>>        Function_Return sRevision
75646>>>>>>>    End_Function
75647>>>>>>>    
75647>>>>>>>    Function CkUsesUri Returns Integer
75649>>>>>>>        String  sDriverID
75649>>>>>>>        String  sVoid1
75649>>>>>>>        String  sVoid2
75649>>>>>>>        Integer iRetval
75649>>>>>>>        
75649>>>>>>>        Get psDriverID to sDriverID
75650>>>>>>>        
75650>>>>>>>        Move 0 to iRetval
75651>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75651>>>>>>>        // This error would otherwise be raised when we have an older
75651>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
75651>>>>>>>        Send Ignore_error to Error_object_Id 20491
75652>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
75657>>>>>>>        Send Trap_Error to Error_object_Id 20491
75658>>>>>>>        
75658>>>>>>>        Function_Return iRetval
75659>>>>>>>    End_Function
75660>>>>>>>    
75660>>>>>>>    
75660>>>>>>>    
75660>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
75660>>>>>>>    //
75660>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
75660>>>>>>>    //
75660>>>>>>>    
75660>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
75662>>>>>>>        Integer iPartRev
75662>>>>>>>        Integer iCurrentPart
75662>>>>>>>        Integer iSeparatorPos
75662>>>>>>>        
75662>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
75665>>>>>>>        
75665>>>>>>>        Move 0 to iCurrentPart
75666>>>>>>>        Repeat
75666>>>>>>>>
75666>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
75667>>>>>>>            If (iSeparatorPos > 0) Begin
75669>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
75670>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
75671>>>>>>>                Increment iCurrentPart
75672>>>>>>>            End
75672>>>>>>>>
75672>>>>>>>            Else If (sRevision <> "") Begin
75675>>>>>>>                Move sRevision to iPartRev
75676>>>>>>>                Move "" to sRevision
75677>>>>>>>                Increment iCurrentPart
75678>>>>>>>            End
75678>>>>>>>>
75678>>>>>>>            Else ;                Move -1 to iPartRev
75680>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
75682>>>>>>>        
75682>>>>>>>        Function_Return iPartRev
75683>>>>>>>    End_Function
75684>>>>>>>    
75684>>>>>>>    
75684>>>>>>>    
75684>>>>>>>    //
75684>>>>>>>    //  Returns the major revision of the CK
75684>>>>>>>    //
75684>>>>>>>    
75684>>>>>>>    Function CKMajorRevision Returns Integer
75686>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
75687>>>>>>>    End_Function
75688>>>>>>>    
75688>>>>>>>    
75688>>>>>>>    
75688>>>>>>>    //  Returns the minor revision of the CK
75688>>>>>>>    //
75688>>>>>>>    
75688>>>>>>>    Function CKMinorRevision Returns Integer
75690>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
75691>>>>>>>    End_Function
75692>>>>>>>    
75692>>>>>>>    
75692>>>>>>>    //  Returns the release revision of the CK
75692>>>>>>>    //
75692>>>>>>>    
75692>>>>>>>    Function CKReleaseRevision Returns Integer
75694>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
75695>>>>>>>    End_Function
75696>>>>>>>    
75696>>>>>>>    
75696>>>>>>>    //  Returns the major revision of the CK
75696>>>>>>>    //
75696>>>>>>>    
75696>>>>>>>    Function CKBuildRevision Returns Integer
75698>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
75699>>>>>>>    End_Function
75700>>>>>>>    
75700>>>>>>>    
75700>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
75700>>>>>>>    //
75700>>>>>>>    
75700>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
75702>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
75705>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
75708>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
75711>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
75714>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
75717>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
75721>>>>>>>            End
75721>>>>>>>>
75721>>>>>>>        End
75721>>>>>>>>
75721>>>>>>>        
75721>>>>>>>        Function_Return (False)
75722>>>>>>>    End_Function
75723>>>>>>>    
75723>>>>>>>    //   Functions to query the Pervasive.SQL version:
75723>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
75723>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
75723>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
75723>>>>>>>    //
75723>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
75723>>>>>>>    //   in the following format:
75723>>>>>>>    //       <version>.<revision>.<type>
75723>>>>>>>    //   possible values for <type>:
75723>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
75723>>>>>>>    //         server using Workgroup authentication mode
75723>>>>>>>    //       C for client cache engine
75723>>>>>>>    //       D for DOS workstation
75723>>>>>>>    //       N for client Requester
75723>>>>>>>    //       S for NetWare server
75723>>>>>>>    //       T for 32-bit Windows server engine
75723>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
75723>>>>>>>    //
75723>>>>>>>    //   example:
75723>>>>>>>    //       8.50.T
75723>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
75723>>>>>>>    //   32-bits Windows server.
75723>>>>>>>    //
75723>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
75723>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
75723>>>>>>>    //
75723>>>>>>>    //   If the version information is not available or can not be obtained
75723>>>>>>>    //   the functions will return "0.0.0"
75723>>>>>>>    
75723>>>>>>>    //  Returns the version information of the
75723>>>>>>>    //           Pervasive.SQL Client requester.
75723>>>>>>>    
75723>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
75725>>>>>>>        
75725>>>>>>>        String  sDriverID
75725>>>>>>>        String  sVersion
75725>>>>>>>        String  sVoid
75725>>>>>>>        Integer iRetval
75725>>>>>>>        
75725>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75725>>>>>>>        // This error would otherwise be raised when we have an older
75725>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75725>>>>>>>        Send Ignore_error to Error_object_Id 20491
75726>>>>>>>        Get psDriverID to sDriverID
75727>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75728>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75733>>>>>>>        Send Trap_Error to Error_object_Id 20491
75734>>>>>>>        If (Trim(sVersion) = "") Begin
75736>>>>>>>            // Unable to get the revision. return all zeroes.
75736>>>>>>>            Move "0.0.0" to sVersion
75737>>>>>>>        End
75737>>>>>>>>
75737>>>>>>>        Function_Return sVersion
75738>>>>>>>    End_Function
75739>>>>>>>    
75739>>>>>>>    //           Pervasive.SQL Engine
75739>>>>>>>    
75739>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
75741>>>>>>>        
75741>>>>>>>        String  sDriverID
75741>>>>>>>        String  sVersion
75741>>>>>>>        String  sVoid
75741>>>>>>>        Integer iRetval
75741>>>>>>>        
75741>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75741>>>>>>>        // This error would otherwise be raised when we have an older
75741>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75741>>>>>>>        Send Ignore_error to Error_object_Id 20491
75742>>>>>>>        Get psDriverID to sDriverID
75743>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75744>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75749>>>>>>>        Send Trap_Error to Error_object_Id 20491
75750>>>>>>>        If (Trim(sVersion) = "") Begin
75752>>>>>>>            // Unable to get the revision. return all zeroes.
75752>>>>>>>            Move "0.0.0" to sVersion
75753>>>>>>>        End
75753>>>>>>>>
75753>>>>>>>        Function_Return sVersion
75754>>>>>>>    End_Function
75755>>>>>>>    
75755>>>>>>>    //  Returns the version information of the
75755>>>>>>>    //           Pervasive.SQL Server Engine
75755>>>>>>>    
75755>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
75757>>>>>>>        
75757>>>>>>>        String  sDriverID
75757>>>>>>>        String  sVersion
75757>>>>>>>        String  sVoid
75757>>>>>>>        Integer iRetval
75757>>>>>>>        
75757>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75757>>>>>>>        // This error would otherwise be raised when we have an older
75757>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75757>>>>>>>        Send Ignore_error to Error_object_Id 20491
75758>>>>>>>        Get psDriverID to sDriverID
75759>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75760>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75765>>>>>>>        Send Trap_Error to Error_object_Id 20491
75766>>>>>>>        If (Trim(sVersion) = "") Begin
75768>>>>>>>            // Unable to get the revision. return all zeroes.
75768>>>>>>>            Move "0.0.0" to sVersion
75769>>>>>>>        End
75769>>>>>>>>
75769>>>>>>>        Function_Return sVersion
75770>>>>>>>    End_Function
75771>>>>>>>    
75771>>>>>>>End_Class
75772>>>>>>>
75772>>>>>>>
75772>>>>>Use vWin32fh.pkg
75772>>>>>
75772>>>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
75772>>>>>>>// *** The Database Update Framework Include file for Languages ***
75772>>>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
75772>>>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
75772>>>>>>>//
75772>>>>>>>Use LanguageText.Pkg
75772>>>>>>>
75772>>>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
75772>>>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
75772>>>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
75772>>>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
75772>>>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
75772>>>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
75772>>>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
75772>>>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
75772>>>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
75772>>>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
75772>>>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
75772>>>>>>>    Define CS_DUF_CopyingData               for "Copying data"
75772>>>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
75772>>>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
75772>>>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
75772>>>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
75772>>>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
75772>>>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
75772>>>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
75772>>>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
75772>>>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
75772>>>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
75772>>>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
75772>>>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
75772>>>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
75772>>>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
75772>>>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
75772>>>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
75772>>>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
75772>>>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
75772>>>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile in the data-folder.\n\nThe program will now close."
75772>>>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
75772>>>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
75772>>>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
75772>>>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
75772>>>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
75772>>>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>
75772>>>>>    Define DATAFLEX_ID for "DATAFLEX"
75772>>>>>
75772>>>>>// Create a new PSQL identifier for the Btrieve driver.
75772>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
75772>>>>>
75772>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
75772>>>>>// They can have slightly different SQL keywords.
75772>>>>>// Note: If a new type is added to the list,
75772>>>>>//       the struct array xxx must be adjusted
75772>>>>>//       so that it is filled with all SQL
75772>>>>>//       keywords for that new type.
75772>>>>>Enum_List  
75772>>>>>        Define EN_DbTypeDataFlex   for 0
75772>>>>>        Define EN_DbTypeMSSQL      for 1
75772>>>>>        Define EN_DbTypeMySQL      for 2
75772>>>>>        Define EN_DbTypeOracle     for 3
75772>>>>>        Define EN_DbTypeDB2        for 4
75772>>>>>        Define EN_DbTypePostgre    for 5
75772>>>>>        Define EN_DbTypePervasive  for 6
75772>>>>>End_Enum_List
75772>>>>>
75772>>>>>// We need to have our "own" constants for the standard DataFlex data types.
75772>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
75772>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
75772>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
75772>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
75772>>>>>Define CS_DbTypeMySQL       for "MySQL"
75772>>>>>Define CS_DbTypeOracle      for "Oracle"
75772>>>>>Define CS_DbTypeDB2         for "IBM DB2"
75772>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
75772>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
75772>>>>>
75772>>>>>
75772>>>>>// SQLConnection.ini constants:
75772>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
75772>>>>>
75772>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
75772>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
75772>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
75772>>>>>Define CS_SQLIniSectionName             for "Connection"
75772>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
75772>>>>>
75772>>>>>// DF 19 ini-file settings:
75772>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
75772>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
75772>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
75772>>>>>Define CS_SQLIniUIDKeyword              for "UID"
75772>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
75772>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
75772>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
75772>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
75772>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
75772>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
75772>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
75772>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
75772>>>>>
75772>>>>>// Database Update Framework extended settings:
75772>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
75772>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
75772>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
75772>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
75772>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
75772>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
75772>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
75772>>>>>
75772>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
75772>>>>>Define CS_SQLIniConnectionYes           for "Yes"
75772>>>>>Define CS_SQLIniConnectionNo            for "No"
75772>>>>>
75772>>>>>Struct tSQLConnection
75772>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
75772>>>>>    String sConnectionID            // 2. The name of the connection ID.
75772>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
75772>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
75772>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
75772>>>>>    String sDatabase                // 6. SQL Database
75772>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
75772>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
75772>>>>>    String sUserID                  // 9. User ID
75772>>>>>    String sPassword                // 10. Password
75772>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
75772>>>>>    String sBaseTableSpace          // 12. DB2 specific
75772>>>>>    String sLongTableSpace          // 13. DB2 specific
75772>>>>>    String sIndexTableSpace         // 14. DB2 specific
75772>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
75772>>>>>    Boolean bError                  // 16. Set to true on error.
75772>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
75772>>>>>End_Struct
75772>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
75772>>>>>Use cSQLConnectionIniFile.inc
75772>>>>>
75772>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
75773>>>>>    Procedure Construct_Object
75775>>>>>        Forward Send Construct_Object
75777>>>>>        Property String psDriverID DATAFLEX_ID
75778>>>>>    End_Procedure
75779>>>>>
75779>>>>>    Function ServerKeyword String sServer Returns String
75781>>>>>        String sRetval
75781>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
75783>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
75784>>>>>        End                                        
75784>>>>>>
75784>>>>>        Else Begin
75785>>>>>            Move CS_SQLIniDSNKeyword to sRetval
75786>>>>>        End
75786>>>>>>
75786>>>>>            
75786>>>>>        Function_Return sRetval
75787>>>>>    End_Function
75788>>>>>
75788>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
75790>>>>>        String sConnect sServerKeyWord sDriverID
75790>>>>>
75790>>>>>        Get psDriverID to sDriverID
75791>>>>>        Get ServerKeyword sServer to sServerKeyWord
75792>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
75793>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
75795>>>>>            Move "" to sDatabase
75796>>>>>        End
75796>>>>>>
75796>>>>>        
75796>>>>>        // 2019-10-20 I think this was plain wrong for the DAW ODBC_DRV driver. At least it didn't work for login to an MS-SQL db.
75796>>>>>//        If (bTrusted = False and (sDriverID = ODBC_DRV_ID and sServerKeyWord = CS_SQLIniDSNKeyword)) Begin
75796>>>>>//            Function_Return sConnect
75796>>>>>//        End
75796>>>>>
75796>>>>>        If (sDatabase <> "") Begin
75798>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
75799>>>>>        End
75799>>>>>>
75799>>>>>        If (bTrusted = True) Begin
75801>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
75802>>>>>        End
75802>>>>>>
75802>>>>>        Else Begin
75803>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
75804>>>>>        End
75804>>>>>>
75804>>>>>        Function_Return sConnect
75805>>>>>    End_Function
75806>>>>>
75806>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
75808>>>>>        Boolean bLoginSuccessful
75808>>>>>        String sDriverID
75808>>>>>
75808>>>>>        Get psDriverID to sDriverID
75809>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
75811>>>>>            Function_Return True
75812>>>>>        End
75812>>>>>>
75812>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
75813>>>>>        If (bTrusted = False and sDatabase <> "") Begin
75815>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
75816>>>>>            Login sServer sUserId sPassword sDriverID  
75818>>>>>        End
75818>>>>>>
75818>>>>>        Else Begin
75819>>>>>            Login sConnectionString "" "" sDriverID
75821>>>>>        End
75821>>>>>>
75821>>>>>        Move (LastErr = 0) to bLoginSuccessful
75822>>>>>        Function_Return bLoginSuccessful
75823>>>>>    End_Function
75824>>>>>End_Class
75825>>>>>
75825>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
75826>>>>>    Function ServerKeyword String sServer Returns String
75828>>>>>        Function_Return CS_SQLIniServerKeyword
75829>>>>>    End_Function
75830>>>>>End_Class
75831>>>>>
75831>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
75832>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
75834>>>>>        Boolean bLoginSuccessful
75834>>>>>        String sDriverID
75834>>>>>
75834>>>>>        Get psDriverID to sDriverID
75835>>>>>        Move (Trim(sDriverID)) to sDriverID
75836>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
75838>>>>>            Function_Return True
75839>>>>>        End
75839>>>>>>
75839>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
75840>>>>>        If (bTrusted = False) Begin
75842>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
75844>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
75845>>>>>            End
75845>>>>>>
75845>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
75848>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
75849>>>>>            End
75849>>>>>>
75849>>>>>            Login sServer sUserId sPassword sDriverID  
75851>>>>>        End
75851>>>>>>
75851>>>>>        Else Begin
75852>>>>>            Login sConnectionString "" "" sDriverID
75854>>>>>        End
75854>>>>>>
75854>>>>>        Move (LastErr = 0) to bLoginSuccessful
75855>>>>>
75855>>>>>        Function_Return bLoginSuccessful
75856>>>>>    End_Function
75857>>>>>End_Class
75858>>>>>
75858>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
75859>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
75861>>>>>        Boolean bLoginSuccessful
75861>>>>>        String sDriverID
75861>>>>>
75861>>>>>        Move False to Err
75862>>>>>        Get psDriverID to sDriverID
75863>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
75865>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
75866>>>>>        End
75866>>>>>>
75866>>>>>        Login sServer sUserId sPassword sDriverID
75868>>>>>
75868>>>>>        Move (not(Err)) to bLoginSuccessful
75869>>>>>        Function_Return bLoginSuccessful
75870>>>>>    End_Function
75871>>>>>End_Class
75872>>>>>
75872>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
75873>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
75875>>>>>        Boolean bLoginSuccessful
75875>>>>>        String sDriverID
75875>>>>>
75875>>>>>        Move False to Err
75876>>>>>        Get psDriverID to sDriverID
75877>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
75877>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
75877>>>>>//        End
75877>>>>>        Login sServer sUserId sPassword sDriverID
75879>>>>>
75879>>>>>        Move (not(Err)) to bLoginSuccessful
75880>>>>>        Function_Return bLoginSuccessful
75881>>>>>    End_Function
75882>>>>>End_Class
75883>>>>>
75883>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
75884>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
75886>>>>>        Function_Return ""
75887>>>>>    End_Function
75888>>>>>End_Class
75889>>>>>
75889>>>>>Class cDbUpdateDatabaseDriver is a cObject
75890>>>>>    Procedure Construct_Object
75892>>>>>        Forward Send Construct_Object
75894>>>>>        Property String psDriverID DATAFLEX_ID
75895>>>>>        Property Handle phoDriverSpecificObject
75896>>>>>    End_Procedure
75897>>>>>
75897>>>>>    Function CreateDriver Returns Handle
75899>>>>>        String sDriverID
75899>>>>>        Handle hoDriver hcDriverClass
75899>>>>>
75899>>>>>        Get psDriverID to sDriverID
75900>>>>>        Case Begin
75900>>>>>            Case (sDriverID = MSSQLDRV_ID)
75902>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
75903>>>>>                Case Break
75904>>>>>            Case (sDriverID = ODBC_DRV_ID)
75907>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
75908>>>>>                Case Break
75909>>>>>            Case (sDriverID = DB2_DRV_ID)
75912>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
75913>>>>>                Case Break               
75914>>>>>            // DATAFLEX_ID = Default driver
75914>>>>>            Case Else
75914>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
75915>>>>>                Move DATAFLEX_ID to sDriverID
75916>>>>>        Case End
75916>>>>>
75916>>>>>        Get Create hcDriverClass to hoDriver
75917>>>>>        Set psDriverID of hoDriver to sDriverID
75918>>>>>        Set phoDriverSpecificObject to hoDriver
75919>>>>>
75919>>>>>        Function_Return hoDriver
75920>>>>>    End_Function
75921>>>>>
75921>>>>>    Procedure DestroyDriver
75923>>>>>        If (phoDriverSpecificObject(Self)) Begin
75925>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
75926>>>>>        End
75926>>>>>>
75926>>>>>    End_Procedure
75927>>>>>
75927>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
75929>>>>>        String sConnect
75929>>>>>        Handle hoDriver
75929>>>>>
75929>>>>>        Get CreateDriver to hoDriver
75930>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
75931>>>>>        Send DestroyDriver
75932>>>>>        Function_Return sConnect
75933>>>>>    End_Function
75934>>>>>
75934>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
75936>>>>>        Boolean bLoginSuccessful
75936>>>>>        Handle hoDriver
75936>>>>>
75936>>>>>        Get CreateDriver to hoDriver
75937>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
75938>>>>>        Send DestroyDriver
75939>>>>>        Function_Return bLoginSuccessful
75940>>>>>    End_Function
75941>>>>>
75941>>>>>End_Class
75942>>>
75942>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cLoginEncryption.pkg)
75942>>>>>Use cCryptographerEx.pkg
75942>>>>>
75942>>>>>Class cLoginEncryption is a cObject
75943>>>>>    
75943>>>>>    Procedure Construct_Object
75945>>>>>        Forward Send Construct_Object
75947>>>>>        // this must be set to a multi (40ish) character random key
75947>>>>>        Property String psEncryptPassword ""
75948>>>>>        
75948>>>>>        Object oDataCrypter is a cCryptographerEx
75950>>>>>            Set piHash to CALG_SHA_256
75951>>>>>            Set piCipher to CALG_AES_256
75952>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
75953>>>>>            Set piProvider to PROV_RSA_AES
75954>>>>>        End_Object
75955>>>>>    End_Procedure
75956>>>>>    
75956>>>>>    // This can be augmented to return a password encryption key using any
75956>>>>>    // hidden mechanism desired.
75956>>>>>    Function GetEncryptionPassword Returns String
75958>>>>>        String sPassword
75958>>>>>        Get psEncryptPassword to sPassword
75959>>>>>        Function_Return sPassword
75960>>>>>    End_Function
75961>>>>>    
75961>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
75961>>>>>    //
75961>>>>>    // Params:
75961>>>>>    //   sPlainText     String to encrypt.
75961>>>>>    // Returns:
75961>>>>>    //   Base64 encoded hash.
75961>>>>>    Function EncryptPassword String sPlainText Returns String
75963>>>>>        String sEncryptPassword sBase64
75963>>>>>        UChar[] ucBinary
75964>>>>>        Pointer pBase64
75964>>>>>        Integer iVoid
75964>>>>>        
75964>>>>>        //  Encrypt Key
75964>>>>>        Get GetEncryptionPassword to sEncryptPassword
75965>>>>>        If (sEncryptPassword = "") Begin
75967>>>>>            Error DFERR_PROGRAM "No encryption password set"
75968>>>>>>
75968>>>>>        End
75968>>>>>>
75968>>>>>        
75968>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
75969>>>>>        
75969>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
75971>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
75972>>>>>>
75972>>>>>            Function_Return ""
75973>>>>>        End
75973>>>>>>
75973>>>>>        
75973>>>>>        //  Encode binary hash to Base64
75973>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
75974>>>>>        Move (PointerToString(pBase64)) to sBase64
75975>>>>>        Move (Free(pBase64)) to iVoid
75976>>>>>        
75976>>>>>        Function_Return sBase64
75977>>>>>    End_Function
75978>>>>>    
75978>>>>>    
75978>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
75978>>>>>    //
75978>>>>>    // Params:
75978>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
75978>>>>>    // Returns:
75978>>>>>    //   Readable plain text password
75978>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
75980>>>>>        String sEncryptPassword
75980>>>>>        UChar[] ucBinary ucPlain
75982>>>>>        Boolean bIsHex
75982>>>>>        Integer iLen iVoid
75982>>>>>        Pointer pBinary
75982>>>>>        
75982>>>>>        If (sBase64EncryptedPassword <> "") Begin
75984>>>>>            //  Decode from Base64
75984>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
75985>>>>>            
75985>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
75986>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
75987>>>>>                        
75987>>>>>            Move (Free(pBinary)) to iVoid
75988>>>>>            
75988>>>>>            //  Encrypted binary hash to string
75988>>>>>            Get GetEncryptionPassword to sEncryptPassword
75989>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
75990>>>>>        End
75990>>>>>>
75990>>>>>        
75990>>>>>        Function_Return (UCharArrayToString(ucPlain))
75991>>>>>    End_Function
75992>>>>>End_Class
75993>>>
75993>>>Class cSQLConnectionIniFile is a cIniFile
75994>>>    Procedure Construct_Object
75996>>>        Forward Send Construct_Object
75998>>>
75998>>>        Property String Private_psIniFilePath
75999>>>        Property String Private_psIniFileName CS_SQLIniFileName
76000>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
76001>>>
76001>>>        Property Boolean pbDFConnId False
76002>>>
76002>>>        // *** You really want to change this value! ***
76002>>>        // It is used when encrypting/decrypting passwords.
76002>>>        Property String psHashString "zx!2139(LI0+?ips7433"
76003>>>
76003>>>    End_Procedure
76004>>>
76004>>>    Procedure End_Construct_Object
76006>>>        Forward Send End_Construct_Object
76008>>>    End_Procedure
76009>>>
76009>>>    Procedure Set psIniFilePath String sPath
76011>>>        String sIniFile
76011>>>        Get vFolderFormat sPath to sPath
76012>>>        Set private_psIniFilePath to sPath
76013>>>        Get psIniFileName to sIniFile
76014>>>        Set psFileName to (sPath + sIniFile)
76015>>>    End_Procedure
76016>>>
76016>>>    Function psIniFilePath Returns String
76018>>>        Function_Return (private_psIniFilePath(Self))
76019>>>    End_Function
76020>>>
76020>>>    Procedure Set psIniFileName String sFileName
76022>>>        String sPath
76022>>>        Get psIniFilePath to sPath
76023>>>        Set psFileName to (sPath + sFileName)
76024>>>        Set private_psIniFileName to sFileName
76025>>>    End_Procedure
76026>>>
76026>>>    Function psIniFileName Returns String
76028>>>        Function_Return (private_psIniFileName(Self))
76029>>>    End_Function
76030>>>
76030>>>    // *** Generalized messages to Get & Set values of the ini file.
76030>>>    // Sets a value in the program's ini file (write)
76030>>>    // Pass a section name, the value name parameter and the value itself to be written.
76030>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
76032>>>        String sIniFile sPath
76032>>>
76032>>>        Get psIniFilePath to sPath
76033>>>        Get psIniFileName to sIniFile
76034>>>        Move (sPath + sIniFile) to sIniFile
76035>>>        Set psFileName to sIniFile
76036>>>        Send WriteString sSection sValueName sValue
76037>>>    End_Procedure
76038>>>
76038>>>    // Get a value from program's ini-file (read)
76038>>>    // Pass a section name and the name of the value parameter & a default value.
76038>>>    // Returns the value
76038>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
76040>>>        String sValue sIniFile sPath
76040>>>
76040>>>        Get psIniFilePath to sPath
76041>>>        Get psIniFileName to sIniFile
76042>>>        Move (sPath + sIniFile) to sIniFile
76043>>>        Set psFileName to sIniFile
76044>>>        Get ReadString sSection sValueName sDefaultValue to sValue
76045>>>
76045>>>        Function_Return sValue
76046>>>    End_Function
76047>>>
76047>>>    // Sort function that first sorts on bEnabled & then on the connection string.
76047>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
76049>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
76052>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
76055>>>
76055>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
76058>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
76061>>>
76061>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
76064>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
76067>>>
76067>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
76070>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
76073>>>
76073>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
76076>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
76079>>>
76079>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
76082>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
76085>>>
76085>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
76088>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
76091>>>
76091>>>        Function_Return (EQ)
76092>>>    End_Function
76093>>>
76093>>>    Function SQLIniFileNumberOfConnections Returns Integer
76095>>>        Handle hoSections
76095>>>        Integer iItems
76095>>>
76095>>>        Send ReadSections hoSections
76096>>>        Move (Item_Count(hoSections)) to iItems
76097>>>        Function_Return iItems
76098>>>    End_Function
76099>>>
76099>>>    // The normal connection string looks something like this;
76099>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
76099>>>    // ...but the full connection string looks like this;
76099>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
76099>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
76099>>>//        String sSection
76099>>>//        Integer iCount
76099>>>//
76099>>>//        Move False to Err
76099>>>//        Get psIniSectionName to sSection
76099>>>//        Get SQLIniFileNumberOfConnections to iCount
76099>>>//        Increment iCount
76099>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
76099>>>//
76099>>>//        Function_Return (Err = False)
76099>>>//    End_Function
76099>>>
76099>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
76101>>>        Integer iCount
76101>>>        Boolean bExists
76101>>>        String sSection
76101>>>
76101>>>        Move False to Err
76102>>>        Move 1 to iCount
76103>>>        Get psIniSectionName to sSection
76104>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
76105>>>        While (bExists = True)
76109>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
76110>>>            Increment iCount
76111>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
76112>>>        Loop
76113>>>>
76113>>>        Function_Return (Err = False)
76114>>>    End_Function
76115>>>
76115>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
76117>>>        Integer iCount
76117>>>        String sSection
76117>>>        Boolean bExists
76117>>>
76117>>>        Move False to Err
76118>>>        Move 1 to iCount
76119>>>        Get psIniSectionName to sSection
76120>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
76121>>>        While (bExists = True)
76125>>>            If (iCount = iItem) Begin
76127>>>                Send DeleteSection sSection
76128>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
76128>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
76129>>>            End
76129>>>>
76129>>>            Increment iCount
76130>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
76131>>>        Loop
76132>>>>
76132>>>
76132>>>        Function_Return (Err = False)
76133>>>    End_Function
76134>>>
76134>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
76134>>>    // If it fails the returned struct member SQLConnection.bError = True.
76134>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
76136>>>        tSQLConnection[] SQLConnectionsArray
76136>>>        tSQLConnection[] SQLConnectionsArray
76137>>>        tSQLConnection   SQLConnection
76137>>>        tSQLConnection   SQLConnection
76137>>>        Integer iIndex
76137>>>
76137>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
76138>>>        If (iIndex = -1) Begin
76140>>>            Move True to SQLConnection.bError
76141>>>            Function_Return SQLConnection
76142>>>        End
76142>>>>
76142>>>
76142>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76143>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
76144>>>
76144>>>        Function_Return SQLConnection
76145>>>    End_Function
76146>>>
76146>>>    // Returns -1 if the passed connection ID was not found, else the item number.
76146>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
76148>>>        tSQLConnection[] SQLConnectionsArray
76148>>>        tSQLConnection[] SQLConnectionsArray
76149>>>        Integer iRetval iCount iSize
76149>>>        String sValue
76149>>>        Boolean bExists
76149>>>
76149>>>        Move -1 to iRetval
76150>>>
76150>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76151>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
76152>>>        Decrement iSize
76153>>>        For iCount from 0 to iSize
76159>>>>
76159>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
76160>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
76161>>>            If (bExists) Begin
76163>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
76164>>>                Move iSize to iCount         // We're done!
76165>>>            End
76165>>>>
76165>>>        Loop
76166>>>>
76166>>>
76166>>>        Function_Return iRetval
76167>>>    End_Function
76168>>>
76168>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
76168>>>    // Used to check that ConnectionID's are unique.
76168>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
76170>>>        Integer iCount iSize iItems
76170>>>        String sValue
76170>>>        Boolean bExists
76170>>>        tSQLConnection[] SQLConnectionsArray
76170>>>        tSQLConnection[] SQLConnectionsArray
76171>>>
76171>>>        Move 0 to iItems
76172>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76173>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
76174>>>        Decrement iSize
76175>>>        For iCount from 0 to iSize
76181>>>>
76181>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
76182>>>            Move (sValue = sConnectionID) to bExists
76183>>>            If (bExists) Begin
76185>>>                Increment iItems
76186>>>            End
76186>>>>
76186>>>        Loop
76187>>>>
76187>>>
76187>>>        Function_Return (iItems > 1)
76188>>>    End_Function
76189>>>
76189>>>    // To update the SQLConnections.ini file with a new default Connection ID.
76189>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
76191>>>        Boolean bOK
76191>>>        Integer iSize iCount
76191>>>        tSQLConnection[] SQLConnectionsArray
76191>>>        tSQLConnection[] SQLConnectionsArray
76192>>>        tSQLConnection SQLConnection
76192>>>        tSQLConnection SQLConnection
76192>>>        String sConnectionString
76192>>>
76192>>>        Move False to Err
76193>>>        Get psConnectionString to sConnectionString
76194>>>
76194>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76195>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
76196>>>        Decrement iSize
76197>>>        // Set all current connection to inactive.
76197>>>        For iCount from 0 to iSize
76203>>>>
76203>>>            Move False to SQLConnectionsArray[iCount].bEnabled
76204>>>        Loop
76205>>>>
76205>>>
76205>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
76206>>>        Move True              to SQLConnection.bEnabled
76207>>>        Move sConnectionString to SQLConnection.sConnectionString
76208>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
76209>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
76210>>>
76210>>>        Function_Return (bOK = True)
76211>>>    End_Function
76212>>>
76212>>>    // Used for updating an existing connection with new data.
76212>>>    // Returns True if successful.
76212>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
76214>>>        Boolean bOK
76214>>>        Integer iItem iSize iCount
76214>>>        tSQLConnection[] SQLConnectionsArray
76214>>>        tSQLConnection[] SQLConnectionsArray
76215>>>
76215>>>        Move False to Err
76216>>>        Move -1 to iItem
76217>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76218>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
76219>>>        Decrement iSize
76220>>>        // Set all current connection to inactive.
76220>>>        For iCount from 0 to iSize
76226>>>>
76226>>>            Move False to SQLConnectionsArray[iCount].bEnabled
76227>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
76229>>>                Move iCount to iItem
76230>>>            End
76230>>>>
76230>>>        Loop
76231>>>>
76231>>>
76231>>>        If (iItem <> -1) Begin
76233>>>            Move True to SQLConnection.bEnabled
76234>>>            Move SQLConnection to SQLConnectionsArray[iItem]
76235>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
76236>>>        End
76236>>>>
76236>>>
76236>>>        Function_Return (bOK = True)
76237>>>    End_Function
76238>>>
76238>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
76240>>>        tSQLConnection[] SQLConnectionsArray
76240>>>        tSQLConnection[] SQLConnectionsArray
76241>>>        String sSection sValue
76241>>>        Integer iCount
76241>>>        Boolean bExists
76241>>>
76241>>>        Get psIniSectionName to sSection
76242>>>        Get SectionExists sSection to bExists
76243>>>        If (bExists = False) Begin
76245>>>            Function_Return SQLConnectionsArray
76246>>>        End
76246>>>>
76246>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
76247>>>        If (bExists = True) Begin
76249>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
76250>>>>
76250>>>        End
76250>>>>
76250>>>
76250>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
76251>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
76252>>>
76252>>>        While (bExists = True)                 
76256>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
76256>>>            // We always put the enabled/active connection at the top
76256>>>//            Move (iCount = 1) to bEnabled
76256>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
76256>>>
76256>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
76257>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
76258>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
76259>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
76260>>>
76260>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
76260>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
76261>>>            If (sValue = "99") Begin
76263>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
76264>>>            End
76264>>>>
76264>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
76265>>>
76265>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
76266>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
76267>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
76269>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
76270>>>            End
76270>>>>
76270>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
76272>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
76273>>>            End
76273>>>>
76273>>>
76273>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
76274>>>
76274>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
76275>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
76276>>>
76276>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
76277>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
76278>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
76280>>>                Get DecryptPassword sValue to sValue
76281>>>            End
76281>>>>
76281>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
76282>>>
76282>>>            // Here we reconstruct the connection string to be complete with all params;
76282>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
76283>>>
76283>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
76284>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
76285>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
76286>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
76287>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
76288>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
76289>>>
76289>>>            Increment iCount
76290>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
76291>>>        Loop
76292>>>>
76292>>>
76292>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
76292>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
76294>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
76295>>>        End
76295>>>>
76295>>>
76295>>>        Function_Return SQLConnectionsArray
76296>>>    End_Function
76297>>>
76297>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
76299>>>        Integer iCount iSize
76299>>>        Boolean bOK
76299>>>        String sSection sValue
76299>>>
76299>>>        // First we need to _remove_ all current connections from the ini-file.
76299>>>        Move 0 to iCount
76300>>>        Get SQLIniFileDeleteAllConnections to bOK
76301>>>        If (bOK = False) Begin
76303>>>            Function_Return False
76304>>>        End
76304>>>>
76304>>>
76304>>>        Move False to Err
76305>>>        Get psIniSectionName to sSection
76306>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
76306>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
76307>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
76308>>>        Decrement iSize
76309>>>
76309>>>        For iCount from 0 to iSize
76315>>>>
76315>>>            // DF 19 compatible settings:
76315>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
76316>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
76317>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
76318>>>            
76318>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
76319>>>
76319>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
76320>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
76322>>>                Get EncryptPassword sValue to sValue
76323>>>            End
76323>>>>
76323>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
76324>>>
76324>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
76326>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
76327>>>            End
76327>>>>
76327>>>
76327>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
76328>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
76329>>>
76329>>>            // The Database Update Framework extended settings:
76329>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
76330>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
76331>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
76332>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
76333>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
76334>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
76335>>>        Loop
76336>>>>
76336>>>
76336>>>        Function_Return (bOK and Err = False)
76337>>>    End_Function
76338>>>
76338>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
76338>>>    //
76338>>>    // SQL utility function that returns a database type (string) constant
76338>>>    // corresponding to the passed iDbType.
76338>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
76340>>>        String sRetval
76340>>>        If (iDbType = EN_dbTypeMSSQL) Begin
76342>>>            Move CS_dbTypeMSSQL to sRetval
76343>>>        End
76343>>>>
76343>>>        If (iDbType = EN_dbTypeMySQL) Begin
76345>>>            Move CS_dbTypeMySQL to sRetval
76346>>>        End
76346>>>>
76346>>>        If (iDbType = EN_dbTypeOracle) Begin
76348>>>            Move CS_dbTypeOracle to sRetval
76349>>>        End
76349>>>>
76349>>>        If (iDbType = EN_dbTypeDB2) Begin
76351>>>            Move CS_dbTypeDB2 to sRetval
76352>>>        End
76352>>>>
76352>>>        If (iDbType = EN_dbTypePostgre) Begin
76354>>>            Move CS_dbTypePostgre to sRetval
76355>>>        End
76355>>>>
76355>>>        If (iDbType = EN_DbTypePervasive) Begin
76357>>>            Move CS_DbTypePervasive to sRetval
76358>>>        End
76358>>>>
76358>>>        Function_Return sRetval
76359>>>    End_Function
76360>>>
76360>>>    // SQL utility function that returns a database type constant (integer)
76360>>>    // corresponding to the passed sDbType string constant.
76360>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
76362>>>        Integer iRetval
76362>>>        If (sDbType = CS_dbTypeMSSQL) Begin
76364>>>            Move EN_dbTypeMSSQL to iRetval
76365>>>        End
76365>>>>
76365>>>        If (sDbType = CS_dbTypeMySQL) Begin
76367>>>            Move EN_dbTypeMySQL to iRetval
76368>>>        End
76368>>>>
76368>>>        If (sDbType = CS_dbTypeOracle) Begin
76370>>>            Move EN_dbTypeOracle to iRetval
76371>>>        End
76371>>>>
76371>>>        If (sDbType = CS_dbTypeDB2) Begin
76373>>>            Move EN_dbTypeDB2 to iRetval
76374>>>        End
76374>>>>
76374>>>        If (sDbType = CS_dbTypePostgre) Begin
76376>>>            Move EN_dbTypePostgre to iRetval
76377>>>        End
76377>>>>
76377>>>        If (sDbType = CS_DbTypePervasive) Begin
76379>>>            Move EN_DbTypePervasive to iRetval
76380>>>        End
76380>>>>
76380>>>        Function_Return iRetval
76381>>>    End_Function
76382>>>
76382>>>    // Pass an integer DbType and function returns the database type integer as a string value.
76382>>>    // Used e.g. when reading a connection ini-file to display the database type in
76382>>>    // the SQL Connection program's grid.
76382>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
76384>>>        String sRetval
76384>>>        If (iDbType = EN_dbTypeMSSQL) Begin
76386>>>            Move "EN_dbTypeMSSQL" to sRetval
76387>>>        End
76387>>>>
76387>>>        If (iDbType = EN_dbTypeMySQL) Begin
76389>>>            Move "EN_dbTypeMySQL" to sRetval
76390>>>        End
76390>>>>
76390>>>        If (iDbType = EN_dbTypeOracle) Begin
76392>>>            Move "EN_dbTypeOracle" to sRetval
76393>>>        End
76393>>>>
76393>>>        If (iDbType = EN_dbTypeDB2) Begin
76395>>>            Move "EN_dbTypeDB2" to sRetval
76396>>>        End
76396>>>>
76396>>>        If (iDbType = EN_dbTypePostgre) Begin
76398>>>            Move "EN_dbTypePostgre" to sRetval
76399>>>        End
76399>>>>
76399>>>        If (iDbType = EN_DbTypePervasive) Begin
76401>>>            Move "EN_dbTypePervasive" to sRetval
76402>>>        End
76402>>>>
76402>>>        Function_Return sRetval
76403>>>    End_Function
76404>>>
76404>>>    // Pass a driver id and the function will return
76404>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
76404>>>    // quite work and always returns "MS SQL Server"
76404>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
76406>>>        Integer iRetval
76406>>>        If (sDriverID = MSSQLDRV_ID) Begin
76408>>>            Move EN_dbTypeMSSQL to iRetval
76409>>>        End
76409>>>>
76409>>>        If (sDriverID = ODBC_DRV_ID) Begin
76411>>>            Move EN_dbTypeMSSQL to iRetval
76412>>>        End
76412>>>>
76412>>>        If (sDriverID = DB2_DRV_ID) Begin
76414>>>            Move EN_dbTypeDB2 to iRetval
76415>>>        End
76415>>>>
76415>>>        If (sDriverID = DFBTRDRV_ID) Begin
76417>>>            Move EN_DbTypePervasive to iRetval
76418>>>        End
76418>>>>
76418>>>        Function_Return iRetval
76419>>>    End_Function
76420>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
76420>>>>
76420>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
76422>>>>    Integer iStart iEnd
76422>>>>    String sRetval
76422>>>>
76422>>>>    Move (Trim(sConnect)) to sConnect
76423>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
76424>>>>    If (iStart = 0) Begin
76426>>>>        Function_Return ""
76427>>>>    End
76427>>>>>
76427>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
76428>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
76429>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
76431>>>>        Move (Pos(",", sRetval))          to iEnd
76432>>>>    End
76432>>>>>
76432>>>>    Else Begin
76433>>>>        Move (Pos(";", sRetval))          to iEnd
76434>>>>    End
76434>>>>>
76434>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
76436>>>>        Move (Pos(",", sRetval))          to iEnd
76437>>>>        Decrement iEnd
76438>>>>    End
76438>>>>>
76438>>>>    If (iEnd <> 0) Begin
76440>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
76441>>>>    End
76441>>>>>
76441>>>>    Move (Replace("=", sRetval, ""))      to sRetval
76442>>>>
76442>>>>    Function_Return (Trim(sRetval))
76443>>>>End_Function
76444>>>>
76444>>>>
76444>>>
76444>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76446>>>        String sConnect
76446>>>        Handle hoDriver
76446>>>
76446>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
76447>>>        Set psDriverID of hoDriver to sDriverID
76448>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
76449>>>        Send Destroy of hoDriver
76450>>>
76450>>>        Function_Return sConnect
76451>>>    End_Function
76452>>>
76452>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
76452>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
76454>>>        String sConnect
76454>>>
76454>>>        Case Begin
76454>>>            Case (sDriverID = MSSQLDRV_ID)
76456>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
76457>>>                If (sDatabase <> "") Begin
76459>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
76460>>>                End
76460>>>>
76460>>>                Case Break
76461>>>
76461>>>            Case (sDriverID = ODBC_DRV_ID)
76464>>>                If (Uppercase(sServer) contains ".DSN") Begin
76466>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
76467>>>                End
76467>>>>
76467>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
76470>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
76471>>>                End
76471>>>>
76471>>>
76471>>>                If (sDatabase <> "") Begin
76473>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
76474>>>                End
76474>>>>
76474>>>                Case Break
76475>>>
76475>>>            Case (sDriverID = DB2_DRV_ID)
76478>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
76479>>>                If (sDatabase <> "") Begin
76481>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
76482>>>                End
76482>>>>
76482>>>                Case Break
76483>>>
76483>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
76486>>>                Break
76487>>>
76487>>>            Case Else
76487>>>                Move "" to sConnect
76488>>>        Case End
76488>>>
76488>>>        Function_Return sConnect
76489>>>    End_Function
76490>>>
76490>>>    // Use Base64
76490>>>    Function EncryptPassword String sPassword Returns String
76492>>>        String sRetval
76492>>>        Handle hoLoginEncryption
76492>>>
76492>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
76493>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
76494>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
76495>>>        Send Destroy of hoLoginEncryption
76496>>>          
76496>>>        Function_Return sRetval
76497>>>    End_Function
76498>>>
76498>>>    Function DecryptPassword String sPassword Returns String
76500>>>        String sRetval
76500>>>        Handle hoLoginEncryption
76500>>>
76500>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
76501>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
76502>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
76503>>>        Send Destroy of hoLoginEncryption
76504>>>
76504>>>        Function_Return sRetval
76505>>>    End_Function
76506>>>
76506>>>    // Returns the full path of the Application (no trailing "\")
76506>>>    Function ApplicationPath Returns String
76508>>>        String sApplicationFileName sPath
76508>>>        Integer iNumChars iRetval
76508>>>
76508>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
76509>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
76510>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
76511>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
76512>>>        Move (CString(sApplicationFileName)) to sPath
76513>>>
76513>>>        Function_Return sPath
76514>>>    End_Function
76515>>>
76515>>>    // Pass a filename including the extension. The return value
76515>>>    // will be the path of of the first found "sSearchFileName in the workspace.
76515>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
76515>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
76517>>>        Boolean bExists
76517>>>        Handle hoPaths hoIniFile
76517>>>        String[] asWorkSpaceFiles
76518>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
76518>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
76518>>>        
76518>>>        Get psIniFilePath to sProgramsPath
76519>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
76520>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
76521>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
76522>>>        If (bExists = True) Begin
76524>>>            Function_Return sProgramsPath
76525>>>        End                      
76525>>>>
76525>>>    
76525>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
76526>>>        If (Right(sProgramsPath, 1) ="\") Begin
76528>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
76529>>>        End                                              
76529>>>>
76529>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
76530>>>        
76530>>>        Move False to bExists
76531>>>        Get Create (RefClass(Array)) to hoPaths
76532>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
76533>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
76534>>>        Decrement iSize       
76535>>>        
76535>>>        For iCount from 0 to iSize
76541>>>>
76541>>>            Move asWorkspaceFiles[iCount] to sFileName
76542>>>            Get Create (Refclass(cIniFile)) to hoIniFile
76543>>>            Set psFileName of hoIniFile to sFileName
76544>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
76545>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
76551>>>>
76551>>>                Get Value of hoPaths iPath to sSection    
76552>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
76553>>>                // Check if there are more than one path specified;
76553>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
76554>>>                If (iNoOfPaths > 1) Begin         
76556>>>                    Move sRelativePath to sRelativePaths
76557>>>                    For iCountPath from 1 to iNoOfPaths
76563>>>>
76563>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
76564>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
76565>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
76566>>>                        Get vFolderFormat sPath to sPath
76567>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
76568>>>                        If (bExists = True) Begin
76570>>>                            Move iNoOfPaths to iCountPath
76571>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
76572>>>                            Move iSize to iCount
76573>>>                        End                                                    
76573>>>>
76573>>>                    Loop
76574>>>>
76574>>>                End
76574>>>>
76574>>>                Else Begin
76575>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
76576>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
76577>>>                    Get vFolderFormat sPath to sPath
76578>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
76579>>>                    If (bExists = True) Begin
76581>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
76582>>>                        Move iSize to iCount
76583>>>                    End                                                    
76583>>>>
76583>>>                End
76583>>>>
76583>>>            Loop
76584>>>>
76584>>>            If (bExists = False) Begin
76586>>>                Move "" to sPath    
76587>>>            End
76587>>>>
76587>>>            Send Destroy of hoIniFile          
76588>>>        Loop        
76589>>>>
76589>>>        Send Destroy of hoPaths
76590>>>        
76590>>>        // Then not found in workspace, look for the file in DFSysPath;
76590>>>        If (sPath = "") Begin
76592>>>            Get_File_Path sSearchFileName to sFileName   
76593>>>            Get ParseFolderName sFileName to sPath
76594>>>        End                  
76594>>>>
76594>>>        
76594>>>        Function_Return sPath    
76595>>>    End_Function
76596>>>    
76596>>>    // Pass the path to the workspace Programs folder - returns a string array
76596>>>    // with one or more .ws file names.
76596>>>    // First checks if there is a .sws file - and if so reads the name of the
76596>>>    // workspace file (.ws) and returns it as a string array.
76596>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
76596>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
76598>>>        String[] asSWSFiles asWorkspaceFiles   
76600>>>        String sFile sHomePath sDirSep
76600>>>        Integer iCh iSize
76600>>>        Boolean bExists      
76600>>>        Handle hoIniFile 
76600>>>        
76600>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
76601>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
76602>>>        If (Right(sProgramsPath, 1) ="\") Begin
76604>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
76605>>>        End                                              
76605>>>>
76605>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
76606>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
76607>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
76608>>>        Get vFolderFormat sHomePath to sHomePath 
76609>>>        
76609>>>        // First check if theres an .sws file. If there is we will open it and
76609>>>        // read the name of the .ws file name.
76609>>>        File_Exist (sHomePath + "*.sws") bExists
76610>>>        If (bExists = True) Begin
76612>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
76613>>>            If (iCh < 0) Begin
76615>>>                Function_Return asSWSFiles
76616>>>            End                                 
76616>>>>
76616>>>            
76616>>>            Repeat
76616>>>>
76616>>>                Readln channel iCh sFile
76618>>>                If (Trim(sFile) <> "") Begin
76620>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
76621>>>                End
76621>>>>
76621>>>            Until (SeqEof = True)
76623>>>            Send Seq_Close_Channel iCh    
76624>>>            
76624>>>            Move (SizeOfArray(asSWSFiles)) to iSize
76625>>>            If (iSize <> 0) Begin
76627>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
76628>>>                // Use the file with that is last as it might have the DataFlex version in it,
76628>>>                // and thus is the latest one and it is more likely it is accurate (?)...
76628>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
76629>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
76630>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
76631>>>                If (sFile <> "") Begin
76633>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
76634>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
76635>>>                    File_Exist sFile bExists
76636>>>                    If (bExists = True) Begin
76638>>>                        Move sFile to asWorkspaceFiles[0] 
76639>>>                    End
76639>>>>
76639>>>                End
76639>>>>
76639>>>                Send Destroy of hoIniFile
76640>>>            End
76640>>>>
76640>>>        End
76640>>>>
76640>>>        
76640>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
76640>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
76642>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
76643>>>            File_Exist (sProgramsPath + "*.ws") bExists
76644>>>            If (bExists = False) Begin
76646>>>                Function_Return asWorkspaceFiles
76647>>>            End
76647>>>>
76647>>>        
76647>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
76648>>>            If (iCh < 0) Begin
76650>>>                Function_Return asWorkspaceFiles
76651>>>            End                                 
76651>>>>
76651>>>            
76651>>>            Repeat
76651>>>>
76651>>>                Readln channel iCh sFile
76653>>>                If (Trim(sFile) <> "") Begin
76655>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
76656>>>                End
76656>>>>
76656>>>            Until (SeqEof = True)
76658>>>            Send Seq_Close_Channel iCh
76659>>>        End
76659>>>>
76659>>>        
76659>>>        Function_Return asWorkspaceFiles
76660>>>    End_Function
76661>>>
76661>>>End_Class
76662>
76662>Object oHtmlHelp is a cHtmlHelp
76664>    Set pbAlwaysOnTop to False
76665>End_Object
76666>
76666>Object oApplication is a cApplication
76668>    Set peHelpType to htHtmlHelp
76669>    Set psHelpFile to "Developer5.chm"
76670>    Set psCompany to "RDC Tools International"
76671>    Set psProduct to "DUF - SQL Connections Manager"
76672>    Set psVersion to (String(piVersionMajor(phoVersionInfo(Self))) + "." + String(piVersionMinor(phoVersionInfo(Self))))
76673>    Set psAutoOpenWorkspace to ""
76674>
76674>    Property String psCommandLineIniFilePath ""
76676>    Property Boolean pbIniFileExists False     
76678>    Property Handle phoMainView 0
76680>
76680>    Property String psCompileDateAndTime
76682>    // This is used by the About object to display the compile date & time:
76682>    Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_LINE
76682>        
76682>    // If the folder contains exactly one workspace file (*.ws), it will be
76682>    // returned. Else an empty string ("") will be returned.
76682>    Function FindWorkspaceFile String sPath Returns String
76685>        String sSingleWorkspaceFile
76685>        Handle hoSQLIniFile                  
76685>        String[] aWsFiles
76686>        Integer iSize
76686>        
76686>        Get Create (RefClass(cSQLConnectionIniFile)) to hoSQLIniFile
76687>        Get WorkspaceIniFiles of hoSQLIniFile sPath to aWsFiles
76688>        Move (SizeOfArray(aWsFiles)) to iSize
76689>        If (iSize = 1) Begin
76691>            Move aWsFiles[0] to sSingleWorkspaceFile
76692>        End                    
76692>        Else Begin
76693>            Move "" to sSingleWorkspaceFile
76694>        End
76694>        Send Destroy of hoSQLIniFile      
76695>        Function_Return sSingleWorkspaceFile
76696>    End_Function
76697>
76697>    Procedure OnCreate
76700>        Integer eOpened
76700>        Handle hoCmdLine
76700>        String sArgument sPath sFileName sWsFile
76700>        Integer iRetval
76700>        Boolean bExists
76700>
76700>        Get phoCommandLine to hoCmdLine
76701>        Get Argument of hoCmdLine 1 to sArgument
76702>        If (sArgument <> "") Begin
76704>            Get ParseFolderName sArgument to sPath
76705>            Get vFolderExists sPath to iRetval
76706>            If (iRetval = True) Begin
76708>                Set psCommandLineIniFilePath to sPath
76709>                Get vFilePathExists (sPath + CS_SQLIniFileName) to bExists
76710>                Set pbIniFileExists to bExists
76711>            End
76711>        End
76711>
76711>        Get OpenWorkspaceFile of (phoWorkspace(Self)) "config.ws" to eOpened
76712>        If (eOpened <> wsWorkspaceOpened) Begin
76714>            Get GetApplicationPath to sPath     
76715>            Get FindWorkspaceFile sPath to sWsFile
76716>            If (sWsFile = "") Begin
76718>                Get vSelect_File "Workspace Files (*.ws)|*.ws|All Files (*.*)|*.*" "Please select a Workspace file (*.ws)" sPath to sWsFile
76719>                Get vFilePathExists sWsFile to bExists
76720>                If (bExists = False) Begin
76722>                    Send Stop_Box "No Workspace file selected. Cannot continue!"
76723>                    Send Exit_Application
76724>                End
76724>            End
76724>            Get OpenWorkspaceFile of (phoWorkspace(Self)) sWsFile to eOpened
76725>            If (eOpened <> wsWorkspaceOpened) Begin
76727>                Set psHome          of (phoWorkspace(Self)) to sPath
76728>                Set psProgramPath   of (phoWorkspace(Self)) to sPath
76729>                Set psDataPath      of (phoWorkspace(Self)) to sPath
76730>                Set psFileList      of (phoWorkspace(Self)) to sPath
76731>                Set psHelpPath      of (phoWorkspace(Self)) to sPath
76732>                Set psBitmapPath    of (phoWorkspace(Self)) to sPath
76733>            End
76733>        End
76733>    End_Procedure  
76734>    
76734>
76734>    Procedure End_Construct_Object
76737>        String sCompileTime  
76737>        Integer iPos
76737>        
76737>        Forward Send End_Construct_Object
76739>        Direct_Input "resource: res_CompileHeader"
76740>        Readln sCompileTime
76741>        Move (Pos('"', sCompileTime)) to iPos
76742>        If (iPos <> 0) Begin
76744>            Move (Mid(sCompileTime, Length(sCompileTime), (iPos + 1))) to sCompileTime
76745>            Move (Replaces('"', sCompileTime, '')) to sCompileTime
76746>            Set psCompileDateAndTime to sCompileTime
76747>        End
76747>        Close_Input
76748>    End_Procedure
76749>
76749>End_Object
76750>
76750>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
76750>>>//****************************************************************************
76750>>>// $Module type: Class
76750>>>// $Module name: cDbUpdateFunctionLibrary
76750>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
76750>>>// Web-site    : http://www.rdctools.com
76750>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
76750>>>//
76750>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
76750>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
76750>>>//               functions to make db changes to Sql databases with DAW drivers,
76750>>>//               with the help of Sql-scripts.
76750>>>//
76750>>>// $Rev History:
76750>>>//    2014-09-05  Module header created
76750>>>//
76750>>>//****************************************************************************
76750>>>//
76750>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
76750>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
76750>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
76750>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
76750>>>// decimals you may Get truncation that again may cause problems with finding.
76750>>>//
76750>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
76750>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
76750>>>
76750>>>
76750>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
76750>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
76750>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
76750>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
76750>>>//
76750>>>Use cBaseDbUpdateFuncLib.pkg
Including file: cBaseDbUpdateFuncLib.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cBaseDbUpdateFuncLib.pkg)
76750>>>>>//****************************************************************************
76750>>>>>// $Module type: Class
76750>>>>>// $Module name: cBaseDbUpdateFuncLib
76750>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
76750>>>>>// Web-site    : http://www.rdctools.com
76750>>>>>// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
76750>>>>>//
76750>>>>>// Description : The class consists of the basis/parent for the cDbUpdateFunctionLibrary class
76750>>>>>//               It contains helper functions for the cDbUpdateFunctionLibrary class
76750>>>>>//
76750>>>>>// $Rev History:
76750>>>>>//    2023-11-06  Module header created
76750>>>>>//
76750>>>>>//****************************************************************************
76750>>>>>Use cApplication.pkg
76750>>>>>Use seq_chnl.pkg
76750>>>>>Use GlobalFunctionsProcedures.pkg
76750>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
76750>>>>>Use Dfcursor.pkg
76750>>>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
76750>>>>>>>// StatPnl.pkg - creates the standard status_panel object.
76750>>>>>>>//
76750>>>>>>>//
76750>>>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
76750>>>>>>>// invoke the standard status panel. The standard has always been that the package name
76750>>>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
76750>>>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
76750>>>>>>>// prior revisions has been replace with status panel that is part of the application.
76750>>>>>>>// This should work much better and faster than the old sentinel based solution.
76750>>>>>>>// While the way this operates has changed, the interface has not and therefore this should work
76750>>>>>>>// with most applications.
76750>>>>>>>//
76750>>>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
76750>>>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
76750>>>>>>>// a cleaner more robust interface.
76750>>>>>>>//
76750>>>>>>>//
76750>>>>>>>// Compatibility Note:
76750>>>>>>>//
76750>>>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
76750>>>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
76750>>>>>>>//
76750>>>>>>>// If for some reason you application will not work using this as a replacement for the old status
76750>>>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
76750>>>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
76750>>>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
76750>>>>>>>//
76750>>>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
76750>>>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
76750>>>>>>>//
76750>>>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
76750>>>>>>>// can still access the new object via the ghoStatusPanel handle.
76750>>>>>>>//
76750>>>>>>>//
76750>>>>>>>// Creating your own Status Panel objects
76750>>>>>>>//
76750>>>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
76750>>>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
76750>>>>>>>// with a different file and object name and direct your status panel request to the new object.
76750>>>>>>>//
76750>>>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
76750>>>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
76750>>>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
76750>>>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
76750>>>>>>>// e.g.
76750>>>>>>>//       Procedure UpdateStatusBar
76750>>>>>>>//           Send DoAdvance of oProgressBar
76750>>>>>>>//           Send ProcessEvents
76750>>>>>>>//       End_Procedure
76750>>>>>>>//
76750>>>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
76750>>>>>>>// messages this will be done for you.
76750>>>>>>>//
76750>>>>>>>// the standard Interface for status panels are:
76750>>>>>>>//
76750>>>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
76750>>>>>>>// Send Start_StatusPanel      - start the status panel
76750>>>>>>>// Send Stop_StatusPanel       - stop the status panel
76750>>>>>>>// Send Update_StatusPanel     - update the status panel's action area
76750>>>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
76750>>>>>>>//
76750>>>>>>>// Get/Set Caption_Text - updates the caption bar
76750>>>>>>>// Get/Set Title_Text   - updates the title area
76750>>>>>>>// Get/Set Message_Text - updates the Message area
76750>>>>>>>// Get/Set Action_Text  - updates the action area
76750>>>>>>>// Get/Set Button_Text  - updates the button area
76750>>>>>>>//
76750>>>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
76750>>>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
76750>>>>>>>//
76750>>>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
76750>>>>>>>Use cProcessStatusPanel.pkg
76750>>>>>>>Use cCJSkinFramework.pkg
76750>>>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cProgressBar.pkg)
76750>>>>>>>>>Use Windows.pkg
76750>>>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cWinControl.pkg)
76750>>>>>>>>>>>Use Windows.pkg
76750>>>>>>>>>>>
76750>>>>>>>>>>>// Key State Masks for Mouse Messages
76750>>>>>>>>>>>
76750>>>>>>>>>>>Define MK_LBUTTON  for |CI$0001
76750>>>>>>>>>>>Define MK_RBUTTON  for |CI$0002
76750>>>>>>>>>>>Define MK_SHIFT    for |CI$0004
76750>>>>>>>>>>>Define MK_CONTROL  for |CI$0008
76750>>>>>>>>>>>Define MK_MBUTTON  for |CI$0010
76750>>>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
76750>>>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
76750>>>>>>>>>>>
76750>>>>>>>>>>>Enum_List // Mouse Key Flags
76750>>>>>>>>>>>    Define mkLeft    for MK_LBUTTON
76750>>>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
76750>>>>>>>>>>>    Define mkRight   for MK_RBUTTON
76750>>>>>>>>>>>    Define mkX1      for MK_XBUTTON1
76750>>>>>>>>>>>    Define mkX2      for MK_XBUTTON2
76750>>>>>>>>>>>    Define mkShift   for MK_SHIFT
76750>>>>>>>>>>>    Define mkControl for MK_CONTROL
76750>>>>>>>>>>>End_Enum_List
76750>>>>>>>>>>>
76750>>>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
76750>>>>>>>>>>>    Define mbLeft
76750>>>>>>>>>>>    Define mbMiddle
76750>>>>>>>>>>>    Define mbRight
76750>>>>>>>>>>>    Define mbX1
76750>>>>>>>>>>>    Define mbX2
76750>>>>>>>>>>>End_Enum_List
76750>>>>>>>>>>>
76750>>>>>>>>>>>Class cWinControl is a DfBaseControl
76751>>>>>>>>>>>    Procedure Construct_Object
76753>>>>>>>>>>>        Forward Send Construct_Object
76755>>>>>>>>>>>        Property Integer private_pbEnabled True
76756>>>>>>>>>>>        Property Integer private_pbVisible True
76757>>>>>>>>>>>    End_Procedure
76758>>>>>>>>>>>    
76758>>>>>>>>>>>    Procedure End_Construct_Object
76760>>>>>>>>>>>        Forward Send End_Construct_Object
76762>>>>>>>>>>>        
76762>>>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
76763>>>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
76764>>>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
76765>>>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
76766>>>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
76767>>>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
76768>>>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
76769>>>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
76770>>>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
76771>>>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
76772>>>>>>>>>>>    End_Procedure
76773>>>>>>>>>>>    
76773>>>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
76775>>>>>>>>>>>        //Intentionally cancelled
76775>>>>>>>>>>>    End_Procedure
76776>>>>>>>>>>>    
76776>>>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
76778>>>>>>>>>>>        //Intentionally cancelled
76778>>>>>>>>>>>    End_Procedure
76779>>>>>>>>>>>    
76779>>>>>>>>>>>    Procedure DoRecreateWindow
76781>>>>>>>>>>>        // Recreates the window
76781>>>>>>>>>>>        If (Window_Handle(Self)) Begin
76783>>>>>>>>>>>            // attempt to do this without disturbing the focus tree.
76783>>>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
76784>>>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
76785>>>>>>>>>>>        End
76785>>>>>>>>>>>>
76785>>>>>>>>>>>    End_Procedure
76786>>>>>>>>>>>    
76786>>>>>>>>>>>    Procedure DoUpdateWindow
76788>>>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
76788>>>>>>>>>>>        Handle hWnd
76788>>>>>>>>>>>        
76788>>>>>>>>>>>        Get Window_Handle to hWnd
76789>>>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
76792>>>>>>>>>>>    End_Procedure
76793>>>>>>>>>>>    
76793>>>>>>>>>>>    Procedure Page Integer iState
76795>>>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
76796>>>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
76797>>>>>>>>>>>        Forward Send Page iState
76799>>>>>>>>>>>    End_Procedure
76800>>>>>>>>>>>    
76800>>>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
76802>>>>>>>>>>>        Integer x y eButton
76802>>>>>>>>>>>        
76802>>>>>>>>>>>        Move (Hi(lParam))  to y
76803>>>>>>>>>>>        Move (Low(lParam)) to x
76804>>>>>>>>>>>        
76804>>>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
76805>>>>>>>>>>>    End_Procedure
76806>>>>>>>>>>>    
76806>>>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
76808>>>>>>>>>>>        Integer x y eButton
76808>>>>>>>>>>>        
76808>>>>>>>>>>>        Move (Hi(lParam))  to y
76809>>>>>>>>>>>        Move (Low(lParam)) to x
76810>>>>>>>>>>>        
76810>>>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
76811>>>>>>>>>>>    End_Procedure
76812>>>>>>>>>>>    
76812>>>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
76814>>>>>>>>>>>        Integer x y eButton
76814>>>>>>>>>>>        
76814>>>>>>>>>>>        Move (Hi(lParam))  to y
76815>>>>>>>>>>>        Move (Low(lParam)) to x
76816>>>>>>>>>>>        
76816>>>>>>>>>>>        Send OnMouseUp mbRight x y wParam
76817>>>>>>>>>>>    End_Procedure
76818>>>>>>>>>>>    
76818>>>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
76820>>>>>>>>>>>        Integer x y eButton fKeys
76820>>>>>>>>>>>        
76820>>>>>>>>>>>        Move (Hi(lParam))  to y
76821>>>>>>>>>>>        Move (Low(lParam)) to x
76822>>>>>>>>>>>        
76822>>>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
76823>>>>>>>>>>>    End_Procedure
76824>>>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
76826>>>>>>>>>>>        Integer x y eButton
76826>>>>>>>>>>>        
76826>>>>>>>>>>>        Move (Hi(lParam))  to y
76827>>>>>>>>>>>        Move (Low(lParam)) to x
76828>>>>>>>>>>>        
76828>>>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
76829>>>>>>>>>>>    End_Procedure
76830>>>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
76832>>>>>>>>>>>        Integer x y eButton
76832>>>>>>>>>>>        
76832>>>>>>>>>>>        Move (Hi(lParam))  to y
76833>>>>>>>>>>>        Move (Low(lParam)) to x
76834>>>>>>>>>>>        
76834>>>>>>>>>>>        Send OnMouseDown mbRight x y wParam
76835>>>>>>>>>>>    End_Procedure
76836>>>>>>>>>>>    
76836>>>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
76838>>>>>>>>>>>        Integer x y eButton
76838>>>>>>>>>>>        
76838>>>>>>>>>>>        Move (Hi(lParam))  to y
76839>>>>>>>>>>>        Move (Low(lParam)) to x
76840>>>>>>>>>>>        
76840>>>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
76841>>>>>>>>>>>    End_Procedure
76842>>>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
76844>>>>>>>>>>>        Integer x y eButton
76844>>>>>>>>>>>        
76844>>>>>>>>>>>        Move (Hi(lParam))  to y
76845>>>>>>>>>>>        Move (Low(lParam)) to x
76846>>>>>>>>>>>        
76846>>>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
76847>>>>>>>>>>>    End_Procedure
76848>>>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
76850>>>>>>>>>>>        Integer x y eButton
76850>>>>>>>>>>>        
76850>>>>>>>>>>>        Move (Hi(lParam))  to y
76851>>>>>>>>>>>        Move (Low(lParam)) to x
76852>>>>>>>>>>>        
76852>>>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
76853>>>>>>>>>>>    End_Procedure
76854>>>>>>>>>>>    
76854>>>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
76856>>>>>>>>>>>        Integer x y eButton
76856>>>>>>>>>>>        
76856>>>>>>>>>>>        Move (Hi(lParam))  to y
76857>>>>>>>>>>>        Move (Low(lParam)) to x
76858>>>>>>>>>>>        
76858>>>>>>>>>>>        Send OnMouseMove x y wParam
76859>>>>>>>>>>>    End_Procedure
76860>>>>>>>>>>>    
76860>>>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
76862>>>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
76862>>>>>>>>>>>        //String sButton
76862>>>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
76862>>>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
76862>>>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
76862>>>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
76862>>>>>>>>>>>        
76862>>>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
76862>>>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
76862>>>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
76862>>>>>>>>>>>    End_Procedure
76863>>>>>>>>>>>    
76863>>>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
76865>>>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
76865>>>>>>>>>>>        //String sButton
76865>>>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
76865>>>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
76865>>>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
76865>>>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
76865>>>>>>>>>>>        
76865>>>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
76865>>>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
76865>>>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
76865>>>>>>>>>>>    End_Procedure
76866>>>>>>>>>>>    
76866>>>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
76868>>>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
76868>>>>>>>>>>>        //String sButton
76868>>>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
76868>>>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
76868>>>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
76868>>>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
76868>>>>>>>>>>>        
76868>>>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
76868>>>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
76868>>>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
76868>>>>>>>>>>>    End_Procedure
76869>>>>>>>>>>>    
76869>>>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
76871>>>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
76871>>>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
76871>>>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
76871>>>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
76871>>>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
76871>>>>>>>>>>>        
76871>>>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
76871>>>>>>>>>>>    End_Procedure
76872>>>>>>>>>>>    
76872>>>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
76874>>>>>>>>>>>        Handle hWnd
76874>>>>>>>>>>>        
76874>>>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
76876>>>>>>>>>>>            Set private_pbEnabled to bEnabled
76877>>>>>>>>>>>            Get Window_Handle to hWnd
76878>>>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
76881>>>>>>>>>>>        End
76881>>>>>>>>>>>>
76881>>>>>>>>>>>    End_Procedure
76882>>>>>>>>>>>    Function pbEnabled Returns Boolean
76884>>>>>>>>>>>        Function_Return (private_pbEnabled(Self))
76885>>>>>>>>>>>    End_Function
76886>>>>>>>>>>>    
76886>>>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
76888>>>>>>>>>>>        Handle  hWnd
76888>>>>>>>>>>>        Integer iVoid
76888>>>>>>>>>>>        
76888>>>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
76890>>>>>>>>>>>            Set private_pbVisible to bVisible
76891>>>>>>>>>>>            Get Window_Handle to hWnd
76892>>>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
76895>>>>>>>>>>>        End
76895>>>>>>>>>>>>
76895>>>>>>>>>>>    End_Procedure
76896>>>>>>>>>>>    Function pbVisible Returns Boolean
76898>>>>>>>>>>>        Function_Return (private_pbVisible(Self))
76899>>>>>>>>>>>    End_Function
76900>>>>>>>>>>>    
76900>>>>>>>>>>>End_Class
76901>>>>>>>>>Use CommCtrl.pkg
76901>>>>>>>>>
76901>>>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
76901>>>>>>>>>Class cProgressBar is a cWinControl
76902>>>>>>>>>    
76902>>>>>>>>>    Procedure Construct_Object
76904>>>>>>>>>        Forward Send Construct_Object
76906>>>>>>>>>        Property Integer private_piMinimum
76907>>>>>>>>>        Property Integer private_piMaximum   100
76908>>>>>>>>>        Property Integer private_piAdvanceBy 10
76909>>>>>>>>>        Property Integer private_piPosition
76910>>>>>>>>>        Property Integer private_pbVertical  False
76911>>>>>>>>>        Property Integer private_pbSmooth    False
76912>>>>>>>>>        Property Integer private_piBackColor clDefault
76913>>>>>>>>>        Property Integer private_piBarColor  clDefault
76914>>>>>>>>>        
76914>>>>>>>>>        Send Define_ToolTip_Support_Mixin
76915>>>>>>>>>        
76915>>>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
76916>>>>>>>>>        Set Focus_Mode to NonFocusable
76917>>>>>>>>>        Set Skip_State to True
76918>>>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
76919>>>>>>>>>    End_Procedure
76920>>>>>>>>>    
76920>>>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
76921>>>>>>>>>    
76921>>>>>>>>>    Procedure Set piMinimum Integer iMin
76923>>>>>>>>>        Integer iMax
76923>>>>>>>>>        
76923>>>>>>>>>        Set private_piMinimum to iMin
76924>>>>>>>>>        Get private_piMaximum to iMax
76925>>>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
76926>>>>>>>>>    End_Procedure
76927>>>>>>>>>    Function piMinimum Returns Integer
76929>>>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
76932>>>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
76934>>>>>>>>>    End_Function
76935>>>>>>>>>    
76935>>>>>>>>>    Procedure Set piMaximum Integer iMax
76937>>>>>>>>>        Integer iMin
76937>>>>>>>>>        
76937>>>>>>>>>        Set private_piMaximum to iMax
76938>>>>>>>>>        Get private_piMinimum to iMin
76939>>>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
76940>>>>>>>>>    End_Procedure
76941>>>>>>>>>    Function piMaximum Returns Integer
76943>>>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
76946>>>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
76948>>>>>>>>>    End_Function
76949>>>>>>>>>    
76949>>>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
76951>>>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
76952>>>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
76953>>>>>>>>>    End_Procedure
76954>>>>>>>>>    Function piAdvanceBy Returns Integer
76956>>>>>>>>>        Function_Return (private_piAdvanceBy(Self))
76957>>>>>>>>>    End_Function
76958>>>>>>>>>    
76958>>>>>>>>>    Procedure Set piPosition Integer iPos
76960>>>>>>>>>        Set private_piPosition to iPos
76961>>>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
76962>>>>>>>>>    End_Procedure
76963>>>>>>>>>    
76963>>>>>>>>>    Function piPosition Returns Integer
76965>>>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
76968>>>>>>>>>        Else;            Function_Return (private_piPosition(Self))
76970>>>>>>>>>    End_Function
76971>>>>>>>>>    
76971>>>>>>>>>    Procedure Set pbVertical Boolean bVertical
76973>>>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
76975>>>>>>>>>            Set private_pbVertical to bVertical
76976>>>>>>>>>            Send DoRecreateWindow
76977>>>>>>>>>        End
76977>>>>>>>>>>
76977>>>>>>>>>    End_Procedure
76978>>>>>>>>>    
76978>>>>>>>>>    Function pbVertical Returns Boolean
76980>>>>>>>>>        Function_Return (private_pbVertical(Self))
76981>>>>>>>>>    End_Function
76982>>>>>>>>>    
76982>>>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
76984>>>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
76986>>>>>>>>>            Set private_pbSmooth to bSmooth
76987>>>>>>>>>            Send DoRecreateWindow
76988>>>>>>>>>        End
76988>>>>>>>>>>
76988>>>>>>>>>    End_Procedure
76989>>>>>>>>>    Function pbSmooth Returns Boolean
76991>>>>>>>>>        Function_Return (private_pbSmooth(Self))
76992>>>>>>>>>    End_Function
76993>>>>>>>>>    
76993>>>>>>>>>    Procedure Set piBackColor Integer rgbColor
76995>>>>>>>>>        Set private_piBackColor to rgbColor
76996>>>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
76997>>>>>>>>>    End_Procedure
76998>>>>>>>>>    Function piBackColor Returns Integer
77000>>>>>>>>>        Function_Return (private_piBackColor(Self))
77001>>>>>>>>>    End_Function
77002>>>>>>>>>    
77002>>>>>>>>>    Procedure Set piBarColor Integer rgbColor
77004>>>>>>>>>        Set private_piBarColor to rgbColor
77005>>>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
77006>>>>>>>>>    End_Procedure
77007>>>>>>>>>    Function piBarColor Returns Integer
77009>>>>>>>>>        Function_Return (private_piBarColor(Self))
77010>>>>>>>>>    End_Function
77011>>>>>>>>>    
77011>>>>>>>>>    Procedure DoAdvance
77013>>>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
77014>>>>>>>>>    End_Procedure
77015>>>>>>>>>    
77015>>>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
77017>>>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
77018>>>>>>>>>    End_Procedure
77019>>>>>>>>>    
77019>>>>>>>>>    Procedure private_DoInitWindow
77021>>>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
77022>>>>>>>>>        Set piBackColor to (private_piBackColor(Self))
77023>>>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
77024>>>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
77025>>>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
77026>>>>>>>>>        Set piPosition  to (private_piPosition(Self))
77027>>>>>>>>>    End_Procedure
77028>>>>>>>>>    
77028>>>>>>>>>    Procedure Page_Object Integer iState
77030>>>>>>>>>        Handle hWnd
77030>>>>>>>>>        
77030>>>>>>>>>        Get Window_Handle to hWnd
77031>>>>>>>>>        If (hWnd=0 and iState) Begin
77033>>>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
77034>>>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
77035>>>>>>>>>            Forward Send Page_Object True
77037>>>>>>>>>        End
77037>>>>>>>>>>
77037>>>>>>>>>        Else ;            Forward Send Page_Object iState
77040>>>>>>>>>        
77040>>>>>>>>>        // Handle tooltip support....
77040>>>>>>>>>        If (iState = 0) Begin
77042>>>>>>>>>            Send RequestDeleteToolTip
77043>>>>>>>>>        End
77043>>>>>>>>>>
77043>>>>>>>>>        Else Begin
77044>>>>>>>>>            Send RequestAddToolTip
77045>>>>>>>>>        End
77045>>>>>>>>>>
77045>>>>>>>>>    End_Procedure
77046>>>>>>>>>    
77046>>>>>>>>>    Procedure Page Integer iState
77048>>>>>>>>>        Forward Send Page iState
77050>>>>>>>>>        If (iState =1);            Send private_DoInitWindow
77053>>>>>>>>>    End_Procedure
77054>>>>>>>>>    
77054>>>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
77054>>>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
77054>>>>>>>>>    // is implemented in a mixin class.
77054>>>>>>>>>    Procedure RequestAddToolTip
77056>>>>>>>>>        Send AddToolTip
77057>>>>>>>>>    End_Procedure
77058>>>>>>>>>    
77058>>>>>>>>>    
77058>>>>>>>>>    // Called by Page_Object. Handles tooltip removal.
77058>>>>>>>>>    Procedure RequestDeleteToolTip
77060>>>>>>>>>        Send DeleteToolTip
77061>>>>>>>>>    End_Procedure
77062>>>>>>>>>End_Class
77063>>>>>>>Use Windows.pkg
77063>>>>>>>Use DUFLanguageConstants.inc
77063>>>>>>>Use Statpnl.pkg
77063>>>>>>>
77063>>>>>>>
77063>>>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
77063>>>>>>>
77063>>>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
77063>>>>>>>
77063>>>>>>>Object Status_Panel is a cProcessStatusPanel
77065>>>>>>>    Set Size to 152 222
77066>>>>>>>    Set Border_Style to Border_Dialog
77067>>>>>>>    Set Icon to "Default.ico"
77068>>>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
77069>>>>>>>
77069>>>>>>>    Property Boolean Cancel_Button_Visible_State True
77071>>>>>>>
77071>>>>>>>    Procedure Activate
77074>>>>>>>        Integer iSizeBefore
77074>>>>>>>        Get GuiSize to iSizeBefore
77075>>>>>>>        Forward Send Activate
77077>>>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
77078>>>>>>>    End_Procedure
77079>>>>>>>
77079>>>>>>>    Procedure End_Construct_Object
77082>>>>>>>        Forward Send End_Construct_Object
77084>>>>>>>        Set Label of oTitleTxt      to ""
77085>>>>>>>        Set Label of oTableNameTxt  to ""
77086>>>>>>>        Set Label of oMessageTxt    to ""
77087>>>>>>>        Set Label of oActionTxt     to ""
77088>>>>>>>    End_Procedure
77089>>>>>>>
77089>>>>>>>    Object oTitleTxt is a TextBox
77091>>>>>>>        Set Location to 5 21
77092>>>>>>>        Set Size to 8 179
77093>>>>>>>        Set Auto_Size_State to False
77094>>>>>>>        Set Justification_Mode  to jMode_Center
77095>>>>>>>        Set Label to "This is the Title Text"
77096>>>>>>>    End_Object
77097>>>>>>>
77097>>>>>>>    Object oTableNameTxt is a TextBox
77099>>>>>>>        Set Size to 19 204
77100>>>>>>>        Set Location to 18 9
77101>>>>>>>        Set Auto_Size_State to False
77102>>>>>>>        Set Justification_Mode to JMode_Left
77103>>>>>>>        Set Label to "This is the TableName Text"
77104>>>>>>>    End_Object
77105>>>>>>>
77105>>>>>>>    Object oMessageTxt is a TextBox
77107>>>>>>>        Set Location to 39 9
77108>>>>>>>        Set Size to 19 204
77109>>>>>>>        Set Auto_Size_State to False
77110>>>>>>>        Set Justification_Mode to JMode_Left
77111>>>>>>>        Set Label to "This is the Message text"
77112>>>>>>>    End_Object
77113>>>>>>>
77113>>>>>>>    Object oActionTxt is a TextBox
77115>>>>>>>        Set Size to 16 204
77116>>>>>>>        Set Location to 60 9
77117>>>>>>>        Set Auto_Size_State to False
77118>>>>>>>        Set Justification_Mode to JMode_Left
77119>>>>>>>        Set Label to "This is the Action Text"
77120>>>>>>>    End_Object
77121>>>>>>>
77121>>>>>>>    Object oStopButton is a Button
77123>>>>>>>        Set Location to 123 82
77124>>>>>>>        Set Label to C_$Cancel
77125>>>>>>>
77125>>>>>>>        Procedure OnClick 
77128>>>>>>>            Integer iRetval
77128>>>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
77129>>>>>>>            If (iRetval = MBR_Yes) Begin
77131>>>>>>>                Send Exit_Application
77132>>>>>>>            End
77132>>>>>>>>
77132>>>>>>>        End_Procedure
77133>>>>>>>
77133>>>>>>>    End_Object
77134>>>>>>>
77134>>>>>>>    Object oPercentage_tb is a TextBox
77136>>>>>>>        Set Location to 74 196
77137>>>>>>>        Set Size to 10 25
77138>>>>>>>//        Set Label to "% Done"
77138>>>>>>>    End_Object
77139>>>>>>>
77139>>>>>>>    Object oCopyRight is a TextBox
77141>>>>>>>        Set Location to 140 21
77142>>>>>>>        Set Size to 9 197
77143>>>>>>>        Set FontPointHeight to 8
77144>>>>>>>        Set Auto_Size_State to False
77145>>>>>>>        Set Justification_Mode  to jMode_Center
77146>>>>>>>        Set Label to "Copyright 2001-2023 RDC Tools International"
77147>>>>>>>    End_Object
77148>>>>>>>
77148>>>>>>>    Object oProgressBar is a cProgressBar
77150>>>>>>>        Set Size to 10 179
77151>>>>>>>        Set Location to 83 22
77152>>>>>>>        Set pbVisible to True // default
77153>>>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
77154>>>>>>>    End_Object
77155>>>>>>>
77155>>>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
77158>>>>>>>        Set pbVisible of ghoProgressBar to bVisible
77159>>>>>>>    End_Procedure
77160>>>>>>>
77160>>>>>>>    Function Progress_Bar_Visible_State Returns Boolean
77163>>>>>>>        Boolean bVisible
77163>>>>>>>        Get pbVisible of ghoProgressBar to bVisible
77164>>>>>>>        Function_Return (bVisible)
77165>>>>>>>    End_Function
77166>>>>>>>
77166>>>>>>>    Object oProgressBarOverall is a cProgressBar
77168>>>>>>>        Set Size to 10 179
77169>>>>>>>        Set Location to 107 22
77170>>>>>>>        Set pbVisible to True // default
77171>>>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
77172>>>>>>>    End_Object
77173>>>>>>>
77173>>>>>>>    Object oOverallProgress_tb is a TextBox
77175>>>>>>>        Set Size to 10 65
77176>>>>>>>        Set Location to 95 24
77177>>>>>>>        Set Label to "Overall Progress"
77178>>>>>>>    End_Object
77179>>>>>>>
77179>>>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
77182>>>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
77183>>>>>>>    End_Procedure
77184>>>>>>>
77184>>>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
77187>>>>>>>        Boolean bVisible
77187>>>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
77188>>>>>>>        Function_Return (bVisible)
77189>>>>>>>    End_Function
77190>>>>>>>
77190>>>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
77190>>>>>>>    // objects defined within this instance of the status panel.
77190>>>>>>>
77190>>>>>>>    // note: all of the messages that change text should be forwarded
77190>>>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
77190>>>>>>>
77190>>>>>>>    Procedure Set Message_Text String sText
77193>>>>>>>        Set Label of oMessageTxt to sText
77194>>>>>>>        Forward Set Message_Text to sText
77196>>>>>>>    End_Procedure
77197>>>>>>>
77197>>>>>>>    Function Message_Text Returns String
77200>>>>>>>        Function_Return (Label(oMessageTxt))
77201>>>>>>>    End_Function
77202>>>>>>>
77202>>>>>>>    Procedure Set Action_Text String sText
77205>>>>>>>        Set Label of oActionTxt to sText
77206>>>>>>>        Forward Set Action_Text to sText
77208>>>>>>>    End_Procedure
77209>>>>>>>
77209>>>>>>>    Function Action_Text Returns String
77212>>>>>>>        Function_Return (Label(oActionTxt))
77213>>>>>>>    End_Function
77214>>>>>>>
77214>>>>>>>    Procedure Set Button_Text String sText
77217>>>>>>>        Set Label of oStopButton to sText
77218>>>>>>>        Forward Set Button_Text to sText
77220>>>>>>>    End_Procedure
77221>>>>>>>
77221>>>>>>>    Function Button_Text Returns String
77224>>>>>>>        Function_Return (Label(oStopButton))
77225>>>>>>>    End_Function
77226>>>>>>>
77226>>>>>>>    Procedure Set Title_Text String sText
77229>>>>>>>        Set Label of oTitleTxt to sText
77230>>>>>>>        Forward Set Title_Text to sText
77232>>>>>>>    End_Procedure
77233>>>>>>>
77233>>>>>>>    Function Title_Text Returns String
77236>>>>>>>        Function_Return (Label(oTitleTxt))
77237>>>>>>>    End_Function
77238>>>>>>>
77238>>>>>>>    Procedure Set TableName_Text String sText
77241>>>>>>>        Set Label of oTableNameTxt to sText
77242>>>>>>>    End_Procedure
77243>>>>>>>
77243>>>>>>>    Function TableName_Text Returns String
77246>>>>>>>        Function_Return (Label(oTableNameTxt))
77247>>>>>>>    End_Function
77248>>>>>>>
77248>>>>>>>    Procedure Set License_Text String sText
77251>>>>>>>//        Set Label of oLicense_txt to sText
77251>>>>>>>    End_Procedure
77252>>>>>>>
77252>>>>>>>    // gets called when status panel is activated passing whether a button
77252>>>>>>>    // should appear
77252>>>>>>>    Procedure EnableCancelButton Boolean bEnable
77255>>>>>>>        Boolean bVisible
77255>>>>>>>        Get Cancel_Button_Visible_State to bVisible
77256>>>>>>>        If (bEnable = False) Begin
77258>>>>>>>            Set Visible_State of oStopButton to bVisible
77259>>>>>>>        End
77259>>>>>>>>
77259>>>>>>>        Set Enabled_State of oStopButton to bEnable
77260>>>>>>>    End_Procedure
77261>>>>>>>
77261>>>>>>>    Procedure Reset_StatusPanel
77264>>>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
77265>>>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
77266>>>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
77267>>>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
77268>>>>>>>    End_Procedure
77269>>>>>>>
77269>>>>>>>//    Object oProgressBar is a cProgressBar
77269>>>>>>>//        Move Self to ghoProgressBar
77269>>>>>>>//        Set Location to 1 25
77269>>>>>>>//        Set Size to 9 173
77269>>>>>>>//        Set piMinimum        to 0
77269>>>>>>>//        Set piMaximum        to 2000
77269>>>>>>>//        Set piAdvanceBy      to 100
77269>>>>>>>//        Set pbSmooth to True
77269>>>>>>>//
77269>>>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
77269>>>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
77269>>>>>>>//        // color will show correctly.
77269>>>>>>>//        Procedure Page Integer iPageObject
77269>>>>>>>//            Handle hWin
77269>>>>>>>//            Forward Send Page iPageObject
77269>>>>>>>//            If (ghoSkinFramework <> 0) Begin
77269>>>>>>>//                Get Window_Handle to hWin
77269>>>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
77269>>>>>>>//            End
77269>>>>>>>//        End_Procedure
77269>>>>>>>//    End_Object
77269>>>>>>>
77269>>>>>>>End_Object
77270>>>>>>>
77270>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
77270>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
77270>>>>>>>//
77270>>>>>>>// We need to create a mixin class for the library.
77270>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
77270>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
77270>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
77270>>>>>>>// Note: This class should _not_ have a construct_object defined.
77270>>>>>>>//
77270>>>>>>>Use VdfBase.pkg
77270>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 23.0\Pkg\WinUuid.pkg)
77270>>>>>>>>>Use Unicode.Pkg
77270>>>>>>>>>
77270>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
77271>>>>>>>>>
77271>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
77272>>>>>>>>>
77272>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
77273>>>>>>>>>
77273>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
77274>>>>>>>>>
77274>>>>>>>>>
77274>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
77274>>>>>>>>>Function RandomHexUUID Global Returns String
77276>>>>>>>>>    Pointer pUUID pUUIDStr
77276>>>>>>>>>    Integer iRetval iOffset iChar
77276>>>>>>>>>    String sUUID
77276>>>>>>>>>    
77276>>>>>>>>>    Move (Alloc(16)) to pUUID
77277>>>>>>>>>    
77277>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
77278>>>>>>>>>    
77278>>>>>>>>>    If (iRetval = 0) Begin
77280>>>>>>>>>        Move 0 to pUUIDStr
77281>>>>>>>>>        
77281>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
77282>>>>>>>>>        If (iRetval = 0) Begin
77284>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
77285>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
77286>>>>>>>>>            
77286>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
77287>>>>>>>>>        End
77287>>>>>>>>>>
77287>>>>>>>>>    End
77287>>>>>>>>>>
77287>>>>>>>>>    
77287>>>>>>>>>    Move (Free(pUUID)) to iRetval
77288>>>>>>>>>    
77288>>>>>>>>>    Function_Return sUUID
77289>>>>>>>>>End_Function
77290>>>>>>>>>
77290>>>>>>>>>
77290>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
77290>>>>>>>>>Function SeqHexUUID Global Returns String
77292>>>>>>>>>    Pointer pUUID pUUIDStr
77292>>>>>>>>>    Integer iRetval iOffset iChar
77292>>>>>>>>>    String sUUID
77292>>>>>>>>>    
77292>>>>>>>>>    Move (Alloc(16)) to pUUID
77293>>>>>>>>>    
77293>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
77294>>>>>>>>>    
77294>>>>>>>>>    If (iRetval = 0) Begin
77296>>>>>>>>>        Move 0 to pUUIDStr
77297>>>>>>>>>        
77297>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
77298>>>>>>>>>        If (iRetval = 0) Begin
77300>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
77301>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
77302>>>>>>>>>            
77302>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
77303>>>>>>>>>        End
77303>>>>>>>>>>
77303>>>>>>>>>    End
77303>>>>>>>>>>
77303>>>>>>>>>    
77303>>>>>>>>>    Move (Free(pUUID)) to iRetval
77304>>>>>>>>>    
77304>>>>>>>>>    Function_Return sUUID
77305>>>>>>>>>End_Function
77306>>>>>>>Use cli.pkg
77306>>>>>>>Use sql.pkg
77306>>>>>>>Use MSSqldrv.pkg
77306>>>>>>>Use db2_drv.pkg
77306>>>>>>>Use odbc_drv.pkg
77306>>>>>>>Use DFBTRDRV.PKG
77306>>>>>>>Use cSQLConnectionIniFile.inc
77306>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
77306>>>>>>>>>Use DUFLanguageConstants.inc
77306>>>>>>>>>
77306>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
77306>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
77306>>>>>>>>>
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_OEM_Txt for "OEM"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_SERVER for "SERVER"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
77306>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
77306>>>>>>>>>
77306>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
77306>>>>>>>>>    Global_Variable Handle ghoDbUpdateHandler    
77306>>>>>>>>>    Move 0 to ghoDbUpdateHandler
77307>>>>>>>>>
77307>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
77307>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
77308>>>>>>>>>
77308>>>>>>>>>Struct tSQLScriptArray
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>    Boolean bArgumentSizeChanged
77308>>>>>>>>>    Integer iOrgArgumentSize
77308>>>>>>>>>    String[] sSQLScriptArray
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tSqlErrorArray
77308>>>>>>>>>    String[]  sSqlErrorArray
77308>>>>>>>>>    String[]  sSqlStatementArray
77308>>>>>>>>>    Integer[] iSqlErrorArray
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tSqlColumnNew
77308>>>>>>>>>    String  sBaseColumnName
77308>>>>>>>>>    String  sBaseTableName
77308>>>>>>>>>    String  sLabel
77308>>>>>>>>>    Integer iSqlType
77308>>>>>>>>>    Integer iSize
77308>>>>>>>>>    Integer iPrecision
77308>>>>>>>>>    Integer iDFType
77308>>>>>>>>>    Integer iDFNativeType
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tColumnType
77308>>>>>>>>>    String  sSQLType
77308>>>>>>>>>    Integer iSQLType
77308>>>>>>>>>    Boolean bCanEditSize
77308>>>>>>>>>    Integer iDefaultSize
77308>>>>>>>>>    Integer iMinSize
77308>>>>>>>>>    Number  nMaxSize
77308>>>>>>>>>    String  sDataFlexType
77308>>>>>>>>>    Integer iDataFlexType
77308>>>>>>>>>    Boolean bNativeDataType
77308>>>>>>>>>    String  sPrecision
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
77308>>>>>>>>>// Various SQL back-ends can have slightly different
77308>>>>>>>>>// keywords.
77308>>>>>>>>>Struct tSQLKeyWords
77308>>>>>>>>>    Integer iSQLWord
77308>>>>>>>>>    Integer iSQLDbType
77308>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tSQLRelation
77308>>>>>>>>>    Integer iFileNumber
77308>>>>>>>>>    Integer iFieldNumber
77308>>>>>>>>>    String  sFileName
77308>>>>>>>>>    String  sFieldName
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tSQLLoggedInUser
77308>>>>>>>>>    String sUser
77308>>>>>>>>>    String sProgram
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
77308>>>>>>>>>Enumeration_List
77308>>>>>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
77308>>>>>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
77308>>>>>>>>>End_Enumeration_List
77308>>>>>>>>>
77308>>>>>>>>>// We need to re-define the standard constants because several driver constants
77308>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
77308>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
77308>>>>>>>>>// They can have slightly different SQL keywords.
77308>>>>>>>>>// Note: If a new type is added to the list,
77308>>>>>>>>>//       the struct array xxx must be adjusted
77308>>>>>>>>>//       so that it is filled with all SQL
77308>>>>>>>>>//       keywords for that new type.
77308>>>>>>>>>Enum_List
77308>>>>>>>>>//    Define EN_DbTypeMSSQL
77308>>>>>>>>>//    Define EN_DbTypeMySQL
77308>>>>>>>>>//    Define EN_DbTypeOracle
77308>>>>>>>>>//    Define EN_DbTypeDB2
77308>>>>>>>>>//    Define EN_DbTypePostgre
77308>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
77308>>>>>>>>>End_Enum_List
77308>>>>>>>>>
77308>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
77308>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
77308>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
77308>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
77308>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
77308>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
77308>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
77308>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
77308>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
77308>>>>>>>>>
77308>>>>>>>>>// We need to re-define the standard constants because several driver constants
77308>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
77308>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
77308>>>>>>>>>Enum_List
77308>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
77308>>>>>>>>>    Define DF_BCD_DUF       for -1499
77308>>>>>>>>>    Define DF_DATE_DUF      for -1498
77308>>>>>>>>>    Define DF_TEXT_DUF      for -1495
77308>>>>>>>>>    Define DF_BINARY_DUF    for -1494
77308>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
77308>>>>>>>>>End_Enum_List
77308>>>>>>>>>
77308>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
77308>>>>>>>>>
77308>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
77308>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
77308>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
77308>>>>>>>>>
77308>>>>>>>>>// These are not defined pre DF 18:
77308>>>>>>>>>
77308>>>>>>>>>Struct tSQLIntTableInfo
77308>>>>>>>>>    String sDriverName
77308>>>>>>>>>    String sServerName
77308>>>>>>>>>    String sDatabaseName
77308>>>>>>>>>    String sSchemaName
77308>>>>>>>>>    Boolean bRecnumTable
77308>>>>>>>>>    Integer iPrimaryIndex
77308>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
77308>>>>>>>>>    String sTableCharacterFormat
77308>>>>>>>>>    Boolean bUseDummyZeroDate
77308>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
77308>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
77308>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
77308>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
77308>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
77308>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
77308>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
77308>>>>>>>>>    String sFileIndexTablespace
77308>>>>>>>>>    String sFileLongTablespace
77308>>>>>>>>>    String sTableTablespace
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tSQLIntColumnInfo
77308>>>>>>>>>    Integer iFieldNumber
77308>>>>>>>>>    Integer iFieldIndex
77308>>>>>>>>>    Integer iFieldRelatedFile
77308>>>>>>>>>    Integer iFieldRelatedField
77308>>>>>>>>>    Integer iIndexNumber
77308>>>>>>>>>    Integer iIndexNumberSegments
77308>>>>>>>>>    Integer iIndexSegmentField1
77308>>>>>>>>>    Integer iIndexSegmentField2
77308>>>>>>>>>    Integer iIndexSegmentFieldn
77308>>>>>>>>>    String  sIndexName
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPIColumn
77308>>>>>>>>>    Integer iFieldNumber
77308>>>>>>>>>    String  sFieldName
77308>>>>>>>>>    Integer iType
77308>>>>>>>>>    String  sType
77308>>>>>>>>>    Integer iLength
77308>>>>>>>>>    Integer iPrecision
77308>>>>>>>>>    Integer iOptions
77308>>>>>>>>>    Boolean bIsSQLType
77308>>>>>>>>>    Boolean bAllowNULL
77308>>>>>>>>>    String  sDefaultValue
77308>>>>>>>>>    Boolean bShouldChange
77308>>>>>>>>>    Boolean bCancel
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPIColumnCompare
77308>>>>>>>>>    Integer iFieldNumber
77308>>>>>>>>>    // FROM database:
77308>>>>>>>>>    Boolean bExistsFrom
77308>>>>>>>>>    String  sFieldNameFrom
77308>>>>>>>>>    Integer iTypeFrom
77308>>>>>>>>>    String  sTypeFrom
77308>>>>>>>>>    Integer iLengthFrom
77308>>>>>>>>>    Integer iPrecisionFrom
77308>>>>>>>>>    Integer iOptionsFrom
77308>>>>>>>>>    Boolean bIsSQLTypeFrom
77308>>>>>>>>>    Boolean bAllowNULLFrom
77308>>>>>>>>>    String  sDefaultValueFrom
77308>>>>>>>>>    Boolean bShouldChangeFrom
77308>>>>>>>>>    Boolean bCancelFrom
77308>>>>>>>>>    Boolean bErrorFrom
77308>>>>>>>>>    // TO database:
77308>>>>>>>>>    Boolean bExistsTo
77308>>>>>>>>>    Integer iFieldNumberTo
77308>>>>>>>>>    String  sFieldNameTo
77308>>>>>>>>>    Integer iTypeTo
77308>>>>>>>>>    String  sTypeTo
77308>>>>>>>>>    Integer iLengthTo
77308>>>>>>>>>    Integer iPrecisionTo
77308>>>>>>>>>    Integer iOptionsTo
77308>>>>>>>>>    Boolean bIsSQLTypeTo
77308>>>>>>>>>    Boolean bAllowNULLTo
77308>>>>>>>>>    String  sDefaultValueTo
77308>>>>>>>>>    Boolean bShouldChangeTo
77308>>>>>>>>>    Boolean bCancelTo
77308>>>>>>>>>    Boolean bErrorTo
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPIRelation
77308>>>>>>>>>    Handle  hTableFrom
77308>>>>>>>>>    Integer iColumnFrom
77308>>>>>>>>>    Handle  hTableTo
77308>>>>>>>>>    Integer iColumnTo
77308>>>>>>>>>    String  sLogicalNameFrom
77308>>>>>>>>>    String  sLogicalNameTo
77308>>>>>>>>>    String  sFieldNameFrom
77308>>>>>>>>>    String  sFieldNameTo
77308>>>>>>>>>    Boolean bShouldChange
77308>>>>>>>>>    Boolean bCancel
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPIRelationCompare
77308>>>>>>>>>    // Common:
77308>>>>>>>>>    Handle  hTableFrom
77308>>>>>>>>>    Integer iColumnFrom
77308>>>>>>>>>    Handle  hTableTo
77308>>>>>>>>>    Integer iColumnTo
77308>>>>>>>>>    // FROM database:
77308>>>>>>>>>    Boolean bExistsFrom
77308>>>>>>>>>    String  sLogicalNameFrom_From
77308>>>>>>>>>    String  sLogicalNameTo_From
77308>>>>>>>>>    String  sFieldNameFrom_From
77308>>>>>>>>>    String  sFieldNameTo_From
77308>>>>>>>>>    Boolean bShouldChange_From
77308>>>>>>>>>    Boolean bCancel_From
77308>>>>>>>>>    Boolean bError_From
77308>>>>>>>>>    // TO database:
77308>>>>>>>>>    Boolean bExistsTo
77308>>>>>>>>>    String  sLogicalNameFrom_To
77308>>>>>>>>>    String  sLogicalNameTo_To
77308>>>>>>>>>    String  sFieldNameFrom_To
77308>>>>>>>>>    String  sFieldNameTo_To
77308>>>>>>>>>    Boolean bShouldChange_To
77308>>>>>>>>>    Boolean bCancel_To
77308>>>>>>>>>    Boolean bError_To
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPIIndexSegment
77308>>>>>>>>>    Integer iFieldNumber
77308>>>>>>>>>    String  sFieldName
77308>>>>>>>>>    Boolean bUppercase
77308>>>>>>>>>    Boolean bAscending
77308>>>>>>>>>    Boolean bShouldChange
77308>>>>>>>>>    Boolean bCancel
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPIIndex
77308>>>>>>>>>    Integer iIndexNumber
77308>>>>>>>>>    Integer iPrimaryIndex
77308>>>>>>>>>    String  sSQLIndexName
77308>>>>>>>>>    Integer iSQLIndexType
77308>>>>>>>>>    Boolean bIsSQLClustered
77308>>>>>>>>>    Boolean bIsSQLPrimaryKey
77308>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
77308>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
77308>>>>>>>>>    Boolean bShouldChange
77308>>>>>>>>>    Boolean bCancel
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPIIndexCompare
77308>>>>>>>>>    // Common:
77308>>>>>>>>>    Integer iIndexNumber
77308>>>>>>>>>    // FROM database:
77308>>>>>>>>>    Boolean bExistsFrom
77308>>>>>>>>>    Integer iPrimaryIndexFrom
77308>>>>>>>>>    String  sSQLIndexNameFrom
77308>>>>>>>>>    Integer iSQLIndexTypeFrom
77308>>>>>>>>>    Boolean bIsSQLClusteredFrom
77308>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
77308>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
77308>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
77308>>>>>>>>>    Boolean bShouldChangeFrom
77308>>>>>>>>>    Boolean bCancelFrom
77308>>>>>>>>>    Boolean bErrorFrom
77308>>>>>>>>>    // TO database:
77308>>>>>>>>>    Boolean bExistsTo
77308>>>>>>>>>    Integer iPrimaryIndexTo
77308>>>>>>>>>    String  sSQLIndexNameTo
77308>>>>>>>>>    Integer iSQLIndexTypeTo
77308>>>>>>>>>    Boolean bIsSQLClusteredTo
77308>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
77308>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
77308>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
77308>>>>>>>>>    Boolean bShouldChangeTo
77308>>>>>>>>>    Boolean bCancelTo
77308>>>>>>>>>    Boolean bErrorTo
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPITableNameInfo
77308>>>>>>>>>    Integer iTableNumber
77308>>>>>>>>>    String  sRootName
77308>>>>>>>>>    String  sLogicalName
77308>>>>>>>>>    String  sDisplayName
77308>>>>>>>>>    String  sDriverID
77308>>>>>>>>>    Boolean bIsAlias
77308>>>>>>>>>    Boolean bIsSQL
77308>>>>>>>>>    Boolean bIsSystemFile
77308>>>>>>>>>    Boolean bShouldChange
77308>>>>>>>>>    Boolean bCancel
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPITableNameInfoCompare
77308>>>>>>>>>    Integer iTableNumber
77308>>>>>>>>>    // FROM
77308>>>>>>>>>    Boolean bExistsFrom
77308>>>>>>>>>    String  sRootNameFrom
77308>>>>>>>>>    String  sLogicalNameFrom
77308>>>>>>>>>    String  sDisplayNameFrom
77308>>>>>>>>>    String  sDriverIDFrom
77308>>>>>>>>>    Boolean bIsAliasFrom
77308>>>>>>>>>    Boolean bIsSQLFrom
77308>>>>>>>>>    Boolean bIsSystemFileFrom
77308>>>>>>>>>    // TO database:
77308>>>>>>>>>    Boolean bExistsTo
77308>>>>>>>>>    String  sRootNameTo
77308>>>>>>>>>    String  sLogicalNameTo
77308>>>>>>>>>    String  sDisplayNameTo
77308>>>>>>>>>    String  sDriverIDTo
77308>>>>>>>>>    Boolean bIsAliasTo
77308>>>>>>>>>    Boolean bIsSQLTo
77308>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
77308>>>>>>>>>    Boolean bShouldChange
77308>>>>>>>>>    Boolean bCancel
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPITable
77308>>>>>>>>>    Handle hTable
77308>>>>>>>>>    Boolean bFromTable
77308>>>>>>>>>    Boolean bToTable
77308>>>>>>>>>    tAPITableNameInfo ApiTableInfo
77308>>>>>>>>>    tAPITableNameInfo ApiTableInfo
77308>>>>>>>>>    tAPIColumn[]      aApiColumns
77308>>>>>>>>>    tAPIColumn[]      aApiColumns
77308>>>>>>>>>    tAPIIndex[]       aApiIndexes
77308>>>>>>>>>    tAPIIndex[]       aApiIndexes
77308>>>>>>>>>    tAPIRelation[]    aApiRelations
77308>>>>>>>>>    tAPIRelation[]    aApiRelations
77308>>>>>>>>>    Boolean bShouldChange
77308>>>>>>>>>    Boolean bCancel
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPITableCompare
77308>>>>>>>>>    Handle hTable
77308>>>>>>>>>    // FROM database:
77308>>>>>>>>>    Boolean bExistsFrom
77308>>>>>>>>>    // TO database:
77308>>>>>>>>>    Boolean bExistsTo
77308>>>>>>>>>    // Both:
77308>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
77308>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
77308>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
77308>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
77308>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
77308>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
77308>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
77308>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
77308>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
77308>>>>>>>>>    Boolean bCancel         // User cancel
77308>>>>>>>>>    Boolean bError          // Error occured while collecting data
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPITableBooleans
77308>>>>>>>>>    Boolean bApiTableUpdateAuto
77308>>>>>>>>>    Boolean bCompareDate_DateTime
77308>>>>>>>>>    Boolean bCompareIndexAscending
77308>>>>>>>>>    Boolean bCompareIndexUppercase
77308>>>>>>>>>    Boolean bCompareFilelistUppercase
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Define C_tAPIColumn_None for 0
77308>>>>>>>>>Define C_tAPIColumn_Identity for 1
77308>>>>>>>>>
77308>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
77308>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
77308>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
77308>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
77308>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
77308>>>>>>>>>Enum_List
77308>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
77308>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
77308>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
77308>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
77308>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
77308>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
77308>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
77308>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
77308>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
77308>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
77308>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
77308>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
77308>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
77308>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
77308>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
77308>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
77308>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
77308>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
77308>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
77308>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
77308>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
77308>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
77308>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
77308>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
77308>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
77308>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
77308>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
77308>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
77308>>>>>>>>>    Define CI_SQLTo                    //for "TO"
77308>>>>>>>>>    Define CI_SQLGO                    //for "GO"
77308>>>>>>>>>    Define CI_SQLUse                   //for "USE"
77308>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
77308>>>>>>>>>
77308>>>>>>>>>    Define CI_SQLName                  //for "NAME"
77308>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
77308>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
77308>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
77308>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
77308>>>>>>>>>    Define CI_SQLID                    //for "ID"
77308>>>>>>>>>    Define CI_SQLAND                   //for "AND"
77308>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
77308>>>>>>>>>    Define CI_SQLSet                   //for "SET"
77308>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
77308>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
77308>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
77308>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
77308>>>>>>>>>End_Enum_List
77308>>>>>>>>>
77308>>>>>>>>>
77308>>>>>>>
77308>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
77309>>>>>>>
77309>>>>>>>    Procedure CreateDbUpdateLibraryProperties
77311>>>>>>>        Handle hoSQLManagerMT
77311>>>>>>>
77311>>>>>>>        Property String private.psUseDatabase ""
77312>>>>>>>
77312>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
77312>>>>>>>        Property Handle  private.phCurrentTable 0
77313>>>>>>>        Property Integer private.piCurrentField 0
77314>>>>>>>
77314>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
77315>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
77316>>>>>>>
77316>>>>>>>        Property Handle phoSQLManagerMT
77317>>>>>>>
77317>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
77318>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
77319>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
77320>>>>>>>        Property Handle phoSQLConnectionHandler 0
77321>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
77322>>>>>>>
77322>>>>>>>        Property Boolean pbHandleQueryErrors True
77323>>>>>>>
77323>>>>>>>        Property tSqlColumnNew[] paQueryColumns
77324>>>>>>>        Property String[] paSQLFetchResults
77325>>>>>>>
77325>>>>>>>        // Error handling
77325>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
77326>>>>>>>        Property Boolean pbSqlError False
77327>>>>>>>        Property tSqlErrorArray paSqlErrorArray
77328>>>>>>>        Property Boolean pbProcessingError False
77329>>>>>>>
77329>>>>>>>        // Statistics on query
77329>>>>>>>        Property TimeSpan ptsTotalQueryTime
77330>>>>>>>        Property TimeSpan ptsQueryExec
77331>>>>>>>        Property TimeSpan ptsFetchResults
77332>>>>>>>        Property Integer piColumns 0
77333>>>>>>>        Property Integer piRows 0
77334>>>>>>>        Property Integer piRowType 0
77335>>>>>>>        Property String[] paQueryMessages
77336>>>>>>>        Property String psSQLStatementString
77337>>>>>>>
77337>>>>>>>        Property Integer[] paTableConvertExceptions
77338>>>>>>>
77338>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
77339>>>>>>>
77339>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
77339>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
77339>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
77339>>>>>>>        Property Integer piChunkMax 500
77340>>>>>>>
77340>>>>>>>        // Fill the paSQLKeywordArray array with values;
77340>>>>>>>        Send SetupSQLKeywordArray
77341>>>>>>>    End_Procedure
77342>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
77342>>>>>>>>
77342>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
77344>>>>>>>>    Integer iStart iEnd
77344>>>>>>>>    String sRetval
77344>>>>>>>>
77344>>>>>>>>    Move (Trim(sConnect)) to sConnect
77345>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
77346>>>>>>>>    If (iStart = 0) Begin
77348>>>>>>>>        Function_Return ""
77349>>>>>>>>    End
77349>>>>>>>>>
77349>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
77350>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
77351>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
77353>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77354>>>>>>>>    End
77354>>>>>>>>>
77354>>>>>>>>    Else Begin
77355>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
77356>>>>>>>>    End
77356>>>>>>>>>
77356>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
77358>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77359>>>>>>>>        Decrement iEnd
77360>>>>>>>>    End
77360>>>>>>>>>
77360>>>>>>>>    If (iEnd <> 0) Begin
77362>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
77363>>>>>>>>    End
77363>>>>>>>>>
77363>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
77364>>>>>>>>
77364>>>>>>>>    Function_Return (Trim(sRetval))
77365>>>>>>>>End_Function
77366>>>>>>>>
77366>>>>>>>>
77366>>>>>>>
77366>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
77366>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
77368>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
77370>>>>>>>            Function_Return (EQ)
77371>>>>>>>        End
77371>>>>>>>>
77371>>>>>>>        Function_Return (GT)
77372>>>>>>>    End_Function
77373>>>>>>>
77373>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
77373>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
77375>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
77378>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
77381>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
77384>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
77387>>>>>>>
77387>>>>>>>        Function_Return (EQ)
77388>>>>>>>    End_Function
77389>>>>>>>
77389>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
77391>>>>>>>        tSQLKeyWords[] SQLKeywordArray
77391>>>>>>>        tSQLKeyWords[] SQLKeywordArray
77392>>>>>>>        Integer iSize
77392>>>>>>>
77392>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
77393>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
77394>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
77395>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
77396>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
77397>>>>>>>
77397>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
77398>>>>>>>    End_Procedure
77399>>>>>>>
77399>>>>>>>    // Creates a struct array with all SQL keywords
77399>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
77399>>>>>>>    // have slightly different wording.
77399>>>>>>>    // If a new EN_dbTypexxx type is added; additions
77399>>>>>>>    // needs to be done for every keyword group below.
77399>>>>>>>    Procedure SetupSQLKeywordArray
77401>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
77401>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
77403>>>>>>>
77403>>>>>>>        // This should only be called once; but in case it is
77403>>>>>>>        // we delete the array first.
77403>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
77404>>>>>>>
77404>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
77404>>>>>>>        //
77404>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
77405>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
77406>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
77407>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
77408>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
77409>>>>>>>
77409>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
77410>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
77411>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
77412>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
77413>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
77414>>>>>>>
77414>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
77415>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
77416>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
77417>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
77418>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
77419>>>>>>>
77419>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
77420>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
77421>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
77422>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
77423>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
77424>>>>>>>
77424>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
77425>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
77426>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
77427>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
77428>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
77429>>>>>>>
77429>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
77430>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
77431>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
77432>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
77433>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
77434>>>>>>>
77434>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
77435>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
77436>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
77437>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
77438>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
77439>>>>>>>
77439>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
77440>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
77441>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
77442>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
77443>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
77444>>>>>>>
77444>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
77445>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
77446>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
77447>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
77448>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
77449>>>>>>>
77449>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
77450>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
77451>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
77452>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
77453>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
77454>>>>>>>
77454>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
77455>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
77456>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
77457>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
77458>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
77459>>>>>>>
77459>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
77460>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
77461>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
77462>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
77463>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
77464>>>>>>>
77464>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
77465>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
77466>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
77467>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
77468>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
77469>>>>>>>
77469>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
77470>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
77471>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
77472>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
77473>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
77474>>>>>>>
77474>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
77475>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
77476>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
77477>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
77478>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
77479>>>>>>>
77479>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
77480>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
77481>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
77482>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
77483>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
77484>>>>>>>
77484>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
77485>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
77486>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
77487>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
77488>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
77489>>>>>>>
77489>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
77490>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
77491>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
77492>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
77493>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
77494>>>>>>>
77494>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
77495>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
77496>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
77497>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
77498>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
77499>>>>>>>
77499>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
77500>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
77501>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
77502>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
77503>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
77504>>>>>>>
77504>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
77505>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
77506>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
77507>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
77508>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
77509>>>>>>>
77509>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
77510>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
77511>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
77512>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
77513>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
77514>>>>>>>
77514>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
77515>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
77516>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
77517>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
77518>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
77519>>>>>>>
77519>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
77520>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
77521>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
77522>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
77523>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
77524>>>>>>>
77524>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
77525>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
77526>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
77527>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
77528>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
77529>>>>>>>
77529>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
77530>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
77531>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
77532>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
77533>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
77534>>>>>>>
77534>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
77535>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
77536>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
77537>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
77538>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
77539>>>>>>>
77539>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
77540>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
77541>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
77542>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
77543>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
77544>>>>>>>
77544>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
77545>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
77546>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
77547>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
77548>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
77549>>>>>>>
77549>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
77550>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
77551>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
77552>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
77553>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
77554>>>>>>>
77554>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
77555>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
77556>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
77557>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
77558>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
77559>>>>>>>
77559>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
77560>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
77561>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
77562>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
77563>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
77564>>>>>>>
77564>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
77565>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
77566>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
77567>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
77568>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
77569>>>>>>>
77569>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
77570>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
77571>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
77572>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
77573>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
77574>>>>>>>
77574>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
77575>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
77576>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
77577>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
77578>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
77579>>>>>>>
77579>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
77580>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
77581>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
77582>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
77583>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
77584>>>>>>>
77584>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
77585>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
77586>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
77587>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
77588>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
77589>>>>>>>
77589>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
77590>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
77591>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
77592>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
77593>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
77594>>>>>>>
77594>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
77595>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
77596>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
77597>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
77598>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
77599>>>>>>>
77599>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
77600>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
77601>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
77602>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
77603>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
77604>>>>>>>
77604>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
77605>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
77606>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
77607>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
77608>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
77609>>>>>>>
77609>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
77610>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
77611>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
77612>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
77613>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
77614>>>>>>>
77614>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
77615>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
77616>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
77617>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
77618>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
77619>>>>>>>
77619>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
77620>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
77621>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
77622>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
77623>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
77624>>>>>>>
77624>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
77624>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
77625>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
77626>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
77627>>>>>>>
77627>>>>>>>    End_Procedure
77628>>>>>>>
77628>>>>>>>End_Class
77629>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
77629>>>>>>>//****************************************************************************
77629>>>>>>>// $Module type: Class
77629>>>>>>>// $Module name: cSQLConnectionHandler.pkg
77629>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
77629>>>>>>>// Web-site    : http://www.rdctools.com
77629>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
77629>>>>>>>//
77629>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
77629>>>>>>>//
77629>>>>>>>// $Rev History:
77629>>>>>>>//    2015-08-11  Module header created
77629>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
77629>>>>>>>//                Added a new structure for passing connection data back & forth.
77629>>>>>>>//                Added better error handling.
77629>>>>>>>//                Added a decompose message for the connection string.
77629>>>>>>>//    2017-01-09  Added support for Mertech drivers
77629>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
77629>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
77629>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
77629>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
77629>>>>>>>//    2023-11-06 *** REMOVED ALL SUPPORT FOR MERTECH DRIVERS ***
77629>>>>>>>//****************************************************************************
77629>>>>>>>Use cli.pkg
77629>>>>>>>Use MSSqldrv.pkg
77629>>>>>>>Use db2_drv.pkg
77629>>>>>>>Use odbc_drv.pkg
77629>>>>>>>Use cSQLConnectionIniFile.pkg
77629>>>>>>>Use cDbUpdateDatabaseDriver.pkg
77629>>>>>>>Use vWin32fh.pkg
77629>>>>>>>
77629>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
77629>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
77629>>>>>>>
77629>>>>>>>// We're making references to this object handle so we need it defined
77629>>>>>>>// here as well as for the cDbUpdateHandler class
77629>>>>>>>
77629>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
77629>>>>>>>    Move 0 to ghoSQLConnectionHandler
77630>>>>>>>
77630>>>>>>>Class cSQLConnectionHandler is a cObject
77631>>>>>>>
77631>>>>>>>    Procedure Construct_Object
77633>>>>>>>        Forward Send Construct_Object
77635>>>>>>>        Move Self to ghoSQLConnectionHandler
77636>>>>>>>
77636>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
77637>>>>>>>
77637>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
77637>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
77637>>>>>>>        // methods to this class.
77637>>>>>>>        Property Boolean pbUseConnectionID True
77638>>>>>>>        Property Boolean pbToANSI          True
77639>>>>>>>        Property Boolean pbRecnum          True
77640>>>>>>>        Property Boolean pbCopyData        True
77641>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
77642>>>>>>>        Property Boolean pbCompareDate_DateTime  False
77643>>>>>>>        Property Boolean pbCompareIndexAscending False
77644>>>>>>>        Property Boolean pbCompareIndexUppercase False
77645>>>>>>>
77645>>>>>>>        // Driver default value settings:
77645>>>>>>>        // Note: When the object is created the corresponding values
77645>>>>>>>        // from the driver .int files are read.
77645>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
77645>>>>>>>        Property String psDriverDefaultValueASCII    ""
77646>>>>>>>        Property String psDriverDefaultValueBinary   ""
77647>>>>>>>        Property String psDriverDefaultValueDate     ""
77648>>>>>>>        Property String psDriverDefaultValueDateTime ""
77649>>>>>>>        Property String psDriverDefaultValueNumeric  ""
77650>>>>>>>        Property String psDriverDefaultValueText     ""
77651>>>>>>>
77651>>>>>>>        // Driver "nullability" settings:
77651>>>>>>>        // Note: When the object is created the corresponding values
77651>>>>>>>        // from the driver .int files are read.
77651>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
77651>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
77652>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
77653>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
77654>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
77655>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
77656>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
77657>>>>>>>
77657>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
77657>>>>>>>        //     It is private because the get/set version also updates the DAW
77657>>>>>>>        //     driver interfaces.
77657>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
77657>>>>>>>        //     of the struct they are all routed throu this struct property.
77657>>>>>>>        Property tSQLConnection Private.pSQLConnection
77658>>>>>>>
77658>>>>>>>    End_Procedure
77659>>>>>>>
77659>>>>>>>    Procedure End_Construct_Object
77661>>>>>>>        tSQLConnection SQLConnection
77661>>>>>>>        tSQLConnection SQLConnection
77661>>>>>>>
77661>>>>>>>        Forward Send End_Construct_Object
77663>>>>>>>
77663>>>>>>>        // Now is the time to read and apply SQL connection settings.
77663>>>>>>>        Get SetupSQLConnection True True to SQLConnection
77664>>>>>>>        Set Private.pSQLConnection to SQLConnection
77665>>>>>>>    End_Procedure
77666>>>>>>>
77666>>>>>>>    // *** Properties ***
77666>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
77666>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
77666>>>>>>>    // merely here for conveniance.
77666>>>>>>>    //
77666>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
77666>>>>>>>    // where we update data to/from the DAW driver interfaces and this framework.
77666>>>>>>>    // This struct property contains all the connection data.
77666>>>>>>>    //
77666>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
77668>>>>>>>        Boolean bOK
77668>>>>>>>
77668>>>>>>>        Set Private.pSQLConnection to SQLConnection
77669>>>>>>>
77669>>>>>>>        // When starting a program we might not have a connection id yet:
77669>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
77671>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
77671>>>>>>>            Procedure_Return
77672>>>>>>>        End
77672>>>>>>>>
77672>>>>>>>
77672>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
77672>>>>>>>        // be logged in already and don't want to do it again.
77672>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
77674>>>>>>>            // After we have set the class property we need to tell the DAW
77674>>>>>>>            // driver interfaces about the change & make a new login.
77674>>>>>>>            Get SQLLogin SQLConnection to bOK
77675>>>>>>>            If (bOK = False) Begin
77677>>>>>>>                Error DFERR_PROGRAM "Login error."
77678>>>>>>>>
77678>>>>>>>            End
77678>>>>>>>>
77678>>>>>>>        End
77678>>>>>>>>
77678>>>>>>>
77678>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
77678>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
77679>>>>>>>
77679>>>>>>>    End_Procedure
77680>>>>>>>
77680>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
77680>>>>>>>    // attempt to load the driver.
77680>>>>>>>    // Returns true if the passed driver is SQL based.
77680>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
77682>>>>>>>        Boolean bOK
77682>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
77683>>>>>>>        Function_Return bOK
77684>>>>>>>    End_Function
77685>>>>>>>
77685>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
77685>>>>>>>    Procedure SetupDriverDefaults String sDriverID
77687>>>>>>>        String sAttributeValue
77687>>>>>>>        Integer iDriverID
77687>>>>>>>        Boolean bNULL bSQLDriver
77687>>>>>>>
77687>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
77688>>>>>>>        If (bSQLDriver = False) Begin
77690>>>>>>>            Procedure_Return
77691>>>>>>>        End                                      
77691>>>>>>>>
77691>>>>>>>        
77691>>>>>>>        Get DriverIndex sDriverID to iDriverID
77692>>>>>>>
77692>>>>>>>        // Driver default values for various data types:
77692>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
77695>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
77696>>>>>>>
77696>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
77699>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
77700>>>>>>>
77700>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
77703>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
77704>>>>>>>
77704>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
77707>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
77708>>>>>>>
77708>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
77711>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
77712>>>>>>>
77712>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
77715>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
77716>>>>>>>
77716>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
77716>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
77719>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
77720>>>>>>>
77720>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
77723>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
77724>>>>>>>
77724>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
77727>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
77728>>>>>>>
77728>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
77731>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
77732>>>>>>>
77732>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
77735>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
77736>>>>>>>
77736>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
77739>>>>>>>        Set pbDriverDefaultNullableText to bNULL
77740>>>>>>>
77740>>>>>>>    End_Procedure
77741>>>>>>>
77741>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
77743>>>>>>>        Boolean bOK bIsDaw
77743>>>>>>>        String sConnectionString
77743>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
77743>>>>>>>        Integer iDriverID
77743>>>>>>>
77743>>>>>>>        Move False to bOK
77744>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
77745>>>>>>>
77745>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
77746>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
77747>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
77748>>>>>>>        If (iDriverID = 0) Begin
77750>>>>>>>            Move hoErrorObj to Error_Object_Id
77751>>>>>>>            Function_Return False
77752>>>>>>>        End
77752>>>>>>>>
77752>>>>>>>
77752>>>>>>>        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
77755>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
77756>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
77757>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
77758>>>>>>>        Send Destroy   of hoDriver
77759>>>>>>>
77759>>>>>>>        Function_Return bOK
77760>>>>>>>    End_Function
77761>>>>>>>
77761>>>>>>>    Function pSQLConnection Returns tSQLConnection
77763>>>>>>>        tSQLConnection SQLConnection
77763>>>>>>>        tSQLConnection SQLConnection
77763>>>>>>>        Get Private.pSQLConnection to SQLConnection
77764>>>>>>>        Function_Return SQLConnection
77765>>>>>>>    End_Function
77766>>>>>>>
77766>>>>>>>    Procedure Set psConnectionID String sValue
77768>>>>>>>        tSQLConnection SQLConnection
77768>>>>>>>        tSQLConnection SQLConnection
77768>>>>>>>
77768>>>>>>>        Get Private.pSQLConnection to SQLConnection
77769>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
77771>>>>>>>            Move sValue to SQLConnection.sConnectionID
77772>>>>>>>        End
77772>>>>>>>>
77772>>>>>>>
77772>>>>>>>        // Else we might want to change the current connection ID
77772>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
77775>>>>>>>            Move False to Err
77776>>>>>>>            Logout SQLConnection.sDriverID
77777>>>>>>>            // This will also make a login to the new server.
77777>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
77778>>>>>>>        End
77778>>>>>>>>
77778>>>>>>>        Set pSQLConnection to SQLConnection
77779>>>>>>>    End_Procedure
77780>>>>>>>
77780>>>>>>>    Function psConnectionID Returns String
77782>>>>>>>        tSQLConnection SQLConnection
77782>>>>>>>        tSQLConnection SQLConnection
77782>>>>>>>        Get Private.pSQLConnection to SQLConnection
77783>>>>>>>        Function_Return SQLConnection.sConnectionID
77784>>>>>>>    End_Function
77785>>>>>>>
77785>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
77785>>>>>>>    //       the psDriverID *must* be the first property that is changed!
77785>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
77785>>>>>>>    //       for a connection string has the wrong format for that driver.
77785>>>>>>>    Procedure Set psDriverID String sValue
77787>>>>>>>        tSQLConnection SQLConnection
77787>>>>>>>        tSQLConnection SQLConnection
77787>>>>>>>        Get pSQLConnection to SQLConnection
77788>>>>>>>        Move sValue        to SQLConnection.sDriverID
77789>>>>>>>        Set pSQLConnection to SQLConnection
77790>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
77792>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77793>>>>>>>        End
77793>>>>>>>>
77793>>>>>>>    End_Procedure
77794>>>>>>>
77794>>>>>>>    Function psDriverID Returns String
77796>>>>>>>        tSQLConnection SQLConnection
77796>>>>>>>        tSQLConnection SQLConnection
77796>>>>>>>        Get Private.pSQLConnection to SQLConnection
77797>>>>>>>        If (SQLConnection.sDriverID = "") Begin
77799>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
77800>>>>>>>        End
77800>>>>>>>>
77800>>>>>>>        Function_Return SQLConnection.sDriverID
77801>>>>>>>    End_Function
77802>>>>>>>
77802>>>>>>>    Procedure Set psConnectionString String sValue
77804>>>>>>>        tSQLConnection SQLConnection
77804>>>>>>>        tSQLConnection SQLConnection
77804>>>>>>>        Get Private.pSQLConnection to SQLConnection
77805>>>>>>>        Move sValue        to SQLConnection.sConnectionString
77806>>>>>>>        Set pSQLConnection to SQLConnection
77807>>>>>>>    End_Procedure
77808>>>>>>>
77808>>>>>>>    Function psConnectionString Returns String
77810>>>>>>>        tSQLConnection SQLConnection
77810>>>>>>>        tSQLConnection SQLConnection
77810>>>>>>>        Get Private.pSQLConnection to SQLConnection
77811>>>>>>>        Function_Return SQLConnection.sConnectionString
77812>>>>>>>    End_Function
77813>>>>>>>
77813>>>>>>>    Procedure Set psServer String sValue
77815>>>>>>>        tSQLConnection SQLConnection
77815>>>>>>>        tSQLConnection SQLConnection
77815>>>>>>>        Get Private.pSQLConnection to SQLConnection
77816>>>>>>>        Move sValue        to SQLConnection.sServer
77817>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77818>>>>>>>        Set pSQLConnection to SQLConnection
77819>>>>>>>    End_Procedure
77820>>>>>>>
77820>>>>>>>    Function psServer Returns String
77822>>>>>>>        tSQLConnection SQLConnection
77822>>>>>>>        tSQLConnection SQLConnection
77822>>>>>>>        Get Private.pSQLConnection to SQLConnection
77823>>>>>>>        Function_Return SQLConnection.sServer
77824>>>>>>>    End_Function
77825>>>>>>>
77825>>>>>>>    Procedure Set psDatabase String sValue
77827>>>>>>>        tSQLConnection SQLConnection
77827>>>>>>>        tSQLConnection SQLConnection
77827>>>>>>>        Get Private.pSQLConnection to SQLConnection
77828>>>>>>>        Move sValue        to SQLConnection.sDatabase
77829>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77830>>>>>>>        Set pSQLConnection to SQLConnection
77831>>>>>>>    End_Procedure
77832>>>>>>>
77832>>>>>>>    Function psDatabase Returns String
77834>>>>>>>        tSQLConnection SQLConnection
77834>>>>>>>        tSQLConnection SQLConnection
77834>>>>>>>        Get Private.pSQLConnection to SQLConnection
77835>>>>>>>        Function_Return SQLConnection.sDatabase
77836>>>>>>>    End_Function
77837>>>>>>>
77837>>>>>>>    Procedure Set psUserID String sValue
77839>>>>>>>        tSQLConnection SQLConnection
77839>>>>>>>        tSQLConnection SQLConnection
77839>>>>>>>        Get Private.pSQLConnection to SQLConnection
77840>>>>>>>        Move sValue        to SQLConnection.sUserID
77841>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77842>>>>>>>        Set pSQLConnection to SQLConnection
77843>>>>>>>    End_Procedure
77844>>>>>>>
77844>>>>>>>    Function psUserID Returns String
77846>>>>>>>        tSQLConnection SQLConnection
77846>>>>>>>        tSQLConnection SQLConnection
77846>>>>>>>        Get Private.pSQLConnection to SQLConnection
77847>>>>>>>        Function_Return SQLConnection.sUserID
77848>>>>>>>    End_Function
77849>>>>>>>
77849>>>>>>>    // This is the uncrypted password
77849>>>>>>>    Procedure Set psPassword String sValue
77851>>>>>>>        tSQLConnection SQLConnection
77851>>>>>>>        tSQLConnection SQLConnection
77851>>>>>>>        Get Private.pSQLConnection to SQLConnection
77852>>>>>>>        Move sValue        to SQLConnection.sPassword
77853>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77854>>>>>>>        Set pSQLConnection to SQLConnection
77855>>>>>>>    End_Procedure
77856>>>>>>>
77856>>>>>>>    Function psPassword Returns String
77858>>>>>>>        tSQLConnection SQLConnection
77858>>>>>>>        tSQLConnection SQLConnection
77858>>>>>>>        Get Private.pSQLConnection to SQLConnection
77859>>>>>>>        Function_Return SQLConnection.sPassword
77860>>>>>>>    End_Function
77861>>>>>>>
77861>>>>>>>    Procedure Set pbTrusted Boolean bValue
77863>>>>>>>        tSQLConnection SQLConnection
77863>>>>>>>        tSQLConnection SQLConnection
77863>>>>>>>        Get Private.pSQLConnection to SQLConnection
77864>>>>>>>        Move bValue        to SQLConnection.bTrusted
77865>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77866>>>>>>>        Set pSQLConnection to SQLConnection
77867>>>>>>>    End_Procedure
77868>>>>>>>
77868>>>>>>>    Function pbTrusted Returns Boolean
77870>>>>>>>        tSQLConnection SQLConnection
77870>>>>>>>        tSQLConnection SQLConnection
77870>>>>>>>        Get Private.pSQLConnection to SQLConnection
77871>>>>>>>        Function_Return SQLConnection.bTrusted
77872>>>>>>>    End_Function
77873>>>>>>>
77873>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
77873>>>>>>>    //     Thus they are not propagated to the DAW classes and that is why
77873>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
77873>>>>>>>    //     the central pSQLConnection "hub".
77873>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
77875>>>>>>>        tSQLConnection SQLConnection
77875>>>>>>>        tSQLConnection SQLConnection
77875>>>>>>>        Get Private.pSQLConnection to SQLConnection
77876>>>>>>>        Move bValue to SQLConnection.bTrusted
77877>>>>>>>        Set Private.pSQLConnection to SQLConnection
77878>>>>>>>    End_Procedure
77879>>>>>>>
77879>>>>>>>    Function pbSilentLogin Returns Boolean
77881>>>>>>>        tSQLConnection SQLConnection
77881>>>>>>>        tSQLConnection SQLConnection
77881>>>>>>>        Get Private.pSQLConnection to SQLConnection
77882>>>>>>>        Function_Return SQLConnection.bSilentLogin
77883>>>>>>>    End_Function
77884>>>>>>>
77884>>>>>>>    Procedure Set piDbType Integer iValue
77886>>>>>>>        tSQLConnection SQLConnection
77886>>>>>>>        tSQLConnection SQLConnection
77886>>>>>>>        Get Private.pSQLConnection to SQLConnection
77887>>>>>>>        Move iValue to SQLConnection.iDbType
77888>>>>>>>        Set Private.pSQLConnection to SQLConnection
77889>>>>>>>    End_Procedure
77890>>>>>>>
77890>>>>>>>    Function piDbType Returns Integer
77892>>>>>>>        tSQLConnection SQLConnection
77892>>>>>>>        tSQLConnection SQLConnection
77892>>>>>>>        Get Private.pSQLConnection to SQLConnection
77893>>>>>>>        Function_Return SQLConnection.iDbType
77894>>>>>>>    End_Function
77895>>>>>>>
77895>>>>>>>    Procedure Set psBaseTableSpace String sValue
77897>>>>>>>        tSQLConnection SQLConnection
77897>>>>>>>        tSQLConnection SQLConnection
77897>>>>>>>        Get Private.pSQLConnection to SQLConnection
77898>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
77899>>>>>>>        Set Private.pSQLConnection to SQLConnection
77900>>>>>>>    End_Procedure
77901>>>>>>>
77901>>>>>>>    Function psBaseTableSpace Returns String
77903>>>>>>>        tSQLConnection SQLConnection
77903>>>>>>>        tSQLConnection SQLConnection
77903>>>>>>>        Get Private.pSQLConnection to SQLConnection
77904>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
77905>>>>>>>    End_Function
77906>>>>>>>
77906>>>>>>>    Procedure Set psIndexTableSpace String sValue
77908>>>>>>>        tSQLConnection SQLConnection
77908>>>>>>>        tSQLConnection SQLConnection
77908>>>>>>>        Get Private.pSQLConnection to SQLConnection
77909>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
77910>>>>>>>        Set Private.pSQLConnection to SQLConnection
77911>>>>>>>    End_Procedure
77912>>>>>>>
77912>>>>>>>    Function psIndexTableSpace Returns String
77914>>>>>>>        tSQLConnection SQLConnection
77914>>>>>>>        tSQLConnection SQLConnection
77914>>>>>>>        Get Private.pSQLConnection to SQLConnection
77915>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
77916>>>>>>>    End_Function
77917>>>>>>>
77917>>>>>>>    Procedure Set psLongTableSpace String sValue
77919>>>>>>>        tSQLConnection SQLConnection
77919>>>>>>>        tSQLConnection SQLConnection
77919>>>>>>>        Get Private.pSQLConnection to SQLConnection
77920>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
77921>>>>>>>        Set Private.pSQLConnection to SQLConnection
77922>>>>>>>    End_Procedure
77923>>>>>>>
77923>>>>>>>    Function psLongTableSpace Returns String
77925>>>>>>>        tSQLConnection SQLConnection
77925>>>>>>>        tSQLConnection SQLConnection
77925>>>>>>>        Get Private.pSQLConnection to SQLConnection
77926>>>>>>>        Function_Return SQLConnection.sLongTableSpace
77927>>>>>>>    End_Function
77928>>>>>>>
77928>>>>>>>    Procedure Set psSchema String sValue
77930>>>>>>>        tSQLConnection SQLConnection
77930>>>>>>>        tSQLConnection SQLConnection
77930>>>>>>>        Get Private.pSQLConnection to SQLConnection
77931>>>>>>>        Move sValue to SQLConnection.sSchema
77932>>>>>>>        Set Private.pSQLConnection to SQLConnection
77933>>>>>>>    End_Procedure
77934>>>>>>>
77934>>>>>>>    Function psSchema Returns String
77936>>>>>>>        tSQLConnection SQLConnection
77936>>>>>>>        tSQLConnection SQLConnection
77936>>>>>>>        Get Private.pSQLConnection to SQLConnection
77937>>>>>>>        Function_Return SQLConnection.sSchema
77938>>>>>>>    End_Function
77939>>>>>>>
77939>>>>>>>    Procedure Set pbEnabled Boolean bValue
77941>>>>>>>        tSQLConnection SQLConnection
77941>>>>>>>        tSQLConnection SQLConnection
77941>>>>>>>        Get Private.pSQLConnection to SQLConnection
77942>>>>>>>        Move bValue to SQLConnection.bEnabled
77943>>>>>>>        Set Private.pSQLConnection to SQLConnection
77944>>>>>>>    End_Procedure
77945>>>>>>>
77945>>>>>>>    Function pbEnabled Returns Boolean
77947>>>>>>>        tSQLConnection SQLConnection
77947>>>>>>>        tSQLConnection SQLConnection
77947>>>>>>>        Get Private.pSQLConnection to SQLConnection
77948>>>>>>>        Function_Return SQLConnection.bEnabled
77949>>>>>>>    End_Function
77950>>>>>>>
77950>>>>>>>
77950>>>>>>>    // ************************************
77950>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
77952>>>>>>>        tSQLConnection SQLConnection
77952>>>>>>>        tSQLConnection SQLConnection
77952>>>>>>>
77952>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
77952>>>>>>>        // deferr reading SQL connection values until later.
77952>>>>>>>        If (bReadDFConnSettings = True) Begin
77954>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
77954>>>>>>>            If (ghoConnection > 0) Begin
77956>>>>>>>                Get ReadcConnections to SQLConnection
77957>>>>>>>            End
77957>>>>>>>>
77957>>>>>>>
77957>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
77957>>>>>>>            // object is used.
77957>>>>>>>            If (bReadSQLConnections = True) Begin
77959>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
77960>>>>>>>            End
77960>>>>>>>>
77960>>>>>>>        End
77960>>>>>>>>
77960>>>>>>>
77960>>>>>>>        Function_Return SQLConnection
77961>>>>>>>    End_Function
77962>>>>>>>
77962>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
77962>>>>>>>    Function ReadcConnections Returns tSQLConnection
77964>>>>>>>        tConnection Connection
77964>>>>>>>        tConnection Connection
77964>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
77964>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
77964>>>>>>>        Integer iRetval iDbType
77964>>>>>>>        Boolean bOK bConnected
77964>>>>>>>        String sConnectionID
77964>>>>>>>
77964>>>>>>>            tConnection[] Connections
77964>>>>>>>            tConnection[] Connections
77965>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
77965>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
77965>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
77965>>>>>>>            //   we then generate an error and abort the program...
77965>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
77966>>>>>>>            If (bOK = False) Begin
77968>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
77969>>>>>>>>
77969>>>>>>>                Abort
77970>>>>>>>>
77970>>>>>>>            End
77970>>>>>>>>
77970>>>>>>>            If (sConnectionID = "") Begin
77972>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
77973>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
77975>>>>>>>                    Move Connections[0].sId to sConnectionID
77976>>>>>>>                End
77976>>>>>>>>
77976>>>>>>>            End
77976>>>>>>>>
77976>>>>>>>
77976>>>>>>>            Move 0 to iRetval
77977>>>>>>>            // DAW DF19 connection info:
77977>>>>>>>            // We first check that the connection is OK:
77977>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
77978>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
77978>>>>>>>            If (iRetval = -1) Begin
77980>>>>>>>                Function_Return SQLConnectionEmpty
77981>>>>>>>            End
77981>>>>>>>>
77981>>>>>>>
77981>>>>>>>            If (sConnectionID <> "") Begin
77983>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
77984>>>>>>>            End
77984>>>>>>>>
77984>>>>>>>            If (Connection.sId = "") Begin
77986>>>>>>>                Move True to SQLConnectionEmpty.bError
77987>>>>>>>                Function_Return SQLConnectionEmpty
77988>>>>>>>            End
77988>>>>>>>>
77988>>>>>>>
77988>>>>>>>            // DUF connection info struct property:
77988>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
77989>>>>>>>
77989>>>>>>>            Move Connection.sId to sConnectionID
77990>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
77991>>>>>>>
77991>>>>>>>            If (bConnected = False) Begin
77993>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
77994>>>>>>>                If (iRetval <> 0) Begin
77996>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
77997>>>>>>>                    Send Exit_Application
77998>>>>>>>                End
77998>>>>>>>>
77998>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
77999>>>>>>>                // We need to get the DAW connection info again as it might have
77999>>>>>>>                // been changed in the DAW db login dialog.
77999>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78000>>>>>>>            End
78000>>>>>>>>
78000>>>>>>>
78000>>>>>>>            Move True                                        to SQLConnection.bEnabled
78001>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
78002>>>>>>>
78002>>>>>>>            // Not used in DUF:
78002>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
78002>>>>>>>
78002>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
78003>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
78004>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
78005>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
78006>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
78007>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
78008>>>>>>>
78008>>>>>>>            // Not used in DUF:
78008>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
78008>>>>>>>
78008>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
78008>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
78008>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
78010>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
78011>>>>>>>            End
78011>>>>>>>>
78011>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
78013>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
78014>>>>>>>                If (SQLConnection.sServer = "") Begin
78016>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78017>>>>>>>                End
78017>>>>>>>>
78017>>>>>>>            End
78017>>>>>>>>
78017>>>>>>>
78017>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
78018>>>>>>>
78018>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
78018>>>>>>>            // the value from the driver id:
78018>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
78019>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
78019>>>>>>>            Get piDbType                                     to iDbType
78020>>>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
78022>>>>>>>                Move iDbType to SQLConnection.iDbType
78023>>>>>>>            End
78023>>>>>>>>
78023>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
78024>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
78025>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
78026>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
78027>>>>>>>
78027>>>>>>>            // We finally set the struct property to the newly fetched values.
78027>>>>>>>            Set pSQLConnection to SQLConnection
78028>>>>>>>
78028>>>>>>>        Function_Return SQLConnection
78029>>>>>>>    End_Function
78030>>>>>>>
78030>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
78030>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
78030>>>>>>>    // connection id for a particular driver.
78030>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
78030>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
78030>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
78030>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
78030>>>>>>>    // connections of the DAW cConnect class.
78030>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
78032>>>>>>>        tConnection[] ConnIdArray
78032>>>>>>>        tConnection[] ConnIdArray
78033>>>>>>>        Integer iCount iSize iConnectionIDCounter
78033>>>>>>>        Boolean bEnabled bFound
78033>>>>>>>        String sConnectionID2 sDriverID sDriverConn
78033>>>>>>>
78033>>>>>>>        Move False to bFound
78034>>>>>>>        If (ghoConnection > 0) Begin
78036>>>>>>>
78036>>>>>>>            // The property of the cDbUpdateHandler container object
78036>>>>>>>            Get psDriverID to sDriverID
78037>>>>>>>
78037>>>>>>>            Move 0 to iConnectionIDCounter
78038>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
78038>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
78039>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
78040>>>>>>>            Decrement iSize
78041>>>>>>>            For iCount from 0 to iSize
78047>>>>>>>>
78047>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
78048>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
78049>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
78050>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
78050>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
78050>>>>>>>                If (sConnectionID = "") Begin
78052>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
78053>>>>>>>                End
78053>>>>>>>>
78053>>>>>>>                Else Begin
78054>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
78056>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
78057>>>>>>>                    End
78057>>>>>>>>
78057>>>>>>>                End
78057>>>>>>>>
78057>>>>>>>
78057>>>>>>>                If (bFound = True) Begin
78059>>>>>>>                    Increment iConnectionIDCounter
78060>>>>>>>                End
78060>>>>>>>>
78060>>>>>>>            Loop
78061>>>>>>>>
78061>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
78062>>>>>>>            If (bFound = True) Begin
78064>>>>>>>                Move sConnectionID2 to sConnectionID
78065>>>>>>>            End
78065>>>>>>>>
78065>>>>>>>        End
78065>>>>>>>>
78065>>>>>>>
78065>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
78065>>>>>>>        // but no DFConn.ini record has been created.
78065>>>>>>>        If (iSize = -1) Begin
78067>>>>>>>            Move True to bFound
78068>>>>>>>        End
78068>>>>>>>>
78068>>>>>>>
78068>>>>>>>        Function_Return bFound
78069>>>>>>>    End_Function
78070>>>>>>>
78070>>>>>>>    // Send on object creation to read the default connection string settings, and
78070>>>>>>>    // create a connection to the server.
78070>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
78072>>>>>>>        String sPath sFileName
78072>>>>>>>        Boolean bExists bActive
78072>>>>>>>        tSQLConnection[] SQLConnectionArray
78072>>>>>>>        tSQLConnection[] SQLConnectionArray
78073>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78073>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78073>>>>>>>        Handle hoIniFile
78073>>>>>>>        Integer iSize iCount iRetval
78073>>>>>>>
78073>>>>>>>        Get psIniFilePath to sPath
78074>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78075>>>>>>>        If (sPath = "") Begin
78077>>>>>>>            Get ApplicationPath of hoIniFile to sPath
78078>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
78079>>>>>>>        End
78079>>>>>>>>
78079>>>>>>>        Get vFolderFormat sPath to sPath
78080>>>>>>>        Get psIniFileName to sFileName
78081>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
78082>>>>>>>
78082>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
78083>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
78084>>>>>>>        If (iSize = 0) Begin
78086>>>>>>>            // This may have been set by the "ReadcConnections" function,
78086>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
78086>>>>>>>            // in the cApplication object.
78086>>>>>>>            Get pSQLConnection to SQLConnection
78087>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
78089>>>>>>>                Function_Return SQLConnectionEmpty
78090>>>>>>>            End
78090>>>>>>>>
78090>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
78091>>>>>>>            Move 1 to iSize
78092>>>>>>>        End
78092>>>>>>>>
78092>>>>>>>
78092>>>>>>>        Move False to bActive
78093>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
78093>>>>>>>        Decrement iSize
78094>>>>>>>        For iCount from 0 to iSize
78100>>>>>>>>
78100>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
78101>>>>>>>            If (SQLConnection.bEnabled = True) Begin
78103>>>>>>>                Move True to bActive
78104>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
78105>>>>>>>            End
78105>>>>>>>>
78105>>>>>>>        Loop
78106>>>>>>>>
78106>>>>>>>
78106>>>>>>>        // In case all connections have been disabled, we're out of here.
78106>>>>>>>        If (bActive = False) Begin
78108>>>>>>>            Function_Return SQLConnectionEmpty
78109>>>>>>>        End
78109>>>>>>>>
78109>>>>>>>
78109>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
78110>>>>>>>
78110>>>>>>>        Set pSQLConnection to SQLConnection
78111>>>>>>>        Get AutoSetConnectionID to iRetval
78112>>>>>>>
78112>>>>>>>        Function_Return SQLConnection
78113>>>>>>>    End_Function
78114>>>>>>>
78114>>>>>>>    Procedure Set psIniFilePath String sPath
78116>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
78117>>>>>>>    End_Procedure
78118>>>>>>>
78118>>>>>>>    Function psIniFilePath Returns String
78120>>>>>>>        String sRetval
78120>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
78121>>>>>>>        Function_Return sRetval
78122>>>>>>>    End_Function
78123>>>>>>>
78123>>>>>>>    Procedure Set psIniFileName String sFileName
78125>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
78126>>>>>>>    End_Procedure
78127>>>>>>>
78127>>>>>>>    Function psIniFileName Returns String
78129>>>>>>>        String sRetval
78129>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
78130>>>>>>>        Function_Return sRetval
78131>>>>>>>    End_Function
78132>>>>>>>
78132>>>>>>>    Procedure Set psIniSectionName String sSection
78134>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
78135>>>>>>>    End_Procedure
78136>>>>>>>
78136>>>>>>>    Function psIniSectionName Returns String
78138>>>>>>>        String sRetval
78138>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
78139>>>>>>>        Function_Return sRetval
78140>>>>>>>    End_Function
78141>>>>>>>
78141>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
78143>>>>>>>        Handle ho
78143>>>>>>>        Get phoSQLConnectionIniFile to ho
78144>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
78145>>>>>>>    End_Procedure
78146>>>>>>>
78146>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
78148>>>>>>>        Handle ho
78148>>>>>>>        String sRetval
78148>>>>>>>        Get phoSQLConnectionIniFile to ho
78149>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
78150>>>>>>>        Function_Return sRetval
78151>>>>>>>    End_Function
78152>>>>>>>
78152>>>>>>>    Function SectionExists String sSection Returns Boolean
78154>>>>>>>        Handle ho
78154>>>>>>>        Boolean bRetval
78154>>>>>>>        Get phoSQLConnectionIniFile to ho
78155>>>>>>>        Get SectionExists of ho sSection to bRetval
78156>>>>>>>        Function_Return bRetval
78157>>>>>>>    End_Function
78158>>>>>>>
78158>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
78160>>>>>>>        Handle ho
78160>>>>>>>        Boolean bRetval
78160>>>>>>>        Get phoSQLConnectionIniFile to ho
78161>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
78162>>>>>>>        Function_Return bRetval
78163>>>>>>>    End_Function
78164>>>>>>>
78164>>>>>>>    Function EncryptPassword String sPassword Returns String
78166>>>>>>>        Handle ho
78166>>>>>>>        String sRetval
78166>>>>>>>        Get phoSQLConnectionIniFile to ho
78167>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
78168>>>>>>>        Function_Return sRetval
78169>>>>>>>    End_Function
78170>>>>>>>
78170>>>>>>>    Function DecryptPassword String sPassword Returns String
78172>>>>>>>        Handle ho
78172>>>>>>>        String sRetval
78172>>>>>>>        Get phoSQLConnectionIniFile to ho
78173>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
78174>>>>>>>        Function_Return sRetval
78175>>>>>>>    End_Function
78176>>>>>>>
78176>>>>>>>    // *** Main Connection Message ***
78176>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
78178>>>>>>>        Handle hoDriver
78178>>>>>>>        String sConnectionString sError
78178>>>>>>>        Boolean bLoginSuccessful
78178>>>>>>>
78178>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
78179>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78180>>>>>>>        Set psDriverID of hoDriver to sDriverID
78181>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
78182>>>>>>>        If (bLoginSuccessful = False) Begin
78184>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
78185>>>>>>>>
78185>>>>>>>            If (bExitProgram = True) Begin
78187>>>>>>>                Send Exit_Application
78188>>>>>>>            End
78188>>>>>>>>
78188>>>>>>>        End
78188>>>>>>>>
78188>>>>>>>        Send Destroy of hoDriver
78189>>>>>>>    End_Procedure
78190>>>>>>>
78190>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
78192>>>>>>>        Integer iRetval
78192>>>>>>>        Handle hoCLI
78192>>>>>>>        String sDriverID
78192>>>>>>>
78192>>>>>>>        Get psDriverID to sDriverID
78193>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
78194>>>>>>>        If (hoCLI <> 0) Begin
78196>>>>>>>            Set psDriverID of hoCLI to sDriverID
78197>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
78198>>>>>>>            Send Destroy of hoCLI
78199>>>>>>>        End
78199>>>>>>>>
78199>>>>>>>
78199>>>>>>>        Function_Return iRetval
78200>>>>>>>    End_Function
78201>>>>>>>
78201>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
78203>>>>>>>        tSQLConnection SQLConnection
78203>>>>>>>        tSQLConnection SQLConnection
78203>>>>>>>
78203>>>>>>>        Set psDriverID to sDriverID
78204>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
78205>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
78206>>>>>>>    End_Procedure
78207>>>>>>>
78207>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
78207>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
78207>>>>>>>    // or the one in the DataFlex Bin folder.)
78207>>>>>>>    // We then need to delete the current one before creating a new one.
78207>>>>>>>    // This is because the parameters may differ between the program code and the
78207>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
78207>>>>>>>    // when one tries to create a Connection ID that already exists.
78207>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
78209>>>>>>>        Integer iResult iDriver iNumConn iConn
78209>>>>>>>        Handle hoCLI
78209>>>>>>>        String sID
78209>>>>>>>
78209>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
78211>>>>>>>            Procedure_Return
78212>>>>>>>        End
78212>>>>>>>>
78212>>>>>>>
78212>>>>>>>        Move 0 to iResult
78213>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78214>>>>>>>        If (hoCLI <> 0) Begin
78216>>>>>>>            Set psDriverID of hoCLI to sDriverID
78217>>>>>>>            Get DriverIndex sDriverID to iDriver
78218>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78221>>>>>>>            Decrement iNumConn
78222>>>>>>>            For iConn from 0 to iNumConn
78228>>>>>>>>
78228>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78231>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78233>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
78234>>>>>>>                End
78234>>>>>>>>
78234>>>>>>>            Loop
78235>>>>>>>>
78235>>>>>>>            Send Destroy of hoCLI
78236>>>>>>>        End
78236>>>>>>>>
78236>>>>>>>
78236>>>>>>>    End_Procedure
78237>>>>>>>
78237>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
78239>>>>>>>        Integer iResult iDriver iNumConn iConn
78239>>>>>>>        Handle hoCLI
78239>>>>>>>        String sID sConnectionString sVal sDatabase
78239>>>>>>>        tSQLConnection SQLConnection
78239>>>>>>>        tSQLConnection SQLConnection
78239>>>>>>>        Boolean bTrusted
78239>>>>>>>
78239>>>>>>>        Move 0 to iResult
78240>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78241>>>>>>>        If (hoCLI <> 0) Begin
78243>>>>>>>            Set psDriverID of hoCLI to sDriverID
78244>>>>>>>            Get DriverIndex sDriverID to iDriver
78245>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78248>>>>>>>            Decrement iNumConn
78249>>>>>>>            For iConn from 0 to iNumConn
78255>>>>>>>>
78255>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78258>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78260>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
78261>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
78264>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
78267>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
78268>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
78271>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
78272>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
78273>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
78274>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
78275>>>>>>>
78275>>>>>>>                    Case Begin
78275>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
78277>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
78278>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
78279>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
78280>>>>>>>                            Case Break
78281>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
78284>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78285>>>>>>>                            Case Break
78286>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
78289>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78290>>>>>>>                            If (SQLConnection.sServer = "") Begin
78292>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78293>>>>>>>                            End
78293>>>>>>>>
78293>>>>>>>                            Case Break
78294>>>>>>>                        Case Else
78294>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
78295>>>>>>>>
78295>>>>>>>                            Case Break
78296>>>>>>>                    Case End
78296>>>>>>>                End
78296>>>>>>>>
78296>>>>>>>            Loop
78297>>>>>>>>
78297>>>>>>>            Send Destroy of hoCLI
78298>>>>>>>        End
78298>>>>>>>>
78298>>>>>>>
78298>>>>>>>        Function_Return SQLConnection
78299>>>>>>>    End_Function
78300>>>>>>>
78300>>>>>>>    Function DriverIndex String sDriverID Returns Integer
78302>>>>>>>        String  sCurrentDriver
78302>>>>>>>        Integer iNumberOfDrivers iDriver iCount
78302>>>>>>>
78302>>>>>>>        Move 0 to iDriver
78303>>>>>>>        Move 0 to iCount
78304>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78307>>>>>>>        For iCount from 1 to iNumberOfDrivers
78313>>>>>>>>
78313>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
78316>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
78318>>>>>>>                Function_Return iCount
78319>>>>>>>            End
78319>>>>>>>>
78319>>>>>>>        Loop
78320>>>>>>>>
78320>>>>>>>
78320>>>>>>>        // If driver not previously loaded; attempt to do so now.
78320>>>>>>>        If (iDriver = 0) Begin
78322>>>>>>>            Move 0 to LastErr
78323>>>>>>>            Load_Driver sDriverID
78324>>>>>>>            // If driver could not be loaded.
78324>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
78326>>>>>>>                Move -1 to iCount
78327>>>>>>>            End
78327>>>>>>>>
78327>>>>>>>        End
78327>>>>>>>>
78327>>>>>>>        Function_Return iCount
78328>>>>>>>    End_Function
78329>>>>>>>
78329>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
78329>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
78331>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
78331>>>>>>>        Boolean bTrusted bSilent
78331>>>>>>>        Integer iRetval
78331>>>>>>>
78331>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
78332>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
78333>>>>>>>        Move SQLConnection.sServer       to sServer
78334>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
78335>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
78336>>>>>>>        Move SQLConnection.sUserID       to sUserID
78337>>>>>>>        Move SQLConnection.sPassword     to sPassword
78338>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
78339>>>>>>>
78339>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
78340>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
78340>>>>>>>        Get AutoSetConnectionID to iRetval
78341>>>>>>>    End_Procedure
78342>>>>>>>
78342>>>>>>>    // Called when the object is constructed.
78342>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
78342>>>>>>>    // as psConnectionID property. It is later used whenever a login to
78342>>>>>>>    // the database is needed.
78342>>>>>>>    Function AutoSetConnectionID Returns Boolean
78344>>>>>>>        String sConnectionID sDriverID sConnectionString
78344>>>>>>>        Integer iDriver iRetval
78344>>>>>>>        Handle hoCLI
78344>>>>>>>        Boolean bOK bSilent
78344>>>>>>>
78344>>>>>>>        Get pbSilentLogin      to bSilent
78345>>>>>>>        Get psConnectionID     to sConnectionID
78346>>>>>>>        Get psConnectionString to sConnectionString
78347>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
78347>>>>>>>        Get psDriverID to sDriverID
78348>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78349>>>>>>>        If (bOK = False) Begin
78351>>>>>>>            Function_Return False
78352>>>>>>>        End
78352>>>>>>>>
78352>>>>>>>
78352>>>>>>>        Get DriverIndex sDriverID          to iDriver
78353>>>>>>>        // If driver not loaded; load it.
78353>>>>>>>        If (iDriver = 0) Begin
78355>>>>>>>            Load_Driver sDriverID
78356>>>>>>>            Get DriverIndex sDriverID      to iDriver
78357>>>>>>>        End
78357>>>>>>>>
78357>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
78357>>>>>>>        If (iDriver = 0) Begin
78359>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
78360>>>>>>>>
78360>>>>>>>            Function_Return False
78361>>>>>>>        End           
78361>>>>>>>>
78361>>>>>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
78364>>>>>>>        
78364>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78365>>>>>>>        Set psDriverID of hoCLI            to sDriverID
78366>>>>>>>        // Delete the connection first; in case it exists
78366>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
78367>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
78368>>>>>>>        Send Destroy of hoCLI
78369>>>>>>>
78369>>>>>>>        Function_Return (iRetval = 0)
78370>>>>>>>    End_Function
78371>>>>>>>
78371>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
78373>>>>>>>        Boolean bOK
78373>>>>>>>
78373>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78374>>>>>>>
78374>>>>>>>        If (bOK = False) Begin
78376>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
78377>>>>>>>>
78377>>>>>>>            Function_Return False
78378>>>>>>>        End
78378>>>>>>>>
78378>>>>>>>
78378>>>>>>>        Function_Return True
78379>>>>>>>    End_Function
78380>>>>>>>
78380>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78382>>>>>>>        Boolean bOK
78382>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
78383>>>>>>>        Function_Return bOK
78384>>>>>>>    End_Function
78385>>>>>>>
78385>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78387>>>>>>>        Handle hoIniFile
78387>>>>>>>        String sConnect
78387>>>>>>>
78387>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78388>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
78389>>>>>>>
78389>>>>>>>        Function_Return sConnect
78390>>>>>>>    End_Function
78391>>>>>>>
78391>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
78391>>>>>>>    // Pass a complete driver connection string
78391>>>>>>>    // Returns the following as a struct:
78391>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
78391>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
78391>>>>>>>    //
78391>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
78393>>>>>>>        tSQLConnection SQLConnection
78393>>>>>>>        tSQLConnection SQLConnection
78393>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
78393>>>>>>>        Boolean bTrusted bSilent bOK
78393>>>>>>>        Integer iPos
78393>>>>>>>
78393>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78394>>>>>>>        If (bOK = False) Begin
78396>>>>>>>            Function_Return SQLConnection
78397>>>>>>>        End
78397>>>>>>>>
78397>>>>>>>
78397>>>>>>>        Move False to bTrusted
78398>>>>>>>        Move False to bSilent
78399>>>>>>>
78399>>>>>>>        Case Begin
78399>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
78401>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78402>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78403>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78404>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78405>>>>>>>                If (bTrusted = False) Begin
78407>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78408>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78409>>>>>>>                End
78409>>>>>>>>
78409>>>>>>>                Case Break
78410>>>>>>>
78410>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
78413>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
78415>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
78416>>>>>>>                End
78416>>>>>>>>
78416>>>>>>>                Else Begin
78417>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78418>>>>>>>                End
78418>>>>>>>>
78418>>>>>>>
78418>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78419>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78420>>>>>>>                If (bTrusted = False) Begin
78422>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78423>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78424>>>>>>>                End
78424>>>>>>>>
78424>>>>>>>                Case Break
78425>>>>>>>
78425>>>>>>>            Case (sDriverID = DB2_DRV_ID)
78428>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78429>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78430>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78431>>>>>>>                Case Break
78432>>>>>>>
78432>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78435>>>>>>>                Break
78436>>>>>>>        Case End
78436>>>>>>>
78436>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
78437>>>>>>>
78437>>>>>>>        // bSilent?
78437>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
78438>>>>>>>        If (iPos = 0) Begin
78440>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
78441>>>>>>>        End
78441>>>>>>>>
78441>>>>>>>        If (iPos = 0) Begin
78443>>>>>>>            Move "0"                                                            to sValue
78444>>>>>>>        End
78444>>>>>>>>
78444>>>>>>>        Else Begin
78445>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
78446>>>>>>>        End
78446>>>>>>>>
78446>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
78447>>>>>>>
78447>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
78448>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
78449>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
78450>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
78451>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
78452>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
78453>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
78454>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
78455>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
78456>>>>>>>
78456>>>>>>>        Function_Return SQLConnection
78457>>>>>>>    End_Function
78458>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78458>>>>>>>>
78458>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78460>>>>>>>>    Integer iStart iEnd
78460>>>>>>>>    String sRetval
78460>>>>>>>>
78460>>>>>>>>    Move (Trim(sConnect)) to sConnect
78461>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78462>>>>>>>>    If (iStart = 0) Begin
78464>>>>>>>>        Function_Return ""
78465>>>>>>>>    End
78465>>>>>>>>>
78465>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78466>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78467>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78469>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78470>>>>>>>>    End
78470>>>>>>>>>
78470>>>>>>>>    Else Begin
78471>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
78472>>>>>>>>    End
78472>>>>>>>>>
78472>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78474>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78475>>>>>>>>        Decrement iEnd
78476>>>>>>>>    End
78476>>>>>>>>>
78476>>>>>>>>    If (iEnd <> 0) Begin
78478>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78479>>>>>>>>    End
78479>>>>>>>>>
78479>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78480>>>>>>>>
78480>>>>>>>>    Function_Return (Trim(sRetval))
78481>>>>>>>>End_Function
78482>>>>>>>>
78482>>>>>>>>
78482>>>>>>>
78482>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
78482>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78484>>>>>>>        Handle ho
78484>>>>>>>        Integer iIndex
78484>>>>>>>        Boolean bRetval bOK
78484>>>>>>>        tSQLConnection SQLConnection
78484>>>>>>>        tSQLConnection SQLConnection
78484>>>>>>>
78484>>>>>>>        Get pSQLConnection to SQLConnection
78485>>>>>>>        Get phoSQLConnectionIniFile to ho
78486>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
78487>>>>>>>        If (iIndex = -1) Begin
78489>>>>>>>            Function_Return False
78490>>>>>>>        End
78490>>>>>>>>
78490>>>>>>>
78490>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
78491>>>>>>>        Send UpdateConnectionString SQLConnection
78492>>>>>>>        If (ghoConnection > 0) Begin
78494>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
78495>>>>>>>            If (iIndex <> -1) Begin
78497>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
78498>>>>>>>            End
78498>>>>>>>>
78498>>>>>>>        End
78498>>>>>>>>
78498>>>>>>>
78498>>>>>>>        Function_Return bRetval
78499>>>>>>>    End_Function
78500>>>>>>>
78500>>>>>>>End_Class
78501>>>>>Use vWin32fh.pkg
78501>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout20\DfAbout.pkg)
78501>>>>>>>Use LanguageText.pkg
78501>>>>>>>Use Windows.pkg
78501>>>>>>>Use Dfclient.pkg
78501>>>>>>>Use DFbitmap.pkg
78501>>>>>>>Use GlobalFunctionsProcedures.pkg
78501>>>>>>>Use cRichEdit.pkg
78501>>>>>>>Use cTextEdit.pkg
78501>>>>>>>Use cRichEdit.pkg
78501>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 23.0\Pkg\gFormatNumbers.pkg)
78501>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cFormatter.pkg)
78501>>>>>>>>>>>Use VDFBase.pkg
78501>>>>>>>>>>>
78501>>>>>>>>>>>Class cFormatter is an cObject
78502>>>>>>>>>>>    
78502>>>>>>>>>>>    Procedure Construct_object
78504>>>>>>>>>>>        Integer iCh
78504>>>>>>>>>>>        Forward Send construct_object
78506>>>>>>>>>>>        Property String  psCurrencySymbol
78507>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
78508>>>>>>>>>>>        
78508>>>>>>>>>>>        Property String  psLeft
78509>>>>>>>>>>>        Property String  psright
78510>>>>>>>>>>>        Property Integer pbThousandsSep
78511>>>>>>>>>>>        Property Integer piPoints
78512>>>>>>>>>>>        
78512>>>>>>>>>>>        Property String  psCurPosLeft
78513>>>>>>>>>>>        Property String  psCurPosright
78514>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
78515>>>>>>>>>>>        Property Integer piCurPosPoints
78516>>>>>>>>>>>        
78516>>>>>>>>>>>        Property String  psCurNegLeft
78517>>>>>>>>>>>        Property String  psCurNegright
78518>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
78519>>>>>>>>>>>        Property Integer piCurNegPoints
78520>>>>>>>>>>>        
78520>>>>>>>>>>>        Property String  psNumPosLeft
78521>>>>>>>>>>>        Property String  psNumPosright
78522>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
78523>>>>>>>>>>>        Property Integer piNumPosPoints
78524>>>>>>>>>>>        
78524>>>>>>>>>>>        Property String  psNumNegLeft
78525>>>>>>>>>>>        Property String  psNumNegright
78526>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
78527>>>>>>>>>>>        Property Integer piNumNegPoints
78528>>>>>>>>>>>        
78528>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
78529>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
78530>>>>>>>>>>>        
78530>>>>>>>>>>>    End_Procedure
78531>>>>>>>>>>>    
78531>>>>>>>>>>>    // internal
78531>>>>>>>>>>>    // parse passed format string and set temporary properties with result
78531>>>>>>>>>>>    Procedure ParseFormat String sFmt
78533>>>>>>>>>>>        
78533>>>>>>>>>>>        String sLeft sRight sDigit
78533>>>>>>>>>>>        Integer bSep iPos i iDigits
78533>>>>>>>>>>>        
78533>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
78533>>>>>>>>>>>        // some literals are special. $ . , / #
78533>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
78534>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
78535>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
78536>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
78537>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
78538>>>>>>>>>>>        Move (Character(9)) to sDigit
78539>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
78540>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
78541>>>>>>>>>>>        
78541>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
78542>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
78545>>>>>>>>>>>        
78545>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
78546>>>>>>>>>>>        
78546>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
78547>>>>>>>>>>>        
78547>>>>>>>>>>>        // Move all the special literals back into place before parsing
78547>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
78548>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
78549>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
78550>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
78551>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
78552>>>>>>>>>>>        
78552>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
78554>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
78555>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
78557>>>>>>>>>>>                Move -2 to iDigits
78558>>>>>>>>>>>                Increment i
78559>>>>>>>>>>>            End
78559>>>>>>>>>>>>
78559>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
78563>>>>>>>>>>>                Increment i
78564>>>>>>>>>>>            Loop
78565>>>>>>>>>>>>
78565>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
78566>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
78569>>>>>>>>>>>            //
78569>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
78570>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
78574>>>>>>>>>>>                Increment i
78575>>>>>>>>>>>            Loop
78576>>>>>>>>>>>>
78576>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
78577>>>>>>>>>>>        End
78577>>>>>>>>>>>>
78577>>>>>>>>>>>        Else Begin                             // we have no decinal
78578>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
78579>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
78580>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
78582>>>>>>>>>>>                Move sFmt to sLeft
78583>>>>>>>>>>>                Move ""   to sRight
78584>>>>>>>>>>>            End
78584>>>>>>>>>>>>
78584>>>>>>>>>>>            Else Begin
78585>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
78586>>>>>>>>>>>                Move 1 to i
78587>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
78591>>>>>>>>>>>                    Increment i
78592>>>>>>>>>>>                Loop
78593>>>>>>>>>>>>
78593>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
78594>>>>>>>>>>>            End
78594>>>>>>>>>>>>
78594>>>>>>>>>>>        End
78594>>>>>>>>>>>>
78594>>>>>>>>>>>        // set temporary format properties and exit
78594>>>>>>>>>>>        Set pbThousandsSep to bSep
78595>>>>>>>>>>>        Set psLeft         to sLeft
78596>>>>>>>>>>>        Set psRight        to sRight
78597>>>>>>>>>>>        Set piPoints       to iDigits
78598>>>>>>>>>>>    End_Procedure
78599>>>>>>>>>>>    
78599>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
78599>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
78599>>>>>>>>>>>    //
78599>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
78599>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
78601>>>>>>>>>>>        String sPos sNeg
78601>>>>>>>>>>>        Integer iPos
78601>>>>>>>>>>>        
78601>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78602>>>>>>>>>>>        If iPos Begin
78604>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
78605>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
78606>>>>>>>>>>>        End
78606>>>>>>>>>>>>
78606>>>>>>>>>>>        Else Begin
78607>>>>>>>>>>>            Move sFmt         to sPos
78608>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
78609>>>>>>>>>>>        End
78609>>>>>>>>>>>>
78609>>>>>>>>>>>        Send ParseFormat sPos
78610>>>>>>>>>>>        If bCurrency Begin
78612>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
78613>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
78614>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
78615>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
78616>>>>>>>>>>>        End
78616>>>>>>>>>>>>
78616>>>>>>>>>>>        Else Begin
78617>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
78618>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
78619>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
78620>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
78621>>>>>>>>>>>        End
78621>>>>>>>>>>>>
78621>>>>>>>>>>>        
78621>>>>>>>>>>>        Send ParseFormat sNeg
78622>>>>>>>>>>>        If bCurrency Begin
78624>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
78625>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
78626>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
78627>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
78628>>>>>>>>>>>        End
78628>>>>>>>>>>>>
78628>>>>>>>>>>>        Else Begin
78629>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
78630>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
78631>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
78632>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
78633>>>>>>>>>>>        End
78633>>>>>>>>>>>>
78633>>>>>>>>>>>    End_Procedure
78634>>>>>>>>>>>    
78634>>>>>>>>>>>    // low level formatting. Pass parameters
78634>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
78636>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
78636>>>>>>>>>>>        Integer bIsNegative iDec iLen iCh
78636>>>>>>>>>>>        
78636>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
78639>>>>>>>>>>>        Move (Character(iCh)) to sDec
78640>>>>>>>>>>>        
78640>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
78641>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
78642>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
78643>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
78644>>>>>>>>>>>        // format for decimal separator
78644>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
78647>>>>>>>>>>>        
78647>>>>>>>>>>>        // format for thousand sep.
78647>>>>>>>>>>>        If bSep Begin
78649>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
78652>>>>>>>>>>>            Move (Character(iCh)) to sSep
78653>>>>>>>>>>>            Move (Length(sLeft)) to iLen
78654>>>>>>>>>>>            While (iLen>3)
78658>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
78659>>>>>>>>>>>                Move (iLen-3) to iLen
78660>>>>>>>>>>>            Loop
78661>>>>>>>>>>>>
78661>>>>>>>>>>>        End
78661>>>>>>>>>>>>
78661>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
78661>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
78664>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
78665>>>>>>>>>>>    End_Function
78666>>>>>>>>>>>    
78666>>>>>>>>>>>    // Public: Format for currency
78666>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
78668>>>>>>>>>>>        String  sLeft sRight
78668>>>>>>>>>>>        Integer bSep
78668>>>>>>>>>>>        If (nNumber<0) Begin
78670>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
78671>>>>>>>>>>>            Get psCurNegLeft         to sLeft
78672>>>>>>>>>>>            Get psCurNegRight        to sRight
78673>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
78676>>>>>>>>>>>        End
78676>>>>>>>>>>>>
78676>>>>>>>>>>>        Else Begin
78677>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
78678>>>>>>>>>>>            Get psCurPosLeft         to sLeft
78679>>>>>>>>>>>            Get psCurPosRight        to sRight
78680>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
78683>>>>>>>>>>>        End
78683>>>>>>>>>>>>
78683>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78684>>>>>>>>>>>    End_Function
78685>>>>>>>>>>>    
78685>>>>>>>>>>>    // Public: Format for numeric
78685>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
78687>>>>>>>>>>>        String  sLeft sRight
78687>>>>>>>>>>>        Integer bSep
78687>>>>>>>>>>>        If (nNumber<0) Begin
78689>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
78690>>>>>>>>>>>            Get psNumNegLeft         to sLeft
78691>>>>>>>>>>>            Get psNumNegRight        to sRight
78692>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
78695>>>>>>>>>>>        End
78695>>>>>>>>>>>>
78695>>>>>>>>>>>        Else Begin
78696>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
78697>>>>>>>>>>>            Get psNumPosLeft         to sLeft
78698>>>>>>>>>>>            Get psNumPosRight        to sRight
78699>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
78702>>>>>>>>>>>        End
78702>>>>>>>>>>>>
78702>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78703>>>>>>>>>>>    End_Function
78704>>>>>>>>>>>    
78704>>>>>>>>>>>    
78704>>>>>>>>>>>    // Public: Format passing format string
78704>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
78706>>>>>>>>>>>        Integer iPos bIsNeg
78706>>>>>>>>>>>        String  sLeft sRight
78706>>>>>>>>>>>        Integer iPoints bSep
78706>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
78707>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78708>>>>>>>>>>>        Case Begin
78708>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
78711>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
78715>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
78719>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
78721>>>>>>>>>>>        Case End
78721>>>>>>>>>>>        Send ParseFormat sFmt
78722>>>>>>>>>>>        Get pbThousandsSep to bSep
78723>>>>>>>>>>>        Get psLeft         to sLeft
78724>>>>>>>>>>>        Get psRight        to sRight
78725>>>>>>>>>>>        Get piPoints       to iPoints
78726>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78727>>>>>>>>>>>    End_Function
78728>>>>>>>>>>>    
78728>>>>>>>>>>>End_Class
78729>>>>>>>>>
78729>>>>>>>>>Global_Variable Handle ghoFormatter
78729>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
78730>>>>>>>>>
78730>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
78732>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
78733>>>>>>>>>End_Function
78734>>>>>>>>>
78734>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
78736>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
78737>>>>>>>>>End_Function
78738>>>>>>>>>
78738>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
78740>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
78741>>>>>>>>>End_Function
78742>>>>>>>>>
78742>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
78744>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
78745>>>>>>>>>End_Procedure
78746>>>>>>>>>
78746>>>>>>>>>Procedure SetNumberFormat Global String sFmt
78748>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
78749>>>>>>>>>End_Procedure
78750>>>>>>>>>
78750>>>>>>>>>
78750>>>>>>>Use tWinStructs.pkg
78750>>>>>>>
78750>>>>>>>Use cli.pkg
78750>>>>>>>Use DFBTRDRV.PKG
78750>>>>>>>Use MSSqldrv.pkg
78750>>>>>>>Use db2_drv.pkg
78750>>>>>>>Use odbc_drv.pkg
78750>>>>>>>Use seq_chnl.pkg
78750>>>>>>>
78750>>>>>>>Register_Function phoWorkspace Returns Handle
78750>>>>>>>Register_Function Help_filename Returns String
78750>>>>>>>Register_Function GetHelpFile Returns String
78750>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
78750>>>>>>>
78750>>>>>>>// *** Constant Declarations: ***
78750>>>>>>>//
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>// System icon menu constants. If the upper left hand
78750>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
78750>>>>>>>    Define SC_RESTORE  for |CI$F120
78750>>>>>>>    Define SC_MOVE     for |CI$F010
78750>>>>>>>    Define SC_SIZE     for |CI$F000
78750>>>>>>>    Define SC_MINIMIZE for |CI$F020
78750>>>>>>>    Define SC_MAXIMIZE for |CI$F030
78750>>>>>>>    Define SC_CLOSE    for |CI$F060
78750>>>>>>>    Define SC_KEYMENU  for |CI$F100
78750>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
78750>>>>>>>    Define SC_PREVWINDOW for |CI$F050
78750>>>>>>>
78750>>>>>>>Define CS_SignProgram        for "signtool.exe"
78750>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
78750>>>>>>>Define CS_VerifyCredentials  for "verify"
78750>>>>>>>Define CS_VerifyFileParam    for "/a"
78750>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
78750>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
78750>>>>>>>
78750>>>>>>>// *** Struct Declarations: ***
78750>>>>>>>Struct AboutSHELLEXECUTEINFO
78750>>>>>>>    DWord   cbSize
78750>>>>>>>    Integer fMask
78750>>>>>>>    Handle  hwnd
78750>>>>>>>    Pointer lpVerb
78750>>>>>>>    Pointer lpFile
78750>>>>>>>    Pointer lpParameters
78750>>>>>>>    Pointer lpDirectory
78750>>>>>>>    Integer nShow
78750>>>>>>>    Pointer hInstApp
78750>>>>>>>    Pointer lpIDList
78750>>>>>>>    Pointer lpClass
78750>>>>>>>    Handle  hkeyClass
78750>>>>>>>    DWord   dwHotKey
78750>>>>>>>    Handle  hIconMonitor // Union
78750>>>>>>>    //Handle  hMonitor     // Union
78750>>>>>>>    Handle  hProcess
78750>>>>>>>End_Struct
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
78750>>>>>>>//Type MEMORYSTATUS
78750>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
78750>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
78750>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
78750>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
78750>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
78750>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
78750>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
78750>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
78750>>>>>>>//End_Type
78750>>>>>>>
78750>>>>>>>// *** External Function calls: ***
78750>>>>>>>//
78750>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
78751>>>>>>>
78751>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
78752>>>>>>>
78752>>>>>>>// Do not call directly, use the wrapper function instead
78752>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
78753>>>>>>>
78753>>>>>>>    // Wrapper Function WNetGetUser
78753>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
78755>>>>>>>
78755>>>>>>>        DWord   dwResult
78755>>>>>>>        UWide   uwName uwUserName
78755>>>>>>>        UWide   uwName uwUserName
78755>>>>>>>
78755>>>>>>>        Send StringToWide lpName (&uwName)
78756>>>>>>>
78756>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
78757>>>>>>>
78757>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
78758>>>>>>>
78758>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
78759>>>>>>>
78759>>>>>>>        Function_Return dwResult
78760>>>>>>>    End_Function
78761>>>>>>>
78761>>>>>>>
78761>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
78762>>>>>>>
78762>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
78763>>>>>>>
78763>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
78764>>>>>>>
78764>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
78765>>>>>>>
78765>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
78766>>>>>>>
78766>>>>>>>// *** Global/Desktop Function Declarations: ***
78766>>>>>>>
78766>>>>>>>Function ComputerName Desktop Returns String
78768>>>>>>>    String sName
78768>>>>>>>    Get_Environment "COMPUTERNAME" to sName
78769>>>>>>>>
78769>>>>>>>    Function_Return sName
78770>>>>>>>End_Function
78771>>>>>>>
78771>>>>>>>Function Network_User_Name Desktop Returns String
78773>>>>>>>    WString wName
78773>>>>>>>    Integer iRetval iLength
78773>>>>>>>
78773>>>>>>>    Move 0 to iLength
78774>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
78775>>>>>>>    Move (ZeroString(iLength)) to wName
78776>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
78777>>>>>>>
78777>>>>>>>    If (iRetval = NO_ERROR) Begin
78779>>>>>>>        Function_Return (CString (wName))
78780>>>>>>>    End
78780>>>>>>>>
78780>>>>>>>
78780>>>>>>>    Function_Return "User Unknown"
78781>>>>>>>End_Function
78782>>>>>>>
78782>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
78784>>>>>>>    String sClient sDriver sClientDriver
78784>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
78784>>>>>>>    Handle hoMsqlDrv
78784>>>>>>>
78784>>>>>>>    Move 0 to iDriver
78785>>>>>>>    Move "" to sClient
78786>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78789>>>>>>>    For iCount from 1 to iNumberOfDrivers
78795>>>>>>>>
78795>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
78798>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
78800>>>>>>>            Move iCount to iDriver
78801>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
78802>>>>>>>        End
78802>>>>>>>>
78802>>>>>>>    Loop
78803>>>>>>>>
78803>>>>>>>
78803>>>>>>>    // This info is (at current) only available for the MS SQL driver:
78803>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
78805>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
78808>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
78809>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
78810>>>>>>>        Send Destroy of hoMsqlDrv
78811>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
78812>>>>>>>    End
78812>>>>>>>>
78812>>>>>>>
78812>>>>>>>    Function_Return sClient
78813>>>>>>>End_Function
78814>>>>>>>
78814>>>>>>>// *** Class Declarations: ***
78814>>>>>>>//
78814>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
78815>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
78817>>>>>>>        Send Mouse_Up iWindowNumber iPosition
78818>>>>>>>    End_Procedure
78819>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
78821>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
78823>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
78824>>>>>>>    End_Procedure
78825>>>>>>>End_Class
78826>>>>>>>
78826>>>>>>>Class cCopyEditorContentButton is a Button
78827>>>>>>>    Procedure Construct_Object
78829>>>>>>>        Forward Send Construct_Object
78831>>>>>>>        Property Handle phoEditorHandle
78832>>>>>>>        Set psToolTip to C_$DescCopy
78833>>>>>>>    End_Procedure
78834>>>>>>>
78834>>>>>>>    Procedure CopyToWindowsClipboard
78836>>>>>>>        Handle hoEditor
78836>>>>>>>        Boolean bCanCopy
78836>>>>>>>        Address aEditorAddress
78836>>>>>>>
78836>>>>>>>        Get phoEditorHandle to hoEditor
78837>>>>>>>        Send Select_All of hoEditor
78838>>>>>>>        Get CanCopy of hoEditor to bCanCopy
78839>>>>>>>        If (bCanCopy = True) Begin
78841>>>>>>>            Get paValue of hoEditor to aEditorAddress
78842>>>>>>>            Send Copy   of hoEditor
78843>>>>>>>            // Remove the selection after text is copied to the clipboard.
78843>>>>>>>            Send Beginning_of_Data of hoEditor
78844>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
78845>>>>>>>        End
78845>>>>>>>>
78845>>>>>>>    End_Procedure
78846>>>>>>>End_Class
78847>>>>>>>
78847>>>>>>>Class SysinfoDisplay is a cTextEdit
78848>>>>>>>    Procedure Construct_Object
78850>>>>>>>        Forward Send Construct_Object
78852>>>>>>>
78852>>>>>>>        Set Size to 100 245
78853>>>>>>>        Set Location to 6 6
78854>>>>>>>        Set Border_Style to Border_None
78855>>>>>>>        Set Read_Only_State to True
78856>>>>>>>        Set pbWrap to True
78857>>>>>>>        Set peAnchors to anAll
78858>>>>>>>    End_Procedure
78859>>>>>>>
78859>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
78859>>>>>>>
78859>>>>>>>    Procedure AppendTextLn String sText
78861>>>>>>>        String sWorkspaceWSFile
78861>>>>>>>
78861>>>>>>>        // Only works for English:
78861>>>>>>>        If (ghoApplication > 0) Begin
78863>>>>>>>            If (sText contains "Workspace Name") Begin
78865>>>>>>>                Move "Workspace Config Filename:" to sText
78866>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
78867>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
78868>>>>>>>            End
78868>>>>>>>>
78868>>>>>>>        End
78868>>>>>>>>
78868>>>>>>>        Send AppendText sText
78869>>>>>>>        Send AppendText (character(10))
78870>>>>>>>    End_Procedure
78871>>>>>>>
78871>>>>>>>    //    This method will show the name Of the current directory in the system
78871>>>>>>>    //    information box
78871>>>>>>>    Procedure Show_Current_Directory
78873>>>>>>>        String sDir
78873>>>>>>>
78873>>>>>>>        Get_Current_Directory To sDir
78874>>>>>>>
78874>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
78875>>>>>>>    End_Procedure
78876>>>>>>>
78876>>>>>>>    Procedure Show_Windows_Directory
78878>>>>>>>        String sWindir
78878>>>>>>>
78878>>>>>>>        Get_Windows_Directory To sWindir
78879>>>>>>>
78879>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
78880>>>>>>>    End_Procedure
78881>>>>>>>
78881>>>>>>>    Procedure Show_Current_User
78883>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
78884>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
78885>>>>>>>    End_Procedure
78886>>>>>>>
78886>>>>>>>    Procedure Show_Number_Format
78888>>>>>>>        Integer iFormat
78888>>>>>>>        String sFormatText
78888>>>>>>>
78888>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
78891>>>>>>>        Move (Character (iFormat)) To sFormatText
78892>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
78893>>>>>>>
78893>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
78896>>>>>>>        Move (Character (iFormat)) to sFormatText
78897>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
78898>>>>>>>    End_Procedure
78899>>>>>>>
78899>>>>>>>    Procedure Show_Filelist_Name
78901>>>>>>>        String sFilename
78901>>>>>>>
78901>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
78904>>>>>>>
78904>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
78905>>>>>>>    End_Procedure
78906>>>>>>>
78906>>>>>>>    Procedure Show_Lock_Delay
78908>>>>>>>        Integer iLockdelay
78908>>>>>>>
78908>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
78911>>>>>>>
78911>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
78912>>>>>>>    End_Procedure
78913>>>>>>>
78913>>>>>>>    Procedure Show_Lock_Timeout
78915>>>>>>>        Integer iLockTimeout
78915>>>>>>>
78915>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
78918>>>>>>>
78918>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
78919>>>>>>>    End_Procedure
78920>>>>>>>
78920>>>>>>>    Procedure Show_Screen_Size
78922>>>>>>>        Integer iYscreensize iXscreensize
78922>>>>>>>
78922>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
78923>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
78924>>>>>>>
78924>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
78925>>>>>>>    End_Procedure
78926>>>>>>>
78926>>>>>>>    Procedure Show_Page_Size
78928>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
78929>>>>>>>    End_procedure
78930>>>>>>>
78930>>>>>>>    Procedure Show_Date
78932>>>>>>>        Date dToday
78932>>>>>>>
78932>>>>>>>        Move (CurrentDateTime()) to dToday
78933>>>>>>>
78933>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
78934>>>>>>>    End_procedure
78935>>>>>>>
78935>>>>>>>    Procedure Show_Date_Format
78937>>>>>>>        Integer iDateFormat
78937>>>>>>>        String sDateFormat
78937>>>>>>>
78937>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
78940>>>>>>>        Case Begin
78940>>>>>>>            Case (iDateFormat = DF_DATE_USA)
78942>>>>>>>                Move C_$USA To sDateFormat
78943>>>>>>>                Case Break
78944>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
78947>>>>>>>                Move C_$European To sDateFormat
78948>>>>>>>                Case Break
78949>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
78952>>>>>>>                Move C_$Military To sDateFormat
78953>>>>>>>                Case Break
78954>>>>>>>            Case Else
78954>>>>>>>                Move C_$UnknownDateType To sDateFormat
78955>>>>>>>                Case Break
78956>>>>>>>        Case End
78956>>>>>>>
78956>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
78957>>>>>>>    End_Procedure
78958>>>>>>>
78958>>>>>>>    // 2013-08-14 NGS
78958>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
78958>>>>>>>    Procedure Show_Systemresources
78960>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
78960>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
78960>>>>>>>        Integer iRetval
78960>>>>>>>        Number nValue
78960>>>>>>>        String sValue
78960>>>>>>>
78960>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
78961>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
78962>>>>>>>        If (iRetval = 0) Begin
78964>>>>>>>            Move (ShowLastError ()) to iRetval
78965>>>>>>>            Procedure_Return
78966>>>>>>>        End
78966>>>>>>>>
78966>>>>>>>
78966>>>>>>>        Send AppendTextLn ""
78967>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
78968>>>>>>>
78968>>>>>>>        // Show memory in Gigabytes:
78968>>>>>>>        Move (nValue/1024/1024/1024) to nValue
78969>>>>>>>        Move (Round(nValue)) to nValue
78970>>>>>>>        Get FormatNumber nValue 2 to sValue
78971>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
78972>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
78973>>>>>>>
78973>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
78973>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
78974>>>>>>>        Move (Round(nValue)) to nValue
78975>>>>>>>        Get FormatNumber nValue 0 to sValue
78976>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
78977>>>>>>>
78977>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
78977>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
78978>>>>>>>        Move (Round(nValue)) to nValue
78979>>>>>>>        Get FormatNumber nValue 0 to sValue
78980>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
78981>>>>>>>
78981>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
78981>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
78982>>>>>>>        Move (Round(nValue)) to nValue
78983>>>>>>>        Get FormatNumber nValue 0 to sValue
78984>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
78985>>>>>>>
78985>>>>>>>        // Add an empty row after the memory information:
78985>>>>>>>        Send AppendTextLn ""
78986>>>>>>>    End_Procedure
78987>>>>>>>
78987>>>>>>>    Procedure Show_Registration
78989>>>>>>>        String sRegName
78989>>>>>>>        Integer iSN iUsersMax iUserCount
78989>>>>>>>
78989>>>>>>>        Registration sRegName iSN
78990>>>>>>>>
78990>>>>>>>        Get_Licensed_Max_Users to iUsersMax
78991>>>>>>>        Get_Current_User_Count to iUserCount
78992>>>>>>>
78992>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
78993>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
78994>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
78995>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
78996>>>>>>>    End_Procedure
78997>>>>>>>
78997>>>>>>>    //****************************************************************************
78997>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
78997>>>>>>>    // To the workspace object passing the an object and message To send back
78997>>>>>>>    // To this object. It is expected that the workspace object will send this
78997>>>>>>>    // message for every line Of information it wants displayed (passing the
78997>>>>>>>    // information To be displayed
78997>>>>>>>    //****************************************************************************
78997>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
78997>>>>>>>
78997>>>>>>>    Procedure Show_ServicePack
78999>>>>>>>        String sKey sVersion sDataFlex
78999>>>>>>>        Handle hoRegistry
78999>>>>>>>        Boolean bExists bOpened
78999>>>>>>>
78999>>>>>>>        Move "DataFlex"        to sDataFlex
79000>>>>>>>
79000>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
79001>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
79002>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
79003>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
79004>>>>>>>
79004>>>>>>>        If (bExists) Begin
79006>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79007>>>>>>>        End
79007>>>>>>>>
79007>>>>>>>        Else Begin
79008>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79009>>>>>>>        End
79009>>>>>>>>
79009>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
79010>>>>>>>        If (bExists) Begin
79012>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
79013>>>>>>>            If (bOpened) Begin
79015>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
79016>>>>>>>                If (bExists) Begin
79018>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
79019>>>>>>>                End
79019>>>>>>>>
79019>>>>>>>                Send CloseKey of hoRegistry
79020>>>>>>>            End
79020>>>>>>>>
79020>>>>>>>        End
79020>>>>>>>>
79020>>>>>>>        Send Destroy of hoRegistry
79021>>>>>>>
79021>>>>>>>        If (sVersion <> "") Begin
79023>>>>>>>           Send AppendTextLn sVersion
79024>>>>>>>           Send AppendTextLn ""
79025>>>>>>>        End
79025>>>>>>>>
79025>>>>>>>    End_Procedure
79026>>>>>>>
79026>>>>>>>    Procedure Show_WorkspaceInformation
79028>>>>>>>        Integer hoWorkspace
79028>>>>>>>
79028>>>>>>>        If (ghoApplication <> 0) Begin
79030>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79031>>>>>>>            If (hoWorkspace <> 0) Begin
79033>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
79034>>>>>>>            End
79034>>>>>>>>
79034>>>>>>>        End
79034>>>>>>>>
79034>>>>>>>    End_Procedure
79035>>>>>>>
79035>>>>>>>    //****************************************************************************
79035>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
79035>>>>>>>    // to the connection manager object passing the an object and message to send
79035>>>>>>>    // back to this object. It is expected that the connection manager object will
79035>>>>>>>    // send this message for every line Of information it wants displayed (passing
79035>>>>>>>    // the information To be displayed
79035>>>>>>>    //****************************************************************************
79035>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
79035>>>>>>>
79035>>>>>>>    Procedure Show_ConnectionIdInformation
79037>>>>>>>        If (ghoConnection > 0) Begin
79039>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79040>>>>>>>            Send AppendTextLn ""
79041>>>>>>>        End
79041>>>>>>>>
79041>>>>>>>    End_Procedure
79042>>>>>>>
79042>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
79044>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
79045>>>>>>>    End_Function
79046>>>>>>>
79046>>>>>>>    Procedure Show_Versions
79048>>>>>>>        Integer iVersion iRevision iBuild
79048>>>>>>>
79048>>>>>>>        Version_information iVersion iRevision iBuild
79050>>>>>>>
79050>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
79051>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
79052>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
79053>>>>>>>        Send AppendTextLn "This is a 32-bit exe file"
79054>>>>>>>    End_Procedure
79055>>>>>>>
79055>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
79057>>>>>>>        Boolean bOK
79057>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
79058>>>>>>>        Function_Return bOK
79059>>>>>>>    End_Function
79060>>>>>>>
79060>>>>>>>    //***
79060>>>>>>>    //*** BW
79060>>>>>>>    //*** Procedure: Show_Drivers
79060>>>>>>>    //*** Purpose  : Show loaded database drivers
79060>>>>>>>    //***
79060>>>>>>>
79060>>>>>>>//#IF (Required_FMAC_Build > 106)
79060>>>>>>>//    #Warning -3
79060>>>>>>>//#ENDIF
79060>>>>>>>    Procedure Show_Drivers
79062>>>>>>>        String sDriverID sVersion sClient sValue
79062>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
79062>>>>>>>        Handle hoCLIHandler hoBtrvHandler
79062>>>>>>>        Boolean bStudioLicense bIsDAWDriver
79062>>>>>>>
79062>>>>>>>        Move False to bStudioLicense
79063>>>>>>>
79063>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
79064>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
79065>>>>>>>
79065>>>>>>>        // For testing purposes:
79065>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79065>>>>>>>//        Load_Driver MSSQLDRV_ID
79065>>>>>>>//        Load_Driver ODBC_DRV_ID
79065>>>>>>>//        Load_Driver DB2_DRV_ID
79065>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79065>>>>>>>//
79065>>>>>>>        Move False to Err
79066>>>>>>>
79066>>>>>>>        // Loop through all loaded drivers.
79066>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79069>>>>>>>        If (iNumberOfDrivers > 1) Begin
79071>>>>>>>            Send AppendTextLn ""
79072>>>>>>>        End
79072>>>>>>>>
79072>>>>>>>        For iDriver from 1 to iNumberOfDrivers
79078>>>>>>>>
79078>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79079>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
79082>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79083>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
79084>>>>>>>
79084>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True) Begin
79086>>>>>>>
79086>>>>>>>                // Pervasive/Btrieve database
79086>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
79088>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
79089>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
79090>>>>>>>                    If (sClient <> "0.0.0") Begin
79092>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
79093>>>>>>>                    End
79093>>>>>>>>
79093>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
79094>>>>>>>                    If (sClient <> "0.0.0") Begin
79096>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
79097>>>>>>>                    End
79097>>>>>>>>
79097>>>>>>>                End
79097>>>>>>>>
79097>>>>>>>
79097>>>>>>>                Else Begin
79098>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
79099>>>>>>>                    Move 0 to iNumServers
79100>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
79102>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
79105>>>>>>>                    End
79105>>>>>>>>
79105>>>>>>>
79105>>>>>>>                    If (bIsDAWDriver = True) Begin
79107>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
79109>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
79110>>>>>>>                        End
79110>>>>>>>>
79110>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
79111>>>>>>>                    End
79111>>>>>>>>
79111>>>>>>>
79111>>>>>>>                    // If the serialnumber is = 0, it means that the
79111>>>>>>>                    // Studio licens is in use and there is no
79111>>>>>>>                    // number of max users defined because the driver is
79111>>>>>>>                    // relying on the info from the VDF license.
79111>>>>>>>                    If (bStudioLicense = False) Begin
79113>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
79114>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
79115>>>>>>>                    End
79115>>>>>>>>
79115>>>>>>>                End
79115>>>>>>>>
79115>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
79116>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
79118>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
79119>>>>>>>                End
79119>>>>>>>>
79119>>>>>>>                If (iNumServers <> 0) Begin
79121>>>>>>>                    For iCount from 1 to iNumServers
79127>>>>>>>>
79127>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
79130>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
79132>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
79133>>>>>>>                        End
79133>>>>>>>>
79133>>>>>>>                    Loop
79134>>>>>>>>
79134>>>>>>>                End
79134>>>>>>>>
79134>>>>>>>            End
79134>>>>>>>>
79134>>>>>>>        Loop
79135>>>>>>>>
79135>>>>>>>
79135>>>>>>>        Send AppendTextLn ""
79136>>>>>>>        If (bStudioLicense = False) Begin
79138>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
79139>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
79140>>>>>>>        End
79140>>>>>>>>
79140>>>>>>>        Else Begin
79141>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
79142>>>>>>>        End
79142>>>>>>>>
79142>>>>>>>        Send Destroy of hoCLIHandler
79143>>>>>>>        Send Destroy of hoBtrvHandler
79144>>>>>>>    End_Procedure
79145>>>>>>>
79145>>>>>>>    Procedure Show_HelpFile
79147>>>>>>>        String sHelpFile
79147>>>>>>>        Integer eHelpType
79147>>>>>>>
79147>>>>>>>        If (ghoApplication <> 0) Begin
79149>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
79150>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
79152>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
79153>>>>>>>            End
79153>>>>>>>>
79153>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
79156>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
79157>>>>>>>            End
79157>>>>>>>>
79157>>>>>>>            Else Begin
79158>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
79159>>>>>>>            End
79159>>>>>>>>
79159>>>>>>>
79159>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
79160>>>>>>>        End
79160>>>>>>>>
79160>>>>>>>    End_Procedure
79161>>>>>>>
79161>>>>>>>    Procedure Show_EnterAsTab
79163>>>>>>>        Boolean bEnterKeyAsTabKey
79163>>>>>>>        String sText
79163>>>>>>>
79163>>>>>>>        If (ghoApplication <> 0) Begin
79165>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
79166>>>>>>>            If (bEnterKeyAsTabKey) Begin
79168>>>>>>>                Move "True" To sText
79169>>>>>>>            End
79169>>>>>>>>
79169>>>>>>>            Else Begin
79170>>>>>>>                Move "False" To sText
79171>>>>>>>            End
79171>>>>>>>>
79171>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
79172>>>>>>>        End
79172>>>>>>>>
79172>>>>>>>    End_Procedure
79173>>>>>>>
79173>>>>>>>    //    During activation we will remove the old information and add the newly
79173>>>>>>>    //    found systeminformation
79173>>>>>>>    Procedure Add_Focus Integer hoRoot
79175>>>>>>>        Forward Send Add_Focus hoRoot
79177>>>>>>>
79177>>>>>>>        Send Delete_Data
79178>>>>>>>
79178>>>>>>>        Set Changed_State To False
79179>>>>>>>        Set Read_Only_State To True
79180>>>>>>>
79180>>>>>>>        Send Show_Registration
79181>>>>>>>        Send Show_Drivers
79182>>>>>>>        Send Show_ServicePack
79183>>>>>>>        Send Show_Versions
79184>>>>>>>        Send AppendTextLn ""
79185>>>>>>>
79185>>>>>>>        If (ghoApplication <> 0) Begin
79187>>>>>>>            Send Show_WorkSpaceInformation
79188>>>>>>>            Send Show_HelpFile
79189>>>>>>>            Send AppendTextLn ""
79190>>>>>>>        End
79190>>>>>>>>
79190>>>>>>>        Else Begin
79191>>>>>>>            Send AppendTextLn ""
79192>>>>>>>        End
79192>>>>>>>>
79192>>>>>>>
79192>>>>>>>        If (ghoConnection <> 0) Begin
79194>>>>>>>            Send Show_ConnectionIdInformation
79195>>>>>>>        End
79195>>>>>>>>
79195>>>>>>>
79195>>>>>>>        Send Show_Current_User
79196>>>>>>>        Send Show_Windows_Directory
79197>>>>>>>        Send Show_Current_Directory
79198>>>>>>>
79198>>>>>>>        // This is already shown in the workspace details,
79198>>>>>>>        // unless no workspace object is present:
79198>>>>>>>        If (ghoApplication = 0) Begin
79200>>>>>>>            Send Show_Filelist_Name
79201>>>>>>>        End
79201>>>>>>>>
79201>>>>>>>
79201>>>>>>>        If (ghoApplication <> 0) Begin
79203>>>>>>>            Send AppendTextLn ""
79204>>>>>>>            Send Show_EnterAsTab
79205>>>>>>>        End
79205>>>>>>>>
79205>>>>>>>
79205>>>>>>>        Send Show_Screen_Size
79206>>>>>>>        Send Show_Page_Size
79207>>>>>>>        Send Show_Number_Format
79208>>>>>>>        Send Show_Date_Format
79209>>>>>>>        Send Show_Lock_Delay
79210>>>>>>>        Send Show_Lock_Timeout
79211>>>>>>>        Send Show_Date
79212>>>>>>>        Send Show_Systemresources
79213>>>>>>>        Send Beginning_of_Data
79214>>>>>>>
79214>>>>>>>        Set Icon to 'default.ico'
79215>>>>>>>    End_Procedure
79216>>>>>>>End_Class
79217>>>>>>>
79217>>>>>>>Class SysInfoDialog is a ModalPanel
79218>>>>>>>    Procedure Construct_Object
79220>>>>>>>        Forward Send Construct_Object
79222>>>>>>>
79222>>>>>>>        Set Label to C_$SystemInformation
79223>>>>>>>        Set Size to 140 267
79224>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79225>>>>>>>        Set Border_Style to Border_Thick
79226>>>>>>>        Set Sysmenu_Icon to False
79227>>>>>>>
79227>>>>>>>        // "+1" will make the panel to paint correctly.
79227>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
79228>>>>>>>
79228>>>>>>>        // 2014-09-14 NGS
79228>>>>>>>        // Added a container object around the cTexteditor
79228>>>>>>>        // object to get a border around the text.
79228>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
79230>>>>>>>            Set Location to 2 4
79231>>>>>>>            Set Size to 110 255
79232>>>>>>>            Set Border_Style to Border_ClientEdge
79233>>>>>>>            Set Color to clWhite
79234>>>>>>>            Set peAnchors to anAll
79235>>>>>>>
79235>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
79237>>>>>>>            End_Object
79238>>>>>>>
79238>>>>>>>        End_Object
79239>>>>>>>
79239>>>>>>>        Object oCloseButton is a Button
79241>>>>>>>            Set Label to C_$Close
79242>>>>>>>            Set Location to 120 210
79243>>>>>>>            CompilerWarnings Off
79243>>>>>>>            Set Message Item 0 to msg_Close_Panel
79244>>>>>>>            CompilerWarnings On
79244>>>>>>>            Set Default_State To True
79245>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
79245>>>>>>>            // and changes its peAnchors, we might as well prepare this object
79245>>>>>>>            // for that situation.
79245>>>>>>>            Set peAnchors to anBottomRight
79246>>>>>>>        End_Object
79247>>>>>>>
79247>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79249>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79250>>>>>>>            Set Size to 14 50
79251>>>>>>>            Set Location to 120 158
79252>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79252>>>>>>>            // we might as well prepare the object for it.
79252>>>>>>>            Set peAnchors to anBottomRight
79253>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
79254>>>>>>>        End_Object
79255>>>>>>>
79255>>>>>>>        On_Key kCancel Send Close_Panel
79256>>>>>>>    End_Procedure
79257>>>>>>>
79257>>>>>>>    Procedure Page Integer iPageObject
79259>>>>>>>        Handle hMenu
79259>>>>>>>        Integer iPrevState
79259>>>>>>>
79259>>>>>>>        Forward Send Page iPageObject
79261>>>>>>>
79261>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
79261>>>>>>>        //
79261>>>>>>>    End_Procedure
79262>>>>>>>
79262>>>>>>>End_Class
79263>>>>>>>
79263>>>>>>>Class cAboutEdit is an cRichEdit
79264>>>>>>>    Procedure Construct_Object
79266>>>>>>>        Forward Send Construct_Object
79268>>>>>>>
79268>>>>>>>        Property String psContentText
79269>>>>>>>
79269>>>>>>>        Set Size to 77 153
79270>>>>>>>        Set Location to 8 60
79271>>>>>>>        Set Read_Only_State to True
79272>>>>>>>        Set Skip_State to True
79273>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
79273>>>>>>>        // or 1/20 of a printer's point.
79273>>>>>>>        Set piRightMargin to (0.1 * 1440)
79274>>>>>>>        Set Border_Style  to Border_None
79275>>>>>>>    End_Procedure
79276>>>>>>>
79276>>>>>>>    // Adds a line of text to the edit object
79276>>>>>>>    Procedure Add_Line String sText
79278>>>>>>>        String sContentText
79278>>>>>>>        Get psContentText to sContentText
79279>>>>>>>        Move (sContentText + String(sText)) to sContentText
79280>>>>>>>        Set psContentText to sContentText
79281>>>>>>>    End_Procedure
79282>>>>>>>
79282>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
79282>>>>>>>    // Note that we use a property psContentText and add to it,
79282>>>>>>>    // because the object isn't paged yet when we add these
79282>>>>>>>    // values and the COM edit object needs to be paged
79282>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
79282>>>>>>>    Procedure Add_LineLn String sText
79284>>>>>>>        String sContentText sCR
79284>>>>>>>
79284>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
79285>>>>>>>        Get psContentText to sContentText
79286>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
79287>>>>>>>        Set psContentText to sContentText
79288>>>>>>>    End_Procedure
79289>>>>>>>
79289>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
79291>>>>>>>        String sLinkText
79291>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
79292>>>>>>>        Send Show_HomePage sLinkText
79293>>>>>>>    End_Procedure
79294>>>>>>>
79294>>>>>>>    Procedure Page Integer iPageObject
79296>>>>>>>        String sContentText
79296>>>>>>>
79296>>>>>>>        Forward Send Page iPageObject
79298>>>>>>>        Get psContentText to sContentText
79299>>>>>>>        Send AppendText sContentText
79300>>>>>>>        send Beginning_of_Data
79301>>>>>>>    End_Procedure
79302>>>>>>>
79302>>>>>>>End_Class
79303>>>>>>>
79303>>>>>>>Class AboutDialog is a ModalPanel
79304>>>>>>>    Procedure Construct_Object
79306>>>>>>>
79306>>>>>>>        Forward Send Construct_Object
79308>>>>>>>
79308>>>>>>>        Set Label to C_$About
79309>>>>>>>        Set Size to 118 230
79310>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79311>>>>>>>        Set Border_Style to Border_Thick
79312>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
79313>>>>>>>
79313>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
79315>>>>>>>        End_Object
79316>>>>>>>
79316>>>>>>>        Object oBox is a Container3d
79318>>>>>>>            Set Border_Style to Border_Normal
79319>>>>>>>            Set Size to 90 220
79320>>>>>>>            Set Location to 4 5
79321>>>>>>>            Set Color to clWhite
79322>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79322>>>>>>>            // we might as well prepare the object for it.
79322>>>>>>>            Set peAnchors to anAll
79323>>>>>>>
79323>>>>>>>            Object oAboutGraphic is a BitmapContainer
79325>>>>>>>                Set Border_Style To Border_None
79326>>>>>>>                Set Bitmap_Style to Bitmap_Center
79327>>>>>>>                Set Color to clWhite
79328>>>>>>>                Set Size to 45 50
79329>>>>>>>                Set Location to 0 3
79330>>>>>>>            End_Object
79331>>>>>>>
79331>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
79333>>>>>>>                Set Border_Style to Border_None
79334>>>>>>>                Set Bitmap_Style to Bitmap_Center
79335>>>>>>>                Set Color to clWhite
79336>>>>>>>                Set Size to 30 55
79337>>>>>>>                Set Location to 50 3
79338>>>>>>>            End_Object
79339>>>>>>>
79339>>>>>>>            Object oInfoList_Editor is an cAboutEdit
79341>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
79341>>>>>>>                // we might as well prepare the object for it.
79341>>>>>>>                Set peAnchors to anAll
79342>>>>>>>            End_Object
79343>>>>>>>
79343>>>>>>>            // These objects are here for backwards compatability only.
79343>>>>>>>            // They are not used.
79343>>>>>>>            Object oProductName is a TextBox
79345>>>>>>>                Set Label To C_$ProductName
79346>>>>>>>                Set Size To 10 45
79347>>>>>>>                Set Location To 8 53
79348>>>>>>>                Set Visible_State to False
79349>>>>>>>                Set Focus_Mode to NonFocusable
79350>>>>>>>            End_Object
79351>>>>>>>
79351>>>>>>>            Object oVersion is a TextBox
79353>>>>>>>                Set Label To C_$Version
79354>>>>>>>                Set Size To 10 25
79355>>>>>>>                Set Location To 21 53
79356>>>>>>>                Set Visible_State to False
79357>>>>>>>                Set Focus_Mode to NonFocusable
79358>>>>>>>            End_Object
79359>>>>>>>
79359>>>>>>>            Object oCopyright is a TextBox
79361>>>>>>>                Set Label To C_$Copyright
79362>>>>>>>                Set Size To 10 31
79363>>>>>>>                Set Location To 34 53
79364>>>>>>>                Set Visible_State to False
79365>>>>>>>                Set Focus_Mode to NonFocusable
79366>>>>>>>            End_Object
79367>>>>>>>
79367>>>>>>>            Object oAuthor is a TextBox
79369>>>>>>>                Set Label To C_$Author
79370>>>>>>>                Set Size To 10 22
79371>>>>>>>                Set Location To 46 53
79372>>>>>>>                Set Visible_State to False
79373>>>>>>>                Set Focus_Mode to NonFocusable
79374>>>>>>>            End_Object
79375>>>>>>>
79375>>>>>>>        End_Object
79376>>>>>>>
79376>>>>>>>        Object oOKButton is a Button
79378>>>>>>>            On_Item C_$Close Send Close_Panel
79379>>>>>>>            Set Location to 98 176
79380>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79380>>>>>>>            // we might as well prepare the object for it.
79380>>>>>>>            Set peAnchors to anBottomRight
79381>>>>>>>        End_Object
79382>>>>>>>
79382>>>>>>>        Object oSysInfoButton is a Button
79384>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
79385>>>>>>>            Set Location to 98 123
79386>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79386>>>>>>>            // we might as well prepare the object for it.
79386>>>>>>>            Set peAnchors to anBottomRight
79387>>>>>>>        End_Object
79388>>>>>>>
79388>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79390>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79391>>>>>>>            Set Size to 14 50
79392>>>>>>>            Set Location to 98 70
79393>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79393>>>>>>>            // we might as well prepare the object for it.
79393>>>>>>>            Set peAnchors to anBottomRight
79394>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
79395>>>>>>>        End_Object
79396>>>>>>>
79396>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
79397>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
79398>>>>>>>        Set LogoDF to "DF32.bmp"
79399>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
79399>>>>>>>    End_Procedure
79400>>>>>>>
79400>>>>>>>    Procedure Page Integer iPageObject
79402>>>>>>>        Handle hMenu
79402>>>>>>>        Integer iPrevState
79402>>>>>>>
79402>>>>>>>        Forward Send Page iPageObject
79404>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
79404>>>>>>>        Set Icon to "Default.ico"
79405>>>>>>>
79405>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
79405>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
79406>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79407>>>>>>>        // The "Move" menu command may come in handy to have.
79407>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79407>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79408>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79409>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79410>>>>>>>        // The "Close" menu command may be good to have.
79410>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79410>>>>>>>    End_Procedure
79411>>>>>>>
79411>>>>>>>    Procedure Set ProductName String sText
79413>>>>>>>        Set Value of oProductName to sText
79414>>>>>>>    End_Procedure
79415>>>>>>>
79415>>>>>>>    Procedure Set Copyright String sText
79417>>>>>>>        Set Value of oCopyright to sText
79418>>>>>>>    End_Procedure
79419>>>>>>>
79419>>>>>>>    Procedure Set Author String sText
79421>>>>>>>        Set Value of oAuthor to sText
79422>>>>>>>    End_Procedure
79423>>>>>>>
79423>>>>>>>    Procedure Set Version String sVersion
79425>>>>>>>        Handle hoVersionInfo
79425>>>>>>>        Boolean bIncluded
79425>>>>>>>        Integer iMajor iMinor iRelease iBuild
79425>>>>>>>//        Date dCompileDate
79425>>>>>>>        String sCertInfo sCompileDateAndTime
79425>>>>>>>
79425>>>>>>>        If (sVersion = "") Begin
79427>>>>>>>            // This automatically shows the program version of the program, if available.
79427>>>>>>>            // It will be displayed as the second item in the edit object.
79427>>>>>>>            If (ghoApplication <> 0) Begin
79429>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
79430>>>>>>>                If (hoVersionInfo <> 0) Begin
79432>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
79433>>>>>>>                    If (bIncluded) Begin
79435>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
79436>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
79437>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
79438>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
79439>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
79440>>>>>>>                    End
79440>>>>>>>>
79440>>>>>>>                End
79440>>>>>>>>
79440>>>>>>>            End
79440>>>>>>>>
79440>>>>>>>        End
79440>>>>>>>>
79440>>>>>>>
79440>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
79440>>>>>>>        Get psCompileDateAndTime of ghoApplication to sCompileDateAndTime
79441>>>>>>>        If (sCompileDateAndTime <> "") Begin
79443>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
79444>>>>>>>        End
79444>>>>>>>>
79444>>>>>>>//        Get GetCompileDate to dCompileDate
79444>>>>>>>//        If (sVersion <> "") Begin
79444>>>>>>>//            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
79444>>>>>>>//        End
79444>>>>>>>
79444>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
79445>>>>>>>        If (sCertInfo <> "-1") Begin
79447>>>>>>>            If (sCertInfo <> "") Begin
79449>>>>>>>                Send Add_LineLn sCertInfo
79450>>>>>>>            End
79450>>>>>>>>
79450>>>>>>>            Else Begin
79451>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
79452>>>>>>>            End
79452>>>>>>>>
79452>>>>>>>        End
79452>>>>>>>>
79452>>>>>>>    End_Procedure
79453>>>>>>>
79453>>>>>>>    Function IsDate String sDate Returns Boolean
79455>>>>>>>        Boolean bIsDate
79455>>>>>>>        String sGoodCharacters sChar
79455>>>>>>>        Integer iCount iLength
79455>>>>>>>
79455>>>>>>>        Move True to bIsDate
79456>>>>>>>        Move "0123456789-/" to sGoodCharacters
79457>>>>>>>        Move (Length(sDate)) to iLength
79458>>>>>>>        For iCount from 1 to iLength
79464>>>>>>>>
79464>>>>>>>            Move (Left(sDate, 1)) to sChar
79465>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
79466>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
79467>>>>>>>            If (bIsDate = False) Begin
79469>>>>>>>                Move iLength to iCount
79470>>>>>>>            End
79470>>>>>>>>
79470>>>>>>>        Loop
79471>>>>>>>>
79471>>>>>>>        Function_Return bIsDate
79472>>>>>>>    End_Function
79473>>>>>>>
79473>>>>>>>    Function GetCompileDate Returns Date
79475>>>>>>>        Date dCompileDate
79475>>>>>>>        String sAppFilename sProgram sData sCompileDate
79475>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
79475>>>>>>>        Boolean bIsValid   
79475>>>>>>>        
79475>>>>>>>        Move 0 to dCompileDate
79476>>>>>>>        // Get full path to the current running executable
79476>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
79477>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
79478>>>>>>>
79478>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
79478>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
79479>>>>>>>
79479>>>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
79481>>>>>>>        Move (Pos(sProgram, sData)) to iPos
79482>>>>>>>        If (iPos > 0) Begin
79484>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
79484>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
79485>>>>>>>
79485>>>>>>>            // If the current date format is non US, we need to temporary
79485>>>>>>>            // change the format and then move the string to the date variable.
79485>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
79488>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
79491>>>>>>>            Send Ignore_Error of Error_Object_Id 16 
79492>>>>>>>            If (Left(sCompileDate, 1) = "0") Begin
79494>>>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
79495>>>>>>>            End
79495>>>>>>>>
79495>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
79496>>>>>>>            Send Trap_Error of Error_Object_Id 16
79497>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79500>>>>>>>        End
79500>>>>>>>>
79500>>>>>>>        Else Begin
79501>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
79502>>>>>>>>
79502>>>>>>>        End
79502>>>>>>>>
79502>>>>>>>
79502>>>>>>>        Send Seq_Close_Channel iChannel
79503>>>>>>>
79503>>>>>>>        Function_Return dCompileDate
79504>>>>>>>    End_Function
79505>>>>>>>
79505>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
79505>>>>>>>    // (the passed program), has been finished
79505>>>>>>>    // The DOS box does also _not_ flash briefly.
79505>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
79507>>>>>>>        Handle hProcess
79507>>>>>>>        Integer iVoid
79507>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79507>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79507>>>>>>>
79507>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
79508>>>>>>>
79508>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
79509>>>>>>>        Move SW_SHOW                 to sInfo.nShow
79510>>>>>>>
79510>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
79511>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
79512>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
79512>>>>>>>        Move 0                       to sInfo.nShow
79513>>>>>>>
79513>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
79514>>>>>>>        Move sInfo.hProcess to hProcess
79515>>>>>>>        If (hProcess) Begin
79517>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
79518>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
79519>>>>>>>        End
79519>>>>>>>>
79519>>>>>>>    End_Procedure
79520>>>>>>>
79520>>>>>>>    Function AddFolderDelimiter String sPath Returns String
79522>>>>>>>        String sDirSep
79522>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79523>>>>>>>        Move (Trim(sPath)) to sPath
79524>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79526>>>>>>>            Move (sPath + sDirSep) to sPath
79527>>>>>>>        End
79527>>>>>>>>
79527>>>>>>>        Function_Return sPath
79528>>>>>>>    End_Function
79529>>>>>>>
79529>>>>>>>    // Returns an empty string if the current program is not digitally signed,
79529>>>>>>>    // or there is a problem with the certificate.
79529>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
79529>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
79529>>>>>>>    Function IsProgramDigitallySigned Returns String
79531>>>>>>>        Boolean bExists
79531>>>>>>>        String sPath sProgram sParams sRetval
79531>>>>>>>        Integer iCh
79531>>>>>>>
79531>>>>>>>        Move "" to sRetval
79532>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
79533>>>>>>>        Get AddFolderDelimiter sPath to sPath
79534>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
79535>>>>>>>        If (bExists = False) Begin
79537>>>>>>>            Function_Return "-1"
79538>>>>>>>        End
79538>>>>>>>>
79538>>>>>>>
79538>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
79539>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
79540>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
79541>>>>>>>        Move (sParams * String("| clip"))    to sParams
79542>>>>>>>        Get Seq_New_Channel to iCh
79543>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
79545>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
79548>>>>>>>        Close_Output channel iCh
79550>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
79550>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
79551>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
79553>>>>>>>            Readln channel iCh sRetval
79555>>>>>>>            Readln channel iCh sRetval
79557>>>>>>>            Readln channel iCh sRetval
79559>>>>>>>            Readln channel iCh sRetval
79561>>>>>>>        Close_Input channel iCh
79563>>>>>>>        Send Seq_Release_Channel iCh
79564>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
79566>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
79567>>>>>>>        End
79567>>>>>>>>
79567>>>>>>>        Else Begin
79568>>>>>>>            Move "" to sRetval
79569>>>>>>>        End
79569>>>>>>>>
79569>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
79569>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
79570>>>>>>>>
79570>>>>>>>        Function_Return sRetval
79571>>>>>>>    End_Function
79572>>>>>>>
79572>>>>>>>    Procedure Add_LineLn String sValue
79574>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
79575>>>>>>>    End_Procedure
79576>>>>>>>
79576>>>>>>>    Procedure Add_Line String sValue
79578>>>>>>>        Send Add_Line of oInfoList_Editor sValue
79579>>>>>>>    End_Procedure
79580>>>>>>>
79580>>>>>>>    Procedure Set Logo string sLogo
79582>>>>>>>        // Square bitmaps of 80x80 work best
79582>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
79583>>>>>>>    End_Procedure
79584>>>>>>>
79584>>>>>>>    Procedure Set LogoDF String sLogo
79586>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
79587>>>>>>>    End_Procedure
79588>>>>>>>
79588>>>>>>>    Procedure Show_Sysinfo
79590>>>>>>>        Send Popup_Modal of oSysinfoDialog
79591>>>>>>>    End_Procedure
79592>>>>>>>
79592>>>>>>>    Procedure Show_HomePage String sWebpage
79594>>>>>>>        Handle hWnd
79594>>>>>>>        Get Window_Handle to hWnd
79595>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
79596>>>>>>>    End_Procedure
79597>>>>>>>
79597>>>>>>>End_Class
79598>>>>>
79598>>>>>    Function piOrgErrorHandlerID Returns Integer
79600>>>>>    End_Function
79601>>>>>
79601>>>>>Class cBaseDbUpdateFuncLib is a cObject
79602>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
79603>>>>>>
79603>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
79605>>>>>>    Integer iStart iEnd
79605>>>>>>    String sRetval
79605>>>>>>
79605>>>>>>    Move (Trim(sConnect)) to sConnect
79606>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
79607>>>>>>    If (iStart = 0) Begin
79609>>>>>>        Function_Return ""
79610>>>>>>    End
79610>>>>>>>
79610>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
79611>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
79612>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
79614>>>>>>        Move (Pos(",", sRetval))          to iEnd
79615>>>>>>    End
79615>>>>>>>
79615>>>>>>    Else Begin
79616>>>>>>        Move (Pos(";", sRetval))          to iEnd
79617>>>>>>    End
79617>>>>>>>
79617>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
79619>>>>>>        Move (Pos(",", sRetval))          to iEnd
79620>>>>>>        Decrement iEnd
79621>>>>>>    End
79621>>>>>>>
79621>>>>>>    If (iEnd <> 0) Begin
79623>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
79624>>>>>>    End
79624>>>>>>>
79624>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
79625>>>>>>
79625>>>>>>    Function_Return (Trim(sRetval))
79626>>>>>>End_Function
79627>>>>>>
79627>>>>>>
79627>>>>>    
79627>>>>>    Procedure Construct_Object
79629>>>>>        Handle ho
79629>>>>>        Forward Send Construct_Object
79631>>>>>        Move Self to ghoDbUpdateFunctionLibrary
79632>>>>>        
79632>>>>>        Send CreateDbUpdateLibraryProperties
79633>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
79634>>>>>
79634>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
79634>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
79634>>>>>        // etc settings.
79634>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79636>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
79637>>>>>            Set phoSQLConnectionHandler to ho
79638>>>>>        End
79638>>>>>>
79638>>>>>
79638>>>>>    End_Procedure
79639>>>>>
79639>>>>>    Procedure End_Construct_Object
79641>>>>>        Forward Send End_Construct_Object
79643>>>>>
79643>>>>>    End_Procedure
79644>>>>>
79644>>>>>    // Latin1_General_CI_AS = General Insensitive collation
79644>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
79644>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
79644>>>>>    // Good read about which collation to select:
79644>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
79644>>>>>    Procedure Set psCollation String sCollation
79646>>>>>        Set private.psCollation to sCollation
79647>>>>>        If (ghoDbUpdateHandler > 0) Begin
79649>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
79650>>>>>        End
79650>>>>>>
79650>>>>>    End_Procedure
79651>>>>>
79651>>>>>    Function psCollation Returns String
79653>>>>>        String sCollation
79653>>>>>        If (ghoDbUpdateHandler > 0) Begin
79655>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
79656>>>>>        End   
79656>>>>>>
79656>>>>>        Else Begin
79657>>>>>            Get private.psCollation to sCollation
79658>>>>>        End
79658>>>>>>
79658>>>>>        Function_Return sCollation
79659>>>>>    End_Function
79660>>>>>
79660>>>>>    // Array sorting helper functions:
79660>>>>>    Function __UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
79662>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
79664>>>>>            Function_Return (EQ)
79665>>>>>        End
79665>>>>>>
79665>>>>>
79665>>>>>        Function_Return (GT)
79666>>>>>    End_Function
79667>>>>>
79667>>>>>    Function __SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
79669>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
79672>>>>>
79672>>>>>        Function_Return (GT)
79673>>>>>    End_Function
79674>>>>>
79674>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
79674>>>>>    // Note that it first removes any driver prefixes in the rootname.
79674>>>>>    Function _ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
79676>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
79676>>>>>        Handle hTable
79676>>>>>        Boolean bIsSame
79676>>>>>
79676>>>>>        Move APITableInfo.iTableNumber      to hTable
79677>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
79678>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
79681>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
79682>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
79685>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
79688>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
79689>>>>>
79689>>>>>        If (bCompareFilelistUppercase = True) Begin
79691>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
79692>>>>>        End
79692>>>>>>
79692>>>>>        Else Begin
79693>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
79694>>>>>        End
79694>>>>>>
79694>>>>>
79694>>>>>        Function_Return bIsSame
79695>>>>>    End_Function
79696>>>>>
79696>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
79698>>>>>        Integer iRetval
79698>>>>>        Move 1 to iRetval
79699>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
79701>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
79702>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
79703>>>>>        End
79703>>>>>>
79703>>>>>        Function_Return (iRetval = 0)
79704>>>>>    End_Function
79705>>>>>
79705>>>>>    Function _AddFolderDelimiter String sPath Returns String
79707>>>>>        String sDirSep
79707>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79708>>>>>        Move (Trim(sPath)) to sPath
79709>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79711>>>>>            Move (sPath + sDirSep) to sPath
79712>>>>>        End
79712>>>>>>
79712>>>>>        Function_Return sPath
79713>>>>>    End_Function
79714>>>>>
79714>>>>>    Procedure _SqlColumnInfo Handle hoStmt
79716>>>>>        Integer i iCols iItem
79716>>>>>        tSqlColumnNew[] aQueryColumns
79716>>>>>        tSqlColumnNew[] aQueryColumns
79717>>>>>
79717>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
79718>>>>>        For i from 1 to iCols
79724>>>>>>
79724>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
79725>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
79726>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
79727>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
79728>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
79729>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
79730>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
79731>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
79732>>>>>        Loop
79733>>>>>>
79733>>>>>        Set piColumns to iCols
79734>>>>>        Set paQueryColumns to aQueryColumns
79735>>>>>    End_Procedure
79736>>>>>
79736>>>>>    // *** Property Messages ***
79736>>>>>    //
79736>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
79736>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
79736>>>>>    //
79736>>>>>    Function pSQLConnection Returns tSQLConnection
79738>>>>>        tSQLConnection SQLConnection
79738>>>>>        tSQLConnection SQLConnection
79738>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79740>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
79740>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79741>>>>>>
79741>>>>>            Function_Return
79742>>>>>        End
79742>>>>>>
79742>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
79743>>>>>        Function_Return SQLConnection
79744>>>>>    End_Function
79745>>>>>
79745>>>>>    // * Dummy function for the Studio's Code Explorer *
79745>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
79747>>>>>        Function_Return False
79748>>>>>    End_Function
79749>>>>>
79749>>>>>    Procedure Set psServer String sValue
79751>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79753>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
79753>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79754>>>>>>
79754>>>>>            Procedure_Return
79755>>>>>        End
79755>>>>>>
79755>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
79756>>>>>    End_Procedure
79757>>>>>
79757>>>>>    Function psServer Returns String
79759>>>>>        String sValue
79759>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79761>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79762>>>>>>
79762>>>>>            Function_Return
79763>>>>>        End
79763>>>>>>
79763>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
79764>>>>>        Function_Return sValue
79765>>>>>    End_Function
79766>>>>>
79766>>>>>    Procedure Set psDatabase String sValue
79768>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79770>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79771>>>>>>
79771>>>>>            Procedure_Return
79772>>>>>        End
79772>>>>>>
79772>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
79773>>>>>    End_Procedure
79774>>>>>
79774>>>>>    Function psDatabase Returns String
79776>>>>>        String sValue
79776>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79778>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79779>>>>>>
79779>>>>>            Function_Return
79780>>>>>        End
79780>>>>>>
79780>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
79781>>>>>        Function_Return sValue
79782>>>>>    End_Function
79783>>>>>
79783>>>>>    Procedure Set psUserID String sValue
79785>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79787>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79788>>>>>>
79788>>>>>            Procedure_Return
79789>>>>>        End
79789>>>>>>
79789>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
79790>>>>>    End_Procedure
79791>>>>>
79791>>>>>    Function psUserID Returns String
79793>>>>>        String sValue
79793>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79795>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79796>>>>>>
79796>>>>>            Function_Return
79797>>>>>        End
79797>>>>>>
79797>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
79798>>>>>        Function_Return sValue
79799>>>>>    End_Function
79800>>>>>
79800>>>>>    Procedure Set psPassword String sValue
79802>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79804>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79805>>>>>>
79805>>>>>            Procedure_Return
79806>>>>>        End
79806>>>>>>
79806>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
79807>>>>>    End_Procedure
79808>>>>>
79808>>>>>    Function psPassword Returns String
79810>>>>>        String sValue
79810>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79812>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79813>>>>>>
79813>>>>>            Function_Return
79814>>>>>        End
79814>>>>>>
79814>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
79815>>>>>        Function_Return sValue
79816>>>>>    End_Function
79817>>>>>
79817>>>>>    Procedure Set pbTrusted Boolean bValue
79819>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79821>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79822>>>>>>
79822>>>>>            Procedure_Return
79823>>>>>        End
79823>>>>>>
79823>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
79824>>>>>    End_Procedure
79825>>>>>
79825>>>>>    Function pbTrusted Returns Boolean
79827>>>>>        Boolean bValue
79827>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79829>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79830>>>>>>
79830>>>>>            Function_Return
79831>>>>>        End
79831>>>>>>
79831>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
79832>>>>>        Function_Return bValue
79833>>>>>    End_Function
79834>>>>>
79834>>>>>    Procedure Set pbSilentLogin Boolean bValue
79836>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79838>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79839>>>>>>
79839>>>>>            Procedure_Return
79840>>>>>        End
79840>>>>>>
79840>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
79841>>>>>    End_Procedure
79842>>>>>
79842>>>>>    Function pbSilentLogin Returns Boolean
79844>>>>>        Boolean bValue
79844>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79846>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79847>>>>>>
79847>>>>>            Function_Return
79848>>>>>        End
79848>>>>>>
79848>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
79849>>>>>        Function_Return bValue
79850>>>>>    End_Function
79851>>>>>
79851>>>>>    Procedure Set psConnectionID String sValue
79853>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79855>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79856>>>>>>
79856>>>>>            Procedure_Return
79857>>>>>        End
79857>>>>>>
79857>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
79858>>>>>    End_Procedure
79859>>>>>
79859>>>>>    Function psConnectionID Returns String
79861>>>>>        String sValue
79861>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79863>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79864>>>>>>
79864>>>>>            Function_Return
79865>>>>>        End
79865>>>>>>
79865>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
79866>>>>>        Function_Return sValue
79867>>>>>    End_Function
79868>>>>>
79868>>>>>    Procedure Set psConnectionString String sValue
79870>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79872>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79873>>>>>>
79873>>>>>            Procedure_Return
79874>>>>>        End
79874>>>>>>
79874>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
79875>>>>>    End_Procedure
79876>>>>>
79876>>>>>    Function psConnectionString Returns String
79878>>>>>        String sValue
79878>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79880>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79881>>>>>>
79881>>>>>            Function_Return
79882>>>>>        End
79882>>>>>>
79882>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
79883>>>>>        Function_Return sValue
79884>>>>>    End_Function
79885>>>>>
79885>>>>>    // The normal connection string looks something like this;
79885>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
79885>>>>>    // ...and the full connection string looks like this;
79885>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
79885>>>>>    Function psFullConnectionString Returns String
79887>>>>>        String sConnectionID sConnectionString
79887>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79889>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79890>>>>>>
79890>>>>>            Function_Return
79891>>>>>        End
79891>>>>>>
79891>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
79892>>>>>        Move (Trim(sConnectionID)) to sConnectionID
79893>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
79894>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
79895>>>>>    End_Function
79896>>>>>
79896>>>>>    Function piConnectionOptions Returns Integer
79898>>>>>        Integer iValue
79898>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79900>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79901>>>>>>
79901>>>>>            Function_Return
79902>>>>>        End
79902>>>>>>
79902>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
79903>>>>>        Function_Return iValue
79904>>>>>    End_Function
79905>>>>>
79905>>>>>    Procedure Set psSchema String sValue
79907>>>>>        tSQLConnection SQLConnection
79907>>>>>        tSQLConnection SQLConnection
79907>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79909>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79910>>>>>>
79910>>>>>            Procedure_Return
79911>>>>>        End
79911>>>>>>
79911>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
79912>>>>>    End_Procedure
79913>>>>>
79913>>>>>    Function psSchema Returns String
79915>>>>>        String sRetval
79915>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79917>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79918>>>>>>
79918>>>>>            Function_Return
79919>>>>>        End
79919>>>>>>
79919>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
79920>>>>>        Function_Return sRetval
79921>>>>>    End_Function
79922>>>>>
79922>>>>>    Procedure Set psBaseTableSpace String sValue
79924>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79926>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79927>>>>>>
79927>>>>>            Procedure_Return
79928>>>>>        End
79928>>>>>>
79928>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
79929>>>>>    End_Procedure
79930>>>>>
79930>>>>>    Function psBaseTableSpace Returns String
79932>>>>>        String sRetval
79932>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79934>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79935>>>>>>
79935>>>>>            Function_Return
79936>>>>>        End
79936>>>>>>
79936>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
79937>>>>>        Function_Return sRetval
79938>>>>>    End_Function
79939>>>>>
79939>>>>>    Procedure Set psLongTableSpace String sValue
79941>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79943>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79944>>>>>>
79944>>>>>            Procedure_Return
79945>>>>>        End
79945>>>>>>
79945>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
79946>>>>>    End_Procedure
79947>>>>>
79947>>>>>    Function psLongTableSpace Returns String
79949>>>>>        String sRetval
79949>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79951>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79952>>>>>>
79952>>>>>            Function_Return
79953>>>>>        End
79953>>>>>>
79953>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
79954>>>>>        Function_Return sRetval
79955>>>>>    End_Function
79956>>>>>
79956>>>>>    Procedure Set psIndexTableSpace String sValue
79958>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79960>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79961>>>>>>
79961>>>>>            Procedure_Return
79962>>>>>        End
79962>>>>>>
79962>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
79963>>>>>    End_Procedure
79964>>>>>
79964>>>>>    Function psIndexTableSpace Returns String
79966>>>>>        String sRetval
79966>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79968>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79969>>>>>>
79969>>>>>            Function_Return
79970>>>>>        End
79970>>>>>>
79970>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
79971>>>>>        Function_Return sRetval
79972>>>>>    End_Function
79973>>>>>
79973>>>>>    Procedure Set pbUseConnectionID Boolean bState
79975>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79977>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79978>>>>>>
79978>>>>>            Procedure_Return
79979>>>>>        End
79979>>>>>>
79979>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
79980>>>>>    End_Procedure
79981>>>>>
79981>>>>>    Function pbUseConnectionID Returns Boolean
79983>>>>>        Boolean bState
79983>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79985>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79986>>>>>>
79986>>>>>            Function_Return
79987>>>>>        End
79987>>>>>>
79987>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
79988>>>>>        Function_Return bState
79989>>>>>    End_Function
79990>>>>>
79990>>>>>    Procedure Set pbToANSI Boolean bState
79992>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79994>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79995>>>>>>
79995>>>>>            Procedure_Return
79996>>>>>        End
79996>>>>>>
79996>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
79997>>>>>    End_Procedure
79998>>>>>
79998>>>>>    Function pbToANSI Returns Boolean
80000>>>>>        Boolean bState
80000>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80002>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80003>>>>>>
80003>>>>>            Function_Return
80004>>>>>        End
80004>>>>>>
80004>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
80005>>>>>        Function_Return bState
80006>>>>>    End_Function
80007>>>>>
80007>>>>>    Procedure Set pbRecnum Boolean bState
80009>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80011>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80012>>>>>>
80012>>>>>            Procedure_Return
80013>>>>>        End
80013>>>>>>
80013>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
80014>>>>>    End_Procedure
80015>>>>>
80015>>>>>    Function pbRecnum Returns Boolean
80017>>>>>        Boolean bState
80017>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80019>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80020>>>>>>
80020>>>>>            Function_Return
80021>>>>>        End
80021>>>>>>
80021>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
80022>>>>>        Function_Return bState
80023>>>>>    End_Function
80024>>>>>
80024>>>>>    Procedure Set pbCopyData Boolean bState
80026>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80028>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80029>>>>>>
80029>>>>>            Procedure_Return
80030>>>>>        End
80030>>>>>>
80030>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
80031>>>>>    End_Procedure
80032>>>>>
80032>>>>>    Function pbCopyData Returns Boolean
80034>>>>>        Boolean bState
80034>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80036>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80037>>>>>>
80037>>>>>            Function_Return
80038>>>>>        End
80038>>>>>>
80038>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
80039>>>>>        Function_Return bState
80040>>>>>    End_Function
80041>>>>>
80041>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
80043>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80045>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80046>>>>>>
80046>>>>>            Procedure_Return
80047>>>>>        End
80047>>>>>>
80047>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80048>>>>>    End_Procedure
80049>>>>>
80049>>>>>    Function pbApiTableUpdateAuto Returns Boolean
80051>>>>>        Boolean bState
80051>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80053>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80054>>>>>>
80054>>>>>            Function_Return
80055>>>>>        End
80055>>>>>>
80055>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80056>>>>>        Function_Return bState
80057>>>>>    End_Function
80058>>>>>
80058>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
80060>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80062>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80063>>>>>>
80063>>>>>            Procedure_Return
80064>>>>>        End
80064>>>>>>
80064>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80065>>>>>    End_Procedure
80066>>>>>
80066>>>>>    Function pbCompareDate_DateTime Returns Boolean
80068>>>>>        Boolean bState
80068>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80070>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80071>>>>>>
80071>>>>>            Function_Return
80072>>>>>        End
80072>>>>>>
80072>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80073>>>>>        Function_Return bState
80074>>>>>    End_Function
80075>>>>>
80075>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
80077>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80079>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80080>>>>>>
80080>>>>>            Procedure_Return
80081>>>>>        End
80081>>>>>>
80081>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80082>>>>>    End_Procedure
80083>>>>>
80083>>>>>    Function pbCompareIndexAscending Returns Boolean
80085>>>>>        Boolean bState
80085>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80087>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80088>>>>>>
80088>>>>>            Function_Return
80089>>>>>        End
80089>>>>>>
80089>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80090>>>>>        Function_Return bState
80091>>>>>    End_Function
80092>>>>>
80092>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
80094>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80096>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80097>>>>>>
80097>>>>>            Procedure_Return
80098>>>>>        End
80098>>>>>>
80098>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80099>>>>>    End_Procedure
80100>>>>>
80100>>>>>    Function pbCompareIndexUppercase Returns Boolean
80102>>>>>        Boolean bState
80102>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80104>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80105>>>>>>
80105>>>>>            Function_Return
80106>>>>>        End
80106>>>>>>
80106>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80107>>>>>        Function_Return bState
80108>>>>>    End_Function
80109>>>>>
80109>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
80111>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80113>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80114>>>>>>
80114>>>>>            Procedure_Return
80115>>>>>        End
80115>>>>>>
80115>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
80116>>>>>    End_Procedure
80117>>>>>
80117>>>>>    Function psDriverDefaultValueASCII Returns String
80119>>>>>        String sRetval
80119>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80121>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80122>>>>>>
80122>>>>>            Function_Return
80123>>>>>        End
80123>>>>>>
80123>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
80124>>>>>        Function_Return sRetval
80125>>>>>    End_Function
80126>>>>>
80126>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
80128>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80130>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80131>>>>>>
80131>>>>>            Procedure_Return
80132>>>>>        End
80132>>>>>>
80132>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
80133>>>>>    End_Procedure
80134>>>>>
80134>>>>>    Function psDriverDefaultValueBinary Returns String
80136>>>>>        String sRetval
80136>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80138>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80139>>>>>>
80139>>>>>            Function_Return
80140>>>>>        End
80140>>>>>>
80140>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
80141>>>>>        Function_Return sRetval
80142>>>>>    End_Function
80143>>>>>
80143>>>>>    Procedure Set psDriverDefaultValueDate String sValue
80145>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80147>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80148>>>>>>
80148>>>>>            Procedure_Return
80149>>>>>        End
80149>>>>>>
80149>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
80150>>>>>    End_Procedure
80151>>>>>
80151>>>>>    Function psDriverDefaultValueDate Returns String
80153>>>>>        String sRetval
80153>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80155>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80156>>>>>>
80156>>>>>            Function_Return
80157>>>>>        End
80157>>>>>>
80157>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
80158>>>>>        Function_Return sRetval
80159>>>>>    End_Function
80160>>>>>
80160>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
80162>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80164>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80165>>>>>>
80165>>>>>            Procedure_Return
80166>>>>>        End
80166>>>>>>
80166>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
80167>>>>>    End_Procedure
80168>>>>>
80168>>>>>    Function psDriverDefaultValueDateTime Returns String
80170>>>>>        String sRetval
80170>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80172>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80173>>>>>>
80173>>>>>            Function_Return
80174>>>>>        End
80174>>>>>>
80174>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
80175>>>>>        Function_Return sRetval
80176>>>>>    End_Function
80177>>>>>
80177>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
80179>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80181>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80182>>>>>>
80182>>>>>            Procedure_Return
80183>>>>>        End
80183>>>>>>
80183>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
80184>>>>>    End_Procedure
80185>>>>>
80185>>>>>    Function psDriverDefaultValueNumeric Returns String
80187>>>>>        String sRetval
80187>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80189>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80190>>>>>>
80190>>>>>            Function_Return
80191>>>>>        End
80191>>>>>>
80191>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
80192>>>>>        Function_Return sRetval
80193>>>>>    End_Function
80194>>>>>
80194>>>>>    Procedure Set psDriverDefaultValueText String sValue
80196>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80198>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80199>>>>>>
80199>>>>>            Procedure_Return
80200>>>>>        End
80200>>>>>>
80200>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
80201>>>>>    End_Procedure
80202>>>>>
80202>>>>>    Function psDriverDefaultValueText Returns String
80204>>>>>        String sRetval
80204>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80206>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80207>>>>>>
80207>>>>>            Function_Return
80208>>>>>        End
80208>>>>>>
80208>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
80209>>>>>        Function_Return sRetval
80210>>>>>    End_Function
80211>>>>>
80211>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
80213>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80215>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80216>>>>>>
80216>>>>>            Procedure_Return
80217>>>>>        End
80217>>>>>>
80217>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80218>>>>>    End_Procedure
80219>>>>>
80219>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
80221>>>>>        Boolean bState
80221>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80223>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80224>>>>>>
80224>>>>>            Function_Return
80225>>>>>        End
80225>>>>>>
80225>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80226>>>>>        Function_Return bState
80227>>>>>    End_Function
80228>>>>>
80228>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
80230>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80232>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80233>>>>>>
80233>>>>>            Procedure_Return
80234>>>>>        End
80234>>>>>>
80234>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80235>>>>>    End_Procedure
80236>>>>>
80236>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
80238>>>>>        Boolean bState
80238>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80240>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80241>>>>>>
80241>>>>>            Function_Return
80242>>>>>        End
80242>>>>>>
80242>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80243>>>>>        Function_Return bState
80244>>>>>    End_Function
80245>>>>>
80245>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
80247>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80249>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80250>>>>>>
80250>>>>>            Procedure_Return
80251>>>>>        End
80251>>>>>>
80251>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80252>>>>>    End_Procedure
80253>>>>>
80253>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
80255>>>>>        Boolean bState
80255>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80257>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80258>>>>>>
80258>>>>>            Function_Return
80259>>>>>        End
80259>>>>>>
80259>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80260>>>>>        Function_Return bState
80261>>>>>    End_Function
80262>>>>>
80262>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
80264>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80266>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80267>>>>>>
80267>>>>>            Procedure_Return
80268>>>>>        End
80268>>>>>>
80268>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80269>>>>>    End_Procedure
80270>>>>>
80270>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
80272>>>>>        Boolean bState
80272>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80274>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80275>>>>>>
80275>>>>>            Function_Return
80276>>>>>        End
80276>>>>>>
80276>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80277>>>>>        Function_Return bState
80278>>>>>    End_Function
80279>>>>>
80279>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
80281>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80283>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80284>>>>>>
80284>>>>>            Procedure_Return
80285>>>>>        End
80285>>>>>>
80285>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80286>>>>>    End_Procedure
80287>>>>>
80287>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
80289>>>>>        Boolean bState
80289>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80291>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80292>>>>>>
80292>>>>>            Function_Return
80293>>>>>        End
80293>>>>>>
80293>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80294>>>>>        Function_Return bState
80295>>>>>    End_Function
80296>>>>>
80296>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
80298>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80300>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80301>>>>>>
80301>>>>>            Procedure_Return
80302>>>>>        End
80302>>>>>>
80302>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80303>>>>>    End_Procedure
80304>>>>>
80304>>>>>    Function pbDriverDefaultNullableText Returns Boolean
80306>>>>>        Boolean bState
80306>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80308>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80309>>>>>>
80309>>>>>            Function_Return
80310>>>>>        End
80310>>>>>>
80310>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80311>>>>>        Function_Return bState
80312>>>>>    End_Function
80313>>>>>
80313>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
80313>>>>>    //       the psDriverID *must* be the first property that gets changed!
80313>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
80313>>>>>    //       for a connection string has the wrong format for that driver.
80313>>>>>    Procedure Set psDriverID String sValue
80315>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80316>>>>>        Delegate Set psDriverID to sValue
80318>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80319>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
80320>>>>>    End_Procedure
80321>>>>>
80321>>>>>    Function psDriverID Returns String
80323>>>>>        String sDriverID
80323>>>>>
80323>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80324>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
80324>>>>>        Delegate Get psDriverID to sDriverID
80326>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80327>>>>>        Move False to Err
80328>>>>>
80328>>>>>        // ...and in case it didn't use property of this class. Then the library is
80328>>>>>        // probably used as "utilites" from a special made program and
80328>>>>>        // the ghoSQLConnectionHandler must have been setup
80328>>>>>        If (sDriverID = "") Begin
80330>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
80331>>>>>        End
80331>>>>>>
80331>>>>>        Function_Return sDriverID
80332>>>>>    End_Function
80333>>>>>
80333>>>>>    Procedure Set piDbType Integer iValue
80335>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80336>>>>>        Delegate Set piDbType to iValue
80338>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80339>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
80340>>>>>    End_Procedure
80341>>>>>
80341>>>>>    Function piDbType Returns Integer
80343>>>>>        Integer iRetval
80343>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
80344>>>>>        Function_Return iRetval
80345>>>>>    End_Function
80346>>>>>
80346>>>>>    // Returns the index for the passed sTableName
80346>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
80346>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
80348>>>>>        Integer iIndex iSize iCount
80348>>>>>        String[] sTablesArray
80349>>>>>        String sDatabase sSchema sVal sConnectionString
80349>>>>>
80349>>>>>        Move -1 to iIndex
80350>>>>>        Get psConnectionString to sConnectionString
80351>>>>>        Get psDatabase to sDatabase
80352>>>>>        Get psSchema   to sSchema
80353>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
80354>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
80355>>>>>        Decrement iSize
80356>>>>>        For iCount from 0 to iSize
80362>>>>>>
80362>>>>>            Move sTablesArray[iCount] to sVal
80363>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
80365>>>>>                Move iCount to iIndex // We found it!
80366>>>>>                Move iSize to iCount  // End the loop
80367>>>>>            End
80367>>>>>>
80367>>>>>        Loop
80368>>>>>>
80368>>>>>
80368>>>>>        Function_Return iIndex
80369>>>>>    End_Function
80370>>>>>
80370>>>>>    // Returns all schemas as a string array for the passed driver id.
80370>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
80372>>>>>        String[] sReturnArray
80373>>>>>        Boolean bOK
80373>>>>>
80373>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80374>>>>>        If (bOK = False) Begin
80376>>>>>            Function_Return sReturnArray
80377>>>>>        End
80377>>>>>>
80377>>>>>
80377>>>>>        Case Begin
80377>>>>>            Case (sDriverID = DB2_DRV_ID)
80379>>>>>                Get _SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
80380>>>>>                Case Break
80381>>>>>
80381>>>>>            Case Else
80381>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
80382>>>>>>
80382>>>>>                Case Break
80383>>>>>        Case End
80383>>>>>
80383>>>>>        Function_Return sReturnArray
80384>>>>>    End_Function
80385>>>>>
80385>>>>>    // Returns a string array with all tables for the current database.
80385>>>>>    Function _SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
80387>>>>>        String[] sReturnArray sArray
80389>>>>>        String sConnectionString sSelect
80389>>>>>        Integer iSize iCount iDbType
80389>>>>>        Boolean bOK
80389>>>>>
80389>>>>>        If (sDriverID = DATAFLEX_ID) Begin
80391>>>>>            Function_Return sArray
80392>>>>>        End
80392>>>>>>
80392>>>>>
80392>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80393>>>>>        If (bOK = False) Begin
80395>>>>>            Function_Return sReturnArray
80396>>>>>        End
80396>>>>>>
80396>>>>>        If (sSchema = "") Begin
80398>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
80399>>>>>        End
80399>>>>>>
80399>>>>>
80399>>>>>        Get psConnectionString to sConnectionString
80400>>>>>
80400>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80400>>>>>        // the dbType.
80400>>>>>        Get piDbType to iDbType
80401>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
80403>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
80405>>>>>                Move MSSQLDRV_ID to sDriverID
80406>>>>>            End
80406>>>>>>
80406>>>>>            If (iDbType = EN_DbTypeDB2) Begin
80408>>>>>                Move DB2_DRV_ID to sDriverID
80409>>>>>            End
80409>>>>>>
80409>>>>>            If (iDbType = EN_DbTypePostgre) Begin
80411>>>>>                Move ODBC_DRV_ID to sDriverID
80412>>>>>            End
80412>>>>>>
80412>>>>>        End
80412>>>>>>
80412>>>>>
80412>>>>>        Case Begin
80412>>>>>            Case (sDriverID = MSSQLDRV_ID)
80414>>>>>                Get _SqlTableArrayDAW to sReturnArray
80415>>>>>                Case Break
80416>>>>>
80416>>>>>            Case (sDriverID = DB2_DRV_ID)
80419>>>>>                Get _SqlTableArrayDAW to sReturnArray
80420>>>>>                Case Break
80421>>>>>
80421>>>>>            Case (sDriverID = ODBC_DRV_ID)
80424>>>>>                Get _SqlTableArrayDAW to sReturnArray
80425>>>>>                Case Break
80426>>>>>
80426>>>>>            Case Else
80426>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTables function."
80427>>>>>>
80427>>>>>                Case Break
80428>>>>>        Case End
80428>>>>>
80428>>>>>        Function_Return sReturnArray
80429>>>>>    End_Function
80430>>>>>
80430>>>>>    // Returns all table spaces as a string array for the passed driver id.
80430>>>>>    Function _SqlUtilEnumerateTablespaces String sDriverID Returns String[]
80432>>>>>        String[] sReturnArray
80433>>>>>        Boolean bOK
80433>>>>>
80433>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80434>>>>>        If (bOK = False) Begin
80436>>>>>            Function_Return sReturnArray
80437>>>>>        End
80437>>>>>>
80437>>>>>
80437>>>>>        Case Begin
80437>>>>>            Case (sDriverID = DB2_DRV_ID)
80439>>>>>                Get _SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
80440>>>>>                Case Break
80441>>>>>
80441>>>>>            Case Else
80441>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTablespaces function."
80442>>>>>>
80442>>>>>                Case Break
80443>>>>>        Case End
80443>>>>>
80443>>>>>        Function_Return sReturnArray
80444>>>>>    End_Function
80445>>>>>
80445>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
80445>>>>>    Function _SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
80447>>>>>        String[] sReturnArray
80448>>>>>        String sConnectionString sSelect sSchema
80448>>>>>        Boolean bOK
80448>>>>>        Integer iDbType
80448>>>>>
80448>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80449>>>>>        If (bOK = False) Begin
80451>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80452>>>>>>
80452>>>>>            Function_Return sReturnArray
80453>>>>>        End
80453>>>>>>
80453>>>>>
80453>>>>>        Get psConnectionString to sConnectionString
80454>>>>>        Get psSchema to sSchema
80455>>>>>
80455>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80455>>>>>        // the dbType.
80455>>>>>        Get piDbType to iDbType
80456>>>>>
80456>>>>>        Case Begin
80456>>>>>            Case (sDriverID = ODBC_DRV_ID)
80458>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
80460>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
80461>>>>>                End
80461>>>>>>
80461>>>>>                If (iDbType = EN_DbTypePostgre) Begin
80463>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
80464>>>>>                End
80464>>>>>>
80464>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
80466>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80467>>>>>                End
80467>>>>>>
80467>>>>>
80467>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80468>>>>>                Case Break
80469>>>>>
80469>>>>>            Case (sDriverID = MSSQLDRV_ID)
80472>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80473>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80474>>>>>                Case Break
80475>>>>>
80475>>>>>            Case (sDriverID = DB2_DRV_ID)
80478>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
80479>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80480>>>>>                Case Break
80481>>>>>
80481>>>>>            Case Else
80481>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateColumns function."
80482>>>>>>
80482>>>>>                Case Break
80483>>>>>        Case End
80483>>>>>
80483>>>>>        Function_Return sReturnArray
80484>>>>>    End_Function
80485>>>>>
80485>>>>>
80485>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
80485>>>>>    Function _SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
80487>>>>>        String[] sReturnArray sReturnArray2
80489>>>>>        String sConnectionString sSelect sSchema
80489>>>>>        Boolean bOK
80489>>>>>        Integer iCount iSize
80489>>>>>
80489>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80490>>>>>        If (bOK = False) Begin
80492>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80493>>>>>>
80493>>>>>            Function_Return sReturnArray
80494>>>>>        End
80494>>>>>>
80494>>>>>
80494>>>>>        Get psConnectionString to sConnectionString
80495>>>>>        Get psSchema to sSchema
80496>>>>>
80496>>>>>        Case Begin
80496>>>>>            Case (sDriverID = MSSQLDRV_ID)
80498>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
80499>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80500>>>>>                Case Break
80501>>>>>
80501>>>>>            Case (sDriverID = DB2_DRV_ID)
80504>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80505>>>>>>
80505>>>>>//                Move () to sSelect
80505>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80505>>>>>                Case Break
80506>>>>>
80506>>>>>            Case Else
80506>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateIndexes function."
80507>>>>>>
80507>>>>>                Case Break
80508>>>>>        Case End
80508>>>>>
80508>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
80509>>>>>        Decrement iSize
80510>>>>>        For iCount from 0 to iSize
80516>>>>>>
80516>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
80518>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
80519>>>>>            End
80519>>>>>>
80519>>>>>        Loop
80520>>>>>>
80520>>>>>
80520>>>>>        Function_Return sReturnArray2
80521>>>>>    End_Function
80522>>>>>
80522>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
80522>>>>>    // The format of the array is "TableName.FieldName"
80522>>>>>    Function _SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
80524>>>>>        String[] sFileNameArray sFieldNameArray
80526>>>>>        tSQLRelation[] sRelationsArray
80526>>>>>        tSQLRelation[] sRelationsArray
80527>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
80527>>>>>        Boolean bOK
80527>>>>>        Integer iCount iSize iLength
80527>>>>>
80527>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80528>>>>>        If (bOK = False) Begin
80530>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80531>>>>>>
80531>>>>>            Function_Return sRelationsArray
80532>>>>>        End
80532>>>>>>
80532>>>>>
80532>>>>>        Get psConnectionString to sConnectionString
80533>>>>>        Get psSchema to sSchema
80534>>>>>
80534>>>>>        Case Begin
80534>>>>>            Case (sDriverID = MSSQLDRV_ID)
80536>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
80537>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
80538>>>>>                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80539>>>>>                Case Break
80540>>>>>
80540>>>>>            Case (sDriverID = DB2_DRV_ID)
80543>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80544>>>>>>
80544>>>>>//                Move () to sSelect
80544>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80544>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80544>>>>>                Case Break
80545>>>>>
80545>>>>>            Case Else
80545>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the _SqlUtilEnumerateRelations function."
80546>>>>>>
80546>>>>>                Case Break
80547>>>>>        Case End
80547>>>>>
80547>>>>>        Move (Length(sTableName)) to iLength
80548>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
80549>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
80550>>>>>        Decrement iSize
80551>>>>>        For iCount from 0 to iSize
80557>>>>>>
80557>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
80559>>>>>                Move sFileNameArray[iCount]         to sFileName
80560>>>>>                Move sFieldNameArray[iCount]        to sFieldName
80561>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
80562>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
80563>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
80564>>>>>            End
80564>>>>>>
80564>>>>>        Loop
80565>>>>>>
80565>>>>>
80565>>>>>        Function_Return sRelationsArray
80566>>>>>    End_Function
80567>>>>>
80567>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
80569>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80569>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80570>>>>>        String[] sUsers sPrograms
80572>>>>>        String sSelect
80572>>>>>        Integer iSize iCount
80572>>>>>
80572>>>>>        Case Begin
80572>>>>>            Case (sDriverID = MSSQLDRV_ID)
80574>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
80575>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sUsers
80576>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sPrograms
80577>>>>>                Case Break
80578>>>>>            Case Else
80578>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
80579>>>>>>
80579>>>>>        Case End
80579>>>>>
80579>>>>>        Move (SizeOfArray(sUsers)) to iSize
80580>>>>>        Decrement iSize
80581>>>>>        For iCount from 0 to iSize
80587>>>>>>
80587>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
80588>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
80589>>>>>        Loop
80590>>>>>>
80590>>>>>
80590>>>>>        Function_Return SQLLoggedInUser
80591>>>>>    End_Function
80592>>>>>
80592>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
80592>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
80592>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
80594>>>>>        String[] sFilesData
80595>>>>>        Boolean bExists
80595>>>>>        Integer iCh
80595>>>>>        String sFileName sExt
80595>>>>>
80595>>>>>        Get vFolderExists sDataPath to bExists
80596>>>>>        If (bExists = True) Begin
80598>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
80599>>>>>            Move ("dir:" + sDataPath)      to sDataPath
80600>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
80601>>>>>            Direct_Input channel iCh sDataPath
80603>>>>>                Repeat
80603>>>>>>
80603>>>>>                    Readln channel iCh sFileName
80605>>>>>                    Get ParseFileExtension sFileName to sExt
80606>>>>>                    If (Uppercase(sExt) = "INT") Begin
80608>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
80610>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
80611>>>>>                        End
80611>>>>>>
80611>>>>>                    End
80611>>>>>>
80611>>>>>                Until (SeqEof = True)
80613>>>>>            Close_Input channel iCh
80615>>>>>            Send Seq_Release_Channel iCh
80616>>>>>        End
80616>>>>>>
80616>>>>>        Function_Return sFilesData
80617>>>>>    End_Function
80618>>>>>
80618>>>>>    // Only done for MSSQLDRV_ID so far...
80618>>>>>    Function _SqlEnumerateDatabaseCollations String sDriverID Returns String[]
80620>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
80620>>>>>        String sDescription sFrom sSys sValue sPrevious
80620>>>>>        Handle hStmt hoSQLManager hoSQLConnect
80620>>>>>        Integer iFetchResult iRows iColumn iPos
80620>>>>>        tSQLConnection SQLConnection
80620>>>>>        tSQLConnection SQLConnection
80620>>>>>        String[] asCollations
80621>>>>>        
80621>>>>>        If (sDriverID = "") Begin
80623>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
80624>>>>>>
80624>>>>>            Function_Return asCollations
80625>>>>>        End
80625>>>>>>
80625>>>>>
80625>>>>>        // Only done for MSSQLDRV_ID so far...
80625>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
80627>>>>>            Function_Return asCollations
80628>>>>>        End                 
80628>>>>>>
80628>>>>>
80628>>>>>        Get phoSQLManager to hoSQLManager
80629>>>>>        Get psConnectionID     to sConnectionID
80630>>>>>        Get psConnectionString to sConnectionString
80631>>>>>        Move 0 to LastErr
80632>>>>>
80632>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80633>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
80634>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80635>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
80637>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
80638>>>>>>
80638>>>>>            Function_Return asCollations
80639>>>>>        End
80639>>>>>>
80639>>>>>
80639>>>>>        Get SqlOpen of hoSQLConnect to hStmt
80640>>>>>
80640>>>>>        If (hStmt = 0) Begin
80642>>>>>            Send SqlDisconnect of hoSQLManager
80643>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
80644>>>>>>
80644>>>>>            Function_Return asCollations
80645>>>>>        End
80645>>>>>>
80645>>>>>
80645>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
80646>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
80647>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
80648>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
80649>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
80650>>>>>
80650>>>>>        // MS-SQL Syntax:  
80650>>>>>        // SELECT name, description
80650>>>>>        //   from sys.fn_helpcollations();
80650>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
80651>>>>>
80651>>>>>        Move 1 to iColumn
80652>>>>>        Send SqlExecDirect of hStmt sSQL
80653>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
80654>>>>>        Repeat
80654>>>>>>
80654>>>>>            Get SQLFetch of hStmt to iFetchResult
80655>>>>>            If (iFetchResult <> 0) Begin
80657>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
80658>>>>>                If (sValue <> sPrevious) Begin         
80660>>>>>                    // We need to skip all collations starting with "SQL" because they
80660>>>>>                    // are obsolete and for pre-SQL Server 2000.
80660>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
80661>>>>>                    If (iPos <> 1) Begin
80663>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
80664>>>>>                    End
80664>>>>>>
80664>>>>>                End
80664>>>>>>
80664>>>>>                Move sValue to sPrevious
80665>>>>>            End
80665>>>>>>
80665>>>>>        Until (iFetchResult = 0)
80667>>>>>        Send SQLClose of hStmt
80668>>>>>        Send SQLDisconnect of hoSQLConnect
80669>>>>>
80669>>>>>        Function_Return asCollations
80670>>>>>    End_Function
80671>>>>>
80671>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
80671>>>>>    // for DAW drivers.
80671>>>>>    // Returns: A string array.
80671>>>>>    Function _SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
80673>>>>>        String[] sReturnArray
80674>>>>>        String sValue sPrevious
80674>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
80674>>>>>        Integer iFetchResult iRows
80674>>>>>        tSQLConnection SQLConnection
80674>>>>>        tSQLConnection SQLConnection
80674>>>>>
80674>>>>>        Get phoSQLManager to hoSQLHandler
80675>>>>>
80675>>>>>        If (hoSQLHandler <> 0) Begin
80677>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80678>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
80679>>>>>
80679>>>>>            If (hoSQLConnect <> 0) Begin
80681>>>>>                Get SQLOpen of hoSQLConnect to hstmt
80682>>>>>                If (hstmt <> 0) Begin
80684>>>>>                    Send SqlExecDirect of hstmt sStmt
80685>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
80686>>>>>                    Repeat
80686>>>>>>
80686>>>>>                        Get SQLFetch of hstmt to iFetchResult
80687>>>>>                        If (iFetchResult <> 0) Begin
80689>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
80690>>>>>                            If (sValue <> sPrevious) Begin
80692>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
80693>>>>>                            End
80693>>>>>>
80693>>>>>                            Move sValue to sPrevious
80694>>>>>                        End
80694>>>>>>
80694>>>>>                    Until (iFetchResult = 0)
80696>>>>>                    Send SQLClose of hstmt
80697>>>>>                End
80697>>>>>>
80697>>>>>                Send SQLDisconnect of hoSQLConnect
80698>>>>>            End
80698>>>>>>
80698>>>>>        End
80698>>>>>>
80698>>>>>
80698>>>>>        Function_Return sReturnArray
80699>>>>>    End_Function
80700>>>>>
80700>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
80702>>>>>        String[] sReturnArray
80703>>>>>        String sDataSource
80703>>>>>        Handle hoSQLHandler
80703>>>>>        Integer iItem
80703>>>>>
80703>>>>>        Get phoDB2SQLHandler to hoSQLHandler
80704>>>>>        Send SeedDataSources of hoSQLHandler
80705>>>>>
80705>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80706>>>>>
80706>>>>>        Repeat
80706>>>>>>
80706>>>>>            Get DataSources of hoSQLHandler to sDataSource
80707>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
80708>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
80709>>>>>            Increment iItem
80710>>>>>        Until (sDataSource = "")
80712>>>>>
80712>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80713>>>>>
80713>>>>>        Function_Return sReturnArray
80714>>>>>    End_Function
80715>>>>>
80715>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
80717>>>>>        String[] sReturnArray
80718>>>>>        String sDataSource
80718>>>>>        Handle hoSQLHandler
80718>>>>>        Integer iItem
80718>>>>>
80718>>>>>        Get phoODBCSQLHandler to hoSQLHandler
80719>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80720>>>>>
80720>>>>>        Send SeedDataSources of hoSQLHandler
80721>>>>>
80721>>>>>        Repeat
80721>>>>>>
80721>>>>>            Get DataSources of hoSQLHandler to sDataSource
80722>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
80724>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
80725>>>>>                Increment iItem
80726>>>>>            End
80726>>>>>>
80726>>>>>        Until (sDataSource = "")
80728>>>>>
80728>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80729>>>>>
80729>>>>>        Function_Return sReturnArray
80730>>>>>    End_Function
80731>>>>>
80731>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
80733>>>>>        String[] sDataSources
80734>>>>>        tSQLConnection SQLConnection
80734>>>>>        tSQLConnection SQLConnection
80734>>>>>        tSQLIntTableInfo[] sReturnArray
80734>>>>>        tSQLIntTableInfo[] sReturnArray
80735>>>>>        Integer iDataSources iCount iItem
80735>>>>>        String sConnection sServer sDatabase sKey sSubKey
80735>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
80735>>>>>        Boolean bExists bKeyOpened
80735>>>>>
80735>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80736>>>>>        Move SQLConnection.sConnectionString to sConnection
80737>>>>>        Move SQLConnection.sServer           to sServer
80738>>>>>
80738>>>>>        // FileDSN - read DATABASE name from DSN ini-file
80738>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
80740>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
80741>>>>>            Set psFileName of hoIniFile to sServer
80742>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
80743>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
80744>>>>>            Send Destroy of hoIniFile
80745>>>>>        End
80745>>>>>>
80745>>>>>
80745>>>>>        // DSN - read DATABASE name from the registry
80745>>>>>        Else Begin
80746>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
80747>>>>>
80747>>>>>            // We start with checking the "System DNS" area in the registry as it is the
80747>>>>>            // most probably place the info is kept that we're after.
80747>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
80748>>>>>            Set pfAccessRights of hoRegistry to Key_Read
80749>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
80750>>>>>            If (bExists = True) Begin
80752>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
80753>>>>>            End
80753>>>>>>
80753>>>>>            Else Begin
80754>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
80755>>>>>            End
80755>>>>>>
80755>>>>>
80755>>>>>            Get KeyExists of hoRegistry sKey to bExists
80756>>>>>            If (bExists) Begin
80758>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
80759>>>>>                If (bKeyOpened) Begin
80761>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
80762>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
80763>>>>>                    If (iDataSources > 0) Begin
80765>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
80766>>>>>                        Decrement iDataSources
80767>>>>>                        for iCount from 0 to iDataSources
80773>>>>>>
80773>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
80774>>>>>                        Loop
80775>>>>>>
80775>>>>>                        Move 0 to iItem
80776>>>>>                        for iCount from 0 to iDataSources
80782>>>>>>
80782>>>>>                            Move sDataSources[iCount] to sSubKey
80783>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
80784>>>>>                            If (bKeyOpened = True) Begin
80786>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
80787>>>>>                                If (bExists = True) Begin
80789>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
80790>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
80791>>>>>                                    Increment iItem
80792>>>>>                                End
80792>>>>>>
80792>>>>>                            End
80792>>>>>>
80792>>>>>                        Loop
80793>>>>>>
80793>>>>>                    End
80793>>>>>>
80793>>>>>                    Send CloseKey of hoRegistry
80794>>>>>                    Send Destroy of hoODBCDataSources
80795>>>>>                End
80795>>>>>>
80795>>>>>            End
80795>>>>>>
80795>>>>>
80795>>>>>            // We then check the "User DNS" area in the registry.
80795>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
80796>>>>>            Set pfAccessRights of hoRegistry to Key_Read
80797>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
80798>>>>>            Get KeyExists of hoRegistry sKey to bExists
80799>>>>>
80799>>>>>            If (bExists) Begin
80801>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
80802>>>>>                If (bKeyOpened) Begin
80804>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
80805>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
80806>>>>>                    If (iDataSources > 0) Begin
80808>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
80809>>>>>                        Decrement iDataSources
80810>>>>>                        for iCount from 0 to iDataSources
80816>>>>>>
80816>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
80817>>>>>                        Loop
80818>>>>>>
80818>>>>>                        for iCount from 0 to iDataSources
80824>>>>>>
80824>>>>>                            Move sDataSources[iCount] to sSubKey
80825>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
80826>>>>>                            If (bKeyOpened = True) Begin
80828>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
80829>>>>>                                If (bExists = True) Begin
80831>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
80832>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
80833>>>>>                                    Increment iItem
80834>>>>>                                End
80834>>>>>>
80834>>>>>                            End
80834>>>>>>
80834>>>>>                        Loop
80835>>>>>>
80835>>>>>                    End
80835>>>>>>
80835>>>>>                    Send CloseKey of hoRegistry
80836>>>>>                    Send Destroy of hoODBCDataSources
80837>>>>>                End
80837>>>>>>
80837>>>>>            End
80837>>>>>>
80837>>>>>
80837>>>>>            Send Destroy of hoRegistry
80838>>>>>        End
80838>>>>>>
80838>>>>>
80838>>>>>        Function_Return sReturnArray
80839>>>>>    End_Function
80840>>>>>
80840>>>>>    // We might have a split Sql script where the info about which database to use is
80840>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
80840>>>>>    // insert it for scriplets to come after the first one.
80840>>>>>    Function _SqlFormatStatement String sStmt Returns String
80842>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
80842>>>>>        Integer iStart iEnd iDbType
80842>>>>>        Boolean bOK
80842>>>>>
80842>>>>>        Get piDbType to iDbType
80843>>>>>        Get psDriverID to sDriverID
80844>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
80845>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
80846>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
80847>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
80848>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
80849>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
80851>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
80852>>>>>            Move (Pos("]", sTmp)) to iEnd
80853>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
80854>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
80855>>>>>            Set Private.psUseDatabase to sUseDatabase
80856>>>>>        End
80856>>>>>>
80856>>>>>        Else Begin
80857>>>>>            Move (Uppercase(sStmt)) to sTmp
80858>>>>>
80858>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
80858>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
80860>>>>>                Get Private.psUseDatabase to sUseDatabase
80861>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
80862>>>>>            End
80862>>>>>>
80862>>>>>
80862>>>>>            // This is a bit special to place here but was done so because it was easier that way.
80862>>>>>            // We will get an error when trying to create a view if it already exists.
80862>>>>>            // So to avoid such errors; we first remove it & then recreate it.
80862>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
80865>>>>>                // Make sure we only have one space between statements/words.
80865>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
80866>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
80867>>>>>                Move (Trim(sTmp)) to sTmp
80868>>>>>                Move (Pos(" ", sTmp)) to iEnd
80869>>>>>                Move (Left(sTmp, iEnd)) to sTmp
80870>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
80872>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
80873>>>>>                End
80873>>>>>>
80873>>>>>                Move (Trim(sTmp)) to sTmp
80874>>>>>                // Remove data view as it already exists!
80874>>>>>                Get _SqlViewRemove sDriverID sTmp to bOK
80875>>>>>            End
80875>>>>>>
80875>>>>>        End
80875>>>>>>
80875>>>>>
80875>>>>>        Function_Return sStmt
80876>>>>>    End_Function
80877>>>>>
80877>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
80877>>>>>    Function _SqlViewRemove String sDataView Returns Boolean
80879>>>>>        String sDriverID sSQLString sDropViewKeyWord
80879>>>>>        Integer iRetval
80879>>>>>        Boolean bOK
80879>>>>>
80879>>>>>        Get psDriverID to sDriverID
80880>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
80881>>>>>
80881>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
80882>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
80883>>>>>        Set psSQLStatementString to sSQLString
80884>>>>>
80884>>>>>        // As we don't check if the view exist or not, it might happen
80884>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
80884>>>>>        Move False to Err
80885>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
80886>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
80887>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
80888>>>>>        Move 0 to LastErr
80889>>>>>
80889>>>>>        // We also need to remove the cache-file since the table has been changed
80889>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
80890>>>>>
80890>>>>>        Function_Return (Err = False)
80891>>>>>    End_Function
80892>>>>>
80892>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
80892>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
80894>>>>>        String sRetval
80894>>>>>        Integer iDbType iIndex
80894>>>>>        tSQLKeyWords[] SQLKeywordArray
80894>>>>>        tSQLKeyWords[] SQLKeywordArray
80895>>>>>        tSQLKeyWords   SQLKeyWords
80895>>>>>        tSQLKeyWords   SQLKeyWords
80895>>>>>
80895>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
80895>>>>>        Move "" to sRetval
80896>>>>>        Get piDbType to iDbType
80897>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
80898>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
80899>>>>>
80899>>>>>        Get paSQLKeywordArray to SQLKeywordArray
80900>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
80901>>>>>        If (iIndex >= 0) Begin
80903>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
80904>>>>>        End
80904>>>>>>
80904>>>>>
80904>>>>>        Function_Return sRetval
80905>>>>>    End_Function
80906>>>>>
80906>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
80906>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
80908>>>>>        String[] sSQLScriptArray
80909>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
80909>>>>>        Integer iSize iCount
80909>>>>>        Boolean bCommentStart bCommentEnd bDashComment
80909>>>>>
80909>>>>>        Move False to bCommentStart
80910>>>>>        Move False to bCommentEnd
80911>>>>>        Move False to bDashComment
80912>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
80913>>>>>        Move "*/"  to sCommentEnd
80914>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
80915>>>>>
80915>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
80916>>>>>        Decrement iSize
80917>>>>>        Move "" to sText
80918>>>>>
80918>>>>>        for iCount from 0 to iSize
80924>>>>>>
80924>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
80925>>>>>            Move (Trim(sLine)) to sTmp
80926>>>>>            If (sTmp <> "") Begin
80928>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
80929>>>>>                If (bCommentStart = False) Begin
80931>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
80932>>>>>                    If (bCommentStart = False) Begin
80934>>>>>                    End
80934>>>>>>
80934>>>>>                End
80934>>>>>>
80934>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
80935>>>>>                If (bCommentEnd = True) Begin
80937>>>>>                    Move False to bCommentStart
80938>>>>>                End
80938>>>>>>
80938>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
80940>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
80941>>>>>                End
80941>>>>>>
80941>>>>>            End
80941>>>>>>
80941>>>>>        Loop
80942>>>>>>
80942>>>>>
80942>>>>>        // Update the retval struct array:
80942>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
80943>>>>>        Function_Return SqlScriptArray
80944>>>>>    End_Function
80945>>>>>
80945>>>>>    // Helper function that builds a string like;
80945>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
80945>>>>>    Function _SqlSelectFromWhereName Returns String
80947>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
80947>>>>>
80947>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
80948>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
80949>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
80950>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
80951>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
80952>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
80953>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
80954>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
80955>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
80956>>>>>        Function_Return sRetval
80957>>>>>    End_Function
80958>>>>>
80958>>>>>    // Helper function to create a SQL statement like;
80958>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
80958>>>>>    // Used for checking if an index exists.
80958>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
80960>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
80960>>>>>
80960>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
80961>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
80962>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
80963>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
80964>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
80965>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
80966>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
80967>>>>>
80967>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
80968>>>>>
80968>>>>>        Function_Return sRetval
80969>>>>>    End_Function
80970>>>>>
80970>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
80970>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
80970>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
80972>>>>>        String sRetval
80972>>>>>        If (iLength <> 0) Begin
80974>>>>>            Move ("(" + String(iLength)) to sRetval
80975>>>>>            If (iDecimals <> 0) Begin
80977>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
80978>>>>>            End
80978>>>>>>
80978>>>>>            Move (sRetval + ")") to sRetval
80979>>>>>        End
80979>>>>>>
80979>>>>>        Function_Return sRetval
80980>>>>>    End_Function
80981>>>>>
80981>>>>>    // Checks that the passed sDriverID is defined.
80981>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
80981>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
80983>>>>>        Boolean bOK
80983>>>>>        Integer iDriver
80983>>>>>
80983>>>>>        If (sDriverID = DATAFLEX_ID) Begin
80985>>>>>            Function_Return False
80986>>>>>        End
80986>>>>>>
80986>>>>>
80986>>>>>        Get IsDAWSQLDriver sDriverID to bOK
80987>>>>>
80987>>>>>        If (bOK = False) Begin
80989>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, or ODBC_DRV"
80990>>>>>>
80990>>>>>            Function_Return False
80991>>>>>        End
80991>>>>>>
80991>>>>>
80991>>>>>        Get DriverIndex sDriverID to iDriver
80992>>>>>        If (iDriver = 0) Begin
80994>>>>>            Load_Driver sDriverID
80995>>>>>        End
80995>>>>>>
80995>>>>>
80995>>>>>        Function_Return True
80996>>>>>    End_Function
80997>>>>>
80997>>>>>    // Checks that the length parameter has been passed correctly.
80997>>>>>    // This is only of concern for certain SQL data types.
80997>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
80999>>>>>        Integer iLength
80999>>>>>        Boolean bOK bCheckTypeLength
80999>>>>>
80999>>>>>        If (num_arguments > 1) Begin
81001>>>>>            Move iLen to iLength
81002>>>>>        End
81002>>>>>>
81002>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
81003>>>>>
81003>>>>>        If (bCheckTypeLength = True) Begin
81005>>>>>            Move (iLength > 0) to bOK
81006>>>>>        End
81006>>>>>>
81006>>>>>
81006>>>>>        Function_Return (bOK = True)
81007>>>>>    End_Function
81008>>>>>
81008>>>>>    Function _SqlProperTableName String sTableName Returns String
81010>>>>>        String sVal sSchema sDriverID
81010>>>>>        Integer iDbType
81010>>>>>
81010>>>>>        If (Trim(sTableName) = "") Begin
81012>>>>>            Function_Return ""
81013>>>>>        End
81013>>>>>>
81013>>>>>
81013>>>>>        Get psDriverID to sDriverID
81014>>>>>        Get piDbType   to iDbType
81015>>>>>        If (iDbType = EN_dbTypeOracle) Begin
81017>>>>>            Get psUserID to sSchema
81018>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
81018>>>>>            Move (Uppercase(sSchema)) to sSchema
81019>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
81020>>>>>            Function_Return sTableName
81021>>>>>        End
81021>>>>>>
81021>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
81023>>>>>            Get psDatabase to sVal
81024>>>>>            Move (sVal + "." + sTableName) to sTableName
81025>>>>>            Function_Return sTableName
81026>>>>>        End
81026>>>>>>
81026>>>>>        If (iDbType = EN_DbTypePostgre) Begin
81028>>>>>            Move ('"' + sTableName + '"') to sTableName
81029>>>>>            Function_Return sTableName
81030>>>>>        End
81030>>>>>>
81030>>>>>
81030>>>>>        Get psSchema to sSchema
81031>>>>>        If (sSchema = "") Begin
81033>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81034>>>>>        End
81034>>>>>>
81034>>>>>
81034>>>>>        Move (Uppercase(sTableName)) to sVal
81035>>>>>        If (not(sVal contains (sSchema + "."))) Begin
81037>>>>>            If (iDbType = EN_dbTypeDB2) Begin
81039>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
81040>>>>>            End
81040>>>>>>
81040>>>>>            Else Begin
81041>>>>>                Move (sSchema + "." + sTableName) to sTableName
81042>>>>>            End
81042>>>>>>
81042>>>>>        End
81042>>>>>>
81042>>>>>
81042>>>>>        Function_Return sTableName
81043>>>>>    End_Function
81044>>>>>
81044>>>>>    // SQL column names can be case-sensitive. This function is used to check that
81044>>>>>    // the passed sFieldName has the correct spelling.
81044>>>>>    // Used with Embedded SQL statement calls.
81044>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
81044>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
81046>>>>>        String sRetval sValue sDriverID
81046>>>>>        String[] sColumnNamesArray
81047>>>>>        Integer iCount iColumns
81047>>>>>
81047>>>>>        Move "" to sRetval
81048>>>>>        Get psDriverID to sDriverID
81049>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
81050>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
81051>>>>>        Decrement iColumns
81052>>>>>
81052>>>>>        For iCount from 0 to iColumns
81058>>>>>>
81058>>>>>            Move sColumnNamesArray[iCount] to sValue
81059>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
81061>>>>>                Move sValue to sRetval
81062>>>>>                Move iColumns to iCount // We're done.
81063>>>>>            End
81063>>>>>>
81063>>>>>        Loop
81064>>>>>>
81064>>>>>
81064>>>>>        Function_Return sRetval
81065>>>>>    End_Function
81066>>>>>
81066>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
81068>>>>>        String[] sReturnArray
81069>>>>>        Handle hoSQLHandler
81069>>>>>        Integer iCount iSize iItem
81069>>>>>        String sServer
81069>>>>>        tSQLConnection SQLConnection
81069>>>>>        tSQLConnection SQLConnection
81069>>>>>
81069>>>>>        Get phoMSSQLHandler to hoSQLHandler
81070>>>>>        Send Delete_Data    of hoSQLHandler
81071>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
81072>>>>>
81072>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81073>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
81074>>>>>        Decrement iSize
81075>>>>>
81075>>>>>        For iCount from 0 to iSize
81081>>>>>>
81081>>>>>            Get String_Value of hoSQLHandler iCount to sServer
81082>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
81083>>>>>            Increment iItem
81084>>>>>        Loop
81085>>>>>>
81085>>>>>
81085>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81086>>>>>
81086>>>>>        Function_Return sReturnArray
81087>>>>>    End_Function
81088>>>>>
81088>>>>>    Function _SqlTableArrayDAW Returns String[]
81090>>>>>        String[] sReturnArray
81091>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
81091>>>>>        Handle hoSQLHandler
81091>>>>>        Integer iCount iSize iItem iPos
81091>>>>>        Boolean bOK
81091>>>>>        tSQLConnection SQLConnection
81091>>>>>        tSQLConnection SQLConnection
81091>>>>>
81091>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81092>>>>>        If (SQLConnection.sConnectionString = "") Begin
81094>>>>>            Function_Return sReturnArray
81095>>>>>        End
81095>>>>>>
81095>>>>>
81095>>>>>        Move SQLConnection.sSchema      to sDefSchema
81096>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
81097>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
81098>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
81099>>>>>
81099>>>>>        Get phoCLIHandler to hoSQLHandler
81100>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
81101>>>>>        Send Delete_Data  of hoSQLHandler
81102>>>>>
81102>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81103>>>>>        Move SQLConnection.sConnectionString to sConnectionString
81104>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
81104>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
81104>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
81104>>>>>//                Move (Pos(";", sConnectionString)) to iPos
81104>>>>>//                If (iPos > 0) Begin
81104>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
81104>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
81104>>>>>//                End
81104>>>>>//            End
81104>>>>>//        End
81104>>>>>
81104>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
81105>>>>>        Move False to Err
81106>>>>>        Move 0 to iItem
81107>>>>>
81107>>>>>        // Note that the enumeration starts from table no 1. (not zero)
81107>>>>>        For iCount from 1 to iSize
81113>>>>>>
81113>>>>>            Get TableName    of hoSQLHandler iCount to sTable
81114>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
81115>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
81116>>>>>            If (sSchema = "") Begin
81118>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
81119>>>>>            End
81119>>>>>>
81119>>>>>            Get TableComment of hoSQLHandler iCount to sComment
81120>>>>>            Move (Trim(sTable)) to sTable
81121>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
81123>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
81124>>>>>            End
81124>>>>>>
81124>>>>>            Else Begin
81125>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
81126>>>>>            End
81126>>>>>>
81126>>>>>            If (bOK = True) Begin
81128>>>>>                Move sTable to sReturnArray[iItem]
81129>>>>>                Increment iItem
81130>>>>>            End
81130>>>>>>
81130>>>>>        Loop
81131>>>>>>
81131>>>>>
81131>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81132>>>>>
81132>>>>>        Function_Return sReturnArray
81133>>>>>    End_Function
81134>>>>>
81134>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
81136>>>>>        String[] sReturnArray
81137>>>>>        String sValue
81137>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
81137>>>>>        Integer iRetval iCols iFetchResult
81137>>>>>        tSQLConnection SQLConnection
81137>>>>>        tSQLConnection SQLConnection
81137>>>>>
81137>>>>>        Get phoSQLManager to hoSQLHandler
81138>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81139>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81140>>>>>
81140>>>>>        If (hoSQLConnect <> 0) Begin
81142>>>>>            Get SqlOpen of hoSQLConnect to hStmt
81143>>>>>            If (hStmt <> 0) Begin
81145>>>>>                Send SqlSetProcedurename of hStmt sStmt
81146>>>>>                If (sArgument <> "") Begin
81148>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
81149>>>>>                End
81149>>>>>>
81149>>>>>
81149>>>>>                Send SqlCall             of hStmt
81150>>>>>                Get SqlReturnValue       of hStmt to iRetval
81151>>>>>                If (iRetval = 0) Begin
81153>>>>>                    Repeat
81153>>>>>>
81153>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
81154>>>>>                        If (iCols > 0) Begin
81156>>>>>                            Repeat
81156>>>>>>
81156>>>>>                                Get SqlFetch of hStmt to iFetchResult
81157>>>>>                                If (iFetchResult <> 0) Begin
81159>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
81160>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
81161>>>>>                                End
81161>>>>>>
81161>>>>>                            Until (iFetchResult = 0)
81163>>>>>                        End
81163>>>>>>
81163>>>>>                        Get SqlNextResultSet of hStmt to iRetval
81164>>>>>                    Until (iRetval = 0)
81166>>>>>                    Send SqlClose of hStmt
81167>>>>>                End
81167>>>>>>
81167>>>>>            End
81167>>>>>>
81167>>>>>            Send SqlDisconnect of hoSQLConnect
81168>>>>>        End
81168>>>>>>
81168>>>>>        Function_Return sReturnArray
81169>>>>>    End_Function
81170>>>>>
81170>>>>>    Function _SqlUtilUpdateIntFile Integer hTable Returns Boolean
81172>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
81172>>>>>        Boolean bOpened bOK
81172>>>>>
81172>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
81172>>>>>        // which makes the program unable to run because they can't be opened.
81172>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
81172>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
81172>>>>>        // proper .int files for the two tables.
81172>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
81174>>>>>            Function_Return True
81175>>>>>        End
81175>>>>>>
81175>>>>>
81175>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81178>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81179>>>>>        Move CS_OEM_Txt  to sOrgFormat
81180>>>>>        Move CS_ANSI_Txt to sNewFormat
81181>>>>>        Get AutoConnectionIDLogin to bOK
81182>>>>>
81182>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
81182>>>>>        Sleep 1
81183>>>>>
81183>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81186>>>>>        If (bOpened = False) Begin
81188>>>>>            Open hTable
81190>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
81193>>>>>        End
81193>>>>>>
81193>>>>>        If (bOpened = False) Begin
81195>>>>>            Function_Return False
81196>>>>>        End
81196>>>>>>
81196>>>>>
81196>>>>>        Get psDriverID to sDriverID
81197>>>>>
81197>>>>>        Move False to Err
81198>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81201>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
81202>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81202>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81202>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81203>>>>>
81203>>>>>        Move False to Err
81204>>>>>
81204>>>>>        If (hTable > 0) Begin
81206>>>>>            Structure_Start hTable
81207>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81210>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81213>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
81215>>>>>        End
81215>>>>>>
81215>>>>>        Else Begin
81216>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81219>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81222>>>>>        End
81222>>>>>>
81222>>>>>        Function_Return (Err = False)
81223>>>>>    End_Function
81224>>>>>
81224>>>>>    // Subfunction to the ApiTableUpdate function (et al)
81224>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
81226>>>>>        Handle hTable
81226>>>>>        String sConnectionID
81226>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
81226>>>>>
81226>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
81227>>>>>        If (bSameTableNames = True) Begin
81229>>>>>            Function_Return True
81230>>>>>        End
81230>>>>>>
81230>>>>>
81230>>>>>        Move True to bOK
81231>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
81232>>>>>        Set Private.phCurrentTable              to hTable
81233>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
81236>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
81239>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
81242>>>>>
81242>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
81244>>>>>            Get psConnectionID to sConnectionID
81245>>>>>            Get _UtilTableExists hTable to bTableExists
81246>>>>>            If (bTableExists = True) Begin
81248>>>>>                Get _SqlUtilUpdateIntFile hTable to bOK
81249>>>>>            End
81249>>>>>>
81249>>>>>            Else Begin
81250>>>>>                Get pbToANSI to bANSI
81251>>>>>                Get _SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
81252>>>>>            End
81252>>>>>>
81252>>>>>        End
81252>>>>>>
81252>>>>>
81252>>>>>        Function_Return bOK
81253>>>>>    End_Function
81254>>>>>
81254>>>>>    // The table must already exist in the filelist for this function to work.
81254>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
81254>>>>>    Function _SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
81256>>>>>        Boolean bOK bExists bUseConnectionID 
81256>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
81256>>>>>        String[] sIndexArray
81257>>>>>        Integer iCount iCh iSize
81257>>>>>
81257>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
81258>>>>>        Get psConnectionString to sConnectionString
81259>>>>>
81259>>>>>        Move CS_ANSI_Txt to sANSI_OEM
81260>>>>>        If (bANSI = False) Begin
81262>>>>>            Move CS_OEM_Txt to sANSI_OEM
81263>>>>>        End
81263>>>>>>
81263>>>>>
81263>>>>>        Get psDataPathFirstPart to sDataPath
81264>>>>>        Get vFolderExists sDataPath to bOK
81265>>>>>        If (bOK = False) Begin
81267>>>>>            Error DFERR_PROGRAM "Function _SqlUtilCreateIntFile; psDataPath not found!"
81268>>>>>>
81268>>>>>            Function_Return False
81269>>>>>        End
81269>>>>>>
81269>>>>>        Get vFolderFormat sDataPath to sDataPath
81270>>>>>
81270>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81273>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81276>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81277>>>>>        Move sLogicalName  to sPhysicalFileName
81278>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
81279>>>>>
81279>>>>>        Get psSchema hTable to sSchemaName
81280>>>>>        If (sSchemaName = "") Begin
81282>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
81283>>>>>        End
81283>>>>>>
81283>>>>>
81283>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
81283>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
81284>>>>>        If (bExists = True) Begin
81286>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
81287>>>>>        End
81287>>>>>>
81287>>>>>
81287>>>>>        Get _UtilDeleteCacheFile sRootName to bOK
81288>>>>>        Get _SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
81289>>>>>
81289>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
81290>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
81295>>>>>            If (bUseConnectionID = True) Begin
81297>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
81304>>>>>            End
81304>>>>>>
81304>>>>>            Else Begin
81305>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
81312>>>>>            End
81312>>>>>>
81312>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
81317>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
81322>>>>>            // There seems to be a new order how these are set from DF19.
81322>>>>>            If (bSysFile = True) Begin
81324>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
81329>>>>>            End
81329>>>>>>
81329>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
81334>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
81339>>>>>            If (bSysFile = True) Begin
81341>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
81346>>>>>            End
81346>>>>>>
81346>>>>>
81346>>>>>            If (bSysFile = False) Begin
81348>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
81349>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
81350>>>>>                If (iSize > 0) Begin
81352>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
81355>>>>>                    Writeln channel iCh // Just an empty line
81357>>>>>                End
81357>>>>>>
81357>>>>>                Decrement iSize
81358>>>>>                for iCount from 0 to iSize
81364>>>>>>
81364>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
81367>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
81370>>>>>                    Writeln channel iCh
81372>>>>>                Loop
81373>>>>>>
81373>>>>>            End
81373>>>>>>
81373>>>>>        Send Seq_Close_Channel iCh
81374>>>>>
81374>>>>>        // Wait a sec for Windows to finish writing the file:
81374>>>>>        Sleep 1
81375>>>>>
81375>>>>>        Function_Return (bOK = True)
81376>>>>>    End_Function
81377>>>>>
81377>>>>>    Function _UtilDeleteCacheFile String sTableName Returns Boolean
81379>>>>>        String sDataPath sDriverID
81379>>>>>        Boolean bOK
81379>>>>>        Integer iPos
81379>>>>>
81379>>>>>        If (sTableName contains ".") Begin
81381>>>>>            Move (Pos(".", sTableName)) to iPos
81382>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
81383>>>>>        End
81383>>>>>>
81383>>>>>
81383>>>>>        Get psDriverID to sDriverID
81384>>>>>        Get psDataPathFirstPart to sDataPath
81385>>>>>        // First delete the cache file:
81385>>>>>        Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
81386>>>>>
81386>>>>>        Function_Return bOK
81387>>>>>    End_Function
81388>>>>>
81388>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
81388>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
81388>>>>>    // if it is an SQL table
81388>>>>>    Function _UtilTableExists Handle hTable Returns Boolean
81390>>>>>        Boolean bExists bIsSQLTable
81390>>>>>        String sDataPath sRootName
81390>>>>>
81390>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81391>>>>>        If (bExists = False) Begin
81393>>>>>            Function_Return False
81394>>>>>        End
81394>>>>>>
81394>>>>>
81394>>>>>        Move False to bIsSQLTable
81395>>>>>        If (hTable > 0) Begin
81397>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81400>>>>>            Move (sRootName contains ":") to bIsSQLTable
81401>>>>>        End
81401>>>>>>
81401>>>>>        If (bIsSQLTable = True) Begin
81403>>>>>            Get _UtilTableIsSql hTable to bExists
81404>>>>>            Function_Return bExists
81405>>>>>        End
81405>>>>>>
81405>>>>>        Else Begin
81406>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81407>>>>>            Get vFolderFormat sDataPath to sDataPath
81408>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
81409>>>>>        End
81409>>>>>>
81409>>>>>
81409>>>>>        Function_Return bExists
81410>>>>>    End_Function
81411>>>>>
81411>>>>>    // Pass a table handle
81411>>>>>    // Returns True if the table exists in filelist.cfg.
81411>>>>>    Function _UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
81413>>>>>        Handle hTable
81413>>>>>        Boolean bFound
81413>>>>>
81413>>>>>        Move False to bFound
81414>>>>>        Move 0 to hTable
81415>>>>>        Repeat
81415>>>>>>
81415>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81418>>>>>            If (hTable > 0) Begin
81420>>>>>                If (hTable = hCheckTable) Begin
81422>>>>>                    Move True to bFound
81423>>>>>                End
81423>>>>>>
81423>>>>>            End
81423>>>>>>
81423>>>>>            If (bFound = True) ;                Break
81426>>>>>        Until (hTable = 0)
81428>>>>>
81428>>>>>        Function_Return (bFound = True)
81429>>>>>    End_Function
81430>>>>>
81430>>>>>    // DataFlex Embedded Database Data Types:
81430>>>>>    // Helper function for _UtilEnumerateColumnTypes
81430>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
81432>>>>>        tColumnType[] ColumnType
81432>>>>>        tColumnType[] ColumnType
81433>>>>>        Integer i
81433>>>>>
81433>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
81434>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
81435>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
81436>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
81437>>>>>        Move "254"              to ColumnType[i].sPrecision
81438>>>>>        Increment i
81439>>>>>
81439>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
81440>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
81441>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
81442>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
81443>>>>>        Move "14.8"             to ColumnType[i].sPrecision
81444>>>>>        Increment i
81445>>>>>
81445>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
81446>>>>>        Move "Date"             to ColumnType[i].sSQLType
81447>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
81448>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
81449>>>>>        Move "6.0"              to ColumnType[i].sPrecision
81450>>>>>        Move True               to ColumnType[i].bCanEditSize
81451>>>>>        Increment i
81452>>>>>
81452>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
81453>>>>>        Move "Text"             to ColumnType[i].sSQLType
81454>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
81455>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
81456>>>>>        Move "16384"            to ColumnType[i].sPrecision
81457>>>>>        Increment i
81458>>>>>
81458>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
81459>>>>>        Move "Binary"           to ColumnType[i].sSQLType
81460>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
81461>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
81462>>>>>        Move "16384"            to ColumnType[i].sPrecision
81463>>>>>        Increment i
81464>>>>>
81464>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
81465>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
81466>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
81467>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
81468>>>>>        Move "23"               to ColumnType[i].sPrecision
81469>>>>>        Move True               to ColumnType[i].bCanEditSize
81470>>>>>        Increment i
81471>>>>>
81471>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
81472>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
81473>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
81474>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
81475>>>>>        Move "0.0"              to ColumnType[i].sPrecision
81476>>>>>
81476>>>>>        Function_Return ColumnType
81477>>>>>    End_Function
81478>>>>>
81478>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
81480>>>>>        tColumnType[] aColumnType
81480>>>>>        tColumnType[] aColumnType
81481>>>>>        Integer i
81481>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
81481>>>>>>// Generated By The Database Update Framework
81481>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
81481>>>>>>// Driver COLUMN DATA TYPES
81481>>>>>>//
81481>>>>>>// Created: 2019-07-18 18:57:13.935
81481>>>>>>
81481>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
81482>>>>>>            Move -5                                      to aColumnType[i].iSQLType
81483>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81484>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81485>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81486>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81487>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81488>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81489>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81490>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81491>>>>>>            Increment i
81492>>>>>>
81492>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
81493>>>>>>            Move -2                                      to aColumnType[i].iSQLType
81494>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81495>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81496>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81497>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81498>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81499>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81500>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81501>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81502>>>>>>            Increment i
81503>>>>>>
81503>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
81504>>>>>>            Move -7                                      to aColumnType[i].iSQLType
81505>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81506>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81507>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81508>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81509>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81510>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81511>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81512>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81513>>>>>>            Increment i
81514>>>>>>
81514>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
81515>>>>>>            Move 1                                       to aColumnType[i].iSQLType
81516>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81517>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81518>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81519>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81520>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81521>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81522>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81523>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81524>>>>>>            Increment i
81525>>>>>>
81525>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
81526>>>>>>            Move 91                                      to aColumnType[i].iSQLType
81527>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81528>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81529>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81530>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81531>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81532>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81533>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81534>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81535>>>>>>            Increment i
81536>>>>>>
81536>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
81537>>>>>>            Move 93                                      to aColumnType[i].iSQLType
81538>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81539>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81540>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81541>>>>>>            Move -1                                      to aColumnType[i].iMinSize
81542>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
81543>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81544>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81545>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81546>>>>>>            Increment i
81547>>>>>>
81547>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
81548>>>>>>            Move -200                                    to aColumnType[i].iSQLType
81549>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81550>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81551>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
81552>>>>>>            Move 23                                      to aColumnType[i].iMinSize
81553>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
81554>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81555>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81556>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81557>>>>>>            Increment i
81558>>>>>>
81558>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
81559>>>>>>            Move -155                                    to aColumnType[i].iSQLType
81560>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81561>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81562>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
81563>>>>>>            Move 34                                      to aColumnType[i].iMinSize
81564>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
81565>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81566>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81567>>>>>>            Move 34                                      to aColumnType[i].sPrecision
81568>>>>>>            Increment i
81569>>>>>>
81569>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
81570>>>>>>            Move 3                                       to aColumnType[i].iSQLType
81571>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81572>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81573>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81574>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81575>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81576>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81577>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81578>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81579>>>>>>            Increment i
81580>>>>>>
81580>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
81581>>>>>>            Move 6                                       to aColumnType[i].iSQLType
81582>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81583>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81584>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81585>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81586>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81587>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
81588>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
81589>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81590>>>>>>            Increment i
81591>>>>>>
81591>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
81592>>>>>>            Move -4                                      to aColumnType[i].iSQLType
81593>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81594>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81595>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81596>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81597>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81598>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81599>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81600>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81601>>>>>>            Increment i
81602>>>>>>
81602>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
81603>>>>>>            Move 4                                       to aColumnType[i].iSQLType
81604>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81605>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81606>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
81607>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81608>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
81609>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81610>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81611>>>>>>            Move 10                                      to aColumnType[i].sPrecision
81612>>>>>>            Increment i
81613>>>>>>
81613>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
81614>>>>>>            Move -204                                    to aColumnType[i].iSQLType
81615>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81616>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81617>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81618>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81619>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81620>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81621>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81622>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81623>>>>>>            Increment i
81624>>>>>>
81624>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
81625>>>>>>            Move -8                                      to aColumnType[i].iSQLType
81626>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81627>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81628>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81629>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81630>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
81631>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81632>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81633>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
81634>>>>>>            Increment i
81635>>>>>>
81635>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
81636>>>>>>            Move -10                                     to aColumnType[i].iSQLType
81637>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81638>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81639>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81640>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81641>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81642>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81643>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81644>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81645>>>>>>            Increment i
81646>>>>>>
81646>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
81647>>>>>>            Move 2                                       to aColumnType[i].iSQLType
81648>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81649>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81650>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81651>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81652>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81653>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
81654>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
81655>>>>>>            Move 6                                       to aColumnType[i].sPrecision
81656>>>>>>            Increment i
81657>>>>>>
81657>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
81658>>>>>>            Move -9                                      to aColumnType[i].iSQLType
81659>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81660>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81661>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81662>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81663>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
81664>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81665>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81666>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
81667>>>>>>            Increment i
81668>>>>>>
81668>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
81669>>>>>>            Move -202                                    to aColumnType[i].iSQLType
81670>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81671>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81672>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81673>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81674>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81675>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81676>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81677>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81678>>>>>>            Increment i
81679>>>>>>
81679>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
81680>>>>>>            Move 7                                       to aColumnType[i].iSQLType
81681>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81682>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81683>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81684>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81685>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81686>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81687>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81688>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81689>>>>>>            Increment i
81690>>>>>>
81690>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
81691>>>>>>            Move -206                                    to aColumnType[i].iSQLType
81692>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81693>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81694>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81695>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81696>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81697>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81698>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81699>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81700>>>>>>            Increment i
81701>>>>>>
81701>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
81702>>>>>>            Move 5                                       to aColumnType[i].iSQLType
81703>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81704>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81705>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
81706>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81707>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
81708>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81709>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81710>>>>>>            Move 5                                       to aColumnType[i].sPrecision
81711>>>>>>            Increment i
81712>>>>>>
81712>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
81713>>>>>>            Move -205                                    to aColumnType[i].iSQLType
81714>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81715>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81716>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81717>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81718>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81719>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81720>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81721>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81722>>>>>>            Increment i
81723>>>>>>
81723>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
81724>>>>>>            Move -1                                      to aColumnType[i].iSQLType
81725>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81726>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81727>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81728>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81729>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81730>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81731>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81732>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81733>>>>>>            Increment i
81734>>>>>>
81734>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
81735>>>>>>            Move -154                                    to aColumnType[i].iSQLType
81736>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81737>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81738>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
81739>>>>>>            Move 10                                      to aColumnType[i].iMinSize
81740>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
81741>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81742>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81743>>>>>>            Move 19                                      to aColumnType[i].sPrecision
81744>>>>>>            Increment i
81745>>>>>>
81745>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
81746>>>>>>            Move -6                                      to aColumnType[i].iSQLType
81747>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81748>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81749>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
81750>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81751>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
81752>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81753>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81754>>>>>>            Move 3                                       to aColumnType[i].sPrecision
81755>>>>>>            Increment i
81756>>>>>>
81756>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
81757>>>>>>            Move -11                                     to aColumnType[i].iSQLType
81758>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81759>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81760>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81761>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81762>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81763>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81764>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81765>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81766>>>>>>            Increment i
81767>>>>>>
81767>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
81768>>>>>>            Move -3                                      to aColumnType[i].iSQLType
81769>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81770>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81771>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
81772>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81773>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81774>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81775>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81776>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81777>>>>>>            Increment i
81778>>>>>>
81778>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
81779>>>>>>            Move -203                                    to aColumnType[i].iSQLType
81780>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81781>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81782>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81783>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81784>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81785>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81786>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81787>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81788>>>>>>            Increment i
81789>>>>>>
81789>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
81790>>>>>>            Move 12                                      to aColumnType[i].iSQLType
81791>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81792>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81793>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81794>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81795>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81796>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81797>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81798>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81799>>>>>>            Increment i
81800>>>>>>
81800>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
81801>>>>>>            Move -201                                    to aColumnType[i].iSQLType
81802>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81803>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81804>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81805>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81806>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81807>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81808>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81809>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81810>>>>>>            Increment i
81811>>>>>>
81811>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
81812>>>>>>            Move -152                                    to aColumnType[i].iSQLType
81813>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81814>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81815>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81816>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81817>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81818>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81819>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81820>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81821>>>>>>            Increment i
81822>>>>>>
81822>>>>>>
81822>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
81822>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "16384"            to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
81822>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
81822>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
81822>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
81822>>>>>//        Move "16384"            to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
81822>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
81822>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
81822>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
81822>>>>>//        Move "254"              to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        // ToDo: We need to change the sType when using this!
81822>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
81822>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
81822>>>>>//        Move "254"                  to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
81822>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
81822>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
81822>>>>>//        Move True               to ColumnType[i].bCanEditSize
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
81822>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "16384"            to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
81822>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
81822>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
81822>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
81822>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
81822>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
81822>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
81822>>>>>//        Move "255"              to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
81822>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
81822>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "32000"            to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
81822>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "32000"            to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
81822>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "32000"            to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
81822>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
81822>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
81822>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
81822>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
81822>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
81822>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
81822>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
81822>>>>>//        Move True               to ColumnType[i].bCanEditSize
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
81822>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
81822>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
81822>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
81822>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
81822>>>>>//        Move True               to ColumnType[i].bCanEditSize
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
81822>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "16384"            to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        // ToDo: We need to change the sType when using this!
81822>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
81822>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
81822>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
81822>>>>>//        Move "16384"                to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
81822>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "16384"            to ColumnType[i].sPrecision
81822>>>>>//
81822>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
81822>>>>>//        Move "XML"              to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "16384"            to ColumnType[i].sPrecision
81822>>>>>
81822>>>>>        Function_Return aColumnType
81823>>>>>    End_Function
81824>>>>>
81824>>>>>    // Microsoft SQL Server Database Data Types:
81824>>>>>    // Helper function for _UtilEnumerateColumnTypes
81824>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
81826>>>>>        tColumnType[] aColumnType
81826>>>>>        tColumnType[] aColumnType
81827>>>>>        Integer i
81827>>>>>
81827>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
81829>>>>>>// Generated By The Database Update Framework
81829>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
81829>>>>>>// Driver COLUMN DATA TYPES
81829>>>>>>//
81829>>>>>>// Created: 2019-11-15 21:57:51.001
81829>>>>>>
81829>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
81830>>>>>>            Move -5                                      to aColumnType[i].iSQLType
81831>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81832>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81833>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81834>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81835>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81836>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81837>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81838>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81839>>>>>>            Increment i
81840>>>>>>
81840>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
81841>>>>>>            Move -2                                      to aColumnType[i].iSQLType
81842>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81843>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81844>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81845>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81846>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81847>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
81848>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
81849>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81850>>>>>>            Increment i
81851>>>>>>
81851>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
81852>>>>>>            Move -7                                      to aColumnType[i].iSQLType
81853>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81854>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81855>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81856>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81857>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81858>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81859>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81860>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81861>>>>>>            Increment i
81862>>>>>>
81862>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
81863>>>>>>            Move 1                                       to aColumnType[i].iSQLType
81864>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81865>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81866>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81867>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81868>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81869>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81870>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81871>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81872>>>>>>            Increment i
81873>>>>>>
81873>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
81874>>>>>>            Move 91                                      to aColumnType[i].iSQLType
81875>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81876>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81877>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81878>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81879>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81880>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
81881>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
81882>>>>>>            Move 6                                       to aColumnType[i].sPrecision
81883>>>>>>            Increment i
81884>>>>>>
81884>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
81885>>>>>>            Move 93                                      to aColumnType[i].iSQLType
81886>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81887>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81888>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81889>>>>>>            Move -1                                      to aColumnType[i].iMinSize
81890>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
81891>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
81892>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
81893>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81894>>>>>>            Increment i
81895>>>>>>
81895>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
81896>>>>>>            Move -200                                    to aColumnType[i].iSQLType
81897>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81898>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81899>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
81900>>>>>>            Move 23                                      to aColumnType[i].iMinSize
81901>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
81902>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
81903>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
81904>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81905>>>>>>            Increment i
81906>>>>>>
81906>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
81907>>>>>>            Move -155                                    to aColumnType[i].iSQLType
81908>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81909>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81910>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
81911>>>>>>            Move 34                                      to aColumnType[i].iMinSize
81912>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
81913>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
81914>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
81915>>>>>>            Move 34                                      to aColumnType[i].sPrecision
81916>>>>>>            Increment i
81917>>>>>>
81917>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
81918>>>>>>            Move 3                                       to aColumnType[i].iSQLType
81919>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81920>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81921>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81922>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81923>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81924>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81925>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81926>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81927>>>>>>            Increment i
81928>>>>>>
81928>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
81929>>>>>>            Move 6                                       to aColumnType[i].iSQLType
81930>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81931>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81932>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81933>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81934>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81935>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81936>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81937>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81938>>>>>>            Increment i
81939>>>>>>
81939>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
81940>>>>>>            Move -4                                      to aColumnType[i].iSQLType
81941>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81942>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81943>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81944>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81945>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81946>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
81947>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
81948>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81949>>>>>>            Increment i
81950>>>>>>
81950>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
81951>>>>>>            Move 4                                       to aColumnType[i].iSQLType
81952>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81953>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81954>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
81955>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81956>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
81957>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81958>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81959>>>>>>            Move 10                                      to aColumnType[i].sPrecision
81960>>>>>>            Increment i
81961>>>>>>
81961>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
81962>>>>>>            Move -204                                    to aColumnType[i].iSQLType
81963>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81964>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81965>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81966>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81967>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81968>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81969>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81970>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81971>>>>>>            Increment i
81972>>>>>>
81972>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
81973>>>>>>            Move -8                                      to aColumnType[i].iSQLType
81974>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81975>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81976>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81977>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81978>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
81979>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81980>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81981>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
81982>>>>>>            Increment i
81983>>>>>>
81983>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
81984>>>>>>            Move -10                                     to aColumnType[i].iSQLType
81985>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81986>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81987>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81988>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81989>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81990>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
81991>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
81992>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81993>>>>>>            Increment i
81994>>>>>>
81994>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
81995>>>>>>            Move 2                                       to aColumnType[i].iSQLType
81996>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81997>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81998>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81999>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82000>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82001>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82002>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82003>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82004>>>>>>            Increment i
82005>>>>>>
82005>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82006>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82007>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82008>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82009>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82010>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82011>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82012>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82013>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82014>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82015>>>>>>            Increment i
82016>>>>>>
82016>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82017>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82018>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82019>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82020>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82021>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82022>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82023>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82024>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82025>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82026>>>>>>            Increment i
82027>>>>>>
82027>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82028>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82029>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82030>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82031>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82032>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82033>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82034>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82035>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82036>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82037>>>>>>            Increment i
82038>>>>>>
82038>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82039>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82040>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82041>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82042>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82043>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82044>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82045>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82046>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82047>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82048>>>>>>            Increment i
82049>>>>>>
82049>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82050>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82051>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82052>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82053>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82054>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82055>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82056>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82057>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82058>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82059>>>>>>            Increment i
82060>>>>>>
82060>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82061>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82062>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82063>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82064>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82065>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82066>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82067>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82068>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82069>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82070>>>>>>            Increment i
82071>>>>>>
82071>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82072>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82073>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82074>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82075>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82076>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82077>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82078>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82079>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82080>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82081>>>>>>            Increment i
82082>>>>>>
82082>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82083>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82084>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82085>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82086>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82087>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82088>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82089>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82090>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82091>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82092>>>>>>            Increment i
82093>>>>>>
82093>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82094>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82095>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82096>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82097>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82098>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82099>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82100>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82101>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82102>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82103>>>>>>            Increment i
82104>>>>>>
82104>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82105>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82106>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82107>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82108>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82109>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82110>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82111>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82112>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82113>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82114>>>>>>            Increment i
82115>>>>>>
82115>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82116>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82117>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82118>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82119>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82120>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82121>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82122>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82123>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82124>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82125>>>>>>            Increment i
82126>>>>>>
82126>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82127>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82128>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82129>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82130>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82131>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82132>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82133>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82134>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82135>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82136>>>>>>            Increment i
82137>>>>>>
82137>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82138>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82139>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82140>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82141>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82142>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82143>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82144>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82145>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82146>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82147>>>>>>            Increment i
82148>>>>>>
82148>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82149>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82150>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82151>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82152>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82153>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82154>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82155>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82156>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82157>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82158>>>>>>            Increment i
82159>>>>>>
82159>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82160>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82161>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82162>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82163>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82164>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82165>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82166>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82167>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82168>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82169>>>>>>            Increment i
82170>>>>>>
82170>>>>>>
82170>>>>>
82170>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
82170>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
82170>>>>>//            Move "binary"           to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
82170>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
82170>>>>>//            Move "bit"              to ColumnType[i].sSQLType
82170>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82170>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82170>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
82170>>>>>//            Move "char"             to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
82170>>>>>//            Move "date"             to ColumnType[i].sSQLType
82170>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
82170>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82170>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82170>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82170>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
82170>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
82170>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
82170>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
82170>>>>>//            Move True                to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
82170>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
82170>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
82170>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
82170>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
82170>>>>>//            Move "float"            to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
82170>>>>>//            Move "int"              to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
82170>>>>>//            Move "money"            to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
82170>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
82170>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
82170>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
82170>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
82170>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
82170>>>>>//            Move "real"             to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
82170>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
82170>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
82170>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
82170>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
82170>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
82170>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
82170>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
82170>>>>>//            Move "text"             to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
82170>>>>>//            Move "time"             to ColumnType[i].sSQLType
82170>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82170>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82170>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
82170>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
82170>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
82170>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82170>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82170>>>>>//            Move "36"               to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
82170>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82170>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82170>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
82170>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82170>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82170>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
82170>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82170>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
82170>>>>>//            Move "xml"              to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
82170>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
82170>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
82170>>>>>//            Move "time"             to ColumnType[i].sSQLType
82170>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82170>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82170>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
82170>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82170>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82170>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82170>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>
82170>>>>>        End
82170>>>>>>
82170>>>>>
82170>>>>>        Function_Return aColumnType
82171>>>>>    End_Function
82172>>>>>
82172>>>>>    // MySQL Data Types
82172>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
82174>>>>>        tColumnType[] aColumnType
82174>>>>>        tColumnType[] aColumnType
82175>>>>>        Integer i
82175>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
82175>>>>>>// Generated By The Database Update Framework
82175>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
82175>>>>>>// Driver COLUMN DATA TYPES
82175>>>>>>//
82175>>>>>>// Created: 2018-03-14 23:46:49.593
82175>>>>>>
82175>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82176>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82177>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82178>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82179>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82180>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82181>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82182>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82183>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82184>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82185>>>>>>            Increment i
82186>>>>>>
82186>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82187>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82188>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82189>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82190>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82191>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82192>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
82193>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82194>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82195>>>>>>            Move 64                                      to aColumnType[i].sPrecision
82196>>>>>>            Increment i
82197>>>>>>
82197>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82198>>>>>>            Move 252                                     to aColumnType[i].iSQLType
82199>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82200>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82201>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82202>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82203>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82204>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82205>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82206>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82207>>>>>>            Increment i
82208>>>>>>
82208>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82209>>>>>>            Move 254                                     to aColumnType[i].iSQLType
82210>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82211>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82212>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82213>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82214>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82215>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82216>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82217>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82218>>>>>>            Increment i
82219>>>>>>
82219>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82220>>>>>>            Move 10                                      to aColumnType[i].iSQLType
82221>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82222>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82223>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82224>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82225>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82226>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82227>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82228>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82229>>>>>>            Increment i
82230>>>>>>
82230>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82231>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82232>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82233>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82234>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82235>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82236>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82237>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82238>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82239>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82240>>>>>>            Increment i
82241>>>>>>
82241>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82242>>>>>>            Move 246                                     to aColumnType[i].iSQLType
82243>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82244>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82245>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82246>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82247>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82248>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82249>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82250>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82251>>>>>>            Increment i
82252>>>>>>
82252>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
82253>>>>>>            Move 0                                       to aColumnType[i].iSQLType
82254>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82255>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82256>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82257>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82258>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82259>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82260>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82261>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82262>>>>>>            Increment i
82263>>>>>>
82263>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82264>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82265>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82266>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82267>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82268>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82269>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82270>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82271>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82272>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82273>>>>>>            Increment i
82274>>>>>>
82274>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
82275>>>>>>            Move 247                                     to aColumnType[i].iSQLType
82276>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82277>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82278>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82279>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82280>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82281>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82282>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82283>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82284>>>>>>            Increment i
82285>>>>>>
82285>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82286>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82287>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82288>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82289>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82290>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82291>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82292>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82293>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82294>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82295>>>>>>            Increment i
82296>>>>>>
82296>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82297>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82298>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82299>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82300>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82301>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82302>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82303>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82304>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82305>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82306>>>>>>            Increment i
82307>>>>>>
82307>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
82308>>>>>>            Move 251                                     to aColumnType[i].iSQLType
82309>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82310>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82311>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82312>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82313>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82314>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82315>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82316>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82317>>>>>>            Increment i
82318>>>>>>
82318>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
82319>>>>>>            Move -251                                    to aColumnType[i].iSQLType
82320>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82321>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82322>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82323>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82324>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82325>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82326>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82327>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82328>>>>>>            Increment i
82329>>>>>>
82329>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
82330>>>>>>            Move 250                                     to aColumnType[i].iSQLType
82331>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82332>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82333>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82334>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82335>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82336>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82337>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82338>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82339>>>>>>            Increment i
82340>>>>>>
82340>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
82341>>>>>>            Move 9                                       to aColumnType[i].iSQLType
82342>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82343>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82344>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
82345>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82346>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
82347>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82348>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82349>>>>>>            Move 9                                       to aColumnType[i].sPrecision
82350>>>>>>            Increment i
82351>>>>>>
82351>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
82352>>>>>>            Move -250                                    to aColumnType[i].iSQLType
82353>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82354>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82355>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82356>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82357>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82358>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82359>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82360>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82361>>>>>>            Increment i
82362>>>>>>
82362>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
82363>>>>>>            Move 248                                     to aColumnType[i].iSQLType
82364>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82365>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82366>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82367>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82368>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82369>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82370>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82371>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82372>>>>>>            Increment i
82373>>>>>>
82373>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82374>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82375>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82376>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82377>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82378>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82379>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82380>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82381>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82382>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82383>>>>>>            Increment i
82384>>>>>>
82384>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82385>>>>>>            Move -252                                    to aColumnType[i].iSQLType
82386>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82387>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82388>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82389>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82390>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82391>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82392>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82393>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82394>>>>>>            Increment i
82395>>>>>>
82395>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82396>>>>>>            Move 11                                      to aColumnType[i].iSQLType
82397>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82398>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82399>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82400>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82401>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82402>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82403>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82404>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82405>>>>>>            Increment i
82406>>>>>>
82406>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82407>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82408>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82409>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82410>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82411>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82412>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82413>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82414>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82415>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82416>>>>>>            Increment i
82417>>>>>>
82417>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
82418>>>>>>            Move 249                                     to aColumnType[i].iSQLType
82419>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82420>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82421>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82422>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82423>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82424>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82425>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82426>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82427>>>>>>            Increment i
82428>>>>>>
82428>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82429>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82430>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82431>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82432>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82433>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82434>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
82435>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82436>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82437>>>>>>            Move 4                                       to aColumnType[i].sPrecision
82438>>>>>>            Increment i
82439>>>>>>
82439>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
82440>>>>>>            Move -249                                    to aColumnType[i].iSQLType
82441>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82442>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82443>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82444>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82445>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82446>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82447>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82448>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82449>>>>>>            Increment i
82450>>>>>>
82450>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82451>>>>>>            Move 253                                     to aColumnType[i].iSQLType
82452>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82453>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82454>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82455>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82456>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82457>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82458>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82459>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82460>>>>>>            Increment i
82461>>>>>>
82461>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
82462>>>>>>            Move 13                                      to aColumnType[i].iSQLType
82463>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82464>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82465>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82466>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82467>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82468>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82469>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82470>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82471>>>>>>            Increment i
82472>>>>>>
82472>>>>>>
82472>>>>>
82472>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
82472>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
82472>>>>>//        Move "bit"              to ColumnType[i].sSQLType
82472>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82472>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82472>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82472>>>>>//        Move True               to ColumnType[i].bCanEditSize
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
82472>>>>>//        Move "blob"             to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82472>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82472>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
82472>>>>>//        Move "char"             to ColumnType[i].sSQLType
82472>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82472>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82472>>>>>//        Move "254"              to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
82472>>>>>//        Move "date"             to ColumnType[i].sSQLType
82472>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82472>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82472>>>>>//        Move True               to ColumnType[i].bCanEditSize
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
82472>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
82472>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82472>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82472>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82472>>>>>//        Move True               to ColumnType[i].bCanEditSize
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
82472>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
82472>>>>>//        Move "double"           to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
82472>>>>>//        Move "enum"             to ColumnType[i].sSQLType
82472>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82472>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82472>>>>>//        Move "254"              to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
82472>>>>>//        Move "float"            to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82472>>>>>//        Move "int"              to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
82472>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82472>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
82472>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
82472>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82472>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
82472>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82472>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82472>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82472>>>>>//
82472>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
82472>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
82472>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82472>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
82472>>>>>//        Move "set"              to ColumnType[i].sSQLType
82472>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82472>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82472>>>>>//        Move "254"              to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
82472>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
82472>>>>>//        Move "text"             to ColumnType[i].sSQLType
82472>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82472>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
82472>>>>>//        Move "time"             to ColumnType[i].sSQLType
82472>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82472>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82472>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
82472>>>>>//        Move True               to ColumnType[i].bCanEditSize
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
82472>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
82472>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82472>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82472>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82472>>>>>//        Move True               to ColumnType[i].bCanEditSize
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
82472>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82472>>>>>//        Move "254"              to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
82472>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
82472>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
82472>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82472>>>>>//        Move "254"              to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
82472>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
82472>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82472>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
82472>>>>>//        Move "year"             to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82472>>>>>//        Move True               to ColumnType[i].bCanEditSize
82472>>>>>//        Increment i
82472>>>>>
82472>>>>>        Function_Return aColumnType
82473>>>>>    End_Function
82474>>>>>
82474>>>>>    // Oracle Data Types
82474>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
82476>>>>>        tColumnType[] aColumnType
82476>>>>>        tColumnType[] aColumnType
82477>>>>>        Integer i
82477>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
82477>>>>>>// Generated By The Database Update Framework
82477>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
82477>>>>>>// Driver COLUMN DATA TYPES
82477>>>>>>//
82477>>>>>>// Created: 2018-03-14 23:47:34.82
82477>>>>>>
82477>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82478>>>>>>            Move 113                                     to aColumnType[i].iSQLType
82479>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82480>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82481>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82482>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82483>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82484>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82485>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82486>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82487>>>>>>            Increment i
82488>>>>>>
82488>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82489>>>>>>            Move 96                                      to aColumnType[i].iSQLType
82490>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82491>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82492>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82493>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82494>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82495>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82496>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82497>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82498>>>>>>            Increment i
82499>>>>>>
82499>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
82500>>>>>>            Move 112                                     to aColumnType[i].iSQLType
82501>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82502>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82503>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82504>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82505>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82506>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82507>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82508>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82509>>>>>>            Increment i
82510>>>>>>
82510>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82511>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82512>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82513>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82514>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82515>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82516>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82517>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82518>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82519>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82520>>>>>>            Increment i
82521>>>>>>
82521>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82522>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82523>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82524>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82525>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82526>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82527>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82528>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82529>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82530>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82531>>>>>>            Increment i
82532>>>>>>
82532>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82533>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82534>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82535>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82536>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82537>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82538>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82539>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82540>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82541>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82542>>>>>>            Increment i
82543>>>>>>
82543>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
82544>>>>>>            Move 190                                     to aColumnType[i].iSQLType
82545>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82546>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82547>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82548>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82549>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82550>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82551>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82552>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82553>>>>>>            Increment i
82554>>>>>>
82554>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
82555>>>>>>            Move 189                                     to aColumnType[i].iSQLType
82556>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82557>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82558>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82559>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82560>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82561>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82562>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82563>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82564>>>>>>            Increment i
82565>>>>>>
82565>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
82566>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82567>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82568>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82569>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82570>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82571>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82572>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82573>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82574>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82575>>>>>>            Increment i
82576>>>>>>
82576>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
82577>>>>>>            Move 24                                      to aColumnType[i].iSQLType
82578>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82579>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82580>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82581>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82582>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82583>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82584>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82585>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82586>>>>>>            Increment i
82587>>>>>>
82587>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82588>>>>>>            Move 286                                     to aColumnType[i].iSQLType
82589>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82590>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82591>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82592>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82593>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82594>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82595>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82596>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82597>>>>>>            Increment i
82598>>>>>>
82598>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
82599>>>>>>            Move 288                                     to aColumnType[i].iSQLType
82600>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82601>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82602>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82603>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82604>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82605>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82606>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82607>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82608>>>>>>            Increment i
82609>>>>>>
82609>>>>>>            Move "number"                                to aColumnType[i].sSQLType
82610>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82611>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82612>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82613>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82614>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82615>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82616>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82617>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82618>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82619>>>>>>            Increment i
82620>>>>>>
82620>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
82621>>>>>>            Move 287                                     to aColumnType[i].iSQLType
82622>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82623>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82624>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82625>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82626>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82627>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82628>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82629>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82630>>>>>>            Increment i
82631>>>>>>
82631>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
82632>>>>>>            Move 23                                      to aColumnType[i].iSQLType
82633>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82634>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82635>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82636>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82637>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82638>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82639>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82640>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82641>>>>>>            Increment i
82642>>>>>>
82642>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82643>>>>>>            Move 187                                     to aColumnType[i].iSQLType
82644>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82645>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82646>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82647>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82648>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82649>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82650>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82651>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82652>>>>>>            Increment i
82653>>>>>>
82653>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
82654>>>>>>            Move 232                                     to aColumnType[i].iSQLType
82655>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82656>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82657>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82658>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82659>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82660>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82661>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82662>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82663>>>>>>            Increment i
82664>>>>>>
82664>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
82665>>>>>>            Move 188                                     to aColumnType[i].iSQLType
82666>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82667>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82668>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82669>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82670>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82671>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82672>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82673>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82674>>>>>>            Increment i
82675>>>>>>
82675>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
82676>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82677>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82678>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82679>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82680>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82681>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82682>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82683>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82684>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82685>>>>>>            Increment i
82686>>>>>>
82686>>>>>>
82686>>>>>
82686>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
82686>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
82686>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82686>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
82686>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
82686>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "2000"             to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
82686>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
82686>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
82686>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
82686>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82686>>>>>//        Move True               to ColumnType[i].bCanEditSize
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
82686>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
82686>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
82686>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
82686>>>>>//        Move "INT"              to ColumnType[i].sSQLType
82686>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
82686>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
82686>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
82686>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82686>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82686>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82686>>>>>//        Move True               to ColumnType[i].bCanEditSize
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
82686>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
82686>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
82686>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
82686>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
82686>>>>>//        Move True                to ColumnType[i].bCanEditSize
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
82686>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
82686>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82686>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
82686>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
82686>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82686>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
82686>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
82686>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "2000"             to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
82686>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
82686>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
82686>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
82686>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
82686>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
82686>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
82686>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "4000"             to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
82686>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
82686>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82686>>>>>//        Move "2000"             to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
82686>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
82686>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
82686>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
82686>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82686>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82686>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
82686>>>>>//        Move True               to ColumnType[i].bCanEditSize
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
82686>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
82686>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
82686>>>>>//        Move True                   to ColumnType[i].bCanEditSize
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
82686>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
82686>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
82686>>>>>//        Move True                   to ColumnType[i].bCanEditSize
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
82686>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
82686>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82686>>>>>
82686>>>>>        Function_Return aColumnType
82687>>>>>    End_Function
82688>>>>>
82688>>>>>    // PostgreSQL Data Types
82688>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
82690>>>>>        tColumnType[] aColumnType
82690>>>>>        tColumnType[] aColumnType
82691>>>>>        Integer i
82691>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
82691>>>>>>// Generated By The Database Update Framework
82691>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
82691>>>>>>// Driver COLUMN DATA TYPES
82691>>>>>>//
82691>>>>>>// Created: 2018-03-14 23:47:02.984
82691>>>>>>
82691>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82692>>>>>>            Move 20                                      to aColumnType[i].iSQLType
82693>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82694>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82695>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82696>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82697>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82698>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82699>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82700>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82701>>>>>>            Increment i
82702>>>>>>
82702>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82703>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
82704>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82705>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82706>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82707>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82708>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82709>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82710>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82711>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82712>>>>>>            Increment i
82713>>>>>>
82713>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
82714>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82715>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82716>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82717>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82718>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82719>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82720>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82721>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82722>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82723>>>>>>            Increment i
82724>>>>>>
82724>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
82725>>>>>>            Move 17                                      to aColumnType[i].iSQLType
82726>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82727>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82728>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82729>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82730>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82731>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82732>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82733>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82734>>>>>>            Increment i
82735>>>>>>
82735>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82736>>>>>>            Move 18                                      to aColumnType[i].iSQLType
82737>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82738>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82739>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82740>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82741>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82742>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82743>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82744>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82745>>>>>>            Increment i
82746>>>>>>
82746>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
82747>>>>>>            Move -25                                     to aColumnType[i].iSQLType
82748>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82749>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82750>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82751>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82752>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82753>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82754>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82755>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82756>>>>>>            Increment i
82757>>>>>>
82757>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82758>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
82759>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82760>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82761>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82762>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82763>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82764>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82765>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82766>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82767>>>>>>            Increment i
82768>>>>>>
82768>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82769>>>>>>            Move 701                                     to aColumnType[i].iSQLType
82770>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82771>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82772>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82773>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82774>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82775>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82776>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82777>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82778>>>>>>            Increment i
82779>>>>>>
82779>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
82780>>>>>>            Move 23                                      to aColumnType[i].iSQLType
82781>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82782>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82783>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
82784>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82785>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82786>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82787>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82788>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82789>>>>>>            Increment i
82790>>>>>>
82790>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82791>>>>>>            Move 790                                     to aColumnType[i].iSQLType
82792>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82793>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82794>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
82795>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82796>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
82797>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82798>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82799>>>>>>            Move 30                                      to aColumnType[i].sPrecision
82800>>>>>>            Increment i
82801>>>>>>
82801>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82802>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
82803>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82804>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82805>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82806>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82807>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82808>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82809>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82810>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82811>>>>>>            Increment i
82812>>>>>>
82812>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
82813>>>>>>            Move 26                                      to aColumnType[i].iSQLType
82814>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82815>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82816>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
82817>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82818>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82819>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82820>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82821>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82822>>>>>>            Increment i
82823>>>>>>
82823>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82824>>>>>>            Move 700                                     to aColumnType[i].iSQLType
82825>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82826>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82827>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82828>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82829>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82830>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82831>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82832>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82833>>>>>>            Increment i
82834>>>>>>
82834>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
82835>>>>>>            Move 24                                      to aColumnType[i].iSQLType
82836>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82837>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82838>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
82839>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82840>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82841>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82842>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82843>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82844>>>>>>            Increment i
82845>>>>>>
82845>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82846>>>>>>            Move 21                                      to aColumnType[i].iSQLType
82847>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82848>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82849>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82850>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82851>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82852>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82853>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82854>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82855>>>>>>            Increment i
82856>>>>>>
82856>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82857>>>>>>            Move 25                                      to aColumnType[i].iSQLType
82858>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82859>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82860>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82861>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82862>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82863>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82864>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82865>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82866>>>>>>            Increment i
82867>>>>>>
82867>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82868>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
82869>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82870>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82871>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
82872>>>>>>            Move 8                                       to aColumnType[i].iMinSize
82873>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
82874>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82875>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82876>>>>>>            Move 15                                      to aColumnType[i].sPrecision
82877>>>>>>            Increment i
82878>>>>>>
82878>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82879>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
82880>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82881>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82882>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82883>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82884>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82885>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82886>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82887>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82888>>>>>>            Increment i
82889>>>>>>
82889>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
82890>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
82891>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82892>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82893>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82894>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82895>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82896>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82897>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82898>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82899>>>>>>            Increment i
82900>>>>>>
82900>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
82901>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
82902>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82903>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82904>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
82905>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82906>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82907>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82908>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82909>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82910>>>>>>            Increment i
82911>>>>>>
82911>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
82912>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
82913>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82914>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82915>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82916>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82917>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82918>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82919>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82920>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82921>>>>>>            Increment i
82922>>>>>>
82922>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82923>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
82924>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82925>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82926>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82927>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82928>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82929>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82930>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82931>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82932>>>>>>            Increment i
82933>>>>>>
82933>>>>>>
82933>>>>>
82933>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
82933>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82933>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82933>>>>>//        Move True               to ColumnType[i].bCanEditSize
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
82933>>>>>//        Move "bit"              to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
82933>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
82933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82933>>>>>//        Move "1"                to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
82933>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
82933>>>>>//        Move "char"             to ColumnType[i].sSQLType
82933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82933>>>>>//        Move "2000"             to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
82933>>>>>//        Move "citext"           to ColumnType[i].sSQLType
82933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82933>>>>>//        Move "254"              to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
82933>>>>>//        Move "date"             to ColumnType[i].sSQLType
82933>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82933>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82933>>>>>//        Move True               to ColumnType[i].bCanEditSize
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
82933>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
82933>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
82933>>>>>//        Move "double"           to ColumnType[i].sSQLType
82933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82933>>>>>//        Move "22"               to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
82933>>>>>//        Move "integer"          to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82933>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
82933>>>>>//        Move "money"            to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82933>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
82933>>>>>//        Move "oid"              to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
82933>>>>>//        Move "real"             to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
82933>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
82933>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
82933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82933>>>>>//        Move "64"               to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
82933>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82933>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
82933>>>>>//        Move "text"             to ColumnType[i].sSQLType
82933>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
82933>>>>>//        Move "time"             to ColumnType[i].sSQLType
82933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82933>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82933>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
82933>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
82933>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82933>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82933>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82933>>>>>//        Move True               to ColumnType[i].bCanEditSize
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
82933>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
82933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82933>>>>>//        Move "40"               to ColumnType[i].sPrecision
82933>>>>>//        Move True               to ColumnType[i].bCanEditSize
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
82933>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
82933>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82933>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
82933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>
82933>>>>>        Function_Return aColumnType
82934>>>>>    End_Function
82935>>>>>
82935>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
82935>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
82937>>>>>        Integer iValue iSize iCount iStart
82937>>>>>        tColumnType[] ColumnTypeArray
82937>>>>>        tColumnType[] ColumnTypeArray
82938>>>>>        tColumnType RetvalType
82938>>>>>        tColumnType RetvalType
82938>>>>>        String sValue
82938>>>>>        Boolean bFrameworkDataFlexType
82938>>>>>
82938>>>>>        Move "Undefined" to RetvalType.sSQLType
82939>>>>>        Move -1999       to RetvalType.iSQLType
82940>>>>>
82940>>>>>        Move 0 to iStart
82941>>>>>        Move (Uppercase(sType)) to sType
82942>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
82943>>>>>        If (bFrameworkDataFlexType = True) Begin
82945>>>>>            Get _UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
82946>>>>>            Function_Return RetvalType
82947>>>>>        End
82947>>>>>>
82947>>>>>
82947>>>>>        Get _UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
82948>>>>>
82948>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
82949>>>>>        Decrement iSize
82950>>>>>
82950>>>>>        For iCount from iStart to iSize
82956>>>>>>
82956>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
82957>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
82958>>>>>            If (bIntegerInputType = True) Begin
82960>>>>>                If (iValue = iType) Begin
82962>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
82963>>>>>                    Move iType                                  to RetvalType.iSQLType
82964>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
82965>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
82966>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
82967>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
82968>>>>>                    Move iSize to iCount // We're done!
82969>>>>>                End
82969>>>>>>
82969>>>>>            End
82969>>>>>>
82969>>>>>            Else Begin
82970>>>>>                Move (Uppercase(sValue)) to sValue
82971>>>>>                If (sValue = sType) Begin
82973>>>>>                    Move sType                                  to RetvalType.sSQLType
82974>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
82975>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
82976>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
82977>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
82978>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
82979>>>>>                    Move iSize to iCount // We're done!
82980>>>>>                End
82980>>>>>>
82980>>>>>            End
82980>>>>>>
82980>>>>>        Loop
82981>>>>>>
82981>>>>>
82981>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
82981>>>>>        // In which case we search for a match in DataFlex standard types:
82981>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
82983>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
82984>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
82985>>>>>            Decrement iSize
82986>>>>>
82986>>>>>            For iCount from iStart to iSize
82992>>>>>>
82992>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
82993>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
82994>>>>>                If (iValue = iType) Begin
82996>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
82997>>>>>                    Move iType                                  to RetvalType.iSQLType
82998>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
82999>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83000>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83001>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83002>>>>>                    Move iSize to iCount // We're done!
83003>>>>>                End
83003>>>>>>
83003>>>>>            Loop
83004>>>>>>
83004>>>>>        End
83004>>>>>>
83004>>>>>
83004>>>>>        Function_Return RetvalType
83005>>>>>    End_Function
83006>>>>>
83006>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
83006>>>>>    Function _UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
83008>>>>>        tColumnType[] ColumnType
83008>>>>>        tColumnType[] ColumnType
83009>>>>>
83009>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
83009>>>>>        // the dbType.
83009>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83011>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
83013>>>>>                Move ODBC_DRV_ID to sDriverID
83014>>>>>            End
83014>>>>>>
83014>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
83016>>>>>                Move MSSQLDRV_ID to sDriverID
83017>>>>>            End
83017>>>>>>
83017>>>>>            If (iDbType = EN_DbTypeDB2) Begin
83019>>>>>                Move DB2_DRV_ID to sDriverID
83020>>>>>            End
83020>>>>>>
83020>>>>>            If (iDbType = EN_DbTypePostgre) Begin
83022>>>>>                Move ODBC_DRV_ID to sDriverID
83023>>>>>            End
83023>>>>>>
83023>>>>>        End
83023>>>>>>
83023>>>>>
83023>>>>>        Case Begin
83023>>>>>            Case (iDbType = EN_dbTypeDataFlex)
83025>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
83026>>>>>                Case Break
83027>>>>>
83027>>>>>            Case (iDbType = EN_DbTypeDB2)
83030>>>>>                Get _UtilEnumerateDB2Types to ColumnType
83031>>>>>                Case Break
83032>>>>>
83032>>>>>            Case (iDbType = EN_DbTypeMSSQL)
83035>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
83036>>>>>                Case Break
83037>>>>>        Case End
83037>>>>>
83037>>>>>        Function_Return ColumnType
83038>>>>>    End_Function
83039>>>>>
83039>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
83039>>>>>    // are mapped to a DUF data type.
83039>>>>>    Function _UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
83041>>>>>        tColumnType ColumnType
83041>>>>>        tColumnType ColumnType
83041>>>>>        String sDataType
83041>>>>>        Integer iDriverID iCount
83041>>>>>
83041>>>>>        Move 0 to iCount
83042>>>>>        Get DriverIndex sDriverID to iDriverID
83043>>>>>
83043>>>>>        Case Begin
83043>>>>>            // DF_ASCII
83043>>>>>            Case (iType = DF_ASCII_DUF)
83045>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83047>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
83050>>>>>                End
83050>>>>>>
83050>>>>>                Else Begin
83051>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
83054>>>>>                End
83054>>>>>>
83054>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
83055>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
83056>>>>>                Move sDataType   to ColumnType.sSQLType
83057>>>>>                Move DF_ASCII    to ColumnType.iSQLType
83058>>>>>                Move False       to ColumnType.bCanEditSize
83059>>>>>                Case Break
83060>>>>>
83060>>>>>            // DF_BINARY
83060>>>>>            Case (iType = DF_BINARY_DUF)
83063>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83065>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
83068>>>>>                End
83068>>>>>>
83068>>>>>                Else Begin
83069>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
83072>>>>>                End
83072>>>>>>
83072>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
83073>>>>>                Move "Binary"    to ColumnType.sDataFlexType
83074>>>>>                Move sDataType   to ColumnType.sSQLType
83075>>>>>                Move DF_BINARY   to ColumnType.iSQLType
83076>>>>>                Move False       to ColumnType.bCanEditSize
83077>>>>>                Case Break
83078>>>>>
83078>>>>>            // DF_DATE
83078>>>>>            Case (iType = DF_DATE_DUF)
83081>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83083>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83086>>>>>                End
83086>>>>>>
83086>>>>>                Else Begin
83087>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83090>>>>>                End
83090>>>>>>
83090>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
83091>>>>>                Move "Date"      to ColumnType.sDataFlexType
83092>>>>>                Move sDataType   to ColumnType.sSQLType
83093>>>>>                Move DF_DATE     to ColumnType.iSQLType
83094>>>>>                Move True        to ColumnType.bCanEditSize
83095>>>>>                Case Break
83096>>>>>
83096>>>>>            // DF_DATETIME
83096>>>>>            Case (iType = DF_DATETIME_DUF)
83099>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83101>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
83104>>>>>                End
83104>>>>>>
83104>>>>>                Else Begin
83105>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
83108>>>>>                End
83108>>>>>>
83108>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
83109>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
83110>>>>>                Move sDataType   to ColumnType.sSQLType
83111>>>>>                Move DF_DATETIME to ColumnType.iSQLType
83112>>>>>                Move True        to ColumnType.bCanEditSize
83113>>>>>                Case Break
83114>>>>>
83114>>>>>            // DF_NUMERIC
83114>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
83114>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
83114>>>>>            // we make them here all "Numeric"...
83114>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
83114>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83114>>>>>            // End
83114>>>>>            // Else Begin
83114>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83114>>>>>            // End
83114>>>>>            // ToDo: How should we find the best "Numeric" data type here?
83114>>>>>            Case (iType = DF_BCD_DUF)
83117>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
83118>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
83119>>>>>                Move "Numeric"   to ColumnType.sSQLType
83120>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
83121>>>>>                Move False       to ColumnType.bCanEditSize
83122>>>>>                Case Break
83123>>>>>
83123>>>>>            // DF_TEXT
83123>>>>>            Case (iType = DF_TEXT_DUF)
83126>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83128>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
83131>>>>>                End
83131>>>>>>
83131>>>>>                Else Begin
83132>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
83135>>>>>                End
83135>>>>>>
83135>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
83136>>>>>                Move "Text"      to ColumnType.sDataFlexType
83137>>>>>                Move sDataType   to ColumnType.sSQLType
83138>>>>>                Move DF_TEXT     to ColumnType.iSQLType
83139>>>>>                Move False       to ColumnType.bCanEditSize
83140>>>>>                Case Break
83141>>>>>
83141>>>>>            Case Else
83141>>>>>                Move -1999       to ColumnType.iDataFlexType
83142>>>>>                Move "Undefined" to ColumnType.sDataFlexType
83143>>>>>                Move "Undefined" to ColumnType.sSQLType
83144>>>>>                Move -1999       to ColumnType.iSQLType
83145>>>>>                Move True        to ColumnType.bCanEditSize
83146>>>>>
83146>>>>>        Case End
83146>>>>>
83146>>>>>        Function_Return ColumnType
83147>>>>>    End_Function
83148>>>>>
83148>>>>>    Function _AllTablesToConvert Returns Integer[]
83150>>>>>        Integer[] aTableConvertExceptions iTablesArray
83152>>>>>        Handle hTable
83152>>>>>        Integer iIndex
83152>>>>>        String sTableName
83152>>>>>        Boolean bFlexErrs
83152>>>>>
83152>>>>>        // a) Get the exception table array the developer has specified
83152>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
83153>>>>>
83153>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
83153>>>>>        Repeat
83153>>>>>>
83153>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83156>>>>>            If (hTable <> 0) Begin
83158>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83161>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83162>>>>>                If (bFlexErrs = False) Begin
83164>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
83166>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83167>>>>>                        If (iIndex = -1) Begin
83169>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
83170>>>>>                        End
83170>>>>>>
83170>>>>>                    End
83170>>>>>>
83170>>>>>                End
83170>>>>>>
83170>>>>>            End
83170>>>>>>
83170>>>>>        Until (hTable = 0)
83172>>>>>
83172>>>>>        Move 0 to hTable
83173>>>>>
83173>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83173>>>>>        Repeat
83173>>>>>>
83173>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83176>>>>>            If (hTable > 0) Begin
83178>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83181>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83182>>>>>                If (bFlexErrs = False) Begin
83184>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83185>>>>>                    If (iIndex = -1) Begin
83187>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83188>>>>>                    End
83188>>>>>>
83188>>>>>                End
83188>>>>>>
83188>>>>>            End
83188>>>>>>
83188>>>>>        Until (hTable = 0)
83190>>>>>
83190>>>>>        Function_Return iTablesArray
83191>>>>>    End_Function
83192>>>>>
83192>>>>>    Function _AllTablesDateCorrections Returns Integer[]
83194>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
83196>>>>>        Handle hTable
83196>>>>>        Integer iIndex
83196>>>>>        String sTableName
83196>>>>>        Boolean bFlexErrs
83196>>>>>
83196>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83197>>>>>        Move 0 to hTable
83198>>>>>
83198>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83198>>>>>        Repeat
83198>>>>>>
83198>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83201>>>>>            If (hTable > 0) Begin
83203>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83206>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83207>>>>>                If (bFlexErrs = False) Begin
83209>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
83210>>>>>                    If (iIndex = -1) Begin
83212>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83213>>>>>                    End
83213>>>>>>
83213>>>>>                End
83213>>>>>>
83213>>>>>            End
83213>>>>>>
83213>>>>>        Until (hTable = 0)
83215>>>>>
83215>>>>>        Function_Return iTablesArray
83216>>>>>    End_Function
83217>>>>>
83217>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
83219>>>>>        tAPIColumn NewAPIColumn
83219>>>>>        tAPIColumn NewAPIColumn
83219>>>>>
83219>>>>>        Move sFieldName to NewAPIColumn.sFieldName
83220>>>>>        Move iType      to NewAPIColumn.iType
83221>>>>>        Move iLength    to NewAPIColumn.iLength
83222>>>>>        Move iPrecision to NewAPIColumn.iPrecision
83223>>>>>        Move iOptions   to NewAPIColumn.iOptions
83224>>>>>
83224>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
83225>>>>>
83225>>>>>        Function_Return aCurrent
83226>>>>>    End_Function
83227>>>>>
83227>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
83229>>>>>        String sRetval sFieldName
83229>>>>>        Integer iCount iSize
83229>>>>>
83229>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
83230>>>>>        Decrement iSize
83231>>>>>        For iCount from 0 to iSize
83237>>>>>>
83237>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
83238>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
83239>>>>>        Loop
83240>>>>>>
83240>>>>>        Move (Trim(sRetval)) to sRetval
83241>>>>>
83241>>>>>        Function_Return sRetval
83242>>>>>    End_Function
83243>>>>>
83243>>>>>    // *** Miscellaneous other functions ***
83243>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
83243>>>>>    //
83243>>>>>
83243>>>>>    // Callback functionality used when e.g. calling driver functions directly.
83243>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
83245>>>>>        Integer iPerc
83245>>>>>        Number nReady nTotal
83245>>>>>
83245>>>>>        Send DoAdvance of ghoProgressBar
83246>>>>>
83246>>>>>        If (sCallback_Text contains "Copy records") Begin
83248>>>>>            Move CS_DUF_CopyingData to sCallback_Text
83249>>>>>        End
83249>>>>>>
83249>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
83251>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83252>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83253>>>>>        End
83253>>>>>>
83253>>>>>        If (sCallback_Text contains "Creating index") Begin
83255>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
83256>>>>>        End
83256>>>>>>
83256>>>>>
83256>>>>>        Case Begin
83256>>>>>            Case (iCallback_Type = DF_Message_Text)
83258>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83259>>>>>                Set Action_Text  of ghoStatusPanel to ""
83260>>>>>                Case Break
83261>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
83264>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83265>>>>>                Set Action_Text  of ghoStatusPanel to ""
83266>>>>>                Case Break
83267>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
83270>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83271>>>>>                Set Action_Text  of ghoStatusPanel to ""
83272>>>>>                Case Break
83273>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
83276>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83277>>>>>                Set Action_Text  of ghoStatusPanel to ""
83278>>>>>                Case Break
83279>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
83282>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83283>>>>>                Set Action_Text  of ghoStatusPanel to ""
83284>>>>>                Case Break
83285>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
83288>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83289>>>>>                Set Action_Text  of ghoStatusPanel to ""
83290>>>>>                Case Break
83291>>>>>            Case (iCallback_Type = DF_Message_Warning)
83294>>>>>                Send None
83295>>>>>                Case Break
83296>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
83299>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83300>>>>>                Set Action_Text  of ghoStatusPanel to ""
83301>>>>>                Case Break
83302>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
83305>>>>>                //*** Interpret numbers
83305>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
83306>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
83307>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
83308>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
83309>>>>>                Case Break
83310>>>>>            Case Else
83310>>>>>                Set Message_Text to ""
83311>>>>>                Set Action_Text  to ""
83312>>>>>        Case End
83312>>>>>
83312>>>>>        Send ProcessEvents of ghoStatusPanel
83313>>>>>        Function_Return False
83314>>>>>    End_Function
83315>>>>>
83315>>>>>    // * Dummy function for the Studio's Code Explorer *
83315>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
83317>>>>>        Function_Return False
83318>>>>>    End_Function
83319>>>>>
83319>>>>>    // *** Helper functions with compiled sql script code ***
83319>>>>>    //
83319>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
83319>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83319>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
83319>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
83319>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83319>>>>>    //   ALTER TABLE MyTable
83319>>>>>    //       REBUILD
83319>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
83321>>>>>        Boolean bOK
83321>>>>>
83321>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83323>>>>>            Function_Return False
83324>>>>>        End
83324>>>>>>
83324>>>>>
83324>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
83324>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
83325>>>>>
83325>>>>>        Function_Return (bOK = True)
83326>>>>>    End_Function
83327>>>>>
83327>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
83327>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83327>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
83327>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
83327>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83327>>>>>    //   ALTER TABLE MyTable
83327>>>>>    //       REBUILD
83327>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
83329>>>>>        tSQLScriptArray SQLScriptArray
83329>>>>>        tSQLScriptArray SQLScriptArray
83329>>>>>        String sDriverID
83329>>>>>        Boolean bOK
83329>>>>>        Integer iSize iCount
83329>>>>>
83329>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83331>>>>>            Function_Return False
83332>>>>>        End
83332>>>>>>
83332>>>>>
83332>>>>>        Get psDriverID to sDriverID
83333>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83334>>>>>        If (SQLScriptArray.bError = True) Begin
83336>>>>>            Function_Return False
83337>>>>>        End
83337>>>>>>
83337>>>>>
83337>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83338>>>>>        Decrement iSize
83339>>>>>
83339>>>>>        For iCount from 0 to iSize
83345>>>>>>
83345>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
83347>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
83348>>>>>            End
83348>>>>>>
83348>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
83350>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
83351>>>>>            End
83351>>>>>>
83351>>>>>        Loop
83352>>>>>>
83352>>>>>
83352>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83353>>>>>
83353>>>>>        Function_Return (bOK = True)
83354>>>>>    End_Function
83355>>>>>
83355>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
83355>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
83355>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
83355>>>>>    Function _SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
83357>>>>>        Integer iChannel iArgumentSize iCount
83357>>>>>        Number nByteCount
83357>>>>>        String sSQLScript
83357>>>>>        tSQLScriptArray SqlScriptArray
83357>>>>>        tSQLScriptArray SqlScriptArray
83357>>>>>        UChar[] uCharData
83358>>>>>
83358>>>>>        Move False to Err
83359>>>>>        Get Seq_New_Channel to iChannel
83360>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83362>>>>>            Error DFERR_PROGRAM 'No channel available...'
83363>>>>>>
83363>>>>>            Move True to SqlScriptArray.bError
83364>>>>>            Function_Return SqlScriptArray
83365>>>>>        End
83365>>>>>>
83365>>>>>
83365>>>>>        // First decide the size of the script
83365>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83367>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
83369>>>>>        Close_Input channel iChannel
83371>>>>>
83371>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
83372>>>>>        If (nByteCount  < 1) Begin
83374>>>>>            Send Seq_Release_Channel iChannel
83375>>>>>            Move True to SqlScriptArray.bError
83376>>>>>            Function_Return SqlScriptArray
83377>>>>>        End
83377>>>>>>
83377>>>>>
83377>>>>>        // If necessary change the string argument_size
83377>>>>>        // Read the script file from memory line-by-line
83377>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83379>>>>>            Move 0 to iCount
83380>>>>>            Repeat
83380>>>>>>
83380>>>>>                Readln channel iChannel sSQLScript
83382>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
83383>>>>>                Increment iCount
83384>>>>>            Until (SeqEof = True)
83386>>>>>        Close_Input channel iChannel
83388>>>>>        Send Seq_Release_Channel iChannel
83389>>>>>
83389>>>>>        // Finally "sanitize" the script by removing all comments.
83389>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
83390>>>>>
83390>>>>>        Function_Return SqlScriptArray
83391>>>>>    End_Function
83392>>>>>
83392>>>>>    Function _SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
83394>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
83394>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
83394>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
83394>>>>>        String[] sMsg aSQLQueryMessages
83396>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
83396>>>>>        TimeSpan tsQuery
83396>>>>>        tSqlErrorArray aSqlErrorArray
83396>>>>>        tSqlErrorArray aSqlErrorArray
83396>>>>>        tSQLConnection SQLConnection
83396>>>>>        tSQLConnection SQLConnection
83396>>>>>        Boolean bShowProgress
83396>>>>>
83396>>>>>        If (num_arguments > 4) Begin
83398>>>>>            Move bShowProgr to bShowProgress
83399>>>>>        End
83399>>>>>>
83399>>>>>        Get phoSQLManager to hoSql
83400>>>>>
83400>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
83401>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
83401>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
83401>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
83401>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
83401>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
83401>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
83401>>>>>        Get piChunkMax to iChunkMax
83402>>>>>        Move 0 to iChunkCounter
83403>>>>>        Move "" to sStmt
83404>>>>>
83404>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
83405>>>>>        Move (Character(13) + Character(10)) to sCR
83406>>>>>
83406>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83407>>>>>
83407>>>>>        Get phoSQLManager  to hoSQL
83408>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83410>>>>>            If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
83412>>>>>                Move (Pos(";", SQLConnection.sConnectionString)) to iPos
83413>>>>>                If (iPos > 0) Begin
83415>>>>>                    Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
83416>>>>>                    Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
83417>>>>>                End
83417>>>>>>
83417>>>>>            End
83417>>>>>>
83417>>>>>        End
83417>>>>>>
83417>>>>>        Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
83418>>>>>        Get SqlConnect     of hoSQL "" "" to hoSQLConnect
83419>>>>>
83419>>>>>        If (hoSQLConnect <> 0) Begin
83421>>>>>            Move False to Err
83422>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
83423>>>>>            If (hoStmt <> 0) Begin
83425>>>>>
83425>>>>>                // If the embedded resource should be written as a script file to disk:
83425>>>>>                If (bCreateScriptFile = True) Begin
83427>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
83428>>>>>                    Get vFolderFormat sExportFile to sExportFile
83429>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
83430>>>>>                    Get Seq_New_Channel to iOut
83431>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83433>>>>>                        Direct_Output channel iOut sExportFile
83435>>>>>                    End
83435>>>>>>
83435>>>>>                End
83435>>>>>>
83435>>>>>
83435>>>>>                // Record starting date/time stamp
83435>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
83436>>>>>                // Turn on error handling if enabled
83436>>>>>                If (pbHandleQueryErrors(Self)) Begin
83438>>>>>                    Set pbSqlError to False
83439>>>>>                    Set paSqlErrorArray to aSqlErrorArray
83440>>>>>                    Move Error_Object_Id to hoError
83441>>>>>                    Move Self to Error_Object_Id
83442>>>>>                End
83442>>>>>>
83442>>>>>
83442>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
83443>>>>>                Decrement iRows
83444>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
83446>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
83447>>>>>                End
83447>>>>>>
83447>>>>>
83447>>>>>                for iCount from 0 to iRows
83453>>>>>>
83453>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
83454>>>>>
83454>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
83456>>>>>                        If (sSQLVal <> "") Begin
83458>>>>>                            Move (sSQLVal + sCR) to sSQLVal
83459>>>>>                        End
83459>>>>>>
83459>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
83460>>>>>                    End
83460>>>>>>
83460>>>>>
83460>>>>>                    // - Each time we encounter a "GO" statement we execute it,
83460>>>>>                    // or if at the very end of the script.
83460>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
83462>>>>>
83462>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
83462>>>>>                        // instead of all in one go.
83462>>>>>                        Send SqlExecDirect of hoStmt sStmt
83463>>>>>
83463>>>>>                        If (bCreateScriptFile = True) Begin
83465>>>>>                            Write channel iOut sStmt
83467>>>>>                        End
83467>>>>>>
83467>>>>>                        Move "" to sStmt
83468>>>>>                        Move 0 to iChunkCounter
83469>>>>>                    End
83469>>>>>>
83469>>>>>                    Increment iChunkCounter
83470>>>>>                Loop
83471>>>>>>
83471>>>>>
83471>>>>>                Repeat
83471>>>>>>
83471>>>>>                    If (pbHandleQueryErrors(Self)) Begin
83473>>>>>                        Move hoError to Error_Object_Id
83474>>>>>                    End
83474>>>>>>
83474>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
83475>>>>>
83475>>>>>                    Send _SqlColumnInfo hoStmt
83476>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
83477>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83478>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
83479>>>>>                    Set piRows    to iRows
83480>>>>>                    Set piRowType to iRowType
83481>>>>>
83481>>>>>                    If (iMsgs <> 0) Begin
83483>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83485>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83486>>>>>                        End
83486>>>>>>
83486>>>>>                        for i from 1 to iMsgs
83492>>>>>>
83492>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
83493>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
83494>>>>>                            If (bShowProgress = True) Begin
83496>>>>>                                If (Active_State(ghoStatusPanel)) Begin
83498>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83499>>>>>                                End
83499>>>>>>
83499>>>>>                                Else Begin
83500>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83502>>>>>                                End
83502>>>>>>
83502>>>>>                            End
83502>>>>>>
83502>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
83503>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
83504>>>>>                        Loop
83505>>>>>>
83505>>>>>
83505>>>>>
83505>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83507>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83508>>>>>                        End
83508>>>>>>
83508>>>>>                        Set paQueryMessages to sMsg
83509>>>>>                    End
83509>>>>>>
83509>>>>>
83509>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
83510>>>>>                Until (iNextSet = 0)
83512>>>>>
83512>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
83513>>>>>            End
83513>>>>>>
83513>>>>>
83513>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
83514>>>>>            Set ptsQueryExec to tsQuery
83515>>>>>            Send SqlClose of hoStmt
83516>>>>>
83516>>>>>            If (bCreateScriptFile = True) Begin
83518>>>>>                Close_Output channel iOut
83520>>>>>                Send Seq_Release_Channel iOut
83521>>>>>            End
83521>>>>>>
83521>>>>>        End
83521>>>>>>
83521>>>>>        Send SqlDisconnect of hoSQLConnect
83522>>>>>
83522>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
83523>>>>>    End_Function
83524>>>>>
83524>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83526>>>>>        tSQLScriptArray SQLScriptArray
83526>>>>>        tSQLScriptArray SQLScriptArray
83526>>>>>        String sDriverID sCollation
83526>>>>>        Boolean bOK
83526>>>>>        Integer iSize iCount
83526>>>>>
83526>>>>>        If (Trim(sDatabaseName) = "") Begin
83528>>>>>            Function_Return False
83529>>>>>        End
83529>>>>>>
83529>>>>>
83529>>>>>        Get psDriverID  to sDriverID
83530>>>>>        Get psCollation to sCollation
83531>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83532>>>>>        If (SQLScriptArray.bError = True) Begin
83534>>>>>            Function_Return False
83535>>>>>        End
83535>>>>>>
83535>>>>>
83535>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83536>>>>>        Decrement iSize
83537>>>>>
83537>>>>>        For iCount from 0 to iSize
83543>>>>>>
83543>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83545>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83546>>>>>            End
83546>>>>>>
83546>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83548>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83549>>>>>            End
83549>>>>>>
83549>>>>>        Loop
83550>>>>>>
83550>>>>>
83550>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83551>>>>>
83551>>>>>        Function_Return (bOK = True)
83552>>>>>    End_Function
83553>>>>>
83553>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83555>>>>>        tSQLScriptArray SQLScriptArray
83555>>>>>        tSQLScriptArray SQLScriptArray
83555>>>>>        String sDriverID sCollation
83555>>>>>        Boolean bOK
83555>>>>>        Integer iSize iCount
83555>>>>>
83555>>>>>        If (Trim(sDatabaseName) = "") Begin
83557>>>>>            Function_Return False
83558>>>>>        End
83558>>>>>>
83558>>>>>
83558>>>>>        Get psDriverID  to sDriverID
83559>>>>>        Get psCollation to sCollation
83560>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83561>>>>>        If (SQLScriptArray.bError = True) Begin
83563>>>>>            Function_Return False
83564>>>>>        End
83564>>>>>>
83564>>>>>
83564>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83565>>>>>        Decrement iSize
83566>>>>>
83566>>>>>        For iCount from 0 to iSize
83572>>>>>>
83572>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83574>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83575>>>>>            End
83575>>>>>>
83575>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83577>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83578>>>>>            End
83578>>>>>>
83578>>>>>        Loop
83579>>>>>>
83579>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
83579>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83580>>>>>
83580>>>>>        Function_Return (bOK = True)
83581>>>>>    End_Function
83582>>>>>
83582>>>>>    Function _StrToFieldNumber Integer iFile String sField Returns Integer
83584>>>>>        Integer iMax iPos
83584>>>>>        String sName
83584>>>>>
83584>>>>>        Move (Lowercase(sField)) to sField
83585>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
83588>>>>>        For iPos from 0 to iMax
83594>>>>>>
83594>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
83597>>>>>            Move (Lowercase(sName)) to sName
83598>>>>>            If (sName = sField) Begin
83600>>>>>                Function_Return iPos
83601>>>>>            End
83601>>>>>>
83601>>>>>        Loop
83602>>>>>>
83602>>>>>        Function_Return -1
83603>>>>>    End_Function
83604>>>>>
83604>>>>>    // Checks if the passed connection id exists in the CLI interface.
83604>>>>>    // This might be needed by API-methods when a connection id is to be used and
83604>>>>>    // the connection id hasn't been established with the driver's CLI interface.
83604>>>>>    // NOTE: Only applicable for DAW drivers.
83604>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
83606>>>>>        String sID sConnString
83606>>>>>        Integer iDriver iNumConn iCount
83606>>>>>        Handle hoCLI
83606>>>>>        Boolean bOK
83606>>>>>
83606>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83607>>>>>        If (bOK = False) Begin
83609>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers."
83610>>>>>>
83610>>>>>            Function_Return False
83611>>>>>        End
83611>>>>>>
83611>>>>>
83611>>>>>        Move False to bOK
83612>>>>>        Get phoCLIHandler to hoCLI
83613>>>>>        If (hoCLI <> 0) Begin
83615>>>>>            Set psDriverID of hoCLI to sDriverID
83616>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
83617>>>>>
83617>>>>>            // If driver not loaded; load it.
83617>>>>>            If (iDriver = 0) Begin
83619>>>>>                Load_Driver sDriverID
83620>>>>>                Get DriverIndex sDriverID to iDriver
83621>>>>>            End
83621>>>>>>
83621>>>>>            If (iDriver <> 0) Begin
83623>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
83626>>>>>                Decrement iNumConn
83627>>>>>                For iCount from 0 to iNumConn
83633>>>>>>
83633>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
83636>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
83639>>>>>                    If (sID = sConnectionID) Begin
83641>>>>>                        Move True to bOK
83642>>>>>                    End
83642>>>>>>
83642>>>>>                Loop
83643>>>>>>
83643>>>>>            End
83643>>>>>>
83643>>>>>        End
83643>>>>>>
83643>>>>>
83643>>>>>        Function_Return bOK
83644>>>>>    End_Function
83645>>>>>
83645>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
83647>>>>>        Boolean bOK
83647>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
83648>>>>>        Function_Return bOK
83649>>>>>    End_Function
83650>>>>>
83650>>>>>    Function IsMSSQLDriver Returns Boolean
83652>>>>>        Integer iDriverIndex
83652>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
83653>>>>>        Function_Return (iDriverIndex <> 0)
83654>>>>>    End_Function
83655>>>>>
83655>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
83655>>>>>    // attempt to load the driver.
83655>>>>>    // Returns true if the passed driver is SQL based.
83655>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
83657>>>>>        Boolean bOK
83657>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83658>>>>>        Function_Return bOK
83659>>>>>    End_Function
83660>>>>>
83660>>>>>    // *** Error Handler ***
83660>>>>>    //
83660>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
83660>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
83660>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
83662>>>>>        Integer iSize iErrorMode
83662>>>>>        tSqlErrorArray aSqlErrorArray
83662>>>>>        tSqlErrorArray aSqlErrorArray
83662>>>>>
83662>>>>>        If (pbProcessingError(Self)) Begin
83664>>>>>            Procedure_Return
83665>>>>>        End
83665>>>>>>
83665>>>>>
83665>>>>>        Get Error_Report_Mode to iErrorMode
83666>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
83668>>>>>            Procedure_Return
83669>>>>>        End
83669>>>>>>
83669>>>>>
83669>>>>>        Set pbProcessingError to True
83670>>>>>        Set pbSqlError to True
83671>>>>>        Get paSqlErrorArray      to aSqlErrorArray
83672>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
83673>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
83674>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
83675>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
83676>>>>>        Set paSqlErrorArray      to aSqlErrorArray
83677>>>>>        Set pbProcessingError to False
83678>>>>>    End_Procedure
83679>>>>>
83679>>>>>    // *** Miscellanous Helper Functions ***
83679>>>>>    //
83679>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
83679>>>>>    // returns the table name only; stripped of any path or filename extension.
83679>>>>>    Function _TableNameOnly String sName Returns String
83681>>>>>        String sPath sExt
83681>>>>>
83681>>>>>        Get ParseFolderName sName to sPath
83682>>>>>        If (sPath <> "") Begin
83684>>>>>            Move (Replace(sPath, sName, "")) to sName
83685>>>>>        End
83685>>>>>>
83685>>>>>        Get ParseFileExtension sName to sExt
83686>>>>>        If (sExt <> "") Begin
83688>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
83689>>>>>        End
83689>>>>>>
83689>>>>>
83689>>>>>        Function_Return sName
83690>>>>>    End_Function
83691>>>>>
83691>>>>>    // Removes any prefix to a table name.
83691>>>>>    // Example mssqldrv:mytable returns mytable
83691>>>>>    //         dbo.mytable returns mytable
83691>>>>>    Function _TableNoPrefix String sName Returns String
83693>>>>>        Integer iPos
83693>>>>>
83693>>>>>        Move (Pos(":", sName)) to iPos
83694>>>>>        If (iPos <> 0) Begin
83696>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
83697>>>>>        End
83697>>>>>>
83697>>>>>        Move (Pos(".", sName)) to iPos
83698>>>>>        If (iPos <> 0) Begin
83700>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
83701>>>>>        End
83701>>>>>>
83701>>>>>
83701>>>>>        Function_Return sName
83702>>>>>    End_Function
83703>>>>>
83703>>>>>    // Returns the first datapath found in the psDataPath property.
83703>>>>>    // The returned path always ends with a "\"
83703>>>>>    Function psDataPathFirstPart Returns String
83705>>>>>        String sDataPath
83705>>>>>        Integer iCount
83705>>>>>
83705>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
83706>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
83707>>>>>        If (iCount > 1) Begin
83709>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
83710>>>>>        End
83710>>>>>>
83710>>>>>        If (sDataPath <> "") Begin
83712>>>>>            Get vFolderFormat sDataPath to sDataPath
83713>>>>>        End
83713>>>>>>
83713>>>>>
83713>>>>>        Function_Return sDataPath
83714>>>>>    End_Function
83715>>>>>
83715>>>>>    Function psLogTextFileWithPath Returns String
83717>>>>>        String sFileName
83717>>>>>        Handle hoLogFile
83717>>>>>        Get phoLogFile to hoLogFile
83718>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
83719>>>>>        Function_Return sFileName
83720>>>>>    End_Function
83721>>>>>
83721>>>>>    Function phoLogFile Returns Handle
83723>>>>>        Handle hoLogFile   
83723>>>>>        Boolean bErr
83723>>>>>        
83723>>>>>        Move Err to bErr
83724>>>>>        Move 0 to hoLogFile
83725>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
83726>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
83727>>>>>        Delegate Get phoLogFile to hoLogFile
83729>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
83730>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
83731>>>>>        Move bErr to Err
83732>>>>>        
83732>>>>>        Function_Return hoLogFile
83733>>>>>    End_Function
83734>>>>>
83734>>>>>    Function pnCurrentVersionUpdate Returns Number
83736>>>>>        Number nCurrentVersionUpdate
83736>>>>>
83736>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
83737>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
83739>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
83740>>>>>
83740>>>>>        Function_Return nCurrentVersionUpdate
83741>>>>>    End_Function
83742>>>>>
83742>>>>>    Procedure LogError String sText Boolean bError
83744>>>>>        Handle hoLogFile
83744>>>>>        Number nCurrentVersionUpdate
83744>>>>>
83744>>>>>        Get phoLogFile to hoLogFile
83745>>>>>        If (hoLogFile = 0) Begin
83747>>>>>            Procedure_Return
83748>>>>>        End
83748>>>>>>
83748>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
83749>>>>>
83749>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
83750>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
83751>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
83752>>>>>    End_Procedure
83753>>>>>
83753>>>>>    Function pbContinueOnError Returns Boolean
83755>>>>>        Boolean bContinueOnError
83755>>>>>        If (ghoDbUpdateHandler > 0) Begin
83757>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
83758>>>>>        End
83758>>>>>>
83758>>>>>        Function_Return bContinueOnError
83759>>>>>    End_Function
83760>>>>>
83760>>>>>
83760>>>>>    Function _UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
83762>>>>>        Integer iChIn iChOut // iCount
83762>>>>>        Boolean bExists
83762>>>>>        String sExistingColumn
83762>>>>>
83762>>>>>        Move False to bExists
83763>>>>>        Get Seq_New_Channel to iChIn
83764>>>>>        Get Seq_New_Channel to iChOut
83765>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83767>>>>>            Function_Return True
83768>>>>>        End
83768>>>>>>
83768>>>>>
83768>>>>>        Move False to Err
83769>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
83769>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
83771>>>>>        While (not(SeqEof))
83775>>>>>            Readln channel iChIn sExistingColumn
83777>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
83779>>>>>                Move True to bExists
83780>>>>>            End
83780>>>>>>
83780>>>>>            If (Trim(sExistingColumn) = "") Begin
83782>>>>>                Move True to SeqEof
83783>>>>>            End
83783>>>>>>
83783>>>>>        Loop
83784>>>>>>
83784>>>>>        Close_Input channel iChIn
83786>>>>>        Send Seq_Release_Channel iChIn
83787>>>>>
83787>>>>>        If (bExists = False) Begin
83789>>>>>            Append_Output channel iChOut sFullTAGFileName
83791>>>>>            Writeln channel iChOut sColumnName
83794>>>>>            Close_Output channel iChOut
83796>>>>>            Send Seq_Release_Channel iChOut
83797>>>>>        End
83797>>>>>>
83797>>>>>
83797>>>>>        Function_Return (Err = False)
83798>>>>>    End_Function
83799>>>>>
83799>>>>>    // Changes source code files.
83799>>>>>    // Pass a file name with full path and a value to search for, together with the value
83799>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
83799>>>>>    // to use a Connection ID.
83799>>>>>    // Sample: Get _UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
83799>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
83799>>>>>    // Returns True if no errors occured.
83799>>>>>    Function _UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
83801>>>>>        Integer iCh iRow iItems iCount
83801>>>>>        String sValue sRow
83801>>>>>        String[] sFileArray
83802>>>>>        Boolean bExists bIsActive
83802>>>>>
83802>>>>>        Move False to Err
83803>>>>>        Move 0 to iRow
83804>>>>>
83804>>>>>        If (ghoStatusPanel <> 0) Begin
83806>>>>>            Get Active_state of ghoStatusPanel to bIsActive
83807>>>>>        End
83807>>>>>>
83807>>>>>
83807>>>>>        Get vFilePathExists sFileName to bExists
83808>>>>>        If (bExists = False) Begin
83810>>>>>            If (bShowResult = True) Begin
83812>>>>>                If (bIsActive = True) Begin
83814>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
83815>>>>>                End
83815>>>>>>
83815>>>>>                Else Begin
83816>>>>>                    Showln "File does not exist: " sFileName
83819>>>>>                End
83819>>>>>>
83819>>>>>            End
83819>>>>>>
83819>>>>>            Function_Return False
83820>>>>>        End
83820>>>>>>
83820>>>>>
83820>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
83821>>>>>        If (iCh < 1) Begin
83823>>>>>            Function_Return False
83824>>>>>        End
83824>>>>>>
83824>>>>>
83824>>>>>        If (bShowResult = True) Begin
83826>>>>>            If (ghoStatusPanel <> 0) Begin
83828>>>>>                Get Active_state of ghoStatusPanel to bIsActive
83829>>>>>                If (bIsActive = True) Begin
83831>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
83832>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
83833>>>>>                    Send DoAdvance of ghoProgressBar
83834>>>>>                End
83834>>>>>>
83834>>>>>            End
83834>>>>>>
83834>>>>>            Else Begin
83835>>>>>                Showln ""
83837>>>>>                Showln "sFileName = " sFileName
83840>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
83845>>>>>            End
83845>>>>>>
83845>>>>>        End
83845>>>>>>
83845>>>>>
83845>>>>>        While (not(SeqEof))
83849>>>>>            Readln channel iCh sRow
83851>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
83853>>>>>//                If (bShowResult = True) Begin
83853>>>>>//                    If (bIsActive = True) Begin
83853>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
83853>>>>>//                    End
83853>>>>>//                    Else Begin
83853>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
83853>>>>>//                    End
83853>>>>>//                End
83853>>>>>                // Change the whole line to the new connection id:
83853>>>>>                Move sChangeTo to sRow
83854>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
83854>>>>>            End
83854>>>>>>
83854>>>>>            Move sRow to sFileArray[iRow]
83855>>>>>            Increment iRow
83856>>>>>        Loop
83857>>>>>>
83857>>>>>        Send Seq_Close_Channel iCh
83858>>>>>
83858>>>>>        Sleep 1 // Wait for Windows to close the file
83859>>>>>
83859>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
83860>>>>>        If (iCh < 1) Begin
83862>>>>>            Function_Return False
83863>>>>>        End
83863>>>>>>
83863>>>>>        Move (SizeOfArray(sFileArray)) to iItems
83864>>>>>        Decrement iItems
83865>>>>>
83865>>>>>        for iCount from 0 to iItems
83871>>>>>>
83871>>>>>            Move sFileArray[iCount] to sValue
83872>>>>>            Writeln channel iCh sValue
83875>>>>>        Loop
83876>>>>>>
83876>>>>>        Send Seq_Close_Channel iCh
83877>>>>>
83877>>>>>        Function_Return (Err = False)
83878>>>>>    End_Function
83879>>>>>
83879>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
83879>>>>>    // and opens it in "notepad.exe".
83879>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
83879>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
83879>>>>>    Procedure _UtilShowErrorList
83881>>>>>        tSqlErrorArray aSqlErrorArray
83881>>>>>        tSqlErrorArray aSqlErrorArray
83881>>>>>        Integer iRows iCount iCh iErrorNum
83881>>>>>        String sPath sFileName sErrorTxt sStatement
83881>>>>>
83881>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
83882>>>>>        Get vFolderFormat sPath to sPath
83883>>>>>        Move "SQLErrorLog.txt"  to sFileName
83884>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
83885>>>>>            Get paSqlErrorArray to aSqlErrorArray
83886>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
83887>>>>>            If (iRows > 0) Begin
83889>>>>>                Decrement iRows
83890>>>>>                for iCount from 0 to iRows
83896>>>>>>
83896>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
83897>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
83898>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
83899>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
83905>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
83909>>>>>                Loop
83910>>>>>>
83910>>>>>            End
83910>>>>>>
83910>>>>>        Send Seq_Close_Channel iCh
83911>>>>>
83911>>>>>        If (iRows > 0) Begin
83913>>>>>            Runprogram Shell Background (sPath + sFileName)
83914>>>>>        End
83914>>>>>>
83914>>>>>    End_Procedure
83915>>>>>
83915>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
83915>>>>>    // and the table needs to exist as an SQL table.
83915>>>>>    Function _UtilTableIsSql Handle hTable Returns Boolean
83917>>>>>        String sRootName sDriverID
83917>>>>>        Boolean bIsSQL
83917>>>>>
83917>>>>>        Move False to bIsSQL
83918>>>>>        If (hTable > 0) Begin
83920>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
83923>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
83924>>>>>            If (bIsSQL = True) Begin
83926>>>>>                Get psDriverID to sDriverID
83927>>>>>                Get _TableNameOnly sRootName to sRootName
83928>>>>>                Get _SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
83929>>>>>            End
83929>>>>>>
83929>>>>>        End
83929>>>>>>
83929>>>>>
83929>>>>>        Function_Return bIsSQL
83930>>>>>    End_Function
83931>>>>>
83931>>>>>    Function _UtilTableIsSqlByRootName String sRootName Returns Boolean
83933>>>>>        Boolean bIsSQL
83933>>>>>        Move (sRootName contains ":") to bIsSQL
83934>>>>>        Function_Return bIsSQL
83935>>>>>    End_Function
83936>>>>>
83936>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
83936>>>>>    Function _SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
83938>>>>>        String sDatabase sSchema sVal
83938>>>>>        Boolean bExists
83938>>>>>        String[] sTablesArray
83939>>>>>        Integer iSize iCount
83939>>>>>
83939>>>>>        Move False to bExists
83940>>>>>        Get psDatabase to sDatabase
83941>>>>>        Get psSchema   to sSchema
83942>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
83943>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
83944>>>>>        Decrement iSize
83945>>>>>        for iCount from 0 to iSize
83951>>>>>>
83951>>>>>            Move sTablesArray[iCount] to sVal
83952>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
83954>>>>>                Move True to bExists
83955>>>>>                Move iSize to iCount // We're done!
83956>>>>>            End
83956>>>>>>
83956>>>>>        Loop
83957>>>>>>
83957>>>>>
83957>>>>>        Function_Return bExists
83958>>>>>    End_Function
83959>>>>>
83959>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
83959>>>>>    // that the embedded .dat file exists on disk.
83959>>>>>    Function _UtilTableIsEmbedded Handle hTable Returns Boolean
83961>>>>>        Boolean bExists bIsEmbedded
83961>>>>>        String sDataPath sRootName
83961>>>>>
83961>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
83962>>>>>        If (bExists = False) Begin
83964>>>>>            Function_Return False
83965>>>>>        End
83965>>>>>>
83965>>>>>
83965>>>>>        Move False to bIsEmbedded
83966>>>>>        If (hTable > 0) Begin
83968>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
83971>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
83972>>>>>        End
83972>>>>>>
83972>>>>>        If (bIsEmbedded = True) Begin
83974>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
83975>>>>>            Get vFolderFormat sDataPath to sDataPath
83976>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
83977>>>>>        End
83977>>>>>>
83977>>>>>
83977>>>>>        Function_Return bIsEmbedded
83978>>>>>    End_Function
83979>>>>>
83979>>>>>End_Class
83980>>>
83980>>>Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib
83981>>>
83981>>>    Procedure Construct_Object
83983>>>        Forward Send Construct_Object
83985>>>        Move Self to ghoDbUpdateFunctionLibrary
83986>>>    End_Procedure
83987>>>
83987>>>    Procedure End_Construct_Object
83989>>>        Forward Send End_Construct_Object
83991>>>    End_Procedure
83992>>>
83992>>>    // *** SQL Messages for making changes to the SQL back-end ***
83992>>>    //
83992>>>    // * Dummy function for the Studio's Code Explorer *
83992>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
83994>>>        Function_Return False
83995>>>    End_Function
83996>>>
83996>>>    // Function for creating a new *Database*.
83996>>>    // Note: This is for creating SQL DATABASES - not tables!
83996>>>    // Returns True if successful.
83996>>>    // ToDo: Currently only works for MS-SQL...
83996>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
83998>>>        String sSQL sSQL1 sConnectionID sConnectionString
83998>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
83998>>>        Handle hConnection hStmt hoSQLManager
83998>>>        Integer iFetchResult iDbType
83998>>>        Boolean bOK bExists
83998>>>
83998>>>        Get piDbType to iDbType
83999>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
84001>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 drivers"
84002>>>>
84002>>>            Function_Return False
84003>>>        End
84003>>>>
84003>>>
84003>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
84004>>>        If (bExists = True) Begin
84006>>>            Function_Return True
84007>>>        End
84007>>>>
84007>>>
84007>>>        Get phoSQLManager to hoSQLManager
84008>>>
84008>>>        Get psConnectionID     to sConnectionID
84009>>>        Get psConnectionString to sConnectionString
84010>>>        Move 0 to LastErr
84011>>>
84011>>>        If (sDriverID = ODBC_DRV_ID) Begin
84013>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
84013>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
84013>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
84013>>>//                Move (Pos(";", sConnectionString)) to iPos
84013>>>//                If (iPos > 0) Begin
84013>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
84013>>>//                    Move (Trim(sConnectionString)) to sConnectionString
84013>>>//                End
84013>>>//            End
84013>>>        End
84013>>>>
84013>>>
84013>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84014>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84015>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84016>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84018>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
84019>>>>
84019>>>            Function_Return False
84020>>>        End
84020>>>>
84020>>>
84020>>>        Get SqlOpen of hConnection to hStmt
84021>>>
84021>>>        If (hStmt = 0) Begin
84023>>>            Send SqlDisconnect of hoSQLManager
84024>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84025>>>>
84025>>>            Function_Return False
84026>>>        End
84026>>>>
84026>>>
84026>>>        Get psCollation to sCollation
84027>>>
84027>>>        Case Begin
84027>>>            Case (sDriverID = MSSQLDRV_ID)
84029>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84030>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
84031>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
84032>>>
84032>>>                // Check if database exists
84032>>>                Send SqlExecDirect of hStmt sSQL
84033>>>                Get SqlFetch of hStmt to iFetchResult
84034>>>                Send SqlClose of hStmt
84035>>>                Send SqlDisconnect of hConnection
84036>>>                // If database already exists we're out of here!
84036>>>                // Note that we return True as this is not an error.
84036>>>                If (iFetchResult > 0) Begin
84038>>>                    Function_Return True
84039>>>                End
84039>>>>
84039>>>                // Database doesn't exist, create it.
84039>>>                If (iFetchResult = 0) Begin
84041>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84042>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84043>>>                    If (sCollation <> "") Begin
84045>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84046>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
84047>>>                    End
84047>>>>
84047>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
84048>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84049>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
84051>>>                        Function_Return False
84052>>>                    End
84052>>>>
84052>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84052>>>                    Sleep 1
84053>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
84054>>>                End
84054>>>>
84054>>>                Case Break
84055>>>
84055>>>            Case (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID)
84058>>>                // ToDo: How should this be set/checked?
84058>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
84058>>>//                    Set psCollation to "utf8"
84058>>>//                End
84058>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
84058>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
84059>>>                Case Break
84060>>>
84060>>>            Case Else
84060>>>                Error DFERR_PROGRAM "Unsupported database type"
84061>>>>
84061>>>        Case End
84061>>>
84061>>>        If (Err = False) Begin
84063>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
84064>>>        End
84064>>>>
84064>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
84064>>>        // the one we just created.
84064>>>        If (bUpdateConnectionString = True and Err = False) Begin
84066>>>            Set psDatabase to sDatabase
84067>>>            //...and perhaps also the SQLConnections.ini file setting.
84067>>>            If (bPermanantly = True) Begin
84069>>>                If (ghoSQLConnectionHandler <> 0) Begin
84071>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84072>>>                End
84072>>>>
84072>>>            End
84072>>>>
84072>>>        End
84072>>>>
84072>>>
84072>>>        Function_Return (Err = False)
84073>>>    End_Function
84074>>>
84074>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
84074>>>    // will be used.
84074>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
84076>>>        Boolean bOK bExists bShowProgress bErr
84076>>>        String sStatement sDriverID
84076>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84076>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84076>>>        Integer iDbType
84076>>>
84076>>>        If (sDatabase = "") Begin
84078>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84079>>>>
84079>>>            Function_Return False
84080>>>        End
84080>>>>
84080>>>        If (sBackupName = "") Begin
84082>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84083>>>>
84083>>>            Function_Return False
84084>>>        End
84084>>>>
84084>>>
84084>>>        // Create backup-folder if it doesn't exist
84084>>>        Get vFolderExists sPath to bExists
84085>>>        If (bExists = False) Begin
84087>>>            Get vCreateDirectory sPath to bErr
84088>>>            If (bErr = True) Begin
84090>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
84091>>>>
84091>>>                Function_Return False
84092>>>            End
84092>>>>
84092>>>        End
84092>>>>
84092>>>        // Make sure the path ends with a back-slash
84092>>>        If (sPath <> "") Begin
84094>>>            Get vFolderFormat sPath to sPath
84095>>>        End
84095>>>>
84095>>>
84095>>>        Get psDriverID to sDriverID
84096>>>        Get piDbType   to iDbType
84097>>>        If (num_arguments > 3) Begin
84099>>>            Move bShowProg to bShowProgress
84100>>>        End
84100>>>>
84100>>>
84100>>>        Case Begin
84100>>>            Case (iDbType = EN_DbTypeMSSQL)
84102>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
84102>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
84102>>>                Get _SqlUtilReadResource  "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
84103>>>                Get _SqlUtilReadResource "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
84104>>>
84104>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84105>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
84106>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
84107>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
84108>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
84109>>>                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" bShowProgress to bOK
84110>>>                Case Break
84111>>>            Case Else
84111>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84112>>>        Case End
84112>>>
84112>>>        Function_Return bOK
84113>>>    End_Function
84114>>>
84114>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
84116>>>        String sStatement sDriverID sRetval //sPrevious
84116>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84116>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84116>>>        Integer iDbType iRows iFetchResult //iColumn
84116>>>        Handle hoSQLHandler hoSQLConnect hstmt
84116>>>        tSQLConnection SQLConnection
84116>>>        tSQLConnection SQLConnection
84116>>>
84116>>>        If (sDatabase = "") Begin
84118>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
84119>>>>
84119>>>            Function_Return ""
84120>>>        End
84120>>>>
84120>>>
84120>>>        Move "" to sRetval
84121>>>        Get psDriverID to sDriverID
84122>>>        Get piDbType   to iDbType
84123>>>
84123>>>        Case Begin
84123>>>            Case (iDbType = EN_DbTypeMSSQL)
84125>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
84125>>>                Get _SqlUtilReadResource "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
84126>>>
84126>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84127>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
84128>>>                Get phoSQLManager to hoSQLHandler
84129>>>
84129>>>                If (hoSQLHandler <> 0) Begin
84131>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84132>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
84133>>>
84133>>>                    If (hoSQLConnect <> 0) Begin
84135>>>                        Get SQLOpen of hoSQLConnect to hstmt
84136>>>                        If (hstmt <> 0) Begin
84138>>>                            Send SqlExecDirect of hstmt sStatement
84139>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
84140>>>                            Get SQLFetch of hstmt to iFetchResult
84141>>>                            If (iFetchResult <> 0) Begin
84143>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
84144>>>                            End
84144>>>>
84144>>>                            Send SQLClose of hstmt
84145>>>                        End
84145>>>>
84145>>>                        Send SQLDisconnect of hoSQLConnect
84146>>>                    End
84146>>>>
84146>>>                End
84146>>>>
84146>>>                Case Break
84147>>>            Case Else
84147>>>                If (bSilent = False) Begin
84149>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
84150>>>                End
84150>>>>
84150>>>        Case End
84150>>>
84150>>>        Function_Return sRetval
84151>>>    End_Function
84152>>>
84152>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
84154>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
84154>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
84154>>>        Handle hConnection hStmt hoSQLManager
84154>>>        Integer iDbType // iFetchResult
84154>>>
84154>>>        If (sDatabase = "") Begin
84156>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84157>>>>
84157>>>            Function_Return False
84158>>>        End
84158>>>>
84158>>>
84158>>>        If (sSQLCollation = "") Begin
84160>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84161>>>>
84161>>>            Function_Return False
84162>>>        End
84162>>>>
84162>>>
84162>>>        Get psDriverID to sDriverID
84163>>>        Get piDbType   to iDbType
84164>>>
84164>>>        Get phoSQLManager to hoSQLManager
84165>>>        Get psConnectionID     to sConnectionID
84166>>>        Get psConnectionString to sConnectionString
84167>>>        Move 0 to LastErr
84168>>>
84168>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84169>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84170>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84171>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84173>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84174>>>>
84174>>>            Function_Return False
84175>>>        End
84175>>>>
84175>>>
84175>>>        Get SqlOpen of hConnection to hStmt
84176>>>
84176>>>        If (hStmt = 0) Begin
84178>>>            Send SqlDisconnect of hoSQLManager
84179>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84180>>>>
84180>>>            Function_Return False
84181>>>        End
84181>>>>
84181>>>
84181>>>        // Check if collation already exists
84181>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
84182>>>        // If the current collate is the same as the new; do nothing.
84182>>>        If (sSQLCollation = sSQLCollationCheck) Begin
84184>>>            Function_Return True
84185>>>        End
84185>>>>
84185>>>
84185>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
84186>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
84187>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
84188>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
84189>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
84190>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
84191>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
84192>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84193>>>
84193>>>        // MS-SQL Syntax:
84193>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
84193>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
84193>>>        // ALTER DATABASE [database] SET MULTI_USER;
84193>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
84194>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84195>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
84196>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84196>>>
84196>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84197>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
84198>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84199>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
84201>>>           Function_Return False
84202>>>        End
84202>>>>
84202>>>
84202>>>        Function_Return (Err = False)
84203>>>    End_Function
84204>>>
84204>>>
84204>>>    // * Dummy function for the Studio's Code Explorer *
84204>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
84206>>>        Function_Return False
84207>>>    End_Function
84208>>>
84208>>>    // Converts from SQL to Embedded (DataFlex .dat files).
84208>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
84208>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
84208>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
84208>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
84208>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
84210>>>        Handle hToTable
84210>>>        Boolean bOK bExists bOpened bCopyData
84210>>>        String sDriverID sPhysicalName sRootName sDisplayName
84210>>>        tSQLConnection SQLConnection
84210>>>        tSQLConnection SQLConnection
84210>>>        Integer iPos iMaxRecords
84210>>>
84210>>>        Get psDriverID to sDriverID
84211>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
84212>>>        If (bExists = False) Begin
84214>>>            Function_Return False
84215>>>        End
84215>>>>
84215>>>
84215>>>        If (num_arguments > 1) Begin
84217>>>            Move bCpyDat to bCopyData
84218>>>        End
84218>>>>
84218>>>        Else Begin
84219>>>            Move False to bCopyData
84220>>>        End
84220>>>>
84220>>>
84220>>>        Open hTable
84222>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84225>>>        If (bOpened = False) Begin
84227>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
84228>>>>
84228>>>            Function_Return False
84229>>>        End
84229>>>>
84229>>>        Move 0 to hToTable
84230>>>
84230>>>        Move 16711679 to iMaxRecords
84231>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84234>>>        Move (Pos(".", sDisplayName)) to iPos
84235>>>        If (iPos > 0) Begin
84237>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
84238>>>        End
84238>>>>
84238>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84241>>>        Get _TableNameOnly sRootName                 to sRootName
84242>>>        Move (sRootName + ".dat")                    to sPhysicalName
84243>>>
84243>>>        If (ghoProgressBar <> 0) Begin
84245>>>            Send DoAdvance of ghoProgressBar
84246>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
84247>>>        End
84247>>>>
84247>>>
84247>>>        Move False to Err
84248>>>
84248>>>        Structure_Start hToTable DATAFLEX_ID
84249>>>            Structure_Copy hTable to hToTable
84250>>>
84250>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
84253>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
84256>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
84259>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
84262>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
84265>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84266>>>
84266>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84268>>>
84268>>>        Set Action_Text of ghoStatusPanel to ""
84269>>>        Move (not(Err)) to bOK
84270>>>        If (bOK = True and bCopyData = True) Begin
84272>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
84273>>>        End
84273>>>>
84273>>>
84273>>>        // This must be after copying data...
84273>>>        If (Err = False) Begin
84275>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84278>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84281>>>        End
84281>>>>
84281>>>        Move (not(Err)) to bOK
84282>>>
84282>>>        Function_Return (bOK = True)
84283>>>    End_Function
84284>>>
84284>>>    // Creates an SQL Table at the SQL end by its filelist number;
84284>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84284>>>    Function SqlTableCreate Integer hTable Returns Boolean
84286>>>        String sTableName sSQLString sPath sCreateTable sDriverID
84286>>>        Integer iDbType
84286>>>        Boolean bExists
84286>>>
84286>>>        Get psDriverID to sDriverID
84287>>>        Get UtilTableHandleToString hTable to sTableName
84288>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84289>>>        If (bExists = True) Begin
84291>>>            Function_Return False
84292>>>        End
84292>>>>
84292>>>
84292>>>        Get psDataPathFirstPart to sPath
84293>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84294>>>
84294>>>        Get piDbType to iDbType
84295>>>        Get _SqlProperTableName sTableName to sTableName
84296>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84297>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84298>>>
84298>>>        Move False to Err
84299>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84300>>>
84300>>>        Function_Return (Err = False)
84301>>>    End_Function
84302>>>
84302>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
84302>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84302>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
84304>>>        String sSQLString sPath sCreateTable sDriverID
84304>>>        Integer iDbType
84304>>>        Boolean bExists
84304>>>
84304>>>        Get psDriverID to sDriverID
84305>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84306>>>        If (bExists = True) Begin
84308>>>            Function_Return False
84309>>>        End
84309>>>>
84309>>>
84309>>>        Get psDataPathFirstPart to sPath
84310>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84311>>>        If (bExists = True) Begin
84313>>>            // ToDo: What should we do if an .int file already exists?
84313>>>        End
84313>>>>
84313>>>
84313>>>        Get piDbType to iDbType
84314>>>        Get _SqlProperTableName sTableName to sTableName
84315>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84316>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84317>>>
84317>>>        Move False to Err
84318>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84319>>>
84319>>>        Function_Return (Err = False)
84320>>>    End_Function
84321>>>    
84321>>>    // ToDo: 2019-09-23 This needs to be finilized 
84321>>>    // It resets SQL constraints after a Structure_End, if necessary.
84321>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
84323>>>        Boolean bOK                                                            
84323>>>        String sStatement
84323>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
84324>>>        Function_Return bOK
84325>>>    End_Function
84326>>>    
84326>>>    // First deletes the data cache file and then drops the passed SQL table.
84326>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
84326>>>    //       else try using the SqlTableRemoveByTableName message.
84326>>>    Function SqlTableRemove Handle hTable Returns Boolean
84328>>>        String sSQLString sPath sDropTable sTableName sDriverID
84328>>>        Integer iRetval iDbType
84328>>>        Boolean bExists bOK
84328>>>
84328>>>        Get psDriverID to sDriverID
84329>>>        Get UtilTableHandleToString hTable to sTableName
84330>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84331>>>        If (bExists = False) Begin
84333>>>            Function_Return False
84334>>>        End
84334>>>>
84334>>>
84334>>>        Get psDataPathFirstPart to sPath
84335>>>        Get _UtilDeleteCacheFile sTableName to iRetval
84336>>>
84336>>>        Get piDbType to iDbType
84337>>>        Get _SqlProperTableName sTableName to sTableName
84338>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84339>>>        Move (sDropTable * String(sTableName)) to sSQLString
84340>>>
84340>>>        Move False to Err
84341>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84342>>>
84342>>>        // We also need to remove the cache-file since the table has been changed
84342>>>        Get _UtilDeleteCacheFile sTableName to bOK
84343>>>
84343>>>        Function_Return (Err = False)
84344>>>    End_Function
84345>>>
84345>>>    // First deletes the data cache file and then drops the passed data table.
84345>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
84347>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
84347>>>        Integer iRetval iDbType
84347>>>        Boolean bOK
84347>>>
84347>>>        Get psDriverID to sDriverID
84348>>>        Get psDataPathFirstPart to sPath
84349>>>        Get _UtilDeleteCacheFile sTableName to iRetval
84350>>>
84350>>>        Get piDbType to iDbType
84351>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84352>>>        Get psSchema to sSchema
84353>>>        If (sSchema = "") Begin
84355>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
84356>>>        End
84356>>>>
84356>>>        Move (Uppercase(sTableName)) to sVal
84357>>>        If (not(sVal contains (sSchema + "."))) Begin
84359>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
84360>>>        End
84360>>>>
84360>>>        Move (sDropTable * String(sTableName)) to sSQLString
84361>>>
84361>>>        Move False to Err
84362>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84363>>>
84363>>>        // We also need to remove the cache-file since the table has been changed
84363>>>        Get _UtilDeleteCacheFile sTableName to bOK
84364>>>
84364>>>        Function_Return (Err = False)
84365>>>    End_Function
84366>>>
84366>>>    // *** Sql View Messages ***
84366>>>
84366>>>    // First deletes the data cache file and then drops the passed Sql data view.
84366>>>    Function SqlViewRemove String sDataView Returns Boolean
84368>>>        String sDriverID sSQLString sDropViewKeyWord
84368>>>        Integer iRetval
84368>>>        Boolean bOK
84368>>>
84368>>>        Get psDriverID to sDriverID
84369>>>        Get _UtilDeleteCacheFile sDataView to iRetval
84370>>>
84370>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
84371>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
84372>>>        Set psSQLStatementString to sSQLString
84373>>>
84373>>>        // As we don't check if the view exist or not, it might happen
84373>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
84373>>>        Move False to Err
84374>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84375>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84376>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84377>>>        Move 0 to LastErr
84378>>>
84378>>>        // We also need to remove the cache-file since the table has been changed
84378>>>        Get _UtilDeleteCacheFile sDataView to bOK
84379>>>
84379>>>        Function_Return (Err = False)
84380>>>    End_Function
84381>>>
84381>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
84383>>>        Boolean bOK
84383>>>        Integer iDbType
84383>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
84383>>>
84383>>>        Get psDriverID to sDriverID
84384>>>        Get piDbType   to iDbType
84385>>>
84385>>>        Case Begin
84385>>>            Case (iDbType = EN_DbTypeDB2)
84387>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84388>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84389>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84390>>>            Break
84391>>>
84391>>>            Case (iDbType = EN_DbTypeMSSQL)
84394>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84395>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84396>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
84397>>>            Break
84398>>>
84398>>>            Case (iDbType = EN_DbTypeOracle)
84401>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84402>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84403>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84404>>>            Break
84405>>>
84405>>>            Case (iDbType = EN_DbTypePostgre)
84408>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84409>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84410>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84411>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
84412>>>            Break
84413>>>
84413>>>            Case (iDbType = EN_DbTypeMySQL)
84416>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84417>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84418>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
84419>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84420>>>            Break
84421>>>        Case End
84421>>>
84421>>>        Move False to Err
84422>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84423>>>        Move (Err = False) to bOK
84424>>>
84424>>>        Function_Return bOK
84425>>>    End_Function
84426>>>
84426>>>    // * Dummy function for the Studio's Code Explorer *
84426>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
84428>>>        Function_Return False
84429>>>    End_Function
84430>>>
84430>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
84430>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84432>>>        Integer iLength iDecimals
84432>>>        String sColumnValue
84432>>>        String sTableName sDriverID
84432>>>        Boolean bOK bInitializeValue
84432>>>
84432>>>        Get psDriverID to sDriverID
84433>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84434>>>        If (bOK = False) Begin
84436>>>            Function_Return False
84437>>>        End
84437>>>>
84437>>>
84437>>>        Get UtilTableHandleToString hTable to sTableName
84438>>>        If (sTableName = "") Begin
84440>>>            Function_Return False
84441>>>        End
84441>>>>
84441>>>
84441>>>        If (num_arguments > 3) Begin
84443>>>            Move iLen     to iLength
84444>>>            Move iDec     to iDecimals
84445>>>            Move bInitVal to bInitializeValue
84446>>>            Move sColVal  to sColumnValue
84447>>>        End
84447>>>>
84447>>>
84447>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
84448>>>
84448>>>        Function_Return (bOK = True)
84449>>>    End_Function
84450>>>
84450>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
84450>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84452>>>        Integer iDbType iLength iDecimals iDriver
84452>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
84452>>>        String sDriverID sNotNull
84452>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
84452>>>        Handle hTable
84452>>>
84452>>>        Get psDriverID to sDriverID
84453>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84454>>>        If (bOK = False) Begin
84456>>>            Function_Return True
84457>>>        End
84457>>>>
84457>>>
84457>>>        Get UtilTableNameToHandle sTableName to hTable
84458>>>        If (hTable = 0) Begin
84460>>>            Get NextFreeFilelistSlot to hTable
84461>>>        End
84461>>>>
84461>>>
84461>>>        Get piDbType to iDbType
84462>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
84462>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84463>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
84465>>>            Function_Return True
84466>>>        End
84466>>>>
84466>>>
84466>>>        Get DriverIndex sDriverID to iDriver
84467>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84470>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84473>>>
84473>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84474>>>        If (num_arguments > 3) Begin
84476>>>            Move iLen     to iLength
84477>>>            Move iDec     to iDecimals
84478>>>            Move bInitVal to bInitializeValue
84479>>>            Move sColVal  to sColumnValue
84480>>>        End
84480>>>>
84480>>>
84480>>>        Get _SqlProperTableName sTableName   to sTableName
84481>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
84482>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
84483>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84484>>>
84484>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84485>>>        If (bFixed = False) Begin
84487>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84488>>>        End
84488>>>>
84488>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84489>>>
84489>>>        Move False to Err
84490>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84491>>>
84491>>>        If (bInitializeValue = True and Err = False) Begin
84493>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
84494>>>        End
84494>>>>
84494>>>
84494>>>        If (Err = False) Begin
84496>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
84497>>>        End
84497>>>>
84497>>>
84497>>>        Move (not(Err)) to bRetval
84498>>>
84498>>>        // We also need to remove the cache-file since the table has been changed
84498>>>        Get _UtilDeleteCacheFile sTableName to bOK
84499>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84502>>>
84502>>>        Function_Return bRetval
84503>>>    End_Function
84504>>>
84504>>>    // To update all current rows for a table column with a common value.
84504>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
84506>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
84506>>>        Boolean bRetval bSQLDriver
84506>>>        Integer iCurrErr iDbType
84506>>>
84506>>>        Move False to bRetval
84507>>>        Get piDbType to iDbType
84508>>>        Get psDriverID to sDriverID
84509>>>        Get IsSQLDriver sDriverID to bSQLDriver
84510>>>        If (bSQLDriver = False) Begin
84512>>>            Function_Return bRetval
84513>>>        End
84513>>>>
84513>>>        Get UtilTableHandleToString hTable to sTableName
84514>>>
84514>>>        Move Err to iCurrErr
84515>>>        Move False to Err
84516>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
84517>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
84518>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
84519>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
84519>>>        If (iDbType = EN_DbTypeMySQL) Begin
84521>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
84522>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84523>>>        End
84523>>>>
84523>>>        Else Begin
84524>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84525>>>        End
84525>>>>
84525>>>
84525>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84526>>>        Move (Err = False) to bRetval
84527>>>        Move iCurrErr to Err
84528>>>
84528>>>        Function_Return bRetval
84529>>>    End_Function
84530>>>
84530>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84530>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84530>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84532>>>        String sDriverID sTableName
84532>>>        Boolean bOK
84532>>>
84532>>>        Get psDriverID to sDriverID
84533>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84534>>>        If (bOK = False) Begin
84536>>>            Function_Return False
84537>>>        End
84537>>>>
84537>>>
84537>>>        Get UtilTableHandleToString hTable to sTableName
84538>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
84539>>>
84539>>>        Function_Return (Err = False)
84540>>>    End_Function
84541>>>
84541>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
84541>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84541>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84541>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84543>>>        Integer iDbType iLength iDecimals
84543>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
84543>>>        Boolean bExists bOK bFixed
84543>>>        Handle hTable
84543>>>
84543>>>        Get psDriverID to sDriverID
84544>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84545>>>        If (bOK = False) Begin
84547>>>            Function_Return False
84548>>>        End
84548>>>>
84548>>>
84548>>>        Get UtilTableNameToHandle sTableName to hTable
84549>>>        If (hTable = 0) Begin
84551>>>            Get NextFreeFilelistSlot to hTable
84552>>>        End
84552>>>>
84552>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
84553>>>        If (bExists = False) Begin
84555>>>            Function_Return False
84556>>>        End
84556>>>>
84556>>>
84556>>>        If (num_arguments > 3) Begin
84558>>>            Move iLen to iLength
84559>>>        End
84559>>>>
84559>>>        If (num_arguments > 4) Begin
84561>>>            Move iDec to iDecimals
84562>>>        End
84562>>>>
84562>>>
84562>>>        Get piDbType to iDbType
84563>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84564>>>
84564>>>        Move False to Err
84565>>>        Get _SqlProperTableName sTableName    to sTableName
84566>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84567>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
84568>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84569>>>
84569>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84570>>>        If (bFixed = False) Begin
84572>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84573>>>        End
84573>>>>
84573>>>
84573>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84574>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84575>>>
84575>>>        // We also need to remove the cache-file since the table has been changed
84575>>>        Get _UtilDeleteCacheFile sTableName to bOK
84576>>>
84576>>>        Function_Return (Err = False)
84577>>>    End_Function
84578>>>
84578>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
84580>>>        Boolean bOK bErr bIsSQLDriver
84580>>>        String sDriverID
84580>>>        Integer iDataType
84580>>>
84580>>>        Get psDriverID to sDriverID
84581>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84582>>>        If (bIsSQLDriver = False) Begin
84584>>>            Function_Return False
84585>>>        End
84585>>>>
84585>>>
84585>>>        Move Err to bErr
84586>>>        Move False to bErr
84587>>>
84587>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
84587>>>        // inserts randomly character(10) and spaces, so we correct from that here:
84587>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
84588>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
84591>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
84593>>>            Move ("[" + String(sValue) + "]") to sValue
84594>>>        End
84594>>>>
84594>>>
84594>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
84597>>>        Move (not(Err)) to bOK
84598>>>        Move bErr to Err
84599>>>
84599>>>        Function_Return bOK
84600>>>    End_Function
84601>>>
84601>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
84603>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
84603>>>        String sDriverID
84603>>>
84603>>>        Get psDriverID to sDriverID
84604>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84605>>>        If (bIsSQLDriver = False) Begin
84607>>>            Function_Return False
84608>>>        End
84608>>>>
84608>>>
84608>>>        Move Err to bErr
84609>>>        Move False to bErr
84610>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
84613>>>        If (bNullable = bCurrentState) Begin
84615>>>            Function_Return True
84616>>>        End
84616>>>>
84616>>>
84616>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
84619>>>        If (bOpen = False) Begin
84621>>>            Get AutoConnectionIDLogin to bOK
84622>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84623>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84624>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84625>>>            Open hTable
84627>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84628>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84629>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84630>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
84633>>>        End
84633>>>>
84633>>>        If (bOpen = True) Begin
84635>>>            Structure_Start hTable sDriverID
84636>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
84639>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
84640>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84642>>>            Set Action_Text of ghoStatusPanel to ""
84643>>>        End
84643>>>>
84643>>>
84643>>>        Move (not(Err)) to bOK
84644>>>        Move bErr to Err
84645>>>
84645>>>        Function_Return bOK
84646>>>    End_Function
84647>>>
84647>>>    // Drop column by its table handle
84647>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
84649>>>        String sDriverID sTableName
84649>>>        Boolean bOK
84649>>>
84649>>>        Get psDriverID to sDriverID
84650>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84651>>>        If (bOK = False) Begin
84653>>>            Function_Return False
84654>>>        End
84654>>>>
84654>>>
84654>>>        Get UtilTableHandleToString hTable to sTableName
84655>>>        If (sTableName = "") Begin
84657>>>            Function_Return False
84658>>>        End
84658>>>>
84658>>>
84658>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
84659>>>
84659>>>        Function_Return (bOK = True)
84660>>>    End_Function
84661>>>
84661>>>    // Drop column by its table name as a string.
84661>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
84663>>>        Integer iDbType iDriver
84663>>>        String sDriverID sStmt sAlterTable sDropColumn
84663>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
84663>>>        Handle hTable
84663>>>
84663>>>        Get psDriverID to sDriverID
84664>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84665>>>        If (bOK = False) Begin
84667>>>            Function_Return False
84668>>>        End
84668>>>>
84668>>>
84668>>>        Get DriverIndex sDriverID to iDriver
84669>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84672>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84675>>>
84675>>>        Get UtilTableNameToHandle sTableName to hTable
84676>>>        If (hTable <> 0) Begin
84678>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
84679>>>            If (bExists = False) Begin
84681>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84684>>>                Function_Return False
84685>>>            End
84685>>>>
84685>>>        End
84685>>>>
84685>>>
84685>>>        Get piDbType to iDbType
84686>>>        If (iDbType = EN_DbTypeMSSQL) Begin
84688>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
84689>>>            Get _UtilDeleteCacheFile sTableName to bOK
84690>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84693>>>            Function_Return bOK
84694>>>        End
84694>>>>
84694>>>
84694>>>        Move False to Err
84695>>>        Get _SqlProperTableName sTableName    to sTableName
84696>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84697>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
84698>>>
84698>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
84699>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84700>>>        Move (not(Err)) to bRetval
84701>>>
84701>>>        // We also need to remove the cache-file since the table has been changed
84701>>>        Get _UtilDeleteCacheFile sTableName to bOK
84702>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84705>>>
84705>>>        Function_Return bRetval
84706>>>    End_Function
84707>>>
84707>>>    // Rename a field/column by table handle (filelist number)
84707>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
84709>>>        String sDriverID sTableName
84709>>>        Boolean bOK
84709>>>
84709>>>        Get psDriverID to sDriverID
84710>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84711>>>        If (bOK = False) Begin
84713>>>            Function_Return False
84714>>>        End
84714>>>>
84714>>>
84714>>>        Get UtilTableHandleToString hTable to sTableName
84715>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
84716>>>
84716>>>        Function_Return (Err = False)
84717>>>    End_Function
84718>>>
84718>>>    // Rename a field/column by table name.
84718>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
84720>>>        Integer iDbType iDataType
84720>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
84720>>>        Boolean bOK bRetval
84720>>>        Handle hTable
84720>>>
84720>>>        Move sTableName to sOrgTableName
84721>>>        Get psDriverID to sDriverID
84722>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84723>>>        If (bOK = False) Begin
84725>>>            Function_Return False
84726>>>        End
84726>>>>
84726>>>
84726>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84727>>>        If (sVal = "") Begin
84729>>>            Function_Return False
84730>>>        End
84730>>>>
84730>>>
84730>>>        Get piDbType to iDbType
84731>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
84732>>>        Get _SqlProperTableName sTableName     to sTableName
84733>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
84734>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
84735>>>
84735>>>        Case Begin
84735>>>            Case (iDbType = EN_dbTypeMSSQL)
84737>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
84738>>>                Case Break
84739>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
84739>>>            Case (iDbType = EN_dbTypeOracle)
84742>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84743>>>                Case Break
84744>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
84744>>>            Case (iDbType = EN_dbTypeDB2)
84747>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84748>>>                Case Break
84749>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
84749>>>            Case (iDbType = EN_dbTypePostgre)
84752>>>                Move sOrgTableName to sTableName
84753>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84754>>>                Case Break
84755>>>            Case (iDbType = EN_dbTypeMySQL)
84758>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
84758>>>                Move sOrgTableName to sTableName
84759>>>                Get psDatabase to sDatabase
84760>>>                Get UtilTableNameToHandle sTableName to hTable
84761>>>                If (hTable = 0) Begin
84763>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
84764>>>                    If (bOK = False) Begin
84766>>>                        Function_Return False
84767>>>                    End
84767>>>>
84767>>>                    Get NextFreeFilelistSlot to hTable
84768>>>                End
84768>>>>
84768>>>                Else Begin
84769>>>                    Open hTable
84771>>>                End
84771>>>>
84771>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
84772>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
84773>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
84774>>>                Case Break
84775>>>            Case Else
84775>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
84776>>>        Case End
84776>>>
84776>>>        Move False to Err
84777>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84778>>>        Move (Err = False) to bRetval
84779>>>        // We also need to remove the cache-file since the table has been changed
84779>>>        Get _UtilDeleteCacheFile sTableName to bOK
84780>>>
84780>>>        Function_Return bRetval
84781>>>    End_Function
84782>>>
84782>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
84784>>>        Handle hoSQLHandler hSQLConnect hStmt
84784>>>        Integer iNumCols iCount iDataType
84784>>>        String sValue
84784>>>
84784>>>        Get phoSQLManager to hoSQLHandler
84785>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
84786>>>        If (hSQLConnect <> 0) Begin
84788>>>            Get SQLOpen of hSQLConnect to hStmt
84789>>>            If (hStmt <> 0) Begin
84791>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
84792>>>
84792>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
84793>>>                For iCount from 1 to iNumCols
84799>>>>
84799>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
84800>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
84802>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
84803>>>                        Move iNumCols to iCount // We're out of here
84804>>>                    End
84804>>>>
84804>>>                Loop
84805>>>>
84805>>>
84805>>>                Send SQLClose of hStmt
84806>>>            End
84806>>>>
84806>>>            Send SQLDisconnect of hSQLConnect
84807>>>        End
84807>>>>
84807>>>
84807>>>        Function_Return iDataType
84808>>>    End_Function
84809>>>
84809>>>    // * Dummy function for the Studio's Code Explorer *
84809>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
84811>>>        Function_Return False
84812>>>    End_Function
84813>>>
84813>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
84815>>>        String sMessage // sConnectionString
84815>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
84815>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
84815>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
84818>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
84818>>>        TimeSpan tsQuery tsFetch
84818>>>        tSqlErrorArray aSqlErrorArray
84818>>>        tSqlErrorArray aSqlErrorArray
84818>>>        Boolean bOK bShowProgress
84818>>>        tSQLConnection SQLConnection
84818>>>        tSQLConnection SQLConnection
84818>>>
84818>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84819>>>        If (bOK = False) Begin
84821>>>            Procedure_Return
84822>>>        End
84822>>>>
84822>>>
84822>>>        If (num_arguments > 2) Begin
84824>>>            Move bShowProgr to bShowProgress
84825>>>        End
84825>>>>
84825>>>
84825>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84826>>>        Get phoSQLManager to hoSqlHandler
84827>>>        Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
84828>>>        Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
84829>>>
84829>>>        If (hoSQLConnect <> 0) Begin
84831>>>            Get SqlOpen of hoSQLConnect to hoStmt
84832>>>            If (hoStmt <> 0) Begin
84834>>>                // record starting date/time stamp
84834>>>                Move (CurrentDateTime()) to dtQueryExecStart
84835>>>                // turn on error handling if enabled
84835>>>                If (pbHandleQueryErrors(Self)) Begin
84837>>>                    Set pbSqlError to False
84838>>>                    Set paSqlErrorArray to aSqlErrorArray
84839>>>                    Move Error_Object_Id to hoError
84840>>>                    If (ghoDbUpdateHandler <> 0) Begin
84842>>>                        Move ghoDbUpdateHandler to Error_Object_Id
84843>>>                    End
84843>>>>
84843>>>                    Else Begin
84844>>>                        Move Self to Error_Object_Id
84845>>>                    End
84845>>>>
84845>>>                End
84845>>>>
84845>>>
84845>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
84845>>>                Set psSQLStatementString to sStmt
84846>>>                Send Cursor_Wait of Cursor_Control
84847>>>                Send SqlExecDirect of hoStmt sStmt
84848>>>                Send Cursor_Ready of Cursor_Control
84849>>>
84849>>>                If (pbHandleQueryErrors(Self)) Begin
84851>>>                    Move hoError to Error_Object_Id
84852>>>                End
84852>>>>
84852>>>
84852>>>                Move 0 to iMsgs
84853>>>                Move Err to iErr
84854>>>                Move LastErr to iLastErr
84855>>>                Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
84856>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
84857>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
84858>>>                Send _SqlColumnInfo hoStmt
84859>>>                Send Ignore_Error of Error_Object_Id 12289
84860>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84861>>>                Repeat
84861>>>>
84861>>>                    Get SqlFetch of hoStmt to iFetchResult
84862>>>                    If (iFetchResult <> 0) Begin
84864>>>                        Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
84865>>>                    End
84865>>>>
84865>>>                Until (iFetchResult = 0)
84867>>>                Send Trap_Error of Error_Object_Id 12289
84868>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
84869>>>                Move iErr to Err
84870>>>                Move iLastErr to LastErr
84871>>>                Set paSQLFetchResults to aSQLFetchResults
84872>>>
84872>>>                Set piRows    to iRows
84873>>>                Set piRowType to iRowType
84874>>>                Move (CurrentDateTime()) to dtQueryExecEnd
84875>>>                Move (CurrentDateTime()) to dtFetchStart
84876>>>
84876>>>                If (iMsgs <> 0) Begin
84878>>>                    If (ghoDbUpdateHandler > 0) Begin
84880>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
84881>>>                    End
84881>>>>
84881>>>                    For i from 1 to iMsgs
84887>>>>
84887>>>                        Get SqlGetMessage of hoStmt i to sMessage
84888>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
84889>>>                        If (bShowProgress = True) Begin
84891>>>                            If (Active_State(ghoStatusPanel)) Begin
84893>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
84894>>>                            End
84894>>>>
84894>>>                            Else Begin
84895>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
84897>>>                            End
84897>>>>
84897>>>                        End
84897>>>>
84897>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
84898>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
84899>>>                    Loop
84900>>>>
84900>>>                    If (ghoDbUpdateHandler > 0) Begin
84902>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
84903>>>                    End
84903>>>>
84903>>>                    Set paQueryMessages to sMsg
84904>>>                End
84904>>>>
84904>>>                Else Begin
84905>>>                    If (bShowProgress = True) Begin
84907>>>                        Get paSqlErrorArray to aSqlErrorArray
84908>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
84910>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
84911>>>                            Decrement iMsgs
84912>>>                            For i from 0 to iMsgs
84918>>>>
84918>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
84921>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
84924>>>                            Loop
84925>>>>
84925>>>                        End
84925>>>>
84925>>>                    End
84925>>>>
84925>>>                End
84925>>>>
84925>>>                Move (CurrentDateTime()) to dtFetchEnd
84926>>>            End
84926>>>>
84926>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
84927>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
84928>>>            Set ptsQueryExec to tsQuery
84929>>>            Set ptsFetchResults to tsFetch
84930>>>            Send SqlClose of hoStmt
84931>>>        End
84931>>>>
84931>>>
84931>>>        Send SqlDisconnect of hoSQLConnect
84932>>>    End_Procedure
84933>>>
84933>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
84933>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
84933>>>    // Returns False if no error occured.
84933>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
84935>>>        Boolean bOK bShowProgress
84935>>>        tSQLScriptArray SQLScriptArray
84935>>>        tSQLScriptArray SQLScriptArray
84935>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
84935>>>        TimeSpan tsTotalTime
84935>>>
84935>>>        Move (CurrentDateTime()) to dtTotalQueryStart
84936>>>        Get _SqlUtilReadResource sMemFileName to SQLScriptArray
84937>>>        If (SQLScriptArray.bError = True) Begin
84939>>>            Function_Return False
84940>>>        End
84940>>>>
84940>>>
84940>>>        If (num_arguments > 3) Begin
84942>>>            Move bShowProgr to bShowProgress
84943>>>        End
84943>>>>
84943>>>
84943>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84944>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
84945>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84946>>>
84946>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
84947>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
84948>>>        Set ptsTotalQueryTime to tsTotalTime
84949>>>
84949>>>        Function_Return bOK
84950>>>    End_Function
84951>>>
84951>>>    // * Dummy function for the Studio's Code Explorer *
84951>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
84953>>>        Function_Return False
84954>>>    End_Function
84955>>>
84955>>>    // Does three things with auxilirary files;
84955>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
84955>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
84955>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
84955>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
84957>>>        String sDataPath sDDSrcPath sDriverID
84957>>>        Boolean bOK bExists
84957>>>        Integer iCount iCh iPos
84957>>>
84957>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
84957>>>        If (sTableName contains ".") Begin
84959>>>            Move (Pos(".", sTableName)) to iPos
84960>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
84961>>>        End
84961>>>>
84961>>>
84961>>>        Get psDriverID to sDriverID
84962>>>        Get psDataPathFirstPart to sDataPath
84963>>>        Get vFolderExists sDataPath to bOK
84964>>>        If (bOK = False) Begin
84966>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
84967>>>>
84967>>>            Function_Return False
84968>>>        End
84968>>>>
84968>>>
84968>>>        // First delete the cache file:
84968>>>        Get _UtilDeleteCacheFile sTableName to bOK
84969>>>
84969>>>        Get Seq_New_Channel to iCh
84970>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84972>>>            Function_Return False
84973>>>        End
84973>>>>
84973>>>
84973>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
84974>>>        If (bExists = False) Begin
84976>>>            Function_Return False
84977>>>        End
84977>>>>
84977>>>
84977>>>        Get _SqlUtilUpdateIntFile hTable to bOK
84978>>>        // Add the new column name to the .tag filen (if it doesn't exist):
84978>>>        Get _UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
84979>>>
84979>>>        // If in development environment; output new .fd file:
84979>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
84980>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
84981>>>        If (iCount > 1) Begin
84983>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
84984>>>        End
84984>>>>
84984>>>        Get vFolderExists sDDSrcPath to bExists
84985>>>        If (bExists = True) Begin
84987>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
84988>>>            Move False to Err
84989>>>            Get AutoConnectionIDLogin to bOK
84990>>>            If (hTable <> 0) Begin
84992>>>                Open hTable
84994>>>            End
84994>>>>
84994>>>            Else Begin
84995>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
84996>>>            End
84996>>>>
84996>>>
84996>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
84999>>>            If (bOK = True) Begin
85001>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
85003>>>            End
85003>>>>
85003>>>            If (Err = True) Begin
85005>>>                Move False to bOK
85006>>>            End
85006>>>>
85006>>>        End
85006>>>>
85006>>>
85006>>>        Function_Return (bOK = True)
85007>>>    End_Function
85008>>>
85008>>>    // Message for changing .int files to use connection ID's
85008>>>    //
85008>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
85008>>>    // OR changes an existing connection id to a new id.
85008>>>    // Pass the full path to the data folder and the name of the connection id (string value).
85008>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
85008>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
85010>>>        String sFileName sDriverID sDriverFile sConnectionString
85010>>>        String[] sFilesData
85011>>>        Boolean bOK bCancel
85011>>>        Integer iSize iCount
85011>>>
85011>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
85012>>>        Move (SizeOfArray(sFilesData))    to iSize
85013>>>        If (iSize = 0) Begin
85015>>>            If (ghoStatusPanel <> 0) Begin
85017>>>                If (Active_State(ghoStatusPanel)) Begin
85019>>>                    Send Stop_StatusPanel of ghoStatusPanel
85020>>>                End
85020>>>>
85020>>>            End
85020>>>>
85020>>>            Send Info_Box CS_DUF_NoIntFilesFound
85021>>>            Procedure_Return
85022>>>        End
85022>>>>
85022>>>
85022>>>        Move (Trim(sConnectionID)) to sConnectionID
85023>>>        Get vFolderFormat sDataPath to sDataPath
85024>>>        Decrement iSize
85025>>>        For iCount from 0 to iSize
85031>>>>
85031>>>            Move sFilesData[iCount] to sFileName
85032>>>            // This makes sure that we also can change an existing connection id to something new:
85032>>>            Get _UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
85033>>>            If (ghoStatusPanel <> 0) Begin
85035>>>                If (Active_State(ghoStatusPanel)) Begin
85037>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
85038>>>                    If (bCancel = True) Begin
85040>>>                        Send Deactivate of ghoStatusPanel
85041>>>                        Procedure_Return
85042>>>                    End
85042>>>>
85042>>>                End
85042>>>>
85042>>>            End
85042>>>>
85042>>>        Loop
85043>>>>
85043>>>
85043>>>        Get psDriverID to sDriverID
85044>>>
85044>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85044>>>        Move "" to sFileName
85045>>>        If (sDriverID = MSSQLDRV_ID) Begin
85047>>>            Move "MSSQLDrv.int" to sFileName
85048>>>        End
85048>>>>
85048>>>        If (sDriverID = DB2_DRV_ID) Begin
85050>>>            Move "DB2_Drv.int" to sFileName
85051>>>        End
85051>>>>
85051>>>        If (sDriverID = ODBC_DRV_ID) Begin
85053>>>            Move "ODBC_Drv.int" to sFileName
85054>>>        End
85054>>>>
85054>>>        If (sFileName <> "") Begin
85056>>>            Move "" to sDriverFile
85057>>>            Get_File_Path sFileName to sDriverFile
85058>>>            If (sDriverFile <> "") Begin
85060>>>                Get psConnectionString to sConnectionString
85061>>>                Get _UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85062>>>            End
85062>>>>
85062>>>        End
85062>>>>
85062>>>    End_Procedure
85063>>>
85063>>>    // Checks if the database exists in SQL. Returns = True if it does.
85063>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85065>>>        String[] sDatabaseArray
85066>>>        String sVal sServer sDriverID
85066>>>        Integer iCount iSize iPos
85066>>>        Boolean bExists
85066>>>        tSQLConnection SQLConnection
85066>>>        tSQLConnection SQLConnection
85066>>>
85066>>>        Move False to bExists
85067>>>        Get psDriverID to sDriverID
85068>>>        // DB2 doesn't have a "Database" name, so we always return True.
85068>>>        If (sDriverID = DB2_DRV_ID) Begin
85070>>>            Function_Return bExists
85071>>>        End
85071>>>>
85071>>>
85071>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
85072>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
85074>>>            Function_Return False
85075>>>        End
85075>>>>
85075>>>
85075>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85076>>>        Move SQLConnection.sServer to sServer
85077>>>
85077>>>        // Special code to handle a FILEDSN that also can contain "/"
85077>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
85079>>>            Move sDatabaseArray[0] to sVal  // Dummy!
85080>>>        End
85080>>>>
85080>>>        Else If (sServer contains "/") Begin
85083>>>            Move (Pos("/", sServer)) to iPos
85084>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
85085>>>        End
85085>>>>
85085>>>
85085>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
85086>>>        Decrement iSize
85087>>>        For iCount from 0 to iSize
85093>>>>
85093>>>            Move sDatabaseArray[iCount] to sVal
85094>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
85096>>>                Move True to bExists
85097>>>                If (bExists = True) Begin
85099>>>                    Move iSize to iCount // We're done.
85100>>>                End
85100>>>>
85100>>>            End
85100>>>>
85100>>>        Loop
85101>>>>
85101>>>
85101>>>        Function_Return bExists
85102>>>    End_Function
85103>>>
85103>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85103>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85105>>>        String sDatabase sSchema sTableName sVal
85105>>>        Boolean bExists
85105>>>        String[] sTablesArray
85106>>>        Integer iSize iCount
85106>>>
85106>>>        Move False to bExists
85107>>>        Get UtilTableHandleToString hTable to sTableName
85108>>>        Get psDatabase to sDatabase
85109>>>        Get psSchema   to sSchema
85110>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85111>>>        Move (SizeOfArray(sTablesArray)) to iSize
85112>>>        Decrement iSize
85113>>>        For iCount from 0 to iSize
85119>>>>
85119>>>            Move sTablesArray[iCount] to sVal
85120>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85122>>>                Move True to bExists
85123>>>                Move iSize to iCount // We're done!
85124>>>            End
85124>>>>
85124>>>        Loop
85125>>>>
85125>>>
85125>>>        Function_Return bExists
85126>>>    End_Function
85127>>>
85127>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
85129>>>        String sVal sTableSpelledCorrectly
85129>>>        Boolean bExists
85129>>>        String[] sTablesArray
85130>>>        Integer iSize iCount
85130>>>
85130>>>        Move False to bExists
85131>>>        Move sTableName to sTableSpelledCorrectly
85132>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85133>>>        Move (SizeOfArray(sTablesArray)) to iSize
85134>>>        Decrement iSize
85135>>>        For iCount from 0 to iSize
85141>>>>
85141>>>            Move sTablesArray[iCount] to sVal
85142>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85144>>>                Move sVal to sTableSpelledCorrectly
85145>>>                Move iSize to iCount // We're done!
85146>>>            End
85146>>>>
85146>>>        Loop
85147>>>>
85147>>>
85147>>>        Function_Return sTableSpelledCorrectly
85148>>>    End_Function
85149>>>
85149>>>    // ToDo: This index name function needs to be finished...
85149>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85151>>>        String sSchema sTableName sDriverID
85151>>>        Boolean bExists
85151>>>
85151>>>        Get psDriverID to sDriverID
85152>>>        Get psSchema to sSchema
85153>>>        Get UtilTableHandleToString hTable to sTableName
85154>>>
85154>>>        Function_Return bExists
85155>>>    End_Function
85156>>>
85156>>>    // Checks if a column/field name exists in a SQL table definition
85156>>>    // Returns True if it does
85156>>>    // Sample:
85156>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
85156>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
85158>>>        Integer iNumColumns iColumn
85158>>>        String sColumn sDriverID
85158>>>        String[] sColumnsArray
85159>>>        Boolean bExists bOK
85159>>>
85159>>>        Move False to bExists
85160>>>        Get AutoConnectionIDLogin to bOK
85161>>>        Get psDriverID to sDriverID
85162>>>
85162>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
85163>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
85164>>>        Decrement iNumColumns
85165>>>        For iColumn from 0 to iNumColumns
85171>>>>
85171>>>            Move sColumnsArray[iColumn] to sColumn
85172>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
85174>>>                Move True to bExists
85175>>>                Move iNumColumns to iColumn // We're out of here
85176>>>            End
85176>>>>
85176>>>        Loop
85177>>>>
85177>>>
85177>>>        Function_Return bExists
85178>>>    End_Function
85179>>>
85179>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
85181>>>        Integer iNumColumns iColumn iDFType iNativeType
85181>>>        Boolean bOpened bOK
85181>>>        String sColumnName sNativeTypeName
85181>>>
85181>>>        Get AutoConnectionIDLogin to bOK
85182>>>        Get OpenTableExclusive hTable to bOK
85183>>>        If (bOK = False) Begin
85185>>>            Function_Return False
85186>>>        End
85186>>>>
85186>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85189>>>        If (bOpened = False) Begin
85191>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
85192>>>>
85192>>>            Function_Return False
85193>>>        End
85193>>>>
85193>>>
85193>>>        Move False to Err
85194>>>
85194>>>        Structure_Start hTable
85195>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
85198>>>
85198>>>            For iColumn from 1 to iNumColumns
85204>>>>
85204>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
85207>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
85210>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
85213>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
85216>>>
85216>>>                Case Begin
85216>>>                    Case (iDFType = DF_DATE)
85218>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85220>>>                            // Convert datetime to date
85220>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
85223>>>                        End
85223>>>>
85223>>>                        Case Break
85224>>>                    Case (iDFType = DF_DATETIME)
85227>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85229>>>                            // Convert datetime to datetime2
85229>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
85232>>>                        End
85232>>>>
85232>>>                        Case Break
85233>>>                    Case (iDFType = DF_ASCII)
85236>>>                        If (iNativeType = SQL_CHAR) Begin
85238>>>                            // Convert char to varchar
85238>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85241>>>                        End
85241>>>>
85241>>>                        Case Break
85242>>>                    Case (iDFType = DF_TEXT)
85245>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
85247>>>                            // Convert text to varchar(max)
85247>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85250>>>                        End
85250>>>>
85250>>>                        Case Break
85251>>>                    Case (iDFType = DF_BINARY)
85254>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
85256>>>                            // Convert image to varbinary(max)
85256>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
85259>>>                        End
85259>>>>
85259>>>                        Case Break
85260>>>                Case End
85260>>>            Loop
85261>>>>
85261>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85262>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85264>>>
85264>>>        Set Action_Text of ghoStatusPanel to ""
85265>>>        Function_Return (Err = False)
85266>>>    End_Function
85267>>>
85267>>>
85267>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
85267>>>    // the DbUpdateVersion database revision in.
85267>>>    // Also pass the file number of the current (embedded?) table number used in development.
85267>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
85267>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
85269>>>        Boolean bOK bOpened
85269>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
85269>>>
85269>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85272>>>        Get _TableNameOnly sTableName to sTableName
85273>>>        If (sTableName = "") Begin
85275>>>            Function_Return False
85276>>>        End
85276>>>>
85276>>>
85276>>>        // This just creates the table and a "dummy" column.
85276>>>        Get SqlTableCreate hTable sDriverID to bOK
85277>>>        If (bOK = False) Begin
85279>>>            Function_Return False
85280>>>        End
85280>>>>
85280>>>
85280>>>        Close hTable
85281>>>        Move False to Err
85282>>>
85282>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
85283>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
85284>>>        Move "Decimal" to sDataType
85285>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
85286>>>
85286>>>        // Adds the "sColumnName" passed to the function
85286>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
85287>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85288>>>
85288>>>        // Now we can delete the dummy column:
85288>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
85289>>>
85289>>>        // Finally, we attach to the newly created table.
85289>>>        If (Err = False) Begin
85291>>>            Get ApiTableAttachToSQL hTable True to bOK
85292>>>        End
85292>>>>
85292>>>        Open hTable
85294>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85297>>>
85297>>>        Function_Return (Err = False and bOK = True and bOpened = True)
85298>>>    End_Function
85299>>>
85299>>>    // Returns a handle to the SQL server associated with the passed driver ID.
85299>>>    // Pass e.g. the psServer property to determine the current connection server.
85299>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
85299>>>    // This handle can be used to obtain attributes about the server, such as default
85299>>>    // column types.
85299>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
85301>>>        Handle hDatabase
85301>>>        Integer iDriver iServers iCount
85301>>>        String sValue
85301>>>
85301>>>        If (sServer = "") Begin
85303>>>            Function_Return 0
85304>>>        End
85304>>>>
85304>>>
85304>>>        Get DriverIndex sDriverID to iDriver
85305>>>        If (iDriver = 0) Begin
85307>>>            Function_Return 0
85308>>>        End
85308>>>>
85308>>>
85308>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
85311>>>        For iCount from 1 to iServers
85317>>>>
85317>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
85320>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
85322>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
85325>>>            End
85325>>>>
85325>>>        Loop
85326>>>>
85326>>>
85326>>>        Function_Return hDatabase
85327>>>    End_Function
85328>>>
85328>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
85328>>>//        String sRootName
85328>>>//        Boolean bOK
85328>>>//
85328>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85328>>>//        Move (sRootName contains sDriverID) to bOK
85328>>>//
85328>>>//        Function_Return bOK
85328>>>//    End_Function
85328>>>
85328>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
85328>>>//        String sDriverID sRootName sDisplayName sSchema sVal
85328>>>//        Integer iDbType
85328>>>//        Boolean bOK
85328>>>//
85328>>>//        Get UtilIsFilelistEntryDriverBased to bOK
85328>>>//        If (bOK = True) Begin
85328>>>//            Function_Return False
85328>>>//        End
85328>>>//
85328>>>//        Get psDriverID to sDriverID
85328>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85328>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
85328>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85328>>>//
85328>>>//        Get psDriverID to sDriverID
85328>>>//        Get piDbType   to iDbType
85328>>>//        Get psSchema   to sSchema
85328>>>//        If (sSchema = "") Begin
85328>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85328>>>//        End
85328>>>//
85328>>>//        Move (Uppercase(sDisplayName)) to sVal
85328>>>//        If (not(sVal contains (sSchema + "."))) Begin
85328>>>//            If (iDbType = EN_dbTypeDB2) Begin
85328>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85328>>>//            End
85328>>>//            Else Begin
85328>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
85328>>>//            End
85328>>>//        End
85328>>>//
85328>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85328>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85328>>>//
85328>>>//        Function_Return True
85328>>>//    End_Function
85328>>>
85328>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
85328>>>    // from the passed filelist.
85328>>>    // Returns the number of tables affected.
85328>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
85330>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
85330>>>        Integer iRetval
85330>>>        Handle hTable
85330>>>
85330>>>        // We first save the current filelist as the passed filelist name
85330>>>        // may come from another workspace, to restore it when we're ready.
85330>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
85333>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
85336>>>        Move 0 to hTable
85337>>>        Move 0 to iRetval
85338>>>
85338>>>        Repeat
85338>>>>
85338>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85341>>>            If (hTable <> 0) Begin
85343>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85346>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85349>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85352>>>                Move (Uppercase(sRootName)) to sVal
85353>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
85355>>>                    // Prefixes:
85355>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
85356>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
85357>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
85358>>>                    // Suffixes:
85358>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
85359>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
85360>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
85361>>>
85361>>>                    // Change Filelist entry:
85361>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
85364>>>
85364>>>                    Move (Lowercase(sDisplayName)) to sVal
85365>>>                    If (sVal contains "dbo.") Begin
85367>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
85368>>>
85368>>>                        // Change Filelist entry:
85368>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
85371>>>                    End
85371>>>>
85371>>>                    Increment iRetval
85372>>>                End
85372>>>>
85372>>>            End
85372>>>>
85372>>>        Until (hTable = 0)
85374>>>
85374>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
85377>>>
85377>>>        Function_Return iRetval
85378>>>    End_Function
85379>>>
85379>>>    // To open all Sql based tables in Filelist.cfg
85379>>>    Procedure SqlUtilOpenAllTables
85381>>>        Handle hTable
85381>>>        String sRoot sDriverID
85381>>>        Boolean bOK
85381>>>
85381>>>        Move 0 to hTable
85382>>>        Move "" to sDriverID
85383>>>        Get AutoConnectionIDLogin to bOK
85384>>>
85384>>>        Repeat
85384>>>>
85384>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85387>>>            If (hTable > 0) Begin
85389>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85392>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
85394>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
85397>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
85399>>>                        Open hTable
85401>>>                    End
85401>>>>
85401>>>                End
85401>>>>
85401>>>            End
85401>>>>
85401>>>
85401>>>        Until (hTable = 0)
85403>>>    End_Procedure
85404>>>
85404>>>//    Function SqlUtilSchemaName Handle hTable Returns String
85404>>>//        String sRetval sDriverID
85404>>>//        String sTableName
85404>>>//        Integer iDbType iIndex
85404>>>//        Boolean bOK
85404>>>//
85404>>>//        Get psDriverID to sDriverID
85404>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
85404>>>//        If (hTable = 0 or bOK = False) Begin
85404>>>//            Function_Return ""
85404>>>//        End
85404>>>//
85404>>>//        Move False to Err
85404>>>//        Get UtilTableHandleToString hTable to sTableName
85404>>>//        Get piDbType to iDbType
85404>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
85404>>>//        If (iIndex = -1) Begin
85404>>>//            Function_Return ""
85404>>>//        End
85404>>>//
85404>>>//        Function_Return sRetval
85404>>>//    End_Function
85404>>>
85404>>>    // Checks if the passed Table;
85404>>>    // 1) Already has a Filelist entry that points to SQL and
85404>>>    // 2) It has an .int file.
85404>>>    // If both is True it should already be connected to SQL
85404>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
85406>>>        Boolean bExists bRootName
85406>>>        String sRootName sDataPath
85406>>>
85406>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85409>>>        Move (sRootName contains sDriverID) to bRootName
85410>>>
85410>>>        Get psDataPathFirstPart to sDataPath
85411>>>        Get vFolderExists sDataPath to bExists
85412>>>        If (bExists = False) Begin
85414>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
85414>>>            Function_Return False
85415>>>        End
85415>>>>
85415>>>
85415>>>        Get vFolderFormat sDataPath to sDataPath
85416>>>        Get _TableNameOnly sRootName to sRootName
85417>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
85418>>>
85418>>>        Function_Return (bRootName = True and bExists = True)
85419>>>    End_Function
85420>>>
85420>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
85422>>>        Boolean bViewTableType bOpen bOK
85422>>>        Integer iTableCount iNumTables
85422>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
85422>>>        Handle hoCliHandler
85422>>>        tSQLConnection SQLConnection
85422>>>        tSQLConnection SQLConnection
85422>>>
85422>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85425>>>        If (bOpen = False) Begin
85427>>>            Get AutoConnectionIDLogin to bOK
85428>>>            Open hTable
85430>>>        End
85430>>>>
85430>>>
85430>>>        Get pSQLConnection to SQLConnection
85431>>>        Get phoCLIHandler to hoCliHandler
85432>>>        Set psDriverID of hoCliHandler to sDriverID
85433>>>
85433>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85436>>>        Get _TableNameOnly sTableName to sTableName
85437>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
85440>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
85441>>>
85441>>>        For iTableCount from 1 to iNumTables
85447>>>>
85447>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
85448>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
85449>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
85451>>>                Get TableType of hoCliHandler iTableCount to sTableType
85452>>>                Move iNumTables to iTableCount // We're done.
85453>>>            End
85453>>>>
85453>>>        Loop
85454>>>>
85454>>>
85454>>>        Move (sTableType = "VIEW") to bViewTableType
85455>>>        If (bOpen = False) Begin
85457>>>            Close hTable
85458>>>        End
85458>>>>
85458>>>
85458>>>        Function_Return bViewTableType
85459>>>    End_Function
85460>>>
85460>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
85460>>>    //
85460>>>    // SQL utility function that returns a database type (string) constant
85460>>>    // corresponding to the passed iDbType.
85460>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
85462>>>        String sRetval
85462>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85463>>>        Function_Return sRetval
85464>>>    End_Function
85465>>>
85465>>>    // SQL utility function that returns a database type constant (integer)
85465>>>    // corresponding to the passed sDbType string constant.
85465>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
85467>>>        Integer iRetval
85467>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
85468>>>        Function_Return iRetval
85469>>>    End_Function
85470>>>
85470>>>    // Pass an integer DbType and function returns the database type integer as a string value.
85470>>>    // Used e.g. when reading a connection ini-file to display the database type in
85470>>>    // the SQL Connection program's grid.
85470>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
85472>>>        String sRetval
85472>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85473>>>        Function_Return sRetval
85474>>>    End_Function
85475>>>
85475>>>    // Pass a driver name as a string and the function will return
85475>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
85475>>>    // quite work and always returns "MS SQL Server"
85475>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
85477>>>        Integer iRetval
85477>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
85478>>>        Function_Return iRetval
85479>>>    End_Function
85480>>>
85480>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
85480>>>    // that "fits" in the max allowed length for table names.
85480>>>    // Max number of characters allowed for table names;
85480>>>    // IBM DB2      = 128
85480>>>    // MS-SQL       = 128
85480>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
85480>>>    // MySQL        = 64
85480>>>    // PostgreSQL   = 64
85480>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
85482>>>        String sGUIDName
85482>>>        Integer iDbType iLength
85482>>>
85482>>>        Get piDbType to iDbType
85483>>>        Move (RandomHexUUID()) to sGUIDName
85484>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
85485>>>        Move (Length(sGUIDName)) to iLength
85486>>>
85486>>>        Case Begin
85486>>>            Case (iDbType = EN_DbTypeDB2)
85488>>>            If (iLength > 128) Begin
85490>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85491>>>            End
85491>>>>
85491>>>            Case Break
85492>>>
85492>>>            Case (iDbType = EN_DbTypeMSSQL)
85495>>>            If (iLength > 128) Begin
85497>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85498>>>            End
85498>>>>
85498>>>            Case Break
85499>>>
85499>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
85502>>>            If (iLength > 128) Begin
85504>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85505>>>            End
85505>>>>
85505>>>            Case Break
85506>>>
85506>>>            Case (iDbType = EN_DbTypeMySQL)
85509>>>            If (iLength > 64) Begin
85511>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85512>>>            End
85512>>>>
85512>>>            Case Break
85513>>>
85513>>>            Case (iDbType = EN_DbTypePostgre)
85516>>>            If (iLength > 64) Begin
85518>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85519>>>            End
85519>>>>
85519>>>        Case End
85519>>>
85519>>>        Function_Return sGUIDName
85520>>>    End_Function
85521>>>
85521>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
85521>>>    // Pass the memory resource file reference and the filename to be created,
85521>>>    // including full path.
85521>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
85523>>>        String sText
85523>>>        Integer iCh iSize iArgSize
85523>>>
85523>>>        Move ("Resource:" + sMemFileName) to sMemFileName
85524>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
85525>>>        Get_Channel_Size iCh to iSize
85526>>>        Read_Block channel iCh sText iSize
85528>>>        Send Seq_Close_Channel iCh
85529>>>
85529>>>        Get Seq_Open_Output_Channel sFileName to iCh
85530>>>            Write channel iCh sText
85532>>>        Send Seq_Close_Channel iCh
85533>>>
85533>>>        // Wait for file to be written to disk.
85533>>>        Sleep 2
85534>>>    End_Procedure
85535>>>
85535>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
85537>>>        String sNotNull sRetval sDefaultValue
85537>>>        Boolean bOK
85537>>>
85537>>>        Get IsSQLDriver sDriverID to bOK
85538>>>        If (bOK = False) Begin
85540>>>            Function_Return ""
85541>>>        End
85541>>>>
85541>>>
85541>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
85542>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
85543>>>
85543>>>        Case Begin
85543>>>            Case (iDbType = EN_dbTypeMSSQL)
85545>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
85546>>>                Case Break
85547>>>            Case (iDbType = EN_dbTypeMySQL)
85550>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85551>>>                Case Break
85552>>>            Case (iDbType = EN_dbTypePostgre)
85555>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85556>>>                Case Break
85557>>>            Case (iDbType = EN_dbTypeDB2)
85560>>>                Move (String(sNotNull))                                     to sRetval
85561>>>                Case Break
85562>>>
85562>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
85562>>>            // ToDo: We need to look deeper into how Oracle handles NULL
85562>>>            Case (iDbType = EN_dbTypeOracle)
85565>>>                Move  ""                                                    to sRetval
85566>>>                Case Break
85567>>>
85567>>>            Case Else
85567>>>                Move  ""                                                    to sRetval
85568>>>        Case End
85568>>>
85568>>>        Function_Return sRetval
85569>>>    End_Function
85570>>>
85570>>>    // * Dummy function for the Studio's Code Explorer *
85570>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
85572>>>        Function_Return False
85573>>>    End_Function
85574>>>
85574>>>    // Enumerate SQL Servers.
85574>>>    // Pass a driver id. Returns a string array.
85574>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
85574>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
85574>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
85576>>>        String[] sReturnArray
85577>>>        Handle hoSQLHandler
85577>>>        String sServer
85577>>>        Integer iCount iNumItems iDataSourceType
85577>>>
85577>>>        If (num_arguments > 1) Begin
85579>>>            Move iDatSrcType to iDataSourceType
85580>>>        End
85580>>>>
85580>>>
85580>>>        Case Begin
85580>>>            Case (sDriverID = MSSQLDRV_ID)
85582>>>                Get phoMSSQLHandler to hoSQLHandler
85583>>>                Get EnumerateServers of hoSQLHandler to iNumItems
85584>>>                For iCount from 0 to (iNumItems - 1)
85590>>>>
85590>>>                    Get String_Value of hoSQLHandler iCount to sServer
85591>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
85592>>>                Loop
85593>>>>
85593>>>                Case Break
85594>>>
85594>>>            Case (sDriverID = DB2_DRV_ID)
85597>>>                Get phoDB2SQLHandler to hoSQLHandler
85598>>>                Send SeedDataSources of hoSQLHandler
85599>>>                Move 0 to iCount
85600>>>                Repeat
85600>>>>
85600>>>                    Get DataSources of hoSQLHandler to sServer
85601>>>                    If (sServer <> "") Begin
85603>>>                        Move (Replace(",", sServer, "")) to sServer
85604>>>                        Move sServer to sReturnArray[iCount]
85605>>>                    End
85605>>>>
85605>>>                    Increment iCount
85606>>>                Until (sServer = "")
85608>>>                Case Break
85609>>>
85609>>>            Case (sDriverID = ODBC_DRV_ID)
85612>>>                Get phoODBCSQLHandler to hoSQLHandler
85613>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
85614>>>                Move 0 to iCount
85615>>>                Repeat
85615>>>>
85615>>>                    Get DataSources of hoSQLHandler to sServer
85616>>>                    If (sServer <> "") Begin
85618>>>                        Move (Replace(",", sServer, ", ")) to sServer
85619>>>                        Move sServer to sReturnArray[iCount]
85620>>>                    End
85620>>>>
85620>>>                    Increment iCount
85621>>>                Until (sServer = "")
85623>>>                Case Break
85624>>>
85624>>>            Case Else
85624>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
85625>>>>
85625>>>        Case End
85625>>>
85625>>>        Function_Return sReturnArray
85626>>>    End_Function
85627>>>
85627>>>    // Returns all databases as a string array for the passed driver id.
85627>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
85629>>>        String[] sReturnArray
85630>>>        String sServer sVal
85630>>>        tSQLIntTableInfo[] sReturnStructArray
85630>>>        tSQLIntTableInfo[] sReturnStructArray
85631>>>        tSQLConnection SQLConnection
85631>>>        tSQLConnection SQLConnection
85631>>>        Boolean bOK
85631>>>        Integer iCount iSize
85631>>>
85631>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85632>>>        If (bOK = False) Begin
85634>>>            Function_Return sReturnArray
85635>>>        End
85635>>>>
85635>>>
85635>>>        Case Begin
85635>>>            Case (sDriverID = MSSQLDRV_ID)
85637>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
85638>>>                Case Break
85639>>>            Case (sDriverID = DB2_DRV_ID)
85642>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
85643>>>                Case Break
85644>>>
85644>>>            // This is needed to be able to check if a database exists or not.
85644>>>            Case (sDriverID = ODBC_DRV_ID)
85647>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
85648>>>                If (SizeOfArray(sReturnStructArray)) Begin
85650>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
85652>>>                        // If a FILEDSN: (can only be one database name)
85652>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
85653>>>                    End
85653>>>>
85653>>>                    Else Begin
85654>>>                        // Else the DSN's were read from the registry.
85654>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85655>>>                        Move SQLConnection.sServer to sServer
85656>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
85657>>>                        Decrement iSize
85658>>>                        for iCount from 0 to iSize
85664>>>>
85664>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
85665>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
85667>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
85668>>>                                Move iSize to iCount // We're done.
85669>>>                            End
85669>>>>
85669>>>                        Loop
85670>>>>
85670>>>                    End
85670>>>>
85670>>>                End
85670>>>>
85670>>>                Case Break
85671>>>
85671>>>            Case Else
85671>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
85671>>>        Case End
85671>>>
85671>>>        Function_Return sReturnArray
85672>>>    End_Function
85673>>>
85673>>>    
85673>>>    // *** Database API Functions: ***
85673>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
85673>>>    // make changes/updates to the database.
85673>>>
85673>>>    // * Dummy function for the Studio's Code Explorer *
85673>>>    Function API_TABLE_FUNCTIONS Returns Boolean
85675>>>        Function_Return False
85676>>>    End_Function
85677>>>
85677>>>    // This might not do what you think - Here's what it does:
85677>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
85677>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
85677>>>    // to the SQL table.
85677>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
85677>>>    // already exists in SQL.
85677>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
85677>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
85677>>>    // restructuring an existing table.
85677>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
85679>>>        Boolean bExists bOpened bOK bSystemFile bUseConnectionID bIsAlias
85679>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
85679>>>        Handle hToTable
85679>>>
85679>>>        Move True to bUseConnectionID
85680>>>        If (num_arguments > 1) Begin
85682>>>            Move bUseConnID to bUseConnectionID
85683>>>        End
85683>>>>
85683>>>
85683>>>        Get psDriverID to sDriverID
85684>>>        // If the table doesn't exist on the SQL back-end we do nothing.
85684>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
85685>>>        If (bExists = False) Begin
85687>>>            Function_Return False
85688>>>        End
85688>>>>
85688>>>
85688>>>        Get UtilTableIsAlias hTable to bIsAlias
85689>>>
85689>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85690>>>        If (bOK = False) Begin
85692>>>            Function_Return False
85693>>>        End
85693>>>>
85693>>>
85693>>>        // Then we need to check that the function hasn't been called before; which in case
85693>>>        // we do nothing
85693>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
85694>>>        If (bExists = True) Begin
85696>>>            Function_Return False
85697>>>        End
85697>>>>
85697>>>
85697>>>        Get psConnectionID     to sConnectionID
85698>>>        Get psConnectionString to sConnectionString
85699>>>        If (sConnectionID = "" or sConnectionString = "") Begin
85701>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
85702>>>>
85702>>>            Function_Return False
85703>>>        End
85703>>>>
85703>>>
85703>>>        Set Private.phCurrentTable to hTable
85704>>>        Get psSchema to sSchema
85705>>>        If (sSchema = "") Begin
85707>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85708>>>        End
85708>>>>
85708>>>
85708>>>        // If we should use a connection id we need to check it exists;
85708>>>        // else we create it before attempting creating the table
85708>>>        If (bUseConnectionID = True) Begin
85710>>>            Get AutoConnectionIDLogin to bOK
85711>>>            If (bOk = False) Begin
85713>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
85714>>>>
85714>>>                Function_Return False
85715>>>            End
85715>>>>
85715>>>        End
85715>>>>
85715>>>
85715>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85718>>>        Get _TableNameOnly sRootName to sRootName
85719>>>        If (sRootName = "") Begin
85721>>>            Function_Return False
85722>>>        End
85722>>>>
85722>>>        Move (sRootName + ".int")                    to sPhysicalName
85723>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85726>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85729>>>
85729>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
85729>>>        //
85729>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
85729>>>        // because then the table should not be visible to users.
85729>>>//        Move (Pos("@", sDisplayName)) to iPos
85729>>>//        If (iPos <> 1) Begin
85729>>>//            If (sDisplayName contains ".") Begin
85729>>>//                Move (Pos(".", sDisplayName)) to iPos
85729>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
85729>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
85729>>>//            End
85729>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
85729>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85729>>>//            End
85729>>>//        End
85729>>>
85729>>>        If (bIsAlias = False) Begin
85731>>>            Get OpenTableExclusive hTable to bOpened
85732>>>            If (bOpened = False) Begin
85734>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
85735>>>>
85735>>>                Function_Return False
85736>>>            End
85736>>>>
85736>>>        End
85736>>>>
85736>>>
85736>>>        If (ghoProgressBar <> 0) Begin
85738>>>            Send DoAdvance of ghoProgressBar
85739>>>            Set Message_Text of ghoStatusPanel to ""
85740>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
85741>>>        End
85741>>>>
85741>>>        // Note: The hToTable will get changed by the Structure_xxx command...
85741>>>        Move hTable to hToTable
85742>>>        Move False to Err
85743>>>
85743>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
85743>>>        // then we do a pseudo .int file change with the "_SqlUtilUpdateIntFile" function. After that we have
85743>>>        // a proper and updated .int file.
85743>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
85746>>>        Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
85747>>>
85747>>>        If (bIsAlias = False) Begin
85749>>>            Structure_Start hToTable sDriverID
85750>>>                Set Private.phCurrentTable to hTable
85751>>>                If (bUseConnectionID = True) Begin
85753>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
85756>>>                End
85756>>>>
85756>>>                Else Begin
85757>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
85760>>>                End
85760>>>>
85760>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
85763>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
85763>>>                Move False to Err
85764>>>                Move 0 to LastErr
85765>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85766>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85768>>>            Set Action_Text of ghoStatusPanel to ""
85769>>>        End
85769>>>>
85769>>>
85769>>>        Move (not(Err)) to bOK
85770>>>        If (bOK = True) Begin
85772>>>            // The attributes set above will always trigger an error
85772>>>            // We also adjust the Filelist entries
85772>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
85775>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85778>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85781>>>
85781>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
85781>>>            Get _SqlUtilUpdateIntFile hTable to bOK
85782>>>        End
85782>>>>
85782>>>
85782>>>        Function_Return (bOK = True)
85783>>>    End_Function
85784>>>
85784>>>    // Sample usage:
85784>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
85784>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
85784>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
85786>>>        Boolean bOK bIsSQLTable
85786>>>
85786>>>        Get AutoConnectionIDLogin to bOK
85787>>>        Move False to Err
85788>>>        Get OpenTableExclusive hTable to bOK
85789>>>        If (bOK = False) Begin
85791>>>            Function_Return False
85792>>>        End
85792>>>>
85792>>>
85792>>>        // ToDo: Add to all table change functions!
85792>>>            Get _UtilTableIsSql hTable to bIsSQLTable
85793>>>            If (bIsSQLTable = True) Begin
85795>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85798>>>            End
85798>>>>
85798>>>
85798>>>        Set Private.phCurrentTable to hTable
85799>>>        Structure_Start hTable
85800>>>            Set_Attribute iAttribute of hTable to iValue
85803>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85804>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85806>>>
85806>>>        Set Action_Text of ghoStatusPanel to ""
85807>>>        Function_Return (Err = False)
85808>>>    End_Function
85809>>>
85809>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
85811>>>        Boolean bOK
85811>>>        
85811>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
85812>>>        If (bOK = True) Begin
85814>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
85815>>>        End
85815>>>>
85815>>>        
85815>>>        Function_Return (bOK = True)
85816>>>    End_Function
85817>>>    
85817>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
85817>>>    // or to change the filelist slot names.
85817>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
85819>>>        String sFileListName
85819>>>        
85819>>>        Move False to Err
85820>>>
85820>>>        If (ghoProgressBar <> 0) Begin
85822>>>            Send DoAdvance of ghoProgressBar
85823>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
85824>>>        End
85824>>>>
85824>>>        // If all strings are empty it means that we should remove this entry from filelist.
85824>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
85826>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
85829>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
85832>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
85835>>>            Function_Return (Err = False) // And we're done.
85836>>>        End
85836>>>>
85836>>>
85836>>>        If (sDriverID <> DATAFLEX_ID) Begin
85838>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
85838>>>            Move (sDriverID + ":" + sRootName) to sRootName
85839>>>        End
85839>>>>
85839>>>//        Else Begin
85839>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85839>>>//        End
85839>>>//
85839>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
85839>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
85839>>>
85839>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
85842>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
85845>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
85848>>>        
85848>>>        Function_Return (Err = False)
85849>>>    End_Function
85850>>>
85850>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
85852>>>        Boolean bOK
85852>>>
85852>>>        Get AutoConnectionIDLogin to bOK
85853>>>        Move False to Err
85854>>>        Get OpenTableExclusive hTable to bOK
85855>>>        If (bOK = False) Begin
85857>>>            Function_Return False
85858>>>        End
85858>>>>
85858>>>
85858>>>        Set Private.phCurrentTable to hTable
85859>>>        Structure_Start hTable
85860>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
85863>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85864>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85866>>>
85866>>>        Set Action_Text of ghoStatusPanel to ""
85867>>>        Function_Return (Err = False)
85868>>>    End_Function
85869>>>
85869>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
85871>>>        Boolean bOK bIsSQLTable
85871>>>
85871>>>        Move False to Err
85872>>>        Get AutoConnectionIDLogin to bOK
85873>>>        Open hToTable
85875>>>        Get OpenTableExclusive hTable to bOK
85876>>>        If (bOK = False) Begin
85878>>>            Function_Return False
85879>>>        End
85879>>>>
85879>>>
85879>>>            Get _UtilTableIsSql hTable to bIsSQLTable
85880>>>            If (bIsSQLTable = True) Begin
85882>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85885>>>            End
85885>>>>
85885>>>
85885>>>        Set Private.phCurrentTable to hTable
85886>>>        Structure_Start hTable
85887>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
85890>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
85893>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85894>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85896>>>
85896>>>        Set Action_Text of ghoStatusPanel to ""
85897>>>        Function_Return (Err = False)
85898>>>    End_Function
85899>>>
85899>>>    Procedure ApiTableConvertAllAddException Integer hTable
85901>>>        Integer[] aTableConvertExceptions
85902>>>        Get paTableConvertExceptions to aTableConvertExceptions
85903>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
85904>>>        Set paTableConvertExceptions to aTableConvertExceptions
85905>>>    End_Procedure
85906>>>
85906>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
85908>>>        Integer[] aTableDateCorrectionExceptions
85909>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
85910>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
85911>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
85912>>>    End_Procedure
85913>>>
85913>>>    Procedure ApiTableConvertALLToSql
85915>>>        Integer[] iTablesArray
85916>>>        Integer iSize iCount
85916>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
85916>>>        String sDriverID
85916>>>
85916>>>        Get psDriverID to sDriverID
85917>>>        Get pbUseConnectionID to bUseConnectionID
85918>>>        Get pbToANSI          to bToANSI
85919>>>        Get pbRecnum          to bRecnum
85920>>>        Get pbCopyData        to bCopyData
85921>>>        If (ghoDbUpdateHandler > 0) Begin
85923>>>            Get pbContinueOnError to bContinueOnError
85924>>>        End
85924>>>>
85924>>>
85924>>>        Get _AllTablesToConvert to iTablesArray
85925>>>        Move (SizeOfArray(iTablesArray)) to iSize
85926>>>        Set pbVisible   of ghoProgressBarOverall to True
85927>>>        Set piPosition  of ghoProgressBarOverall to 0
85928>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
85929>>>        Set piMaximum   of ghoProgressBarOverall to iSize
85930>>>
85930>>>        Decrement iSize
85931>>>        For iCount from 0 to iSize
85937>>>>
85937>>>            Set piPosition of ghoProgressBarOverall to iCount
85938>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
85939>>>            // Probably the right logic here is to just continue trying to convert every table even
85939>>>            // if there was an error converting one table...
85939>>>            //If (bContinueOnError = False and bOK = False) Break
85939>>>        Loop
85940>>>>
85940>>>
85940>>>    End_Procedure
85941>>>
85941>>>    Procedure ApiTableAttachALLToSql
85943>>>        Integer[] iTablesArray
85944>>>        Integer iSize iCount
85944>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
85944>>>        String sDriverID
85944>>>
85944>>>        Get psDriverID to sDriverID
85945>>>        Get pbUseConnectionID to bUseConnectionID
85946>>>        Get pbToANSI          to bToANSI
85947>>>        Get pbRecnum          to bRecnum
85948>>>        Get pbCopyData        to bCopyData
85949>>>        If (ghoDbUpdateHandler > 0) Begin
85951>>>            Get pbContinueOnError to bContinueOnError
85952>>>        End
85952>>>>
85952>>>
85952>>>        Get _AllTablesToConvert to iTablesArray
85953>>>        Move (SizeOfArray(iTablesArray)) to iSize
85954>>>        Decrement iSize
85955>>>        For iCount from 0 to iSize
85961>>>>
85961>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
85962>>>        Loop
85963>>>>
85963>>>
85963>>>    End_Procedure
85964>>>
85964>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
85966>>>        Handle hToTable hoLogFile
85966>>>        Boolean bOK bExists bOpened bDAWDriver bContinueOnError bIsAlias
85966>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
85966>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
85966>>>        tSQLConnection SQLConnection
85966>>>        tSQLConnection SQLConnection
85966>>>
85966>>>        Get _UtilTableExists hTable to bExists
85967>>>        If (bExists = False) Begin
85969>>>            Set Private.phCurrentTable to hTable
85970>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
85971>>>>
85971>>>            Function_Return False
85972>>>        End
85972>>>>
85972>>>
85972>>>        Get UtilTableIsAlias hTable to bIsAlias
85973>>>        // If this is an Alias file there is nothing to convert to SQL.
85973>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
85973>>>        If (bIsAlias = True) Begin
85975>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85978>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
85980>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
85983>>>                Get psConnectionID to sConnectionID
85984>>>                Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
85985>>>            End
85985>>>>
85985>>>            Function_Return True
85986>>>        End
85986>>>>
85986>>>
85986>>>        Set Private.phCurrentTable to hTable
85987>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85990>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85993>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85996>>>
85996>>>        If (ghoProgressBar <> 0) Begin
85998>>>            Send DoAdvance of ghoProgressBar
85999>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
86000>>>            Set Message_Text   of ghoStatusPanel to ""
86001>>>            Set Action_Text    of ghoStatusPanel to ""
86002>>>        End
86002>>>>
86002>>>
86002>>>        // Marco Kuipers suggestion;
86002>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
86002>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
86002>>>        // SQL table.
86002>>>        Get _UtilTableIsSql hTable to bOK
86003>>>        If (bOK = False) Begin
86005>>>            Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86006>>>            If (bExists = True) Begin
86008>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86008>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86008>>>                Get phoLogFile to hoLogFile
86009>>>                If (hoLogFile <> 0) Begin          
86011>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
86012>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
86012>>>                    Send LogError sWarning False
86013>>>                End
86013>>>>
86013>>>                Else Begin
86014>>>                    Error DFERR_PROGRAM sWarning
86015>>>>
86015>>>                End                                                       
86015>>>>
86015>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
86016>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
86017>>>            End
86017>>>>
86017>>>        End
86017>>>>
86017>>>
86017>>>        // Does the rootname contain a driver?
86017>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86019>>>            // Does the table already exist as an SQL table?
86019>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86020>>>            // It can happen that the table is missing from Filelist.cfg but still
86020>>>            // exist on the SQL side, in case we want to search for the table by its name.
86020>>>            If (bExists = False) Begin
86022>>>                Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86023>>>            End
86023>>>>
86023>>>            If (bExists = True) Begin
86025>>>                Set TableName_Text of ghoStatusPanel to ""
86026>>>                Function_Return False
86027>>>            End
86027>>>>
86027>>>        End
86027>>>>
86027>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
86028>>>
86028>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
86029>>>        If (bUseConnectionID = True) Begin
86031>>>            Move False to bUseConnectionID
86032>>>        End
86032>>>>
86032>>>
86032>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86033>>>        Move SQLConnection.sSchema           to sSchema
86034>>>        If (sSchema = "") Begin
86036>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
86037>>>            Move (Lowercase(sSchema))        to sSchema
86038>>>        End
86038>>>>
86038>>>
86038>>>        Move SQLConnection.sDatabase         to sDatabase
86039>>>        Move SQLConnection.sConnectionID     to sConnectionID
86040>>>        Move SQLConnection.sConnectionString to sConnectionString
86041>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86043>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
86044>>>>
86044>>>            Function_Return False
86045>>>        End
86045>>>>
86045>>>
86045>>>        Get AutoConnectionIDLogin to bOK
86046>>>        Open hTable
86048>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86051>>>        If (bOpened = False) Begin
86053>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
86054>>>>
86054>>>            Function_Return False
86055>>>        End
86055>>>>
86055>>>
86055>>>        If (ghoProgressBar <> 0) Begin
86057>>>            Send DoAdvance of ghoProgressBar
86058>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
86059>>>        End
86059>>>>
86059>>>
86059>>>        Move 0 to hToTable
86060>>>        Get _TableNameOnly sRootName                 to sRootName
86061>>>        Move (sRootName + ".int")                    to sPhysicalName
86062>>>
86062>>>        Case Begin
86062>>>            Case (sDriverID = MSSQLDRV_ID)
86064>>>                Case Break
86065>>>            Case (sDriverID = ODBC_DRV_ID)
86068>>>                Case Break
86069>>>            Case (sDriverID = DB2_DRV_ID)
86072>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
86073>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
86074>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
86075>>>                Case Break
86076>>>            Case (sDriverID = DATAFLEX_ID)
86079>>>                Case Break
86080>>>            Case Else
86080>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
86081>>>>
86081>>>                Case Break
86082>>>        Case End
86082>>>
86082>>>        Move False to Err
86083>>>
86083>>>        Structure_Start hToTable sDriverID
86084>>>            Structure_Copy hTable to hToTable
86085>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
86088>>>
86088>>>            If (sDriverID <> DATAFLEX_ID) Begin
86090>>>                If (bUseConnectionID = True) Begin
86092>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86095>>>                End
86095>>>>
86095>>>                Else Begin
86096>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
86099>>>                End
86099>>>>
86099>>>
86099>>>                Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
86102>>>
86102>>>                If (sSchema <> "") Begin
86104>>>                    Set_Attribute DF_FILE_OWNER of hToTable to sSchema
86107>>>                End
86107>>>>
86107>>>
86107>>>                If (sDriverID = DB2_DRV_ID) Begin
86109>>>                    If (sLongTableSpace <> "") Begin
86111>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
86114>>>                    End
86114>>>>
86114>>>                    If (sBaseTableSpace <> "") Begin
86116>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
86119>>>                    End
86119>>>>
86119>>>                    If (sIndexTableSpace <> "") Begin
86121>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
86124>>>                    End
86124>>>>
86124>>>                End
86124>>>>
86124>>>            End
86124>>>>
86124>>>
86124>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86125>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86127>>>        Set Action_Text of ghoStatusPanel to ""
86128>>>
86128>>>        Move (not(Err)) to bOK
86129>>>
86129>>>        If (bOK = True and bCopyData = True) Begin
86131>>>            Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
86132>>>
86132>>>            If (ghoDbUpdateHandler > 0) Begin
86134>>>                Get pbContinueOnError to bContinueOnError
86135>>>            End
86135>>>>
86135>>>            // If the data copy failed we will keep the newly created SQL table but
86135>>>            // rename it by adding a GUID to the end of the table name
86135>>>            // - or as much as "fit" because different SQL back-ends have
86135>>>            // different rules how long a table name can be.
86135>>>            // The new table will probably contain data but something went
86135>>>            // wrong while converting the data from embedded to SQL.
86135>>>            If (bOK = False and bContinueOnError = False) Begin
86137>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86138>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86139>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
86140>>>>
86140>>>            End
86140>>>>
86140>>>        End
86140>>>>
86140>>>
86140>>>        // This must be after copying data...
86140>>>        If (Err = False) Begin
86142>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86145>>>            // It seems the Studio does not do this any more, so commented out.
86145>>>            // We also adjust the display name by prefixing it by the schema name;
86145>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86145>>>            //                // The max length for the display_name is 31 characters...
86145>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
86145>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
86145>>>            //                End
86145>>>            //            End
86145>>>        End
86145>>>>
86145>>>
86145>>>        Close hTable
86146>>>        Move (not(Err)) to bOK
86147>>>        Function_Return bOK
86148>>>    End_Function
86149>>>
86149>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
86149>>>    // It will first drop all indicies, copy the data and then recreate indicies.
86149>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
86149>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
86151>>>        Boolean bOpened bOK
86151>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
86151>>>        String sErrorFile sEmpty sPath
86151>>>
86151>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
86154>>>        Get AutoConnectionIDLogin to bOK
86155>>>        If (sDriverID = DATAFLEX_ID) Begin
86157>>>            Send IncreaseSortBufferSize
86158>>>//            Send SetAllIndexesToBatch hToTable
86158>>>        End
86158>>>>
86158>>>
86158>>>        Move False to Err
86159>>>        Open sPhysicalName as hToTable
86161>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
86164>>>        If (bOpened = False) Begin
86166>>>            Function_Return False
86167>>>        End
86167>>>>
86167>>>
86167>>>        If (ghoStatusPanel <> 0) Begin
86169>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
86170>>>            Set piMinimum of ghoProgressBar to 0
86171>>>            Set piMaximum of ghoProgressBar to 100 // 100%
86172>>>        End
86172>>>>
86172>>>
86172>>>        Move "" to sEmpty
86173>>>        Move False to Err
86174>>>        Move True to bOK
86175>>>        Set Private.phCurrentTable to hToTable
86176>>>
86176>>>        // No need to get the record identifier
86176>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
86179>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86182>>>        If (sDriverID <> DATAFLEX_ID) Begin
86184>>>            // Remove all indices to speed up copying of data:
86184>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86189>>>            If (iRetval <> 0) Begin       
86191>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86192>>>>
86192>>>                Close hToTable
86193>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86196>>>                Function_Return False
86197>>>            End
86197>>>>
86197>>>        End
86197>>>>
86197>>>
86197>>>        Move (sRootName + ".err") to sErrorFile
86198>>>        Move 0 to iIndex
86199>>>        Move False to Err
86200>>>
86200>>>        If (sDriverID = MSSQLDRV_ID) Begin
86202>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
86205>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
86210>>>            If (iRetval <> 0) Begin
86212>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86213>>>>
86213>>>                Close hToTable
86214>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86217>>>                Function_Return False
86218>>>            End
86218>>>>
86218>>>        End
86218>>>>
86218>>>        Else Begin
86219>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
86222>>>        End
86222>>>>
86222>>>
86222>>>        If (Err = False) Begin
86224>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
86225>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
86226>>>        End
86226>>>>
86226>>>
86226>>>        If (sDriverID <> DATAFLEX_ID) Begin
86228>>>            // Recreate indices:
86228>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86233>>>            If (iRetval <> 0) Begin
86235>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86236>>>>
86236>>>                Close hToTable
86237>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86240>>>                Function_Return False
86241>>>            End
86241>>>>
86241>>>        End
86241>>>>
86241>>>
86241>>>        Close hToTable
86242>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86245>>>
86245>>>        If (bOK = True) Begin
86247>>>            Move (not(Err)) to bOK
86248>>>        End
86248>>>>
86248>>>
86248>>>        If (ghoStatusPanel <> 0) Begin
86250>>>            Set TableName_Text of ghoStatusPanel to ""
86251>>>            Set Message_Text   of ghoStatusPanel to ""
86252>>>            Set Action_Text    of ghoStatusPanel to ""
86253>>>        End
86253>>>>
86253>>>
86253>>>        Function_Return (bOK = True)
86254>>>    End_Function
86255>>>
86255>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
86255>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
86255>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
86257>>>        Handle hFile
86257>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
86257>>>        Integer iIdentityType iDataType iDbType iCount iSize
86257>>>        Boolean bOk bExists bSqlDriver bDeleteDummy bExistsInFilelist bSysFile
86257>>>        tSQLConnection SQLConnection
86257>>>        tSQLConnection SQLConnection
86257>>>        tAPIColumn[] aColumns
86257>>>        tAPIColumn[] aColumns
86258>>>        tColumnType ColumnType
86258>>>        tColumnType ColumnType
86258>>>
86258>>>        // First check if the passed filenumber already exists; in case we do nothing
86258>>>        Get _UtilTableExists hTable to bOk
86259>>>        If (bOk = True) Begin
86261>>>            Function_Return False
86262>>>        End
86262>>>>
86262>>>
86262>>>        Set Private.phCurrentTable to hTable
86263>>>        Move sLogicalName to sTableName
86264>>>        If (ghoProgressBar <> 0) Begin
86266>>>            Send DoAdvance of ghoProgressBar
86267>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
86268>>>        End
86268>>>>
86268>>>
86268>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
86269>>>        Get psDriverID to sDriverID
86270>>>        Get IsSQLDriver sDriverID to bSqlDriver
86271>>>        Get piDbType to iDbType
86272>>>
86272>>>        // If no columns passed in, we need to create a "dummy" column
86272>>>        Move False to bDeleteDummy
86273>>>        If (Num_Arguments = 8) Begin
86275>>>            Move aColumnIn to aColumns
86276>>>        End
86276>>>>
86276>>>        If ((SizeOfArray(aColumns)) = 0) Begin
86278>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
86279>>>            Move ColumnType.iSQLType to iDataType
86280>>>            If (bRecnum = False) Begin
86282>>>                Move C_tAPIColumn_Identity to iIdentityType
86283>>>            End
86283>>>>
86283>>>            Else Begin
86284>>>                Move C_tAPIColumn_None     to iIdentityType
86285>>>            End
86285>>>>
86285>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
86286>>>            Move True to bDeleteDummy
86287>>>        End
86287>>>>
86287>>>
86287>>>        // If columns have been passed as an array we need to check if an identity column
86287>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
86287>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
86287>>>        // two identity columns and SQL doesn't like that and throws an error.
86287>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
86289>>>            Move (SizeOfArray(aColumns)) to iSize
86290>>>            Decrement iSize
86291>>>            for iCount from 0 to iSize
86297>>>>
86297>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
86299>>>                    Move False to bRecnum
86300>>>                    Move iSize to iCount
86301>>>                End
86301>>>>
86301>>>            Loop
86302>>>>
86302>>>        End
86302>>>>
86302>>>
86302>>>        // If this is a SQL based driver we also check if the table exists
86302>>>        // in the SQL back end; in case we do nothing.
86302>>>        If (bSqlDriver = True) Begin
86304>>>            // Get all connection properties
86304>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86305>>>            Move SQLConnection.sSchema to sSchema
86306>>>            If (sSchema = "") Begin
86308>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
86309>>>            End
86309>>>>
86309>>>
86309>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86310>>>            // It can happen that the table is missing from Filelist.cfg but still
86310>>>            // exist on the SQL side, in case we want to search for the table by its name.
86310>>>            If (bExists = False) Begin
86312>>>                Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
86313>>>            End
86313>>>>
86313>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
86313>>>            // we will just add it to Filelist.cfg
86313>>>            If (bExists = True) Begin
86315>>>                If (bExistsInFilelist = False) Begin
86317>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86319>>>                        Move (sDriverID + ":" + sRootName) to sRootName
86320>>>                    End
86320>>>>
86320>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86323>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86326>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86329>>>                    Move False to bSysFile
86330>>>                    Get _SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
86331>>>                End
86331>>>>
86331>>>                Function_Return False
86332>>>            End
86332>>>>
86332>>>        End
86332>>>>
86332>>>
86332>>>        Move CS_ANSI_Txt to sANSI_OEM
86333>>>        If (num_arguments > 6) Begin
86335>>>            If (bANSI = False) Begin
86337>>>                Move CS_OEM_Txt to sANSI_OEM
86338>>>            End
86338>>>>
86338>>>        End
86338>>>>
86338>>>
86338>>>        Move False to Err
86339>>>        If (sDriverID = DATAFLEX_ID) Begin
86341>>>            Move sRootName to sPhysicalFile
86342>>>        End
86342>>>>
86342>>>
86342>>>        If (sDriverID <> DATAFLEX_ID) Begin
86344>>>            Move SQLConnection.sConnectionID to sConnectionID
86345>>>
86345>>>            // If DAW driver and we should use a connection id we need to
86345>>>            // check if the connection ID exists; else we create it before attempting creating the table
86345>>>            If (bUseConnectionID = True) Begin
86347>>>                Get IsConnectionID sConnectionID sDriverID to bExists
86348>>>                If (bExists = False) Begin
86350>>>                    Get AutoSetConnectionID sConnectionID to bOk
86351>>>                    If (bOk = False) Begin
86353>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86354>>>>
86354>>>                        Function_Return False
86355>>>                    End
86355>>>>
86355>>>                End
86355>>>>
86355>>>            End
86355>>>>
86355>>>
86355>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86357>>>                Move (sTableName + ".int") to sPhysicalFile
86358>>>            End
86358>>>>
86358>>>            Else Begin
86359>>>                Move (sRootName + ".int") to sPhysicalFile
86360>>>            End
86360>>>>
86360>>>            Move (Uppercase(sDisplayName)) to sVal
86361>>>//            If (not(sVal contains (sSchema + "."))) Begin
86361>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
86361>>>//            End
86361>>>        End
86361>>>>
86361>>>        Move False to Err
86362>>>        Move 0 to hFile
86363>>>
86363>>>        Structure_Start hFile sDriverID
86364>>>            If (sDriverID <> DATAFLEX_ID) Begin
86366>>>                If (bUseConnectionID = True) Begin
86368>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
86371>>>                End
86371>>>>
86371>>>                Else Begin
86372>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
86375>>>                End
86375>>>>
86375>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
86378>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
86381>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
86384>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
86387>>>
86387>>>                If (sSchema <> "") Begin
86389>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
86392>>>                End
86392>>>>
86392>>>
86392>>>                If (sDriverID = DB2_DRV_ID) Begin
86394>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
86396>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
86399>>>                    End
86399>>>>
86399>>>                End
86399>>>>
86399>>>                If (sDriverID = DB2_DRV_ID) Begin
86401>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
86403>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
86406>>>                    End
86406>>>>
86406>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
86408>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
86411>>>                    End
86411>>>>
86411>>>                End
86411>>>>
86411>>>            End
86411>>>>
86411>>>
86411>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
86414>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
86415>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86416>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86418>>>        Set Action_Text of ghoStatusPanel to ""
86419>>>
86419>>>        Move (not(Err)) to bOK
86420>>>        If (bOk = True) Begin
86422>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86424>>>                Move (sDriverID + ":" + sRootName) to sRootName
86425>>>            End
86425>>>>
86425>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86428>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86431>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86434>>>
86434>>>            // Lastly we remove the temporary column we created above, if all went well.
86434>>>            If (bDeleteDummy) Begin
86436>>>                Get ApiColumnRemove hTable "temp" to bOk
86437>>>            End
86437>>>>
86437>>>        End
86437>>>>
86437>>>
86437>>>        Set TableName_Text of ghoStatusPanel to ""
86438>>>        Close hTable
86439>>>        Function_Return (bOK = True)
86440>>>    End_Function
86441>>>
86441>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
86443>>>        Move False to Err
86444>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
86447>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
86450>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
86453>>>
86453>>>        Function_Return (Err = False)
86454>>>    End_Function
86455>>>
86455>>>    // ToDo: Needs to be revised
86455>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
86457>>>        Handle hTable
86457>>>        String sDEFName sDataPath
86457>>>        Boolean bExists
86457>>>
86457>>>        // Do nothing if MSSQL Driver.
86457>>>//        Get IsMSSQLDriver to bExists
86457>>>//        If (bExists = True) Begin
86457>>>//            Procedure_Return
86457>>>//        End
86457>>>
86457>>>        Get psDataPathFirstPart to sDataPath
86458>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
86459>>>        If (bExists = True) Begin
86461>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
86461>>>            // still be missing from the filelist and needs to be added.
86461>>>            Get _UtilTableNumberIsInUse iFilelistSlot to bExists
86462>>>            If (bExists = True) Begin
86464>>>                Procedure_Return
86465>>>            End
86465>>>>
86465>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
86465>>>            Else Begin
86466>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
86469>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
86472>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
86475>>>                Procedure_Return
86476>>>            End
86476>>>>
86476>>>        End
86476>>>>
86476>>>
86476>>>        Move (sPath + sFileName + ".def") to sDEFName
86477>>>        Move 0 to hTable
86478>>>        Move False to Err
86479>>>
86479>>>        Structure_Start hTable DATAFLEX_ID
86480>>>            Load_Def sDEFName Onto hTable
86481>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
86484>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86485>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86487>>>        Set Action_Text of ghoStatusPanel to ""
86488>>>
86488>>>        Move iFilelistSlot to hTable
86489>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
86492>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86495>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86498>>>
86498>>>    End_Procedure
86499>>>
86499>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
86501>>>        Boolean bTmp bErr bOK
86501>>>        String sTableName sDisplayName sFileName
86501>>>
86501>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
86501>>>        Move Err to bTmp
86502>>>        Move False to Err
86503>>>
86503>>>        Get AutoConnectionIDLogin to bOK
86504>>>        // First get the info for the current filelist slot:
86504>>>        Open iFromFileSlot
86506>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
86509>>>        If (bOK = True) Begin
86511>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
86514>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
86517>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
86520>>>
86520>>>            //...then move it.
86520>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
86523>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
86526>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
86529>>>
86529>>>            //...and finally remove the old filelist values.
86529>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
86532>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
86535>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
86538>>>        End
86538>>>>
86538>>>        Close iFromFileSlot
86539>>>
86539>>>        Move Err to bErr
86540>>>        Move bTmp to Err
86541>>>        Function_Return (bErr = False)
86542>>>    End_Function
86543>>>
86543>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
86545>>>        Handle hTable
86545>>>        Boolean bOK
86545>>>        String sDriverID
86545>>>
86545>>>        Get _UtilTableExists hTableFrom to bOK
86546>>>        If (bOK = False) Begin
86548>>>            Set Private.phCurrentTable to hTableFrom
86549>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86550>>>>
86550>>>            Function_Return False
86551>>>        End
86551>>>>
86551>>>
86551>>>        Get _UtilTableExists hTableTo to bOK
86552>>>        If (bOK = False) Begin
86554>>>            Set Private.phCurrentTable to hTableTo
86555>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86556>>>>
86556>>>            Function_Return False
86557>>>        End
86557>>>>
86557>>>
86557>>>        Get AutoConnectionIDLogin to bOK
86558>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
86559>>>        If (bOK = False) Begin
86561>>>            Function_Return False
86562>>>        End
86562>>>>
86562>>>
86562>>>        Move False to Err
86563>>>        Open hTableTo
86565>>>
86565>>>        Move hTableFrom to hTable
86566>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86569>>>        Set Private.phCurrentTable to hTable
86570>>>
86570>>>        Structure_Start hTable sDriverID
86571>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
86574>>>            If (iColumnTo <> 0) Begin
86576>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
86579>>>            End
86579>>>>
86579>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86580>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86582>>>        Set Action_Text of ghoStatusPanel to ""
86583>>>
86583>>>        If (hTableTo > 0) Begin
86585>>>            Close hTableTo
86586>>>        End
86586>>>>
86586>>>
86586>>>        Function_Return (Err = False)
86587>>>    End_Function
86588>>>
86588>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
86588>>>    Function ApiTableRemove Handle hTable Returns Boolean
86590>>>        String sTableName sDriverID
86590>>>        Boolean bOk
86590>>>        String sDataPath
86590>>>
86590>>>        Get AutoConnectionIDLogin to bOK
86591>>>        Move False to Err
86592>>>        Get psDriverID to sDriverID
86593>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
86594>>>        If (sTableName = "") Begin
86596>>>            Function_Return False
86597>>>        End
86597>>>>
86597>>>
86597>>>        Set Private.phCurrentTable to hTable
86598>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
86599>>>        Delete_db sTableName
86600>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
86601>>>
86601>>>        If (sDriverID <> DATAFLEX_ID) Begin
86603>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
86603>>>            Get psDataPathFirstPart to sDataPath
86604>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
86605>>>        End
86605>>>>
86605>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
86605>>>        If (hTable <> 0) Begin
86607>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86610>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86613>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86616>>>        End
86616>>>>
86616>>>
86616>>>        Close hTable
86617>>>        Function_Return (hTable <> 0)
86618>>>    End_Function
86619>>>
86619>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
86621>>>        Handle hTable
86621>>>        Boolean bOK
86621>>>
86621>>>        Get AutoConnectionIDLogin to bOK
86622>>>        Move False to Err
86623>>>        Open hTableFrom Mode DF_EXCLUSIVE
86625>>>        Move hTableFrom to hTable
86626>>>
86626>>>        Structure_Start hTable
86627>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
86630>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86631>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86633>>>        Set Action_Text of ghoStatusPanel to ""
86634>>>
86634>>>        Close hTableFrom
86635>>>        Function_Return (Err = False)
86636>>>    End_Function
86637>>>
86637>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
86639>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
86639>>>        Boolean bOK bExists bOpened
86639>>>        tAPITableNameInfo APITableNameInfo
86639>>>        tAPITableNameInfo APITableNameInfo
86639>>>
86639>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86642>>>        If (bOpened = False) Begin
86644>>>            Get OpenTableExclusive hTable to bOpened
86645>>>            If (bOpened = False) Begin
86647>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
86648>>>                Function_Return False
86649>>>            End
86649>>>>
86649>>>        End
86649>>>>
86649>>>
86649>>>        Set Private.phCurrentTable to hTable
86650>>>        Move hTable         to APITableNameInfo.iTableNumber
86651>>>        Move sRootName      to APITableNameInfo.sRootName
86652>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
86653>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
86654>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfo to bExists
86655>>>        If (bExists = True) Begin
86657>>>            Function_Return True
86658>>>        End
86658>>>>
86658>>>
86658>>>        Set Private.phCurrentTable to hTable
86659>>>        Move False to Err
86660>>>        Get psDataPathFirstPart to sDataPath
86661>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
86664>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
86667>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
86670>>>
86670>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86673>>>        Close hTable
86674>>>        If (sDriverID = DATAFLEX_ID) Begin
86676>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
86677>>>            If (bExists = True) Begin
86679>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
86681>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
86684>>>                    // We need a short break here before attempting to delete the physical old files or Windows
86684>>>                    // might report "File in use..." and the deletion will fail.
86684>>>                    Sleep 2
86685>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
86686>>>                End
86686>>>>
86686>>>            End
86686>>>>
86686>>>        End
86686>>>>
86686>>>
86686>>>        If (sDriverID <> DATAFLEX_ID) Begin
86688>>>            If (not(sPhysicalName contains ".")) Begin
86690>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
86691>>>            End
86691>>>>
86691>>>
86691>>>            // Change the table name in the .int file to the new table new:
86691>>>            Get _UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
86692>>>            If (bOK = False) Begin
86694>>>                Function_Return False
86695>>>            End
86695>>>>
86695>>>
86695>>>            // Change table name at the SQL side:
86695>>>            Get psSchema to sSchema
86696>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
86697>>>
86697>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
86698>>>            // Remove cache file and Rename the physical file names:
86698>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
86699>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
86700>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
86701>>>            Move (sDriverID + ":" + sRootName) to sRootName
86702>>>
86702>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86702>>>//            If (not(sDisplayName contains ".")) Begin
86702>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
86702>>>//            End
86702>>>        End
86702>>>>
86702>>>
86702>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86705>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86708>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86711>>>
86711>>>        Function_Return (Err = False)
86712>>>    End_Function
86713>>>
86713>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
86715>>>        Move False to Err
86716>>>        Set Private.phCurrentTable to hTable
86717>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86720>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86723>>>
86723>>>        Function_Return (Err = False)
86724>>>    End_Function
86725>>>
86725>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
86725>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
86727>>>        Handle hTable
86727>>>        String sTableName
86727>>>        String sDriverIDFrom sDriverIDTo
86727>>>        Integer iDbType
86727>>>        Boolean bOk bOpened bApiTableUpdateAuto
86727>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
86727>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
86727>>>        tSQLConnection SQLConnection
86727>>>        tSQLConnection SQLConnection
86727>>>        tAPITable      APITableFrom APITableTo
86727>>>        tAPITable      APITableFrom APITableTo
86727>>>        tColumnType    ColumnType
86727>>>        tColumnType    ColumnType
86727>>>        tAPIColumnCompare[]   aAPIColumnCompare
86727>>>        tAPIColumnCompare[]   aAPIColumnCompare
86728>>>        tAPIIndexCompare[]    aAPIIndexCompare
86728>>>        tAPIIndexCompare[]    aAPIIndexCompare
86729>>>        tAPIRelationCompare[] aAPIRelationCompare
86729>>>        tAPIRelationCompare[] aAPIRelationCompare
86730>>>
86730>>>        // We don't allow changes to the framework's DbVersion table.
86730>>>        If (Lowercase(sTableName) = "dbversion") Begin
86732>>>            Function_Return False
86733>>>        End
86733>>>>
86733>>>
86733>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
86734>>>        Get piDbType                            to iDbType
86735>>>        Get pbRecnum                            to bRecnum
86736>>>        Get pbToANSI                            to bToANSI
86737>>>        Get pbCopyData                          to bCopyData
86738>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
86739>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
86740>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
86741>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
86742>>>        Get pbUseConnectionID                   to bUseConnectionID
86743>>>
86743>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
86744>>>        Set Private.phCurrentTable              to hTable
86745>>>        Get _UtilTableExists  hTable             to bTableExists
86746>>>
86746>>>        If (ghoProgressBar <> 0) Begin
86748>>>            Send DoAdvance of ghoProgressBar
86749>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
86750>>>            Set Message_Text   of ghoStatusPanel to ""
86751>>>            Set Action_Text    of ghoStatusPanel to ""
86752>>>        End
86752>>>>
86752>>>
86752>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
86753>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
86754>>>        Get _UtilTableIsSql hTable               to bIsSQLTableTo
86755>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
86756>>>        Move True                               to APITableFrom.bFromTable
86757>>>        Move hTable                             to APITableFrom.hTable
86758>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
86759>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
86760>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
86761>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
86762>>>
86762>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
86764>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
86765>>>            If (bOk = True) Begin
86767>>>                Get ApiTableAttachToSql hTable True to bOk
86768>>>                Function_Return bOk
86769>>>            End 
86769>>>>
86769>>>        End
86769>>>>
86769>>>
86769>>>        If (bTableExists = True) Begin
86771>>>            If (bIsSQLTableTo = True) Begin
86773>>>                Get _UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
86774>>>            End
86774>>>>
86774>>>
86774>>>            Get OpenTableExclusive hTable to bOpened
86775>>>            If (bOpened = False) Begin
86777>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
86778>>>                Function_Return False
86779>>>            End
86779>>>>
86779>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
86780>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
86781>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
86782>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
86783>>>        End
86783>>>>
86783>>>
86783>>>        Move False to Err
86784>>>        Case Begin
86784>>>            // Alias table:
86784>>>            Case (bIsAliasFrom = True)
86786>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
86787>>>                Case Break
86788>>>
86788>>>            // New Table:
86788>>>            Case (bTableExists = False)
86791>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
86792>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
86792>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
86794>>>                    Get ApiTableChangeAttribute hTable DF_FILE_IS_SYSTEM_FILE True to bOK
86795>>>                End                                                                 
86795>>>>
86795>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
86796>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
86797>>>                Case Break
86798>>>
86798>>>            // Update table:
86798>>>            Case (bTableExists = True)
86801>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
86802>>>                If (bIsSame = True) Begin
86804>>>                    Case Break
86805>>>                End
86805>>>>
86805>>>                If (bFilelistError = True) Begin
86807>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
86808>>>                    If (bOk = False) Begin
86810>>>                        Case Break
86811>>>                    End
86811>>>>
86811>>>                End
86811>>>>
86811>>>
86811>>>                If (ghoProgressBar <> 0) Begin
86813>>>                    Send DoAdvance of ghoProgressBar
86814>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
86815>>>                End
86815>>>>
86815>>>
86815>>>                // Columns:
86815>>>                Move True to bOk
86816>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
86817>>>                If (bIsSame = False) Begin
86819>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
86820>>>                End
86820>>>>
86820>>>                If (bOk = False) Begin
86822>>>                    Case Break
86823>>>                End
86823>>>>
86823>>>
86823>>>                // Indexes:
86823>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
86824>>>                If (bIsSame = False) Begin
86826>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
86827>>>                End
86827>>>>
86827>>>
86827>>>                // Relations:
86827>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
86828>>>                If (bIsSame = False) Begin
86830>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
86831>>>                    If (bOk = False) Begin
86833>>>                        Case Break
86834>>>                    End
86834>>>>
86834>>>                End
86834>>>>
86834>>>
86834>>>                Case Break
86835>>>
86835>>>            Case Else
86835>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
86836>>>>
86836>>>                Move False to bOk
86837>>>        Case End
86837>>>        
86837>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
86837>>>        // or convert an embedded table to SQL
86837>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
86839>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
86840>>>            If (bOk = False) Begin
86842>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
86843>>>            End
86843>>>>
86843>>>        End
86843>>>>
86843>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
86846>>>            Get SqlTableConvertToEmbedded hTable True to bOk
86847>>>        End
86847>>>>
86847>>>        
86847>>>        // Filelist Names:
86847>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
86848>>>        Close hTable
86849>>>        Set TableName_Text of ghoStatusPanel to ""
86850>>>
86850>>>        Function_Return (bOK = True)
86851>>>    End_Function
86852>>>
86852>>>    // * Dummy function for the Studio's Code Explorer *
86852>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
86854>>>        Function_Return False
86855>>>    End_Function
86856>>>
86856>>>    // Adds a column name to the passed table number.
86856>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
86858>>>        Integer iColumn iCount iFile iPrecision iLastErr
86858>>>        Boolean bExists bOK bInitializeValue bRetval
86858>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
86858>>>
86858>>>        Get UtilColumnExists hTable sFieldName to bExists
86859>>>        If (bExists = True) Begin
86861>>>            Function_Return False
86862>>>        End
86862>>>>
86862>>>
86862>>>        Move False to Err
86863>>>        If (num_arguments > 4) Begin
86865>>>            Move iPrec to iPrecision
86866>>>        End
86866>>>>
86866>>>        If (num_arguments > 6) Begin
86868>>>            Move bInitVal to bInitializeValue
86869>>>            Move sColVal  to sColumnValue
86870>>>        End
86870>>>>
86870>>>        If (iType < -1490) Begin
86872>>>            Move (iType + 1500) to iType
86873>>>        End
86873>>>>
86873>>>
86873>>>        Move hTable to iFile
86874>>>        Get psDriverID to sDriverID
86875>>>        Get AutoConnectionIDLogin to bOK
86876>>>        Move False to Err
86877>>>        Move LastErr to iLastErr
86878>>>        Get OpenTableExclusive iFile to bOK
86879>>>        Set Private.phCurrentTable to hTable
86880>>>
86880>>>        Structure_Start iFile sDriverID
86881>>>            Move 0 to iColumn
86882>>>            Set Private.piCurrentField to iColumn
86883>>>            Create_Field hTable At iColumn
86884>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
86887>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
86890>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
86893>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
86896>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86897>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86899>>>
86899>>>        Set Action_Text of ghoStatusPanel to ""
86900>>>
86900>>>        // If in development environment; create .fd file:
86900>>>        Open hTable
86902>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
86903>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
86904>>>        If (iCount > 1) Begin
86906>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
86907>>>        End
86907>>>>
86907>>>        Get vFolderExists sDDSrcPath to bExists
86908>>>        If (bExists = True) Begin
86910>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
86911>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86914>>>            Get _TableNameOnly sTableName to sTableName
86915>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
86917>>>        End
86917>>>>
86917>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
86919>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
86920>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
86921>>>            If (iCount > 1) Begin
86923>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
86924>>>            End
86924>>>>
86924>>>            Get vFolderFormat sDataPath to sDataPath
86925>>>            // Add the new column name to the .tag filen (if it doesn't exist):
86925>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
86925>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
86925>>>        End
86925>>>>
86925>>>        // Check for a default value
86925>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
86927>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
86928>>>        End
86928>>>>
86928>>>        Close hTable
86929>>>
86929>>>        Function_Return (Err = False)
86930>>>    End_Function
86931>>>
86931>>>    // Adds a column name to the passed table number.
86931>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
86933>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
86933>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
86933>>>        String sDdSrcPath sTableName
86933>>>
86933>>>        Get UtilColumnExists hTable sFieldName to bExists
86934>>>        Move False to Err
86935>>>        If (bExists = True) Begin
86937>>>            Function_Return False
86938>>>        End
86938>>>>
86938>>>        If (num_arguments > 4) Begin
86940>>>            Move iPrec to iPrecision
86941>>>        End
86941>>>>
86941>>>        If (iType < -1490) Begin
86943>>>            Move (iType + 1500) to iType
86944>>>        End
86944>>>>
86944>>>
86944>>>        Get AutoConnectionIDLogin to bOK
86945>>>        Move False to Err
86946>>>        Get _UtilTableIsSql hTable to bIsSQLTypeTo
86947>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
86947>>>        // data types between Embedded and SQL, else we can't compare the data types. 
86947>>>        Get piDbType to iDbType
86948>>>        If (bIsSQLTypeTo = False) Begin
86950>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
86951>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
86953>>>                Move DF_DATE to iType
86954>>>            End
86954>>>>
86954>>>        End
86954>>>>
86954>>>
86954>>>        // Structure_start will change the value of hTable...
86954>>>        Move hTable to iFile
86955>>>        Get OpenTableExclusive iFile to bOK
86956>>>        If (bOK = False) Begin
86958>>>            Function_Return False
86959>>>        End
86959>>>>
86959>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
86962>>>
86962>>>        // If the passed column number is higher than the current number of fields
86962>>>        // in the table, this means we should _not_ insert a field but rather add
86962>>>        // a new field to the end:
86962>>>        If (iColumn > iNumberOfFields) Begin
86964>>>            Move 0 to iColumn
86965>>>        End
86965>>>>
86965>>>
86965>>>        Set Private.phCurrentTable to hTable
86966>>>        Set Private.piCurrentField to iColumn
86967>>>
86967>>>        Structure_Start iFile
86968>>>            Create_Field iFile At iColumn
86969>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
86972>>>            If (bIsSQLTypeTo = False) Begin
86974>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
86977>>>            End
86977>>>>
86977>>>            Else Begin
86978>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
86981>>>            End
86981>>>>
86981>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
86982>>>            If (bIsDateType = False) Begin
86984>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
86987>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
86990>>>            End
86990>>>>
86990>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86991>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86993>>>
86993>>>        Set Action_Text of ghoStatusPanel to ""
86994>>>        // If in development environment; create .fd file:
86994>>>        Open hTable
86996>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
86997>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
86998>>>        If (iCount > 1) Begin
87000>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87001>>>        End
87001>>>>
87001>>>        Get vFolderExists sDDSrcPath to bExists
87002>>>        If (bExists = True) Begin
87004>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87005>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87008>>>            Get _TableNameOnly sTableName to sTableName
87009>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87011>>>        End
87011>>>>
87011>>>
87011>>>        // Check for a default value
87011>>>        Close hTable
87012>>>
87012>>>        Function_Return (Err = False)
87013>>>    End_Function
87014>>>
87014>>>    // To update all records for a table column with a fixed value.
87014>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
87016>>>        Integer iRecs iCurrErr iField iRecord
87016>>>        Boolean bRetval bOpen
87016>>>
87016>>>        Move 0 to iRecs
87017>>>        Move False to bRetval
87018>>>        Move Err to iCurrErr
87019>>>        Move False to Err
87020>>>
87020>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87023>>>        If (bOpen = False) Begin
87025>>>            Open hTable
87027>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87030>>>            If (bOpen = False) Begin
87032>>>                Function_Return bRetval
87033>>>            End
87033>>>>
87033>>>        End
87033>>>>
87033>>>
87033>>>        Field_Map hTable sFieldName to iField
87035>>>        If (iField <> 0) Begin
87037>>>            Set Private.phCurrentTable to hTable
87038>>>            Set Private.piCurrentField to iField
87039>>>            Clear hTable
87040>>>            Repeat
87040>>>>
87040>>>                Vfind hTable 0 GT
87042>>>                If (Found) Begin
87044>>>                    If (ghoStatusPanel <> 0) Begin
87046>>>                        Get_Field_Value hTable 0 to iRecord
87049>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
87050>>>                    End
87050>>>>
87050>>>                    Reread hTable
87054>>>                        Set_Field_Value hTable iField to sColumnValue
87057>>>                        SaveRecord hTable
87058>>>                    Unlock
87059>>>>
87059>>>                End
87059>>>>
87059>>>           Until (not(Found))
87061>>>        End
87061>>>>
87061>>>
87061>>>        Move (Err = False) to bRetval
87062>>>        Move iCurrErr to Err
87063>>>
87063>>>        Function_Return bRetval
87064>>>    End_Function
87065>>>
87065>>>    // Note: This can only be used from within a Structure_Start/End construct.
87065>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
87067>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
87067>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
87067>>>        String sFieldName sDriverID sTableName sDefaultValue
87067>>>
87067>>>        Get psDriverID to sDriverID
87068>>>        Get piDbType to iDbType
87069>>>        Get UtilTableHandleToString hTable to sTableName
87070>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
87071>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
87072>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87073>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
87075>>>            Move True to bIsSqlTable
87076>>>        End
87076>>>>
87076>>>        Move False to bIsOpen
87077>>>        If (hTable > 0) Begin
87079>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87082>>>        End
87082>>>>
87082>>>        If (bIsOpen = True) Begin
87084>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87087>>>        End
87087>>>>
87087>>>        Else Begin
87088>>>            Get pbRecnum to bRecnumTable
87089>>>        End
87089>>>>
87089>>>
87089>>>        Move False to Err
87090>>>        Move (SizeOfArray(aColumns)) to iSize
87091>>>        Decrement iSize
87092>>>        for iCount from 0 to iSize
87098>>>>
87098>>>            Move aColumns[iCount].sFieldName to sFieldName
87099>>>            If (hTable > 0) Begin
87101>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87102>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87103>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
87106>>>                Move (Trim(sFieldName) <> "") to bFieldExists
87107>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87108>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87109>>>            End
87109>>>>
87109>>>            Else Begin
87110>>>                Move False to bFieldExists
87111>>>            End
87111>>>>
87111>>>
87111>>>            If (bFieldExists = False) Begin
87113>>>                Move 0 to iColumn
87114>>>                Create_Field hTable At iColumn
87115>>>            End
87115>>>>
87115>>>            Else Begin
87116>>>                Move iCount to iColumn
87117>>>            End
87117>>>>
87117>>>
87117>>>            Set Private.piCurrentField to iColumn
87118>>>
87118>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
87119>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
87122>>>
87122>>>            Move aColumns[iCount].iType to iType
87123>>>            Move (not(iType < -1490)) to bNativeType
87124>>>            If (iType < -1490) Begin
87126>>>                Move (iType + 1500) to iType
87127>>>            End
87127>>>>
87127>>>
87127>>>            If (bIsSqlTable = True) Begin
87129>>>                If (aColumns[iCount].bIsSQLType = True) Begin
87131>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
87132>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
87135>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
87138>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
87141>>>
87141>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
87142>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87144>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87145>>>                    End
87145>>>>
87145>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
87148>>>
87148>>>                End
87148>>>>
87148>>>                Else Begin
87149>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
87152>>>                End
87152>>>>
87152>>>            End
87152>>>>
87152>>>            Else Begin
87153>>>                If (bCreating = False) Begin
87155>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
87156>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87158>>>                        Move DF_DATE to iType
87159>>>                    End
87159>>>>
87159>>>                End
87159>>>>
87159>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
87162>>>            End
87162>>>>
87162>>>
87162>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
87163>>>            If (bIsDateType = False) Begin
87165>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
87168>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
87171>>>            End
87171>>>>
87171>>>
87171>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
87173>>>                Move 0 to iIndex
87174>>>                Create_Index hTable at iIndex
87175>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
87178>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
87181>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
87184>>>
87184>>>                // If we have an identity table - we must create a primary_key table.
87184>>>                If (bIsSqlTable = True) Begin
87186>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
87189>>>                        Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
87192>>>                End
87192>>>>
87192>>>            End
87192>>>>
87192>>>        Loop
87193>>>>
87193>>>
87193>>>        Function_Return (Err = False)
87194>>>    End_Function
87195>>>
87195>>>    // Changes a field type, length and precision for the passed table number and field name
87195>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
87197>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
87197>>>        Boolean bOK bIsSqlTable
87197>>>        String sFieldNameTo
87197>>>
87197>>>        If (num_arguments > 4) Begin
87199>>>            Move iPrec to iPrecFrom
87200>>>        End
87200>>>>
87200>>>        If (iTypeFrom < -1490) Begin
87202>>>            Move (iTypeFrom + 1500) to iTypeFrom
87203>>>        End
87203>>>>
87203>>>
87203>>>        Get AutoConnectionIDLogin to bOK
87204>>>        Move False to Err
87205>>>        Get OpenTableExclusive hTable to bOK
87206>>>        If (bOK = False) Begin
87208>>>            Function_Return False
87209>>>        End
87209>>>>
87209>>>
87209>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87210>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87211>>>        Field_Map hTable sFieldNameFrom to iColumn
87213>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87214>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87215>>>        If (Err = True) Begin
87217>>>            Function_Return False
87218>>>        End
87218>>>>
87218>>>
87218>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
87221>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87222>>>        If (bIsSqlTable = False) Begin
87224>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
87227>>>        End
87227>>>>
87227>>>        Else Begin
87228>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
87231>>>        End
87231>>>>
87231>>>        // Let the driver decide the other values;
87231>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
87234>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
87237>>>
87237>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
87239>>>            Function_Return False
87240>>>        End
87240>>>>
87240>>>
87240>>>        Set Private.phCurrentTable to hTable
87241>>>        Set Private.piCurrentField to iColumn
87242>>>
87242>>>        Structure_Start hTable
87243>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
87246>>>//            If (bIsSqlTable = False) Begin
87246>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87249>>>//            End
87249>>>//            Else Begin
87249>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87249>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
87249>>>//            End
87249>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
87252>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
87255>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87256>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87258>>>
87258>>>        Set Action_Text of ghoStatusPanel to ""
87259>>>        Function_Return (Err = False)
87260>>>    End_Function
87261>>>
87261>>>    // Changes a field type, length and precision for the passed table number and field name
87261>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
87263>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
87263>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
87263>>>        String sFieldNameTo sDriverIDTo
87263>>>        tColumnType ColumnType
87263>>>        tColumnType ColumnType
87263>>>
87263>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
87264>>>        Get piDbType to iDbType
87265>>>        If (num_arguments > 4) Begin
87267>>>            Move iPrec to iPrecFrom
87268>>>            Move iOpt  to iOptionFrom
87269>>>        End
87269>>>>
87269>>>        If (iTypeFrom < -1490) Begin
87271>>>            Move (iTypeFrom + 1500) to iTypeFrom
87272>>>        End
87272>>>>
87272>>>
87272>>>        Get AutoConnectionIDLogin to bOK
87273>>>        Move False to Err
87274>>>        Close hTable
87275>>>        Get OpenTableExclusive hTable to bOK
87276>>>        If (bOK = False) Begin
87278>>>            Function_Return False
87279>>>        End
87279>>>>
87279>>>
87279>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
87282>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
87285>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
87286>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87288>>>            Move DF_DATE to iDataFlexType
87289>>>        End
87289>>>>
87289>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
87292>>>
87292>>>        If (bIsSQLTableTo = True) Begin
87294>>>                Get_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeTo
87297>>>        End
87297>>>>
87297>>>        Else Begin
87298>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
87301>>>        End
87301>>>>
87301>>>
87301>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
87304>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
87307>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
87310>>>
87310>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87310>>>        // data types between Embedded and SQL, else we can't compare the data types.
87310>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87312>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
87313>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87315>>>                Move DF_DATE to iTypeTo  
87316>>>            End
87316>>>>
87316>>>        End
87316>>>>
87316>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87319>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
87320>>>        End
87320>>>>
87320>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
87321>>>
87321>>>        If (bCompareDate_DateTime = False) Begin
87323>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
87324>>>            If (bSkip = True) Begin
87326>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87328>>>                    Function_Return True
87329>>>                End
87329>>>>
87329>>>            End
87329>>>>
87329>>>        End
87329>>>>
87329>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87332>>>            Function_Return True
87333>>>        End
87333>>>>
87333>>>
87333>>>        Set Private.phCurrentTable to hTable
87334>>>        Set Private.piCurrentField to iColumn
87335>>>
87335>>>        Structure_Start hTable
87336>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
87338>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
87341>>>            End
87341>>>>
87341>>>
87341>>>            If (bIsSameDataType = False) Begin
87343>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
87346>>>                If (bIsSQLTableTo = True) Begin
87348>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeFrom
87351>>>                End
87351>>>>
87351>>>            End
87351>>>>
87351>>>
87351>>>            If (iLengthFrom <> iLengthTo) Begin
87353>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
87356>>>            End
87356>>>>
87356>>>            If (iPrecFrom <> iPrecTo) Begin
87358>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
87361>>>            End
87361>>>>
87361>>>
87361>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
87363>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
87363>>>                If (bRecnumTable = True) Begin
87365>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
87368>>>                End
87368>>>>
87368>>>
87368>>>                // We might need to create an index here.
87368>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
87368>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
87368>>>                // index update checking logic.
87368>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
87371>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
87373>>>                    Create_Index hTable At iIndex
87374>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
87377>>>                End
87377>>>>
87377>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
87380>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
87383>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
87386>>>                If (bIsSQLTableTo = True) Begin
87388>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
87391>>>                End
87391>>>>
87391>>>            End
87391>>>>
87391>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87392>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87394>>>
87394>>>        Set Action_Text of ghoStatusPanel to ""
87395>>>        Function_Return (Err = False)
87396>>>    End_Function
87397>>>
87397>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
87399>>>        Boolean bOK
87399>>>
87399>>>        Get AutoConnectionIDLogin to bOK
87400>>>        Move False to Err
87401>>>        Get OpenTableExclusive hTable to bOK
87402>>>        If (bOK = False) Begin
87404>>>            Function_Return False
87405>>>        End
87405>>>>
87405>>>
87405>>>        Structure_Start hTable
87406>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
87409>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87410>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87412>>>
87412>>>        Set Action_Text of ghoStatusPanel to ""
87413>>>        Function_Return (Err = False)
87414>>>    End_Function
87415>>>
87415>>>    // To move an existing field to another position in a table.
87415>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
87417>>>        String sColumn sDriverID
87417>>>        Integer iType
87417>>>        Boolean bOK bIsDate
87417>>>
87417>>>        Close hTable
87418>>>        Get AutoConnectionIDLogin to bOK
87419>>>        Get OpenTableExclusive hTable to bOK
87420>>>        If (bOK = False) Begin
87422>>>            Function_Return False
87423>>>        End
87423>>>>
87423>>>
87423>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87426>>>        If (sDriverID = DFBTRDRV_ID) Begin
87428>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
87429>>>>
87429>>>            Function_Return False
87430>>>        End
87430>>>>
87430>>>
87430>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
87433>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
87436>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
87437>>>
87437>>>        Set Private.phCurrentTable to hTable
87438>>>        Set Private.piCurrentField to iOld
87439>>>
87439>>>//        If (bIsDate = False) Begin
87439>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
87439>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
87439>>>//        End
87439>>>//        Else Begin
87439>>>//            Move 6 to iLength
87439>>>//            Move 0 to iPrecision
87439>>>//        End
87439>>>
87439>>>        Move False to Err
87440>>>
87440>>>        Structure_Start hTable
87441>>>            Delete_Field hTable iOld
87442>>>            Create_Field hTable At iNew
87443>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
87446>>>
87446>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
87449>>>            If (bIsSQLType = False) Begin
87451>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87454>>>            End
87454>>>>
87454>>>            Else Begin
87455>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87458>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
87458>>>            End
87458>>>>
87458>>>
87458>>>            If (bIsDate = False) Begin
87460>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
87463>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
87466>>>            End
87466>>>>
87466>>>
87466>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87467>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87469>>>
87469>>>        Set Action_Text of ghoStatusPanel to ""
87470>>>        Function_Return (Err = False)
87471>>>    End_Function
87472>>>
87472>>>    // Deletes a column name for the passed table number (and column number).
87472>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
87474>>>        Integer iColumn
87474>>>        Boolean bOK
87474>>>
87474>>>        Get AutoConnectionIDLogin to bOK
87475>>>        Move False to Err
87476>>>        Close hTable
87477>>>        Get OpenTableExclusive hTable to bOK
87478>>>        If (bOK = False) Begin
87480>>>            Function_Return False
87481>>>        End
87481>>>>
87481>>>
87481>>>        If (not(Err)) Begin
87483>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87484>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87485>>>            Field_Map hTable sFieldName to iColumn
87487>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87488>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87489>>>            If (iColumn = 0) Begin
87491>>>                Move 0 to LastErr
87492>>>                Function_Return False
87493>>>            End
87493>>>>
87493>>>            Move False to Err
87494>>>
87494>>>            Set Private.phCurrentTable to hTable
87495>>>            Set Private.piCurrentField to iColumn
87496>>>
87496>>>            Structure_Start hTable
87497>>>                Delete_Field hTable iColumn
87498>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87499>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87501>>>            Set Action_Text of ghoStatusPanel to ""
87502>>>        End
87502>>>>
87502>>>        Else Begin
87503>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
87504>>>>
87504>>>        End
87504>>>>
87504>>>
87504>>>        Function_Return (Err = False)
87505>>>    End_Function
87506>>>
87506>>>    // Renames a field for the passed table number & old field name & new field name
87506>>>    // Returns True if no errors occured.
87506>>>    // Sample usage:
87506>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
87506>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
87508>>>        Integer iField
87508>>>        Boolean bOK bExists bIsOpen
87508>>>
87508>>>        Get UtilColumnExists hTable sNewFieldName to bExists
87509>>>        If (bExists = True) Begin
87511>>>            Function_Return False
87512>>>        End
87512>>>>
87512>>>
87512>>>        // Note: The Field_Map command does _not_ work if the table has been
87512>>>        //       opened exclusively, so we first open it in normal mode.
87512>>>        Close hTable
87513>>>        Open hTable
87515>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87518>>>        If (bIsOpen = False) Begin
87520>>>            Function_Return False
87521>>>        End
87521>>>>
87521>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87522>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87523>>>        Field_Map hTable sOldFieldName to iField
87525>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87526>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87527>>>
87527>>>        Get AutoConnectionIDLogin to bOK
87528>>>        Get OpenTableExclusive hTable to bOK
87529>>>        If (bOK = False) Begin
87531>>>            Function_Return False
87532>>>        End
87532>>>>
87532>>>
87532>>>        Move False to Err
87533>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87534>>>        Set Private.phCurrentTable to hTable
87535>>>        Set Private.piCurrentField to iField
87536>>>
87536>>>        If (iField > 0) Begin
87538>>>            Structure_Start hTable
87539>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
87542>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87543>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87545>>>        End
87545>>>>
87545>>>        Else Begin
87546>>>            Move 0 to LastErr
87547>>>            Move False to Err
87548>>>        End
87548>>>>
87548>>>
87548>>>        Set Action_Text of ghoStatusPanel to ""
87549>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87550>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87551>>>
87551>>>        Function_Return (Err = False)
87552>>>    End_Function
87553>>>
87553>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87555>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87555>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87556>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
87556>>>        Boolean bRenameField
87556>>>
87556>>>        Open hTable
87558>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87559>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87560>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87561>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
87564>>>        Move (iSize max iNumberOfFieldsTo) to iSize
87565>>>        Decrement iSize
87566>>>        for iCount from 0 to iSize
87572>>>>
87572>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87574>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87575>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87576>>>
87576>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
87578>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
87580>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
87581>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
87582>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
87584>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
87585>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
87586>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
87587>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
87588>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
87589>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
87590>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
87591>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
87592>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
87593>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
87594>>>                        Increment iItem
87595>>>                    End
87595>>>>
87595>>>                End
87595>>>>
87595>>>            End
87595>>>>
87595>>>        Loop
87596>>>>
87596>>>
87596>>>        Move False to Err
87597>>>        Move 0 to LastErr
87598>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87599>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87600>>>        Function_Return aAPIColumnsToInsert
87601>>>    End_Function
87602>>>
87602>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
87604>>>        Integer iSize iCount
87604>>>        Boolean bOK
87604>>>        tAPIColumn[] aColumnsTo
87604>>>        tAPIColumn[] aColumnsTo
87605>>>        tAPIColumnCompare[] aAPIColumnCompare
87605>>>        tAPIColumnCompare[] aAPIColumnCompare
87606>>>
87606>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
87607>>>        If (iSize = 0) Begin
87609>>>            Function_Return True
87610>>>        End
87610>>>>
87610>>>
87610>>>        Move False to Err
87611>>>        Decrement iSize
87612>>>        for iCount from 0 to iSize
87618>>>>
87618>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
87619>>>        Loop
87620>>>>
87620>>>
87620>>>        Function_Return bOK
87621>>>    End_Function
87622>>>
87622>>>    // Returns a struct array with fields that has the same names but different field numbers.
87622>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87624>>>        tAPIColumnCompare[] aAPIColumnsToMove
87624>>>        tAPIColumnCompare[] aAPIColumnsToMove
87625>>>        Integer iSize iCount iItem iShouldMove
87625>>>
87625>>>        Move 0 to iItem
87626>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87627>>>        Decrement iSize
87628>>>        for iCount from 0 to iSize
87634>>>>
87634>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87636>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
87637>>>                If (iShouldMove <> -1) Begin
87639>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
87640>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
87641>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
87642>>>                    Increment iItem
87643>>>                End
87643>>>>
87643>>>            End
87643>>>>
87643>>>        Loop
87644>>>>
87644>>>
87644>>>        Move False to Err
87645>>>        Move 0 to LastErr
87646>>>        Function_Return aAPIColumnsToMove
87647>>>    End_Function
87648>>>
87648>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
87650>>>        Integer iSize iCount
87650>>>        Boolean bOK
87650>>>        tAPIColumnCompare[] aAPIColumnCompare
87650>>>        tAPIColumnCompare[] aAPIColumnCompare
87651>>>
87651>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
87652>>>        If (iSize = 0) Begin
87654>>>            Function_Return True
87655>>>        End
87655>>>>
87655>>>
87655>>>        Move False to Err
87656>>>        Decrement iSize
87657>>>        for iCount from 0 to iSize
87663>>>>
87663>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87664>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87665>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
87667>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
87668>>>                Get UtilColumnsStructFill hTable to aColumnsTo
87669>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87670>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
87671>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
87673>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
87674>>>                    Decrement iSize
87675>>>                    Move 0 to iCount
87676>>>                End
87676>>>>
87676>>>            End
87676>>>>
87676>>>        Loop
87677>>>>
87677>>>
87677>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87678>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87679>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
87681>>>            Move 0 to LastErr
87682>>>        End
87682>>>>
87682>>>        Function_Return bOK
87683>>>    End_Function
87684>>>
87684>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
87684>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
87684>>>    // - The "FROM" field name is <> "TO" field name
87684>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
87684>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
87684>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
87686>>>        Boolean bShouldRename
87686>>>        String sFieldNameFrom sFieldNameTo
87686>>>
87686>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
87687>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
87688>>>        If (sFieldNameFrom = sFieldNameTo) Begin
87690>>>            Function_Return False
87691>>>        End
87691>>>>
87691>>>
87691>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
87692>>>//        If (bShouldRename = False) Begin
87692>>>//            Function_Return False
87692>>>//        End
87692>>>//
87692>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
87692>>>//            Function_Return True
87692>>>//        End
87692>>>
87692>>>        Function_Return bShouldRename
87693>>>    End_Function
87694>>>
87694>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
87694>>>    // Else it returns the column/field number of the field that exists in another position.
87694>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
87696>>>        Integer iCount iSize iRetval
87696>>>        String sFieldNameFrom
87696>>>
87696>>>        Move -1 to iRetval
87697>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
87699>>>            Function_Return iRetval
87700>>>        End
87700>>>>
87700>>>
87700>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
87701>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87702>>>        Decrement iSize
87703>>>        for iCount from 0 to iSize
87709>>>>
87709>>>            // We're only interested in fields other than the passed field/column number:
87709>>>            If (iCount <> iColumn) Begin
87711>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
87713>>>                    Move (iCount + 1) to iRetval
87714>>>                End
87714>>>>
87714>>>            End
87714>>>>
87714>>>        Loop
87715>>>>
87715>>>
87715>>>        Move 0 to LastErr
87716>>>        Function_Return iRetval
87717>>>    End_Function
87718>>>
87718>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87720>>>        tAPIColumnCompare[] aAPIColumnsToRename
87720>>>        tAPIColumnCompare[] aAPIColumnsToRename
87721>>>        Integer iSize iCount iItem iFieldTo iShouldMove
87721>>>        Boolean bRenameField
87721>>>
87721>>>        Open hTable
87723>>>        Move 0 to iItem
87724>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87725>>>        Decrement iSize
87726>>>        for iCount from 0 to iSize
87732>>>>
87732>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87734>>>                // Check if the field exists in another position (other field number)
87734>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
87735>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
87736>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
87738>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
87739>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
87740>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
87741>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
87742>>>                    Increment iItem
87743>>>                End
87743>>>>
87743>>>            End
87743>>>>
87743>>>        Loop
87744>>>>
87744>>>
87744>>>        Move False to Err
87745>>>        Move 0 to LastErr
87746>>>        Function_Return aAPIColumnsToRename
87747>>>    End_Function
87748>>>
87748>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
87750>>>        Integer iSize iCount
87750>>>        Boolean bOK
87750>>>        tAPIColumn[] aColumnsTo
87750>>>        tAPIColumn[] aColumnsTo
87751>>>        tAPIColumnCompare[] aAPIColumnCompare
87751>>>        tAPIColumnCompare[] aAPIColumnCompare
87752>>>
87752>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
87753>>>        If (iSize = 0) Begin
87755>>>            Function_Return True
87756>>>        End
87756>>>>
87756>>>
87756>>>        Move False to Err
87757>>>        Decrement iSize
87758>>>        For iCount from 0 to iSize
87764>>>>
87764>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87765>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
87766>>>        Loop
87767>>>>
87767>>>
87767>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87768>>>        Function_Return bOK
87769>>>    End_Function
87770>>>
87770>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
87772>>>        Boolean bDateType
87772>>>
87772>>>        If (bIsSQLTableTo = True) Begin
87774>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
87775>>>        End
87775>>>>
87775>>>        Else Begin
87776>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
87777>>>        End
87777>>>>
87777>>>
87777>>>        Function_Return bDateType
87778>>>    End_Function
87779>>>
87779>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
87781>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
87781>>>        Integer iCount2 iColumn2
87781>>>        Handle hFile
87781>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
87781>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
87781>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
87781>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
87781>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
87786>>>        tColumnType ColumnType
87786>>>        tColumnType ColumnType
87786>>>
87786>>>        Move False to Err
87787>>>        Close hTable
87788>>>        Get OpenTableExclusive hTable to bIsOpen
87789>>>        If (bIsOpen = False) Begin
87791>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
87792>>>>
87792>>>            Function_Return False
87793>>>        End 
87793>>>>
87793>>>        
87793>>>        Get piDbType to iDbType
87794>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87797>>>        Move bIsSQLTableFrom to bIsSQLDriver
87798>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
87799>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
87802>>>
87802>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87803>>>
87803>>>        // Before we start to change the table we need to do three things;
87803>>>        // 1) Insert any new fields
87803>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
87804>>>        If (SizeOfArray(aApiInsertColumns)) Begin
87806>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
87807>>>            If (bOK = False) Begin
87809>>>                Function_Return False
87810>>>            End
87810>>>>
87810>>>            // Update info with changes made.
87810>>>            Get UtilColumnsStructFill hTable to aColumnsTo
87811>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87812>>>        End
87812>>>>
87812>>>
87812>>>        // 2) Move fields with same names
87812>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
87813>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
87815>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
87816>>>            If (bOK = False) Begin
87818>>>                Function_Return False
87819>>>            End
87819>>>>
87819>>>            Get UtilColumnsStructFill hTable to aColumnsTo
87820>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87821>>>        End
87821>>>>
87821>>>        
87821>>>        // 3) Rename fields
87821>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
87822>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
87824>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
87825>>>            If (bOK = False) Begin
87827>>>                Function_Return False
87828>>>            End
87828>>>>
87828>>>            Get UtilColumnsStructFill hTable to aColumnsTo
87829>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87830>>>        End
87830>>>>
87830>>>
87830>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
87830>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
87830>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
87830>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
87830>>>//            If (bOK = False) Begin
87830>>>//                Function_Return False
87830>>>//            End
87830>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
87830>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87830>>>//        End
87830>>>
87830>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
87830>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
87832>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
87833>>>            If (bIsSame = True) Begin
87835>>>                Function_Return True
87836>>>            End
87836>>>>
87836>>>        End
87836>>>>
87836>>>
87836>>>        // We can now continue to make standard field changes:
87836>>>        Get OpenTableExclusive hTable to bIsOpen
87837>>>        Set Private.phCurrentTable to hTable
87838>>>        Move hTable to hFile
87839>>>        Structure_Start hFile sDriverIDTo
87840>>>
87840>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
87841>>>            Decrement iColumns
87842>>>            for iCount from 0 to iColumns
87848>>>>
87848>>>                Send DoAdvance of ghoProgressBar
87849>>>
87849>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
87850>>>                Set Private.piCurrentField                  to iColumn
87851>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
87852>>>                If (bIsSame = False) Begin
87854>>>
87854>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
87855>>>                    If (bFieldExistsFrom = True) Begin
87857>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
87858>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
87859>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
87860>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
87861>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
87862>>>
87862>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
87863>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
87864>>>                        If (iTypeFrom < -1490) Begin
87866>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
87867>>>                        End
87867>>>>
87867>>>
87867>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
87867>>>                        // data types between Embedded and SQL, else we can't compare the data types.
87867>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87869>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
87870>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87872>>>                                Move DF_DATE to iTypeFrom
87873>>>                            End
87873>>>>
87873>>>                        End
87873>>>>
87873>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87876>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
87877>>>                        End
87877>>>>
87877>>>
87877>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
87878>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
87879>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
87880>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
87881>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
87882>>>
87882>>>                        Move False to bSkipTypeChange
87883>>>                        If (bCompareDate_DateTime = False) Begin
87885>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
87886>>>                        End
87886>>>>
87886>>>
87886>>>                        If (bFieldExistsTo = False) Begin
87888>>>                            Move 0 to iColumn
87889>>>                            Create_Field hFile At iColumn
87890>>>                            Set Private.piCurrentField to iColumn
87891>>>                        End
87891>>>>
87891>>>
87891>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
87893>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
87896>>>                        End
87896>>>>
87896>>>
87896>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
87898>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
87901>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
87902>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87904>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87905>>>                            End
87905>>>>
87905>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
87908>>>                        End
87908>>>>
87908>>>
87908>>>                        If (bSkipTypeChange = False) Begin
87910>>>                            If (iTypeFrom <> iTypeTo) Begin
87912>>>                                If (bIsSQLTableTo = True) Begin
87914>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
87917>>>                                End
87917>>>>
87917>>>                                Else Begin                                                   
87918>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87920>>>                                        Move DF_DATE to iDataFlexType  // Date
87921>>>                                    End
87921>>>>
87921>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
87924>>>                                End
87924>>>>
87924>>>                            End
87924>>>>
87924>>>                        End
87924>>>>
87924>>>
87924>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
87925>>>                        // We can't set the length or precision for Date type columns (they are fixed).
87925>>>                        If (bIsDateType = False) Begin
87927>>>                            If (iLengthFrom <> iLengthTo) Begin
87929>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
87932>>>                            End
87932>>>>
87932>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
87934>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
87937>>>                            End
87937>>>>
87937>>>                        End
87937>>>>
87937>>>
87937>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
87939>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
87939>>>                            If (bRecnumTable = True) Begin
87941>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
87944>>>                            End
87944>>>>
87944>>>
87944>>>                            // We might need to create an index here.
87944>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
87944>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
87944>>>                            // index update checking logic.
87944>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
87947>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
87949>>>                                Create_Index hFile at iIndex
87950>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
87953>>>                            End
87953>>>>
87953>>>
87953>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
87956>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
87959>>>                                // Note: The order here is crucial!
87959>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
87962>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
87965>>>                        End
87965>>>>
87965>>>                    End
87965>>>>
87965>>>                    Else Begin
87966>>>                        Delete_Field hFile iColumn
87967>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
87968>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
87969>>>                        Decrement iCount2
87970>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
87970>>>                        // starting with the array number we just deleted the field for.
87970>>>                        for iColumn2 from iCount to iCount2
87976>>>>
87976>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
87977>>>                        Loop
87978>>>>
87978>>>                        Decrement iCount
87979>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87980>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
87981>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
87983>>>                            Move iColumns to iCount 
87984>>>                        End
87984>>>>
87984>>>                    End
87984>>>>
87984>>>                End
87984>>>>
87984>>>            Loop
87985>>>>
87985>>>
87985>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87986>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87988>>>
87988>>>        Set Action_Text of ghoStatusPanel to ""
87989>>>        Function_Return (Err = False)
87990>>>    End_Function
87991>>>
87991>>>    // * Dummy function for the Studio's Code Explorer *
87991>>>    Function API_INDEX_FUNCTIONS Returns Boolean
87993>>>        Function_Return False
87994>>>    End_Function
87995>>>
87995>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
87995>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
87995>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
87995>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
87997>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
87997>>>        String sDriverID
87997>>>        Boolean bOK bExists bIsSQLTable
87997>>>
87997>>>        Get AutoConnectionIDLogin to bOK
87998>>>        Get OpenTableExclusive hTable to bOK
87999>>>        If (bOK = False) Begin
88001>>>            Function_Return False
88002>>>        End
88002>>>>
88002>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88005>>>
88005>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88006>>>            If (bIsSQLTable = True) Begin
88008>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88011>>>            End
88011>>>>
88011>>>
88011>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
88014>>>        Move (iIndexSegments > 0) to bExists
88015>>>        If (bExists = True) Begin
88017>>>            Function_Return True
88018>>>        End
88018>>>>
88018>>>
88018>>>        Move -1 to iSegment1
88019>>>        Move -1 to iSegment2
88020>>>        Move -1 to iSegment3
88021>>>        Move -1 to iSegment4
88022>>>        Move -1 to iSegment5
88023>>>        Move -1 to iSegment6
88024>>>        Move -1 to iSegment7
88025>>>        Move -1 to iSegment8
88026>>>        Move -1 to iSegment9
88027>>>        Move -1 to iSegment10
88028>>>
88028>>>        If (num_arguments > 3) Begin
88030>>>            Move iSgmnt1 to iSegment1
88031>>>        End
88031>>>>
88031>>>        If (num_arguments > 4) Begin
88033>>>            Move iSgmnt2 to iSegment2
88034>>>        End
88034>>>>
88034>>>        If (num_arguments > 5) Begin
88036>>>            Move iSgmnt3 to iSegment3
88037>>>        End
88037>>>>
88037>>>        If (num_arguments > 6) Begin
88039>>>            Move iSgmnt4 to iSegment4
88040>>>        End
88040>>>>
88040>>>        If (num_arguments > 7) Begin
88042>>>            Move iSgmnt5 to iSegment5
88043>>>        End
88043>>>>
88043>>>        If (num_arguments > 8) Begin
88045>>>            Move iSgmnt6 to iSegment6
88046>>>        End
88046>>>>
88046>>>        If (num_arguments > 9) Begin
88048>>>            Move iSgmnt7 to iSegment7
88049>>>        End
88049>>>>
88049>>>        If (num_arguments > 10) Begin
88051>>>            Move iSgmnt8 to iSegment8
88052>>>        End
88052>>>>
88052>>>        If (num_arguments > 11) Begin
88054>>>            Move iSgmnt9 to iSegment9
88055>>>        End
88055>>>>
88055>>>        If (num_arguments > 12) Begin
88057>>>            Move iSgmnt10 to iSegment10
88058>>>        End
88058>>>>
88058>>>
88058>>>        Move False to Err
88059>>>        Move hTable to iTableNo
88060>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88061>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88062>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88063>>>
88063>>>        // We start by deleting the index, if it exists.
88063>>>        If (bExists = True) Begin
88065>>>            Structure_Start hTable sDriverID
88066>>>                Delete_Index iTableNo iIndex
88067>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88068>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88070>>>        End
88070>>>>
88070>>>
88070>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88071>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88072>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88073>>>        Set Action_Text of ghoStatusPanel to ""
88074>>>        Move False to Err
88075>>>        Move 0 to LastErr
88076>>>
88076>>>        // Need to re-open if index deleted.
88076>>>        Move iTableNo to hTable
88077>>>        Get OpenTableExclusive hTable to bOK
88078>>>        If (bOK = False) Begin
88080>>>            Function_Return False
88081>>>        End
88081>>>>
88081>>>
88081>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88082>>>        Structure_Start hTable sDriverID
88083>>>            Create_Index hTable At iIndex
88084>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88087>>>
88087>>>            If (iSgmnt1 <> -1) Begin
88089>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88092>>>            End
88092>>>>
88092>>>            If (iSegment2 <> -1) Begin
88094>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88097>>>            End
88097>>>>
88097>>>            If (iSegment3 <> -1) Begin
88099>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88102>>>            End
88102>>>>
88102>>>            If (iSegment4 <> -1) Begin
88104>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88107>>>            End
88107>>>>
88107>>>            If (iSegment5 <> -1) Begin
88109>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88112>>>            End
88112>>>>
88112>>>            If (iSegment6 <> -1) Begin
88114>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88117>>>            End
88117>>>>
88117>>>            If (iSegment7 <> -1) Begin
88119>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88122>>>            End
88122>>>>
88122>>>            If (iSegment8 <> -1) Begin
88124>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88127>>>            End
88127>>>>
88127>>>            If (iSegment9 <> -1) Begin
88129>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88132>>>            End
88132>>>>
88132>>>            If (iSegment10 <> -1) Begin
88134>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
88137>>>            End
88137>>>>
88137>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88138>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88140>>>
88140>>>        Set Action_Text of ghoStatusPanel to ""
88141>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88142>>>
88142>>>        Function_Return (Err = False)
88143>>>    End_Function
88144>>>
88144>>>    // Example:
88144>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
88144>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
88144>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
88146>>>        Integer iTableNo iNumSgmnt iNumSgmnts
88146>>>        String sDriverID
88146>>>        Boolean bOK bIsSQLTable
88146>>>
88146>>>        Get AutoConnectionIDLogin to bOK
88147>>>
88147>>>        Move False to Err
88148>>>        Move hTable to iTableNo
88149>>>        Get OpenTableExclusive hTable to bOK
88150>>>        If (bOK = False) Begin
88152>>>            Function_Return False
88153>>>        End
88153>>>>
88153>>>
88153>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88156>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88157>>>            If (bIsSQLTable = True) Begin
88159>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88162>>>            End
88162>>>>
88162>>>
88162>>>        // We start by deleting the index
88162>>>        Structure_Start hTable sDriverID
88163>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88164>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88165>>>            Delete_Index iTableNo iIndex
88166>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88167>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88168>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88170>>>
88170>>>        Move False to Err
88171>>>        Move iTableNo to hTable
88172>>>        Get OpenTableExclusive hTable to bOK
88173>>>        If (bOK = False) Begin
88175>>>            Function_Return False
88176>>>        End
88176>>>>
88176>>>
88176>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88177>>>        Structure_Start hTable sDriverID
88178>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
88179>>>
88179>>>            Create_Index hTable at iIndex
88180>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
88183>>>
88183>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
88189>>>>
88189>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
88192>>>            Loop
88193>>>>
88193>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88195>>>
88195>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88196>>>
88196>>>        Function_Return (Err = False)
88197>>>    End_Function
88198>>>
88198>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
88200>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
88200>>>        String sDriverID sSQLIndexName
88200>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
88200>>>
88200>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
88201>>>        If (iSegmentsFrom = 0) Begin
88203>>>            Function_Return False
88204>>>        End
88204>>>>
88204>>>
88204>>>        Get AutoConnectionIDLogin to bOK
88205>>>        Move False to Err
88206>>>        Get OpenTableExclusive hTable to bIsOpen
88207>>>        If (bIsOpen = False) Begin
88209>>>            Function_Return False
88210>>>        End
88210>>>>
88210>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88213>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88214>>>            If (bIsSQLTable = True) Begin
88216>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88219>>>            End
88219>>>>
88219>>>
88219>>>        Move 0     to iSegmentsTo
88220>>>        Move 0     to iSQLIndexType
88221>>>        Move ""    to sSQLIndexName
88222>>>        Move False to bIsSQLTemporaryIndex
88223>>>        Move False to bIsSQLPrimaryKey
88224>>>        Move False to bIsSQLClustered
88225>>>
88225>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
88226>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
88229>>>        Move (iSegmentsTo > 0) to bExists
88230>>>        If (bExists = True) Begin
88232>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
88234>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
88237>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
88240>>>                        Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
88241>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
88244>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
88247>>>            End
88247>>>>
88247>>>        End
88247>>>>
88247>>>
88247>>>        Move hTable to iTableNo
88248>>>        Move False to Err
88249>>>        Move 0 to LastErr
88250>>>
88250>>>        Structure_Start hTable sDriverID
88251>>>            If (bExists = True) Begin
88253>>>                Delete_Index iTableNo APIIndex.iIndexNumber
88254>>>            End
88254>>>>
88254>>>
88254>>>            Create_Index hTable At APIIndex.iIndexNumber
88255>>>
88255>>>                If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
88257>>>                    Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
88260>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
88263>>>                    Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
88266>>>                    Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
88269>>>                End
88269>>>>
88269>>>
88269>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
88272>>>
88272>>>            for iCount from 0 to (iSegmentsFrom -1)
88278>>>>
88278>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
88279>>>                If (iFieldFrom <> -1 ) Begin
88281>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
88284>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
88287>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
88290>>>                End
88290>>>>
88290>>>            Loop
88291>>>>
88291>>>
88291>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88292>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88294>>>
88294>>>        Set Action_Text of ghoStatusPanel to ""
88295>>>
88295>>>        Function_Return (Err = False)
88296>>>    End_Function
88297>>>
88297>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
88297>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
88297>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
88299>>>        Integer iLastIndex iCount iTableNo iSegments
88299>>>        String sSQLIndexNameCompare sTmpIndexName
88299>>>        Boolean bIsOpen bExists bIsSQLDriver 
88299>>>
88299>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88300>>>        
88300>>>        If (bIsSQLDriver = False) Begin
88302>>>            Function_Return False
88303>>>        End
88303>>>>
88303>>>
88303>>>        Move False to Err
88304>>>        Move hTable to iTableNo
88305>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
88308>>>        for iCount from 0 to iLastIndex
88314>>>>
88314>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
88317>>>            Move (iSegments > 0) to bExists
88318>>>            If (bExists = True) Begin
88320>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
88323>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
88325>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
88326>>>                    Structure_Start iTableNo sDriverID
88327>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
88330>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88332>>>                    Open hTable
88334>>>                End
88334>>>>
88334>>>            End
88334>>>>
88334>>>        Loop
88335>>>>
88335>>>
88335>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88338>>>        If (bIsOpen = False) Begin
88340>>>            Get OpenTableExclusive hTable to bIsOpen
88341>>>        End
88341>>>>
88341>>>        If (bIsOpen = False) Begin
88343>>>            Function_Return False
88344>>>        End
88344>>>>
88344>>>
88344>>>        Function_Return (Err = False)
88345>>>    End_Function
88346>>>
88346>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
88346>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
88346>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
88348>>>        Integer iSize iCount
88348>>>        Integer iRetVal
88348>>>
88348>>>        Move 0 to iRetVal
88349>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
88352>>>        If (iRetVal = 0) Begin
88354>>>            Function_Return 0
88355>>>        End
88355>>>>
88355>>>        Move (SizeOfArray(APIIndexTo)) to iSize
88356>>>        Decrement iSize
88357>>>        for iCount from 0 to iSize
88363>>>>
88363>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
88365>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
88367>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
88368>>>                End
88368>>>>
88368>>>            End
88368>>>>
88368>>>        Loop
88369>>>>
88369>>>
88369>>>        Function_Return iRetVal
88370>>>    End_Function
88371>>>
88371>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88373>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88373>>>        Boolean bIsSQLTable
88373>>>        
88373>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88374>>>            If (bIsSQLTable = True) Begin
88376>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88379>>>            End
88379>>>>
88379>>>
88379>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88382>>>        If (iSegment = iNumSegments) Begin
88384>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88384>>>        End
88384>>>>
88384>>>
88384>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88387>>>            for iCurSegment from iSegment to (iNumSegments - 1)
88393>>>>
88393>>>                //*** Move index segment attributes
88393>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88396>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88399>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88402>>>
88402>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
88405>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
88408>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
88411>>>            Loop
88412>>>>
88412>>>
88412>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88415>>>        End
88415>>>>
88415>>>
88415>>>        Function_Return (Err = False)
88416>>>    End_Function
88417>>>
88417>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
88419>>>        Integer iCount iSize iIndex
88419>>>        String sDriverID
88419>>>        Boolean bOK bIsSQLTable bIsOpen
88419>>>
88419>>>        Move (SizeOfArray(APIIndex)) to iSize
88420>>>        If (iSize = 0) Begin
88422>>>            Function_Return True
88423>>>        End
88423>>>>
88423>>>
88423>>>        Get AutoConnectionIDLogin to bOK
88424>>>        Move False to Err
88425>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88428>>>        If (bIsOpen = False) Begin
88430>>>            Get OpenTableExclusive hTable to bIsOpen
88431>>>            If (bIsOpen = False) Begin
88433>>>                Function_Return False
88434>>>            End
88434>>>>
88434>>>        End
88434>>>>
88434>>>
88434>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88437>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88438>>>            If (bIsSQLTable = True) Begin
88440>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88443>>>            End
88443>>>>
88443>>>
88443>>>        Move False to Err
88444>>>        Move 0 to LastErr
88445>>>        Decrement iSize
88446>>>
88446>>>        Structure_Start hTable sDriverID
88447>>>            for iCount from 0 to iSize
88453>>>>
88453>>>//                Move False to bIsSQLPrimaryKey
88453>>>//                #IF (!@ > 180)   // DF 18.1 and up
88453>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88453>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
88453>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88453>>>//                #ENDIF
88453>>>                // We can't delete if this is a primary key index:
88453>>>//                If (bIsSQLPrimaryKey = False) Begin
88453>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
88454>>>                    Delete_Index hTable iIndex
88455>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88455>>>//                End
88455>>>            Loop
88456>>>>
88456>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88457>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88459>>>//        Move False to Err
88459>>>        Move 0 to LastErr
88460>>>
88460>>>        Set Action_Text of ghoStatusPanel to ""
88461>>>        Function_Return (Err = False)
88462>>>    End_Function
88463>>>
88463>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
88465>>>        Boolean bOK
88465>>>
88465>>>        Get AutoConnectionIDLogin to bOK
88466>>>        Move False to Err
88467>>>        Get OpenTableExclusive hTable to bOK
88468>>>        If (bOK = False) Begin
88470>>>            Function_Return False
88471>>>        End
88471>>>>
88471>>>        Structure_Start hTable
88472>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
88475>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88476>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88478>>>
88478>>>        Set Action_Text of ghoStatusPanel to ""
88479>>>        Function_Return (Err = False)
88480>>>    End_Function
88481>>>
88481>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
88483>>>        Integer iCase
88483>>>        Boolean bOK
88483>>>
88483>>>        If (bUppercase = True) Begin
88485>>>            Move DF_CASE_IGNORED to iCase
88486>>>        End
88486>>>>
88486>>>        Else Begin
88487>>>            Move DF_CASE_USED to iCase
88488>>>        End
88488>>>>
88488>>>
88488>>>        Get AutoConnectionIDLogin to bOK
88489>>>        Move False to Err
88490>>>        Get OpenTableExclusive hTable to bOK
88491>>>        If (bOK = False) Begin
88493>>>            Function_Return False
88494>>>        End
88494>>>>
88494>>>        Structure_Start hTable
88495>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
88498>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88499>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88501>>>
88501>>>        Set Action_Text of ghoStatusPanel to ""
88502>>>        Function_Return (Err = False)
88503>>>    End_Function
88504>>>
88504>>>    // To delete an index
88504>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
88506>>>        Integer iTableNo iNumSegments
88506>>>        String sDriverID
88506>>>        Boolean bOK bIsSQLTable
88506>>>
88506>>>        Get AutoConnectionIDLogin to bOK
88507>>>        Move False to Err
88508>>>        Move hTable to iTableNo
88509>>>        Get OpenTableExclusive hTable to bOK
88510>>>        If (bOK = False) Begin
88512>>>            Function_Return False
88513>>>        End
88513>>>>
88513>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88516>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88517>>>            If (bIsSQLTable = True) Begin
88519>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88522>>>            End
88522>>>>
88522>>>
88522>>>        // Check to see if the index exists or not...
88522>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88525>>>        If (iNumSegments = 0) Begin
88527>>>            Function_Return True // Then nothing to do.
88528>>>        End
88528>>>>
88528>>>
88528>>>        Structure_Start hTable sDriverID
88529>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88530>>>            Delete_Index iTableNo iIndex
88531>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88532>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88533>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88535>>>
88535>>>        Set Action_Text of ghoStatusPanel to ""
88536>>>        Function_Return (Err = False)
88537>>>    End_Function
88538>>>
88538>>>    // Delete an Index Segment
88538>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88540>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88540>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88540>>>        Integer iIndexType
88540>>>        String sDriverID
88540>>>
88540>>>        Get AutoConnectionIDLogin to bOK
88541>>>        Move False to Err
88542>>>
88542>>>        Get OpenTableExclusive hTable to bOK
88543>>>        If (bOK = False) Begin
88545>>>            Function_Return False
88546>>>        End
88546>>>>
88546>>>
88546>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88547>>>            If (bIsSQLTable = True) Begin
88549>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88552>>>            End
88552>>>>
88552>>>
88552>>>        // Check to see if the index exists or not...
88552>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88555>>>        If (iNumSegments = 0) Begin
88557>>>            Function_Return False
88558>>>        End
88558>>>>
88558>>>
88558>>>        Move False to bIndexTemporary
88559>>>        Get psDriverID to sDriverID
88560>>>        Get IsSQLDriver sDriverID to bSQLDriver
88561>>>        If (bSQLDriver) Begin
88563>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88566>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88569>>>                Move True to bIndexTemporary
88570>>>        End
88570>>>>
88570>>>
88570>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88570>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88572>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88575>>>            If (iSegment = iNumSegments) Begin
88577>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88580>>>            End
88580>>>>
88580>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88583>>>                For iCurSegment from iSegment to (iNumSegments - 1)
88589>>>>
88589>>>                    //*** Move index segment attributes
88589>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88592>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88595>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88598>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88601>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88604>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88607>>>                Loop
88608>>>>
88608>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88611>>>            End
88611>>>>
88611>>>        End
88611>>>>
88611>>>
88611>>>        Else Begin
88612>>>           Structure_Start hTable
88613>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88616>>>               If (iSegment = iNumSegments) Begin
88618>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88621>>>               End
88621>>>>
88621>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88624>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
88630>>>>
88630>>>                       //*** Move index segment attributes
88630>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88633>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88636>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88639>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88642>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88645>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88648>>>                   Loop
88649>>>>
88649>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88652>>>               End
88652>>>>
88652>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88653>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88655>>>            Set Action_Text of ghoStatusPanel to ""
88656>>>        End
88656>>>>
88656>>>
88656>>>        Function_Return (Err = False)
88657>>>    End_Function
88658>>>
88658>>>    // Add/Insert an Index Segment
88658>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
88660>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88660>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
88660>>>        Integer iIndexType
88660>>>        String sDriverId
88660>>>
88660>>>        Get AutoConnectionIDLogin to bOK
88661>>>        Move False to Err
88662>>>
88662>>>        Get OpenTableExclusive hTable to bOK
88663>>>        If (bOK = False) Begin
88665>>>            Function_Return False
88666>>>        End
88666>>>>
88666>>>
88666>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88667>>>            If (bIsSQLTable = True) Begin
88669>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88672>>>            End
88672>>>>
88672>>>
88672>>>        Move False to bIndexTemporary
88673>>>        // Check to see if the index exists or not...
88673>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88676>>>        If (iNumSegments = 0) Begin
88678>>>            Function_Return False
88679>>>        End
88679>>>>
88679>>>
88679>>>        Get psDriverID to sDriverID
88680>>>        Get IsSQLDriver sDriverID to bSQLDriver
88681>>>        If (bSQLDriver) Begin
88683>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88686>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88689>>>                Move True to bIndexTemporary
88690>>>        End
88690>>>>
88690>>>
88690>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88690>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88692>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88695>>>
88695>>>           If (iSegment > iNumSegments) Begin
88697>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88700>>>               Move (iNumSegments + 1) to iCurSegment
88701>>>           End
88701>>>>
88701>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
88704>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88707>>>               Move iNumSegments to iCurSegment
88708>>>
88708>>>               While (iCurSegment > iSegment)
88712>>>                   //*** Move index segment attributes
88712>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
88715>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
88718>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
88721>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
88724>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
88727>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
88730>>>                   Decrement iCurSegment
88731>>>               Loop
88732>>>>
88732>>>
88732>>>               //*** Now set new segment attributes
88732>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
88735>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
88738>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
88741>>>           End
88741>>>>
88741>>>        End
88741>>>>
88741>>>
88741>>>        Else Begin
88742>>>        Structure_Start hTable
88743>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88746>>>
88746>>>            If (iSegment > iNumSegments) Begin
88748>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88751>>>                Move (iNumSegments + 1) to iCurSegment
88752>>>            End
88752>>>>
88752>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
88755>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88758>>>                Move iNumSegments to iCurSegment
88759>>>
88759>>>                While (iCurSegment > iSegment)
88763>>>                    //*** Move index segment attributes
88763>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
88766>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
88769>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
88772>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88775>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88778>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88781>>>                    Decrement iCurSegment
88782>>>                Loop
88783>>>>
88783>>>
88783>>>                //*** Now set new segment attributes
88783>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
88786>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
88789>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
88792>>>            End
88792>>>>
88792>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88793>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88795>>>            Set Action_Text of ghoStatusPanel to ""
88796>>>        End
88796>>>>
88796>>>
88796>>>        Function_Return (Err = False)
88797>>>    End_Function
88798>>>
88798>>>    // * Dummy function for the Studio's Code Explorer *
88798>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
88800>>>        Function_Return False
88801>>>    End_Function  
88802>>>    
88802>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
88802>>>    // for an SQL conversion.
88802>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
88804>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
88804>>>        
88804>>>        Move True to bConvertTo30FormatbOK
88805>>>        Move True to bRepairAndReindexOK
88806>>>        Move True to bFixBogusDatesOK
88807>>>        Move True to bMoveMiscFilesToBackupOK
88808>>>        
88808>>>        If (bMoveMiscFilesToBackup = True) Begin   
88810>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
88811>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
88812>>>        End                                                                                
88812>>>>
88812>>>        If (bFixALLBogusFilelistEntries = True) Begin
88814>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
88815>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
88816>>>        End
88816>>>>
88816>>>        If (bConvertTo30Format = True) Begin
88818>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
88819>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
88820>>>        End                                                 
88820>>>>
88820>>>        If (bRepairAndReindex = True) Begin
88822>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
88823>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
88824>>>        End  
88824>>>>
88824>>>        If (bFixBogusDates = True) Begin
88826>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
88827>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
88828>>>        End                                    
88828>>>>
88828>>>        
88828>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
88829>>>    End_Function
88830>>>
88830>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
88832>>>        Boolean bOK bFlexErrs bTemp
88832>>>        Handle hTable
88832>>>        String sTableName
88832>>>        Integer iCount iSize
88832>>>        
88832>>>        Move True to bOK
88833>>>        Move 0 to hTable    
88834>>>
88834>>>        Get UtilFilelistNoOfTables to iSize
88835>>>        Set pbVisible    of ghoProgressBarOverall to True
88836>>>        Set piPosition   of ghoProgressBarOverall to 0
88837>>>        Set piMaximum    of ghoProgressBarOverall to iSize
88838>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
88839>>>
88839>>>        Repeat
88839>>>>
88839>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
88840>>>            Set piPosition of ghoProgressBarOverall to iCount  
88841>>>            Increment iCount
88842>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
88845>>>            If (hTable > 0) Begin
88847>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
88850>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
88851>>>                If (bFlexErrs = False) Begin
88853>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
88854>>>                    If (bTemp = False) Begin
88856>>>                        Move False to bOK
88857>>>                    End
88857>>>>
88857>>>                End
88857>>>>
88857>>>            End
88857>>>>
88857>>>        Until (hTable = 0)
88859>>>        
88859>>>        Set Action_Text of ghoStatusPanel to ""
88860>>>        Function_Return bOK
88861>>>    End_Function
88862>>>    
88862>>>    // Converts an embedded table from 2.3 -> 3.0.
88862>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
88862>>>    // It will return a TRUE if successful or the table is an SQL table.
88862>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
88864>>>        Boolean bOK bIsEmbedded bIsAlias
88864>>>        String sRevision
88864>>>        
88864>>>        Get AutoConnectionIDLogin to bOK
88865>>>        If (bOK = False) Begin
88867>>>            Function_Return True
88868>>>        End
88868>>>>
88868>>>        Get OpenTableExclusive hTable to bOK
88869>>>        If (bOK = False) Begin
88871>>>            Function_Return True
88872>>>        End
88872>>>>
88872>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
88873>>>        If (bIsEmbedded = False) Begin
88875>>>            Function_Return True
88876>>>        End                             
88876>>>>
88876>>>        Get UtilTableIsAlias hTable to bIsAlias
88877>>>        If (bIsAlias = True) Begin
88879>>>            Function_Return True
88880>>>        End                     
88880>>>>
88880>>>        
88880>>>        Move False to Err
88881>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
88884>>>        If (sRevision contains "2.3") Begin
88886>>>            Move False to Err
88887>>>            Set Private.phCurrentTable to hTable
88888>>>            Structure_Start hTable    
88889>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
88892>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
88893>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
88895>>>            Set Action_Text of ghoStatusPanel to ""
88896>>>        End
88896>>>>
88896>>>        
88896>>>        Function_Return (Err = False)
88897>>>    End_Function
88898>>>
88898>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
88900>>>        Boolean bIgnore bExists bOK bResponse
88900>>>        Handle hTable   
88900>>>        String sTableName
88900>>>        
88900>>>        Move False to Err 
88901>>>        Move True to bOK
88902>>>        Move 0 to hTable
88903>>>        Repeat
88903>>>>
88903>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
88906>>>            If (hTable > 0) Begin
88908>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
88911>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
88912>>>                If (bIgnore = False) Begin
88914>>>                    Get _UtilTableExists hTable to bExists
88915>>>                    If (bExists = False) Begin
88917>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
88918>>>                        If (bResponse = False) Begin
88920>>>                            Move False to bOK
88921>>>                        End
88921>>>>
88921>>>                        
88921>>>                    End
88921>>>>
88921>>>                End
88921>>>>
88921>>>            End
88921>>>>
88921>>>        Until (hTable = 0)                     
88923>>>        
88923>>>        Set Action_Text of ghoStatusPanel to "" 
88924>>>        Function_Return bOK
88925>>>    End_Function
88926>>>    
88926>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
88926>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
88926>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
88926>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
88926>>>    //
88926>>>    // The root of the problem is the following:
88926>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
88926>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
88926>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
88926>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
88926>>>    // an SQL error will be thrown;
88926>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
88926>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
88928>>>        Boolean bOK bIsAlias bIsSQL
88928>>>        Integer iCount iSize iDateSize
88928>>>        Handle hTable
88928>>>        String sLogicalName
88928>>>        Integer[] aTablesToCheck aDateFields
88930>>>
88930>>>        Get _AllTablesDateCorrections to aTablesToCheck
88931>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
88932>>>        Set pbVisible    of ghoProgressBarOverall to True
88933>>>        Set piPosition   of ghoProgressBarOverall to 0
88934>>>        Set piMaximum    of ghoProgressBarOverall to iSize
88935>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
88936>>>
88936>>>        Move True to bOK
88937>>>        Decrement iSize
88938>>>        for iCount from 0 to iSize
88944>>>>
88944>>>            Move aTablesToCheck[iCount] to hTable
88945>>>            Set piPosition of ghoProgressBarOverall to iCount
88946>>>            Get UtilTableIsAlias hTable to bIsAlias
88947>>>            Get _UtilTableIsSql   hTable to bIsSQL
88948>>>
88948>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
88951>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
88952>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
88953>>>
88953>>>            If (bIsAlias = False and bIsSQL = False) Begin
88955>>>                Get UtilCheckForDateFields hTable to aDateFields
88956>>>                Move (SizeOfArray(aDateFields)) to iDateSize
88957>>>                If (iDateSize > 0) Begin
88959>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
88960>>>                    Close hTable
88961>>>                End
88961>>>>
88961>>>            End
88961>>>>
88961>>>        Loop
88962>>>>
88962>>>
88962>>>        Close DF_ALL
88963>>>        Function_Return bOK
88964>>>    End_Function
88965>>>
88965>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
88965>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
88967>>>        Integer[] aDateFields aDateFieldsEmpty
88969>>>        Integer iSize iCount iType
88969>>>        Boolean bOpen bOK
88969>>>        
88969>>>        Get _UtilTableExists hTable to bOK
88970>>>        If (bOK = False) Begin
88972>>>            Set Private.phCurrentTable to hTable
88973>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
88974>>>>
88974>>>            Function_Return aDateFieldsEmpty
88975>>>        End
88975>>>>
88975>>>        Set Private.phCurrentTable to hTable
88976>>>        Set Private.piCurrentField to 0
88977>>>
88977>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88977>>>        Open hTable
88979>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
88982>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
88982>>>        If (bOpen = False) Begin
88984>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
88984>>>            Function_Return aDateFieldsEmpty
88985>>>        End
88985>>>>
88985>>>
88985>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
88988>>>        For iCount from 1 to iSize
88994>>>>
88994>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
88997>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
88999>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
89000>>>            End
89000>>>>
89000>>>        Loop
89001>>>>
89001>>>
89001>>>        Function_Return aDateFields
89002>>>    End_Function
89003>>>
89003>>>    // Loops through all records for the passed hTable, and checks that all Date values
89003>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
89003>>>    // and the record is saved
89003>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89003>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
89003>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89005>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
89005>>>        String sDriverID sDateMin
89005>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
89005>>>        Date dDate dDateMin
89005>>>        Integer[] iaChangeField
89006>>>
89006>>>        Get _UtilTableExists hTable to bOK
89007>>>        // I believe we should just skip files not found and not report an error.
89007>>>        // This is because a filelist may have entries but no files/tables on disk, but
89007>>>        // this may be adjusted by other calls to DUF in a later update package. 
89007>>>        // Especially considering that this call is probably done at the very
89007>>>        // beginning of a DUF update.
89007>>>        If (bOK = False) Begin
89009>>>//            Set Private.phCurrentTable to hTable
89009>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89009>>>//            Function_Return False
89009>>>            Function_Return True
89010>>>        End
89010>>>>
89010>>>
89010>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
89010>>>        // date format to "USA" = "MM/DD/YYYY"
89010>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
89013>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
89016>>>
89016>>>//        Send SetAllIndexesToBatch hTable True
89016>>>        Open hTable
89018>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89021>>>        If (bOpened = False) Begin
89023>>>            Function_Return False
89024>>>        End
89024>>>>
89024>>>        
89024>>>        Set Private.phCurrentTable to hTable
89025>>>        Move 0 to iRecord
89026>>>        Move (SizeOfArray(aDateFields)) to iSize
89027>>>        Decrement iSize
89028>>>
89028>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89031>>>        Get DriverIndex sDriverID to iDriverIndex
89032>>>        If (iDriverIndex <> 0) Begin
89034>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
89037>>>            If (sDateMin = "") Begin
89039>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
89040>>>            End
89040>>>>
89040>>>            Else Begin
89041>>>                If (IsDate(sDateMin)) Begin
89043>>>                    Move sDateMin to dDateMin
89044>>>                End
89044>>>>
89044>>>                Else Begin
89045>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
89046>>>                End
89046>>>>
89046>>>            End
89046>>>>
89046>>>        End
89046>>>>
89046>>>        Else Begin
89047>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
89048>>>        End
89048>>>>
89048>>>
89048>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
89051>>>        Set piPosition   of ghoProgressBar to 0
89052>>>        Set piAdvanceBy  of ghoProgressBar to 100
89053>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
89054>>>        Move False to Err
89055>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89056>>>
89056>>>        Clear hTable
89057>>>        Repeat
89057>>>>
89057>>>            Vfind hTable 0 GT
89059>>>            Move Found to bFound
89060>>>            If (bFound = True) Begin
89062>>>                Move False to bSaveChanges
89063>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
89064>>>                Move (SizeOfArray(aDateFields)) to iSize
89065>>>                Decrement iSize
89066>>>                For iCount from 0 to iSize
89072>>>>
89072>>>                    Move aDateFields[iCount] to iField
89073>>>                    Get_Field_Value hTable iField to dDate
89076>>>                    If (bFixZeroDates = True) Begin
89078>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
89079>>>                    End
89079>>>>
89079>>>                    Else Begin
89080>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
89081>>>                    End
89081>>>>
89081>>>                    If (bChange = True) Begin
89083>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
89084>>>                    End
89084>>>>
89084>>>                Loop
89085>>>>
89085>>>
89085>>>                // Only change Date fields that needs to be changed.
89085>>>                If (SizeOfArray(iaChangeField)) Begin
89087>>>                    Reread hTable
89091>>>                        Move (SizeOfArray(iaChangeField)) to iSize
89092>>>                        Decrement iSize
89093>>>                        For iCount from 0 to iSize
89099>>>>
89099>>>                            Move iaChangeField[iCount] to iField
89100>>>                            Set Private.piCurrentField to iField
89101>>>                            Set_Field_Value hTable iField to dDateMin
89104>>>                        Loop
89105>>>>
89105>>>                        Move False to Err
89106>>>                        SaveRecord hTable
89107>>>                    Unlock
89108>>>>
89108>>>                End
89108>>>>
89108>>>
89108>>>                Increment iRecord
89109>>>                // Increment the StatusPanel counter and check the
89109>>>                // cancel status every 100 records rather than every
89109>>>                // record, it's way faster.
89109>>>                If (Mod(iRecord, 100) = 0) Begin
89111>>>                    Send DoAdvance of ghoProgressBar
89112>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
89113>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89114>>>                End
89114>>>>
89114>>>            End
89114>>>>
89114>>>        Until (bFound = False)
89116>>>
89116>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
89119>>>        If (bResetIndexesToOnLine = True) Begin
89121>>>            Send SetAllIndexesToBatch hTable False
89122>>>        End
89122>>>>
89122>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89123>>>
89123>>>        Function_Return (Err = False)
89124>>>    End_Function
89125>>>
89125>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89125>>>    // Note that it first removes any driver prefixes in the rootname.
89125>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
89127>>>        Boolean bIsSame
89127>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89127>>>
89127>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
89128>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
89129>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
89130>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
89131>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
89132>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
89133>>>
89133>>>        If (bCompareFilelistUppercase = True) Begin
89135>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
89136>>>        End
89136>>>>
89136>>>        Else Begin
89137>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
89138>>>        End
89138>>>>
89138>>>        If (bIsSame = False) Begin
89140>>>            Function_Return False
89141>>>        End
89141>>>>
89141>>>
89141>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
89142>>>        If (bIsSame = False) Begin
89144>>>            Function_Return False
89145>>>        End
89145>>>>
89145>>>
89145>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
89146>>>        If (bIsSame = False) Begin
89148>>>            Function_Return False
89149>>>        End
89149>>>>
89149>>>
89149>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
89150>>>        If (bIsSame = False) Begin
89152>>>            Function_Return False
89153>>>        End
89153>>>>
89153>>>
89153>>>        Function_Return bIsSame
89154>>>    End_Function
89155>>>
89155>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89157>>>        Handle hTableFrom hTableTo
89157>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89157>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
89157>>>        String sRootName sDriverIDFrom sDriverIDTo
89157>>>        tAPIColumnCompare[]   aAPIColumnCompare
89157>>>        tAPIColumnCompare[]   aAPIColumnCompare
89158>>>        tAPIIndexCompare[]    aAPIIndexCompare
89158>>>        tAPIIndexCompare[]    aAPIIndexCompare
89159>>>        tAPIRelationCompare[] aAPIRelationCompare
89159>>>        tAPIRelationCompare[] aAPIRelationCompare
89160>>>
89160>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
89161>>>        If (bIsSame = True) Begin
89163>>>            Function_Return True
89164>>>        End
89164>>>>
89164>>>
89164>>>        Move False to bFilelistError
89165>>>        Move True to bIsSame
89166>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
89167>>>        Get pbCompareIndexAscending to bCompareIndexAscending
89168>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
89169>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89170>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89171>>>
89171>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
89172>>>        Get _TableNameOnly sRootName             to sRootName
89173>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
89174>>>
89174>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
89174>>>        // bCodeGenerateMode = True = Code Generation mode.
89174>>>        If (bCodeGenerateMode = True) Begin
89176>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89176>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89178>>>                Function_Return False
89179>>>            End
89179>>>>
89179>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89180>>>            If (bIsSame = False) Begin
89182>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
89183>>>                Move True to bFilelistError
89184>>>                Function_Return False
89185>>>            End
89185>>>>
89185>>>        End
89185>>>>
89185>>>
89185>>>        If (bCodeGenerateMode = False) Begin
89187>>>            // Then we want to create this table
89187>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89189>>>                Function_Return False
89190>>>            End
89190>>>>
89190>>>
89190>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89191>>>            If (bIsSame = False) Begin
89193>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
89194>>>>
89194>>>                Move True to bFilelistError
89195>>>                Function_Return False
89196>>>            End
89196>>>>
89196>>>        End
89196>>>>
89196>>>
89196>>>        // Check columns:
89196>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89197>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
89198>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
89199>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89200>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
89201>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
89202>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
89203>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
89204>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
89205>>>        If (bIsSame = False) Begin
89207>>>            Function_Return False
89208>>>        End
89208>>>>
89208>>>
89208>>>        // ...then check indexes:
89208>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
89209>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
89210>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
89211>>>        If (bIsSame = False) Begin
89213>>>            Function_Return False
89214>>>        End
89214>>>>
89214>>>
89214>>>        // ...and finally relationships:
89214>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
89215>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
89216>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
89217>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
89218>>>
89218>>>        Function_Return (bIsSame = True)
89219>>>    End_Function
89220>>>
89220>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
89220>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89222>>>        Handle hTable
89222>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89222>>>        String sRootName sDriverIDFrom sDriverIDTo
89222>>>
89222>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
89224>>>            Move True to bFilelistError
89225>>>            Function_Return False
89226>>>        End
89226>>>>
89226>>>
89226>>>        Move APITableCompare.hTable to hTable
89227>>>        Move True  to bIsSame
89228>>>        Move False to bFilelistError
89229>>>
89229>>>        If (APITableCompare.bExistsFrom = True) Begin
89231>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
89232>>>        End
89232>>>>
89232>>>        Else Begin
89233>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
89234>>>        End
89234>>>>
89234>>>        Get _TableNameOnly sRootName                                   to sRootName
89235>>>
89235>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
89236>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
89237>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
89238>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
89239>>>
89239>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
89239>>>        // bCodeGenerateMode = True = Code Generation mode.
89239>>>        If (bCodeGenerateMode = True) Begin
89241>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89241>>>            If (APITableCompare.bExistsTo = False) Begin
89243>>>                Function_Return False
89244>>>            End
89244>>>>
89244>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
89245>>>            If (bIsSame = False) Begin
89247>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
89248>>>                Move True to bFilelistError
89249>>>                Function_Return False
89250>>>            End
89250>>>>
89250>>>        End
89250>>>>
89250>>>
89250>>>        If (bCodeGenerateMode = False) Begin
89252>>>            If (APITableCompare.bExistsTo = False) Begin
89254>>>                // Then we might want to create this table
89254>>>                Function_Return False
89255>>>            End
89255>>>>
89255>>>
89255>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
89256>>>            If (bIsSame = False) Begin
89258>>>                Function_Return False
89259>>>            End
89259>>>>
89259>>>
89259>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
89260>>>            If (bIsSame = False) Begin
89262>>>                Function_Return False
89263>>>            End
89263>>>>
89263>>>
89263>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
89264>>>            If (bIsSame = False) Begin
89266>>>                Function_Return False
89267>>>            End
89267>>>>
89267>>>
89267>>>            // Check table names et al.
89267>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
89268>>>            If (bIsSame = False) Begin
89270>>>                Function_Return False
89271>>>            End
89271>>>>
89271>>>        End
89271>>>>
89271>>>
89271>>>        // Check Columns:
89271>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
89272>>>        If (bIsSame = False) Begin
89274>>>            Function_Return False
89275>>>        End
89275>>>>
89275>>>
89275>>>        // ...then check Indexes:
89275>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
89276>>>        If (bIsSame = False) Begin
89278>>>            Function_Return False
89279>>>        End
89279>>>>
89279>>>
89279>>>        // ...and finally Relationships:
89279>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
89280>>>
89280>>>        Function_Return (bIsSame = True)
89281>>>    End_Function
89282>>>
89282>>>    // To fill a complete Table array structure (tAPITable[]) with data.
89282>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
89282>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
89282>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
89282>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
89284>>>        tAPITableNameInfo ApiTableNameInfo
89284>>>        tAPITableNameInfo ApiTableNameInfo
89284>>>        tAPITable[]     aApiTables aApiTablesEmpty
89284>>>        tAPITable[]     aApiTables aApiTablesEmpty
89286>>>        tAPIColumn[]    aApiColumns
89286>>>        tAPIColumn[]    aApiColumns
89287>>>        tAPIIndex[]     aApiIndexes
89287>>>        tAPIIndex[]     aApiIndexes
89288>>>        tAPIRelation[]  aApiRelations
89288>>>        tAPIRelation[]  aApiRelations
89289>>>        Handle hTable
89289>>>        Integer iCount
89289>>>        Boolean bUserCancel bOK
89289>>>        String sLogicalName sMessageText
89289>>>
89289>>>        Get AutoConnectionIDLogin to bOK
89290>>>        Move 0 to hTable
89291>>>        If (bFromTables = True) Begin
89293>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
89294>>>            If (bCompareUtil = True) Begin
89296>>>                Move (sMessageText * "(1 of 3)") to sMessageText
89297>>>            End
89297>>>>
89297>>>        End
89297>>>>
89297>>>        Else Begin
89298>>>            Move "Reading 'TO' Table Structure:" to sMessageText
89299>>>            If (bCompareUtil = True) Begin
89301>>>                Move (sMessageText * "(2 of 3)") to sMessageText
89302>>>            End
89302>>>>
89302>>>        End
89302>>>>
89302>>>        Set Message_Text of ghoStatusPanel to sMessageText
89303>>>
89303>>>        Get UtilFilelistNoOfTables to iCount
89304>>>        Set piMaximum of ghoProgressBar to iCount
89305>>>        Move 0 to iCount
89306>>>
89306>>>        Repeat
89306>>>>
89306>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89309>>>            If (hTable > 0 and hTable <> 50) Begin
89311>>>
89311>>>                Open hTable
89313>>>                // ToDo: Needs to be revised
89313>>>                // For some reason tables may be reported as "unopened", while in
89313>>>                // fact the open was successful (!)
89313>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89313>>>//                If (bIsOpen = False) Begin
89313>>>//                    Move True to aApiTablesEmpty[0].bError
89313>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
89313>>>//                    Function_Return aApiTablesEmpty
89313>>>//                End
89313>>>
89313>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89316>>>                Set piPosition of ghoProgressBar to iCount
89317>>>                Send DoAdvance of ghoProgressBarOverall
89318>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
89319>>>
89319>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
89320>>>//                Close hTable DF_PERMANENT
89320>>>                Increment iCount
89321>>>            End
89321>>>>
89321>>>
89321>>>            If (bStatusPanel = True) Begin
89323>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
89324>>>                If (bUserCancel = True) Begin
89326>>>                    Move True to aApiTablesEmpty[0].bCancel
89327>>>                    Function_Return aApiTablesEmpty
89328>>>                End
89328>>>>
89328>>>            End
89328>>>>
89328>>>
89328>>>        Until (hTable = 0)
89330>>>
89330>>>        Function_Return aApiTables
89331>>>    End_Function
89332>>>
89332>>>    // Returns a 'single' table APITable struct.
89332>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
89334>>>        tAPITableNameInfo ApiTableNameInfo
89334>>>        tAPITableNameInfo ApiTableNameInfo
89334>>>        tAPITable         ApiTable ApiTableEmpty
89334>>>        tAPITable         ApiTable ApiTableEmpty
89334>>>        tAPIColumn[]     aApiColumns
89334>>>        tAPIColumn[]     aApiColumns
89335>>>        tAPIIndex[]      aApiIndexes
89335>>>        tAPIIndex[]      aApiIndexes
89336>>>        tAPIRelation[]   aApiRelations
89336>>>        tAPIRelation[]   aApiRelations
89337>>>        Boolean bIsOpen
89337>>>
89337>>>        Open hTable
89339>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89342>>>        If (bIsOpen = False) Begin
89344>>>            Move True to ApiTableEmpty.bError
89345>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89346>>>            Function_Return ApiTableEmpty
89347>>>        End
89347>>>>
89347>>>
89347>>>        // Fill Table Name Info
89347>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
89348>>>
89348>>>        // Fill columns
89348>>>        Get UtilColumnsStructFill hTable to aApiColumns
89349>>>        If (SizeOfArray(aApiColumns)) Begin
89351>>>            If (aApiColumns[0].bCancel = True) Begin
89353>>>                Move True to ApiTableEmpty.bError
89354>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89355>>>                Function_Return ApiTableEmpty
89356>>>            End
89356>>>>
89356>>>        End
89356>>>>
89356>>>
89356>>>        // Fill indexes
89356>>>        Get UtilIndexesStructFill hTable to aApiIndexes
89357>>>        If (SizeOfArray(aApiIndexes)) Begin
89359>>>            If (aApiIndexes[0].bCancel = True) Begin
89361>>>                Move True to ApiTableEmpty.bError
89362>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89363>>>                Function_Return ApiTableEmpty
89364>>>            End
89364>>>>
89364>>>        End
89364>>>>
89364>>>
89364>>>        // Fill relationships
89364>>>        Get UtilRelationsStructFill hTable to aApiRelations
89365>>>        If (SizeOfArray(aApiRelations)) Begin
89367>>>            If (aApiRelations[0].bCancel = True) Begin
89369>>>                Move True to ApiTableEmpty.bError
89370>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89371>>>                Function_Return ApiTableEmpty
89372>>>            End
89372>>>>
89372>>>        End
89372>>>>
89372>>>
89372>>>        Move hTable             to ApiTable.hTable
89373>>>        Move bFromTables        to ApiTable.bFromTable
89374>>>        Move (not(bFromTables)) to ApiTable.bToTable
89375>>>
89375>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
89376>>>        Move aApiColumns        to ApiTable.aApiColumns
89377>>>        Move aApiIndexes        to ApiTable.aApiIndexes
89378>>>        Move aApiRelations      to ApiTable.aApiRelations
89379>>>
89379>>>        Function_Return ApiTable
89380>>>    End_Function
89381>>>
89381>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
89383>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89383>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89383>>>        Boolean bIsOpen
89383>>>
89383>>>        Open hTable
89385>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89388>>>        If (bIsOpen = False) Begin
89390>>>            Move True   to APITableNameInfoEmpty.bError
89391>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
89392>>>            Function_Return APITableNameInfoEmpty
89393>>>        End
89393>>>>
89393>>>
89393>>>        Move hTable                                  to APITableNameInfo.iTableNumber
89394>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
89397>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
89400>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
89403>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
89406>>>
89406>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
89407>>>        Get _UtilTableIsSql                    hTable to APITableNameInfo.bIsSQL
89408>>>
89408>>>        Function_Return APITableNameInfo
89409>>>    End_Function
89410>>>
89410>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
89412>>>        Integer iSize iCount iItem
89412>>>        tAPITableNameInfo ApiTableNameInfo
89412>>>        tAPITableNameInfo ApiTableNameInfo
89412>>>
89412>>>        Move -1 to iItem
89413>>>        Move (SizeOfArray(aTableStructure)) to iSize
89414>>>        Decrement iSize
89415>>>        for iCount from 0 to iSize
89421>>>>
89421>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89422>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
89424>>>                Move iCount to iItem
89425>>>                Move iSize  to iCount // We're done.
89426>>>            End
89426>>>>
89426>>>        Loop
89427>>>>
89427>>>
89427>>>        Function_Return iItem
89428>>>    End_Function
89429>>>
89429>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
89431>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
89434>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
89437>>>
89437>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
89440>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
89443>>>
89443>>>        Function_Return (EQ)
89444>>>    End_Function
89445>>>
89445>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
89447>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
89447>>>        Handle hTable
89447>>>        tAPITable[] aAPITableFromAndTo
89447>>>        tAPITable[] aAPITableFromAndTo
89448>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89448>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89448>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89448>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89448>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89448>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89449>>>        tAPIColumnCompare[]   aAPIColumnCompare
89449>>>        tAPIColumnCompare[]   aAPIColumnCompare
89450>>>        tAPIIndexCompare[]    aAPIIndexCompare
89450>>>        tAPIIndexCompare[]    aAPIIndexCompare
89451>>>        tAPIRelationCompare[] aAPIRelationCompare
89451>>>        tAPIRelationCompare[] aAPIRelationCompare
89452>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89452>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89452>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89452>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89455>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89455>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89458>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89458>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89461>>>
89461>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
89462>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
89463>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
89465>>>            Function_Return aAPITableCompare
89466>>>        End
89466>>>>
89466>>>
89466>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
89467>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
89468>>>
89468>>>        Move 0 to iItem
89469>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
89470>>>        Decrement iSize
89471>>>        for iCount from 0 to iSize
89477>>>>
89477>>>
89477>>>            Move iCount to iItemFrom
89478>>>            Move iCount to iItemTo
89479>>>            Move APITableEmpty to APITableFrom
89480>>>            Move APITableEmpty to APITableTo
89481>>>
89481>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
89483>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89484>>>            End
89484>>>>
89484>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
89486>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
89487>>>            End
89487>>>>
89487>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
89489>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89490>>>                Move (iCount + 1) to iItemTo
89491>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
89492>>>            End
89492>>>>
89492>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
89494>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
89495>>>                If (iItemTo <> -1) Begin
89497>>>                    Move aAPITableTo[iItemTo] to APITableTo
89498>>>                End
89498>>>>
89498>>>                Else Begin
89499>>>                    Move APITableEmpty to APITableTo
89500>>>                End
89500>>>>
89500>>>            End
89500>>>>
89500>>>
89500>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
89501>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
89502>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
89503>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
89504>>>
89504>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
89505>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
89506>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
89507>>>            Move APITableTo.aApiRelations   to aApiRelationTo
89508>>>
89508>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
89509>>>
89509>>>            If (hTable > 0) Begin
89511>>>
89511>>>                // Table info:
89511>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
89512>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
89513>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
89514>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
89515>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
89516>>>
89516>>>                // Column info:
89516>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
89517>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
89518>>>
89518>>>                // Index info:
89518>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
89519>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
89520>>>
89520>>>                // Relation info:
89520>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
89521>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
89522>>>
89522>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
89523>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
89524>>>                Move False                                                              to aAPITableCompare[iItem].bError
89525>>>                If (iItemTo > iItemFrom) Begin
89527>>>                    Increment iCount
89528>>>                End
89528>>>>
89528>>>                Increment iItem
89529>>>            End
89529>>>>
89529>>>
89529>>>        Loop
89530>>>>
89530>>>
89530>>>        Function_Return aAPITableCompare
89531>>>    End_Function
89532>>>
89532>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
89534>>>        Integer iSize iCount iItem
89534>>>        tAPITableNameInfo ApiTableNameInfo
89534>>>        tAPITableNameInfo ApiTableNameInfo
89534>>>
89534>>>        Move -1 to iItem
89535>>>        Move (SizeOfArray(aTableStructure)) to iSize
89536>>>        Decrement iSize
89537>>>        For iCount from 0 to iSize
89543>>>>
89543>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89544>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
89546>>>                Move iCount to iItem
89547>>>                Move iSize  to iCount // We're done.
89548>>>            End
89548>>>>
89548>>>        Loop
89549>>>>
89549>>>
89549>>>        Function_Return iItem
89550>>>    End_Function
89551>>>
89551>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
89553>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89553>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89553>>>
89553>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
89555>>>            Function_Return APITableNameInfoCompare
89556>>>        End
89556>>>>
89556>>>
89556>>>        // FROM database info:
89556>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
89558>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
89559>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
89560>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
89561>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
89562>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
89563>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
89564>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
89565>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
89566>>>        End
89566>>>>
89566>>>
89566>>>        // TO database info:
89566>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
89568>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
89569>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
89570>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
89571>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
89572>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
89573>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
89574>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
89575>>>            Move True                               to APITableNameInfoCompare.bExistsTo
89576>>>        End
89576>>>>
89576>>>
89576>>>        Function_Return APITableNameInfoCompare
89577>>>    End_Function
89578>>>
89578>>>    // Note:
89578>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
89578>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
89578>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
89578>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
89578>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
89578>>>    Function UtilTableHandleToString Handle hTable Returns String
89580>>>        String sTableName
89580>>>        Boolean bOpen bExists bOK
89580>>>
89580>>>        Get _UtilTableNumberIsInUse hTable to bExists
89581>>>        If (bExists = False) Begin
89583>>>            Function_Return ""
89584>>>        End
89584>>>>
89584>>>
89584>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89585>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89588>>>        If (bOpen = False) Begin
89590>>>            Get AutoConnectionIDLogin to bOK
89591>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89592>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
89593>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89594>>>            Open hTable
89596>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89597>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
89598>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89599>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
89602>>>        End
89602>>>>
89602>>>        If (bOpen = True) Begin
89604>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89605>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
89608>>>            // If blank it is an embedded table:
89608>>>            If (sTableName = "") Begin
89610>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89613>>>                Move 0 to LastErr
89614>>>                Move False to Err
89615>>>            End
89615>>>>
89615>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89616>>>        End
89616>>>>
89616>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89617>>>        Move 0 to LastErr
89618>>>
89618>>>        Function_Return sTableName
89619>>>    End_Function
89620>>>
89620>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
89620>>>    // Returns 0 if unsuccessful.
89620>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
89620>>>    Function UtilTableNameToHandle String sTableName Returns Integer
89622>>>        String sValue sPrefixTableName sDriverID
89622>>>        Handle hTable hRetval
89622>>>
89622>>>        Get psDriverID to sDriverID
89623>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
89625>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
89626>>>        End
89626>>>>
89626>>>        Move 0 to hTable
89627>>>        Move 0 to hRetval
89628>>>        Repeat
89628>>>>
89628>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89631>>>            If (hTable <> 0) Begin
89633>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
89636>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
89638>>>                    Move hTable to hRetval
89639>>>                    Move 0 to hTable
89640>>>                End
89640>>>>
89640>>>            End
89640>>>>
89640>>>        Until (hTable = 0)
89642>>>
89642>>>        Function_Return hRetval
89643>>>    End_Function
89644>>>
89644>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
89644>>>    // _after_ all tables have successfully been converted to SQL (.int files)
89644>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
89646>>>        Boolean bOK bExists
89646>>>        String sDataPath sBackupFolder
89646>>>
89646>>>        Close DF_ALL DF_PERMANENT
89647>>>        Send DoAdvance of ghoProgressBar
89648>>>
89648>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
89649>>>        Move CS_DUFBackupDataFolder to sBackupFolder
89650>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
89651>>>        Get vFolderFormat sDataPath to sDataPath
89652>>>
89652>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
89653>>>        If (bExists = False) Begin
89655>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
89656>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
89657>>>            If (bExists = False) Begin
89659>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
89660>>>>
89660>>>                Function_Return False
89661>>>            End
89661>>>>
89661>>>        End
89661>>>>
89661>>>
89661>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
89662>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
89663>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
89664>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
89665>>>        // We need to wait for Windows before we can copy files back
89665>>>        Sleep 2  
89666>>>        
89666>>>        //...except for these files that needs to be copied back to the Data folder:
89666>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
89667>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
89668>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
89669>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
89670>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
89671>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
89672>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
89672>>>        
89672>>>
89672>>>        Set Message_Text of ghoStatusPanel to ""
89673>>>        Function_Return True
89674>>>    End_Function
89675>>>    
89675>>>    Function UtilTableRepairAndReindexALL Returns Boolean
89677>>>        Boolean bOK bRetval
89677>>>        Handle hTable
89677>>>        Integer iSize iCount
89677>>>        
89677>>>        Move True to bOK
89678>>>        Get UtilFilelistNoOfTables to iSize
89679>>>        Set pbVisible    of ghoProgressBarOverall to True
89680>>>        Set piPosition   of ghoProgressBarOverall to 0
89681>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89682>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89683>>>
89683>>>        Repeat
89683>>>>
89683>>>            Set piPosition of ghoProgressBarOverall to iCount
89684>>>            Increment iCount
89685>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89688>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
89690>>>                Get UtilTableRepairAndReindex hTable to bRetval
89691>>>                If (bRetval = False) Begin
89693>>>                    Move False to bOK
89694>>>                End
89694>>>>
89694>>>            End
89694>>>>
89694>>>        Until (hTable = 0)
89696>>>                
89696>>>        Function_Return bOK
89697>>>    End_Function           
89698>>>    
89698>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
89698>>>    // After the header has been repaired - also makes a re-index.  
89698>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
89698>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
89700>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
89700>>>        Integer iRetval
89700>>>        String sRootName sFileName sDataPath
89700>>>        
89700>>>        Move False to Err
89701>>>        Move 0 to LastErr 
89702>>>        Move True to bOK
89703>>>        
89703>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
89704>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
89706>>>            Function_Return True
89707>>>        End
89707>>>>
89707>>>        Get UtilTableIsAlias hTable to bIsAlias 
89708>>>        If (bIsAlias = True) Begin
89710>>>            Function_Return True
89711>>>        End
89711>>>>
89711>>>        
89711>>>        // Check for bad file and remove if exists
89711>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89714>>>        Set private.phCurrentTable to hTable  
89715>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
89716>>>        
89716>>>        // This is important! Else it can happen that the table can't be opened,
89716>>>        // with a "4077 - File in use" error.
89716>>>        Close DF_ALL DF_PERMANENT    
89717>>>        Open hTable
89719>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89722>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89723>>>        If (bIsOpen = False) Begin
89725>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
89726>>>>
89726>>>            Function_Return False        
89727>>>        End
89727>>>>
89727>>>
89727>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
89728>>>        If (bBadExists = True) Begin
89730>>>            Get_File_Path (sRootName + ".BAD") to sFileName
89731>>>            Get vDeleteFile sFileName to iRetval
89732>>>        End
89732>>>>
89732>>>        
89732>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
89733>>>        
89733>>>        Move False to Err
89734>>>        // **** Repair and reindex the table. ****
89734>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
89735>>>
89735>>>        // Check for bad file: if it exists, something went wrong
89735>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
89736>>>        Get vFolderFormat sDataPath to sDataPath
89737>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
89738>>>        If (bBadExists = True) Begin
89740>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
89741>>>>
89741>>>            Move False to bOK
89742>>>        End
89742>>>>
89742>>>        Close hTable
89743>>>
89743>>>        Function_Return bOK
89744>>>    End_Function
89745>>>
89745>>>    // Repair and reindex the named DataFlex data-table.
89745>>>    // No checks are done if the passed table name is an embedded or SQL,
89745>>>    // so use with care (make sure you only pass embedded table names).
89745>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
89747>>>        String sMode
89747>>>        Integer iVoid
89747>>>
89747>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
89748>>>        Move "0" to sMode   // 0=Reindex after repair!    
89749>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
89750>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
89755>>>        Set Message_Text of ghoStatusPanel to ""
89756>>>        Function_Return (iVoid = 0)
89757>>>    End_Function
89758>>>
89758>>>    // Returns _two_ arrays.
89758>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
89758>>>    // Also returns all files that are Alias files in a second array.
89758>>>    // IMPORTANT: All master & alias files _must_ have been included into
89758>>>    //            the DoSetAllMasterAndAlias message.
89758>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
89760>>>        Integer[] iaFileIsAlias
89761>>>        Integer hTable iFileAlias iSize
89761>>>        Boolean bOpen
89761>>>
89761>>>        Move 0 to hTable
89762>>>        Repeat
89762>>>>
89762>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89765>>>            If (hTable <> 0) Begin
89767>>>                Open hTable
89769>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
89772>>>                If (bOpen = True) Begin
89774>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
89777>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
89779>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
89780>>>                        Move hTable to iaFileIsMaster[iSize]
89781>>>                    End
89781>>>>
89781>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
89784>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
89785>>>                        Move hTable to iaFileIsAlias[iSize]
89786>>>                    End
89786>>>>
89786>>>                End
89786>>>>
89786>>>            End
89786>>>>
89786>>>        Until (hTable = 0)
89788>>>
89788>>>        Function_Return iaFileIsAlias
89789>>>    End_Function  
89790>>>    
89790>>>    // Is a repair of the data-header necessary? (Embedded tables only)
89790>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
89792>>>        String sMode
89792>>>        Integer iRepairNeeded bIsOpen
89792>>>
89792>>>        Move "0" to sMode
89793>>>        Set private.phCurrentTable to hTable 
89794>>>        Close hTable
89795>>>        Open hTable
89797>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89800>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
89805>>>
89805>>>        Function_Return iRepairNeeded
89806>>>    End_Function
89807>>>
89807>>>    // Helper function
89807>>>    // Takes two params:
89807>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
89807>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
89807>>>    // Returns:
89807>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
89807>>>    //  DF_FILE_IS_MASTER if master
89807>>>    //  DF_FILE_IS_ALIAS if alias
89807>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
89809>>>        Integer i iSize
89809>>>
89809>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
89810>>>        Decrement iSize
89811>>>        for i from 0 to iSize
89817>>>>
89817>>>            If (hTable = iaFileIsMaster[i]) Begin
89819>>>                Function_Return DF_FILE_IS_MASTER
89820>>>            End
89820>>>>
89820>>>        Loop
89821>>>>
89821>>>
89821>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
89822>>>        Decrement iSize
89823>>>        for i from 0 to iSize
89829>>>>
89829>>>            If (hTable = iaFileIsAlias[i]) Begin
89831>>>                Function_Return DF_FILE_IS_ALIAS
89832>>>            End
89832>>>>
89832>>>        Loop
89833>>>>
89833>>>
89833>>>        Function_Return DF_FILE_ALIAS_DEFAULT
89834>>>    End_Function
89835>>>
89835>>>    // Determine the available indexes of a table.
89835>>>    //
89835>>>    // Arguments:
89835>>>    //   Handle hTable - The number of the table
89835>>>    //
89835>>>    // Returns:
89835>>>    //   String - A string to be used with the sort command
89835>>>    //   to re-index all indexes of a table.
89835>>>    Function UtilTableIndexString Handle hTable Returns String
89837>>>        String  sSortString
89837>>>        Integer iLastIndex iNumSegments iCount
89837>>>
89837>>>        Move "" to sSortString
89838>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
89841>>>
89841>>>        for iCount from 1 to iLastIndex
89847>>>>
89847>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
89850>>>            If iNumSegments Begin
89852>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
89855>>>                Move (Append(sSortString, iCount)) to sSortString
89856>>>            End
89856>>>>
89856>>>        Loop
89857>>>>
89857>>>
89857>>>        Function_Return sSortString
89858>>>    End_Function
89859>>>
89859>>>    
89859>>>    // * Dummy function for the Studio's Code Explorer *
89859>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
89861>>>        Function_Return False
89862>>>    End_Function
89863>>>
89863>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
89863>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
89865>>>        Boolean bIsSame
89865>>>        Integer iCount iColumns iColumn
89865>>>
89865>>>        Move True to bIsSame
89866>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
89867>>>        Set piMaximum of ghoProgressBar  to iColumns
89868>>>        Decrement iColumns
89869>>>
89869>>>        for iCount from 0 to iColumns
89875>>>>
89875>>>            Set piPosition of ghoProgressBar to iCount
89876>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
89877>>>            If (bIsSame = False) Begin
89879>>>                Function_Return False
89880>>>            End
89880>>>>
89880>>>        Loop
89881>>>>
89881>>>
89881>>>        Function_Return (bIsSame = True)
89882>>>    End_Function
89883>>>
89883>>>    // Compares a single column (For 'FROM' & 'TO' tables)
89883>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
89885>>>        Integer iFromType iToType iDbType
89885>>>        tColumnType ColumnType
89885>>>        tColumnType ColumnType
89885>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
89885>>>
89885>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
89887>>>            Function_Return False
89888>>>        End
89888>>>>
89888>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
89890>>>            Function_Return False
89891>>>        End
89891>>>>
89891>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
89893>>>            Function_Return False
89894>>>        End                                                                
89894>>>>
89894>>>
89894>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
89896>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
89898>>>                Function_Return False
89899>>>            End
89899>>>>
89899>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
89901>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
89903>>>                    End
89903>>>>
89903>>>                Else Begin
89904>>>                    Function_Return False
89905>>>                End
89905>>>>
89905>>>            End
89905>>>>
89905>>>        End
89905>>>>
89905>>>
89905>>>        Get piDbType                       to iDbType
89906>>>        Move APIColumnCompare.iTypeFrom    to iFromType
89907>>>        Move APIColumnCompare.iTypeTo      to iToType
89908>>>
89908>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
89908>>>        // data types between Embedded and SQL.
89908>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
89910>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
89911>>>        End
89911>>>>
89911>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
89913>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
89914>>>        End
89914>>>>
89914>>>
89914>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
89915>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
89916>>>
89916>>>        // Make Date and DateTime comparison?
89916>>>        If (bCompareDate_DataTime = True) Begin
89918>>>            If (iFromType <> iToType) Begin
89920>>>                Function_Return False
89921>>>            End
89921>>>>
89921>>>        End
89921>>>>
89921>>>
89921>>>        // This is when not checking for Date/DateTime differences but all other other field types...
89921>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
89923>>>            If (iFromType <> iToType) Begin
89925>>>                Function_Return False
89926>>>            End
89926>>>>
89926>>>        End
89926>>>>
89926>>>
89926>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
89926>>>        If (bIsDateTypeFrom = False) Begin
89928>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
89930>>>                Function_Return False
89931>>>            End
89931>>>>
89931>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
89933>>>                Function_Return False
89934>>>            End
89934>>>>
89934>>>        End
89934>>>>
89934>>>
89934>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
89936>>>            Function_Return False
89937>>>        End
89937>>>>
89937>>>
89937>>>        Function_Return True
89938>>>    End_Function
89939>>>
89939>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
89941>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
89941>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
89941>>>        tAPIColumn[] APIColumns APIColumnsEmpty
89941>>>        tAPIColumn[] APIColumns APIColumnsEmpty
89943>>>        String sDriverID sRootName sLogicalName
89943>>>
89943>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89944>>>        Get piDbType to iDbType
89945>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89948>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89951>>>
89951>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89954>>>        If (bIsOpen = False) Begin
89956>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89957>>>            Open hTable
89959>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89960>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89963>>>            If (bIsOpen = False) Begin
89965>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89966>>>                Move True to APIColumnsEmpty[0].bError
89967>>>                Function_Return APIColumnsEmpty
89968>>>            End
89968>>>>
89968>>>        End
89968>>>>
89968>>>
89968>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89971>>>        Get IsSQLDriver    sDriverID to bSqlDriver
89972>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
89973>>>
89973>>>        Get _UtilTableIsSqlByRootName sRootName to bIsSqlTable
89974>>>        If (bIsSqlTable = True) Begin
89976>>>            Get _UtilTableExists hTable to bExists
89977>>>            If (bExists = False) Begin
89979>>>                Move True to APIColumnsEmpty[0].bError
89980>>>                Function_Return APIColumnsEmpty
89981>>>            End
89981>>>>
89981>>>        End
89981>>>>
89981>>>
89981>>>        Move 0 to iCount
89982>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
89985>>>        Set piMaximum of ghoProgressBar to iNumColumns
89986>>>
89986>>>        for iColumn from 1 to iNumColumns
89992>>>>
89992>>>            Move 0 to iOptions
89993>>>            Move False to bIdentityKey
89994>>>            Move False to Err
89995>>>            Move 0     to LastErr
89996>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
89997>>>            Set piPosition of ghoProgressBar to iColumn
89998>>>            If (bDawSqlDriver = True) Begin
90000>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90001>>>                If (bIsSqlTable = True) Begin
90003>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
90006>>>                    Move iType                                                to APIColumns[iCount].iType
90007>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
90010>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
90013>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
90016>>>                End
90016>>>>
90016>>>                Else Begin
90017>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
90020>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90021>>>                End
90021>>>>
90021>>>
90021>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90021>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
90024>>>                Move (iCheckFieldNumber >= 0) to bExists
90025>>>                If (bExists = False) Begin
90027>>>                    Move 0 to APIColumns[iCount].iType
90028>>>                End
90028>>>>
90028>>>                If (bExists = True) Begin
90030>>>                        Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90033>>>                End
90033>>>>
90033>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90034>>>                If (bIdentityKey = True) Begin
90036>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
90037>>>                End
90037>>>>
90037>>>            End
90037>>>>
90037>>>            Else Begin
90038>>>                Move False to Err
90039>>>                Move 0     to LastErr
90040>>>                If (bIsSqlTable = True) Begin
90042>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
90045>>>                End
90045>>>>
90045>>>                Else Begin
90046>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
90049>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90050>>>                End
90050>>>>
90050>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90050>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
90051>>>                If (bExists = False) Begin
90053>>>                    Move 0 to APIColumns[iCount].iType
90054>>>                End
90054>>>>
90054>>>            End
90054>>>>
90054>>>
90054>>>            If (bExists = True) Begin
90056>>>                Move iColumn to APIColumns[iCount].iFieldNumber
90057>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
90060>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
90060>>>//                If (bIsSqlTable = True) Begin
90060>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
90060>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90060>>>//                End
90060>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
90063>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90066>>>
90066>>>                // If the length was zero we might have an Overlap(!) field.
90066>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
90066>>>                If (APIColumns[iCount].iLength = 0) Begin
90068>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
90071>>>                    If (iType = DF_OVERLAP) Begin
90073>>>                        Move 0 to APIColumns[iCount].iFieldNumber
90074>>>                        Move 0 to APIColumns[iCount].iLength
90075>>>                        Move 0 to APIColumns[iCount].iOptions
90076>>>                        Move 0 to APIColumns[iCount].iPrecision
90077>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
90078>>>                        Move "" to APIColumns[iCount].sFieldName
90079>>>                        Decrement iCount
90080>>>                    End
90080>>>>
90080>>>                End
90080>>>>
90080>>>            End
90080>>>>
90080>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90081>>>            If (bUserCancel = True) Begin
90083>>>                Move True to APIColumnsEmpty[0].bCancel
90084>>>                Function_Return APIColumnsEmpty
90085>>>            End
90085>>>>
90085>>>            Increment iCount
90086>>>        Loop
90087>>>>
90087>>>
90087>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90088>>>        Function_Return APIColumns
90089>>>    End_Function
90090>>>
90090>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90090>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90090>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90090>>>    // have "holes" in the series of index numbers.
90090>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
90092>>>        tAPIColumnCompare[] aAPIColumnCompare
90092>>>        tAPIColumnCompare[] aAPIColumnCompare
90093>>>        tAPIColumnCompare   APIColumnCompare
90093>>>        tAPIColumnCompare   APIColumnCompare
90093>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90093>>>
90093>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
90094>>>        Decrement iSizeFrom
90095>>>        for iCount from 0 to iSizeFrom
90101>>>>
90101>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
90102>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
90103>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
90104>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
90105>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
90106>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
90107>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
90108>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
90109>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
90110>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
90111>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
90112>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
90113>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
90114>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
90115>>>        Loop
90116>>>>
90116>>>
90116>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
90117>>>        Decrement iSizeTo
90118>>>        for iCount from 0 to iSizeTo
90124>>>>
90124>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
90125>>>            // Search if the field number already exists in the array; else add it.
90125>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
90126>>>            If (iItem = -1) Begin
90128>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
90129>>>            End
90129>>>>
90129>>>
90129>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
90130>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
90131>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
90132>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
90133>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
90134>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
90135>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
90136>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
90137>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
90138>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
90139>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
90140>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
90141>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
90142>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
90143>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
90144>>>        Loop
90145>>>>
90145>>>
90145>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
90146>>>
90146>>>        Function_Return aAPIColumnCompare
90147>>>    End_Function
90148>>>
90148>>>    // Checks if a field name exists in a table definition
90148>>>    // Returns True if it does
90148>>>    // Sample:
90148>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90148>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90150>>>        Integer iNumColumns iColumn
90150>>>        String sColumn
90150>>>        Boolean bExists bOK bOpen
90150>>>
90150>>>        Get AutoConnectionIDLogin to bOK
90151>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90152>>>        Open hTable
90154>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90155>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90158>>>        If (bOpen = False) Begin
90160>>>            Function_Return False
90161>>>        End
90161>>>>
90161>>>
90161>>>        Move False to bExists
90162>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90165>>>        for iColumn from 1 to iNumColumns
90171>>>>
90171>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90174>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90176>>>                Move iNumColumns to iColumn
90177>>>                Move True to bExists
90178>>>            End
90178>>>>
90178>>>        Loop
90179>>>>
90179>>>        Close hTable
90180>>>
90180>>>        Function_Return bExists
90181>>>    End_Function
90182>>>
90182>>>    // Returns the field/column number for the passed FieldName as an integer.
90182>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
90184>>>        Integer iNumColumns iColumn iRetval
90184>>>        String sColumn
90184>>>        Boolean bOK bOpen
90184>>>
90184>>>        Get AutoConnectionIDLogin to bOK
90185>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90186>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90187>>>        Open hTable
90189>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90190>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90193>>>        If (bOpen = False) Begin
90195>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90196>>>            Function_Return False
90197>>>        End
90197>>>>
90197>>>
90197>>>        Move 0 to iColumn
90198>>>        Move 0 to iRetval
90199>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90202>>>        for iColumn from 1 to iNumColumns
90208>>>>
90208>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90211>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90213>>>                Move iColumn to iRetval
90214>>>                Move iNumColumns to iColumn
90215>>>            End
90215>>>>
90215>>>        Loop
90216>>>>
90216>>>        Close hTable
90217>>>
90217>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90218>>>        Function_Return iRetval
90219>>>    End_Function
90220>>>
90220>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
90220>>>    // The reciprocal function is UtilColumnTypeToInteger.
90220>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
90222>>>        tColumnType RetvalType
90222>>>        tColumnType RetvalType
90222>>>
90222>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
90223>>>        Function_Return RetvalType.iSQLType
90224>>>    End_Function
90225>>>
90225>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
90225>>>    // The reciprocal function is UtilColumnTypeToString.
90225>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
90227>>>        tColumnType RetvalType
90227>>>        tColumnType RetvalType
90227>>>
90227>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90228>>>        Function_Return RetvalType.sSQLType
90229>>>    End_Function
90230>>>
90230>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
90232>>>        tColumnType RetvalType
90232>>>        tColumnType RetvalType
90232>>>
90232>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90233>>>        Function_Return RetvalType.sPrecision
90234>>>    End_Function
90235>>>
90235>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
90237>>>        tColumnType RetvalType
90237>>>        tColumnType RetvalType
90237>>>
90237>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90238>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
90238>>>        // if the column type length is _not_ fixed.
90238>>>        Function_Return (RetvalType.bCanEditSize = False)
90239>>>    End_Function
90240>>>
90240>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
90242>>>        tColumnType RetvalType
90242>>>        tColumnType RetvalType
90242>>>        String sValue
90242>>>        Integer iRetval iPos
90242>>>
90242>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90243>>>        Move RetvalType.sPrecision to sValue
90244>>>        Move (Pos(".", sValue)) to iPos
90245>>>        If (iPos <> 0) Begin
90247>>>            Move (Left(sValue, (iPos -1))) to iRetval
90248>>>        End
90248>>>>
90248>>>        Else Begin
90249>>>            Move sValue to iRetval
90250>>>        End
90250>>>>
90250>>>        Function_Return iRetval
90251>>>    End_Function
90252>>>
90252>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
90254>>>        tColumnType RetvalType
90254>>>        tColumnType RetvalType
90254>>>        String sValue
90254>>>        Integer iRetval iPos
90254>>>
90254>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90255>>>        Move RetvalType.sPrecision to sValue
90256>>>        Move (Pos(".", sValue)) to iPos
90257>>>        If (iPos = 0) Begin
90259>>>            Function_Return 0
90260>>>        End
90260>>>>
90260>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
90261>>>
90261>>>        Function_Return iRetval
90262>>>    End_Function
90263>>>
90263>>>    // * Dummy function for the Studio's Code Explorer *
90263>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
90265>>>        Function_Return False
90266>>>    End_Function
90267>>>
90267>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
90267>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90269>>>        Boolean bIsSame
90269>>>        Integer iCount iSize
90269>>>
90269>>>        Move True to bIsSame
90270>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
90271>>>        Decrement iSize
90272>>>        For iCount from 0 to iSize
90278>>>>
90278>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90279>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90280>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90281>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90282>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90283>>>            If (bIsSame = False) Begin
90285>>>                Function_Return False
90286>>>            End
90286>>>>
90286>>>        Loop
90287>>>>
90287>>>
90287>>>        Function_Return bIsSame
90288>>>    End_Function
90289>>>
90289>>>    // Compares a single index for a 'FROM' and a 'TO' table.
90289>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90291>>>        Boolean bIsSame
90291>>>        Integer iSegment
90291>>>
90291>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
90292>>>        If (bIsSame = False) Begin
90294>>>            Function_Return False
90295>>>        End
90295>>>>
90295>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
90296>>>        If (bIsSame = False) Begin
90298>>>            Function_Return False
90299>>>        End
90299>>>>
90299>>>
90299>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
90301>>>            // * We should probably not compare SQL index names?
90301>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
90301>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
90301>>>            //     Function_Return False
90301>>>            // End
90301>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
90302>>>            If (bIsSame = False) Begin
90304>>>                Function_Return False
90305>>>            End
90305>>>>
90305>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
90306>>>            If (bIsSame = False) Begin
90308>>>                Function_Return False
90309>>>            End
90309>>>>
90309>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
90310>>>            If (bIsSame = False) Begin
90312>>>                Function_Return False
90313>>>            End
90313>>>>
90313>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
90314>>>            If (bIsSame = False) Begin
90316>>>                Function_Return False
90317>>>            End
90317>>>>
90317>>>        End
90317>>>>
90317>>>
90317>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
90318>>>        Move (iSegment = -1) to bIsSame
90319>>>
90319>>>        Function_Return (bIsSame = True)
90320>>>    End_Function
90321>>>
90321>>>    // Compares each segment for the passed index.
90321>>>    // Returns -1 if same; else returns the index segment that differs.
90321>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90323>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
90323>>>        Boolean bIsSame
90323>>>
90323>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90324>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90325>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
90326>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
90327>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
90328>>>
90328>>>        Decrement iNumSegments
90329>>>        for iSegment from 0 to iNumSegments
90335>>>>
90335>>>            Move False to bIsSame
90336>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
90338>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90339>>>            End
90339>>>>
90339>>>            If (bIsSame = False) Begin
90341>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90342>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90343>>>                Function_Return iSegment
90344>>>            End
90344>>>>
90344>>>        Loop
90345>>>>
90345>>>
90345>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90346>>>        Function_Return -1 // This means bIsSame = True
90347>>>    End_Function
90348>>>
90348>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90350>>>        Boolean bIsSame
90350>>>
90350>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
90351>>>        If (bIsSame = False) Begin
90353>>>            Function_Return False
90354>>>        End
90354>>>>
90354>>>        If (bCompareIndexUppercase = True) Begin
90356>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
90357>>>            If (bIsSame = False) Begin
90359>>>                Function_Return False
90360>>>            End
90360>>>>
90360>>>        End
90360>>>>
90360>>>        If (bCompareIndexAscending = True) Begin
90362>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
90363>>>            If (bIsSame = False) Begin
90365>>>                Function_Return False
90366>>>            End
90366>>>>
90366>>>        End
90366>>>>
90366>>>
90366>>>        Function_Return True
90367>>>    End_Function
90368>>>
90368>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90370>>>        Boolean bIsSame bOK
90370>>>        Integer iSize iSizeTo iCount
90370>>>        tAPIIndexCompare[] aAPIIndexCompare
90370>>>        tAPIIndexCompare[] aAPIIndexCompare
90371>>>
90371>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
90372>>>        If (iSize = 0) Begin
90374>>>            Function_Return True
90375>>>        End
90375>>>>
90375>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
90376>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
90377>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
90378>>>
90378>>>        for iCount from 0 to (iSize - 1)
90384>>>>
90384>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90385>>>            If (bIsSame = False) Begin
90387>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
90388>>>            End
90388>>>>
90388>>>        Loop
90389>>>>
90389>>>
90389>>>        // We probably should delete other indexes if they exists.
90389>>>        for iCount from (iSize +1) to iSizeTo
90395>>>>
90395>>>            Get ApiIndexRemove hTable iCount to bOK
90396>>>        Loop
90397>>>>
90397>>>
90397>>>        Function_Return bOK
90398>>>    End_Function
90399>>>
90399>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
90401>>>        tAPIIndex[] APIIndexes
90401>>>        tAPIIndex[] APIIndexes
90402>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
90402>>>        String sDriverID
90402>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
90402>>>
90402>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90403>>>        Get psDriverID to sDriverID
90404>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90405>>>        Get _UtilTableIsSql hTable to bIsSQLTable
90406>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90409>>>        If (bIsOpen = False) Begin
90411>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90412>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90413>>>            Open hTable
90415>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90416>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90417>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90420>>>            If (bIsOpen = False) Begin
90422>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90423>>>                Move True to APIIndexes[0].bError
90424>>>                Function_Return APIIndexes
90425>>>            End
90425>>>>
90425>>>        End
90425>>>>
90425>>>
90425>>>        Move 0 to iCount
90426>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
90429>>>        for iIndex from 1 to iIndexes
90435>>>>
90435>>>            // This is a test that the index exists as there might be "holes" aka the index
90435>>>            // numbers doesn't not need to be consequitive:
90435>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90438>>>            If (iNumSegments > 0) Begin
90440>>>
90440>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
90441>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
90444>>>                If (bIsSQLTable = True) Begin
90446>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
90449>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
90452>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
90455>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
90458>>>                End
90458>>>>
90458>>>
90458>>>                Move 0 to iSegmentCount
90459>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90462>>>                For iSegment from 1 to iNumSegments
90468>>>>
90468>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
90471>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
90472>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
90475>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
90478>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
90481>>>                    Increment iSegmentCount
90482>>>                Loop
90483>>>>
90483>>>                Increment iCount
90484>>>            End
90484>>>>
90484>>>        Loop
90485>>>>
90485>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90486>>>
90486>>>        Function_Return APIIndexes
90487>>>    End_Function
90488>>>
90488>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90488>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90488>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90488>>>    // have "holes" in the series of index numbers.
90488>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
90490>>>        tAPIIndexCompare[] aAPIIndexCompare
90490>>>        tAPIIndexCompare[] aAPIIndexCompare
90491>>>        tAPIIndexCompare   APIIndexCompare
90491>>>        tAPIIndexCompare   APIIndexCompare
90491>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90491>>>
90491>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
90492>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
90493>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90495>>>            Function_Return aAPIIndexCompare
90496>>>        End
90496>>>>
90496>>>
90496>>>        Decrement iSizeFrom
90497>>>        for iCount from 0 to iSizeFrom
90503>>>>
90503>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
90504>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
90505>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
90506>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
90507>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
90508>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
90509>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
90510>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
90511>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
90512>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
90513>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
90514>>>        Loop
90515>>>>
90515>>>
90515>>>        Decrement iSizeTo
90516>>>        for iCount from 0 to iSizeTo
90522>>>>
90522>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
90523>>>            // Search if the Index number already exists in the array; else add it.
90523>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
90524>>>            If (iItem = -1) Begin
90526>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
90527>>>            End
90527>>>>
90527>>>
90527>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
90528>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
90529>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
90530>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
90531>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
90532>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
90533>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
90534>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
90535>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
90536>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
90537>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
90538>>>        Loop
90539>>>>
90539>>>
90539>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
90540>>>
90540>>>        Function_Return aAPIIndexCompare
90541>>>    End_Function
90542>>>
90542>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
90542>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
90544>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
90544>>>        String sDriverID
90544>>>
90544>>>        Get psDriverID to sDriverID
90545>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90546>>>        Get IsSQLDriver sDriverID to bIsSqlTable
90547>>>        If (bIsSqlTable = True) Begin
90549>>>            Get _UtilTableIsSql hTable to bIsSqlTable
90550>>>        End
90550>>>>
90550>>>
90550>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
90551>>>        If (bIsSame = False) Begin
90553>>>            Function_Return False
90554>>>        End
90554>>>>
90554>>>
90554>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
90556>>>            // Don't think we should do this. Or should we?
90556>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
90556>>>
90556>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
90557>>>            If (bIsSame = False) Begin
90559>>>                Function_Return False
90560>>>            End
90560>>>>
90560>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
90561>>>            If (bIsSame = False) Begin
90563>>>                Function_Return False
90564>>>            End
90564>>>>
90564>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
90565>>>            If (bIsSame = False) Begin
90567>>>                Function_Return False
90568>>>            End
90568>>>>
90568>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
90569>>>            If (bIsSame = False) Begin
90571>>>                Function_Return False
90572>>>            End
90572>>>>
90572>>>        End
90572>>>>
90572>>>
90572>>>        Function_Return bIsSame
90573>>>    End_Function
90574>>>
90574>>>    // DF_INDEX_SQL_TYPE values
90574>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
90574>>>    // returns a string with the name.
90574>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
90576>>>        String sRetval
90576>>>            Case Begin
90576>>>                Case (iIndexType = DF_INDEX_CLIENT)
90578>>>                    Move "DF_INDEX_CLIENT" to sRetval
90579>>>                    Case Break
90580>>>                Case (iIndexType = DF_INDEX_SERVER)
90583>>>                    Move "DF_INDEX_SERVER" to sRetval
90584>>>                    Case Break
90585>>>                Case (iIndexType = DF_INDEX_SERVER_ONLY)
90588>>>                    Move "DF_INDEX_SERVER_ONLY" to sRetval
90589>>>                    Case Break
90590>>>                Case (iIndexType = DF_INDEX_TEMPORARY)
90593>>>                    Move "DF_INDEX_TEMPORARY" to sRetval
90594>>>                    Case Break
90595>>>                Case Else
90595>>>                    Move "UNKNOWN INDEX TYPE" to sRetval
90596>>>            Case End
90596>>>        Function_Return sRetval
90597>>>    End_Function
90598>>>
90598>>>    // * Dummy function for the Studio's Code Explorer *
90598>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
90600>>>        Function_Return False
90601>>>    End_Function
90602>>>
90602>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
90602>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
90604>>>        Boolean bIsSame
90604>>>        Integer iSize iCount
90604>>>
90604>>>        Move True to bIsSame
90605>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
90606>>>        Decrement iSize
90607>>>        For iCount from 0 to iSize
90613>>>>
90613>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
90614>>>            If (bIsSame = False) Begin
90616>>>                Function_Return False
90617>>>            End
90617>>>>
90617>>>        Loop
90618>>>>
90618>>>
90618>>>        Function_Return bIsSame
90619>>>    End_Function
90620>>>
90620>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
90620>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
90622>>>        Boolean bIsSame
90622>>>
90622>>>        Move True to bIsSame
90623>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
90625>>>            Function_Return False
90626>>>        End
90626>>>>
90626>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
90628>>>            Function_Return False
90629>>>        End
90629>>>>
90629>>>
90629>>>        // We could also compare field names, but I don't think that is necessary...
90629>>>
90629>>>        Function_Return bIsSame
90630>>>    End_Function
90631>>>
90631>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
90631>>>    // already exists.
90631>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
90633>>>        Boolean bOK
90633>>>        Integer iSizeTo iSize iCount iColumn
90633>>>        String sDriverID
90633>>>
90633>>>        Move True to bOK
90634>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
90635>>>        If (iSizeTo > 0) Begin
90637>>>            Get AutoConnectionIDLogin to bOK
90638>>>            Move False to Err
90639>>>            Open hTable Mode DF_EXCLUSIVE
90641>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90644>>>            Decrement iSizeTo
90645>>>
90645>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
90645>>>            // for the "TO" database. But start by deleting all current "TO" relations:
90645>>>            Structure_Start hTable sDriverID
90646>>>                for iCount from 0 to iSizeTo
90652>>>>
90652>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
90653>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
90656>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
90659>>>                Loop
90660>>>>
90660>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
90661>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90663>>>            Set Action_Text of ghoStatusPanel to ""
90664>>>        End
90664>>>>
90664>>>
90664>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
90665>>>        Decrement iSize
90666>>>        for iCount from 0 to iSize
90672>>>>
90672>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
90673>>>        Loop
90674>>>>
90674>>>
90674>>>        Function_Return bOK
90675>>>    End_Function
90676>>>
90676>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
90678>>>        tAPIRelation[] APIRelations
90678>>>        tAPIRelation[] APIRelations
90679>>>        Integer iColumn iColumnTo iNumColumns iCount
90679>>>        Handle hParent
90679>>>        Boolean bIsOpen
90679>>>
90679>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90680>>>        Move 0 to iCount
90681>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90684>>>        If (bIsOpen = False) Begin
90686>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90687>>>            Open hTable
90689>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90690>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90693>>>            If (bIsOpen = False) Begin
90695>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90696>>>                Move True to APIRelations[0].bError
90697>>>                Function_Return APIRelations
90698>>>            End
90698>>>>
90698>>>        End
90698>>>>
90698>>>
90698>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90701>>>        For iColumn from 1 to iNumColumns
90707>>>>
90707>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
90710>>>            If (hParent <> 0) Begin
90712>>>                Open hParent
90714>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
90715>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
90718>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
90719>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
90722>>>
90722>>>                Move hParent                                            to APIRelations[iCount].hTableTo
90723>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
90726>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
90729>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
90730>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
90733>>>                Move False                                              to APIRelations[iCount].bShouldChange
90734>>>                Move False                                              to APIRelations[iCount].bCancel
90735>>>                Move False                                              to APIRelations[iCount].bError
90736>>>                Close hParent
90737>>>                Increment iCount
90738>>>            End
90738>>>>
90738>>>        Loop
90739>>>>
90739>>>
90739>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90740>>>        Function_Return APIRelations
90741>>>    End_Function
90742>>>
90742>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90742>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
90742>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
90744>>>        tAPIRelation[] aAPIRelationFromAndTo
90744>>>        tAPIRelation[] aAPIRelationFromAndTo
90745>>>        tAPIRelationCompare[] aAPIRelationCompare
90745>>>        tAPIRelationCompare[] aAPIRelationCompare
90746>>>        tAPIRelationCompare   APIRelationCompare
90746>>>        tAPIRelationCompare   APIRelationCompare
90746>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90746>>>
90746>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
90747>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
90748>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90750>>>            Function_Return aAPIRelationCompare
90751>>>        End
90751>>>>
90751>>>
90751>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
90752>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(__UtilRelationArrayCompare))) to aAPIRelationFromAndTo
90753>>>
90753>>>        Decrement iSizeFrom
90754>>>        for iCount from 0 to iSizeFrom
90760>>>>
90760>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
90761>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
90762>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
90763>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
90764>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
90765>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
90766>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
90767>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
90768>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
90769>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
90770>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
90771>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
90772>>>        Loop
90773>>>>
90773>>>
90773>>>        Decrement iSizeTo
90774>>>        for iCount from 0 to iSizeTo
90780>>>>
90780>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
90781>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
90782>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
90783>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
90784>>>
90784>>>            // Search if the relation already exists in the array; else add it.
90784>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to iItem
90785>>>            If (iItem = -1) Begin
90787>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
90788>>>            End
90788>>>>
90788>>>
90788>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
90789>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
90790>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
90791>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
90792>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
90793>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
90794>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
90795>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
90796>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
90797>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
90798>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
90799>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
90800>>>        Loop
90801>>>>
90801>>>
90801>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to aAPIRelationCompare
90802>>>
90802>>>        Function_Return aAPIRelationCompare
90803>>>    End_Function
90804>>>
90804>>>    // * Dummy function for the Studio's Code Explorer *
90804>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
90806>>>        Function_Return False
90807>>>    End_Function
90808>>>
90808>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
90808>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
90808>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
90808>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
90810>>>        Boolean bFound
90810>>>
90810>>>        Move False to Err
90811>>>        Open CodeMast
90813>>>        Open CodeType
90815>>>
90815>>>        If (bCodeType = True) Begin
90817>>>            Set Private.phCurrentTable to CODETYPE.File_Number
90818>>>            Clear CodeType
90819>>>            Move sTypeValue to CODETYPE.Type
90820>>>            Find eq CODETYPE by 1
90821>>>>
90821>>>            Move Found to bFound
90822>>>            If (bFound = True) Begin
90824>>>                Reread CodeType
90828>>>            End
90828>>>>
90828>>>            Else Begin
90829>>>                Clear CodeType
90830>>>            End
90830>>>>
90830>>>
90830>>>            Move sTypeValue to CODETYPE.Type
90831>>>            Move sValue2    to CODETYPE.Description
90832>>>            Move sValue3    to CODETYPE.Comment
90833>>>            SaveRecord CODETYPE
90834>>>
90834>>>            If (bFound = True) Begin
90836>>>                Unlock
90837>>>>
90837>>>            End
90837>>>>
90837>>>        End
90837>>>>
90837>>>
90837>>>        If (bCodeType = False) Begin
90839>>>            Set Private.phCurrentTable to CODEMAST.File_Number
90840>>>            Clear CODEMAST
90841>>>            Move sTypeValue to CODEMAST.Type
90842>>>            Move sValue2    to CODEMAST.Code
90843>>>            Find eq CODEMAST by 1
90844>>>>
90844>>>            Move Found to bFound
90845>>>            If (bFound = True) Begin
90847>>>                Reread CODEMAST
90851>>>            End
90851>>>>
90851>>>            Else Begin
90852>>>                Clear CODEMAST
90853>>>            End
90853>>>>
90853>>>
90853>>>            Move sTypeValue to CODEMAST.Type
90854>>>            Move sValue2    to CODEMAST.Code
90855>>>            Move sValue3    to CODEMAST.Description
90856>>>            SaveRecord CODEMAST
90857>>>
90857>>>            If (bFound = True) Begin
90859>>>                Unlock
90860>>>>
90860>>>            End
90860>>>>
90860>>>        End
90860>>>>
90860>>>
90860>>>        Close CodeMast
90861>>>        Close CodeType
90862>>>
90862>>>        Function_Return (Err = False)
90863>>>    End_Function
90864>>>
90864>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
90864>>>    // CodeType and then spins through all CodeMast records to change all related records.
90864>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
90866>>>        Boolean bFound
90866>>>
90866>>>        Move False to Err
90867>>>        Open CodeMast
90869>>>        Open CodeType
90871>>>
90871>>>        Clear CodeType
90872>>>        Move sFromValue to CODETYPE.Type
90873>>>        Find eq CODETYPE.Type
90874>>>>
90874>>>        If (Found = True) Begin
90876>>>            Reread CODETYPE
90880>>>                Move sToValue to CODETYPE.Type
90881>>>                SaveRecord CODETYPE
90882>>>            Unlock
90883>>>>
90883>>>        End
90883>>>>
90883>>>
90883>>>        Clear CODEMAST
90884>>>        Find gt CODEMAST by Recnum
90885>>>>
90885>>>        While (Found = True)
90889>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
90890>>>            If (bFound = True) Begin
90892>>>                Reread CODEMAST
90896>>>                    Move sToValue to CODEMAST.Type
90897>>>                    SaveRecord CODEMAST
90898>>>                Unlock
90899>>>>
90899>>>            End
90899>>>>
90899>>>            Find gt CODEMAST by Recnum
90900>>>>
90900>>>        Loop
90901>>>>
90901>>>
90901>>>        Close CodeMast
90902>>>        Close CodeType
90903>>>
90903>>>        Function_Return (Err = False)
90904>>>    End_Function
90905>>>
90905>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
90905>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
90907>>>        Boolean bFound
90907>>>
90907>>>        Move False to Err
90908>>>        Open CodeMast
90910>>>
90910>>>        Clear CODEMAST
90911>>>        Move sTypeValue to CODEMAST.Type
90912>>>        Move sValue2    to CODEMAST.Code
90913>>>        Find eq CODEMAST.Code
90914>>>>
90914>>>        Move Found to bFound
90915>>>        If (bFound = True) Begin
90917>>>            Delete CODEMAST
90918>>>        End
90918>>>>
90918>>>
90918>>>        Close CodeMast
90919>>>
90919>>>        Function_Return (Err = False)
90920>>>    End_Function
90921>>>
90921>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
90923>>>        Boolean bRecnum bToAnsi
90923>>>        Integer iCh
90923>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
90923>>>
90923>>>        If (Trim(sDataPath) = "") Begin
90925>>>            Function_Return False
90926>>>        End
90926>>>>
90926>>>
90926>>>        Move False to Err
90927>>>        Get psDriverID     to sDriverID
90928>>>        Get psConnectionID to sConnectionID
90929>>>        Get psSchema       to sSchemaName
90930>>>        Get True           to bRecnum
90931>>>        Get pbToANSI       to bToAnsi
90932>>>        Move CS_ANSI_Txt to sANSI_OEM
90933>>>        If (bToAnsi = False) Begin
90935>>>            Move CS_OEM_Txt to sANSI_OEM
90936>>>        End
90936>>>>
90936>>>
90936>>>        Get vFolderFormat sDataPath to sDataPath
90937>>>        Move "CodeMast.int"         to sFileName
90938>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
90939>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
90942>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
90945>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
90948>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
90951>>>            Writeln channel iCh ("")
90954>>>            Writeln channel iCh ("RECNUM_TABLE YES")
90957>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
90960>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
90963>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
90966>>>            Writeln channel iCh ("")
90969>>>            Writeln channel iCh ("INDEX_NUMBER 1")
90972>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
90975>>>            Writeln channel iCh ("")
90978>>>        Send Seq_Close_Channel iCh
90979>>>
90979>>>        Get vFolderFormat sDataPath to sDataPath
90980>>>        Move "CodeType.int"         to sFileName
90981>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
90982>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
90985>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
90988>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
90991>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
90994>>>            Writeln channel iCh ("")
90997>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91000>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91003>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91006>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91009>>>            Writeln channel iCh ("")
91012>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91015>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91018>>>            Writeln channel iCh ("")
91021>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91024>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91027>>>            Writeln channel iCh ("")
91030>>>        Send Seq_Close_Channel iCh
91031>>>
91031>>>        Function_Return (Err = False)
91032>>>    End_Function
91033>>>
91033>>>    // * Dummy function for the Studio's Code Explorer *
91033>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
91035>>>        Function_Return False
91036>>>    End_Function
91037>>>
91037>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
91037>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
91037>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
91039>>>        Boolean bOK bExists
91039>>>        String sDataPath sBackupFolder
91039>>>
91039>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
91040>>>        Move CS_DUFBackupDataFolder to sBackupFolder
91041>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91042>>>        Get vFolderFormat sDataPath to sDataPath
91043>>>
91043>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91044>>>        If (bExists = False) Begin
91046>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
91047>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91048>>>            If (bExists = False) Begin
91050>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
91051>>>>
91051>>>                Function_Return False
91052>>>            End
91052>>>>
91052>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
91053>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
91054>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
91055>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
91056>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
91057>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
91058>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
91059>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
91060>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
91061>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
91062>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
91063>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
91064>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
91065>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
91066>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
91067>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
91068>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
91069>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
91070>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
91071>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
91072>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
91073>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
91074>>>        End
91074>>>>
91074>>>
91074>>>        Set Message_Text of ghoStatusPanel to ""
91075>>>        Function_Return True
91076>>>    End_Function
91077>>>    
91077>>>    // Check if the file exists in the Data folder,
91077>>>    // else creates it from memory as it has been compiled into the program as a resource:
91077>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
91079>>>        String sPath
91079>>>        Boolean bExists
91079>>>
91079>>>        Get psDataPathFirstPart to sPath
91080>>>        Move (sPath + sFileName) to sFileName
91081>>>        Get vFilePathExists sFileName to bExists
91082>>>
91082>>>        If (bExists = False) Begin
91084>>>            // Read from memory & create file on disk.
91084>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
91085>>>            Get vFilePathExists sFileName to bExists
91086>>>        End
91086>>>>
91086>>>        Function_Return bExists
91087>>>    End_Function
91088>>>
91088>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
91090>>>        tColumnType RetvalType
91090>>>        tColumnType RetvalType
91090>>>        Integer iRetval
91090>>>
91090>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91091>>>        Move RetvalType.iDataFlexType to iRetval
91092>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
91094>>>            If (iLength <= 255) Begin
91096>>>                Move DF_ASCII to iRetval
91097>>>            End
91097>>>>
91097>>>        End
91097>>>>
91097>>>        Function_Return iRetval
91098>>>    End_Function
91099>>>
91099>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
91101>>>        String sRetval
91101>>>
91101>>>        Case Begin
91101>>>            Case (iDataType = DF_ASCII)
91103>>>                Move "DF_ASCII" to sRetval
91104>>>                Case Break
91105>>>            Case (iDataType = DF_BCD)
91108>>>                Move "DF_BCD" to sRetval
91109>>>                Case Break
91110>>>            Case (iDataType = DF_BINARY)
91113>>>                Move "DF_BINARY" to sRetval
91114>>>                Case Break
91115>>>            Case (iDataType = DF_DATE)
91118>>>                Move "DF_DATE" to sRetval
91119>>>                Case Break
91120>>>            Case (iDataType = DF_DATETIME)
91123>>>                Move "DF_DATETIME" to sRetval
91124>>>                Case Break
91125>>>            Case (iDataType = DF_TEXT)
91128>>>                Move "DF_TEXT" to sRetval
91129>>>                Case Break
91130>>>            Case Else
91130>>>                Move "" to sRetval
91131>>>        Case End
91131>>>
91131>>>        Function_Return sRetval
91132>>>    End_Function
91133>>>
91133>>>    // The default value used for a datatype as specified in the driver int file.
91133>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
91135>>>        String sRetval sServer
91135>>>        tColumnType RetvalType
91135>>>        tColumnType RetvalType
91135>>>        Integer iDriver iDataFlexType
91135>>>        Handle hDatabase
91135>>>
91135>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91136>>>        Move RetvalType.iDataFlexType to iDataFlexType
91137>>>        Get DriverIndex sDriverID to iDriver
91138>>>        Get psServer to sServer
91139>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91140>>>        If (hDatabase = 0) Begin
91142>>>            Function_Return ""
91143>>>        End
91143>>>>
91143>>>
91143>>>        Case Begin
91143>>>            Case (iDataFlexType = DF_ASCII)
91145>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
91148>>>                Case Break
91149>>>            Case (iDataFlexType = DF_BCD)
91152>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
91155>>>                Case Break
91156>>>            Case (iDataFlexType = DF_BINARY)
91159>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
91162>>>                Case Break
91163>>>            Case (iDataFlexType = DF_DATE)
91166>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
91169>>>                Case Break
91170>>>            Case (iDataFlexType = DF_DATETIME)
91173>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
91176>>>                Case Break
91177>>>            Case (iDataFlexType = DF_TEXT)
91180>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
91183>>>                Case Break
91184>>>            Case Else
91184>>>                Move "" to sRetval
91185>>>        Case End
91185>>>
91185>>>        Function_Return sRetval
91186>>>    End_Function
91187>>>
91187>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
91189>>>        String sDriverID sServer
91189>>>        tColumnType RetvalType
91189>>>        tColumnType RetvalType
91189>>>        Integer iDbType iDriver
91189>>>        Handle hDatabase
91189>>>
91189>>>        Get psDriverID to sDriverID
91190>>>        Get piDbType   to iDbType
91191>>>        Get DriverIndex sDriverID to iDriver
91192>>>        Get psServer to sServer
91193>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91194>>>        If (hDatabase = 0) Begin
91196>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
91197>>>>
91197>>>            Procedure_Return
91198>>>        End
91198>>>>
91198>>>
91198>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
91201>>>
91201>>>    End_Procedure
91202>>>
91202>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
91204>>>        String sDriverID sServer
91204>>>        tColumnType RetvalType
91204>>>        tColumnType RetvalType
91204>>>        Integer iDbType iDriver
91204>>>        Handle hDatabase
91204>>>
91204>>>        Get psDriverID to sDriverID
91205>>>        Get piDbType   to iDbType
91206>>>        Get DriverIndex sDriverID to iDriver
91207>>>        Get psServer to sServer
91208>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91209>>>        If (hDatabase = 0) Begin
91211>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
91212>>>>
91212>>>            Procedure_Return
91213>>>        End
91213>>>>
91213>>>
91213>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
91216>>>
91216>>>    End_Procedure
91217>>>
91217>>>    // Returns a struct array with the default column types for the SQL back-end and how they
91217>>>    // are mapped to the standard DataFlex data types.
91217>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
91217>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
91219>>>        tColumnType[] ColumnTypeArray EmptyArray
91219>>>        tColumnType[] ColumnTypeArray EmptyArray
91221>>>        String sDataType
91221>>>        Integer iDataType iDriverID iCount
91221>>>        Boolean bSQLDriver
91221>>>
91221>>>        Move 0 to iCount
91222>>>        Get DriverIndex sDriverID to iDriverID
91223>>>        Get IsSQLDriver sDriverID to bSQLDriver
91224>>>        If (bSQLDriver = False) Begin
91226>>>            Function_Return EmptyArray
91227>>>        End
91227>>>>
91227>>>
91227>>>        // DF_ASCII
91227>>>        If (sDriverID = ODBC_DRV_ID) Begin
91229>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
91232>>>        End
91232>>>>
91232>>>        Else Begin
91233>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
91236>>>        End
91236>>>>
91236>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91237>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
91238>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
91239>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91240>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91241>>>        Increment iCount
91242>>>
91242>>>        // DF_BINARY
91242>>>        If (sDriverID = ODBC_DRV_ID) Begin
91244>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
91247>>>        End
91247>>>>
91247>>>        Else Begin
91248>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
91251>>>        End
91251>>>>
91251>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91252>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
91253>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
91254>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91255>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91256>>>        Increment iCount
91257>>>
91257>>>        // DF_DATE
91257>>>        If (sDriverID = ODBC_DRV_ID) Begin
91259>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
91262>>>        End
91262>>>>
91262>>>        Else Begin
91263>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
91266>>>        End
91266>>>>
91266>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91267>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
91268>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
91269>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91270>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91271>>>        Increment iCount
91272>>>
91272>>>        // DF_DATETIME
91272>>>        If (sDriverID = ODBC_DRV_ID) Begin
91274>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
91277>>>        End
91277>>>>
91277>>>        Else Begin
91278>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
91281>>>        End
91281>>>>
91281>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91282>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
91283>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
91284>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91285>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91286>>>        Increment iCount
91287>>>
91287>>>        // DF_NUMERIC
91287>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
91287>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
91287>>>        // we make them here all "Numeric"...
91287>>>        Case Begin
91287>>>            Case (sDriverID = MSSQLDRV_ID)
91289>>>                Move SQL_NUMERIC to iDataType
91290>>>                Move "numeric"   to sDataType
91291>>>                Case Break
91292>>>            Case (sDriverID = DB2_DRV_ID)
91295>>>                Move SQL_NUMERIC to iDataType
91296>>>                Move "NUMERIC"   to sDataType
91297>>>                Case Break
91298>>>            Case Else
91298>>>                Move DF_BCD      to iDataType
91299>>>                Move "Numeric"   to sDataType
91300>>>        Case End
91300>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
91301>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
91302>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91303>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91304>>>        Increment iCount
91305>>>
91305>>>        // DF_TEXT
91305>>>        If (sDriverID = ODBC_DRV_ID) Begin
91307>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
91310>>>        End
91310>>>>
91310>>>        Else Begin
91311>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
91314>>>        End
91314>>>>
91314>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91315>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
91316>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
91317>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91318>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91319>>>
91319>>>        Function_Return ColumnTypeArray
91320>>>    End_Function
91321>>>
91321>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
91323>>>        tColumnType[] ColumnTypeArray
91323>>>        tColumnType[] ColumnTypeArray
91324>>>        tColumnType   ColumnType
91324>>>        tColumnType   ColumnType
91324>>>        Integer iCount iSize
91324>>>
91324>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
91325>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
91326>>>        Decrement iSize
91327>>>
91327>>>        for iCount from 0 to iSize
91333>>>>
91333>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
91335>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
91336>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
91337>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
91338>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
91339>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
91340>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
91341>>>                Move iSize to iCount
91342>>>            End
91342>>>>
91342>>>        Loop
91343>>>>
91343>>>
91343>>>        Function_Return ColumnType
91344>>>    End_Function
91345>>>
91345>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
91345>>>    // An Alias file/table is a filelist number that share the same Physical filename
91345>>>    // but the Logical name is different.
91345>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
91345>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
91347>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
91347>>>        Handle hInTable hMasterTable 
91347>>>        Boolean bIsAlias
91347>>>        
91347>>>        Move hTable to hInTable
91348>>>        Move False to bIsAlias
91349>>>        Move 0 to hMasterTable
91350>>>        
91350>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91353>>>        // Remove any prefix with a driver name.
91353>>>        Get _TableNameOnly sRootName to sRootName     
91354>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91357>>>        Get _TableNameOnly sLogicalName to sLogicalName     
91358>>>        
91358>>>        // If the table has the same root and logical name it can't be an alias,
91358>>>        // so we can safely return a "False".
91358>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
91360>>>            Function_Return False
91361>>>        End
91361>>>>
91361>>>        
91361>>>        // Now we need to find a master table with the same root name (sRootName above),
91361>>>        // as the passed hTable root name.
91361>>>        // A master table always has the same root and logical name.
91361>>>        Move 0 to hTable
91362>>>        Repeat
91362>>>>
91362>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91365>>>            If (hTable > 0 and hTable <> 50) Begin
91367>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
91370>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
91371>>>                // If we found another table with the same root and logical name
91371>>>                // we have found a master table.
91371>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
91373>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
91376>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
91377>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
91379>>>                        Move hTable to hMasterTable   
91380>>>                        Move 0 to hTable // To end the loop.
91381>>>                    End
91381>>>>
91381>>>                End
91381>>>>
91381>>>            End
91381>>>>
91381>>>        Until (hTable = 0)
91383>>>        
91383>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
91385>>>            Move True to bIsAlias
91386>>>        End
91386>>>>
91386>>>        
91386>>>        Function_Return bIsAlias
91387>>>    End_Function
91388>>>
91388>>>    // To Open a table with any driver.
91388>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
91388>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
91388>>>    //
91388>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
91388>>>    // The found flag is still used to indicate if the open was successful or not. The function
91388>>>    // returns a True if successful (table could be opened).
91388>>>    //
91388>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
91388>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
91388>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
91388>>>    // set properly we can open the table.
91388>>>    //
91388>>>    // DAW Driver Syntax:
91388>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
91388>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
91388>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
91388>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
91388>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
91388>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
91388>>>    //
91388>>>    // DAW Driver Sample:
91388>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
91388>>>    //
91388>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
91390>>>        String sTableNameOrg
91390>>>        Boolean bOpen bOK
91390>>>        tSQLConnection SQLConnection
91390>>>        tSQLConnection SQLConnection
91390>>>        
91390>>>        Move False to bOpen
91391>>>        Move sTableName to sTableNameOrg
91392>>>        If (hTable > 0) Begin
91394>>>            Send Ignore_Error of Error_Object_Id 20529
91395>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91396>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91397>>>            Send Ignore_Error of Error_Object_Id 10
91398>>>            Open hTable Mode iMode
91400>>>            Send Trap_Error of Error_Object_Id 20529
91401>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91402>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91403>>>            Send Trap_Error of Error_Object_Id 10
91404>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91407>>>            If (bOpen = True) Begin
91409>>>                Function_Return True
91410>>>            End
91410>>>>
91410>>>        End
91410>>>>
91410>>>
91410>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
91411>>>        If (hTable > 0) Begin
91413>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91416>>>        End
91416>>>>
91416>>>
91416>>>        Function_Return bOpen
91417>>>    End_Function
91418>>>
91418>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
91420>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
91420>>>        Boolean bOpen bOK
91420>>>        tSQLConnection SQLConnection
91420>>>        tSQLConnection SQLConnection
91420>>>
91420>>>        If (hTable < 1) Begin
91422>>>            Function_Return False
91423>>>        End
91423>>>>
91423>>>
91423>>>        Move sTableName to sTableNameOrg
91424>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91425>>>        Move SQLConnection.sDriverID to sDriverID
91426>>>        Move SQLConnection.sConnectionString to sConnection
91427>>>        Move SQLConnection.sSchema to sSchema
91428>>>        If (sSchema = "") Begin
91430>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
91431>>>        End
91431>>>>
91431>>>
91431>>>        // We need to remove the ".int" part of the table name because
91431>>>        // the table name after the "#" in the connection syntax below wants the
91431>>>        // "bare" table name without any extension.
91431>>>        If (sDriverID <> DATAFLEX_ID) Begin
91433>>>            If (Lowercase(sTableName) contains ".int") Begin
91435>>>                Get ParseFileExtension sTableName to sExt
91436>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
91437>>>            End
91437>>>>
91437>>>            Else Begin
91438>>>                Move sTableName to sTableNameShort
91439>>>                Move (Append(sTableName, ".int")) to sTableName
91440>>>            End
91440>>>>
91440>>>            Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
91441>>>            Move sConnection to sTableName
91442>>>        End
91442>>>>
91442>>>
91442>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91443>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91444>>>        If (hTable = 0) Begin
91446>>>            Get NextFreeFilelistSlot to hTable
91447>>>        End
91447>>>>
91447>>>
91447>>>        Case Begin
91447>>>            Case (sDriverID = MSSQLDRV_ID)
91449>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91449>>>                If (iMode <> DF_EXCLUSIVE) Begin
91451>>>                    Close hTable
91452>>>                    Open sTableName as hTable
91454>>>                End
91454>>>>
91454>>>                Else Begin
91455>>>                    Get OpenTableExclusive hTable to bOK
91456>>>                    If (bOK = False) Begin
91458>>>                        Function_Return False
91459>>>                    End
91459>>>>
91459>>>                End
91459>>>>
91459>>>                Case Break
91460>>>
91460>>>            Case (sDriverID = DB2_DRV_ID)
91463>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91463>>>                If (iMode <> DF_EXCLUSIVE) Begin
91465>>>                    Close hTable
91466>>>                    Open sTableName as hTable
91468>>>                End
91468>>>>
91468>>>                Else Begin
91469>>>                    Get OpenTableExclusive hTable to bOK
91470>>>                    If (bOK = False) Begin
91472>>>                        Function_Return False
91473>>>                    End
91473>>>>
91473>>>                End
91473>>>>
91473>>>                Case Break
91474>>>
91474>>>            Case (sDriverID = ODBC_DRV_ID)
91477>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91477>>>                If (iMode = DF_SHARE) Begin
91479>>>                    Close hTable
91480>>>                    Open sTableName as hTable
91482>>>                End
91482>>>>
91482>>>                Else Begin
91483>>>                    Get OpenTableExclusive hTable to bOK
91484>>>                    If (bOK = False) Begin
91486>>>                        Function_Return False
91487>>>                    End
91487>>>>
91487>>>                End
91487>>>>
91487>>>                Case Break
91488>>>
91488>>>            Case (sDriverID = DATAFLEX_ID)
91491>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
91493>>>                    Close hTable
91494>>>                    Open sTableName as hTable
91496>>>                End
91496>>>>
91496>>>                Else If (iMode = DF_EXCLUSIVE) Begin
91499>>>                    Get OpenTableExclusive hTable to bOK
91500>>>                    If (bOK = False) Begin
91502>>>                        Function_Return False
91503>>>                    End
91503>>>>
91503>>>                End
91503>>>>
91503>>>                Else Begin
91504>>>                    Open hTable
91506>>>                End
91506>>>>
91506>>>                Case Break
91507>>>
91507>>>            Case Else
91507>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
91508>>>>
91508>>>        Case End
91508>>>
91508>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91509>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91510>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
91512>>>            Move False to Found
91513>>>        End
91513>>>>
91513>>>        // If open failed, the Err is set to true,
91513>>>        // but we don't want that because it could end our loop.
91513>>>        Move False to Err
91514>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91517>>>
91517>>>        Function_Return bOpen
91518>>>    End_Function
91519>>>
91519>>>    // Pass a table's logical name
91519>>>    // Returns True if the table exists in filelist.cfg.
91519>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
91521>>>        Handle hTable
91521>>>        Boolean bFound
91521>>>        String sCompareTable
91521>>>
91521>>>        Move False to bFound
91522>>>        Move 0 to hTable
91523>>>        Repeat
91523>>>>
91523>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91526>>>            If (hTable > 0) Begin
91528>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
91531>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
91533>>>                    Move True to bFound
91534>>>                End
91534>>>>
91534>>>            End
91534>>>>
91534>>>            If (bFound = True) ;                Break
91537>>>        Until (hTable = 0)
91539>>>
91539>>>        Function_Return (bFound = True)
91540>>>    End_Function
91541>>>
91541>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
91541>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
91543>>>        Boolean bOK bExists
91543>>>        String sDriverID
91543>>>
91543>>>        Get _UtilTableExists hTable to bExists
91544>>>        If (bExists = False) Begin
91546>>>            Function_Return DATAFLEX_ID
91547>>>        End
91547>>>>
91547>>>        Get OpenTableExclusive hTable to bOK
91548>>>        If (bOK = False) Begin
91550>>>            Function_Return DATAFLEX_ID
91551>>>        End
91551>>>>
91551>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91554>>>        Function_Return sDriverID
91555>>>    End_Function
91556>>>
91556>>>    // Number of tables in Filelist.cfg. Returns integger
91556>>>    Function UtilFilelistNoOfTables Returns Integer
91558>>>        Handle hTable
91558>>>        Integer iRetval
91558>>>
91558>>>        Move 0 to hTable
91559>>>        Move 0 to iRetval
91560>>>
91560>>>        Repeat
91560>>>>
91560>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91563>>>            If (hTable > 0) Begin
91565>>>                Increment iRetval
91566>>>            End
91566>>>>
91566>>>        Until (hTable = 0)
91568>>>
91568>>>        Function_Return iRetval
91569>>>    End_Function
91570>>>
91570>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
91570>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
91572>>>        Handle hTable
91572>>>        String sRoot sDriverID
91572>>>        Boolean bIsSQLTable
91572>>>        Integer iPos
91572>>>
91572>>>        Move 0 to hTable
91573>>>        Move "" to sDriverID
91574>>>        Move False to bIsSQLTable
91575>>>
91575>>>        Repeat
91575>>>>
91575>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91578>>>            If (hTable > 0) Begin
91580>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
91583>>>                If (sRoot contains ":") Begin
91585>>>                    Move (Pos(":", sRoot)) to iPos
91586>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
91587>>>                End
91587>>>>
91587>>>                Get IsSQLDriver sDriverID to bIsSQLTable
91588>>>            End
91588>>>>
91588>>>
91588>>>        Until (hTable = 0 or bIsSQLTable = True)
91590>>>
91590>>>        Function_Return sDriverID
91591>>>    End_Function
91592>>>
91592>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
91594>>>        String sRootName
91594>>>        Boolean bIsSQL
91594>>>        Handle hTable
91594>>>
91594>>>        Move False to bIsSQL
91595>>>        Move 0 to hTable
91596>>>        Repeat
91596>>>>
91596>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91599>>>            If (hTable > 0) Begin
91601>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91604>>>                Get _UtilTableIsSqlByRootName sRootName to bIsSQL
91605>>>                If (bIsSQL = True) Begin
91607>>>                    Move 0 to hTable
91608>>>                End
91608>>>>
91608>>>            End
91608>>>>
91608>>>        Until (hTable = 0)
91610>>>
91610>>>        Function_Return (bIsSQL = False)
91611>>>    End_Function
91612>>>
91612>>>    // * Dummy function for the Studio's Code Explorer *
91612>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
91614>>>        Function_Return False
91615>>>    End_Function
91616>>>
91616>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
91618>>>        String  sRetval
91618>>>        String[] sOverlapFieldsArray
91619>>>        Integer iType iColumn iColumns
91619>>>        Boolean bOpen bOverlap
91619>>>
91619>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91622>>>        If (bOpen = False) Begin
91624>>>            Open hTable
91626>>>        End
91626>>>>
91626>>>
91626>>>        Move "" to sRetval
91627>>>
91627>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
91630>>>
91630>>>        for iColumn from 0 to iColumns
91636>>>>
91636>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
91639>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
91641>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
91644>>>                If (bOverlap) Begin
91646>>>                    If (sRetval <> "") Begin
91648>>>                        Append sRetval ","
91649>>>                    End
91649>>>>
91649>>>                    Append sRetval iColumn
91650>>>                End
91650>>>>
91650>>>            End
91650>>>>
91650>>>        Loop
91651>>>>
91651>>>
91651>>>        If (bOpen = False) Begin
91653>>>            Close hTable
91654>>>        End
91654>>>>
91654>>>
91654>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
91655>>>
91655>>>        Function_Return sOverlapFieldsArray
91656>>>    End_Function
91657>>>
91657>>>    Function UtilEnumerateODBCDrivers Returns String
91659>>>        Handle hoRegistry hoODBCDriverNames
91659>>>        Boolean bExists bKeyOpened
91659>>>        String sKey
91659>>>        String[] sDrivers
91660>>>        Integer iDriverNames iDriverName
91660>>>
91660>>>        Get Create (RefClass (cRegistry)) to hoRegistry
91661>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
91662>>>        Set pfAccessRights of hoRegistry to Key_Read
91663>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
91664>>>        Get KeyExists of hoRegistry sKey to bExists
91665>>>        If (bExists) Begin
91667>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
91668>>>            If (bKeyOpened) Begin
91670>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
91671>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
91672>>>                If (iDriverNames > 0) Begin
91674>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
91675>>>                    Decrement iDriverNames
91676>>>                    for iDriverName from 0 to iDriverNames
91682>>>>
91682>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
91683>>>                    Loop
91684>>>>
91684>>>                End
91684>>>>
91684>>>                Send CloseKey of hoRegistry
91685>>>            End
91685>>>>
91685>>>        End
91685>>>>
91685>>>        Send Destroy of hoRegistry
91686>>>
91686>>>        Function_Return sDrivers
91687>>>    End_Function
91688>>>
91688>>>    Procedure IncreaseSortBufferSize
91690>>>        String sNull
91690>>>        Integer iSortBufferSize
91690>>>        Boolean bBufferSet
91690>>>
91690>>>        Move "" to sNull
91691>>>        Move (1024 * 128) to iSortBufferSize
91692>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
91697>>>
91697>>>    End_Procedure
91698>>>
91698>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
91700>>>        Integer iLastIndex iIndex iNumSegments
91700>>>        Boolean bOK
91700>>>        String sDriverID
91700>>>
91700>>>        If (hTable > 0) Begin
91702>>>            Get UtilDriverFromTableNumber hTable to sDriverID
91703>>>            Close hTable
91704>>>            Get OpenTableExclusive hTable to bOK
91705>>>            If (bOK = False) Begin
91707>>>                Procedure_Return
91708>>>            End
91708>>>>
91708>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
91711>>>            Structure_Start hTable sDriverID
91712>>>                for iIndex from 1 to iLastIndex
91718>>>>
91718>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91721>>>                    If (iNumSegments > 0) Begin
91723>>>                        If (bSetToBatch = True) Begin
91725>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
91728>>>                        End
91728>>>>
91728>>>                        Else Begin
91729>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
91732>>>                        End
91732>>>>
91732>>>                    End
91732>>>>
91732>>>                Loop
91733>>>>
91733>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91735>>>        End
91735>>>>
91735>>>    End_Procedure
91736>>>
91736>>>    Function NextFreeFilelistSlot Returns Handle
91738>>>        Handle hTable
91738>>>
91738>>>        Move 0 to hTable
91739>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
91742>>>
91742>>>        Function_Return hTable
91743>>>    End_Function
91744>>>
91744>>>    // For debugging purposes. To print Sql statements as they are build...
91744>>>    Procedure DebugPrint String sStmt String sFileName
91746>>>        Integer iCh
91746>>>        Get Seq_Append_Output_Channel sFileName to iCh
91747>>>            Write channel iCh sStmt
91749>>>        Send Seq_Close_Channel iCh
91750>>>    End_Procedure
91751>>>
91751>>>    // Returns the integer number for the passed Driver ID that is
91751>>>    // needed by some database API calls.
91751>>>    Function DriverIndex String sDriverID Returns Integer
91753>>>        String  sCurrentDriver
91753>>>        Integer iNumberOfDrivers iDriver iCount
91753>>>
91753>>>        Move 0 to iDriver
91754>>>
91754>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
91757>>>        for iCount from 1 to iNumberOfDrivers
91763>>>>
91763>>>
91763>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
91766>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
91768>>>                Move iCount to iDriver
91769>>>            End
91769>>>>
91769>>>        Loop
91770>>>>
91770>>>
91770>>>        // In case it was not found, it wasn't loaded so we do that now.
91770>>>        If (iDriver = 0) Begin
91772>>>            Move False to Err
91773>>>            Load_Driver sDriverID
91774>>>            If (Err = False) Begin
91776>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
91779>>>            End
91779>>>>
91779>>>        End
91779>>>>
91779>>>
91779>>>        Function_Return iDriver
91780>>>    End_Function
91781>>>
91781>>>
91781>>>    Function SqlServerClientVersionName for cMSSQLHandler Integer iClientVersion  Returns String
91783>>>        String  sSqlServerClientVersionName
91783>>>        
91783>>>        Case Begin
91783>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
91785>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
91786>>>                Case Break
91787>>>                
91787>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
91790>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
91791>>>                Case Break
91792>>>            
91792>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
91795>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
91796>>>                Case Break
91797>>>            
91797>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
91800>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
91801>>>                Case Break
91802>>>            
91802>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
91805>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
91806>>>                Case Break
91807>>>            
91807>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
91810>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
91811>>>                Case Break
91812>>>            
91812>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
91815>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
91816>>>                Case Break
91817>>>            
91817>>>            Case Else
91817>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
91818>>>        Case End
91818>>>        
91818>>>        Function_Return sSqlServerClientVersionName
91819>>>    End_Function
91820>>>
91820>>>    Function SqlServerClientDriverName for cMSSQLHandler Integer iClientVersion  Returns String
91822>>>        String  sSqlServerClientDriverName
91822>>>        
91822>>>        Case Begin
91822>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
91824>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
91825>>>                Case Break
91826>>>                
91826>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
91829>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
91830>>>                Case Break
91831>>>            
91831>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
91834>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
91835>>>                Case Break
91836>>>            
91836>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
91839>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
91840>>>                Case Break
91841>>>            
91841>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
91844>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
91845>>>                Case Break
91846>>>            
91846>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
91849>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
91850>>>                Case Break
91851>>>            
91851>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
91854>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
91855>>>                Case Break
91856>>>            
91856>>>            Case Else
91856>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
91857>>>        Case End
91857>>>        
91857>>>        Function_Return sSqlServerClientDriverName
91858>>>    End_Function
91859>>>    
91859>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
91861>>>        String sDriverID sVersion sClient sClientLowest sRetval
91861>>>        Integer iNumberOfDrivers iDriver iClient
91861>>>        Handle hoCLIHandler hoMSSQLHandler   
91861>>>        Boolean bOK
91861>>>        
91861>>>        Move "" to sRetval
91862>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
91863>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
91864>>>        Load_Driver MSSQLDRV_ID
91865>>>
91865>>>        // Loop through all loaded drivers.
91865>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
91868>>>        For iDriver from 1 to iNumberOfDrivers
91874>>>>
91874>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
91877>>>            If (sDriverID = MSSQLDRV_ID) Begin
91879>>>                Set psDriverID of hoCLIHandler to sDriverID
91880>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
91883>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
91884>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
91885>>>                Get CKRevision of hoCLIHandler to sVersion
91886>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
91887>>>                If (sClient <> "" and sRetval <> "") Begin
91889>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
91890>>>                End                                
91890>>>>
91890>>>                Else Begin
91891>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
91892>>>                End
91892>>>>
91892>>>            End
91892>>>>
91892>>>        Loop
91893>>>>
91893>>>        Send Destroy of hoCLIHandler  
91894>>>        Send Destroy of hoMSSQLHandler  
91895>>>        If (bShowErrorDialog = True) Begin
91897>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
91898>>>            If (bOK = False or (iClient < iClientVersion)) Begin
91900>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
91901>>>                If (bExitProgram = True) Begin
91903>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
91904>>>                End
91904>>>>
91904>>>                Send Stop_Box sRetval  
91905>>>                If (bExitProgram = True) Begin
91907>>>                    Send Exit_Application
91908>>>                End
91908>>>>
91908>>>            End
91908>>>>
91908>>>        End
91908>>>>
91908>>>        
91908>>>        Function_Return sRetval
91909>>>    End_Function  
91910>>>    
91910>>>    // Returns True if first "." separated string is greater than the second.
91910>>>    // It checks from left to right, one part of the string at a time.
91910>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
91910>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
91912>>>        String[] asVersion asSQLVersion          
91914>>>        Integer iSize iCount iVersion iSQLVersion
91914>>>        
91914>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
91915>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
91916>>>        Move (SizeOfArray(asVersion)) to iSize
91917>>>        // Make sure the two arrays are of the same size:
91917>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
91919>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
91920>>>        End
91920>>>>
91920>>>        Decrement iSize
91921>>>        for iCount from 0 to iSize
91927>>>>
91927>>>            Move asVersion[iCount]    to iVersion
91928>>>            Move asSQLVersion[iCount] to iSQLVersion
91929>>>            CompilerWarnings Off
91929>>>            If (iVersion > iSQLVersion) Break
91932>>>            CompilerWarnings On
91932>>>        Loop
91933>>>>
91933>>>        
91933>>>        Function_Return (iVersion > iSQLVersion)
91934>>>    End_Function
91935>>>
91935>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
91935>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
91935>>>    //       so in that case we "cheat" and report those tables were opened OK.
91935>>>    Function OpenTableExclusive Handle hTable Returns Boolean
91937>>>        Integer iMode iErrorObject
91937>>>        Boolean bOpened
91937>>>        String sTableName 
91937>>>        Handle hoCurrentErrorHandler
91937>>>
91937>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91938>>>        // Can't open a table properly if run through the Debugger/Studio,
91938>>>        // so we generate an error here:
91938>>>        If (IsDebuggerPresent()) Begin
91940>>>            Move Error_Object_Id to hoCurrentErrorHandler
91941>>>            Get piOrgErrorHandlerID to iErrorObject
91942>>>            If (iErrorObject <> 0) Begin
91944>>>                Move iErrorObject to Error_Object_Id
91945>>>            End
91945>>>>
91945>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
91946>>>>
91946>>>            Move hoCurrentErrorHandler to Error_Object_Id
91947>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91948>>>            Function_Return False
91949>>>        End
91949>>>>
91949>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91952>>>        If (bOpened) Begin
91954>>>//            If (IsDebuggerPresent()) Begin
91954>>>//                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91954>>>//                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
91954>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
91954>>>//                    Function_Return True
91954>>>//                End
91954>>>//            End
91954>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
91957>>>            If (iMode=DF_EXCLUSIVE) Begin
91959>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
91960>>>                Function_Return True
91961>>>            End
91961>>>>
91961>>>            Close hTable
91962>>>        End
91962>>>>
91962>>>        Else Begin
91963>>>            Open hTable
91965>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
91968>>>            If (bOpened and IsDebuggerPresent()) Begin
91970>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91973>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
91975>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
91976>>>                    Function_Return True
91977>>>                End
91977>>>>
91977>>>            End
91977>>>>
91977>>>
91977>>>        End
91977>>>>
91977>>>
91977>>>        Close hTable
91978>>>        Open hTable Mode DF_EXCLUSIVE
91980>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91983>>>
91983>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91984>>>        Function_Return bOpened
91985>>>    End_Function
91986>>>
91986>>>    Function AutoConnectionIDLogin Returns Boolean
91988>>>        String sConnectionID sConnectionString sDriverID
91988>>>        Boolean bExists bOK bSQLDriver
91988>>>        Handle hoCLI hoDriver
91988>>>        Integer iRetval
91988>>>        tSQLConnection SQLConnection
91988>>>        tSQLConnection SQLConnection
91988>>>
91988>>>        Get psDriverID to sDriverID
91989>>>        Get IsSQLDriver sDriverID to bSQLDriver
91990>>>        If (bSQLDriver = False) Begin
91992>>>            Function_Return True
91993>>>        End
91993>>>>
91993>>>
91993>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91994>>>        Move SQLConnection.sDriverID                  to sDriverID
91995>>>        Move SQLConnection.sConnectionString          to sConnectionString
91996>>>        Move SQLConnection.sConnectionID to sConnectionID
91997>>>
91997>>>        Get IsConnectionID sConnectionID sDriverID to bExists
91998>>>        If (bExists = False) Begin
92000>>>            // We always start by deleting the current connection - if any - because the
92000>>>            // login details my have changed.
92000>>>            Get phoCLIHandler to hoCLI
92001>>>            Set psDriverID    of hoCLI to sDriverID
92002>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
92003>>>            Get AutoSetConnectionID sConnectionID to bOk
92004>>>            If (bOk = False) Begin
92006>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
92007>>>>
92007>>>                Function_Return False
92008>>>            End
92008>>>>
92008>>>            Move bOK to bExists
92009>>>        End
92009>>>>
92009>>>
92009>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92010>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
92011>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
92012>>>        Send Destroy of hoDriver
92013>>>
92013>>>        Function_Return (bExists = True)
92014>>>    End_Function
92015>>>
92015>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92015>>>    // Returns: False if nobody else is running
92015>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92015>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92015>>>    //      tables are not locked as DataFlex tables are.
92015>>>    Function IsDatabaseInUse Returns Boolean
92017>>>        Handle  hTable
92017>>>        String  sRootName
92017>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
92017>>>        Integer iCount iTables
92017>>>
92017>>>        Move 0 to iTables
92018>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
92019>>>        Get AutoConnectionIDLogin to bOK
92020>>>        Get UtilFilelistNoOfTables to iTables
92021>>>        Set piPosition   of ghoProgressBar to 0
92022>>>        Set piAdvanceBy  of ghoProgressBar to 1
92023>>>        Set piMaximum    of ghoProgressBar to iTables
92024>>>        Close DF_ALL
92025>>>        Move 0 to hTable
92026>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92029>>>        Move False to bErr
92030>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92031>>>
92031>>>        Repeat
92031>>>>
92031>>>            Set piPosition of ghoProgressBar to iCount
92032>>>            Increment iCount
92033>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92036>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
92037>>>
92037>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
92037>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQLTable
92038>>>            Move False to bOpen
92039>>>            Get _UtilTableExists hTable to bExists
92040>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
92040>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
92042>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92043>>>                Open hTable
92045>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
92048>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92049>>>                If (bOpen = True) Begin
92051>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
92051>>>                    Get UtilTableIsAlias hTable to bAlias
92052>>>                    If (bAlias = False) Begin
92054>>>                        Close hTable
92055>>>                        Get OpenTableExclusive hTable to bOpen
92056>>>                        If (bOpen = False) Begin
92058>>>                            Move True to bErr
92059>>>                        End
92059>>>>
92059>>>                    End
92059>>>>
92059>>>                End
92059>>>>
92059>>>                Close hTable
92060>>>            End
92060>>>>
92060>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92063>>>            If (bErr = True ) ;                Break
92066>>>        Until (not(hTable))
92068>>>
92068>>>        Set Action_Text of ghoStatusPanel to ""
92069>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92070>>>        Move False to Err
92071>>>
92071>>>        Function_Return bErr
92072>>>    End_Function
92073>>>
92073>>>End_Class
92074>// Needs to be after the cSQLConnectionHandler Object
92074>Object oDbUpdateFunctionLibrary is a cDbUpdateFunctionLibrary
92076>End_Object
92077>
92077>Use cSQLConnectionHandler.pkg
92077>Object oSQLConnectionHandler is a cSQLConnectionHandler
92079>    // If a file was passed on the command line - which can be done from the Studio -
92079>    // we change the ini-file path here. (The file name is always the same)
92079>    Procedure End_Construct_Object
92082>        String sPath
92082>        Boolean bExists
92082>        Get psCommandLineIniFilePath of ghoApplication to sPath
92083>        If (sPath <> "") Begin
92085>            Set psIniFilePath to sPath
92086>        End
92086>        Else Begin
92087>            Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
92088>            Set psIniFilePath to sPath
92089>            Get vFolderFormat sPath to sPath
92090>            Get vFilePathExists (sPath + CS_SQLIniFileName) to bExists
92091>            Set pbIniFileExists of ghoApplication to bExists
92092>        End
92092>        Forward Send End_Construct_Object
92094>    End_Procedure
92095>End_Object
92096>
92096>Object oToolTipController is a cToolTipController
92098>    Move Self to ghoToolTipController
92099>    Set pbBalloonStyle to False
92100>    Set piIcon to TTI_INFO
92101>    Set psTitle to "Information"
92102>    Set piMaxWidth to 400
92103>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
92104>End_Object
92105>
92105>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 23.0\Pkg\oEditContextMenu.pkg)
92105>>>Use cCJStandardMenuItemClasses.pkg
92105>>>
92105>>>Object oEditContextMenu is a cCJContextMenu
92107>>>    
92107>>>    Move Self to Default_Form_Floating_Menu_ID
92108>>>    
92108>>>    Object oUndoMenuItem is a cCJUndoMenuItem
92110>>>    End_Object
92111>>>    
92111>>>    Object oCutMenuItem is a cCJCutMenuItem
92113>>>        Set pbControlBeginGroup to True
92114>>>    End_Object
92115>>>    
92115>>>    Object oCopyMenuItem is a cCJCopyMenuItem
92117>>>    End_Object
92118>>>
92118>>>    Object oPasteMenuItem is a cCJPasteMenuItem
92120>>>    End_Object
92121>>>
92121>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
92123>>>    End_Object
92124>>>
92124>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
92126>>>        Set pbControlBeginGroup to True
92127>>>    End_Object
92128>>>
92128>>>End_Object
92129>>>
92129>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 23.0\Pkg\oDEOEditContextMenu17.pkg)
92129>>>Use Windows.pkg
92129>>>Use cCJStandardMenuItemClasses.pkg
92129>>>Use cCJDeoMenuItemClasses.pkg
92129>>>
92129>>>
92129>>>Object oDEOEditContextMenu17 is a cCJContextMenu
92131>>>    
92131>>>    Move Self to Default_dbFloating_Menu_ID
92132>>>    
92132>>>    Object oUndoMenuItem is a cCJUndoMenuItem
92134>>>    End_Object
92135>>>    
92135>>>    Object oCutMenuItem is a cCJCutMenuItem
92137>>>        Set pbControlBeginGroup to True
92138>>>    End_Object
92139>>>    
92139>>>    Object oCopyMenuItem is a cCJCopyMenuItem
92141>>>    End_Object
92142>>>
92142>>>    Object oPasteMenuItem is a cCJPasteMenuItem
92144>>>    End_Object
92145>>>
92145>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
92147>>>    End_Object
92148>>>
92148>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
92150>>>        Set pbControlBeginGroup to True
92151>>>    End_Object
92152>>>
92152>>>    Object oPromptMenuItem is a cCJPromptMenuItem
92154>>>        Set pbControlBeginGroup to True
92155>>>    End_Object
92156>>>
92156>>>    Object oFindNextMenu is a cCJFindNextMenuItem
92158>>>        Set pbControlBeginGroup to True
92159>>>    End_Object
92160>>>
92160>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
92162>>>    End_Object
92163>>>
92163>>>    Object oClearMenuItem is a cCJClearMenuItem
92165>>>        Set pbControlBeginGroup to True
92166>>>    End_Object
92167>>>
92167>>>    Object oClearAllMenu is a cCJClearAllMenuItem
92169>>>    End_Object
92170>>>
92170>>>    Object oSaveMenu is a cCJSaveMenuItem
92172>>>    End_Object
92173>>>    
92173>>>    Object oDeleteMenu is a cCJDeleteMenuItem
92175>>>    End_Object
92176>>>
92176>>>    Object oRememberitem is a cCJRememberFieldMenuItem
92178>>>        Set pbControlBeginGroup to True
92179>>>    End_Object
92180>>>
92180>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
92182>>>    End_Object
92183>>>
92183>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
92185>>>    End_Object
92186>>>
92186>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
92188>>>    End_Object
92189>>>
92189>>>End_Object
92190>
92190>Object oMain is a Panel
92192>    Set Label to (psProduct(ghoApplication))
92193>    Set Location to 30 17
92194>    Set Size to 190 450
92195>    Set Icon to "SQLConnections1.ico"
92196>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
92197>
92197>    Object oCommandBarSystem is a cCJCommandBarSystem
92199>        Set pbTimerUpdate to True
92200>        Set pbShowTextBelowIcons to True
92201>            Set pbAutoResizeIcons to True
92202>            Set pbLargeIcons to True
92203>
92203>        Procedure OnCreateCommandBars
92206>            Handle hoOptions
92206>            Integer iSize
92206>
92206>            Send DoChangeToolTipFormat
92207>
92207>            Get OptionsObject to hoOptions
92208>            Move 32 to iSize
92209>            Send ComSetIconSize of hoOptions False iSize iSize  // Set icon size for Toolbar buttons.
92210>            Forward Send OnCreateCommandBars
92212>        End_Procedure
92213>
92213>        Procedure DoChangeToolTipFormat
92216>            Variant vToolTip
92216>            Handle  hoObject
92216>            Integer eTheme iToolTipStyle
92216>            Boolean bIsBalloonStyleSupported
92216>
92216>            Get ComToolTipContext to vTooltip
92217>            Get Create (RefClass(cCJToolTipContext)) to hoObject
92218>            Set pvComObject of hoObject to vTooltip
92219>            Move xtpToolTipStandard to iToolTipStyle
92220>            If (iToolTipStyle = -1) Begin
92222>                Get peVisualTheme to eTheme
92223>                Set ComStyle of hoObject to eTheme
92224>            End
92224>            Else Begin
92225>                // Baloon tooltip style requires IE 5.0 or later, so check if installed.
92225>                // The ComShowTitleAndDescription also requires IE 5.0.
92225>                Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
92226>                If (bIsBalloonStyleSupported = False) Begin
92228>                    // If not supported we cannot show baloon tooltip; use standard style instead.
92228>                    If (iToolTipStyle = xtpToolTipBalloon) Begin
92230>                        Move xtpToolTipStandard to iToolTipStyle
92231>                    End
92231>                End
92231>                Set ComStyle of hoObject to iToolTipStyle
92232>                If (bIsBalloonStyleSupported = True) Begin
92234>                    Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
92235>                End
92235>            End
92235>            Set  ComShowOfficeBorder        of hoObject to True
92236>            Set  ComShowShadow              of hoObject to True
92237>            // Set the max width for a tooltip. 250 just seems to be a good
92237>            // compromise. After 250 pixels the text will wrap to the next line automatically.
92237>            Set  ComMaxTipWidth             of hoObject to 250 // In pixels
92238>            Send Destroy of hoObject
92239>            If (phoStatusBar(ghoCommandBars)) Begin
92241>                Send DoChangeToolTipFormat of (phoStatusBar(Self))
92242>            End
92242>
92242>        End_Procedure
92243>
92243>        Object oOpen_Toolbar is a cCJToolbar     
92245>
92245>            Object oOpen_MenuItem is a cCJMenuItem
92247>                Set psTooltip to "&Open"
92248>                Set psDescription to "Open connection ini-file (Ctrl+O)"
92249>                Set psImage to "ActionOpen1.ico"
92250>                Set pbActiveUpdate to True
92251>                Procedure OnExecute Variant vCommandBarControl
92254>                    Forward Send OnExecute vCommandBarControl
92256>                    Send ActivateOpenDialog of (phoMainView(ghoApplication))
92257>                End_Procedure
92258>            End_Object
92259>
92259>            Object oRefreshMenuItem is a cCJMenuItem
92261>                Set psTooltip to "&Refresh"
92262>                Set psDescription to "Refresh grid - re-read values from ini-file (Alt+R)"
92263>                Set psImage to "ActionRefresh1.ico"
92264>                Set pbActiveUpdate to True
92265>               
92265>                Procedure OnExecute Variant vCommandBarControl
92268>                    Forward Send OnExecute vCommandBarControl
92270>                    Send RefreshIniFile of (phoMainView(ghoApplication))
92271>                End_Procedure
92272>
92272>                Function IsEnabled Returns Boolean
92275>                    Boolean bSave
92275>                    Get Should_Save of (oSQLConnections_grd(phoMainView(ghoApplication))) to bSave
92276>                    Function_Return (bSave = True)
92277>                End_Function
92278>                
92278>            End_Object
92279>
92279>        End_Object
92280>
92280>        Object oEdit_Toolbar is a cCJToolbar     
92282>        
92282>            Object oAddMenuItem is a cCJMenuItem
92284>                Set psTooltip to "&Add"
92285>                Set psDescription to "Add new connection (Alt+A)"
92286>                Set psImage to "ActionAdd1.ico"
92287>                Set pbActiveUpdate to True
92288>                Procedure OnExecute Variant vCommandBarControl
92291>                    Forward Send OnExecute vCommandBarControl
92293>                    Send AddItem of (phoMainView(ghoApplication))
92294>                End_Procedure
92295>            End_Object
92296>
92296>            Object oEditMenuItem is a cCJMenuItem
92298>                Set psTooltip to "&Edit"
92299>                Set psDescription to "Edit selected connection (Alt+E)"
92300>                Set psImage to "ActionEdit1.ico"
92301>                Set pbActiveUpdate to True
92302>
92302>                Procedure OnExecute Variant vCommandBarControl
92305>                    Forward Send OnExecute vCommandBarControl
92307>                    Send EditItem of (phoMainView(ghoApplication))
92308>                End_Procedure
92309>
92309>                Function IsEnabled Returns Boolean
92312>                    Handle ho              
92312>                    Boolean bRecord
92312>                    Move (oSQLConnections_grd(phoMainView(ghoApplication))) to ho
92313>                    Send ChangeHeaderText of ho
92314>                    Get HasRecord of ho to bRecord
92315>                    Function_Return (bRecord = True)
92316>                End_Function
92317>
92317>            End_Object
92318>
92318>            Object oSaveMenuItem is a cCJMenuItem
92320>                Set psTooltip to "Save"
92321>                Set psDescription to "Save changes (Ctrl+S)"
92322>                Set psImage to "ActionSave1.ico"
92323>                Set pbActiveUpdate to True
92324>                Set peControlType to xtpControlSplitButtonPopup
92325>
92325>                Procedure OnExecute Variant vCommandBarControl
92328>                    Forward Send OnExecute vCommandBarControl
92330>                    Send SaveIniFile of (phoMainView(ghoApplication))
92331>                End_Procedure
92332>
92332>                Function IsEnabled Returns Boolean
92335>                    Boolean bSave
92335>                    Get Should_Save of (oSQLConnections_grd(phoMainView(ghoApplication))) to bSave
92336>                    Function_Return (bSave = True)
92337>                End_Function
92338>
92338>                Object oSaveAsMenuItem is a cCJMenuItem
92340>                    Set psTooltip to "Save As"
92341>                    Set psDescription to "Save configuration file as..."  
92342>                    Set psImage to "ActionSaveAs1.ico"
92343>                    
92343>                    Procedure OnExecute Variant vCommandBarControl  
92346>                        String sPath sIniFileName sFileName
92346>
92346>                        Forward Send OnExecute vCommandBarControl
92348>                        
92348>                        Get psIniFilePath of ghoSQLConnectionHandler to sPath
92349>                        Get psIniFileName of ghoSQLConnectionHandler to sIniFileName
92350>                        Get vSelectSaveFile ".int" "Please enter a file name to save to" sPath sIniFileName to sFileName
92351>                        If (sFileName <> "") Begin
92353>                            Get ParseFolderName sFileName to sPath
92354>                            Get ParseFileName   sFileName to sIniFileName
92355>                            Set psIniFilePath of ghoSQLConnectionHandler to sPath
92356>                            Set psIniFileName of ghoSQLConnectionHandler to sIniFileName
92357>                            Send SaveIniFile  of (phoMainView(ghoApplication))
92358>                        End
92358>                    End_Procedure
92359>
92359>                End_Object   
92360>                
92360>            End_Object
92361>
92361>            Object oClearMenuItem is a cCJMenuItem 
92363>                Set psTooltip to "Clear All"
92364>                Set psDescription to "Clear ini-file (Ctrl+F5)"
92365>                Set psImage to "ActionClear1.ico"
92366>                Set pbActiveUpdate to True
92367>                
92367>                Procedure OnExecute Variant vCommandBarControl
92370>                    Forward Send OnExecute vCommandBarControl   
92372>                    Send ClearIniFile of (phoMainView(ghoApplication))
92373>                End_Procedure   
92374>                
92374>                Function IsEnabled Returns Boolean
92377>                    Handle ho              
92377>                    Boolean bRecord
92377>                    Move (oSQLConnections_grd(phoMainView(ghoApplication))) to ho
92378>                    Send ChangeHeaderText of ho
92379>                    Get HasRecord of ho to bRecord
92380>                    Function_Return (bRecord = True)
92381>                End_Function
92382>
92382>            End_Object
92383>    
92383>            Object oDeleteMenuItem is a cCJMenuItem
92385>                Set psTooltip to "Delete"
92386>                Set psDescription to "Delete selected connection (Alt+D)"
92387>                Set psImage to "ActionDelete1.ico"
92388>                Set pbActiveUpdate to True
92389>
92389>                Procedure OnExecute Variant vCommandBarControl
92392>                    Forward Send OnExecute vCommandBarControl
92394>                    Send DeleteItem of (phoMainView(ghoApplication))
92395>                End_Procedure   
92396>                
92396>                Function IsEnabled Returns Boolean
92399>                    Handle ho              
92399>                    Boolean bRecord
92399>                    Move (oSQLConnections_grd(phoMainView(ghoApplication))) to ho
92400>                    Send ChangeHeaderText of ho
92401>                    Get HasRecord of ho to bRecord
92402>                    Function_Return (bRecord = True)
92403>                End_Function
92404>
92404>            End_Object
92405>
92405>        End_Object      
92406>        
92406>        Object oExit_Toolbar is a cCJToolbar
92408>            Set peStretched to stStretchShared
92409>
92409>            Object oAddToStudioMenuItem is a cCJMenuItem
92411>                Set psTooltip to "Add to Studio"
92412>                Set psDescription to "Add program to the Studio's toolbar menu"
92413>                Set psImage to "ActionAddStudio1.ico"
92414>                
92414>                Procedure OnExecute Variant vCommandBarControl
92417>                    Forward Send OnExecute vCommandBarControl
92419>                    Send Popup of (oAddToStudio_dg(Client_Id(phoMainPanel(ghoApplication))))
92420>                End_Procedure
92421>            
92421>            End_Object
92422>
92422>            Object oAbout_MenuItem is a cCJMenuItem
92424>                Set psTooltip to C_$About
92425>                Set psDescription to "Info about the program..."
92426>                Set psImage to "ActionAbout1.ico"
92427>        
92427>                Procedure OnExecute Variant vCommandBarControl
92430>                    Send ChangeStatusRowText of (phoMainView(ghoApplication)) ""
92431>                    Send Activate_About of (Client_Id(phoMainPanel(ghoApplication)))
92432>                End_Procedure
92433>        
92433>            End_Object     
92434>            
92434>            Object oHelpMenuItem is a cCJHelpMenuItem
92436>                Set peControlType to xtpControlSplitButtonPopup
92437>                Set psToolTip to C_$Help
92438>                Set psDescription to "Local HTML Help"
92439>                Set psImage to "ActionHelp1.ico"
92440>
92440>                Procedure OnExecute Variant vCommandBarControl
92443>                    Send ShowProgramHelp
92444>                End_Procedure
92445>
92445>                Object oHelpMenuItemLocal is a cCJMenuItem
92447>                    Set psToolTip to C_$Help
92448>                    Set psCaption to "Local HTML Help"
92449>                    Set psDescription to "Local HTML Help"
92450>                    Set psImage to "ActionHelp1.ico"
92451>                    Procedure OnExecute Variant vCommandBarControl
92454>                        Send ShowProgramHelp
92455>                    End_Procedure
92456>                End_Object
92457>
92457>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
92459>                    Set psToolTip to C_$Help
92460>                    Set psCaption to "Online HTML Help"
92461>                    Set psDescription to "Online HTML Help"
92462>                    Set psImage to "ActionHelpInternet1.ico"
92463>                    Procedure OnExecute Variant vCommandBarControl
92466>                        Runprogram Shell Background "https://www.rdctools.com/HTMLHelpDUF/DUFSQLConnectionsTool.html"
92467>                    End_Procedure
92468>                End_Object
92469>
92469>                Object oCheckforUpdatesMenuItem is a cCJMenuItem
92471>                    Set psToolTip to "Updates"
92472>                    Set psCaption to "Check for Updates..."
92473>                    Set psDescription to "Check for Updates..."
92474>                    Set psImage to "InternetUpdate1.ico"
92475>                    Set pbControlBeginGroup to True
92476>                    
92476>                    Procedure OnExecute Variant vCommandBarControl
92479>                        String sPath sUpdateProgram sParam
92479>                        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
92480>                        Get vFolderFormat sPath to sPath
92481>                        Move "updater.exe" to sUpdateProgram
92482>                        Move "/checknow"   to sParam
92483>                        Runprogram Shell Wait ('"' + sPath + sUpdateProgram + '"') sParam
92484>                    End_Procedure
92485>                
92485>                End_Object
92486>                
92486>            End_Object
92487>
92487>            Object oExit_MenuItem is a cCJExitMenuItem
92489>                Set psToolTip to "Exit"
92490>                Set psDescription to "Exit application (Alt+F4)"   
92491>                Set psImage to "ActionExit1.ico"
92492>            End_Object
92493>
92493>        End_Object
92494>        
92494>        Object oStatusBar is a cCJStatusBar
92496>
92496>            Object oStatusPane1 is a cCJStatusBarPane
92498>                Set pbStyleStretch to True
92499>            End_Object
92500>
92500>            Object oStatusPane2 is a cCJStatusBarPane
92502>                Set phoViewPane to Self
92503>                Set pbStyleStretch to True
92504>                Set piTextColor to clRed
92505>            End_Object
92506>
92506>        End_Object
92507>
92507>    End_Object
92508>
92508>    Object oClientArea is a ClientArea
92510>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout20\StdAbout.pkg)
92510>>>//************************************************************************
92510>>>// Confidential Trade Secret.
92510>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
92510>>>// as an unpublished work.  All rights reserved.
92510>>>// DataFlex is a registered trademark of Data Access Corporation.
92510>>>//
92510>>>//************************************************************************
92510>>>//************************************************************************
92510>>>//
92510>>>// $File name  : StdAbout.pkg
92510>>>// $File title : Standard about object package for VDF
92510>>>// Notice      :
92510>>>// $Author(s)  : John Tuohy
92510>>>//
92510>>>// $Rev History
92510>>>//
92510>>>// JT 06/27/97   File created
92510>>>//************************************************************************
92510>>>
92510>>>// This provides a quick and simple way to create an about package for a program.
92510>>>// You need to create a message inside you client area called Activate_About.
92510>>>// Within this message you should send the message DoAbout passing needed
92510>>>// string information.
92510>>>//
92510>>>//       Procedure Activate_About
92510>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
92510>>>//       End_Procedure
92510>>>//    where: sTitle =     Name of application. If none provided, uses caption
92510>>>//                        bar title
92510>>>//           sVersion   = Version Line. If none provided, will be blank
92510>>>//           sCopyRight = Copyright Line. If none provided, will be blank
92510>>>//           sAuthor    = Author name, blank if none provided
92510>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
92510>>>//                        is used.
92510>>>// It is expected that you will place this in your own object package. For
92510>>>// example an order about package may look like this:
92510>>>//
92510>>>//   // OrderAbout.pkg
92510>>>//   Use StdAbout.pkg
92510>>>//   Procedure Activate_About
92510>>>//      String sTitle sCopyright sVersion sAuthor
92510>>>//      Move "My Order Entry System" to sTitle
92510>>>//      Move "Version 2.1" to sVersion
92510>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
92510>>>//      Move "John Smith"  to sAuthor
92510>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
92510>>>//   end_procedure
92510>>>//   // end of file.
92510>>>
92510>>>Use DfAbout.pkg
92510>>>
92510>>>// *************************************************************************
92510>>>//  Public message. This is the default message. It is expected that you will
92510>>>//   create your own message to override this
92510>>>// *************************************************************************
92510>>>
92510>>>Procedure Activate_About
92513>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
92514>>>End_Procedure
92515>>>
92515>>>// *************************************************************************
92515>>>//  Public message. It is expected that you will send this message (most
92515>>>//  likely from Activate_About. This creates an about object, activates it
92515>>>//  and destroys it when done. It is not exepected that you will augment this.
92515>>>// *************************************************************************
92515>>>// Sample usage:
92515>>>//   The first two params will automatically be filled from the application settings if not provided.
92515>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
92515>>>
92515>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
92518>>>    Integer hoObj hoMain iArgs
92518>>>    String sValue
92518>>>
92518>>>    // Create object
92518>>>    Object About is an AboutDialog
92520>>>    // Uncomment these two lines if you would like to have a resizable About object.
92520>>>    //            Set Border_Style to Border_Thick
92520>>>    //            Set peAnchors to anAll
92520>>>
92520>>>    // Add checking for the number of arguments passed to avoid runtime errors
92520>>>    // if one of them is not passed. This makes the interface
92520>>>    // more flexible.
92520>>>        Move num_arguments to iArgs
92521>>>
92521>>>        // If no title is passed use the label of the main panel (if a main panel exists).
92521>>>        If (iArgs > 0 and sTitle = "") Begin
92523>>>            Get Main_Window of Desktop to hoMain
92524>>>            If hoMain Begin
92526>>>                Get Label of hoMain to sValue
92527>>>            End
92527>>>>
92527>>>        End
92527>>>>
92527>>>        Else If (iArgs > 0 and sTitle <> "") Begin
92530>>>            Move sTitle to sValue
92531>>>        End
92531>>>>
92531>>>        Else If (iArgs = 0) Begin
92534>>>            Get Main_Window of Desktop to hoMain
92535>>>            If hoMain Begin
92537>>>                Get Label of hoMain to sValue
92538>>>            End
92538>>>>
92538>>>        End
92538>>>>
92538>>>
92538>>>        If (sValue <> "") Begin
92540>>>            Send Add_LineLn sValue
92541>>>        End
92541>>>>
92541>>>        Move "" to sValue
92542>>>
92542>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
92542>>>        // For this to work the Project Properties Version must have been set in the Studio.
92542>>>        If (iArgs < 2) Begin
92544>>>            Move "" to sValue
92545>>>        End
92545>>>>
92545>>>        Else Begin
92546>>>            Move sVersion to sValue
92547>>>        End
92547>>>>
92547>>>        Set Version to sValue
92548>>>
92548>>>        If (iArgs > 2 and sCopyRight <> "") Begin
92550>>>            Send Add_LineLn sCopyRight
92551>>>        End
92551>>>>
92551>>>
92551>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
92551>>>        // else we do.
92551>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
92553>>>            Send Add_Line sAuthor
92554>>>        End
92554>>>>
92554>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
92557>>>            Send Add_LineLn sAuthor
92558>>>        End
92558>>>>
92558>>>
92558>>>        // Square bitmaps of 80x80 works best
92558>>>        If (iArgs > 4 and sBitmap <> "") Begin
92560>>>            Set Logo to sBitMap
92561>>>        End
92561>>>>
92561>>>
92561>>>        // Here starts handling of the five optional params:
92561>>>        If (iArgs = 6 and sParam6  <> "") Begin
92563>>>            Send Add_Line sParam6
92564>>>        End
92564>>>>
92564>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
92567>>>            Send Add_LineLn sParam6
92568>>>        End
92568>>>>
92568>>>
92568>>>        If (iArgs = 7 and sParam7  <> "") Begin
92570>>>            Send Add_Line sParam7
92571>>>        End
92571>>>>
92571>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
92574>>>            Send Add_LineLn sParam7
92575>>>        End
92575>>>>
92575>>>
92575>>>        If (iArgs = 8 and sParam8  <> "") Begin
92577>>>            Send Add_Line sParam8
92578>>>        End
92578>>>>
92578>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
92581>>>            Send Add_LineLn sParam8
92582>>>        End
92582>>>>
92582>>>
92582>>>        If (iArgs = 9 and sParam9  <> "") Begin
92584>>>            Send Add_Line sParam9
92585>>>        End
92585>>>>
92585>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
92588>>>            Send Add_LineLn sParam9
92589>>>        End
92589>>>>
92589>>>
92589>>>        If (iArgs = 10 and sParam10 <> "") Begin
92591>>>            Send Add_Line sParam10
92592>>>        End
92592>>>>
92592>>>
92592>>>        Move Self to hoObj
92593>>>    End_Object
92594>>>
92594>>>    Send Popup   of hoObj // Popup the about object
92595>>>    Send Destroy of hoObj // When done, it will be destroyed
92596>>>End_Procedure
92597>        Use ManageSQLConnections.vw
Including file: ManageSQLConnections.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ManageSQLConnections.vw)
92597>>>Use DFClient.pkg
92597>>>Use cCJCommandBarSystem.pkg
92597>>>Use cCJGrid.pkg
92597>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJGridColumnRowIndicator.pkg)
92597>>>>>Use cCJGridColumn.pkg
92597>>>>>
92597>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
92598>>>>>    
92598>>>>>    Procedure Construct_Object
92600>>>>>        Forward Send Construct_Object
92602>>>>>        
92602>>>>>        Property Integer piImage 0
92603>>>>>        
92603>>>>>        Set psCaption to ""
92604>>>>>        Set piWidth to 20
92605>>>>>        Set pbResizable to False
92606>>>>>        Set pbEditable to False
92607>>>>>        Set pbFocusable to False
92608>>>>>        Set pbAllowDrag to False
92609>>>>>        Set psToolTip to "Row Indicator"
92610>>>>>    End_Procedure
92611>>>>>    
92611>>>>>    Procedure OnCreateColumn
92613>>>>>        Integer iImage
92613>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
92615>>>>>        Set piImage to iImage
92616>>>>>    End_Procedure
92617>>>>>    
92617>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
92619>>>>>        Integer iImage iFocusedRow
92619>>>>>        Handle hoDataSource
92619>>>>>        
92619>>>>>        Get phoDataSource to hoDataSource
92620>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
92621>>>>>        Move -1 to iImage
92622>>>>>        If (iRow = iFocusedRow) Begin
92624>>>>>            Get piImage to iImage
92625>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
92626>>>>>        End
92626>>>>>>
92626>>>>>    End_Procedure
92627>>>>>    
92627>>>>>End_Class
92628>>>Use cCJGridColumn.pkg
92628>>>Use cSQLConnectionButton.pkg
Including file: cSQLConnectionButton.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionButton.pkg)
92628>>>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCButtonDPI.pkg)
92628>>>>>>>//****************************************************************************
92628>>>>>>>// $Module type: Package
92628>>>>>>>// $Module name: cRDCButtonDPI.pkg
92628>>>>>>>//
92628>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
92628>>>>>>>// Copyright (c) 2013 RDC Tools International
92628>>>>>>>// E-mail      : support@rdctools.com
92628>>>>>>>// Web-site    : http://www.rdctools.com
92628>>>>>>>//
92628>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
92628>>>>>>>//
92628>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
92628>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
92628>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
92628>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
92628>>>>>>>// in the help folder for more details.
92628>>>>>>>//
92628>>>>>>>//****************************************************************************
92628>>>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCButton.pkg)
92628>>>>>>>>>//****************************************************************************
92628>>>>>>>>>// $Module type: Package
92628>>>>>>>>>// $Module name: cRDCButton.pkg
92628>>>>>>>>>//
92628>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
92628>>>>>>>>>// Copyright (c) 2013 RDC Tools International
92628>>>>>>>>>// E-mail      : support@rdctools.com
92628>>>>>>>>>// Web-site    : http://www.rdctools.com
92628>>>>>>>>>//
92628>>>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
92628>>>>>>>>>//
92628>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
92628>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
92628>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
92628>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
92628>>>>>>>>>// in the help folder for more details.
92628>>>>>>>>>//
92628>>>>>>>>>//****************************************************************************
92628>>>>>>>>>Use Windows.pkg
92628>>>>>>>>>Use Enclient.pkg
92628>>>>>>>>>Use errornum.inc
92628>>>>>>>>>
92628>>>>>>>>>Class cButtonIdleHandler is a cIdleHandler
92629>>>>>>>>>    Procedure Construct_Object
92631>>>>>>>>>        Forward Send Construct_Object
92633>>>>>>>>>
92633>>>>>>>>>    End_Procedure
92634>>>>>>>>>
92634>>>>>>>>>    Procedure OnIdle
92636>>>>>>>>>        Delegate Send DoUpdate
92638>>>>>>>>>    End_Procedure
92639>>>>>>>>>
92639>>>>>>>>>End_Class
92640>>>>>>>>>
92640>>>>>>>>>Class cRDCButton is a Button
92641>>>>>>>>>
92641>>>>>>>>>    Procedure Construct_Object
92643>>>>>>>>>        Forward Send Construct_Object
92645>>>>>>>>>
92645>>>>>>>>>        Property Boolean pbAutoEnable True
92646>>>>>>>>>
92646>>>>>>>>>        Property Boolean pbEnabled True
92647>>>>>>>>>
92647>>>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
92648>>>>>>>>>
92648>>>>>>>>>        On_Key kCancel Send CancelIfPopupObject
92649>>>>>>>>>    End_Procedure
92650>>>>>>>>>
92650>>>>>>>>>    Procedure CancelIfPopupObject
92652>>>>>>>>>        Boolean bIsInPopupObject
92652>>>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
92654>>>>>>>>>        If (bIsInPopupObject = True) Begin
92656>>>>>>>>>            Send Close_Panel
92657>>>>>>>>>        End
92657>>>>>>>>>>
92657>>>>>>>>>    End_Procedure
92658>>>>>>>>>
92658>>>>>>>>>    Procedure End_Construct_Object
92660>>>>>>>>>        String sTooltip sStatus_Help
92660>>>>>>>>>
92660>>>>>>>>>        Forward Send End_Construct_Object
92662>>>>>>>>>
92662>>>>>>>>>        Get psToolTip   to sTooltip
92663>>>>>>>>>        Get Status_Help to sStatus_Help
92664>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
92666>>>>>>>>>            Set psToolTip to sStatus_Help
92667>>>>>>>>>        End
92667>>>>>>>>>>
92667>>>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
92669>>>>>>>>>            Set Status_Help to sToolTip
92670>>>>>>>>>        End
92670>>>>>>>>>>
92670>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
92671>>>>>>>>>    End_Procedure
92672>>>>>>>>>
92672>>>>>>>>>    Procedure DoUpdate
92674>>>>>>>>>        If (pbAutoEnable(Self) = False) Begin
92676>>>>>>>>>            Procedure_Return
92677>>>>>>>>>        End
92677>>>>>>>>>>
92677>>>>>>>>>        Set Enabled_State to (IsEnabled(Self))
92678>>>>>>>>>    End_Procedure
92679>>>>>>>>>
92679>>>>>>>>>    Function IsEnabled Returns Boolean
92681>>>>>>>>>        Boolean bEnabled
92681>>>>>>>>>        Get pbEnabled to bEnabled
92682>>>>>>>>>        Function_Return bEnabled
92683>>>>>>>>>    End_Function
92684>>>>>>>>>
92684>>>>>>>>>    // Enable the idle handler timer when the button is activated
92684>>>>>>>>>    Procedure Activating
92686>>>>>>>>>        Forward Send Activating
92688>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
92689>>>>>>>>>    End_Procedure
92690>>>>>>>>>
92690>>>>>>>>>    // Disable the idle handler when the button is deactivated
92690>>>>>>>>>    Procedure Deactivating
92692>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
92693>>>>>>>>>        Forward Send Deactivating
92695>>>>>>>>>    End_Procedure
92696>>>>>>>>>
92696>>>>>>>>>End_Class
92697>>>>>>>
92697>>>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
92697>>>>>>>Class cRDCButtonDPI is a cRDCButton
92698>>>>>>>    Procedure Construct_Object
92700>>>>>>>        Integer iIconSize
92700>>>>>>>        Forward Send Construct_Object
92702>>>>>>>        Set piImageMarginLeft to 10
92703>>>>>>>    End_Procedure
92704>>>>>>>
92704>>>>>>>    // Returns: DPI setting as an integer.
92704>>>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
92704>>>>>>>    //                      iDPI=120 is "Medium setting" 125%
92704>>>>>>>    //                      iDPI= 144 is "Large setting" 150%
92704>>>>>>>    Function GetCurrentDPI Returns Integer
92706>>>>>>>        Handle hDC
92706>>>>>>>        Integer iPixelsX
92706>>>>>>>        Move (GetDC(0)) to hDC
92707>>>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
92708>>>>>>>        Move (ReleaseDC(0, hDC)) to hDC
92709>>>>>>>        Function_Return iPixelsX
92710>>>>>>>    End_Function
92711>>>>>>>
92711>>>>>>>    Function GetCorrectIconSize Returns Integer
92713>>>>>>>        Integer iPixelsX iIndex iSize
92713>>>>>>>        Integer[] iaSizes
92714>>>>>>>
92714>>>>>>>        Move 16 to iaSizes[0]
92715>>>>>>>        Move 24 to iaSizes[1]
92716>>>>>>>        Move 32 to iaSizes[2]
92717>>>>>>>        Move 48 to iaSizes[3]
92718>>>>>>>        Move 64 to iaSizes[4]
92719>>>>>>>
92719>>>>>>>        Get piImageSize to iSize  // the "100%" size
92720>>>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
92721>>>>>>>        Move (0 max iIndex) to iIndex
92722>>>>>>>        Get GetCurrentDPI to iPixelsX
92723>>>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
92723>>>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
92723>>>>>>>        // will increment iIndex as many times as we need here.
92723>>>>>>>        Case Begin
92723>>>>>>>            Case (iPixelsX > 144)
92725>>>>>>>                Increment iIndex
92726>>>>>>>            Case (iPixelsX = 144)
92729>>>>>>>                Increment iIndex
92730>>>>>>>            Case (iPixelsX = 120)
92733>>>>>>>                Increment iIndex
92734>>>>>>>        Case End
92734>>>>>>>        Move (iIndex min 4) to iIndex
92735>>>>>>>        Function_Return iaSizes[iIndex]
92736>>>>>>>    End_Function
92737>>>>>>>
92737>>>>>>>    Procedure Set psToolTip String sToolTip
92739>>>>>>>        String sStatusHelp
92739>>>>>>>
92739>>>>>>>        Get Status_Help to sStatusHelp
92740>>>>>>>        If (sStatusHelp = "") Begin
92742>>>>>>>            Set Status_Help to sToolTip
92743>>>>>>>        End
92743>>>>>>>>
92743>>>>>>>
92743>>>>>>>        Forward Set psToolTip to sToolTip
92745>>>>>>>    End_Procedure
92746>>>>>>>
92746>>>>>>>End_Class
92747>>>>>
92747>>>>>// New button class so we constantly can display the ini-filename in the status_help area:
92747>>>>>Class cSQLConnectionButton is a cRDCButtonDPI
92748>>>>>    Procedure Construct_Object
92750>>>>>        Forward Send Construct_Object
92752>>>>>    End_Procedure
92753>>>>>
92753>>>>>    Procedure End_Construct_Object
92755>>>>>        String sLabel sImage
92755>>>>>        Forward Send End_Construct_Object
92757>>>>>        Get psImage to sImage
92758>>>>>        If (sImage = "") Begin
92760>>>>>            Get Label to sLabel
92761>>>>>            Move (Replace("&", sLabel, "")) to sLabel
92762>>>>>            Move (Replace("...", sLabel, "")) to sLabel
92763>>>>>            Set psImage to ("Action" + sLabel + "1.ico")
92764>>>>>        End
92764>>>>>>
92764>>>>>    End_Procedure
92765>>>>>
92765>>>>>    Function Status_Help String Item# Returns String
92767>>>>>        String sRetval
92767>>>>>        Get IniFileName to sRetval
92768>>>>>        Function_Return sRetval
92769>>>>>    End_Function
92770>>>>>
92770>>>>>End_Class
92771>>>
92771>>>Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
92771>>>>>Use Windows.pkg
92771>>>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJGridPromptList.pkg)
92771>>>>>>>Use Windows.pkg
92771>>>>>>>Use cCJGrid.pkg
92771>>>>>>>Use umPromptRelational.pkg
92771>>>>>>>
92771>>>>>>>Class cCJGridPromptList is a cCJGrid
92772>>>>>>>    
92772>>>>>>>    Procedure Construct_Object
92774>>>>>>>        Forward Send Construct_Object
92776>>>>>>>        
92776>>>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
92777>>>>>>>        Property Boolean Private_pbAutoOrdering True
92778>>>>>>>        Property Boolean pbAutoSearch True  // pops up search window
92779>>>>>>>        Property Integer peUpdateMode umPromptValue
92780>>>>>>>        Property Integer piUpdateColumn 0
92781>>>>>>>        Property Integer piInitialColumn -1
92782>>>>>>>        Property String  psSeedValue ''
92783>>>>>>>        Property Handle phmPromptUpdateCallback 0
92784>>>>>>>        Property Integer phoInvokingObject
92785>>>>>>>        
92785>>>>>>>        Property Boolean pbStoredAutoSeed
92786>>>>>>>        Property Boolean pbStoredAutoOrdering
92787>>>>>>>        Property Boolean pbStoredAutoSearch
92788>>>>>>>        Property Integer peStoredUpdateMode
92789>>>>>>>        Property Integer piStoredUpdateColumn
92790>>>>>>>        Property Integer piStoredInitialColumn
92791>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
92792>>>>>>>        Property Boolean pbStoredSelectionEnable
92793>>>>>>>        Property Boolean pbStoredMultipleSelection
92794>>>>>>>        
92794>>>>>>>        // internally set by list
92794>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
92794>>>>>>>        Property Boolean pbCanceled
92795>>>>>>>        Property Integer[] pSelectedRows
92796>>>>>>>        
92796>>>>>>>        Property Boolean pbNeedsNewOrdering
92797>>>>>>>        Property Boolean pbRequestSearch
92798>>>>>>>        Property tGridKeyPair[] pSearchKeys
92799>>>>>>>        
92799>>>>>>>        // these properties makes a prompt list a prompt list
92799>>>>>>>        // and should not be changed.
92799>>>>>>>        Set pbEditOnKeyNavigation to False
92800>>>>>>>        Set pbEditOnClick to False
92801>>>>>>>        Set pbReadOnly to True
92802>>>>>>>        Set pbFocusSubItems to True
92803>>>>>>>        
92803>>>>>>>        // these could maybe be changed
92803>>>>>>>        Set pbShadeSortColumn to True
92804>>>>>>>        Set pbHeaderReorders to True
92805>>>>>>>        Set pbHeaderTogglesDirection to True
92806>>>>>>>        Set pbHeaderSelectsColumn to True
92807>>>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
92808>>>>>>>        Set piFocusCellBackColor to clNone
92809>>>>>>>        Set piFocusCellForeColor to clNone
92810>>>>>>>        Set piFocusCellRectangleColor to clBlack
92811>>>>>>>        Set pbUseFocusCellRectangle to False
92812>>>>>>>        Set pbSelectionEnable to True
92813>>>>>>>        
92813>>>>>>>        On_Key kEnter Send Ok
92814>>>>>>>        On_Key kCancel Send Cancel
92815>>>>>>>        
92815>>>>>>>    End_Procedure
92816>>>>>>>    
92816>>>>>>>    // reorder list automatically on column change
92816>>>>>>>    // this also set pbFocusSubItems which is required to make the two states work
92816>>>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
92818>>>>>>>        Set Private_pbAutoOrdering to bAutoOrder
92819>>>>>>>        Set pbFocusSubItems to bAutoOrder
92820>>>>>>>    End_Procedure
92821>>>>>>>    
92821>>>>>>>    Function pbAutoOrdering Returns Boolean
92823>>>>>>>        Boolean bAutoOrder
92823>>>>>>>        Get Private_pbAutoOrdering to bAutoOrder
92824>>>>>>>        Function_Return bAutoOrder
92825>>>>>>>    End_Function
92826>>>>>>>    
92826>>>>>>>    // augmented to handle auto-ordering and invoking the search popup list
92826>>>>>>>    Procedure OnIdle
92828>>>>>>>        Boolean bNeedsReorder bSearch bOldToggle
92828>>>>>>>        Handle hoCol
92828>>>>>>>        Integer iKy1 iKy2 iCol
92828>>>>>>>        
92828>>>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
92829>>>>>>>        If bNeedsReorder Begin
92831>>>>>>>            Get SelectedColumn to iCol
92832>>>>>>>            If (iCol<>-1) Begin
92834>>>>>>>                
92834>>>>>>>                Get pbHeaderTogglesDirection to bOldToggle
92835>>>>>>>                Set pbHeaderTogglesDirection to False
92836>>>>>>>                Send HeaderReorder iCol
92837>>>>>>>                Set pbHeaderTogglesDirection to bOldToggle
92838>>>>>>>                
92838>>>>>>>                Set pbNeedsNewOrdering to False
92839>>>>>>>            End
92839>>>>>>>>
92839>>>>>>>        End
92839>>>>>>>>
92839>>>>>>>        
92839>>>>>>>        Get pbRequestSearch to bSearch
92840>>>>>>>        If bSearch Begin
92842>>>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
92843>>>>>>>        End
92843>>>>>>>>
92843>>>>>>>        
92843>>>>>>>        Forward Send OnIdle
92845>>>>>>>    End_Procedure
92846>>>>>>>    
92846>>>>>>>    Procedure OnStoreDefaults
92848>>>>>>>        Integer iVal
92848>>>>>>>        Boolean bVal
92848>>>>>>>        
92848>>>>>>>        Get pbAutoSeed to bVal
92849>>>>>>>        Set pbStoredAutoSeed to bVal
92850>>>>>>>        
92850>>>>>>>        Get pbAutoOrdering to bVal
92851>>>>>>>        Set pbStoredAutoOrdering to bVal
92852>>>>>>>        
92852>>>>>>>        Get pbAutoSearch to bVal
92853>>>>>>>        Set pbStoredAutoSearch to bVal
92854>>>>>>>        
92854>>>>>>>        Get peUpdateMode to iVal
92855>>>>>>>        Set peStoredUpdateMode to iVal
92856>>>>>>>        
92856>>>>>>>        Get piUpdateColumn to iVal
92857>>>>>>>        Set piStoredUpdateColumn to iVal
92858>>>>>>>        
92858>>>>>>>        Get piInitialColumn to iVal
92859>>>>>>>        Set piStoredInitialColumn to iVal
92860>>>>>>>        
92860>>>>>>>        Get phmPromptUpdateCallback to iVal
92861>>>>>>>        Set phmStoredPromptUpdateCallback to iVal
92862>>>>>>>        
92862>>>>>>>        Get pbSelectionEnable to bVal
92863>>>>>>>        Set pbStoredSelectionEnable to bVal
92864>>>>>>>        
92864>>>>>>>        Get pbMultipleSelection to bVal
92865>>>>>>>        Set pbStoredMultipleSelection to bVal
92866>>>>>>>        
92866>>>>>>>    End_Procedure
92867>>>>>>>    
92867>>>>>>>    Procedure OnRestoreDefaults
92869>>>>>>>        Integer iVal
92869>>>>>>>        Boolean bVal
92869>>>>>>>        
92869>>>>>>>        Get pbStoredAutoSeed to bVal
92870>>>>>>>        Set pbAutoSeed to bVal
92871>>>>>>>        
92871>>>>>>>        Get pbStoredAutoOrdering to bVal
92872>>>>>>>        Set pbAutoOrdering to bVal
92873>>>>>>>        
92873>>>>>>>        Get pbStoredAutoSearch to bVal
92874>>>>>>>        Set pbAutoSearch to bVal
92875>>>>>>>        
92875>>>>>>>        Get peStoredUpdateMode to iVal
92876>>>>>>>        Set peUpdateMode to iVal
92877>>>>>>>        
92877>>>>>>>        Get piStoredInitialColumn to iVal
92878>>>>>>>        Set piInitialColumn to iVal
92879>>>>>>>        
92879>>>>>>>        Get phmStoredPromptUpdateCallback to iVal
92880>>>>>>>        Set phmPromptUpdateCallback to iVal
92881>>>>>>>        
92881>>>>>>>        Get pbStoredSelectionEnable to bVal
92882>>>>>>>        Set pbSelectionEnable to bVal
92883>>>>>>>        
92883>>>>>>>        Get pbStoredMultipleSelection to bVal
92884>>>>>>>        Set pbMultipleSelection to bVal
92885>>>>>>>        
92885>>>>>>>    End_Procedure
92886>>>>>>>    
92886>>>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
92886>>>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
92886>>>>>>>    // Suitable for augmentation
92886>>>>>>>    Procedure OnSeedData
92888>>>>>>>        Integer iUpdateColumn iSortColumn
92888>>>>>>>        Boolean bSeed bAuto
92888>>>>>>>        String sValue
92888>>>>>>>        Handle hoCol
92888>>>>>>>        
92888>>>>>>>        Get piUpdateColumn to iUpdateColumn
92889>>>>>>>        Get psSeedValue to sValue
92890>>>>>>>        Get pbAutoSeed to bSeed
92891>>>>>>>        Get piSortColumn to iSortColumn
92892>>>>>>>        Get pbAutoOrdering to bAuto
92893>>>>>>>        // if not yet sorted and this is auto ordering we will
92893>>>>>>>        // sort the data for the search column. We do this to make the
92893>>>>>>>        // column search GE logic work properly.
92893>>>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
92895>>>>>>>            Get ColumnObject iUpdateColumn to hoCol
92896>>>>>>>            Send SortGridByColumn hoCol False
92897>>>>>>>        End
92897>>>>>>>>
92897>>>>>>>        
92897>>>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
92899>>>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
92900>>>>>>>        End
92900>>>>>>>>
92900>>>>>>>        Else Begin
92901>>>>>>>            Send MovetoFirstRow
92902>>>>>>>        End
92902>>>>>>>>
92902>>>>>>>        
92902>>>>>>>    End_Procedure
92903>>>>>>>    
92903>>>>>>>    Procedure OnMoveValueOutByValue
92905>>>>>>>        String sValue
92905>>>>>>>        Handle hoInvokingObject hoCol  hoDataSource
92905>>>>>>>        Integer iRow iCol
92905>>>>>>>        Integer[] SelRowsIndexes
92906>>>>>>>        
92906>>>>>>>        Get phoInvokingObject to hoInvokingObject
92907>>>>>>>        Get pSelectedRows to SelRowsIndexes
92908>>>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
92910>>>>>>>            Get piUpdateColumn to iCol
92911>>>>>>>            Get ColumnObject iCol to hoCol
92912>>>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
92913>>>>>>>            Set Value of hoInvokingObject to sValue
92914>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
92915>>>>>>>        End
92915>>>>>>>>
92915>>>>>>>    End_Procedure
92916>>>>>>>    
92916>>>>>>>    Procedure OnMoveValueOutByCustom
92918>>>>>>>    End_Procedure
92919>>>>>>>    
92919>>>>>>>    // augment to popup a search window when allowed
92919>>>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
92921>>>>>>>        Boolean bSubFocus bAutoSearch bChar
92921>>>>>>>        Integer iVal
92921>>>>>>>        
92921>>>>>>>        Get pbFocusSubItems to bSubFocus
92922>>>>>>>        Get pbAutoSearch to bAutoSearch
92923>>>>>>>        Forward Send OnComKeyDown llKeyCode llShift
92925>>>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
92927>>>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
92929>>>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
92930>>>>>>>                Move (iVal<>0) to bChar
92931>>>>>>>            End
92931>>>>>>>>
92931>>>>>>>            If bChar Begin
92933>>>>>>>                // this can get called multiple times before a search dialog pops up
92933>>>>>>>                Send AddToSearchKeys llKeyCode llShift
92934>>>>>>>            End
92934>>>>>>>>
92934>>>>>>>        End
92934>>>>>>>>
92934>>>>>>>    End_Procedure
92935>>>>>>>    
92935>>>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
92937>>>>>>>        Boolean bAutoSearch
92937>>>>>>>        Integer iKeyCode iShiftCode
92937>>>>>>>        Get pbAutoSearch to bAutoSearch
92938>>>>>>>        If bAutoSearch Begin
92940>>>>>>>            // this can get called multiple times before a search dialog pops up
92940>>>>>>>            Get piLastKey to iKeyCode
92941>>>>>>>            Get piLastKey2 to iShiftCode
92942>>>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
92943>>>>>>>        End
92943>>>>>>>>
92943>>>>>>>        Move True to llCancel
92944>>>>>>>    End_Procedure
92945>>>>>>>    
92945>>>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
92947>>>>>>>        Send ClearSearchRequest // kill any deferred search popup
92948>>>>>>>        Forward Send OnComRowDblClick llRow llItem
92950>>>>>>>    End_Procedure
92951>>>>>>>    
92951>>>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
92953>>>>>>>        Send Ok
92954>>>>>>>    End_Procedure
92955>>>>>>>    
92955>>>>>>>    
92955>>>>>>>    // we don't want a menu for prompt lists
92955>>>>>>>    Function CreateContextMenu Returns Handle
92957>>>>>>>        Function_Return 0
92958>>>>>>>    End_Function
92959>>>>>>>    
92959>>>>>>>    // if we use auto-ordering, change the order when the column changes
92959>>>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
92961>>>>>>>        Boolean bAutoOrder
92961>>>>>>>        Forward Send ColumnChanged iOld iNew
92963>>>>>>>        Get pbAutoOrdering to bAutoOrder
92964>>>>>>>        If bAutoOrder Begin
92966>>>>>>>            // will be reordered in idle event
92966>>>>>>>            Set pbNeedsNewOrdering to True
92967>>>>>>>        End
92967>>>>>>>>
92967>>>>>>>    End_Procedure
92968>>>>>>>    
92968>>>>>>>    
92968>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
92970>>>>>>>        Integer eMode
92970>>>>>>>        Integer[] SelRowsIndexes
92971>>>>>>>        Set pbCanceled to True // assume cancel unless changed
92972>>>>>>>        Set pSelectedRows to SelRowsIndexes // empty
92973>>>>>>>        Get peUpdateMode to eMode
92974>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
92976>>>>>>>            Send OnStoreDefaults
92977>>>>>>>        End
92977>>>>>>>>
92977>>>>>>>        Send InitializePromptList
92978>>>>>>>        Forward Send Add_Focus hoParent
92980>>>>>>>        Send LoadData
92981>>>>>>>        Set psSeedValue to ""
92982>>>>>>>    End_Procedure
92983>>>>>>>    
92983>>>>>>>    // called before the list is activated.
92983>>>>>>>    Procedure InitializePromptList
92985>>>>>>>        Integer hoInvokingObject
92985>>>>>>>        Boolean bAutoColumn bAutoSeed
92985>>>>>>>        Integer i iOldMode eUpdateMode
92985>>>>>>>        String sValue
92985>>>>>>>        
92985>>>>>>>        Get peUpdateMode to eUpdateMode
92986>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
92988>>>>>>>            Get Focus of Desktop to hoInvokingObject
92989>>>>>>>            If (hoInvokingObject<=Desktop) Begin
92991>>>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
92992>>>>>>>>
92992>>>>>>>                Procedure_Return
92993>>>>>>>            End
92993>>>>>>>>
92993>>>>>>>            
92993>>>>>>>            Set phoInvokingObject to hoInvokingObject
92994>>>>>>>            
92994>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
92995>>>>>>>            Get peUpdateMode to eUpdateMode
92996>>>>>>>        End
92996>>>>>>>>
92996>>>>>>>        
92996>>>>>>>        Send ClearSearchRequest // clear the search keys
92997>>>>>>>        Set pbNeedsNewOrdering to False
92998>>>>>>>        
92998>>>>>>>        Get pbAutoSeed to bAutoSeed
92999>>>>>>>        
92999>>>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
93001>>>>>>>            Get Value of hoInvokingObject to sValue
93002>>>>>>>            Set psSeedValue to sValue
93003>>>>>>>        End
93003>>>>>>>>
93003>>>>>>>        
93003>>>>>>>    End_Procedure
93004>>>>>>>    
93004>>>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
93004>>>>>>>    Procedure LoadData
93006>>>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
93006>>>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
93006>>>>>>>        Integer eUpdateMode
93006>>>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
93006>>>>>>>        
93006>>>>>>>        Get phoDataSource to hoDataSource
93007>>>>>>>        Get peUpdateMode to eUpdateMode
93008>>>>>>>        Get phoInvokingObject to hoInvokingObject
93009>>>>>>>        Get pbAutoSeed to bAutoSeed
93010>>>>>>>        Get piInitialColumn to iInitialColumn
93011>>>>>>>        Get piUpdateColumn to iUpdateColumn
93012>>>>>>>        Get RowCount of hoDataSource to iRows
93013>>>>>>>        
93013>>>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
93013>>>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
93013>>>>>>>        If (iInitialColumn=-1) Begin
93015>>>>>>>            Move iUpdateColumn to iInitialColumn
93016>>>>>>>        End
93016>>>>>>>>
93016>>>>>>>        If (iInitialColumn>=0) Begin
93018>>>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
93019>>>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
93020>>>>>>>        End
93020>>>>>>>>
93020>>>>>>>        Send OnSeedData // find a good starting place for the row
93021>>>>>>>        Get pbFocusSubItems to bSubFocus
93022>>>>>>>        If bSubFocus Begin
93024>>>>>>>            // if column focus, which is normal, go to initialcolumn
93024>>>>>>>            If hoInitialColumn Begin
93026>>>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
93027>>>>>>>            End
93027>>>>>>>>
93027>>>>>>>            Else Begin
93028>>>>>>>                Send MoveToFirstEnterableColumn
93029>>>>>>>            End
93029>>>>>>>>
93029>>>>>>>        End
93029>>>>>>>>
93029>>>>>>>        
93029>>>>>>>    End_Procedure
93030>>>>>>>    
93030>>>>>>>    // This is only called in a successful close
93030>>>>>>>    Procedure ClosePromptList
93032>>>>>>>        Handle hoDataSource hoInvokingObject
93032>>>>>>>        Handle hmCallBack
93032>>>>>>>        Integer iRow eUpdateMode
93032>>>>>>>        Integer[] SelRowsIndexes
93033>>>>>>>        
93033>>>>>>>        Get phoDataSource to hoDataSource
93034>>>>>>>        Get phoInvokingObject to hoInvokingObject
93035>>>>>>>        
93035>>>>>>>        If (pbMultipleSelection(Self)) Begin
93037>>>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
93038>>>>>>>        End
93038>>>>>>>>
93038>>>>>>>        Else Begin
93039>>>>>>>            Get SelectedRow of hoDataSource to iRow
93040>>>>>>>            If (iRow<>-1) Begin
93042>>>>>>>                Move iRow to SelRowsIndexes[0]
93043>>>>>>>            End
93043>>>>>>>>
93043>>>>>>>        End
93043>>>>>>>>
93043>>>>>>>        
93043>>>>>>>        Set pbCanceled to False
93044>>>>>>>        Set pSelectedRows to SelRowsIndexes
93045>>>>>>>        
93045>>>>>>>        Get peUpdateMode to eUpdateMode
93046>>>>>>>        // if non-invoking there is by definition, no move value out
93046>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
93048>>>>>>>            
93048>>>>>>>            If (eUpdateMode=umPromptValue) Begin
93050>>>>>>>                Send OnMoveValueOutByValue
93051>>>>>>>            End
93051>>>>>>>>
93051>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
93054>>>>>>>                Send OnMoveValueOutByCustom
93055>>>>>>>            End
93055>>>>>>>>
93055>>>>>>>            Get phmPromptUpdateCallback to hmCallBack
93056>>>>>>>            If hmCallBack Begin
93058>>>>>>>                Send hmCallBack of hoInvokingObject Self
93059>>>>>>>            End
93059>>>>>>>>
93059>>>>>>>        End
93059>>>>>>>>
93059>>>>>>>        
93059>>>>>>>        Send Close_Panel
93060>>>>>>>    End_Procedure
93061>>>>>>>    
93061>>>>>>>    // augment to send OnRestoreDefaults.
93061>>>>>>>    Procedure Release_Focus
93063>>>>>>>        Integer eUpdateMode
93063>>>>>>>        Get peUpdateMode to eUpdateMode
93064>>>>>>>        Forward Send Release_Focus
93066>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
93068>>>>>>>            Send OnRestoreDefaults
93069>>>>>>>        End
93069>>>>>>>>
93069>>>>>>>    End_Procedure
93070>>>>>>>    
93070>>>>>>>    Function SelectedRowIds Returns RowID[]
93072>>>>>>>        RowID[] SelectedRowids
93073>>>>>>>        Integer[] SelectedRows
93074>>>>>>>        Integer i iRows
93074>>>>>>>        Handle hoDataSource
93074>>>>>>>        Get phoDataSource to hoDataSource
93075>>>>>>>        Get pSelectedRows to SelectedRows
93076>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
93077>>>>>>>        For i from 0 to (iRows-1)
93083>>>>>>>>
93083>>>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
93084>>>>>>>        Loop
93085>>>>>>>>
93085>>>>>>>        Function_Return SelectedRowids
93086>>>>>>>    End_Function
93087>>>>>>>    
93087>>>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
93089>>>>>>>        String[] SelectedValues
93090>>>>>>>        Integer[] SelectedRows
93091>>>>>>>        Integer i iRows
93091>>>>>>>        Handle hoCol
93091>>>>>>>        Get ColumnObject iCol to hoCol
93092>>>>>>>        Get pSelectedRows to SelectedRows
93093>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
93094>>>>>>>        For i from 0 to (iRows-1)
93100>>>>>>>>
93100>>>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
93101>>>>>>>        Loop
93102>>>>>>>>
93102>>>>>>>        Function_Return SelectedValues
93103>>>>>>>    End_Function
93104>>>>>>>    
93104>>>>>>>    Procedure Ok Returns Integer
93106>>>>>>>        Send ClosePromptList
93107>>>>>>>    End_Procedure
93108>>>>>>>    
93108>>>>>>>    Procedure Cancel Returns Integer
93110>>>>>>>        Send Close_Panel
93111>>>>>>>    End_Procedure
93112>>>>>>>    
93112>>>>>>>    Procedure Search
93114>>>>>>>        Send Activate // give focus back to list so focus things are correct
93115>>>>>>>        Send Request_Search 0 0
93116>>>>>>>    End_Procedure
93117>>>>>>>    
93117>>>>>>>    // do a search using the current keys in the search key buffer for the sort column.
93117>>>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
93117>>>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
93117>>>>>>>    Procedure Request_SearchEx
93119>>>>>>>        tGridKeyPair[] Keys
93119>>>>>>>        tGridKeyPair[] Keys
93120>>>>>>>        Integer iCol
93120>>>>>>>        Handle hoCol hoSearchDialog
93120>>>>>>>        Boolean bOk
93120>>>>>>>        String sValue
93120>>>>>>>        
93120>>>>>>>        Get piSortColumn to iCol
93121>>>>>>>        If (iCol<>-1) Begin
93123>>>>>>>            Get ColumnObject iCol to hoCol
93124>>>>>>>            Get pSearchKeys to Keys
93125>>>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
93126>>>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
93127>>>>>>>            If bOk Begin
93129>>>>>>>                Send RequestFindColumnValue iCol sValue True 0
93130>>>>>>>            End
93130>>>>>>>>
93130>>>>>>>            Send Destroy of hoSearchDialog
93131>>>>>>>        End
93131>>>>>>>>
93131>>>>>>>        Send ClearSearchRequest // clear the search keys
93132>>>>>>>    End_Procedure
93133>>>>>>>    
93133>>>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
93133>>>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
93135>>>>>>>        tGridKeyPair[] Keys
93135>>>>>>>        tGridKeyPair[] Keys
93136>>>>>>>        tGridKeyPair KeyPair
93136>>>>>>>        tGridKeyPair KeyPair
93136>>>>>>>        Set pbRequestSearch to True
93137>>>>>>>        Move iKeyCode to KeyPair.KeyCode
93138>>>>>>>        Move iShiftCode to KeyPair.ShiftCode
93139>>>>>>>        Get pSearchKeys to Keys
93140>>>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
93141>>>>>>>        Set pSearchKeys to Keys
93142>>>>>>>    End_Procedure
93143>>>>>>>    
93143>>>>>>>    Procedure ClearSearchRequest
93145>>>>>>>        tGridKeyPair[] SearchKeys
93145>>>>>>>        tGridKeyPair[] SearchKeys
93146>>>>>>>        Set pSearchKeys to SearchKeys
93147>>>>>>>        Set pbRequestSearch to False
93148>>>>>>>    End_Procedure
93149>>>>>>>    
93149>>>>>>>End_Class
93150>>>>>>>
93150>>>>>Use cDbUpdateFunctionLibrary.pkg
93150>>>>>Use MSSqldrv.pkg
93150>>>>>Use db2_drv.pkg
93150>>>>>Use odbc_drv.pkg
93150>>>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout20\cRDCModalPanel.pkg)
93150>>>>>>>//****************************************************************************
93150>>>>>>>// $Module type: Class
93150>>>>>>>// $Module name: cRDCModalPanel
93150>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
93150>>>>>>>// Created     : 2014-03-17 @ 12:33
93150>>>>>>>//
93150>>>>>>>// Description :
93150>>>>>>>//
93150>>>>>>>// $Rev History:
93150>>>>>>>//    2014-03-17  Module header created
93150>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
93150>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
93150>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
93150>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
93150>>>>>>>// in the help folder for more details.
93150>>>>>>>//
93150>>>>>>>//****************************************************************************
93150>>>>>>>Use Windows.pkg
93150>>>>>>>Use cCJCommandBarSystem.pkg   
93150>>>>>>>Use cCJSkinFramework.pkg
93150>>>>>>>
93150>>>>>>>Class cRDCModalPanel is a ModalPanel
93151>>>>>>>
93151>>>>>>>    Procedure Construct_Object
93153>>>>>>>        Forward Send Construct_Object
93155>>>>>>>
93155>>>>>>>        Set Maximize_Icon to True
93156>>>>>>>        Set Minimize_Icon to False
93157>>>>>>>        Set Border_Style to Border_Thick
93158>>>>>>>        Set Locate_Mode to Center_On_Parent
93159>>>>>>>
93159>>>>>>>        Property String Private_Icon
93160>>>>>>>        Property Handle phoDialogCommandbar
93161>>>>>>>    End_Procedure
93162>>>>>>>
93162>>>>>>>    Procedure Set Icon String sIcon
93164>>>>>>>        Forward Set Icon to sIcon
93166>>>>>>>        Set Private_Icon to sIcon
93167>>>>>>>    End_Procedure
93168>>>>>>>
93168>>>>>>>    Function Icon Returns String
93170>>>>>>>        String sIcon
93170>>>>>>>        Get Private_Icon to sIcon
93171>>>>>>>        Function_Return sIcon
93172>>>>>>>    End_Function
93173>>>>>>>
93173>>>>>>>    Procedure Page Integer iPageObject
93175>>>>>>>        String sIcon
93175>>>>>>>        Integer hWnd
93175>>>>>>>        
93175>>>>>>>        Forward Send Page iPageObject
93177>>>>>>>        Get Private_Icon to sIcon
93178>>>>>>>        If (sIcon <> "") Begin
93180>>>>>>>            Set Icon to sIcon
93181>>>>>>>        End
93181>>>>>>>>
93181>>>>>>>
93181>>>>>>>        Get Window_Handle to hWnd
93182>>>>>>>
93182>>>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
93184>>>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
93185>>>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
93186>>>>>>>        End
93186>>>>>>>>
93186>>>>>>>    End_Procedure
93187>>>>>>>
93187>>>>>>>    // Put a status bar at the bottom of the panel, which makes
93187>>>>>>>    // status_help work and puts a gripper in the lower right corner.
93187>>>>>>>    Procedure End_Construct_Object
93189>>>>>>>        Integer iStyle iSize iOffset
93189>>>>>>>
93189>>>>>>>        Forward Send End_Construct_Object
93191>>>>>>>
93191>>>>>>>        Get Border_Style to iStyle
93192>>>>>>>        Move 8 to iOffset
93193>>>>>>>        If (iStyle = Border_Thick) Begin
93195>>>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
93197>>>>>>>                Object oStatusBar is a cCJStatusBar
93199>>>>>>>                    Set phoDialogCommandbar to Self
93200>>>>>>>                    Object oStatusIdle is a cCJStatusBarPane
93202>>>>>>>                        Set piId to sbpIDIdlePane
93203>>>>>>>                        Set pbStyleStretch to True
93204>>>>>>>                    End_Object
93205>>>>>>>                End_Object
93206>>>>>>>            End_Object
93207>>>>>>>            Get Size to iSize
93208>>>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
93209>>>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
93210>>>>>>>        End
93210>>>>>>>>
93210>>>>>>>
93210>>>>>>>    End_Procedure
93211>>>>>>>
93211>>>>>>>    Procedure Popup
93213>>>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
93214>>>>>>>        Forward Send Popup
93216>>>>>>>    End_Procedure
93217>>>>>>>
93217>>>>>>>End_Class
93218>>>>>
93218>>>>>Object oDatabaseSelection_sl is a cRDCModalPanel
93220>>>>>    Set Label to "SQL Database Selection"
93221>>>>>    Set Size to 119 183
93222>>>>>    Set piMinSize to 89 170
93223>>>>>    Set Location to 2 2
93224>>>>>    Set Border_Style to Border_Thick
93225>>>>>    Set Icon to "DatabaseLookup1.ico"
93226>>>>>
93226>>>>>    Property String[] psTheData
93228>>>>>
93228>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
93230>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
93232>>>>>        End_Object
93233>>>>>    End
93233>>>>>>
93233>>>>>
93233>>>>>    Object oSelList is a cCJGridPromptList
93235>>>>>        Set Size to 89 167
93236>>>>>        Set Location to 6 6
93237>>>>>        Set peAnchors to anAll
93238>>>>>        Set pbAllowColumnRemove to False
93239>>>>>        Set pbUseAlternateRowBackgroundColor to True
93240>>>>>        Set pbGrayIfDisable to False
93241>>>>>        Set pbHeaderReorders to False
93242>>>>>        Set pbHeaderSelectsColumn to False
93243>>>>>        Set pbHeaderTogglesDirection to False
93244>>>>>        Set pbShadeSortColumn to False
93245>>>>>        Set piFocusCellBackColor to clDkGray
93246>>>>>
93246>>>>>        Object oName is a cCJGridColumn
93248>>>>>            Set piWidth to 334
93249>>>>>            Set psCaption to "Database Name"
93250>>>>>        End_Object
93251>>>>>
93251>>>>>        Procedure Activating
93254>>>>>            tDataSourceRow[] MyData
93254>>>>>            tDataSourceRow[] MyData
93255>>>>>            Handle hoDataSource
93255>>>>>            String[] sTheData
93256>>>>>            Integer iCount iSize
93256>>>>>
93256>>>>>            Send Cursor_Wait of Cursor_Control
93257>>>>>            Forward Send Activating
93259>>>>>
93259>>>>>            Get psTheData to sTheData
93260>>>>>            Move (SizeOfArray(sTheData)) to iSize
93261>>>>>            Decrement iSize
93262>>>>>            For iCount from 0 to iSize
93268>>>>>>
93268>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
93269>>>>>            Loop
93270>>>>>>
93270>>>>>
93270>>>>>            Get phoDataSource to hoDataSource
93271>>>>>            Send InitializeData of hoDataSource MyData
93272>>>>>            Send Cursor_Ready of Cursor_Control
93273>>>>>        End_Procedure
93274>>>>>
93274>>>>>    End_Object
93275>>>>>
93275>>>>>    Object oOK_Btn is a Button
93277>>>>>        Set Size to 14 50
93278>>>>>        Set Label    to "&OK"
93279>>>>>        Set Location to 98 68
93280>>>>>        Set peAnchors To anBottomRight
93281>>>>>
93281>>>>>        Procedure OnClick
93284>>>>>            Send Ok of oSelList
93285>>>>>        End_Procedure
93286>>>>>
93286>>>>>    End_Object
93287>>>>>
93287>>>>>    Object oCancel_Btn is a Button
93289>>>>>        Set Size to 14 50
93290>>>>>        Set Label    to "&Cancel"
93291>>>>>        Set Location to 98 123
93292>>>>>        Set peAnchors to anBottomRight
93293>>>>>
93293>>>>>        Procedure OnClick
93296>>>>>            Send Close_Panel
93297>>>>>        End_Procedure
93298>>>>>
93298>>>>>    End_Object
93299>>>>>
93299>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
93300>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
93301>>>>>End_Object
93302>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
93302>>>>>Use Windows.pkg
93302>>>>>Use cCJGridPromptList.pkg
93302>>>>>Use MSSqldrv.pkg
93302>>>>>Use db2_drv.pkg
93302>>>>>Use odbc_drv.pkg    
93302>>>>>Use cRDCModalPanel.pkg
93302>>>>>Use cDbUpdateFunctionLibrary.pkg
93302>>>>>
93302>>>>>Object oServerSelection_sl is a cRDCModalPanel
93304>>>>>    Set Size to 105 225
93305>>>>>    Set Label to "Database Server/DSN Selection"
93306>>>>>    Set piMinSize to 89 211
93307>>>>>    Set Location to 2 2
93308>>>>>    Set Icon to "ServerLookup1.ico"
93309>>>>>
93309>>>>>    Property String[] psTheData
93311>>>>>
93311>>>>>    Object oSelList is a cCJGridPromptList
93313>>>>>        Set Size to 72 215
93314>>>>>        Set Location to 6 6
93315>>>>>        Set peAnchors to anAll
93316>>>>>        Set pbAllowColumnRemove to False
93317>>>>>        Set pbUseAlternateRowBackgroundColor to True
93318>>>>>        Set pbGrayIfDisable to False
93319>>>>>        Set pbHeaderReorders to False
93320>>>>>        Set pbHeaderSelectsColumn to False
93321>>>>>        Set pbHeaderTogglesDirection to False
93322>>>>>        Set pbShadeSortColumn to False
93323>>>>>        Set piFocusCellBackColor to clDkGray
93324>>>>>
93324>>>>>        Object oName is a cCJGridColumn
93326>>>>>            Set piWidth to 358
93327>>>>>            Set psCaption to "Name"
93328>>>>>        End_Object
93329>>>>>
93329>>>>>        Procedure Activating
93332>>>>>            tDataSourceRow[] MyData
93332>>>>>            tDataSourceRow[] MyData
93333>>>>>            Handle hoDataSource
93333>>>>>            String[] sTheData
93334>>>>>            Integer iCount iSize
93334>>>>>
93334>>>>>            Send Cursor_Wait of Cursor_Control
93335>>>>>            Get psTheData to sTheData
93336>>>>>            Move (SizeOfArray(sTheData)) to iSize
93337>>>>>            Decrement iSize
93338>>>>>            For iCount from 0 to iSize
93344>>>>>>
93344>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
93345>>>>>            Loop
93346>>>>>>
93346>>>>>
93346>>>>>            Forward Send Activating
93348>>>>>
93348>>>>>            Get phoDataSource to hoDataSource
93349>>>>>            Send InitializeData of hoDataSource MyData
93350>>>>>            Send Cursor_Ready of Cursor_Control
93351>>>>>        End_Procedure
93352>>>>>
93352>>>>>    End_Object
93353>>>>>
93353>>>>>    Object oOK_Btn is a Button
93355>>>>>        Set Size to 14 50
93356>>>>>        Set Label    to "&OK"
93357>>>>>        Set Location to 85 116
93358>>>>>        Set peAnchors To anBottomRight
93359>>>>>
93359>>>>>        Procedure OnClick
93362>>>>>            Send Ok of oSelList
93363>>>>>        End_Procedure
93364>>>>>
93364>>>>>    End_Object
93365>>>>>
93365>>>>>    Object oCancel_Btn is a Button
93367>>>>>        Set Size to 14 50
93368>>>>>        Set Label    to "&Cancel"
93369>>>>>        Set Location to 85 171
93370>>>>>        Set peAnchors to anBottomRight
93371>>>>>
93371>>>>>        Procedure OnClick
93374>>>>>            Send Close_Panel
93375>>>>>        End_Procedure
93376>>>>>
93376>>>>>    End_Object
93377>>>>>
93377>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
93378>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
93379>>>>>End_Object
93380>>>Use ManageSQLConnections.dg
Including file: ManageSQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ManageSQLConnections.dg)
93380>>>>>Use Windows.pkg
93380>>>>>Use Cursor.pkg
93380>>>>>Use cCJCommandBarSystem.pkg
93380>>>>>Use cRDCButtonDPI.pkg
93380>>>>>Use cSQLCheckBox.pkg
Including file: cSQLCheckBox.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLCheckBox.pkg)
93380>>>>>>>Use Windows.pkg
93380>>>>>>>
93380>>>>>>>// Used by the "Page" message below to show
93380>>>>>>>// a rectangle around ComboForm and Checkbox objects.
93380>>>>>>>    Define WM_CHANGEUISTATE for |CI$0127
93380>>>>>>>    Define WM_UPDATEUISTATE for |CI$0128
93380>>>>>>>    Define WM_QUERYUISTATE  for |CI$0129
93380>>>>>>>    Define UIS_SET          for 1
93380>>>>>>>    Define UIS_CLEAR        for 2
93380>>>>>>>    Define UIS_INITIALIZE   for 3
93380>>>>>>>    Define UISF_HIDEFOCUS   for |CI$1
93380>>>>>>>    Define UISF_HIDEACCEL   for |CI$2
93380>>>>>>>    Define UISF_ACTIVE      for |CI$4
93380>>>>>>>
93380>>>>>>>// Note: Can't use cRDCCheckbox as then the OnChange event isn't called (Don't know why)
93380>>>>>>>Class cSQLCheckBox is a CheckBox
93381>>>>>>>    Procedure Construct_Object
93383>>>>>>>        Forward Send Construct_Object
93385>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
93385>>>>>>>        Property Integer piItem
93386>>>>>>>    End_Procedure
93387>>>>>>>
93387>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
93389>>>>>>>    End_Procedure
93390>>>>>>>
93390>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
93392>>>>>>>        Integer iItem
93392>>>>>>>        Get piItem to iItem
93393>>>>>>>        Set Checked_State to (sConnectionData[iItem] = "1")
93394>>>>>>>    End_Procedure
93395>>>>>>>
93395>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
93397>>>>>>>        Boolean bState
93397>>>>>>>        Integer iItem
93397>>>>>>>        Get piItem to iItem
93398>>>>>>>        Get Checked_State to bState
93399>>>>>>>        Move bState to sConnectionData[iItem]
93400>>>>>>>    End_Procedure
93401>>>>>>>
93401>>>>>>>    Procedure Set psToolTip String sToolTip
93403>>>>>>>        String sStatusHelp
93403>>>>>>>
93403>>>>>>>        Get Status_Help to sStatusHelp
93404>>>>>>>        If (sStatusHelp = "") Begin
93406>>>>>>>            Set Status_Help to sToolTip
93407>>>>>>>        End
93407>>>>>>>>
93407>>>>>>>
93407>>>>>>>        Forward Set psToolTip to sToolTip
93409>>>>>>>    End_Procedure
93410>>>>>>>
93410>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
93410>>>>>>>    // The bug being that the focus rectangle doesn't show.
93410>>>>>>>    Procedure Page Integer iPageObject
93412>>>>>>>        Handle hWnd
93412>>>>>>>        Integer iRet iState
93412>>>>>>>
93412>>>>>>>        Forward Send Page iPageObject
93414>>>>>>>
93414>>>>>>>        If (iPageObject) Begin
93416>>>>>>>            Get Window_Handle to hWnd
93417>>>>>>>            If (hWnd) Begin
93419>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
93420>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
93422>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
93423>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
93424>>>>>>>                End
93424>>>>>>>>
93424>>>>>>>            End
93424>>>>>>>>
93424>>>>>>>        End
93424>>>>>>>>
93424>>>>>>>    End_Procedure
93425>>>>>>>
93425>>>>>>>End_Class
93426>>>>>Use cSQLComboForm.pkg
Including file: cSQLComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLComboForm.pkg)
93426>>>>>>>Use Windows.pkg
93426>>>>>>>Use cRDCComboForm.pkg
Including file: cRDCComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCComboForm.pkg)
93426>>>>>>>>>//****************************************************************************
93426>>>>>>>>>// $Module type: Package
93426>>>>>>>>>// $Module name: cRDCComboform.pkg
93426>>>>>>>>>//
93426>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
93426>>>>>>>>>// Copyright (c) 2014 RDC Tools International
93426>>>>>>>>>// E-mail      : support@rdctools.com
93426>>>>>>>>>// Web-site    : http://www.rdctools.com
93426>>>>>>>>>//
93426>>>>>>>>>// Created     : 2014-03-17 @ 12:35 (Military date format - Year-Month-Day)
93426>>>>>>>>>//
93426>>>>>>>>>// Portions by : Raveen Sundram, Excellent Software Ltd
93426>>>>>>>>>//               The auto-size combo width logic was developed by Raveen.
93426>>>>>>>>>//
93426>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
93426>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
93426>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
93426>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
93426>>>>>>>>>// in the help folder for more details.
93426>>>>>>>>>//
93426>>>>>>>>>//****************************************************************************
93426>>>>>>>>>Use Windows.pkg
93426>>>>>>>>>
93426>>>>>>>>>// Used by the "Page" message below to show
93426>>>>>>>>>// a focus rectangle around ComboForm and Checkbox objects.
93426>>>>>>>>>
93426>>>>>>>>>Class cComboFormIdleHandler is a cIdleHandler
93427>>>>>>>>>    Procedure Construct_Object
93429>>>>>>>>>        Forward Send Construct_Object
93431>>>>>>>>>
93431>>>>>>>>>        Set Label_Row_Offset to 0
93432>>>>>>>>>        Set Label_Col_Offset to 2
93433>>>>>>>>>        Set Label_Justification_Mode to jMode_Right
93434>>>>>>>>>        Set Combo_Sort_State to False
93435>>>>>>>>>        Set Entry_State to False
93436>>>>>>>>>
93436>>>>>>>>>    End_Procedure
93437>>>>>>>>>
93437>>>>>>>>>    Procedure OnIdle
93439>>>>>>>>>        Delegate Send DoUpdate
93441>>>>>>>>>    End_Procedure
93442>>>>>>>>>
93442>>>>>>>>>End_Class
93443>>>>>>>>>
93443>>>>>>>>>Class cRDCComboForm is a ComboForm
93444>>>>>>>>>    Procedure Construct_Object
93446>>>>>>>>>        Forward Send Construct_Object
93448>>>>>>>>>
93448>>>>>>>>>        Property Boolean pbAutoListWidth True
93449>>>>>>>>>
93449>>>>>>>>>        Property Boolean pbAutoShadowLabelObject True
93450>>>>>>>>>
93450>>>>>>>>>        Property Boolean pbAutoEnable False
93451>>>>>>>>>        Set Label_Col_Offset to 2
93452>>>>>>>>>        Property Boolean pbEnabled True
93453>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
93454>>>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cComboFormIdleHandler)))
93455>>>>>>>>>
93455>>>>>>>>>    End_Procedure
93456>>>>>>>>>
93456>>>>>>>>>    Procedure End_Construct_Object
93458>>>>>>>>>        Boolean bAutoShadowLabelObject
93458>>>>>>>>>        String sTooltip sStatus_Help
93458>>>>>>>>>
93458>>>>>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
93459>>>>>>>>>        If (bAutoShadowLabelObject = True) Begin
93461>>>>>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
93462>>>>>>>>>        End
93462>>>>>>>>>>
93462>>>>>>>>>
93462>>>>>>>>>        Forward Send End_Construct_Object
93464>>>>>>>>>
93464>>>>>>>>>        Get psToolTip   to sTooltip
93465>>>>>>>>>        Get Status_Help to sStatus_Help
93466>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
93468>>>>>>>>>            Set psToolTip to sStatus_Help
93469>>>>>>>>>        End
93469>>>>>>>>>>
93469>>>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
93472>>>>>>>>>            Set Status_Help to sTooltip
93473>>>>>>>>>        End
93473>>>>>>>>>>
93473>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
93474>>>>>>>>>
93474>>>>>>>>>    End_Procedure
93475>>>>>>>>>
93475>>>>>>>>>    Procedure DoUpdate
93477>>>>>>>>>        If (pbAutoEnable(Self) = False) Begin
93479>>>>>>>>>            Procedure_Return
93480>>>>>>>>>        End
93480>>>>>>>>>>
93480>>>>>>>>>        Set Enabled_State to (IsEnabled(Self))
93481>>>>>>>>>    End_Procedure
93482>>>>>>>>>
93482>>>>>>>>>    Function IsEnabled Returns Boolean
93484>>>>>>>>>        Boolean bEnabled
93484>>>>>>>>>        Get pbEnabled to bEnabled
93485>>>>>>>>>        Function_Return bEnabled
93486>>>>>>>>>    End_Function
93487>>>>>>>>>
93487>>>>>>>>>    // Enable the idle handler timer when the object is activated
93487>>>>>>>>>    Procedure Activating
93489>>>>>>>>>        Forward Send Activating
93491>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
93492>>>>>>>>>    End_Procedure
93493>>>>>>>>>
93493>>>>>>>>>    // Disable the idle handler when the object is deactivated
93493>>>>>>>>>    Procedure Deactivating
93495>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
93496>>>>>>>>>        Forward Send Deactivating
93498>>>>>>>>>    End_Procedure
93499>>>>>>>>>
93499>>>>>>>>>    // To "un-select" the text in the comboform on startup
93499>>>>>>>>>    Procedure DoApplyAnchors Integer Arg1 Integer Arg2
93501>>>>>>>>>        Integer iStart iEnd
93501>>>>>>>>>
93501>>>>>>>>>        If (Focus(Desktop)=Self) Begin
93503>>>>>>>>>            Get SelStart to iStart
93504>>>>>>>>>            Get SelEnd   to iEnd
93505>>>>>>>>>        End
93505>>>>>>>>>>
93505>>>>>>>>>        Forward Send DoApplyAnchors Arg1 Arg2
93507>>>>>>>>>        Send SetSel iStart iEnd
93508>>>>>>>>>    End_Procedure
93509>>>>>>>>>
93509>>>>>>>>>    // Message that will drop down the list without the user clicking it,
93509>>>>>>>>>    // so you can send "DropDownList" to the combo to show the list.
93509>>>>>>>>>    Procedure DropDownList
93511>>>>>>>>>        Send Windows_Message CB_SHOWDROPDOWN 1 0
93512>>>>>>>>>    End_Procedure
93513>>>>>>>>>
93513>>>>>>>>>    Procedure SizeComboWidth
93515>>>>>>>>>        Integer iCount iItem iTextExt iRows iWd iNewWd iVertAdj
93515>>>>>>>>>        String sVal
93515>>>>>>>>>
93515>>>>>>>>>        // Initialise Width
93515>>>>>>>>>        Set ListWidth to 0
93516>>>>>>>>>        Send DoSetListWidth
93517>>>>>>>>>
93517>>>>>>>>>        Get ListRowCount     to iRows
93518>>>>>>>>>        Get Combo_Item_Count to iCount
93519>>>>>>>>>
93519>>>>>>>>>        // Vertical scroll-bar adjustment is needed
93519>>>>>>>>>        Move (iRows > 0 and iCount > iRows) to iVertAdj
93520>>>>>>>>>        If (iVertAdj) Begin
93522>>>>>>>>>            Move (GetSystemMetrics(SM_CXVSCROLL)+GetSystemMetrics(SM_CXEDGE)) to iVertAdj
93523>>>>>>>>>        End
93523>>>>>>>>>>
93523>>>>>>>>>        Else Begin
93524>>>>>>>>>            Move (GetSystemMetrics(SM_CXEDGE)) to iVertAdj
93525>>>>>>>>>        End
93525>>>>>>>>>>
93525>>>>>>>>>
93525>>>>>>>>>        // Calculate New Width
93525>>>>>>>>>        Decrement iCount
93526>>>>>>>>>        For iItem from 0 to iCount
93532>>>>>>>>>>
93532>>>>>>>>>            Get Combo_Value iItem to sVal
93533>>>>>>>>>            If (sVal <> "") Begin
93535>>>>>>>>>                Get Text_Extent sVal to iTextExt
93536>>>>>>>>>                Move (Low(iTextExt) + iVertAdj) to iWd
93537>>>>>>>>>                If (iWd > iNewWd) Begin
93539>>>>>>>>>                    Move (iWd + GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CXEDGE)) to iNewWd
93540>>>>>>>>>                End
93540>>>>>>>>>>
93540>>>>>>>>>            End
93540>>>>>>>>>>
93540>>>>>>>>>        Loop
93541>>>>>>>>>>
93541>>>>>>>>>
93541>>>>>>>>>        // Set New Width
93541>>>>>>>>>        Set ListWidth to iNewWd
93542>>>>>>>>>        Send DoSetListWidth
93543>>>>>>>>>    End_Procedure
93544>>>>>>>>>
93544>>>>>>>>>    Procedure Combo_Add_Item String sValue
93546>>>>>>>>>        Forward Send Combo_Add_Item sValue
93548>>>>>>>>>        If (pbAutoListWidth(Self)) Begin
93550>>>>>>>>>            Send SizeComboWidth
93551>>>>>>>>>        End
93551>>>>>>>>>>
93551>>>>>>>>>    End_Procedure
93552>>>>>>>>>
93552>>>>>>>>>    Procedure Combo_Fill_List
93554>>>>>>>>>        Forward Send Combo_Fill_List
93556>>>>>>>>>        If (pbAutoListWidth(Self)) Begin
93558>>>>>>>>>            Send SizeComboWidth
93559>>>>>>>>>        End
93559>>>>>>>>>>
93559>>>>>>>>>    End_Procedure
93560>>>>>>>>>
93560>>>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
93560>>>>>>>>>    // The bug being that the focus rectangle doesn't show.
93560>>>>>>>>>    Procedure Page Integer iPageObject
93562>>>>>>>>>        Handle hWnd
93562>>>>>>>>>        Integer iRet iState
93562>>>>>>>>>
93562>>>>>>>>>        Forward Send Page iPageObject
93564>>>>>>>>>
93564>>>>>>>>>        If (iPageObject) Begin
93566>>>>>>>>>            Get Window_Handle to hWnd
93567>>>>>>>>>            If (hWnd) Begin
93569>>>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
93570>>>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
93572>>>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
93573>>>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
93574>>>>>>>>>                End
93574>>>>>>>>>>
93574>>>>>>>>>            End
93574>>>>>>>>>>
93574>>>>>>>>>        End
93574>>>>>>>>>>
93574>>>>>>>>>
93574>>>>>>>>>        // To "un-select" the text in the comboform
93574>>>>>>>>>        If (iPageObject = 1 and Focus(Desktop) <> Self) Begin
93576>>>>>>>>>            Send SetSel 0 0
93577>>>>>>>>>        End
93577>>>>>>>>>>
93577>>>>>>>>>    End_Procedure
93578>>>>>>>>>
93578>>>>>>>>>End_Class
93579>>>>>>>
93579>>>>>>>// Used by the "Page" message below to show
93579>>>>>>>// a rectangle around ComboForm and Checkbox objects.
93579>>>>>>>//#IFNDEF WM_CHANGEUISTATE
93579>>>>>>>//    Define WM_CHANGEUISTATE for |CI$0127
93579>>>>>>>//    Define WM_UPDATEUISTATE for |CI$0128
93579>>>>>>>//    Define WM_QUERYUISTATE  for |CI$0129
93579>>>>>>>//    Define UIS_SET          for 1
93579>>>>>>>//    Define UIS_CLEAR        for 2
93579>>>>>>>//    Define UIS_INITIALIZE   for 3
93579>>>>>>>//    Define UISF_HIDEFOCUS   for |CI$1
93579>>>>>>>//    Define UISF_HIDEACCEL   for |CI$2
93579>>>>>>>//    Define UISF_ACTIVE      for |CI$4
93579>>>>>>>//#ENDIF
93579>>>>>>>
93579>>>>>>>Class cSQLComboForm is a cRDCComboForm
93580>>>>>>>    Procedure Construct_Object
93582>>>>>>>        Forward Send Construct_Object
93584>>>>>>>
93584>>>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
93584>>>>>>>//        Property Boolean pbAutoShadowLabelObject True
93584>>>>>>>
93584>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
93584>>>>>>>        Property Integer piItem
93585>>>>>>>
93585>>>>>>>//        Set Label_Col_Offset to 2
93585>>>>>>>//        Set Label_Justification_Mode to JMode_Right
93585>>>>>>>    End_Procedure
93586>>>>>>>
93586>>>>>>>    Procedure End_Construct_Object
93588>>>>>>>//        Boolean bAutoShadowLabelObject
93588>>>>>>>//        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
93588>>>>>>>//        If (bAutoShadowLabelObject = True) Begin
93588>>>>>>>//            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
93588>>>>>>>//        End
93588>>>>>>>        Forward Send End_Construct_Object
93590>>>>>>>    End_Procedure
93591>>>>>>>
93591>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
93593>>>>>>>    End_Procedure
93594>>>>>>>
93594>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
93596>>>>>>>        Integer iItem
93596>>>>>>>        Get piItem to iItem
93597>>>>>>>        Set Value to sConnectionData[iItem]
93598>>>>>>>    End_Procedure
93599>>>>>>>
93599>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
93601>>>>>>>        String sValue
93601>>>>>>>        Integer iItem
93601>>>>>>>        Get piItem to iItem
93602>>>>>>>        Get Value to sValue
93603>>>>>>>        Move sValue to sConnectionData[iItem]
93604>>>>>>>    End_Procedure
93605>>>>>>>
93605>>>>>>>//    Procedure Set psToolTip String sToolTip
93605>>>>>>>//        String sStatusHelp
93605>>>>>>>//
93605>>>>>>>//        Get Status_Help to sStatusHelp
93605>>>>>>>//        If (sStatusHelp = "") Begin
93605>>>>>>>//            Set Status_Help to sToolTip
93605>>>>>>>//        End
93605>>>>>>>//
93605>>>>>>>//        Forward Set psToolTip to sToolTip
93605>>>>>>>//    End_Procedure
93605>>>>>>>//
93605>>>>>>>//    // Fix for a bug when using manifest files & running Vista and above.
93605>>>>>>>//    // The bug being that the focus rectangle doesn't show.
93605>>>>>>>//    Procedure Page Integer iPageObject
93605>>>>>>>//        Handle hWnd
93605>>>>>>>//        Integer iRet iState
93605>>>>>>>//
93605>>>>>>>//        Forward Send Page iPageObject
93605>>>>>>>//
93605>>>>>>>//        If (iPageObject) Begin
93605>>>>>>>//            Get Window_Handle to hWnd
93605>>>>>>>//            If (hWnd) Begin
93605>>>>>>>//                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
93605>>>>>>>//                If (iRet iand UISF_HIDEFOCUS) Begin
93605>>>>>>>//                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
93605>>>>>>>//                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
93605>>>>>>>//                End
93605>>>>>>>//            End
93605>>>>>>>//        End
93605>>>>>>>//    End_Procedure
93605>>>>>>>
93605>>>>>>>End_Class
93606>>>>>Use cSQLForm.pkg
Including file: cSQLForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLForm.pkg)
93606>>>>>>>Use Windows.pkg
93606>>>>>>>
93606>>>>>>>Class cSQLForm is a Form
93607>>>>>>>    Procedure Construct_Object
93609>>>>>>>        Forward Send Construct_Object
93611>>>>>>>
93611>>>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
93611>>>>>>>        Property Boolean pbAutoShadowLabelObject True
93612>>>>>>>
93612>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
93612>>>>>>>        Property Integer piItem
93613>>>>>>>
93613>>>>>>>        Set Label_Justification_Mode to JMode_Right
93614>>>>>>>        Set Label_Col_Offset to 2
93615>>>>>>>    End_Procedure
93616>>>>>>>
93616>>>>>>>    Procedure End_Construct_Object
93618>>>>>>>        Boolean bAutoShadowLabelObject
93618>>>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
93619>>>>>>>        If (bAutoShadowLabelObject = True) Begin
93621>>>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
93622>>>>>>>        End
93622>>>>>>>>
93622>>>>>>>        Forward Send End_Construct_Object
93624>>>>>>>    End_Procedure
93625>>>>>>>
93625>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
93627>>>>>>>    End_Procedure
93628>>>>>>>
93628>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
93630>>>>>>>        Integer iItem
93630>>>>>>>        Get piItem to iItem
93631>>>>>>>        Set Value to sConnectionData[iItem]
93632>>>>>>>    End_Procedure
93633>>>>>>>
93633>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
93635>>>>>>>        String sValue
93635>>>>>>>        Integer iItem
93635>>>>>>>        Get piItem to iItem
93636>>>>>>>        Get Value to sValue
93637>>>>>>>        Move sValue to sConnectionData[iItem]
93638>>>>>>>    End_Procedure
93639>>>>>>>
93639>>>>>>>    Procedure Set psToolTip String sToolTip
93641>>>>>>>        String sStatusHelp
93641>>>>>>>
93641>>>>>>>        Get Status_Help to sStatusHelp
93642>>>>>>>        If (sStatusHelp = "") Begin
93644>>>>>>>            Set Status_Help to sToolTip
93645>>>>>>>        End
93645>>>>>>>>
93645>>>>>>>
93645>>>>>>>        Forward Set psToolTip to sToolTip
93647>>>>>>>    End_Procedure
93648>>>>>>>
93648>>>>>>>End_Class
93649>>>>>Use cSQLConnectionHandler.pkg
93649>>>>>Use cDbUpdateFunctionLibrary.pkg
93649>>>>>Use cDbUpdateDatabaseDriver.pkg
93649>>>>>Use DatabaseSelection.dg
93649>>>>>Use ServerSelection.dg
93649>>>>>Use TableSpaceSelection.dg
Including file: TableSpaceSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\TableSpaceSelection.dg)
93649>>>>>>>Use Windows.pkg
93649>>>>>>>Use cCJGridPromptList.pkg     
93649>>>>>>>Use cRDCModalPanel.pkg
93649>>>>>>>Use cDbUpdateFunctionLibrary.pkg
93649>>>>>>>
93649>>>>>>>Object oTableSpaceSelection_sl is a cRDCModalPanel
93651>>>>>>>    Set Size to 118 177
93652>>>>>>>    Set Label to "SQL Tablespace Selection"
93653>>>>>>>    Set piMinSize to 89 177
93654>>>>>>>    Set Location to 2 2
93655>>>>>>>    Set Icon to "DatabaseLookup1.ico"
93656>>>>>>>
93656>>>>>>>    Property String[] psTheData
93658>>>>>>>
93658>>>>>>>//    If (ghoDbUpdateFunctionLibrary = 0) Begin
93658>>>>>>>//        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
93658>>>>>>>//        End_Object
93658>>>>>>>//    End
93658>>>>>>>
93658>>>>>>>    Object oSelList is a cCJGridPromptList
93660>>>>>>>        Set Size to 89 167
93661>>>>>>>        Set Location to 6 6
93662>>>>>>>        Set peAnchors to anAll
93663>>>>>>>        Set pbAllowColumnRemove to False
93664>>>>>>>        Set pbUseAlternateRowBackgroundColor to True
93665>>>>>>>        Set pbGrayIfDisable to False
93666>>>>>>>        Set pbHeaderReorders to False
93667>>>>>>>        Set pbHeaderSelectsColumn to False
93668>>>>>>>        Set pbHeaderTogglesDirection to False
93669>>>>>>>        Set pbShadeSortColumn to False
93670>>>>>>>        Set piFocusCellBackColor to clDkGray
93671>>>>>>>
93671>>>>>>>        Object oName is a cCJGridColumn
93673>>>>>>>            Set piWidth to 334
93674>>>>>>>            Set psCaption to "Table Space Name"
93675>>>>>>>        End_Object
93676>>>>>>>
93676>>>>>>>        Procedure Activating
93679>>>>>>>            tDataSourceRow[] MyData
93679>>>>>>>            tDataSourceRow[] MyData
93680>>>>>>>            Handle hoDataSource
93680>>>>>>>            String[] sTheData
93681>>>>>>>            Integer iCount iSize
93681>>>>>>>
93681>>>>>>>            Send Cursor_Wait of Cursor_Control
93682>>>>>>>            Forward Send Activating
93684>>>>>>>
93684>>>>>>>            Get psTheData to sTheData
93685>>>>>>>            Move (SizeOfArray(sTheData)) to iSize
93686>>>>>>>            Decrement iSize
93687>>>>>>>            For iCount from 0 to iSize
93693>>>>>>>>
93693>>>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
93694>>>>>>>            Loop
93695>>>>>>>>
93695>>>>>>>
93695>>>>>>>            Get phoDataSource to hoDataSource
93696>>>>>>>            Send InitializeData of hoDataSource MyData
93697>>>>>>>            Send Cursor_Ready of Cursor_Control
93698>>>>>>>        End_Procedure
93699>>>>>>>
93699>>>>>>>    End_Object
93700>>>>>>>
93700>>>>>>>    Object oOK_Btn is a Button
93702>>>>>>>        Set Size to 14 50
93703>>>>>>>        Set Label    to "&OK"
93704>>>>>>>        Set Location to 98 68
93705>>>>>>>        Set peAnchors To anBottomRight
93706>>>>>>>
93706>>>>>>>        Procedure OnClick
93709>>>>>>>            Send Ok of oSelList
93710>>>>>>>        End_Procedure
93711>>>>>>>
93711>>>>>>>    End_Object
93712>>>>>>>
93712>>>>>>>    Object oCancel_Btn is a Button
93714>>>>>>>        Set Size to 14 50
93715>>>>>>>        Set Label    to "&Cancel"
93716>>>>>>>        Set Location to 98 123
93717>>>>>>>        Set peAnchors to anBottomRight
93718>>>>>>>
93718>>>>>>>        Procedure OnClick
93721>>>>>>>            Send Close_Panel
93722>>>>>>>        End_Procedure
93723>>>>>>>
93723>>>>>>>    End_Object
93724>>>>>>>
93724>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
93725>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
93726>>>>>>>End_Object
93727>>>>>Use SchemasSelection.dg
Including file: SchemasSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SchemasSelection.dg)
93727>>>>>>>Use Windows.pkg
93727>>>>>>>Use cCJGridPromptList.pkg  
93727>>>>>>>Use cRDCModalPanel.pkg
93727>>>>>>>Use cDbUpdateFunctionLibrary.pkg
93727>>>>>>>
93727>>>>>>>Object oSchemasSelection_sl is a cRDCModalPanel
93729>>>>>>>    Set Size to 118 177
93730>>>>>>>    Set Label to "SQL Schemas Selection"
93731>>>>>>>    Set piMinSize to 89 177
93732>>>>>>>    Set Location to 2 2
93733>>>>>>>    Set Icon to "DatabaseLookup1.ico"
93734>>>>>>>
93734>>>>>>>    Property String[] psTheData
93736>>>>>>>
93736>>>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
93738>>>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
93740>>>>>>>        End_Object
93741>>>>>>>    End
93741>>>>>>>>
93741>>>>>>>
93741>>>>>>>    Object oSelList is a cCJGridPromptList
93743>>>>>>>        Set Size to 89 167
93744>>>>>>>        Set Location to 6 6
93745>>>>>>>        Set peAnchors to anAll
93746>>>>>>>        Set pbAllowColumnRemove to False
93747>>>>>>>        Set pbUseAlternateRowBackgroundColor to True
93748>>>>>>>        Set pbGrayIfDisable to False
93749>>>>>>>        Set pbHeaderReorders to False
93750>>>>>>>        Set pbHeaderSelectsColumn to False
93751>>>>>>>        Set pbHeaderTogglesDirection to False
93752>>>>>>>        Set pbShadeSortColumn to False
93753>>>>>>>        Set piFocusCellBackColor to clDkGray
93754>>>>>>>
93754>>>>>>>        Object oName is a cCJGridColumn
93756>>>>>>>            Set piWidth to 334
93757>>>>>>>            Set psCaption to "Schema Name"
93758>>>>>>>        End_Object
93759>>>>>>>
93759>>>>>>>        Procedure Activating
93762>>>>>>>            tDataSourceRow[] MyData
93762>>>>>>>            tDataSourceRow[] MyData
93763>>>>>>>            Handle hoDataSource
93763>>>>>>>            String[] sTheData
93764>>>>>>>            Integer iCount iSize
93764>>>>>>>
93764>>>>>>>            Send Cursor_Wait of Cursor_Control
93765>>>>>>>            Forward Send Activating
93767>>>>>>>
93767>>>>>>>            Get psTheData to sTheData
93768>>>>>>>
93768>>>>>>>            Move (SizeOfArray(sTheData)) to iSize
93769>>>>>>>            Decrement iSize
93770>>>>>>>            For iCount from 0 to iSize
93776>>>>>>>>
93776>>>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
93777>>>>>>>            Loop
93778>>>>>>>>
93778>>>>>>>
93778>>>>>>>            Get phoDataSource to hoDataSource
93779>>>>>>>            Send InitializeData of hoDataSource MyData
93780>>>>>>>            Send Cursor_Ready of Cursor_Control
93781>>>>>>>        End_Procedure
93782>>>>>>>
93782>>>>>>>    End_Object
93783>>>>>>>
93783>>>>>>>    Object oOK_Btn is a Button
93785>>>>>>>        Set Size to 14 50
93786>>>>>>>        Set Label    to "&OK"
93787>>>>>>>        Set Location to 98 68
93788>>>>>>>        Set peAnchors To anBottomRight
93789>>>>>>>
93789>>>>>>>        Procedure OnClick
93792>>>>>>>            Send Ok of oSelList
93793>>>>>>>        End_Procedure
93794>>>>>>>
93794>>>>>>>    End_Object
93795>>>>>>>
93795>>>>>>>    Object oCancel_Btn is a Button
93797>>>>>>>        Set Size to 14 50
93798>>>>>>>        Set Label    to "&Cancel"
93799>>>>>>>        Set Location to 98 123
93800>>>>>>>        Set peAnchors to anBottomRight
93801>>>>>>>
93801>>>>>>>        Procedure OnClick
93804>>>>>>>            Send Close_Panel
93805>>>>>>>        End_Procedure
93806>>>>>>>
93806>>>>>>>    End_Object
93807>>>>>>>
93807>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
93808>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
93809>>>>>>>End_Object
93810>>>>>Use cRDCHeaderGroup.pkg  
Including file: cRDCHeaderGroup.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCHeaderGroup.pkg)
93810>>>>>>>//****************************************************************************
93810>>>>>>>// $Module type: Package
93810>>>>>>>// $Module name: cRDCHeaderGroup.pkg
93810>>>>>>>//
93810>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
93810>>>>>>>// Copyright (c) 2017 RDC Tools International
93810>>>>>>>// E-mail      : support@rdctools.com
93810>>>>>>>// Web-site    : http://www.rdctools.com
93810>>>>>>>//
93810>>>>>>>// Created     : 2017-01-05 @ 19:04 (Military date format - Year-Month-Day)
93810>>>>>>>//
93810>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
93810>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
93810>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
93810>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
93810>>>>>>>// in the help folder for more details.
93810>>>>>>>//
93810>>>>>>>//****************************************************************************
93810>>>>>>>Use Windows.pkg
93810>>>>>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCommandLinkButton.pkg)
93810>>>>>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
93810>>>>>>>>>// older versions you will just get a regular great big button.
93810>>>>>>>>>
93810>>>>>>>>>Use Windows.pkg
93810>>>>>>>>>Use CharTranslate.pkg
93810>>>>>>>>>
93810>>>>>>>>>Class cCommandLinkButton is a Button
93811>>>>>>>>>    
93811>>>>>>>>>    Procedure Construct_Object
93813>>>>>>>>>        Forward Send Construct_Object
93815>>>>>>>>>        Property String psPrivateNote
93816>>>>>>>>>    End_Procedure
93817>>>>>>>>>    
93817>>>>>>>>>    Procedure Set psNote String sNote
93819>>>>>>>>>        Boolean bSupported
93819>>>>>>>>>        Set psPrivateNote to sNote
93820>>>>>>>>>        Get IsExControlSupported to bSupported
93821>>>>>>>>>        If bSupported Begin
93823>>>>>>>>>            Send SetWinNote
93824>>>>>>>>>        End
93824>>>>>>>>>>
93824>>>>>>>>>    End_Procedure
93825>>>>>>>>>    
93825>>>>>>>>>    Procedure SetWinNote
93827>>>>>>>>>        WString wNote
93827>>>>>>>>>        Handle hWnd
93827>>>>>>>>>        Integer i
93827>>>>>>>>>        Pointer pVar
93827>>>>>>>>>        Get Form_Window_Handle 0 to hWnd
93828>>>>>>>>>        If hWnd Begin
93830>>>>>>>>>            Get psNote to wNote
93831>>>>>>>>>            Move (SendMessage(hwnd, BCM_SETNOTE, 0, AddressOf(wNote))) to i
93832>>>>>>>>>        End
93832>>>>>>>>>>
93832>>>>>>>>>    End_Procedure
93833>>>>>>>>>    
93833>>>>>>>>>    
93833>>>>>>>>>    Function psNote Returns String
93835>>>>>>>>>        Function_Return (psPrivateNote(Self))
93836>>>>>>>>>    End_Function
93837>>>>>>>>>    
93837>>>>>>>>>    
93837>>>>>>>>>    Procedure Page Integer iState
93839>>>>>>>>>        Integer i hWnd
93839>>>>>>>>>        Boolean bSupported
93839>>>>>>>>>        Get IsExControlSupported to bSupported
93840>>>>>>>>>        If (iState=1 and bSupported) Begin
93842>>>>>>>>>            Get form_style i to i
93843>>>>>>>>>            Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
93844>>>>>>>>>            Forward Send Page iState
93846>>>>>>>>>            Send SetWinNote
93847>>>>>>>>>        End
93847>>>>>>>>>>
93847>>>>>>>>>        Else Begin
93848>>>>>>>>>            Forward Send Page iState
93850>>>>>>>>>        End
93850>>>>>>>>>>
93850>>>>>>>>>    End_Procedure
93851>>>>>>>>>    
93851>>>>>>>>>End_Class
93852>>>>>>>
93852>>>>>>>Define clGreenGrey      for (RGB(64, 84, 93))
93852>>>>>>>Define clGreenGreyLight for (RGB(7, 117, 104))
93852>>>>>>>
93852>>>>>>>Class cRDCHeaderGroupImage is a cCommandLinkButton
93853>>>>>>>    Procedure Construct_Object
93855>>>>>>>        Forward Send Construct_Object
93857>>>>>>>
93857>>>>>>>        Set Size to 18 19
93858>>>>>>>        Set Focus_Mode to NonFocusable
93859>>>>>>>        Set peImageAlign to Button_ImageList_Align_Top
93860>>>>>>>        Set pbAutoResizeIcons to True
93861>>>>>>>    End_Procedure
93862>>>>>>>
93862>>>>>>>    Procedure OnClick
93864>>>>>>>        Broadcast Send Prompt of (Parent(Self))
93866>>>>>>>    End_Procedure
93867>>>>>>>
93867>>>>>>>    Procedure Set Bitmap String sBitmapName
93869>>>>>>>        Forward Set psImage to sBitmapName
93871>>>>>>>    End_Procedure
93872>>>>>>>
93872>>>>>>>    Procedure End_Construct_Object
93874>>>>>>>        Set pbShield to False
93875>>>>>>>        Forward Send End_Construct_Object
93877>>>>>>>    End_Procedure
93878>>>>>>>
93878>>>>>>>End_Class
93879>>>>>>>
93879>>>>>>>// Intermediate class - don't use.
93879>>>>>>>Class _cRDCHeaderGroup is a Container3d
93880>>>>>>>
93880>>>>>>>    Procedure Construct_Object
93882>>>>>>>        Forward Send Construct_Object
93884>>>>>>>
93884>>>>>>>        Property String private.psImage
93885>>>>>>>        Property String private.psLabel
93886>>>>>>>
93886>>>>>>>    End_Procedure
93887>>>>>>>
93887>>>>>>>    Procedure Set psImage String sImage
93889>>>>>>>        Set private.psImage to sImage
93890>>>>>>>    End_Procedure
93891>>>>>>>
93891>>>>>>>    Function psImage Returns String
93893>>>>>>>        Function_Return (private.psImage(Self))
93894>>>>>>>    End_Function
93895>>>>>>>
93895>>>>>>>    Procedure Set psLabel String sLabel
93897>>>>>>>        Set private.psLabel to sLabel
93898>>>>>>>    End_Procedure
93899>>>>>>>
93899>>>>>>>    Function psLabel Returns String
93901>>>>>>>        Function_Return (private.psLabel(Self))
93902>>>>>>>    End_Function
93903>>>>>>>
93903>>>>>>>    // Don't display but allow to use old "Label" syntax to set the value of the oInfo_tb object (header text)
93903>>>>>>>    Procedure Set Label String sLabel
93905>>>>>>>        Set psLabel to sLabel
93906>>>>>>>    End_Procedure
93907>>>>>>>
93907>>>>>>>    Function Label Returns String
93909>>>>>>>        Function_Return (private.psLabel(Self))
93910>>>>>>>    End_Function
93911>>>>>>>
93911>>>>>>>End_Class
93912>>>>>>>
93912>>>>>>>Register_Procedure NavigatePrevious
93912>>>>>>>Register_Procedure NavigateNext
93912>>>>>>>
93912>>>>>>>Class cRDCHeaderGroup is a _cRDCHeaderGroup
93913>>>>>>>
93913>>>>>>>    Procedure Construct_Object
93915>>>>>>>        Forward Send Construct_Object
93917>>>>>>>
93917>>>>>>>        Set peAnchors to anTopLeftRight
93918>>>>>>>        Set pbAcceptDropFiles to True
93919>>>>>>>        Set Border_Style to Border_Normal
93920>>>>>>>
93920>>>>>>>        Property Integer private.piColorOrg
93921>>>>>>>        Property Boolean private.pbIsHeaderGroup True // Don't touch!
93922>>>>>>>        Property String private.psToolTip ""
93923>>>>>>>
93923>>>>>>>        Property Integer piImageColOffset 4
93924>>>>>>>        Property Integer piImageRowOffset -1
93925>>>>>>>        Property String psNote ""
93926>>>>>>>        Property Boolean pbLargeImageSize True
93927>>>>>>>        Property Integer private.piLargeImageSize 24
93928>>>>>>>        Property Integer private.piSmallImageSize 16
93929>>>>>>>        Property Boolean pbUseHotspotColor False
93930>>>>>>>        Property Integer piHeaderHotspotColor clAqua
93931>>>>>>>        Property String private.psLabel ""
93932>>>>>>>        Property Integer piLabelColor clGreenGrey
93933>>>>>>>        Property Boolean pbLabelFontItalics False
93934>>>>>>>        Property Integer piLabelLargeFontHeight 12
93935>>>>>>>        Property Integer piLabelSmallFontHeight 10
93936>>>>>>>        Property Boolean pbUseLargeFontHeight False
93937>>>>>>>
93937>>>>>>>        Property Integer piLabelFontPointWeight fw_Bold
93938>>>>>>>        Property Integer piLabelColOffset 28
93939>>>>>>>        Property Integer piLabelRowOffset 4
93940>>>>>>>        Property Boolean pbCreateTooltipItem True
93941>>>>>>>
93941>>>>>>>        Set pbAcceptDropFiles to True
93942>>>>>>>
93942>>>>>>>        Send Define_ToolTip_Support_Mixin
93943>>>>>>>
93943>>>>>>>        // For the Studio to render the header image
93943>>>>>>>        Set Bitmap to "Default32x32.bmp"
93944>>>>>>>        // This doesn't work... I wonder if there's a way to "trick" the Studio
93944>>>>>>>        // to render some text in the header when in design mode?
93944>>>>>>>        Set Label to "HEADER TEXT"
93945>>>>>>>
93945>>>>>>>        On_Key kLeftArrow  Send NavigatePrevious
93946>>>>>>>        On_Key kUpArrow    Send NavigatePrevious
93947>>>>>>>        On_Key kRightArrow Send NavigateNext
93948>>>>>>>        On_Key kDownArrow  Send NavigateNext
93949>>>>>>>        On_Key kSwitch     Send Switch_Next_Area
93950>>>>>>>    End_Procedure
93951>>>>>>>
93951>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
93952>>>>>>>
93952>>>>>>>    Procedure Set psImage String sImage
93954>>>>>>>        Set Bitmap to ""
93955>>>>>>>        Forward Set psImage to sImage
93957>>>>>>>    End_Procedure
93958>>>>>>>
93958>>>>>>>    Function psImage Returns String
93960>>>>>>>        Function_Return (psImage(Self))
93961>>>>>>>    End_Function
93962>>>>>>>
93962>>>>>>>    Procedure Set Label String sLabel
93964>>>>>>>        Forward Set psLabel to sLabel
93966>>>>>>>    End_Procedure
93967>>>>>>>
93967>>>>>>>    Procedure Set psToolTip String sToolTip
93969>>>>>>>        Set private.psToolTip to sToolTip
93970>>>>>>>    End_Procedure
93971>>>>>>>
93971>>>>>>>    Function psToolTip Returns String
93973>>>>>>>        Function_Return (private.psToolTip(Self))
93974>>>>>>>    End_Function
93975>>>>>>>
93975>>>>>>>    Procedure End_Construct_Object
93977>>>>>>>        String sNote sLabel
93977>>>>>>>        Boolean bUseLargeFontHeight bLargeImageSize bCreateTooltipItem
93977>>>>>>>        Integer iFontHeight iImageSize iLabelRowOffset iLabelColOffset iSize iTextOffset
93977>>>>>>>
93977>>>>>>>        Forward Send End_Construct_Object
93979>>>>>>>
93979>>>>>>>        Get piLabelColOffset to iLabelColOffset
93980>>>>>>>        Get pbUseLargeFontHeight to bUseLargeFontHeight
93981>>>>>>>        If (bUseLargeFontHeight = True) Begin
93983>>>>>>>            Get piLabelLargeFontHeight to iFontHeight
93984>>>>>>>            Move 8 to iLabelRowOffset
93985>>>>>>>        End
93985>>>>>>>>
93985>>>>>>>        Else Begin
93986>>>>>>>            Get piLabelSmallFontHeight to iFontHeight
93987>>>>>>>            Move 6 to iLabelRowOffset
93988>>>>>>>        End
93988>>>>>>>>
93988>>>>>>>
93988>>>>>>>        Get pbLargeImageSize to bLargeImageSize
93989>>>>>>>        If (bLargeImageSize = True) Begin
93991>>>>>>>            Get private.piLargeImageSize to iImageSize
93992>>>>>>>        End
93992>>>>>>>>
93992>>>>>>>        Else Begin
93993>>>>>>>            Get private.piSmallImageSize to iImageSize
93994>>>>>>>            Move (iLabelColOffset - 6) to iLabelColOffset
93995>>>>>>>        End
93995>>>>>>>>
93995>>>>>>>
93995>>>>>>>        Object oHeaderGroupImage is a cRDCHeaderGroupImage
93997>>>>>>>            Set piImageSize to iImageSize
93998>>>>>>>            Set Location to (piImageRowOffset(Self)) (piImageColOffset(Self))
93999>>>>>>>            Set psImage to (private.psImage(Self))
94000>>>>>>>            Set peImageAlign to Button_ImageList_Align_Center
94001>>>>>>>            Set psToolTip to (private.psToolTip(Self))
94002>>>>>>>        End_Object
94003>>>>>>>
94003>>>>>>>        Object oHeaderGroupInfo_tb is a TextBox
94005>>>>>>>            Set Size to 12 100
94006>>>>>>>            Set Location to (piLabelRowOffset(Self)) iLabelColOffset
94007>>>>>>>            Set FontWeight to (piLabelFontPointWeight(Self))
94008>>>>>>>            Set FontItalics to (pbLabelFontItalics(Self))
94009>>>>>>>            Set FontPointHeight to iFontHeight
94010>>>>>>>            Set Label to (private.psLabel(Self))
94011>>>>>>>            Set TextColor to (piLabelColor(Self))
94012>>>>>>>            Set psToolTip to (private.psToolTip(Self))
94013>>>>>>>            Get Size to iSize
94014>>>>>>>        End_Object
94015>>>>>>>
94015>>>>>>>        // ToDo: The positioning logic for placing the info image to the right of the header text is flawed.
94015>>>>>>>        // How can it be improved?
94015>>>>>>>        Get pbCreateTooltipItem to bCreateTooltipItem
94016>>>>>>>        If (bCreateTooltipItem = True and private.psToolTip(Self) <> "") Begin
94018>>>>>>>            Get private.psLabel to sLabel
94019>>>>>>>            Get Text_Extent sLabel to iTextOffset
94020>>>>>>>            Move (Low(iTextOffset) -0)  to iTextOffset
94021>>>>>>>            Object oHeaderGroupTooltip_tb is a TextBox
94023>>>>>>>                Set Size to 10 10
94024>>>>>>>                If (bUseLargeFontHeight = True) Begin
94026>>>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset //(Low(iSize) + (iTextOffset))
94026>>>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + (iLabelColOffset * 2) + 10)
94027>>>>>>>                End
94027>>>>>>>>
94027>>>>>>>                Else Begin
94028>>>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset
94028>>>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + iLabelColOffset + 25)
94029>>>>>>>                End
94029>>>>>>>>
94029>>>>>>>                Set psToolTip to (private.psToolTip(Self))
94030>>>>>>>                Set Bitmap to "ActionAbout.bmp"
94031>>>>>>>            End_Object
94032>>>>>>>        End
94032>>>>>>>>
94032>>>>>>>
94032>>>>>>>        Get psNote to sNote
94033>>>>>>>        If (Trim(sNote) <> "") Begin
94035>>>>>>>            Object oHeaderGroupNote_tb is a TextBox
94037>>>>>>>                Set Size to 12 100
94038>>>>>>>                Set Location to (Hi(iSize) + iLabelRowOffset) (iLabelColOffset + 8)
94039>>>>>>>                Set Label to ("-" * String(sNote))
94040>>>>>>>                Set TextColor to (piLabelColor(Self))
94041>>>>>>>                Set FontPointHeight to 9
94042>>>>>>>                Set psToolTip to (private.psToolTip(Self))
94043>>>>>>>            End_Object
94044>>>>>>>        End
94044>>>>>>>>
94044>>>>>>>
94044>>>>>>>    End_Procedure
94045>>>>>>>
94045>>>>>>>    Function Popup_State Returns Boolean
94047>>>>>>>        Boolean bIsPopup
94047>>>>>>>        Get Popup_State of (Parent(Self)) to bIsPopup
94048>>>>>>>        Function_Return bIsPopup
94049>>>>>>>    End_Function
94050>>>>>>>
94050>>>>>>>    Procedure OnEnterArea Handle hoFrom
94052>>>>>>>        Integer iColor
94052>>>>>>>        Forward Send OnEnterArea hoFrom
94054>>>>>>>        // Not ideal, but works most of the time.
94054>>>>>>>        //       When navigating to i.e a popup we don't want
94054>>>>>>>        //       the coloring to appear. Else there will be 2
94054>>>>>>>        //       cRDCHeaderGroup's with the highlight color...
94054>>>>>>>        // Is there a better way?
94054>>>>>>>        If (hoFrom <> Desktop and hoFrom < Parent(Self)) Begin
94056>>>>>>>            Procedure_Return
94057>>>>>>>        End
94057>>>>>>>>
94057>>>>>>>        If (pbUseHotspotColor(Self) = True) Begin
94059>>>>>>>            Get Color to iColor
94060>>>>>>>            Set private.piColorOrg to iColor
94061>>>>>>>            Get piHeaderHotspotColor to iColor
94062>>>>>>>            Set Color to iColor
94063>>>>>>>            Broadcast Recursive Set Color to iColor
94065>>>>>>>        End
94065>>>>>>>>
94065>>>>>>>    End_Procedure
94066>>>>>>>
94066>>>>>>>    Procedure OnExitArea Handle hoFrom
94068>>>>>>>        Integer iColor
94068>>>>>>>        Forward Send OnExitArea hoFrom
94070>>>>>>>        If (pbUseHotspotColor(Self) = True) Begin
94072>>>>>>>            Get private.piColorOrg to iColor
94073>>>>>>>            Set Color to iColor
94074>>>>>>>            Broadcast Recursive Set Color to iColor
94076>>>>>>>        End
94076>>>>>>>>
94076>>>>>>>    End_Procedure
94077>>>>>>>
94077>>>>>>>    // Public access message to change the group header text color at runtime.
94077>>>>>>>    Procedure Set Label_Color Integer iColor
94079>>>>>>>        Set TextColor of (oHeaderGroupInfo_tb(Self)) to iColor
94080>>>>>>>    End_Procedure
94081>>>>>>>
94081>>>>>>>    Procedure NavigatePrevious
94083>>>>>>>        Integer iMulti ivoid iLastErr
94083>>>>>>>        Handle hWnd
94083>>>>>>>        Boolean bErr
94083>>>>>>>
94083>>>>>>>        Move Err to bErr
94084>>>>>>>        Move LastErr to iLastErr
94085>>>>>>>
94085>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
94086>>>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
94087>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
94088>>>>>>>        If (Err) Begin
94090>>>>>>>            Move bErr to Err
94091>>>>>>>            Move iLastErr to LastErr
94092>>>>>>>            Procedure_Return
94093>>>>>>>        End
94093>>>>>>>>
94093>>>>>>>
94093>>>>>>>        Move bErr to Err
94094>>>>>>>        Move iLastErr to LastErr
94095>>>>>>>        If (iMulti = Multi_Select) Begin
94097>>>>>>>            Send Previous
94098>>>>>>>        End
94098>>>>>>>>
94098>>>>>>>        Else Begin
94099>>>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
94100>>>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
94101>>>>>>>        End
94101>>>>>>>>
94101>>>>>>>    End_Procedure
94102>>>>>>>
94102>>>>>>>    Procedure NavigateNext
94104>>>>>>>        Integer iMulti iVoid iLastErr
94104>>>>>>>        Handle hWnd
94104>>>>>>>        Boolean bErr
94104>>>>>>>
94104>>>>>>>        Move Err to bErr
94105>>>>>>>        Move LastErr to iLastErr
94106>>>>>>>
94106>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
94107>>>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
94108>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
94109>>>>>>>        If (Err) Begin
94111>>>>>>>            Move bErr to Err
94112>>>>>>>            Move iLastErr to LastErr
94113>>>>>>>            Procedure_Return
94114>>>>>>>        End
94114>>>>>>>>
94114>>>>>>>
94114>>>>>>>        Move bErr to Err
94115>>>>>>>        Move iLastErr to LastErr
94116>>>>>>>        If (iMulti = Multi_Select) Begin
94118>>>>>>>            Send Next
94119>>>>>>>        End
94119>>>>>>>>
94119>>>>>>>        Else Begin
94120>>>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
94121>>>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
94122>>>>>>>        End
94122>>>>>>>>
94122>>>>>>>
94122>>>>>>>    End_Procedure
94123>>>>>>>
94123>>>>>>>    Procedure Enable_Window Integer iState
94125>>>>>>>        Handle hWnd
94125>>>>>>>        Get Window_Handle to hWnd
94126>>>>>>>        If hWnd Begin
94128>>>>>>>            Move (EnableWindow(hWnd, iState)) to hWnd
94129>>>>>>>        End
94129>>>>>>>>
94129>>>>>>>    End_Procedure
94130>>>>>>>
94130>>>>>>>    Procedure Page_Object Integer iState
94132>>>>>>>        Handle hWnd
94132>>>>>>>        Get Window_Handle to hWnd
94133>>>>>>>        Forward Send Page_Object iState
94135>>>>>>>        If (hWnd = 0 and iState) Begin
94137>>>>>>>            Send Shadow_Display
94138>>>>>>>        End
94138>>>>>>>>
94138>>>>>>>    End_Procedure
94139>>>>>>>
94139>>>>>>>    Procedure Shadow_Display
94141>>>>>>>        Send Enable_Window (not(Object_Shadow_State(Self)))
94142>>>>>>>    End_Procedure
94143>>>>>>>
94143>>>>>>>    Function Explicit_Shadow_State Returns Boolean
94145>>>>>>>        Function_Return (Private.Explicit_Shadow_State(Self))
94146>>>>>>>    End_Function
94147>>>>>>>
94147>>>>>>>    // For some reason we need to augment this event to allow
94147>>>>>>>    // files to be dropped on a cRDCHeaderGroup object; else nothing will
94147>>>>>>>    // happen.
94147>>>>>>>    Procedure OnFileDropped String sFilename Boolean bLast
94149>>>>>>>        Delegate Send OnFileDropped sFilename bLast
94151>>>>>>>    End_Procedure
94152>>>>>>>
94152>>>>>>>End_Class
94153>>>>>>>
94153>>>>>>>// We don't want the broadcast of setting color to set the background
94153>>>>>>>// color for forms that are within a cRDCHeaderGroup object.
94153>>>>>>>// If the Form is not within a cRDCHeaderGroup the Form class should
94153>>>>>>>// behave as it always has. But if you don't like this; just comment
94153>>>>>>>// it out.
94153>>>>>>>//Procedure Set Color for Form Integer eColor
94153>>>>>>>//    Boolean bIsHeaderGroup bErr bEnabled_State
94153>>>>>>>//    Integer iLastErr
94153>>>>>>>//
94153>>>>>>>//    Move Err to bErr
94153>>>>>>>//    Move LastErr to iLastErr
94153>>>>>>>//
94153>>>>>>>//    Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
94153>>>>>>>//    Delegate Get private.pbIsHeaderGroup to bIsHeaderGroup
94153>>>>>>>//    Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
94153>>>>>>>//    Move bErr to Err
94153>>>>>>>//    Move iLastErr to LastErr
94153>>>>>>>//    If (bIsHeaderGroup = False) Begin
94153>>>>>>>//        Forward Set Color to eColor
94153>>>>>>>//    End
94153>>>>>>>//End_Procedure
94153>>>>>Use DriverSettings.dg
Including file: DriverSettings.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DriverSettings.dg)
94153>>>>>>>Use cApplication.pkg
94153>>>>>>>Use Dfline.pkg
94153>>>>>>>Use cRichEdit.pkg
94153>>>>>>>Use cScrollingContainer.pkg
Including file: cScrollingContainer.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cScrollingContainer.pkg)
94153>>>>>>>>>// Provides support for scrolling containers.
94153>>>>>>>>>// Scrolling containers is provided by creating two objects,
94153>>>>>>>>>// a host (cScrollingContainer) and a scrolling clientarea (cScrollingClientArea)
94153>>>>>>>>>// The host has no public interface, you just drop the object. It should have only one child object
94153>>>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
94153>>>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
94153>>>>>>>>>
94153>>>>>>>>>Use Windows.pkg
94153>>>>>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cScrollingContainerMixin.pkg)
94153>>>>>>>>>>>// Mixin classes for scrolling container support:
94153>>>>>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
94153>>>>>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
94153>>>>>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
94153>>>>>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
94153>>>>>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
94153>>>>>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
94153>>>>>>>>>>>
94153>>>>>>>>>>>Use Windows.pkg
94153>>>>>>>>>>>Use Winuser.pkg
94153>>>>>>>>>>>Use tWinStructs.pkg
94153>>>>>>>>>>>
94153>>>>>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
94153>>>>>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
94153>>>>>>>>>>>// support for the scrolling client area mixin object.
94153>>>>>>>>>>>
94153>>>>>>>>>>>Class cScrollingClientAreaMixin is a Mixin
94154>>>>>>>>>>>    
94154>>>>>>>>>>>    Procedure Define_cScrollingClientAreaMixin
94156>>>>>>>>>>>        
94156>>>>>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
94157>>>>>>>>>>>        Set Border_Style to Border_None
94158>>>>>>>>>>>        
94158>>>>>>>>>>>        Property Boolean pbAutoScroll True
94159>>>>>>>>>>>        Property Boolean pbAutoScrollFocus True
94160>>>>>>>>>>>        Property Integer piAutoScrollMarginX 5
94161>>>>>>>>>>>        Property Integer piAutoScrollMarginY 5
94162>>>>>>>>>>>        Property Integer piAutoScrollMinX 0
94163>>>>>>>>>>>        Property Integer piAutoScrollMinY 0
94164>>>>>>>>>>>        Property Boolean pbShowDisabledScrollBar False
94165>>>>>>>>>>>        
94165>>>>>>>>>>>        
94165>>>>>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
94166>>>>>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
94167>>>>>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
94168>>>>>>>>>>>        // keeps track of scrolling
94168>>>>>>>>>>>        Property Integer piCurrentVertScrolled 0
94169>>>>>>>>>>>        Property Integer piCurrentHorzScrolled 0
94170>>>>>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
94171>>>>>>>>>>>        Delegate Set phoScrollingClientArea to Self
94173>>>>>>>>>>>        
94173>>>>>>>>>>>        // set this true to make this a tabbed workspace view (design time)
94173>>>>>>>>>>>        Property Boolean pbTabWorkspaceView False
94174>>>>>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
94174>>>>>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
94175>>>>>>>>>>>    End_Procedure
94176>>>>>>>>>>>    
94176>>>>>>>>>>>    // low level event sent from windows.
94176>>>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
94178>>>>>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
94178>>>>>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
94179>>>>>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
94180>>>>>>>>>>>        If (wParam<0) Begin
94182>>>>>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
94183>>>>>>>>>>>        End
94183>>>>>>>>>>>>
94183>>>>>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
94184>>>>>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
94185>>>>>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
94185>>>>>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
94186>>>>>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
94187>>>>>>>>>>>        // If we have enough Clicks send OnMouseWheel
94187>>>>>>>>>>>        If (iClicks<>0) Begin
94189>>>>>>>>>>>            Send OnMouseWheel iClicks iKeys
94190>>>>>>>>>>>        End
94190>>>>>>>>>>>>
94190>>>>>>>>>>>        // tell windows that we've handled the event.
94190>>>>>>>>>>>        Set Windows_Override_State to True
94191>>>>>>>>>>>    End_Procedure
94192>>>>>>>>>>>    
94192>>>>>>>>>>>    
94192>>>>>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
94192>>>>>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
94194>>>>>>>>>>>        Integer iLineScrollUnit
94194>>>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
94195>>>>>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
94196>>>>>>>>>>>    End_Procedure
94197>>>>>>>>>>>    
94197>>>>>>>>>>>    // should be sent by WM_VSCROLL
94197>>>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
94199>>>>>>>>>>>        Boolean bOk
94199>>>>>>>>>>>        tWinScrollInfo ScrollInfo
94199>>>>>>>>>>>        tWinScrollInfo ScrollInfo
94199>>>>>>>>>>>        Integer iLineScrollUnit
94199>>>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
94200>>>>>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
94201>>>>>>>>>>>        If bOk Begin
94203>>>>>>>>>>>            
94203>>>>>>>>>>>            Case Begin
94203>>>>>>>>>>>                Case (iType=SB_PAGEDOWN)
94205>>>>>>>>>>>                    Send VScroll ScrollInfo.nPage
94206>>>>>>>>>>>                    Case Break
94207>>>>>>>>>>>                
94207>>>>>>>>>>>                Case (iType=SB_PAGEUP)
94210>>>>>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
94211>>>>>>>>>>>                    Case Break
94212>>>>>>>>>>>                
94212>>>>>>>>>>>                Case (iType=SB_LINEDOWN)
94215>>>>>>>>>>>                    Send VScroll iLineScrollUnit
94216>>>>>>>>>>>                    Case Break
94217>>>>>>>>>>>                
94217>>>>>>>>>>>                Case (iType=SB_LINEUP)
94220>>>>>>>>>>>                    Send VScroll (-iLineScrollUnit)
94221>>>>>>>>>>>                    Case Break
94222>>>>>>>>>>>                
94222>>>>>>>>>>>                Case (iType=SB_BOTTOM)
94225>>>>>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
94226>>>>>>>>>>>                    Case Break
94227>>>>>>>>>>>                
94227>>>>>>>>>>>                Case (iType=SB_Top)
94230>>>>>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
94231>>>>>>>>>>>                    Case Break
94232>>>>>>>>>>>                
94232>>>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
94235>>>>>>>>>>>                    Case Break
94236>>>>>>>>>>>                
94236>>>>>>>>>>>                Case (iType=SB_THUMBTRACK)
94239>>>>>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
94240>>>>>>>>>>>                    Case Break
94241>>>>>>>>>>>            Case End
94241>>>>>>>>>>>        End
94241>>>>>>>>>>>>
94241>>>>>>>>>>>    End_Procedure
94242>>>>>>>>>>>    
94242>>>>>>>>>>>    // should be sent by WM_HSCROLL
94242>>>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
94244>>>>>>>>>>>        Boolean bOk
94244>>>>>>>>>>>        tWinScrollInfo ScrollInfo
94244>>>>>>>>>>>        tWinScrollInfo ScrollInfo
94244>>>>>>>>>>>        Integer iLineScrollUnit
94244>>>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
94245>>>>>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
94246>>>>>>>>>>>        If bOk Begin
94248>>>>>>>>>>>            
94248>>>>>>>>>>>            Case Begin
94248>>>>>>>>>>>                Case (iType=SB_PAGEDOWN)
94250>>>>>>>>>>>                    Send hScroll ScrollInfo.nPage
94251>>>>>>>>>>>                    Case Break
94252>>>>>>>>>>>                
94252>>>>>>>>>>>                Case (iType=SB_PAGEUP)
94255>>>>>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
94256>>>>>>>>>>>                    Case Break
94257>>>>>>>>>>>                
94257>>>>>>>>>>>                Case (iType=SB_LINEDOWN)
94260>>>>>>>>>>>                    Send hScroll iLineScrollUnit
94261>>>>>>>>>>>                    Case Break
94262>>>>>>>>>>>                
94262>>>>>>>>>>>                Case (iType=SB_LINEUP)
94265>>>>>>>>>>>                    Send hScroll (-iLineScrollUnit)
94266>>>>>>>>>>>                    Case Break
94267>>>>>>>>>>>                
94267>>>>>>>>>>>                Case (iType=SB_BOTTOM)
94270>>>>>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
94271>>>>>>>>>>>                    Case Break
94272>>>>>>>>>>>                
94272>>>>>>>>>>>                Case (iType=SB_Top)
94275>>>>>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
94276>>>>>>>>>>>                    Case Break
94277>>>>>>>>>>>                
94277>>>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
94280>>>>>>>>>>>                    Case Break
94281>>>>>>>>>>>                
94281>>>>>>>>>>>                Case (iType=SB_THUMBTRACK)
94284>>>>>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
94285>>>>>>>>>>>                    Case Break
94286>>>>>>>>>>>            Case End
94286>>>>>>>>>>>        End
94286>>>>>>>>>>>>
94286>>>>>>>>>>>    End_Procedure
94287>>>>>>>>>>>    
94287>>>>>>>>>>>    
94287>>>>>>>>>>>    // this calls SetScrollInfo with proper info
94287>>>>>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
94289>>>>>>>>>>>        tWinScrollInfo ScrollInfo
94289>>>>>>>>>>>        tWinScrollInfo ScrollInfo
94289>>>>>>>>>>>        Integer iVoid
94289>>>>>>>>>>>        Handle hWnd
94289>>>>>>>>>>>        Boolean bShow
94289>>>>>>>>>>>        
94289>>>>>>>>>>>        Delegate Get Window_Handle to hWnd
94291>>>>>>>>>>>        If (hWnd <> 0) Begin
94293>>>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
94294>>>>>>>>>>>            
94294>>>>>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
94295>>>>>>>>>>>            Get pbShowDisabledScrollBar to bShow
94296>>>>>>>>>>>            If bShow Begin
94298>>>>>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
94299>>>>>>>>>>>            End
94299>>>>>>>>>>>>
94299>>>>>>>>>>>            Move iRangeMin to ScrollInfo.nMin
94300>>>>>>>>>>>            Move iRangeMax to ScrollInfo.nMax
94301>>>>>>>>>>>            Move iPageSize to ScrollInfo.nPage
94302>>>>>>>>>>>            Move 0 to ScrollInfo.nPos
94303>>>>>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
94304>>>>>>>>>>>            
94304>>>>>>>>>>>        End
94304>>>>>>>>>>>>
94304>>>>>>>>>>>    End_Procedure
94305>>>>>>>>>>>    
94305>>>>>>>>>>>    // this wraps GetScrollInfo
94305>>>>>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
94307>>>>>>>>>>>        Boolean bOk
94307>>>>>>>>>>>        Handle hWnd
94307>>>>>>>>>>>        
94307>>>>>>>>>>>        Delegate Get Window_Handle to hWnd
94309>>>>>>>>>>>        If (hWnd <> 0) Begin
94311>>>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
94312>>>>>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
94313>>>>>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
94314>>>>>>>>>>>        End
94314>>>>>>>>>>>>
94314>>>>>>>>>>>        Function_Return bOk
94315>>>>>>>>>>>    End_Function
94316>>>>>>>>>>>    
94316>>>>>>>>>>>    // this wraps SetScrollPos
94316>>>>>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
94318>>>>>>>>>>>        Integer iVoid
94318>>>>>>>>>>>        Handle hWnd
94318>>>>>>>>>>>        
94318>>>>>>>>>>>        Delegate Get Window_Handle to hWnd
94320>>>>>>>>>>>        If (hWnd <> 0) Begin
94322>>>>>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
94323>>>>>>>>>>>        End
94323>>>>>>>>>>>>
94323>>>>>>>>>>>    End_Procedure
94324>>>>>>>>>>>    
94324>>>>>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
94324>>>>>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
94324>>>>>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
94326>>>>>>>>>>>        Send ScrollClientArea
94327>>>>>>>>>>>    End_Procedure
94328>>>>>>>>>>>    
94328>>>>>>>>>>>    // augment to handle the scrolling area initialization.
94328>>>>>>>>>>>    Procedure Add_Focus Handle hoParent
94330>>>>>>>>>>>        Forward Send Add_Focus hoParent
94332>>>>>>>>>>>        // at this the scrolling container and client area should both be paged.
94332>>>>>>>>>>>        // child objects ae also paged with initial anchors applied
94332>>>>>>>>>>>        Send CalculateAutoScrollMinimums
94333>>>>>>>>>>>    End_Procedure
94334>>>>>>>>>>>    
94334>>>>>>>>>>>    Procedure Page Integer iPage
94336>>>>>>>>>>>        Forward Send Page iPage
94338>>>>>>>>>>>        If iPage Begin
94340>>>>>>>>>>>            // at this the scrolling container and client area should both be paged
94340>>>>>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
94340>>>>>>>>>>>            // the child items are paged (else they may get anchored oddly)
94340>>>>>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
94340>>>>>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
94340>>>>>>>>>>>            // before they were really needed. This should be more accurate
94340>>>>>>>>>>>            Send SetScrollBarInfo True 0 0 0
94341>>>>>>>>>>>            Send SetScrollBarInfo False 0 0 0
94342>>>>>>>>>>>        End
94342>>>>>>>>>>>>
94342>>>>>>>>>>>    End_Procedure
94343>>>>>>>>>>>    
94343>>>>>>>>>>>    // determine scrolling minimums and set the client area as required.
94343>>>>>>>>>>>    
94343>>>>>>>>>>>    Procedure CalculateAutoScrollMinimums
94345>>>>>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
94345>>>>>>>>>>>        Integer iAutoMinX iAutoMinY
94345>>>>>>>>>>>        Boolean bAutoScroll
94345>>>>>>>>>>>        Handle hoNext hoFirst
94345>>>>>>>>>>>        
94345>>>>>>>>>>>        Get pbAutoScroll to bAutoScroll
94346>>>>>>>>>>>        Get piAutoScrollMinX to iAutoMinX
94347>>>>>>>>>>>        Get piAutoScrollMinY to iAutoMinY
94348>>>>>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
94349>>>>>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
94350>>>>>>>>>>>        Move (Low(iSiz)) to iAutoMinX
94351>>>>>>>>>>>        Set piMinimumHeight to iAutoMinY
94352>>>>>>>>>>>        Set piMinimumWidth to iAutoMinX
94353>>>>>>>>>>>        
94353>>>>>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
94355>>>>>>>>>>>            
94355>>>>>>>>>>>            Get Next_Level to hoFirst
94356>>>>>>>>>>>            Move hoFirst to hoNext
94357>>>>>>>>>>>            If (hoFirst) Begin
94359>>>>>>>>>>>                Repeat
94359>>>>>>>>>>>>
94359>>>>>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
94360>>>>>>>>>>>                    Get GuiLocation of hoNext to iLoc
94361>>>>>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
94362>>>>>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
94363>>>>>>>>>>>                    Get Next_Focus of hoNext to hoNext
94364>>>>>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
94366>>>>>>>>>>>                
94366>>>>>>>>>>>                If (iAutoMinY=0) Begin
94368>>>>>>>>>>>                    Get piAutoScrollMarginY to iMargin
94369>>>>>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
94370>>>>>>>>>>>                End
94370>>>>>>>>>>>>
94370>>>>>>>>>>>                
94370>>>>>>>>>>>                If (iAutoMinX=0) Begin
94372>>>>>>>>>>>                    Get piAutoScrollMarginX to iMargin
94373>>>>>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
94374>>>>>>>>>>>                    
94374>>>>>>>>>>>                End
94374>>>>>>>>>>>>
94374>>>>>>>>>>>            End
94374>>>>>>>>>>>>
94374>>>>>>>>>>>        End
94374>>>>>>>>>>>>
94374>>>>>>>>>>>        
94374>>>>>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
94374>>>>>>>>>>>        Broadcast Set pbAnchorCreated to False
94376>>>>>>>>>>>        Send ScrollClientArea
94377>>>>>>>>>>>        // after the scroll set up, reinitialize all anchors.
94377>>>>>>>>>>>        Broadcast Send DoCreateAnchors
94379>>>>>>>>>>>    End_Procedure
94380>>>>>>>>>>>    
94380>>>>>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
94380>>>>>>>>>>>    // work of scrolling.
94380>>>>>>>>>>>    
94380>>>>>>>>>>>    Procedure ScrollClientArea
94382>>>>>>>>>>>        Integer iSiz
94382>>>>>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
94382>>>>>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
94382>>>>>>>>>>>        Integer iSzY iSzX iLocX iLocY
94382>>>>>>>>>>>        
94382>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
94384>>>>>>>>>>>        Move (Hi(iSiz)) to iHeight
94385>>>>>>>>>>>        Move (Low(iSiz)) to iWidth
94386>>>>>>>>>>>        
94386>>>>>>>>>>>        // Vertical scrolling
94386>>>>>>>>>>>        
94386>>>>>>>>>>>        Get piMinimumHeight to iOrig
94387>>>>>>>>>>>        Get piMinimumWidth to iWOrig
94388>>>>>>>>>>>        
94388>>>>>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
94390>>>>>>>>>>>            
94390>>>>>>>>>>>            If (iOrig<>0) Begin
94392>>>>>>>>>>>                Get piCurrentVertScrolled to iHCur
94393>>>>>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
94393>>>>>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
94395>>>>>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
94396>>>>>>>>>>>                    Set piCurrentVertScrolled to iHCur
94397>>>>>>>>>>>                End
94397>>>>>>>>>>>>
94397>>>>>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
94399>>>>>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
94400>>>>>>>>>>>                    Send SetScrollBarPosInfo True iHCur
94401>>>>>>>>>>>                End
94401>>>>>>>>>>>>
94401>>>>>>>>>>>                Else Begin
94402>>>>>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
94403>>>>>>>>>>>                End
94403>>>>>>>>>>>>
94403>>>>>>>>>>>            End
94403>>>>>>>>>>>>
94403>>>>>>>>>>>            
94403>>>>>>>>>>>            // Horiz scrolling
94403>>>>>>>>>>>            
94403>>>>>>>>>>>            Get piCurrentHorzScrolled to iWCur
94404>>>>>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
94404>>>>>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
94406>>>>>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
94407>>>>>>>>>>>                Set piCurrentHorzScrolled to iWCur
94408>>>>>>>>>>>            End
94408>>>>>>>>>>>>
94408>>>>>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
94410>>>>>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
94411>>>>>>>>>>>                Send SetScrollBarPosInfo False iWCur
94412>>>>>>>>>>>            End
94412>>>>>>>>>>>>
94412>>>>>>>>>>>            Else Begin
94413>>>>>>>>>>>                Send SetScrollBarInfo False 0 0 0
94414>>>>>>>>>>>            End
94414>>>>>>>>>>>>
94414>>>>>>>>>>>        End
94414>>>>>>>>>>>>
94414>>>>>>>>>>>        
94414>>>>>>>>>>>        // this could change depending on scrollbars appearing or not
94414>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
94416>>>>>>>>>>>        
94416>>>>>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
94416>>>>>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
94416>>>>>>>>>>>        // This is required to make anchors work sensibly
94416>>>>>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
94417>>>>>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
94418>>>>>>>>>>>        Move (-iHCur) to iLocY
94419>>>>>>>>>>>        Move (-iWCur) to iLocX
94420>>>>>>>>>>>        
94420>>>>>>>>>>>        // Allow chance to make modifications
94420>>>>>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
94421>>>>>>>>>>>        
94421>>>>>>>>>>>        Set GuiSize to iSzY iSzX
94422>>>>>>>>>>>        // if we've scrolled, we need to reposition the container
94422>>>>>>>>>>>        Set GuiLocation to iLocY iLocX
94423>>>>>>>>>>>    End_Procedure
94424>>>>>>>>>>>    
94424>>>>>>>>>>>    // note that scrolling never changes the size of the scrolling client.
94424>>>>>>>>>>>    // this way, it does not interfere with anchors.
94424>>>>>>>>>>>    
94424>>>>>>>>>>>    Procedure VScroll Integer iDelta
94426>>>>>>>>>>>        Integer iHeight iCur iOrig iSiz
94426>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
94428>>>>>>>>>>>        Move (hi(iSiz)) to iHeight
94429>>>>>>>>>>>        Get piCurrentVertScrolled to iCur
94430>>>>>>>>>>>        Get piMinimumHeight to iOrig
94431>>>>>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
94433>>>>>>>>>>>            Procedure_Return
94434>>>>>>>>>>>        End
94434>>>>>>>>>>>>
94434>>>>>>>>>>>        // make sure delta is within range
94434>>>>>>>>>>>        If (iDelta+iCur<0) Begin
94436>>>>>>>>>>>            Move (-iCur) to iDelta
94437>>>>>>>>>>>        End
94437>>>>>>>>>>>>
94437>>>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
94440>>>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
94441>>>>>>>>>>>        End
94441>>>>>>>>>>>>
94441>>>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
94444>>>>>>>>>>>        
94444>>>>>>>>>>>        Move (iCur + iDelta) to iCur
94445>>>>>>>>>>>        Set piCurrentVertScrolled to iCur
94446>>>>>>>>>>>        Send SetScrollBarPosInfo True iCur
94447>>>>>>>>>>>        Get GuiLocation to iSiz
94448>>>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
94449>>>>>>>>>>>        Send ScrollClientArea
94450>>>>>>>>>>>    End_Procedure
94451>>>>>>>>>>>    
94451>>>>>>>>>>>    
94451>>>>>>>>>>>    Procedure HScroll Integer iDelta
94453>>>>>>>>>>>        Integer iHeight iCur iOrig iSiz
94453>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
94455>>>>>>>>>>>        Move (low(iSiz)) to iHeight
94456>>>>>>>>>>>        Get piCurrentHorzScrolled to iCur
94457>>>>>>>>>>>        Get piMinimumWidth to iOrig
94458>>>>>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
94460>>>>>>>>>>>            Procedure_Return
94461>>>>>>>>>>>        End
94461>>>>>>>>>>>>
94461>>>>>>>>>>>        If (iDelta+iCur<0) Begin
94463>>>>>>>>>>>            Move (-iCur) to iDelta
94464>>>>>>>>>>>        End
94464>>>>>>>>>>>>
94464>>>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
94467>>>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
94468>>>>>>>>>>>        End
94468>>>>>>>>>>>>
94468>>>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
94471>>>>>>>>>>>        
94471>>>>>>>>>>>        Move (iCur + iDelta) to iCur
94472>>>>>>>>>>>        Set piCurrentHorzScrolled to iCur
94473>>>>>>>>>>>        Send SetScrollBarPosInfo False iCur
94474>>>>>>>>>>>        Get GuiLocation to iSiz
94475>>>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
94476>>>>>>>>>>>        Send ScrollClientArea
94477>>>>>>>>>>>    End_Procedure
94478>>>>>>>>>>>    
94478>>>>>>>>>>>    // make sure client is a 0,0
94478>>>>>>>>>>>    Procedure ScrollHome
94480>>>>>>>>>>>        Send SetVScrollbox SB_TOP 0
94481>>>>>>>>>>>        Send SetHScrollbox SB_TOP 0
94482>>>>>>>>>>>    End_Procedure
94483>>>>>>>>>>>    
94483>>>>>>>>>>>    // get relative GUI location of this object to the parent one passed.
94483>>>>>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
94485>>>>>>>>>>>        Integer ivoid
94485>>>>>>>>>>>        tWinRect Rect0 Rect1
94485>>>>>>>>>>>        tWinRect Rect0 Rect1
94485>>>>>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
94486>>>>>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
94487>>>>>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
94488>>>>>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
94489>>>>>>>>>>>    End_Procedure
94490>>>>>>>>>>>    
94490>>>>>>>>>>>    // This scrolls this object into visual range.
94490>>>>>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
94492>>>>>>>>>>>        Handle hoScrollingContainer
94492>>>>>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
94492>>>>>>>>>>>        Integer iViewHeight iViewWidth
94492>>>>>>>>>>>        Integer iRelLocHeight iRelLocWidth
94492>>>>>>>>>>>        Integer iSize iControlHeight iControlWidth
94492>>>>>>>>>>>        Integer iScroll
94492>>>>>>>>>>>        Integer iMarginX iMarginY
94492>>>>>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
94492>>>>>>>>>>>        
94492>>>>>>>>>>>        Get piAutoScrollMarginX to iMarginX
94493>>>>>>>>>>>        Get piAutoScrollMarginY to iMarginY
94494>>>>>>>>>>>        
94494>>>>>>>>>>>        // the scrolling container
94494>>>>>>>>>>>        Move Self to hoScrollingContainer
94495>>>>>>>>>>>        // the amount the SC is currently scrolled
94495>>>>>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
94496>>>>>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
94497>>>>>>>>>>>        
94497>>>>>>>>>>>        // size of view's client area (this is the viewport area)
94497>>>>>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
94498>>>>>>>>>>>        Move (hi(iSize)) to iViewHeight
94499>>>>>>>>>>>        Move (low(iSize)) to iViewWidth
94500>>>>>>>>>>>        
94500>>>>>>>>>>>        // get this object's location relative to the scrolling container
94500>>>>>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
94501>>>>>>>>>>>        
94501>>>>>>>>>>>        // we expect that the client size is the window size but just in case
94501>>>>>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
94502>>>>>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
94503>>>>>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
94504>>>>>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
94505>>>>>>>>>>>        
94505>>>>>>>>>>>        // the outer size of the control object
94505>>>>>>>>>>>        Get GUIWindowSize of hoControl to iSize
94506>>>>>>>>>>>        Move (hi(iSize)) to iControlHeight
94507>>>>>>>>>>>        Move (low(iSize)) to iControlWidth
94508>>>>>>>>>>>        
94508>>>>>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
94508>>>>>>>>>>>        
94508>>>>>>>>>>>        // Vertical Scroll
94508>>>>>>>>>>>        
94508>>>>>>>>>>>        // Vertical Scroll down
94508>>>>>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
94508>>>>>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
94510>>>>>>>>>>>            
94510>>>>>>>>>>>            // set scroll amount so that the bottom of the control is visible
94510>>>>>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
94511>>>>>>>>>>>            
94511>>>>>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
94511>>>>>>>>>>>            // top of the object appears at the bottom
94511>>>>>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
94513>>>>>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
94514>>>>>>>>>>>            End
94514>>>>>>>>>>>>
94514>>>>>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
94514>>>>>>>>>>>            If (iScroll>0) Begin
94516>>>>>>>>>>>                Send VScroll of hoScrollingContainer iScroll
94517>>>>>>>>>>>            End
94517>>>>>>>>>>>>
94517>>>>>>>>>>>        End
94517>>>>>>>>>>>>
94517>>>>>>>>>>>        // else vertical scroll up
94517>>>>>>>>>>>        // We scroll if the top of the object is not visible.
94517>>>>>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
94520>>>>>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
94520>>>>>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
94521>>>>>>>>>>>            If (iScroll<0) Begin
94523>>>>>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
94524>>>>>>>>>>>            End
94524>>>>>>>>>>>>
94524>>>>>>>>>>>        End
94524>>>>>>>>>>>>
94524>>>>>>>>>>>        
94524>>>>>>>>>>>        // Horizonal Scroll
94524>>>>>>>>>>>        
94524>>>>>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
94524>>>>>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
94526>>>>>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
94527>>>>>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
94529>>>>>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
94530>>>>>>>>>>>            End
94530>>>>>>>>>>>>
94530>>>>>>>>>>>            If (iScroll>0) Begin
94532>>>>>>>>>>>                Send HScroll of hoScrollingContainer iScroll
94533>>>>>>>>>>>            End
94533>>>>>>>>>>>>
94533>>>>>>>>>>>        End
94533>>>>>>>>>>>>
94533>>>>>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
94535>>>>>>>>>>>            // if this can fit by moving all the way to left, do so.
94535>>>>>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
94537>>>>>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
94538>>>>>>>>>>>            End
94538>>>>>>>>>>>>
94538>>>>>>>>>>>            Else Begin
94539>>>>>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
94540>>>>>>>>>>>            End
94540>>>>>>>>>>>>
94540>>>>>>>>>>>            If (iScroll<0) Begin
94542>>>>>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
94543>>>>>>>>>>>            End
94543>>>>>>>>>>>>
94543>>>>>>>>>>>        End
94543>>>>>>>>>>>>
94543>>>>>>>>>>>        
94543>>>>>>>>>>>        
94543>>>>>>>>>>>    End_Procedure
94544>>>>>>>>>>>    
94544>>>>>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
94544>>>>>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
94546>>>>>>>>>>>        Boolean bScrollOnFocus
94546>>>>>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
94547>>>>>>>>>>>        If bScrollOnFocus Begin
94549>>>>>>>>>>>            Send ScrollObjectInRange hoControl
94550>>>>>>>>>>>        End
94550>>>>>>>>>>>>
94550>>>>>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
94552>>>>>>>>>>>    End_Procedure
94553>>>>>>>>>>>    
94553>>>>>>>>>>>    
94553>>>>>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
94555>>>>>>>>>>>        Boolean bCenter
94555>>>>>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
94556>>>>>>>>>>>        Function_Return bCenter
94557>>>>>>>>>>>    End_Function
94558>>>>>>>>>>>    
94558>>>>>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
94560>>>>>>>>>>>        Boolean bTabWorkspaceView
94560>>>>>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
94561>>>>>>>>>>>        If bTabWorkspaceView Begin
94563>>>>>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
94564>>>>>>>>>>>        End
94564>>>>>>>>>>>>
94564>>>>>>>>>>>    End_Procedure
94565>>>>>>>>>>>    
94565>>>>>>>>>>>    Function ParentView Returns Handle
94567>>>>>>>>>>>        Function_Return (Parent(Parent(Self)))
94568>>>>>>>>>>>    End_Function
94569>>>>>>>>>>>    
94569>>>>>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
94571>>>>>>>>>>>        Integer iSize iMax iDiff
94571>>>>>>>>>>>        Handle hoView
94571>>>>>>>>>>>        Boolean bCenter bModal
94571>>>>>>>>>>>        Get ParentView to hoView
94572>>>>>>>>>>>        Get Block_Mouse_State of hoView to bModal
94573>>>>>>>>>>>        If not bModal Begin
94575>>>>>>>>>>>            Get CenterTabWorkspaceView to bCenter
94576>>>>>>>>>>>            Get GuiSize of hoView to iSize
94577>>>>>>>>>>>            Get piMaxSize of hoView to iMax
94578>>>>>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
94579>>>>>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
94581>>>>>>>>>>>                If bCenter Begin
94583>>>>>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
94584>>>>>>>>>>>                End
94584>>>>>>>>>>>>
94584>>>>>>>>>>>                Move (Low(iMax)) to iWidth
94585>>>>>>>>>>>            End
94585>>>>>>>>>>>>
94585>>>>>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
94587>>>>>>>>>>>                If bCenter Begin
94589>>>>>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
94590>>>>>>>>>>>                    Move (iLocy min 25) to  iLocY
94591>>>>>>>>>>>                End
94591>>>>>>>>>>>>
94591>>>>>>>>>>>                Move (Hi(imax)) to iHeight
94592>>>>>>>>>>>            End
94592>>>>>>>>>>>>
94592>>>>>>>>>>>        End
94592>>>>>>>>>>>>
94592>>>>>>>>>>>    End_Procedure
94593>>>>>>>>>>>    
94593>>>>>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
94593>>>>>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
94593>>>>>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
94593>>>>>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
94593>>>>>>>>>>>    // This should almost always yield the right answer.
94593>>>>>>>>>>>    // This is called by the scrolling container's end_constructor
94593>>>>>>>>>>>    Procedure AutoSetTabWorkspaceView
94595>>>>>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
94595>>>>>>>>>>>        Handle hoParent
94595>>>>>>>>>>>        Integer iSize
94595>>>>>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
94596>>>>>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
94598>>>>>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
94599>>>>>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
94599>>>>>>>>>>>            // change this after the commandbar is paged.
94599>>>>>>>>>>>            If (bTabView) Begin
94601>>>>>>>>>>>                Get ParentView to hoParent
94602>>>>>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
94603>>>>>>>>>>>                If (bIsView) Begin
94605>>>>>>>>>>>                    // set this as a tab workspace view
94605>>>>>>>>>>>                    Set pbTabWorkspaceView to True
94606>>>>>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
94606>>>>>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
94606>>>>>>>>>>>                    Set pbAutoScroll to True
94607>>>>>>>>>>>                    
94607>>>>>>>>>>>                End
94607>>>>>>>>>>>>
94607>>>>>>>>>>>            End
94607>>>>>>>>>>>>
94607>>>>>>>>>>>        End
94607>>>>>>>>>>>>
94607>>>>>>>>>>>    End_Procedure
94608>>>>>>>>>>>    
94608>>>>>>>>>>>End_Class
94609>>>>>>>>>>>
94609>>>>>>>>>>>// Container scrolling class support. Nothing in here is public
94609>>>>>>>>>>>Class cScrollingContainerMixin is a Mixin
94610>>>>>>>>>>>    
94610>>>>>>>>>>>    Procedure Define_cScrollingContainerMixin
94612>>>>>>>>>>>        Forward Set Border_Style to Border_None
94614>>>>>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
94615>>>>>>>>>>>        Forward Set peAnchors to anAll
94617>>>>>>>>>>>        
94617>>>>>>>>>>>        // forcing scrollbars right away seems to make painting better
94617>>>>>>>>>>>        Set Window_Style WS_HSCROLL to True
94618>>>>>>>>>>>        Set Window_Style WS_VSCROLL to True
94619>>>>>>>>>>>        
94619>>>>>>>>>>>        Property Handle phoScrollingClientArea 0
94620>>>>>>>>>>>    End_Procedure
94621>>>>>>>>>>>    
94621>>>>>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
94621>>>>>>>>>>>    Procedure Set peAnchors Integer eAnchors
94623>>>>>>>>>>>    End_Procedure
94624>>>>>>>>>>>    
94624>>>>>>>>>>>    // if a border style is set, it will not work. We won't let that happen
94624>>>>>>>>>>>    Procedure Set Border_Style Integer eStyle
94626>>>>>>>>>>>    End_Procedure
94627>>>>>>>>>>>    
94627>>>>>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
94627>>>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
94629>>>>>>>>>>>        Handle hoClient
94629>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
94630>>>>>>>>>>>        If hoClient Begin
94632>>>>>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
94633>>>>>>>>>>>        End
94633>>>>>>>>>>>>
94633>>>>>>>>>>>    End_Procedure
94634>>>>>>>>>>>    
94634>>>>>>>>>>>    // should be sent by WM_VSCROLL
94634>>>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
94636>>>>>>>>>>>        Handle hoClient
94636>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
94637>>>>>>>>>>>        If hoClient Begin
94639>>>>>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
94640>>>>>>>>>>>        End
94640>>>>>>>>>>>>
94640>>>>>>>>>>>    End_Procedure
94641>>>>>>>>>>>    
94641>>>>>>>>>>>    // should be sent by WM_HSCROLL
94641>>>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
94643>>>>>>>>>>>        Handle hoClient
94643>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
94644>>>>>>>>>>>        If hoClient Begin
94646>>>>>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
94647>>>>>>>>>>>        End
94647>>>>>>>>>>>>
94647>>>>>>>>>>>    End_Procedure
94648>>>>>>>>>>>    
94648>>>>>>>>>>>    // augmented to adjust its size to the size of the parent client area.
94648>>>>>>>>>>>    // After this is set, anchors will handle any further resizing.
94648>>>>>>>>>>>    Procedure Page Integer iState
94650>>>>>>>>>>>        Integer iSiz iHeight iWidth
94650>>>>>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
94650>>>>>>>>>>>        Boolean bGroup
94650>>>>>>>>>>>        Handle hoClient
94650>>>>>>>>>>>        If (iState =1) Begin
94652>>>>>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
94654>>>>>>>>>>>            // We have special code to support groups because they
94654>>>>>>>>>>>            // draw a border inside of the client rectangle
94654>>>>>>>>>>>            If bGroup Begin
94656>>>>>>>>>>>                Get Physical_FontSize to iFontSize
94657>>>>>>>>>>>                Move (Hi(iFontSize)) to iTop
94658>>>>>>>>>>>                Move 2 to iLeft
94659>>>>>>>>>>>                Move 2 to iRight
94660>>>>>>>>>>>                Move 2 to iBottom
94661>>>>>>>>>>>            End
94661>>>>>>>>>>>>
94661>>>>>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
94661>>>>>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
94661>>>>>>>>>>>            // makes anchors work properly with unpaged tab-pages
94661>>>>>>>>>>>            Delegate Get GetContainerClientSize to iSiz
94663>>>>>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
94664>>>>>>>>>>>            Set GuiLocation to iTop iLeft
94665>>>>>>>>>>>            Send Adjust_Logicals
94666>>>>>>>>>>>        End
94666>>>>>>>>>>>>
94666>>>>>>>>>>>        Forward Send Page iState
94668>>>>>>>>>>>    End_Procedure
94669>>>>>>>>>>>    
94669>>>>>>>>>>>    Procedure End_Construct_Object
94671>>>>>>>>>>>        Handle hoClient
94671>>>>>>>>>>>        Forward Send End_Construct_Object
94673>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
94674>>>>>>>>>>>        If (hoClient) Begin
94676>>>>>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
94677>>>>>>>>>>>        End
94677>>>>>>>>>>>>
94677>>>>>>>>>>>    End_Procedure
94678>>>>>>>>>>>    
94678>>>>>>>>>>>End_Class
94679>>>>>>>>>
94679>>>>>>>>>Class cScrollingClientArea is a Container3d
94680>>>>>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
94681>>>>>>>>>    Procedure Construct_Object
94683>>>>>>>>>        Forward Send Construct_Object
94685>>>>>>>>>        Send Define_cScrollingClientAreaMixin
94686>>>>>>>>>    End_Procedure
94687>>>>>>>>>End_Class
94688>>>>>>>>>
94688>>>>>>>>>
94688>>>>>>>>>
94688>>>>>>>>>Class cScrollingContainer is a Container3d
94689>>>>>>>>>    Import_Class_Protocol cScrollingContainerMixin
94690>>>>>>>>>    Procedure Construct_Object
94692>>>>>>>>>        Forward Send Construct_Object
94694>>>>>>>>>        Send Define_cScrollingContainerMixin
94695>>>>>>>>>    End_Procedure
94696>>>>>>>>>End_Class
94697>>>>>>>Use cRDCModalPanel.pkg
94697>>>>>>>Use cRDCForm.pkg
Including file: cRDCForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCForm.pkg)
94697>>>>>>>>>//****************************************************************************
94697>>>>>>>>>// $Module type: Class
94697>>>>>>>>>// $Module name: cForm
94697>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
94697>>>>>>>>>// Created     : 2014-03-17 @ 12:34
94697>>>>>>>>>//
94697>>>>>>>>>// Description :
94697>>>>>>>>>//
94697>>>>>>>>>// $Rev History:
94697>>>>>>>>>//    2014-03-17  Module header created
94697>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
94697>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
94697>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
94697>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
94697>>>>>>>>>// in the help folder for more details.
94697>>>>>>>>>//
94697>>>>>>>>>//****************************************************************************
94697>>>>>>>>>Use Windows.pkg
94697>>>>>>>>>
94697>>>>>>>>>Class cFormIdleHandler is a cIdleHandler
94698>>>>>>>>>    Procedure Construct_Object
94700>>>>>>>>>        Forward Send Construct_Object
94702>>>>>>>>>
94702>>>>>>>>>    End_Procedure
94703>>>>>>>>>
94703>>>>>>>>>    Procedure OnIdle
94705>>>>>>>>>        Delegate Send DoUpdate
94707>>>>>>>>>    End_Procedure
94708>>>>>>>>>
94708>>>>>>>>>End_Class
94709>>>>>>>>>
94709>>>>>>>>>Class cRDCForm is a Form
94710>>>>>>>>>
94710>>>>>>>>>    Procedure Construct_Object
94712>>>>>>>>>        Forward Send Construct_Object
94714>>>>>>>>>
94714>>>>>>>>>        Property Boolean pbAutoEnable False
94715>>>>>>>>>
94715>>>>>>>>>        Property Boolean pbEnabled True
94716>>>>>>>>>
94716>>>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cFormIdleHandler)))
94717>>>>>>>>>
94717>>>>>>>>>        Set Label_Justification_mode to JMode_Right
94718>>>>>>>>>        Set Label_Col_Offset to 2
94719>>>>>>>>>        Set Label_Row_Offset to 0
94720>>>>>>>>>    End_Procedure
94721>>>>>>>>>
94721>>>>>>>>>    Procedure End_Construct_Object
94723>>>>>>>>>        String sTooltip sStatus_Help
94723>>>>>>>>>
94723>>>>>>>>>        Forward Send End_Construct_Object
94725>>>>>>>>>
94725>>>>>>>>>        Get psToolTip   to sTooltip
94726>>>>>>>>>        Get Status_Help to sStatus_Help
94727>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
94729>>>>>>>>>            Set psToolTip to sStatus_Help
94730>>>>>>>>>        End
94730>>>>>>>>>>
94730>>>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
94733>>>>>>>>>            Set Status_Help to sTooltip
94734>>>>>>>>>        End
94734>>>>>>>>>>
94734>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
94735>>>>>>>>>    End_Procedure
94736>>>>>>>>>
94736>>>>>>>>>    Procedure DoUpdate
94738>>>>>>>>>        If (pbAutoEnable(Self) = False) Begin
94740>>>>>>>>>            Procedure_Return
94741>>>>>>>>>        End
94741>>>>>>>>>>
94741>>>>>>>>>        Set Enabled_State to (IsEnabled(Self))
94742>>>>>>>>>    End_Procedure
94743>>>>>>>>>
94743>>>>>>>>>    Function IsEnabled Returns Boolean
94745>>>>>>>>>        Boolean bEnabled
94745>>>>>>>>>        Get pbEnabled to bEnabled
94746>>>>>>>>>        Function_Return bEnabled
94747>>>>>>>>>    End_Function
94748>>>>>>>>>
94748>>>>>>>>>    // Enable the idle handler timer when the object is activated
94748>>>>>>>>>    Procedure Activating
94750>>>>>>>>>        Forward Send Activating
94752>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
94753>>>>>>>>>    End_Procedure
94754>>>>>>>>>
94754>>>>>>>>>    // Disable the idle handler when the object is deactivated
94754>>>>>>>>>    Procedure Deactivating  
94756>>>>>>>>>        // When exiting the program it can happen that the idle handler
94756>>>>>>>>>        // already has been destroyed.      
94756>>>>>>>>>        If (Object_id(phoIdleHandler(Self)) <> 0) Begin
94758>>>>>>>>>            Set pbEnabled of (phoIdleHandler(Self)) to False
94759>>>>>>>>>        End
94759>>>>>>>>>>
94759>>>>>>>>>        Forward Send Deactivating
94761>>>>>>>>>    End_Procedure 
94762>>>>>>>>>    
94762>>>>>>>>>    // Toggles the password state, as it doesn't work changing the
94762>>>>>>>>>    // password_state at runtine because it is a design time property.
94762>>>>>>>>>    Procedure TogglePasswordState
94764>>>>>>>>>        Boolean bState    
94764>>>>>>>>>        Handle hoFocus hoParent
94764>>>>>>>>>        Integer iRetval
94764>>>>>>>>>        Get Password_State to bState
94765>>>>>>>>>        Set Password_State to (not(bState))
94766>>>>>>>>>        Get Focus of Desktop to hoFocus
94767>>>>>>>>>        Move (Parent(Self)) to hoParent
94768>>>>>>>>>        Send Page_Object False
94769>>>>>>>>>        Send Page_Object True   
94770>>>>>>>>>        Get msg_Add_Focus hoParent to iRetval
94771>>>>>>>>>        Set Focus_Mode of hoFocus to Focusable
94772>>>>>>>>>//        Send Page_Delete
94772>>>>>>>>>//        Send Page 1
94772>>>>>>>>>    End_Procedure
94773>>>>>>>>>
94773>>>>>>>>>End_Class
94774>>>>>>>Use cRDCComboForm.pkg
94774>>>>>>>Use cRDCButton.pkg
94774>>>>>>>Use cRDCHeaderGroup.pkg
94774>>>>>>>Use cDbDriverSettingsForm.pkg
Including file: cDbDriverSettingsForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbDriverSettingsForm.pkg)
94774>>>>>>>>>//****************************************************************************
94774>>>>>>>>>// $Module type: Class
94774>>>>>>>>>// $Module name: cDbDriverSettingsForm
94774>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International
94774>>>>>>>>>// Created     : 2014-03-17 @ 12:34
94774>>>>>>>>>//
94774>>>>>>>>>// Description :
94774>>>>>>>>>//
94774>>>>>>>>>// $Rev History:
94774>>>>>>>>>//    2014-03-17  Module header created
94774>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
94774>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
94774>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
94774>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
94774>>>>>>>>>// in the help folder for more details.
94774>>>>>>>>>//
94774>>>>>>>>>//****************************************************************************
94774>>>>>>>>>Use Windows.pkg
94774>>>>>>>>>Use seq_chnl.pkg
94774>>>>>>>>>
94774>>>>>>>>>Class cDbDriverSettingsForm is a Form
94775>>>>>>>>>
94775>>>>>>>>>    Procedure Construct_Object
94777>>>>>>>>>        Forward Send Construct_Object
94779>>>>>>>>>
94779>>>>>>>>>        Property Boolean private.pbDriverLoadingError False
94780>>>>>>>>>        
94780>>>>>>>>>        Set Label_Col_Offset to 2
94781>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
94782>>>>>>>>>        Set Size to 11 125 
94783>>>>>>>>>        // We use these settings and not enabled_state to be able
94783>>>>>>>>>        // to show tooltips.
94783>>>>>>>>>        Set Color to clBtnFace
94784>>>>>>>>>        Set Focus_Mode to NonFocusable
94785>>>>>>>>>        Set peAnchors to anTopLeftRight
94786>>>>>>>>>
94786>>>>>>>>>        Property String psDriverIniFile ""
94787>>>>>>>>>    End_Procedure
94788>>>>>>>>>
94788>>>>>>>>>    Procedure Set psToolTip String sText
94790>>>>>>>>>        If (Trim(sText) = "") Begin
94792>>>>>>>>>            Move "No info available" to sText
94793>>>>>>>>>        End
94793>>>>>>>>>>
94793>>>>>>>>>        Forward Set psToolTip to sText
94795>>>>>>>>>    End_Procedure
94796>>>>>>>>>
94796>>>>>>>>>    Function psToolTip Returns String
94798>>>>>>>>>        String sTooltip sSearchValue
94798>>>>>>>>>
94798>>>>>>>>>        Get Label to sSearchValue
94799>>>>>>>>>        Get ExtractIniFileComment sSearchValue to sTooltip
94800>>>>>>>>>
94800>>>>>>>>>        Function_Return sTooltip
94801>>>>>>>>>    End_Function
94802>>>>>>>>>
94802>>>>>>>>>    Procedure SetValue String sDriver String sLabel Integer iAttribute
94804>>>>>>>>>        Integer iDriver
94804>>>>>>>>>        String sValue
94804>>>>>>>>>
94804>>>>>>>>>        // Sadly driver API attributes are only supported by the CLI-drivers,
94804>>>>>>>>>        // and the Pervasive driver is not amongst them. So do nothing if Pervasive.
94804>>>>>>>>>        If (sDriver <> DFBTRDRV_ID and sDriver <> DATAFLEX_ID) Begin
94806>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
94807>>>>>>>>>            Get DriverIndex of ghoSQLConnectionHandler sDriver to iDriver
94808>>>>>>>>>            Set private.pbDriverLoadingError to (iDriver = -1)
94809>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
94810>>>>>>>>>            If (iDriver <= 0) Begin
94812>>>>>>>>>                Procedure_Return
94813>>>>>>>>>            End
94813>>>>>>>>>>
94813>>>>>>>>>            // Set indicator to false prior asking for the driver attribute.
94813>>>>>>>>>            // This way we can decide to show the object or not, based on success/failure.
94813>>>>>>>>>            Move False to Err
94814>>>>>>>>>            Get_Attribute iAttribute of iDriver to sValue
94817>>>>>>>>>            If (sValue = "0") Begin
94819>>>>>>>>>                Move "0 (False)" to sValue
94820>>>>>>>>>            End
94820>>>>>>>>>>
94820>>>>>>>>>            If (sValue = "1") Begin
94822>>>>>>>>>                Move "1 (True)"  to sValue
94823>>>>>>>>>            End
94823>>>>>>>>>>
94823>>>>>>>>>            Set Value to sValue
94824>>>>>>>>>
94824>>>>>>>>>            Move (Replace("DF_DRIVER_", Uppercase(sLabel), "")) to sLabel
94825>>>>>>>>>            // Its a bit annoying reading all caps, so "proper" case
94825>>>>>>>>>            // all labels (DF_DRIVER_XXX values).
94825>>>>>>>>>            Get Propercase sLabel to sLabel
94826>>>>>>>>>            Set Label to sLabel
94827>>>>>>>>>
94827>>>>>>>>>            Get ExtractIniFileComment sLabel to sValue
94828>>>>>>>>>            Set Status_Help to sValue
94829>>>>>>>>>            Set psToolTip to sValue
94830>>>>>>>>>        End
94830>>>>>>>>>>
94830>>>>>>>>>    End_Procedure
94831>>>>>>>>>
94831>>>>>>>>>    // Pass a driver ini filename with path & a comment value to search for.
94831>>>>>>>>>    // Returns: The comments in the file as a string.
94831>>>>>>>>>    Function ExtractIniFileComment String sSearchValue Returns String
94833>>>>>>>>>        String sIniFile sValue sRetval sComment sCommentMarker
94833>>>>>>>>>        Boolean bCommentRow bStart
94833>>>>>>>>>        Integer iCh
94833>>>>>>>>>
94833>>>>>>>>>        Get psDriverIniFile to sIniFile
94834>>>>>>>>>        Move ";" to sCommentMarker
94835>>>>>>>>>        Get Seq_Open_Input_Channel sIniFile to iCh
94836>>>>>>>>>        While (SeqEof = False)
94840>>>>>>>>>            Readln channel iCh sValue
94842>>>>>>>>>            Move (Trim(sValue)) to sValue
94843>>>>>>>>>
94843>>>>>>>>>            // Check for a ";" at pos 1 & if the line contains the passed search value (driver attribute).
94843>>>>>>>>>            Move (Left(sValue, 1)) to sComment
94844>>>>>>>>>            If (bStart = False) Begin
94846>>>>>>>>>                Move (sComment = sCommentMarker and Lowercase(sValue) contains Lowercase(sSearchValue)) to bStart
94847>>>>>>>>>            End
94847>>>>>>>>>>
94847>>>>>>>>>            If (bStart = True) Begin
94849>>>>>>>>>                // Have we read past end of the comment for the driver attribute? If so, quit.
94849>>>>>>>>>                If (sComment <> sCommentMarker) Begin
94851>>>>>>>>>                    Move True to SeqEof
94852>>>>>>>>>                End
94852>>>>>>>>>>
94852>>>>>>>>>                Else Begin
94853>>>>>>>>>                    Move (sComment = sCommentMarker) to bCommentRow
94854>>>>>>>>>                    If (bCommentRow = True) Begin
94856>>>>>>>>>                        Move (Replace(sCommentMarker, sValue, "")) to sValue
94857>>>>>>>>>
94857>>>>>>>>>                        // Replace all double spaces with a single space character.
94857>>>>>>>>>                        Move (Replaces("  ", sValue, " ")) to sValue
94858>>>>>>>>>
94858>>>>>>>>>                        If (sRetval = "") Begin
94860>>>>>>>>>                            Move sValue to sRetval
94861>>>>>>>>>                        End
94861>>>>>>>>>>
94861>>>>>>>>>                        Else Begin
94862>>>>>>>>>                            Move (sRetval + " " + sValue) to sRetval
94863>>>>>>>>>                        End
94863>>>>>>>>>>
94863>>>>>>>>>                    End
94863>>>>>>>>>>
94863>>>>>>>>>                End
94863>>>>>>>>>>
94863>>>>>>>>>            End
94863>>>>>>>>>>
94863>>>>>>>>>        Loop
94864>>>>>>>>>>
94864>>>>>>>>>        Send Seq_Close_Channel iCh
94865>>>>>>>>>
94865>>>>>>>>>CompilerWarnings Off
94865>>>>>>>>>        // Replaces all double spaces with a single space character.
94865>>>>>>>>>        // The Replaces function doesn't quite work for this.
94865>>>>>>>>>        Repeat
94865>>>>>>>>>>
94865>>>>>>>>>            Replace "  " in sRetval with " "
94869>>>>>>>>>        Until (FindErr)
94871>>>>>>>>>        
94871>>>>>>>>>        Function_Return sRetval
94872>>>>>>>>>    End_Function
94873>>>>>>>>>CompilerWarnings On
94873>>>>>>>>>
94873>>>>>>>>>    Function Propercase String sText Returns String 
94875>>>>>>>>>        String[] sDelimiters
94876>>>>>>>>>        Integer iPos
94876>>>>>>>>>        
94876>>>>>>>>>        //Lowercase everything and we'll handle uppercase by exception
94876>>>>>>>>>        Move (Lowercase(sText)) to sText
94877>>>>>>>>>        
94877>>>>>>>>>        Move " " to sDelimiters[SizeOfArray(sDelimiters)]
94878>>>>>>>>>        Move "-" to sDelimiters[SizeOfArray(sDelimiters)]
94879>>>>>>>>>        Move "_" to sDelimiters[SizeOfArray(sDelimiters)]
94880>>>>>>>>>        
94880>>>>>>>>>        For iPos from 1 to (Length(sText)) // 1 based loop to match MID and OVERSTRIKE
94886>>>>>>>>>>
94886>>>>>>>>>            //If the previous character is a space, uppercase the current one (alway upper the first char)
94886>>>>>>>>>            If ((iPos = 1) or (SearchArray( Mid(sText, 1, (iPos - 1)), sDelimiters) <> -1)) ;                Move (Overstrike( Uppercase(Mid(sText, 1, iPos)), sText, iPos )) to sText
94889>>>>>>>>>        Loop
94890>>>>>>>>>>
94890>>>>>>>>>        
94890>>>>>>>>>        Function_Return sText
94891>>>>>>>>>    End_Function
94892>>>>>>>>>
94892>>>>>>>>>End_Class
94893>>>>>>>Use cDbUpdateFunctionLibrary.pkg
94893>>>>>>>
94893>>>>>>>Register_Procedure psOrgToolTip String sTooltip
94893>>>>>>>
94893>>>>>>>Object oDriverSettings_dg is a cRDCModalPanel
94895>>>>>>>    Set Size to 291 345
94896>>>>>>>    Set Label to "Driver Configuration File Info"
94897>>>>>>>    Set Location to 2 2
94898>>>>>>>    Set Maximize_Icon to False
94899>>>>>>>    Set Locate_Mode to CENTER_ON_PARENT
94900>>>>>>>    Set Icon to "DriverSettings1.ico"
94901>>>>>>>    
94901>>>>>>>    Property String psDriverID MSSQLDRV_ID
94903>>>>>>>    Property Boolean pbDriverLoadingError False
94905>>>>>>>    
94905>>>>>>>    Object oCancel_Btn is a cRDCButton
94907>>>>>>>        Set Label    to "&Close"
94908>>>>>>>        Set Location to 269 287
94909>>>>>>>        Set peAnchors to anBottomRight
94910>>>>>>>
94910>>>>>>>        Procedure OnClick
94913>>>>>>>            Send Close_Panel
94914>>>>>>>        End_Procedure
94915>>>>>>>
94915>>>>>>>    End_Object
94916>>>>>>>
94916>>>>>>>    Object oDriver_cf is a cRDCComboForm
94918>>>>>>>        Set Label to "Database Driver"
94919>>>>>>>        Set Size to 13 80
94920>>>>>>>        Set Location to 8 90
94921>>>>>>>        Set Form_Border to 0
94922>>>>>>>        Set Label_Col_Offset to 2
94923>>>>>>>        Set Label_Justification_Mode to JMode_Right
94924>>>>>>>        Set Status_Help to "Database driver."
94925>>>>>>>        Set Enabled_State to False
94926>>>>>>>        Set Skip_State to True
94927>>>>>>>
94927>>>>>>>        Procedure Combo_Fill_List
94930>>>>>>>            Send Combo_Add_Item DATAFLEX_ID
94931>>>>>>>            Send Combo_Add_Item DFBTRDRV_ID
94932>>>>>>>            Send Combo_Add_Item ODBC_DRV_ID
94933>>>>>>>            Send Combo_Add_Item MSSQLDRV_ID
94934>>>>>>>            Send Combo_Add_Item DB2_DRV_ID
94935>>>>>>>        End_Procedure
94936>>>>>>>
94936>>>>>>>    End_Object
94937>>>>>>>
94937>>>>>>>    Object oDriverFileName_cf is a cRDCForm
94939>>>>>>>        Set Label to "Database Driver File"
94940>>>>>>>        Set Size to 12 193
94941>>>>>>>        Set Location to 24 90
94942>>>>>>>        Set Label_Col_Offset to 2
94943>>>>>>>        Set Label_Justification_Mode to JMode_Right
94944>>>>>>>        Set Status_Help to "Database driver to be used when creating new tables."
94945>>>>>>>        Set Color to clBtnFace
94946>>>>>>>        Set Focus_Mode to NonFocusable
94947>>>>>>>        Set peAnchors to anTopLeftRight
94948>>>>>>>
94948>>>>>>>        Procedure OnChange
94951>>>>>>>            String sDriverID sValue sDriverIntFileName sTooltip sPath
94951>>>>>>>
94951>>>>>>>            Forward Send OnChange
94953>>>>>>>            Get Value to sValue
94954>>>>>>>            Set Status_Help to sValue
94955>>>>>>>
94955>>>>>>>            Get psDriverID to sDriverID
94956>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
94958>>>>>>>                Get DatabaseDriverIniFilePath sDriverID to sPath
94959>>>>>>>                If (sPath <> "") Begin
94961>>>>>>>                    Move (sPath + sDriverID + ".int") to sDriverIntFileName
94962>>>>>>>                End
94962>>>>>>>>
94962>>>>>>>            End
94962>>>>>>>>
94962>>>>>>>            Else Begin
94963>>>>>>>                Move sDriverID to sDriverIntFileName
94964>>>>>>>            End
94964>>>>>>>>
94964>>>>>>>
94964>>>>>>>            Set Value of oDriverIniFile_fm to sDriverIntFileName
94965>>>>>>>            Get psOrgToolTip of oDriverIniFile_fm to sTooltip
94966>>>>>>>            Set Status_Help of oDriverIniFile_fm to (sTooltip * sDriverIntFileName)
94967>>>>>>>
94967>>>>>>>            // In case driver attribute objects already exists; destroy them
94967>>>>>>>            Broadcast Send Destroy    of oScrollingClientArea
94969>>>>>>>            // Then recreate them to show driver attributes
94969>>>>>>>            Send DoReadDriverSettings of oScrollingClientArea sDriverID
94970>>>>>>>        End_Procedure  
94971>>>>>>>        
94971>>>>>>>    End_Object
94972>>>>>>>
94972>>>>>>>    Object oDriverInfo_btn is a cRDCButton
94974>>>>>>>        Set Size to 13 50
94975>>>>>>>        Set Location to 24 287
94976>>>>>>>        Set Label to "Version Info"
94977>>>>>>>        Set Status_Help to "Shows a dialog with driver properties and SQL client software version(s), license info and more."
94978>>>>>>>        Set peAnchors to anTopRight
94979>>>>>>>
94979>>>>>>>        Procedure OnClick
94982>>>>>>>            Object oSysInfoDialog is a SysInfoDialog
94984>>>>>>>            End_Object
94985>>>>>>>
94985>>>>>>>            Send Popup of oSysInfoDialog
94986>>>>>>>        End_Procedure
94987>>>>>>>    End_Object
94988>>>>>>>
94988>>>>>>>    Object oDriverIniFile_fm is a cRDCForm
94990>>>>>>>        Set Size to 13 193
94991>>>>>>>        Set Location to 39 90
94992>>>>>>>        Set Label_Col_Offset to 2
94993>>>>>>>        Set Label_Justification_Mode to JMode_Right
94994>>>>>>>        Set Label to "Driver Configuration File"
94995>>>>>>>        Set peAnchors to anTopLeftRight
94996>>>>>>>        Set Color to clBtnFace
94997>>>>>>>        Set Focus_Mode to NonFocusable
94998>>>>>>>        Property String psOrgToolTip "The file is the first found in the DF_OPEN_PATH path string."
95000>>>>>>>        Set Status_Help to (psOrgToolTip(Self))
95001>>>>>>>    End_Object
95002>>>>>>>
95002>>>>>>>    Object oOpenDriverFile_Btn is a cRDCButton
95004>>>>>>>        Set Size to 13 50
95005>>>>>>>        Set Label to "Edit File"
95006>>>>>>>        Set Location to 39 287
95007>>>>>>>        Set Status_Help to "Opens the driver configuration file that contains configuration settings that are used when tables are restructured, in Notepad."
95008>>>>>>>        Set psImage to "ActionEdit1.ico"
95009>>>>>>>        Set peAnchors to anTopRight
95010>>>>>>>        Set pbAutoEnable to True
95011>>>>>>>
95011>>>>>>>        Procedure OnClick
95014>>>>>>>            String sFileName
95014>>>>>>>            Get Value of oDriverIniFile_fm to sFileName
95015>>>>>>>            If (sFileName <> DATAFLEX_ID) Begin
95017>>>>>>>                Runprogram Background "Notepad.exe" sFileName
95018>>>>>>>            End
95018>>>>>>>>
95018>>>>>>>            Else Begin
95019>>>>>>>                Send Info_Box "Sorry, there exist no driver ini file for the DataFlex database driver, so nothing to show here."
95020>>>>>>>            End
95020>>>>>>>>
95020>>>>>>>        End_Procedure   
95021>>>>>>>        
95021>>>>>>>        Function IsEnabled Returns Boolean
95024>>>>>>>            String sFileName
95024>>>>>>>            Get Value of oDriverFileName_cf to sFileName
95025>>>>>>>            Function_Return (sFileName <> "")
95026>>>>>>>        End_Function
95027>>>>>>>
95027>>>>>>>    End_Object
95028>>>>>>>
95028>>>>>>>    Object oDumpDriverData_Btn is a cRDCButton
95030>>>>>>>        Set Size to 13 50
95031>>>>>>>        Set Label to "Dump"
95032>>>>>>>        Set Location to 54 233
95033>>>>>>>        Set peAnchors to anTopRight
95034>>>>>>>        Set psToolTip to "Dumps the current status of the Connectivity Kit driver to an ASCII disk file."
95035>>>>>>>        Set psImage to "ActionExport1.ico"
95036>>>>>>>        Set pbAutoEnable to True
95037>>>>>>>        
95037>>>>>>>        Procedure OnClick
95040>>>>>>>            Handle hoCLI
95040>>>>>>>            String sDriver sPath sFileName
95040>>>>>>>            Integer iRetval
95040>>>>>>>
95040>>>>>>>            Get psDriverID to sDriver
95041>>>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLI
95042>>>>>>>            Set psDriverID of hoCLI  to sDriver
95043>>>>>>>            If (sDriver = DATAFLEX_ID or sDriver = DFBTRDRV_ID) Begin
95045>>>>>>>                Send Destroy of hoCLI
95046>>>>>>>                Send Info_Box "Sorry, no attributes can be shown for the selected database driver."
95047>>>>>>>                Procedure_Return
95048>>>>>>>            End
95048>>>>>>>>
95048>>>>>>>
95048>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
95049>>>>>>>            Get vFolderFormat sPath to sPath
95050>>>>>>>            Move (sDriver + "dump.txt") to sFileName
95051>>>>>>>            Send DumpStatus of hoCLI (sPath + sFileName)
95052>>>>>>>            Send Destroy of hoCLI
95053>>>>>>>
95053>>>>>>>            Send vShellExecute "open" sFileName "" sPath
95054>>>>>>>            Sleep 1
95055>>>>>>>            Get vDeleteFile (sPath + sFileName) to iRetval
95056>>>>>>>        End_Procedure
95057>>>>>>>
95057>>>>>>>        Function IsEnabled Returns Boolean
95060>>>>>>>            String sFileName
95060>>>>>>>            Boolean bDriverLoadingError 
95060>>>>>>>            Get pbDriverLoadingError to bDriverLoadingError
95061>>>>>>>            Get Value of oDriverFileName_cf to sFileName
95062>>>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
95063>>>>>>>        End_Function
95064>>>>>>>
95064>>>>>>>    End_Object
95065>>>>>>>
95065>>>>>>>    Object oReset_Btn is a cRDCButton
95067>>>>>>>        Set Size to 13 50
95068>>>>>>>        Set Label to "Refresh"
95069>>>>>>>        Set Status_Help to "If you edit the driver configuration file, the display of attributes above needs to be refreshed. Click here to refresh."
95070>>>>>>>        Set Location to 54 287
95071>>>>>>>        Set psImage to "ActionRefresh1.ico"
95072>>>>>>>        Set peAnchors to anTopRight
95073>>>>>>>        Set pbAutoEnable to True
95074>>>>>>>
95074>>>>>>>        Procedure OnClick
95077>>>>>>>            String sDriver
95077>>>>>>>            Get psDriverID to sDriver
95078>>>>>>>            Unload_Driver sDriver
95079>>>>>>>            Load_Driver sDriver
95080>>>>>>>            Send Info_Box "This dialog needs to be re-opened to display the refreshed values. Dialog will now close and you need to re-open it manually."
95081>>>>>>>            Send Close_Panel
95082>>>>>>>        End_Procedure
95083>>>>>>>
95083>>>>>>>        Function IsEnabled Returns Boolean
95086>>>>>>>            String sFileName
95086>>>>>>>            Boolean bDriverLoadingError 
95086>>>>>>>            Get pbDriverLoadingError to bDriverLoadingError
95087>>>>>>>            Get Value of oDriverFileName_cf to sFileName
95088>>>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
95089>>>>>>>        End_Function
95090>>>>>>>
95090>>>>>>>    End_Object
95091>>>>>>>
95091>>>>>>>    Object oDriverSetings_grp is a cRDCHeaderGroup
95093>>>>>>>        Set Size to 125 328
95094>>>>>>>        Set Location to 74 9
95095>>>>>>>        Set psImage to "DriverSettings1.ico"
95096>>>>>>>        Set Label to "Driver Configuration File Settings"   
95097>>>>>>>        Set psNote to "Hover the mouse over an attribute field to read information about it."
95098>>>>>>>        Set peAnchors to anAll
95099>>>>>>>
95099>>>>>>>        Object oInvisible_Container is a Container3d
95101>>>>>>>            Set Size to 100 327
95102>>>>>>>            Set Location to 24 0
95103>>>>>>>            Set Border_Style to Border_None
95104>>>>>>>            Set peAnchors to anAll
95105>>>>>>>    
95105>>>>>>>            Object oScrollingContainer is a cScrollingContainer
95107>>>>>>>               
95107>>>>>>>                Object oScrollingClientArea is a cScrollingClientArea
95109>>>>>>>
95109>>>>>>>                    // Just fill the array with all available driver attributes from Cli.pkg,
95109>>>>>>>                    // and one object will automatically be created for each attribute
95109>>>>>>>                    // for the current driver by the DoReadDriverSettings procedure.
95109>>>>>>>                    Function GeneralDriverAttributes Returns String[]
95112>>>>>>>                        String[] sAttributesArray
95113>>>>>>>    
95113>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_ASCII             |CI1101" to sAttributesArray[SizeOfArray(sAttributesArray)]
95114>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_ASCII            |CI1102" to sAttributesArray[SizeOfArray(sAttributesArray)]
95115>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_NUMERIC           |CI1103" to sAttributesArray[SizeOfArray(sAttributesArray)]
95116>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_NUMERIC          |CI1104" to sAttributesArray[SizeOfArray(sAttributesArray)]
95117>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATE              |CI1105" to sAttributesArray[SizeOfArray(sAttributesArray)]
95118>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATE             |CI1106" to sAttributesArray[SizeOfArray(sAttributesArray)]
95119>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_TEXT              |CI1107" to sAttributesArray[SizeOfArray(sAttributesArray)]
95120>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_TEXT             |CI1108" to sAttributesArray[SizeOfArray(sAttributesArray)]
95121>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_BINARY            |CI1109" to sAttributesArray[SizeOfArray(sAttributesArray)]
95122>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_BINARY           |CI1110" to sAttributesArray[SizeOfArray(sAttributesArray)]
95123>>>>>>>                        Move "DF_DRIVER_DUMMY_ZERO_DATE_VALUE             |CI1111" to sAttributesArray[SizeOfArray(sAttributesArray)]
95124>>>>>>>                        Move "DF_DRIVER_MAX_ACTIVE_STATEMENTS             |CI1112" to sAttributesArray[SizeOfArray(sAttributesArray)]
95125>>>>>>>                        Move "DF_DRIVER_CACHE_PATH                        |CI1113" to sAttributesArray[SizeOfArray(sAttributesArray)]
95126>>>>>>>                        Move "DF_DRIVER_DRIVER_DECIMAL_SEPARATOR          |CI1114" to sAttributesArray[SizeOfArray(sAttributesArray)]
95127>>>>>>>                        Move "DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT    |CI1115" to sAttributesArray[SizeOfArray(sAttributesArray)]
95128>>>>>>>                        Move "DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR        |CI1116" to sAttributesArray[SizeOfArray(sAttributesArray)]
95129>>>>>>>                        Move "DF_DRIVER_APPLICATION_CHARACTER_FORMAT      |CI1117" to sAttributesArray[SizeOfArray(sAttributesArray)]
95130>>>>>>>                        Move "DF_DRIVER_DRIVER_DATE_FORMAT                |CI1118" to sAttributesArray[SizeOfArray(sAttributesArray)]
95131>>>>>>>                        Move "DF_DRIVER_LAST_ERROR_TEXT                   |CI1119" to sAttributesArray[SizeOfArray(sAttributesArray)]
95132>>>>>>>                        Move "DF_DRIVER_DRIVER_DATE_SEPARATOR             |CI1120" to sAttributesArray[SizeOfArray(sAttributesArray)]
95133>>>>>>>    
95133>>>>>>>                        // Exception to the rule!
95133>>>>>>>                        // Someone - in its infinite wisdome - decided that the keyword in the ini file should be "DFConnectionId",
95133>>>>>>>                        // and not "Connection_ID" that is the API attribute name. This brakes the cDriverSettingsForm tooltip logic.
95133>>>>>>>                        // We fix it by changing the attribute constant string here (removed the _ (underscore) before the "ID" part.
95133>>>>>>>                        Move "DF_DRIVER_CONNECTIONID                      |CI1121" to sAttributesArray[SizeOfArray(sAttributesArray)]
95134>>>>>>>                        Move "DF_DRIVER_IGNORE_UCASE_SUPPORT              |CI1122" to sAttributesArray[SizeOfArray(sAttributesArray)]
95135>>>>>>>                        Move "DF_DRIVER_CONNECTION_ID_STRING              |CI1123" to sAttributesArray[SizeOfArray(sAttributesArray)]
95136>>>>>>>    
95136>>>>>>>                        Move "DF_DRIVER_IGNORE_WARNINGS                   |CI1124" to sAttributesArray[SizeOfArray(sAttributesArray)]
95137>>>>>>>                        Move "DF_DRIVER_USE_DF_LOCKERROR                  |CI1126" to sAttributesArray[SizeOfArray(sAttributesArray)]
95138>>>>>>>                        Move "DF_DRIVER_FIND_CACHE_TIMEOUT                |CI1128" to sAttributesArray[SizeOfArray(sAttributesArray)]
95139>>>>>>>                        Move "DF_DRIVER_JIT_TRESHOLD                      |CI1130" to sAttributesArray[SizeOfArray(sAttributesArray)]
95140>>>>>>>                        Move "DF_DRIVER_TRUNCATE_BINARY_ZEROES            |CI1132" to sAttributesArray[SizeOfArray(sAttributesArray)]
95141>>>>>>>                        Move "DF_DRIVER_ERROR_DEBUG_MODE                  |CI1134" to sAttributesArray[SizeOfArray(sAttributesArray)]
95142>>>>>>>                        Move "DF_DRIVER_USE_CACHE                         |CI1136" to sAttributesArray[SizeOfArray(sAttributesArray)]
95143>>>>>>>                        Move "DF_DRIVER_REPORT_CACHE_ERRORS               |CI1138" to sAttributesArray[SizeOfArray(sAttributesArray)]
95144>>>>>>>                        Move "DF_DRIVER_USE_CACHE_EXPIRATION              |CI1140" to sAttributesArray[SizeOfArray(sAttributesArray)]
95145>>>>>>>                        Move "DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE       |CI1142" to sAttributesArray[SizeOfArray(sAttributesArray)]
95146>>>>>>>                        Move "DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING    |CI1144" to sAttributesArray[SizeOfArray(sAttributesArray)]
95147>>>>>>>                        Move "DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS       |CI1146" to sAttributesArray[SizeOfArray(sAttributesArray)]
95148>>>>>>>                        Move "DF_DRIVER_SILENT_LOGIN                      |CI1148" to sAttributesArray[SizeOfArray(sAttributesArray)]
95149>>>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_TO_RECNUM             |CI1150" to sAttributesArray[SizeOfArray(sAttributesArray)]
95150>>>>>>>                        Move "DF_DRIVER_CONNECTION_ID_OPTIONS             |CI1152" to sAttributesArray[SizeOfArray(sAttributesArray)]
95151>>>>>>>                        Move "DF_DRIVER_NUMBER_CONNECTION_IDS             |CI1154" to sAttributesArray[SizeOfArray(sAttributesArray)]
95152>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATETIME          |CI1155" to sAttributesArray[SizeOfArray(sAttributesArray)]
95153>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATETIME         |CI1156" to sAttributesArray[SizeOfArray(sAttributesArray)]
95154>>>>>>>                        Move "DF_DRIVER_MATCH_CLIENT_SERVER_VERSION       |CI1158" to sAttributesArray[SizeOfArray(sAttributesArray)]
95155>>>>>>>                        Move "DF_DRIVER_SQLSERVER_CLIENT_VERSION          |CI1160" to sAttributesArray[SizeOfArray(sAttributesArray)]
95156>>>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE            |CI1168" to sAttributesArray[SizeOfArray(sAttributesArray)]
95157>>>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_SQLTYPE             |CI1169" to sAttributesArray[SizeOfArray(sAttributesArray)]
95158>>>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE        |CI1170" to sAttributesArray[SizeOfArray(sAttributesArray)]
95159>>>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE         |CI1171" to sAttributesArray[SizeOfArray(sAttributesArray)]
95160>>>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE           |CI1172" to sAttributesArray[SizeOfArray(sAttributesArray)]
95161>>>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_SQLTYPE            |CI1173" to sAttributesArray[SizeOfArray(sAttributesArray)]
95162>>>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE            |CI1174" to sAttributesArray[SizeOfArray(sAttributesArray)]
95163>>>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE             |CI1175" to sAttributesArray[SizeOfArray(sAttributesArray)]
95164>>>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE          |CI1176" to sAttributesArray[SizeOfArray(sAttributesArray)]
95165>>>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE           |CI1177" to sAttributesArray[SizeOfArray(sAttributesArray)]
95166>>>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA |CI1178" to sAttributesArray[SizeOfArray(sAttributesArray)]
95167>>>>>>>                        Move "DF_DRIVER_LOGIN_ON_OPEN                     |CI1180" to sAttributesArray[SizeOfArray(sAttributesArray)]
95168>>>>>>>                        Move "DF_DRIVER_MINIMUM_CLIENT_VERSION            |CI1182" to sAttributesArray[SizeOfArray(sAttributesArray)]
95169>>>>>>>    
95169>>>>>>>                        // Sort items alphabetically
95169>>>>>>>                        Move (SortArray(sAttributesArray)) to sAttributesArray
95170>>>>>>>                        Function_Return sAttributesArray
95171>>>>>>>                    End_Function
95172>>>>>>>    
95172>>>>>>>                    Function SplitValue String sValue Integer ByRef iAttribute Returns String
95175>>>>>>>                        String sAttribute sTmp
95175>>>>>>>                        Integer iPos
95175>>>>>>>    
95175>>>>>>>                        Move (Pos("|", sValue)) to iPos
95176>>>>>>>                        Move (Left(sValue, (iPos -1))) to sAttribute
95177>>>>>>>                        Move (Mid(sValue, Length(sValue), iPos)) to sTmp
95178>>>>>>>                        Move (Trim(sAttribute)) to sAttribute
95179>>>>>>>                        Move (Eval(sTmp)) to iAttribute
95180>>>>>>>    
95180>>>>>>>                        Function_Return sAttribute
95181>>>>>>>                    End_Function
95182>>>>>>>    
95182>>>>>>>                    // Note: Creates dynamic objects.
95182>>>>>>>                    // They are not being destroyed by this method.
95182>>>>>>>                    // It is the reponsibility of the calling method to do that,
95182>>>>>>>                    // prior calling this method.
95182>>>>>>>                    Procedure DoReadDriverSettings String sDriver
95185>>>>>>>                        Integer iLocW iLocH iHfactor iFirstLineOffset iCount iItems iAttribute
95185>>>>>>>                        Handle ho hoParent
95185>>>>>>>                        String[] sAttributesArray
95186>>>>>>>                        String sValue sAttribute sDriverIniFile 
95186>>>>>>>                        Boolean bDriverLoadingError
95186>>>>>>>    
95186>>>>>>>                        Move (Self) to hoParent
95187>>>>>>>                        Move 13  to iHfactor // Height offset between form
95188>>>>>>>                        Move 120 to iLocW
95189>>>>>>>                        Move 10  to iLocH                            
95190>>>>>>>                        Move  0  to iFirstLineOffset // Offset from the top for the very first object.
95191>>>>>>>    
95191>>>>>>>                        Get Value of oDriverIniFile_fm to sDriverIniFile
95192>>>>>>>                        If (Trim(sDriverIniFile) = "") Begin
95194>>>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
95195>>>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
95196>>>>>>>                            Set Location of ho to iLocH (iLocW + 30)
95197>>>>>>>                            Set Label of ho to "No Driver Configuration File found!"
95198>>>>>>>                            Set Value of ho to "No attributes to display..."   
95199>>>>>>>                            Procedure_Return
95200>>>>>>>                        End
95200>>>>>>>>
95200>>>>>>>                            
95200>>>>>>>                        // Driver attributes aren't supported by the Pervasive driver,
95200>>>>>>>                        // so notify and quite.
95200>>>>>>>                        If (sDriver = DFBTRDRV_ID or sDriver = DATAFLEX_ID) Begin
95202>>>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
95203>>>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
95204>>>>>>>                            Set Location of ho to iLocH (iLocW + 30)
95205>>>>>>>                            Set Label of ho to "Query of driver attributes unsupported!"
95206>>>>>>>                            Set Value of ho to "Sorry, no attributes to display"
95207>>>>>>>                            Procedure_Return
95208>>>>>>>                        End
95208>>>>>>>>
95208>>>>>>>    
95208>>>>>>>                        Get GeneralDriverAttributes to sAttributesArray
95209>>>>>>>                        Move (SizeOfArray(sAttributesArray)) to iItems
95210>>>>>>>                        Decrement iItems
95211>>>>>>>                        Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE 
95212>>>>>>>                        Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE  // Invalid driver value
95213>>>>>>>    
95213>>>>>>>                        For iCount from 0 to iItems
95219>>>>>>>>
95219>>>>>>>                            Move sAttributesArray[iCount] to sValue
95220>>>>>>>                            Get SplitValue sValue (&iAttribute) to sAttribute
95221>>>>>>>    
95221>>>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho 
95222>>>>>>>                            Set psDriverIniFile of ho to sDriverIniFile
95223>>>>>>>                            Send SetValue of ho sDriver sAttribute iAttribute
95224>>>>>>>                            Get private.pbDriverLoadingError of ho to bDriverLoadingError
95225>>>>>>>                            If (bDriverLoadingError = True) Begin
95227>>>>>>>                                Set Label of ho to "Driver could not be loaded!"   
95228>>>>>>>                                If (Trim(sDriverIniFile) = "") Begin
95230>>>>>>>                                    Set Value of ho to "Driver .dll file not found!"
95231>>>>>>>                                End
95231>>>>>>>>
95231>>>>>>>                                Else Begin
95232>>>>>>>                                    Set Value of ho to "No attributes to display..."   
95233>>>>>>>                                End
95233>>>>>>>>
95233>>>>>>>                                Set psToolTip of ho to "Check that the database engine for the selected driver is installed and is running correctly!"  
95234>>>>>>>                                Delegate Set pbDriverLoadingError to True
95236>>>>>>>                                Move iItems to iCount // We're out of here.   
95237>>>>>>>                                Move False to Err
95238>>>>>>>                            End
95238>>>>>>>>
95238>>>>>>>                            If (Err = True) Begin
95240>>>>>>>                                Send Destroy of ho
95241>>>>>>>                            End
95241>>>>>>>>
95241>>>>>>>                            Else Begin
95242>>>>>>>                                If (iCount = 0) Begin
95244>>>>>>>                                    Move (iFirstLineOffset + iLocH) to iLocH
95245>>>>>>>                                End
95245>>>>>>>>
95245>>>>>>>                                Set Location of ho to iLocH (iLocW + 30)
95246>>>>>>>                                Move (iLocH + iHfactor) to iLocH
95247>>>>>>>                            End
95247>>>>>>>>
95247>>>>>>>                        Loop
95248>>>>>>>>
95248>>>>>>>    
95248>>>>>>>                        Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE
95249>>>>>>>                        Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
95250>>>>>>>                    End_Procedure
95251>>>>>>>    
95251>>>>>>>                End_Object
95252>>>>>>>
95252>>>>>>>            End_Object
95253>>>>>>>    
95253>>>>>>>        End_Object
95254>>>>>>>
95254>>>>>>>    End_Object
95255>>>>>>>
95255>>>>>>>    Object oInfo_edt is a cRichEdit
95257>>>>>>>        Set Size to 49 328
95258>>>>>>>        Set Location to 213 9
95259>>>>>>>        Set Label to "General Connectivity Kit Information:"
95260>>>>>>>        Set Value to "It is possible to configure the behavior of a Connectivity Kit through configuration files. Configuration files can be located anywhere in DFPATH. In general, one configuration file per install is enough. There are situations where there is a need to have different configurations for different deploy environments on one machine/network. In that case the configuration file should be placed in the deployment environment rather than in the overall DataFlex environment."
95261>>>>>>>        Set Skip_State to True
95262>>>>>>>        Set Read_Only_State to True
95263>>>>>>>        Set pbItalics to True
95264>>>>>>>        Set peAnchors to anBottomLeftRight
95265>>>>>>>
95265>>>>>>>        Procedure DoIndent
95268>>>>>>>            Integer iTwipsPerInch iCurrentIndent
95268>>>>>>>        
95268>>>>>>>            // number of twips per inch
95268>>>>>>>            Move 1440 to iTwipsPerInch
95269>>>>>>>        
95269>>>>>>>            Set piSpacingBefore to (1440 * 0.05)
95270>>>>>>>            // indent 0.1 inches from current indentation
95270>>>>>>>            Get piParagraphIndent to iCurrentIndent
95271>>>>>>>            Set piParagraphIndent to (iCurrentIndent + (iTwipsPerInch * 0.1))
95272>>>>>>>        End_Procedure
95273>>>>>>>        Send DoIndent
95274>>>>>>>
95274>>>>>>>    End_Object
95275>>>>>>>
95275>>>>>>>    Procedure Activating
95278>>>>>>>        Forward Send Activating
95280>>>>>>>        Send Cursor_Ready of Cursor_Control
95281>>>>>>>    End_Procedure
95282>>>>>>>
95282>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
95283>>>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
95284>>>>>>>End_Object
95285>>>>>>>
95285>>>>>>>// General purpose access method for the dialog above:
95285>>>>>>>Procedure PopupDriverSettings String sDriverID 
95288>>>>>>>    Handle ho
95288>>>>>>>    String sDriverFile sPath
95288>>>>>>>
95288>>>>>>>    Send Cursor_Wait of Cursor_Control
95289>>>>>>>    Move (oDriverSettings_dg(Self)) to ho
95290>>>>>>>    Set psDriverID of ho to sDriverID
95291>>>>>>>    Set pbDriverLoadingError of ho to False
95292>>>>>>>
95292>>>>>>>    Set Value of (oDriver_cf(ho)) to sDriverID
95293>>>>>>>    Get DatabaseDriverPath sDriverID to sPath
95294>>>>>>>    If (sPath <> "") Begin
95296>>>>>>>        Move (sDriverID + ".dll")  to sDriverFile
95297>>>>>>>    End
95297>>>>>>>>
95297>>>>>>>    Set Value of (oDriverFileName_cf(ho)) to (sPath + sDriverFile)
95298>>>>>>>    Send Cursor_Ready of Cursor_Control
95299>>>>>>>
95299>>>>>>>    Send Popup of ho
95300>>>>>>>End_Procedure
95301>>>>>>>
95301>>>>>>>Function DatabaseDriverPath String sDriverID Returns String
95304>>>>>>>    String sPath sDriverFileName
95304>>>>>>>
95304>>>>>>>    Move "" to sPath
95305>>>>>>>    If (sDriverID = DATAFLEX_ID) Begin
95307>>>>>>>        Function_Return sPath
95308>>>>>>>    End                   
95308>>>>>>>>
95308>>>>>>>    
95308>>>>>>>    Move (sDriverID + ".dll") to sDriverFileName
95309>>>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
95310>>>>>>>    
95310>>>>>>>    Function_Return sPath
95311>>>>>>>End_Function      
95312>>>>>>>
95312>>>>>>>Function DatabaseDriverIniFilePath String sDriverID Returns String
95315>>>>>>>    String sPath sDriverFileName
95315>>>>>>>
95315>>>>>>>    Move "" to sPath
95316>>>>>>>    If (sDriverID = DATAFLEX_ID) Begin
95318>>>>>>>        Function_Return sPath
95319>>>>>>>    End                   
95319>>>>>>>>
95319>>>>>>>    
95319>>>>>>>    Move (sDriverID + ".int") to sDriverFileName
95320>>>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
95321>>>>>>>    
95321>>>>>>>    Function_Return sPath
95322>>>>>>>End_Function      
95323>>>>>Use CreateDatabase.dg
Including file: CreateDatabase.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CreateDatabase.dg)
95323>>>>>>>Use Windows.pkg
95323>>>>>>>Use cRDCModalPanel.pkg
95323>>>>>>>Use cRDCForm.pkg 
95323>>>>>>>Use cRDCComboForm.pkg
95323>>>>>>>Use cRDCSuggestionIniForm.pkg
Including file: cRDCSuggestionIniForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCSuggestionIniForm.pkg)
95323>>>>>>>>>//****************************************************************************
95323>>>>>>>>>// $Module type: Class
95323>>>>>>>>>// $Module name: cRDCSuggestionIniForm
95323>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
95323>>>>>>>>>// Web-site    : http://www.rdctools.com
95323>>>>>>>>>// Created     : 2018-09-05 @ 09:50 (Military date format: YY-MM-DD)
95323>>>>>>>>>//
95323>>>>>>>>>// Description : The class consists of a variant of DataAccess Worldwide's cSuggestionFormList
95323>>>>>>>>>//               It has the added ability to save/retrieve values to the workspace .ws file.
95323>>>>>>>>>//
95323>>>>>>>>>// $Rev History:
95323>>>>>>>>>//    2018-09-05  Module header created
95323>>>>>>>>>//
95323>>>>>>>>>//****************************************************************************
95323>>>>>>>>>Use Windows.pkg
95323>>>>>>>>>Use Windows.pkg
95323>>>>>>>>>Use WinSuggestion.pkg
95323>>>>>>>>>Use cIniFile.pkg
95323>>>>>>>>>Use cRDCForm.pkg
95323>>>>>>>>>Use vWin32fh.pkg
95323>>>>>>>>>
95323>>>>>>>>>Define CS_cRDCSuggestionFormList       for "Suggestion Form List"  // [Section Name]
95323>>>>>>>>>Define CS_cRDCSuggestionSaveItem       for "Saved Item"            // Key=Value
95323>>>>>>>>>Define CS_cRDCSuggestionFormTooltip    for "This is a suggestion form - start typing what you're looking for. Previously entered values are saved automatically."
95323>>>>>>>>>
95323>>>>>>>>>Class cRDCSuggestionIniForm is a cRDCForm
95324>>>>>>>>>
95324>>>>>>>>>    Procedure Define_cRDCSuggestionControl_mixin
95326>>>>>>>>>
95326>>>>>>>>>        Property Integer piTimeOutTicks 0
95327>>>>>>>>>
95327>>>>>>>>>        On_Key kEnter            Send SelectSuggestion
95328>>>>>>>>>        On_Key Key_Escape        Send DeActivateSuggestionList
95329>>>>>>>>>        On_Key Key_Up_Arrow      Send Up
95330>>>>>>>>>        On_Key Key_Down_Arrow    Send Down
95331>>>>>>>>>
95331>>>>>>>>>        // Added 'Home' & 'End' navigation keys for the drop-down list and the form object (and Ctrl+Home & Ctrl+End).
95331>>>>>>>>>        On_Key Key_Home          Send Home
95332>>>>>>>>>        On_Key Key_Ctrl+Key_Home Send Home
95333>>>>>>>>>    On_Key Key_End           Send End
95334>>>>>>>>>On_Key Key_Ctrl+Key_End  Send End // Need this as well; else the Ctrl+Home/End keys generates a runtime error (always has).
95335>>>>>>>>>
95335>>>>>>>>>// Just can't seem to get the popup of the suggestion list with F4 to work.
95335>>>>>>>>>On_Key kPrompt           Send Prompt
95336>>>>>>>>>End_Procedure
95337>>>>>>>>>
95337>>>>>>>>>Import_Class_Protocol cSuggestionControl_mixin
95338>>>>>>>>>Import_Class_Protocol cSuggestion_mixin
95339>>>>>>>>>
95339>>>>>>>>>Procedure Construct_Object
95341>>>>>>>>>    Forward Send Construct_Object
95343>>>>>>>>>    Send Define_cRDCSuggestionControl_mixin
95344>>>>>>>>>    Send Define_cSuggestion_mixin
95345>>>>>>>>>
95345>>>>>>>>>    Set peSuggestionMode to smCustom
95346>>>>>>>>>    Set pbFullText to True
95347>>>>>>>>>    Set piStartAtChar to 1
95348>>>>>>>>>
95348>>>>>>>>>    Property String[] psSavedFormValues
95349>>>>>>>>>    Property String psIniFileSection
95350>>>>>>>>>    Property Integer piSuggestionListMaxItems 99 // Max no of values saved/read to ini file
95351>>>>>>>>>    Property Boolean pbUseWorkspaceIniFile True
95352>>>>>>>>>    Property Boolean pbAutoCheckValueExistsAsFile True
95353>>>>>>>>>    Property Boolean pbAskToRemoveMissingFile True
95354>>>>>>>>>    // Note: pbUseWorkspaceIniFile has presedence over the psIniFileName setting.
95354>>>>>>>>>    //       That means that if pbUseWorkspaceIniFile=True, psIniFilename will be set to the
95354>>>>>>>>>    //       worspace .ws file on program startup.
95354>>>>>>>>>    Property String psIniFileName "RDCSuggestionForm.ini"
95355>>>>>>>>>End_Procedure
95356>>>>>>>>>
95356>>>>>>>>>Procedure ShowSuggestions
95358>>>>>>>>>    tSuggestion[] aResults
95358>>>>>>>>>    tSuggestion[] aResults
95359>>>>>>>>>    Integer i iLines
95359>>>>>>>>>    String sSearch
95359>>>>>>>>>
95359>>>>>>>>>    Get pSearchResults to aResults
95360>>>>>>>>>    Get Value to sSearch
95361>>>>>>>>>
95361>>>>>>>>>    If (ghoSuggestionList <> 0) Begin
95363>>>>>>>>>        Send Delete_Data of ghoSuggestionList
95364>>>>>>>>>        Move (SizeOfArray(aResults)) to iLines
95365>>>>>>>>>        For i from 0 to (iLines-1)
95371>>>>>>>>>>
95371>>>>>>>>>            Send ShowSuggestion aResults[i] sSearch
95372>>>>>>>>>            If ((iLines-1)<>i) Begin
95374>>>>>>>>>                Send AppendTextLn of ghoSuggestionList ""
95375>>>>>>>>>            End
95375>>>>>>>>>>
95375>>>>>>>>>        Loop
95376>>>>>>>>>>
95376>>>>>>>>>        Send AdjustSuggestionListSize iLines
95377>>>>>>>>>    End
95377>>>>>>>>>>
95377>>>>>>>>>
95377>>>>>>>>>    Set Cursor of Cursor_Control to IDC_ARROW
95378>>>>>>>>>    Send Activate of (Self)
95379>>>>>>>>>    Send Release_Mouse_Capture
95380>>>>>>>>>End_Procedure
95381>>>>>>>>>
95381>>>>>>>>>Procedure Home
95383>>>>>>>>>    If (Focus(Desktop) = Self and ghoSuggestionList) Begin
95385>>>>>>>>>        Send ScrollHome
95386>>>>>>>>>    End
95386>>>>>>>>>>
95386>>>>>>>>>    Else Begin
95387>>>>>>>>>        Send Key VK_HOME
95388>>>>>>>>>    End
95388>>>>>>>>>>
95388>>>>>>>>>End_Procedure
95389>>>>>>>>>
95389>>>>>>>>>Procedure ScrollHome
95391>>>>>>>>>    Send SelectRow of ghoSuggestionList 0
95392>>>>>>>>>End_Procedure
95393>>>>>>>>>
95393>>>>>>>>>Procedure End
95395>>>>>>>>>If (Focus(Desktop) = Self and ghoSuggestionList) Begin
95397>>>>>>>>>    Send ScrollEnd
95398>>>>>>>>>End
95398>>>>>>>>>>
95398>>>>>>>>>Else Begin
95399>>>>>>>>>    Send Key VK_END
95400>>>>>>>>>End
95400>>>>>>>>>>
95400>>>>>>>>>End_Procedure
95401>>>>>>>>>
95401>>>>>>>>>Procedure ScrollEnd
95403>>>>>>>>>    Integer iLine iLines
95403>>>>>>>>>    Get Line_Count of ghoSuggestionList  to iLines
95404>>>>>>>>>    Get SelectedRow of ghoSuggestionList to iLine
95405>>>>>>>>>    // there can be an extra line at the end
95405>>>>>>>>>    If (iLine < iLines - 1) Begin
95407>>>>>>>>>        Send SelectRow of ghoSuggestionList (iLines - 1)
95408>>>>>>>>>    End
95408>>>>>>>>>>
95408>>>>>>>>>End_Procedure
95409>>>>>>>>>
95409>>>>>>>>>Procedure Activating
95411>>>>>>>>>    String[] sSavedFormValues
95412>>>>>>>>>    If (pbUseWorkspaceIniFile(Self) = True) Begin
95414>>>>>>>>>        Get ReadWorkspaceIniFile to sSavedFormValues
95415>>>>>>>>>        Set psSavedFormValues    to sSavedFormValues
95416>>>>>>>>>    End
95416>>>>>>>>>>
95416>>>>>>>>>End_Procedure
95417>>>>>>>>>
95417>>>>>>>>>Procedure Set psToolTip String sToolTip
95419>>>>>>>>>    String sStatusHelp
95419>>>>>>>>>
95419>>>>>>>>>    Get Status_Help to sStatusHelp
95420>>>>>>>>>    If (sStatusHelp = "") Begin
95422>>>>>>>>>        Set Status_Help to sToolTip
95423>>>>>>>>>    End
95423>>>>>>>>>>
95423>>>>>>>>>
95423>>>>>>>>>    Move (sToolTip + String(Character(10)) + String(CS_cRDCSuggestionFormTooltip)) to sToolTip
95424>>>>>>>>>    Forward Set psToolTip to sToolTip
95426>>>>>>>>>End_Procedure
95427>>>>>>>>>
95427>>>>>>>>>Function ReadWorkspaceIniFile Returns String[]
95429>>>>>>>>>    String sWorkspaceFile sObjectName sValue
95429>>>>>>>>>    String[] sSavedFormValues
95430>>>>>>>>>    Handle hoIniFile
95430>>>>>>>>>    Integer iItem iCount iSize
95430>>>>>>>>>    Boolean bExists
95430>>>>>>>>>
95430>>>>>>>>>    If (pbUseWorkspaceIniFile(Self) = False) Begin
95432>>>>>>>>>        Function_Return sSavedFormValues
95433>>>>>>>>>    End
95433>>>>>>>>>>
95433>>>>>>>>>
95433>>>>>>>>>    Move 0 to iItem
95434>>>>>>>>>    Get Object_Label to sObjectName
95435>>>>>>>>>    Move (psWorkspaceWSFile(phoWorkspace(ghoApplication))) to sWorkspaceFile
95436>>>>>>>>>    Set psIniFileName to sWorkspaceFile
95437>>>>>>>>>    Get Create (RefClass(cIniFile)) to hoIniFile
95438>>>>>>>>>    Set psFileName of hoIniFile to sWorkspaceFile
95439>>>>>>>>>    Get piSuggestionListMaxItems to iSize
95440>>>>>>>>>
95440>>>>>>>>>    For iCount from 0 to iSize
95446>>>>>>>>>>
95446>>>>>>>>>        Get KeyExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) to bExists
95447>>>>>>>>>        // We need to loop through all possible values because the list of items may not start at zero.
95447>>>>>>>>>        Get ReadString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) "" to sValue
95448>>>>>>>>>        If (Trim(sValue) <> "") Begin
95450>>>>>>>>>            Move sValue to sSavedFormValues[iItem]
95451>>>>>>>>>            Increment iItem
95452>>>>>>>>>        End
95452>>>>>>>>>>
95452>>>>>>>>>    Loop
95453>>>>>>>>>>
95453>>>>>>>>>
95453>>>>>>>>>    Send Destroy of hoIniFile
95454>>>>>>>>>    Function_Return sSavedFormValues
95455>>>>>>>>>End_Function
95456>>>>>>>>>
95456>>>>>>>>>Procedure WriteWorkspaceIniFile
95458>>>>>>>>>    String sWorkspaceFile sObjectName sValue
95458>>>>>>>>>    String[] sSavedFormValues
95459>>>>>>>>>    Handle hoIniFile
95459>>>>>>>>>    Integer iSize iCount
95459>>>>>>>>>    Boolean bExists
95459>>>>>>>>>
95459>>>>>>>>>    If (pbUseWorkspaceIniFile(Self) = False) Begin
95461>>>>>>>>>        Procedure_Return
95462>>>>>>>>>    End
95462>>>>>>>>>>
95462>>>>>>>>>
95462>>>>>>>>>    Get Object_Label  to sObjectName
95463>>>>>>>>>    Get psIniFileName to sWorkspaceFile
95464>>>>>>>>>    Get Create (RefClass(cIniFile)) to hoIniFile
95465>>>>>>>>>    Set psFileName    of hoIniFile to sWorkspaceFile
95466>>>>>>>>>    Get SectionExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) to bExists
95467>>>>>>>>>    If (bExists = True) Begin
95469>>>>>>>>>        Send DeleteSection of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName))
95470>>>>>>>>>    End
95470>>>>>>>>>>
95470>>>>>>>>>
95470>>>>>>>>>    Get psSavedFormValues to sSavedFormValues
95471>>>>>>>>>    Move (SizeOfArray(sSavedFormValues)) to iSize
95472>>>>>>>>>    Decrement iSize
95473>>>>>>>>>
95473>>>>>>>>>    For iCount from 0 to iSize
95479>>>>>>>>>>
95479>>>>>>>>>        Move sSavedFormValues[iCount] to sValue
95480>>>>>>>>>        Move (Trim(sValue)) to sValue
95481>>>>>>>>>        Get vFilePathExists sValue to bExists
95482>>>>>>>>>        If (bExists = True) Begin
95484>>>>>>>>>            Send WriteString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) sSavedFormValues[iCount]
95485>>>>>>>>>        End
95485>>>>>>>>>>
95485>>>>>>>>>    Loop
95486>>>>>>>>>>
95486>>>>>>>>>
95486>>>>>>>>>    Send Destroy of hoIniFile
95487>>>>>>>>>End_Procedure
95488>>>>>>>>>
95488>>>>>>>>>Procedure Prompt
95490>>>>>>>>>    If (ghoSuggestionTimer=0) Begin
95492>>>>>>>>>        Send CreateSuggestionTimer
95493>>>>>>>>>    End
95493>>>>>>>>>>
95493>>>>>>>>>    Send ActivateSuggestionList
95494>>>>>>>>>    Send FindSuggestions
95495>>>>>>>>>    Set Visible_State of ghoSuggestionList to True
95496>>>>>>>>>End_Procedure
95497>>>>>>>>>
95497>>>>>>>>>Procedure OnExitObject
95499>>>>>>>>>    String sValue
95499>>>>>>>>>    Boolean bExists
95499>>>>>>>>>    String[] sSavedFormValues
95500>>>>>>>>>    Integer iSize iIndex
95500>>>>>>>>>
95500>>>>>>>>>    Forward Send OnExitObject
95502>>>>>>>>>
95502>>>>>>>>>    If (pbUseWorkspaceIniFile(Self) = False) Begin
95504>>>>>>>>>        Procedure_Return
95505>>>>>>>>>    End
95505>>>>>>>>>>
95505>>>>>>>>>
95505>>>>>>>>>    Get Value to sValue
95506>>>>>>>>>    Move (Trim(sValue)) to sValue
95507>>>>>>>>>    Get psSavedFormValues to sSavedFormValues
95508>>>>>>>>>    Move (SearchArray(sValue, sSavedFormValues)) to iIndex
95509>>>>>>>>>    // Does it exist in the array already?
95509>>>>>>>>>    If (iIndex <> -1) Begin
95511>>>>>>>>>        Procedure_Return
95512>>>>>>>>>    End
95512>>>>>>>>>>
95512>>>>>>>>>    Get vFilePathExists sValue to bExists
95513>>>>>>>>>    If (bExists = False) Begin
95515>>>>>>>>>        Procedure_Return
95516>>>>>>>>>    End
95516>>>>>>>>>>
95516>>>>>>>>>    Move (SizeOfArray(sSavedFormValues)) to iSize
95517>>>>>>>>>    Move sValue to sSavedFormValues[iSize]
95518>>>>>>>>>    Set psSavedFormValues to sSavedFormValues
95519>>>>>>>>>    Send WriteWorkspaceIniFile
95520>>>>>>>>>End_Procedure
95521>>>>>>>>>
95521>>>>>>>>>// Custom code to find all matches for the search
95521>>>>>>>>>Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
95523>>>>>>>>>    String[] sSavedFormValues
95524>>>>>>>>>    Integer i iLen iSize iCount
95524>>>>>>>>>
95524>>>>>>>>>    Move (Lowercase(sSearch)) to sSearch
95525>>>>>>>>>    Move (Length(sSearch)) to iLen
95526>>>>>>>>>    Get psSavedFormValues to sSavedFormValues
95527>>>>>>>>>    Move (SizeOfArray(sSavedFormValues)) to iSize
95528>>>>>>>>>    Decrement iSize
95529>>>>>>>>>    For i from 0 to iSize
95535>>>>>>>>>>
95535>>>>>>>>>        If (Lowercase(sSavedFormValues[i]) contains sSearch) Begin
95537>>>>>>>>>            Move sSavedFormValues[i] to aSuggestions[iCount].sRowId
95538>>>>>>>>>            Move sSavedFormValues[i] to aSuggestions[iCount].aValues[0]
95539>>>>>>>>>            Increment iCount
95540>>>>>>>>>        End
95540>>>>>>>>>>
95540>>>>>>>>>    Loop
95541>>>>>>>>>>
95541>>>>>>>>>End_Procedure
95542>>>>>>>>>
95542>>>>>>>>>Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
95544>>>>>>>>>    Boolean bExists bAutoCheckValueExistsAsFile bAskToRemoveMissingFile
95544>>>>>>>>>    Integer iRetval iIndex
95544>>>>>>>>>    String[] sSavedFormValues
95545>>>>>>>>>    String sValue
95545>>>>>>>>>
95545>>>>>>>>>    //        Send Release_Mouse_Capture
95545>>>>>>>>>    Move Suggestion.sRowId to sValue
95546>>>>>>>>>    Move (Trim(sValue)) to sValue
95547>>>>>>>>>    Get pbAutoCheckValueExistsAsFile to bAutoCheckValueExistsAsFile
95548>>>>>>>>>
95548>>>>>>>>>    If (bAutoCheckValueExistsAsFile = True) Begin
95550>>>>>>>>>        Get pbAskToRemoveMissingFile to bAskToRemoveMissingFile
95551>>>>>>>>>        Get vFilePathExists sValue to bExists
95552>>>>>>>>>        If (bExists = False) Begin
95554>>>>>>>>>            If (bAskToRemoveMissingFile = True) Begin
95556>>>>>>>>>                Get YesNo_Box ("The file" * String(sValue) + "\nDoesn't exist. Do you want to remove it from the suggestion list?") to iRetval
95557>>>>>>>>>            End
95557>>>>>>>>>>
95557>>>>>>>>>            // This will happen if bAskToRemoveMissingFile = False, and bAutoCheckValueExistsAsFile = True.
95557>>>>>>>>>            // Then the missing file will just be removed from the saved list.
95557>>>>>>>>>            Else Begin
95558>>>>>>>>>                Move MBR_Yes to iRetval
95559>>>>>>>>>            End
95559>>>>>>>>>>
95559>>>>>>>>>
95559>>>>>>>>>            If (iRetval = MBR_Yes) Begin
95561>>>>>>>>>                Get psSavedFormValues to sSavedFormValues
95562>>>>>>>>>                Move (SearchArray(sValue, sSavedFormValues)) to iIndex
95563>>>>>>>>>                If (iIndex <> -1) Begin
95565>>>>>>>>>                    Move (RemoveFromArray(sSavedFormValues, iIndex)) to sSavedFormValues
95566>>>>>>>>>                    Set psSavedFormValues to sSavedFormValues
95567>>>>>>>>>                    Send WriteWorkspaceIniFile
95568>>>>>>>>>                    Set Value to ""
95569>>>>>>>>>                    Procedure_Return
95570>>>>>>>>>                End
95570>>>>>>>>>>
95570>>>>>>>>>            End
95570>>>>>>>>>>
95570>>>>>>>>>        End
95570>>>>>>>>>>
95570>>>>>>>>>    End
95570>>>>>>>>>>
95570>>>>>>>>>
95570>>>>>>>>>    Set Value to Suggestion.sRowId
95571>>>>>>>>>    Set Item_Changed_State to False
95572>>>>>>>>>End_Procedure
95573>>>>>>>>>
95573>>>>>>>>>//    { MethodType=Event  NoDoc=True }
95573>>>>>>>>>//    Procedure Mouse_Click Integer i1 Integer i2
95573>>>>>>>>>//        Send Release_Mouse_Capture
95573>>>>>>>>>//        Forward Send Mouse_click i1 i2
95573>>>>>>>>>//    End_Procedure
95573>>>>>>>>>
95573>>>>>>>>>End_Class
95574>>>>>>>>>
95574>>>>>>>>>//    Procedure Mouse_Up for cRDCSuggestionList Integer iWindowNumber Integer iPosition
95574>>>>>>>>>//        Handle hoObj
95574>>>>>>>>>//        Send Release_Mouse_Capture
95574>>>>>>>>>//        Get phoOwner to hoObj
95574>>>>>>>>>//        Send Activate of hoObj // move focus to owner, which will close the list
95574>>>>>>>>>//        Send SelectSuggestion of hoObj
95574>>>>>>>>>//    End_Procedure // Mouse_Up
95574>>>>>>>>>
95574>>>>>>>>>//    Function OnWindowsHook for cRDCSuggestionHookMouse Integer i1 Integer i2 Integer i3 Returns Integer
95574>>>>>>>>>//        tWinMouseHookStruct MouseHook
95574>>>>>>>>>//        Integer ivoid hObj
95574>>>>>>>>>//        Handle hoOwner hoParent
95574>>>>>>>>>//        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;
95574>>>>>>>>>//                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
95574>>>>>>>>>//            Send Release_Mouse_Capture
95574>>>>>>>>>//            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
95574>>>>>>>>>//            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
95574>>>>>>>>>//            If (hObj = Cursor_Control) Begin
95574>>>>>>>>>//                Move (Focus(Desktop)) to hObj
95574>>>>>>>>>//            End
95574>>>>>>>>>//            Get Parent to hoParent
95574>>>>>>>>>//            Get phoOwner of hoParent to hoOwner
95574>>>>>>>>>//            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
95574>>>>>>>>>//                Send DisableWindowsHook
95574>>>>>>>>>//                Send DeActivateSuggestionList of hoOwner
95574>>>>>>>>>//            End
95574>>>>>>>>>//        End
95574>>>>>>>>>//    End_Function
95574>>>>>>>>>
95574>>>>>>>Use cDbUpdateFunctionLibrary.pkg
95574>>>>>>>Use cRDCHeaderGroup.pkg
95574>>>>>>>Use cCommandLinkButton.pkg
95574>>>>>>>
95574>>>>>>>Object oCreateDatabase_dg is a cRDCModalPanel
95576>>>>>>>    Set Size to 151 312
95577>>>>>>>    Set Label to "Create New Database"
95578>>>>>>>    Set piMinSize to 53 211
95579>>>>>>>    Set Location to 2 2
95580>>>>>>>    Set Icon to "ActionCreateDatabase1.ico"
95581>>>>>>>    
95581>>>>>>>    Property String psDriverID                   
95583>>>>>>>    Property String psCollation 
95585>>>>>>>    Property String psDatabaseName 
95587>>>>>>>
95587>>>>>>>//    Object oCollate_cf is a cRDCComboForm
95587>>>>>>>//        Set Size to 13 216
95587>>>>>>>//        Set Location to 42 63
95587>>>>>>>//        Set Label to "Use Collation:"  
95587>>>>>>>//        Set psToolTip to "Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
95587>>>>>>>//        // This must be set to False; else the filling takes for ever.
95587>>>>>>>//        Set pbAutoListWidth to False
95587>>>>>>>//        
95587>>>>>>>//        Procedure Combo_Fill_List
95587>>>>>>>//            String[] asCollations   
95587>>>>>>>//            Integer iCount iSize      
95587>>>>>>>//            String sDriverID sCollation
95587>>>>>>>//            
95587>>>>>>>//            Get psDriverID to sDriverID      
95587>>>>>>>//            
95587>>>>>>>//            // The _SqlEnumerateDatabaseCollations function is *at current* for MSSQLDRV_ID only.
95587>>>>>>>//            If (sDriverID = MSSQLDRV_ID) Begin
95587>>>>>>>//                Send Cursor_Wait of Cursor_Control
95587>>>>>>>//                Get _SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
95587>>>>>>>//                Move (SizeOfArray(asCollations)) to iSize
95587>>>>>>>//                Decrement iSize
95587>>>>>>>//                For iCount from 0 to iSize
95587>>>>>>>//                    Send Combo_Add_Item asCollations[iCount]
95587>>>>>>>//                Loop
95587>>>>>>>//                
95587>>>>>>>//                Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
95587>>>>>>>//                Set Value to sCollation
95587>>>>>>>//                Send Cursor_Ready of Cursor_Control
95587>>>>>>>//            End
95587>>>>>>>//        End_Procedure
95587>>>>>>>//    
95587>>>>>>>//        Procedure OnChange
95587>>>>>>>//            String sValue
95587>>>>>>>//            Get Value to sValue
95587>>>>>>>//            Set psCollation to sValue
95587>>>>>>>//        End_Procedure
95587>>>>>>>//     
95587>>>>>>>//    End_Object
95587>>>>>>>
95587>>>>>>>    Object oInfo_tb is a TextBox
95589>>>>>>>        Set Auto_Size_State to False
95590>>>>>>>        Set Size to 8 50
95591>>>>>>>        Set Location to 133 120
95592>>>>>>>        Set TextColor to clGreen
95593>>>>>>>        Set Justification_Mode to JMode_Right
95594>>>>>>>        Set peAnchors to anBottomRight
95595>>>>>>>    End_Object
95596>>>>>>>
95596>>>>>>>    Object oMain_RDCHeaderGroup is a cRDCHeaderGroup
95598>>>>>>>        Set Size to 108 293
95599>>>>>>>        Set Location to 8 10
95600>>>>>>>        Set psImage to "ActionCreateDatabase1.ico"
95601>>>>>>>        Set Label to "Create Database"
95602>>>>>>>        Set psNote to "Enter collation and database name"
95603>>>>>>>        Set peAnchors to anTopBottom
95604>>>>>>>
95604>>>>>>>        Object oDriver_fm is a cRDCForm
95606>>>>>>>            Set Size to 13 100
95607>>>>>>>            Set Location to 34 63
95608>>>>>>>            Set Label to "Driver"
95609>>>>>>>            Set Enabled_State to False  
95610>>>>>>>        End_Object  
95611>>>>>>>        
95611>>>>>>>        Object oServerCurrentCollating_fm is a cRDCForm
95613>>>>>>>            Set Size to 13 216
95614>>>>>>>            Set Location to 49 63
95615>>>>>>>            Set Label to "Default Collation"
95616>>>>>>>            Set psToolTip to "The SQL server's default collation. It will be used when creating a new database, if nothing else is specified."
95617>>>>>>>            Set Enabled_State to False  
95618>>>>>>>            
95618>>>>>>>            Procedure InitializeCollation 
95621>>>>>>>                String sCollation
95621>>>>>>>                
95621>>>>>>>                Move False to Err
95622>>>>>>>                Send Ignore_All of Error_Object_Id
95623>>>>>>>                // Fetch the SQL server's default collation:
95623>>>>>>>                // It will be used when creating a new database, if nothing else is specified.
95623>>>>>>>                Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary "master" False to sCollation
95624>>>>>>>                Send Trap_All of Error_Object_Id
95625>>>>>>>                If (Err = True) Begin
95627>>>>>>>                    Move "" to sCollation
95628>>>>>>>                End
95628>>>>>>>>
95628>>>>>>>                Set Value to sCollation
95629>>>>>>>            End_Procedure     
95630>>>>>>>    
95630>>>>>>>        End_Object  
95631>>>>>>>        
95631>>>>>>>        Object oCollate_fm is a cRDCSuggestionIniForm 
95633>>>>>>>            Set Size to 13 216
95634>>>>>>>            Set Location to 65 63
95635>>>>>>>            Set Label to "Collation"
95636>>>>>>>            Set psToolTip to "Suggestion list. Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
95637>>>>>>>            Set pbAskToRemoveMissingFile to False
95638>>>>>>>            Set pbAutoCheckValueExistsAsFile to False
95639>>>>>>>            Set pbUseWorkspaceIniFile to True
95640>>>>>>>            Set piStartAtChar to 3
95641>>>>>>>            Set Prompt_Button_Mode to PB_PromptOn
95642>>>>>>>            
95642>>>>>>>            Function ReadWorkspaceIniFile Returns String[]
95645>>>>>>>                String[] asCollations   
95646>>>>>>>                Integer iCount iSize      
95646>>>>>>>                String sDriverID sCollation
95646>>>>>>>                
95646>>>>>>>                Get psDriverID to sDriverID      
95647>>>>>>>                // The _SqlEnumerateDatabaseCollations function is at current for MSSQLDRV_ID only.
95647>>>>>>>                If (sDriverID <> MSSQLDRV_ID) Begin
95649>>>>>>>                    Function_Return asCollations
95650>>>>>>>                End                 
95650>>>>>>>>
95650>>>>>>>                
95650>>>>>>>                Send Cursor_Wait of Cursor_Control
95651>>>>>>>                Get _SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
95652>>>>>>>                Set psSavedFormValues to asCollations
95653>>>>>>>                    
95653>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
95655>>>>>>>                    Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
95656>>>>>>>                    Set Value to sCollation
95657>>>>>>>                End
95657>>>>>>>>
95657>>>>>>>                Send Cursor_Ready of Cursor_Control
95658>>>>>>>                Function_Return asCollations
95659>>>>>>>            End_Function
95660>>>>>>>    
95660>>>>>>>            Procedure OnChange
95663>>>>>>>                String sValue
95663>>>>>>>                Get Value to sValue
95664>>>>>>>                Set psCollation to sValue
95665>>>>>>>            End_Procedure
95666>>>>>>>         
95666>>>>>>>            Procedure WriteWorkspaceIniFile
95669>>>>>>>            End_Procedure             
95670>>>>>>>            
95670>>>>>>>//            Procedure Prompt      
95670>>>>>>>//                If (ghoSuggestionTimer=0) Begin
95670>>>>>>>//                    Send CreateSuggestionTimer
95670>>>>>>>//                End
95670>>>>>>>//                Send ActivateSuggestionList
95670>>>>>>>//                Send FindSuggestions
95670>>>>>>>//                Set Visible_State of ghoSuggestionList to True
95670>>>>>>>//            End_Procedure 
95670>>>>>>>            
95670>>>>>>>            Procedure OnEnterObject
95673>>>>>>>                Set pbUseWorkspaceIniFile to True
95674>>>>>>>                Forward Send OnEnterObject
95676>>>>>>>            End_Procedure
95677>>>>>>>
95677>>>>>>>            Procedure OnExitObject
95680>>>>>>>                Set pbUseWorkspaceIniFile to False
95681>>>>>>>                Forward Send OnExitObject
95683>>>>>>>            End_Procedure
95684>>>>>>>        
95684>>>>>>>            On_Key kCancel Send KeyAction of oCancel_Btn   
95685>>>>>>>//            On_Key kPrompt Send Prompt
95685>>>>>>>        End_Object   
95686>>>>>>>        
95686>>>>>>>        Object oDatabaseName_fm is a cRDCForm
95688>>>>>>>            Set Size to 13 216
95689>>>>>>>            Set Location to 81 63
95690>>>>>>>            Set Label_Col_Offset to 2
95691>>>>>>>            Set Label_Justification_Mode to JMode_Right
95692>>>>>>>            Set Label to "Database Name"
95693>>>>>>>            Set psToolTip to "Specify the name of the database to be created."
95694>>>>>>>        End_Object
95695>>>>>>>    
95695>>>>>>>    End_Object
95696>>>>>>>
95696>>>>>>>    Object oOK_Btn is a Button
95698>>>>>>>        Set Label    to "&OK"
95699>>>>>>>        Set Location to 130 198
95700>>>>>>>        Set peAnchors to anBottomRight   
95701>>>>>>>        
95701>>>>>>>        Property String psWorkingText "Working..."
95703>>>>>>>        Property String psIdleText    ""
95705>>>>>>>
95705>>>>>>>        Procedure OnClick
95708>>>>>>>            String sDatabase sDriverID sCollation
95708>>>>>>>            Boolean bOK bExists
95708>>>>>>>        
95708>>>>>>>            Get Value of oDatabaseName_fm to sDatabase    
95709>>>>>>>            Get psDriverID to sDriverID
95710>>>>>>>            Set psDatabaseName to ""
95711>>>>>>>
95711>>>>>>>            If (sDatabase <> "" and sDriverID <> "") Begin    
95713>>>>>>>                Set Value of oInfo_tb to (psWorkingText(Self))
95714>>>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
95716>>>>>>>                    Get psCollation to sCollation
95717>>>>>>>                    Set psCollation of ghoDbUpdateFunctionLibrary to sCollation
95718>>>>>>>                End
95718>>>>>>>>
95718>>>>>>>
95718>>>>>>>                Get SqlUtilCheckIfDatabaseExists of ghoDbUpdateFunctionLibrary sDatabase to bExists
95719>>>>>>>                If (bExists = True) Begin
95721>>>>>>>                    Set Value of oInfo_tb to ""
95722>>>>>>>                    Send Info_Box "The database already exists. No changes made."
95723>>>>>>>                    Procedure_Return
95724>>>>>>>                End
95724>>>>>>>>
95724>>>>>>>                Send Cursor_Wait of Cursor_Control     
95725>>>>>>>                Get SqlDatabaseCreate of ghoDbUpdateFunctionLibrary sDriverID sDatabase False False to bOK
95726>>>>>>>                Send Cursor_Ready of Cursor_Control
95727>>>>>>>                Set Value of oInfo_tb to (psIdleText(Self))
95728>>>>>>>                If (bOK = False) Begin
95730>>>>>>>                    Send Info_Box ("Something went wrong and the database could NOT be created. Please check your database manager.")
95731>>>>>>>                    Procedure_Return
95732>>>>>>>                End 
95732>>>>>>>>
95732>>>>>>>                Set psDatabaseName to sDatabase
95733>>>>>>>                Send Close_Panel
95734>>>>>>>            End                                 
95734>>>>>>>>
95734>>>>>>>            Else If (sDatabase = "") Begin
95737>>>>>>>                Send Info_Box ("Please enter a database name and try again.")
95738>>>>>>>            End
95738>>>>>>>>
95738>>>>>>>        End_Procedure
95739>>>>>>>
95739>>>>>>>    End_Object
95740>>>>>>>
95740>>>>>>>    Object oCancel_Btn is a Button
95742>>>>>>>        Set Label    to "&Cancel"
95743>>>>>>>        Set Location to 130 253
95744>>>>>>>        Set peAnchors to anBottomRight
95745>>>>>>>
95745>>>>>>>        Procedure OnClick
95748>>>>>>>            Send Close_Panel
95749>>>>>>>        End_Procedure
95750>>>>>>>
95750>>>>>>>    End_Object
95751>>>>>>>
95751>>>>>>>    Object oHelp_btn is a Button
95753>>>>>>>        Set Location to 130 75
95754>>>>>>>        Set Label to "Help"
95755>>>>>>>        Set psImage to "ActionHelpInternet1.ico"
95756>>>>>>>        Set psToolTip to "Show a Full List of Collations Supported in SQL Server 2017"
95757>>>>>>>        Set peAnchors to anBottomLeft
95758>>>>>>>    
95758>>>>>>>        Procedure OnClick
95761>>>>>>>            Runprogram Shell Background "https://database.guide/full-list-of-collations-supported-in-sql-server-2017/"
95762>>>>>>>        End_Procedure
95763>>>>>>>    
95763>>>>>>>    End_Object
95764>>>>>>>    
95764>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
95765>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
95766>>>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
95767>>>>>>>End_Object
95768>>>>>>>
95768>>>>>>>Function Create_DataBase_Dialog String sDriverID Returns String
95771>>>>>>>    String sDatabaseName         
95771>>>>>>>    Handle ho
95771>>>>>>>    
95771>>>>>>>    Move (oCreateDatabase_dg(Self)) to ho
95772>>>>>>>    Set psDriverID of ho to sDriverID
95773>>>>>>>    Set Value of (oDriver_fm(ho)) to sDriverID
95774>>>>>>>    Set Value of (oDatabaseName_fm(ho)) to ""
95775>>>>>>>    Send InitializeCollation of (oServerCurrentCollating_fm(ho))
95776>>>>>>>    Send Popup of ho
95777>>>>>>>    
95777>>>>>>>    Get psDatabaseName of ho to sDatabaseName
95778>>>>>>>    Function_Return sDatabaseName
95779>>>>>>>End_Function                         
95780>>>>>
95780>>>>>Define CS_LoadingServers        for "Enumerating servers..."
95780>>>>>Define CS_LoadingDatabases      for "Enumerating databases..."
95780>>>>>Define CS_LoadingTableSpaces    for "Enumerating table spaces..."
95780>>>>>Define CS_LoadingSchemas        for "Enumerating schemas..."
95780>>>>>Define CS_LoginAttempt          for "Connecting..."
95780>>>>>Define CS_LoginSuccessful       for "Login successful!"
95780>>>>>Define CS_LoginFailed           for "Login failed!"
95780>>>>>Define CS_DF_File_Schema        for "Schema"
95780>>>>>Define CS_DF_File_Owner         for "Owner"
95780>>>>>
95780>>>>>Object oSQLMaintainConnections_dg is a ModalPanel
95782>>>>>    Set Label to "Edit SQL Connection"
95783>>>>>    Set Size to 315 324 //309 324
95784>>>>>    Set Location to 4 6
95785>>>>>    Set piMaxSize to (Hi(Size(Self))) (Low(Size(Self)) + 300)
95786>>>>>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
95787>>>>>    Set Locate_Mode to CENTER_ON_PARENT
95788>>>>>    Set Border_Style to Border_Thick
95789>>>>>    
95789>>>>>    Property Boolean pbReadOnly  False
95791>>>>>    Property Boolean pbNew       False // First time for a workspace, which means the .ini-file is empty.
95793>>>>>    Property Integer piCurrentRow -1   // The current row of the grid that was passed to this dialog.
95795>>>>>    Property Boolean pbChanged   False // If any change was made to the data.
95797>>>>>    Property Handle phoDialogCommandbar
95799>>>>>    Property tSQLConnection pSQLConnectionData
95801>>>>>    Property tDataSourceRow[] pTheData
95803>>>>>    Property Boolean pbDFConnId  False // Is set to True if this is a DAW "DFConnId.ini" file; in which case we warn to not encrypt/decrypt password. (different algorithms and don't touch password)
95805>>>>>    Property String psUncryptedPw      // Used if  pbDFConnId = True to temporary save the un-encrypted password.
95807>>>>>
95807>>>>>    Object oSettings_grp is a cRDCHeaderGroup
95809>>>>>        Set Size to 202 303
95810>>>>>        Set Location to 77 11 //71 11
95811>>>>>        Set psImage to "Settings1.ico"
95812>>>>>        Set psLabel to "SQL Connection Settings"
95813>>>>>        Set peAnchors to anTopLeftRight
95814>>>>>        Set psToolTip to "Setup the SQL connection."
95815>>>>>
95815>>>>>        Object oConnectionID_fm is a cSQLForm
95817>>>>>            Set Size to 13 115
95818>>>>>            Set Location to 22 82
95819>>>>>            Set Label to "Connection ID"
95820>>>>>            Set psToolTip to "The DFConnectionID keyword to set a default connection id for the driver. This is the connection ID that appear in database table .int files with the format; 'SERVER_NAME DFCONNID=MyConnID'"
95821>>>>>            Set piItem to 2
95822>>>>>            Set peAnchors to anTopLeftRight
95823>>>>>        End_Object
95824>>>>>
95824>>>>>        Object oEnabled_cb is a cSQLCheckBox
95826>>>>>            Set Size to 10 36
95827>>>>>            Set Location to 25 210
95828>>>>>            Set Label to "Enabled"
95829>>>>>            Set psToolTip to "Check to indicate that this is the enabled connection. Note: There can only be one enabled connection at a time."
95830>>>>>            Set piItem to 1
95831>>>>>            Set peAnchors to anTopRight
95832>>>>>
95832>>>>>            Procedure OnChange
95835>>>>>                Boolean bChecked bNew
95835>>>>>                tSQLConnection SQLConnection
95835>>>>>                tSQLConnection SQLConnection
95835>>>>>
95835>>>>>                Get pbNew to bNew
95836>>>>>                Get Checked_State to bChecked
95837>>>>>                If (bNew = False and bChecked = True) Begin
95839>>>>>                    Get pSQLConnectionData to SQLConnection
95840>>>>>                    Move True to SQLConnection.bEnabled
95841>>>>>                End
95841>>>>>>
95841>>>>>
95841>>>>>            End_Procedure
95842>>>>>
95842>>>>>        End_Object
95843>>>>>
95843>>>>>        Object oODBC_rgp is a RadioGroup
95845>>>>>            Set Location to 38 24
95846>>>>>            Set Size to 32 173
95847>>>>>//            Set psToolTip to "Only available if the ODBC_DRV has been selected. Depending on the radio button that is selected the 'Server/DSN' selection list shows different values."
95847>>>>>            Set peAnchors to anTopLeftRight
95848>>>>>            Set Label to "ODBC Source Type"
95849>>>>>
95849>>>>>            Object oRadio0 is a Radio
95851>>>>>                Set Label to "User data"
95852>>>>>                Set Size to 10 44
95853>>>>>                Set Location to 12 5
95854>>>>>            End_Object
95855>>>>>
95855>>>>>            Object oRadio1 is a Radio
95857>>>>>                Set Label to "System data"
95858>>>>>                Set Size to 10 52
95859>>>>>                Set Location to 12 52
95860>>>>>            End_Object
95861>>>>>
95861>>>>>            Object oRadio2 is a Radio
95863>>>>>                Set Label to "Both"
95864>>>>>                Set Size to 10 26
95865>>>>>                Set Location to 13 109
95866>>>>>            End_Object
95867>>>>>
95867>>>>>            Object oRadio3 is a Radio
95869>>>>>                Set Label to "File"
95870>>>>>                Set Size to 10 25
95871>>>>>                Set Location to 13 141
95872>>>>>            End_Object
95873>>>>>
95873>>>>>            Procedure Notify_Select_State Integer iToItem Integer iFromItem
95876>>>>>                Forward Send Notify_Select_State iToItem iFromItem 
95878>>>>>                If (oFileDSN_btn(Self) <> 0) Begin
95880>>>>>                    Set Enabled_State of oFileDSN_btn to (iToItem = 3)
95881>>>>>                End
95881>>>>>>
95881>>>>>            End_Procedure
95882>>>>>
95882>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
95885>>>>>                Set Enabled_State to (sDriverID = ODBC_DRV_ID)
95886>>>>>                Set Enabled_State of oODBC_rgp to (sDriverID = ODBC_DRV_ID)
95887>>>>>            End_Procedure
95888>>>>>
95888>>>>>            Set Current_Radio to 2
95889>>>>>        End_Object
95890>>>>>
95890>>>>>        Object oFileDSN_btn is a cRDCButton
95892>>>>>            Set Size to 13 78
95893>>>>>            Set Location to 42 210
95894>>>>>            Set Label to "Select File DSN..."
95895>>>>>            Set pbAutoEnable to True
95896>>>>>            Set peAnchors to anTopRight
95897>>>>>
95897>>>>>            Procedure OnClick
95900>>>>>                String sFileName
95900>>>>>                Get vSelect_File ("Data Sources (*.dsn)|*.dsn|All Files (*.*)|*.*") "Select a file data source" "" to sFileName
95901>>>>>                If (sFileName <> "") Begin
95903>>>>>                    Set Value of oServer_fm to sFileName
95904>>>>>                End
95904>>>>>>
95904>>>>>            End_Procedure     
95905>>>>>            
95905>>>>>            Function IsEnabled Returns Boolean
95908>>>>>                String sDriverID
95908>>>>>                Integer iRadio
95908>>>>>                Get Value of oDriverID_cf to sDriverID
95909>>>>>                Get Current_Radio of oODBC_rgp to iRadio
95910>>>>>                Function_Return (sDriverID = ODBC_DRV_ID and iRadio = 3)
95911>>>>>            End_Function
95912>>>>>
95912>>>>>        End_Object
95913>>>>>
95913>>>>>        Object oODBCAdmin_btn is a cRDCButton
95915>>>>>            Set Size to 13 78
95916>>>>>            Set Location to 57 210
95917>>>>>            Set Label to "ODBC Admin" 
95918>>>>>            Set psImage to "ODBCAD32.ico"
95919>>>>>            Set pbAutoEnable to True
95920>>>>>            Set peAnchors to anTopRight
95921>>>>>            
95921>>>>>            Procedure OnClick
95924>>>>>                Handle hWnd
95924>>>>>                Get Window_Handle to hWnd
95925>>>>>                If (hWnd <> 0) Begin
95927>>>>>                    Call_Driver 0 ODBC_DRV_ID Function ODBC_MANAGE_DATA_SOURCES Callback 0 Passing CLI$StrDummy CLI$StrDummy !1 Result CLI$IntDummy
95932>>>>>                End
95932>>>>>>
95932>>>>>                Else Begin
95933>>>>>                    Send Stop_Box "Could not get a Windows handle.."
95934>>>>>                End
95934>>>>>>
95934>>>>>            End_Procedure
95935>>>>>
95935>>>>>            Function IsEnabled Returns Boolean
95938>>>>>                String sDriverID
95938>>>>>                Get Value of oDriverID_cf to sDriverID
95939>>>>>                Function_Return (sDriverID = ODBC_DRV_ID)
95940>>>>>            End_Function
95941>>>>>
95941>>>>>        End_Object
95942>>>>>
95942>>>>>        Object oServer_fm is a cSQLForm
95944>>>>>            Set Size to 13 114
95945>>>>>            Set Location to 74 82
95946>>>>>            Set Label to "Server"
95947>>>>>            Set psToolTip to "Server/DSN: Depending on the selected database type the label can either display as 'Server' or 'DSN'. Either enter the name - if you know it - or by using the selection list (F4). Tip: If you are using Microsoft SQL Server and you are testing on the same machine as the MS SQL Server instance is running and you are using SQLEXPRESS you can enter e.g. '.\SQLEXPRESS'. That will mean use the SQLEXPRESS instance of Microsoft SQL Server running on this machine. If you press [F4] and the selection list comes up empty for Microsoft SQL Server it probably is because the service hasn't been started. Type 'Services' in Windows menu system to start Windows Services app. Type 'SQL' to jump to the SQL Server services. Check that the 'SQL Server Browser' service is started and set to 'Automatic'."
95948>>>>>            Set piItem to 5
95949>>>>>            Set peAnchors to anTopLeftRight
95950>>>>>
95950>>>>>            Property Handle phoPromptObject (oServerSelection_sl(Self))
95952>>>>>
95952>>>>>            Procedure Prompt
95955>>>>>                String sDriverID sValue
95955>>>>>                String[] sTheData
95956>>>>>                Integer iDbType iODBCType iRadio iPos
95956>>>>>                Handle ho
95956>>>>>
95956>>>>>                Get Prompt_Object to ho
95957>>>>>                If (ho = 0) Begin
95959>>>>>                    Procedure_Return
95960>>>>>                End
95960>>>>>>
95960>>>>>
95960>>>>>                Set Label of oShowInfo_tb to CS_LoadingServers
95961>>>>>                Send Cursor_Wait of Cursor_Control
95962>>>>>                Get SelectedDbType of oDbType_cf to iDbType
95963>>>>>                Get Value of oDriverID_cf to sDriverID
95964>>>>>                Move (Trim(sDriverID)) to sDriverID
95965>>>>>                Get Current_Radio of oODBC_rgp to iRadio
95966>>>>>                If (iRadio = 0) Begin
95968>>>>>                    Move SQL_FETCH_USER   to iODBCType
95969>>>>>                End
95969>>>>>>
95969>>>>>                If (iRadio = 1) Begin
95971>>>>>                    Move SQL_FETCH_SYSTEM to iODBCType
95972>>>>>                End
95972>>>>>>
95972>>>>>                If (iRadio = 2) Begin
95974>>>>>                    Move SQL_FETCH_ALL    to iODBCType
95975>>>>>                End
95975>>>>>>
95975>>>>>
95975>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
95976>>>>>                Load_Driver sDriverID
95977>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
95978>>>>>                If (LastErr = DFERR_CANT_LOAD_DLL) Begin
95980>>>>>                    Send Cursor_Ready of Cursor_Control
95981>>>>>                    Send Info_Box ("Can't display any items because the database driver could not be loaded. (" + sDriverID + ")")
95982>>>>>                    Procedure_Return
95983>>>>>                End
95983>>>>>>
95983>>>>>
95983>>>>>                Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID iODBCType to sTheData
95984>>>>>                Set psTheData  of ho to sTheData
95985>>>>>                Set Label of oShowInfo_tb to ""
95986>>>>>
95986>>>>>                Forward Send Prompt
95988>>>>>
95988>>>>>                // The selection list will show the ODBC DataSource name + a comma (,) + a description.
95988>>>>>                // We need to remove those parts from the comma and to the end of string.
95988>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
95990>>>>>                    Get Value to sValue
95991>>>>>                    Move (Pos(",", sValue)) to iPos
95992>>>>>                    Move (Left(sValue, (iPos - 1))) to sValue
95993>>>>>                    Set Value to sValue
95994>>>>>                End
95994>>>>>>
95994>>>>>            End_Procedure
95995>>>>>
95995>>>>>            Procedure OnChange
95998>>>>>                tSQLIntTableInfo[] sReturnStructArray
95998>>>>>                tSQLIntTableInfo[] sReturnStructArray
95999>>>>>                String sServer sDatabaseName sVal sDriverID
95999>>>>>                Integer iSize iCount iPos 
95999>>>>>                Boolean bFileDSN
95999>>>>>                
95999>>>>>                Move False to bFileDSN
96000>>>>>                Get Value of oDriverID_cf to sDriverID
96001>>>>>                If (sDriverID = "") Begin
96003>>>>>                    Procedure_Return
96004>>>>>                End
96004>>>>>>
96004>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
96006>>>>>                    Move "" to sDatabaseName
96007>>>>>                    Get Value to sServer 
96008>>>>>                    Move (Pos(",", sServer)) to iPos
96009>>>>>                    If (iPos <> 0) Begin
96011>>>>>                        Move (Left(sServer, (iPos -1))) to sServer
96012>>>>>                    End
96012>>>>>>
96012>>>>>                    If (sServer <> "") Begin
96014>>>>>                        Set psServer of ghoDbUpdateFunctionLibrary to sServer
96015>>>>>                    End
96015>>>>>>
96015>>>>>                    Get _SqlDatabasesArrayODBC of ghoDbUpdateFunctionLibrary to sReturnStructArray
96016>>>>>                    If (SizeOfArray(sReturnStructArray)) Begin
96018>>>>>                        If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
96020>>>>>                            // If a FILEDSN: (can only be one database name)
96020>>>>>                            Move sReturnStructArray[0].sDatabaseName to sDatabaseName
96021>>>>>                            Move True to bFileDSN
96022>>>>>                        End
96022>>>>>>
96022>>>>>                        Else Begin
96023>>>>>                            // Else the DSN's were read from the registry.
96023>>>>>                            Move (SizeOfArray(sReturnStructArray)) to iSize
96024>>>>>                            Decrement iSize
96025>>>>>                            For iCount from 0 to iSize
96031>>>>>>
96031>>>>>                                Move (sReturnStructArray[iCount].sServerName) to sVal
96032>>>>>                                If (Uppercase(sServer) = Uppercase(sVal)) Begin
96034>>>>>                                    Move sReturnStructArray[iCount].sDatabaseName to sDatabaseName
96035>>>>>                                    Move iSize to iCount // We're done.
96036>>>>>                                End
96036>>>>>>
96036>>>>>                            Loop
96037>>>>>>
96037>>>>>                        End
96037>>>>>>
96037>>>>>                    End
96037>>>>>>
96037>>>>>                    Set Value of oDatabase_fm to sDatabaseName
96038>>>>>                    If (bFileDSN = True) Begin
96040>>>>>                        Set Current_Radio of oODBC_rgp to 3
96041>>>>>                    End    
96041>>>>>>
96041>>>>>                    Else Begin
96042>>>>>                        Set Current_Radio of oODBC_rgp to 2
96043>>>>>                    End
96043>>>>>>
96043>>>>>                End
96043>>>>>>
96043>>>>>
96043>>>>>            End_Procedure
96044>>>>>
96044>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96047>>>>>                String sLabel
96047>>>>>                Handle ho
96047>>>>>
96047>>>>>                Get phoPromptObject to ho
96048>>>>>                Set Prompt_Button_Mode to PB_PromptOn
96049>>>>>                Case Begin
96049>>>>>                    Case (iDbType = EN_dbTypeDB2)
96051>>>>>                        Move "DSN" to sLabel
96052>>>>>                        Case Break
96053>>>>>                    Case (iDbType = EN_dbTypeMSSQL)
96056>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
96058>>>>>                            Move "ODBC Data Source" to sLabel
96059>>>>>                        End
96059>>>>>>
96059>>>>>                        Else Begin
96060>>>>>                            Move "Server" to sLabel
96061>>>>>                        End
96061>>>>>>
96061>>>>>                        Case Break
96062>>>>>                    Case (iDbType = EN_dbTypeMySQL)
96065>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
96067>>>>>                            Move "ODBC Data Source" to sLabel
96068>>>>>                        End
96068>>>>>>
96068>>>>>                        Else Begin
96069>>>>>                            Move "DSN" to sLabel
96070>>>>>                        End
96070>>>>>>
96070>>>>>                        Case Break
96071>>>>>                    Case (iDbType = EN_dbTypeOracle)
96074>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
96076>>>>>                            Move "ODBC Data Source" to sLabel
96077>>>>>                        End
96077>>>>>>
96077>>>>>                        Else Begin
96078>>>>>                            Move "Server" to sLabel
96079>>>>>                        End
96079>>>>>>
96079>>>>>                        Case Break
96080>>>>>                    Case (iDbType = EN_dbTypePostgre)
96083>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
96085>>>>>                            Move "ODBC Data Source" to sLabel
96086>>>>>                        End
96086>>>>>>
96086>>>>>                        Else Begin
96087>>>>>                            Move "Server" to sLabel
96088>>>>>                        End
96088>>>>>>
96088>>>>>                        Case Break
96089>>>>>                    Case Else
96089>>>>>                Case End
96089>>>>>
96089>>>>>                Set Prompt_Object to ho
96090>>>>>                Set Label to sLabel
96091>>>>>            End_Procedure
96092>>>>>
96092>>>>>        End_Object
96093>>>>>
96093>>>>>        Object oSilentLogin_fm is a cSQLCheckBox
96095>>>>>            Set Size to 10 48
96096>>>>>            Set Location to 76 210
96097>>>>>            Set Label to "Silent Login"
96098>>>>>            Set psToolTip to "Silent login to database is to not show error if login was unsuccessive."
96099>>>>>            Set peAnchors to anTopRight
96100>>>>>            Set piItem to 15
96101>>>>>        End_Object
96102>>>>>
96102>>>>>        Object oTrusted_cb is a cSQLCheckbox
96104>>>>>            Set Size to 12 85
96105>>>>>            Set Location to 91 82
96106>>>>>            Set Label to "Use Trusted Connection"
96107>>>>>            Set psToolTip to "(Windows Authentication) When selected, SQL Server uses integrated login (Windows login information) security to establish connections using this data source, regardless of the current login security mode at the server."
96108>>>>>            Set piItem to 8
96109>>>>>
96109>>>>>            Procedure OnChange
96112>>>>>                Boolean bChecked
96112>>>>>                Get Checked_State to bChecked
96113>>>>>                Set Enabled_State of oUserID_fm   to (bChecked = False)
96114>>>>>                Set Enabled_State of oPassword_fm to (bChecked = False)
96115>>>>>                Set Enabled_State of oViewPassword_btn to (bChecked = False)
96116>>>>>            End_Procedure
96117>>>>>
96117>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96120>>>>>                Boolean bChecked
96120>>>>>
96120>>>>>                Get Checked_State to bChecked
96121>>>>>                If (iDbType <> EN_dbTypeMSSQL) Begin
96123>>>>>                    Set Enabled_State to (iDbType = EN_dbTypeMSSQL)
96124>>>>>                    If (bChecked = True) Begin
96126>>>>>                        Set Checked_State to False
96127>>>>>                    End
96127>>>>>>
96127>>>>>                End
96127>>>>>>
96127>>>>>                Else Begin
96128>>>>>                    Set Enabled_State to True
96129>>>>>                End
96129>>>>>>
96129>>>>>
96129>>>>>                Send OnChange
96130>>>>>            End_Procedure
96131>>>>>
96131>>>>>        End_Object
96132>>>>>
96132>>>>>        Object oUserID_fm is a cSQLForm
96134>>>>>            Set Size to 13 114
96135>>>>>            Set Location to 103 82
96136>>>>>            Set Label to "User ID"
96137>>>>>            Set psToolTip to "Enter the user name to use for authentication when you log on to the database."
96138>>>>>            Set piItem to 9
96139>>>>>            Set peAnchors to anTopLeftRight
96140>>>>>        End_Object
96141>>>>>
96141>>>>>        Object oPassword_fm is a cSQLForm
96143>>>>>            Set Size to 13 61
96144>>>>>            Set Location to 103 210
96145>>>>>            Set Label to "Password"
96146>>>>>            Set psToolTip to "Enter the password for your user name. The password will automatically be encrypted & decrypted when writing/reading from the ini file. Of Special Note: If the cConnection class is used with DataFlex 19 or later and such an .ini file is edited with this program you will get a question if you would like the program to 'touch' the password or not. If you answer No, the ini-file will keep working with the DataFlex tools. You should probably never try to change the password with this program for a DFConnid.ini file as the two programs uses different encryption/decryption algorithms."
96147>>>>>            Set piItem to 10
96148>>>>>            Set Password_State to True
96149>>>>>            Set peAnchors to anTopRight
96150>>>>>            Set Label_Col_Offset to 0
96151>>>>>            Set Label_Justification_Mode to JMode_Top
96152>>>>>        End_Object
96153>>>>>
96153>>>>>        Object oShowInfo_tb is a TextBox
96155>>>>>            Set Auto_Size_State to False
96156>>>>>            Set Size to 10 114
96157>>>>>            Set Location to 119 82
96158>>>>>            Set TextColor to clGreen
96159>>>>>            Set Justification_Mode to JMode_Center
96160>>>>>            Set peAnchors to anTopRight
96161>>>>>        End_Object
96162>>>>>
96162>>>>>        Object oViewPassword_btn is a cRDCButton
96164>>>>>            Set Size to 13 15
96165>>>>>            Set Location to 103 273
96166>>>>>            Set psToolTip to "View/hide password"
96167>>>>>            Set psImage to "ViewPassword1.ico"
96168>>>>>            Set piImageMarginLeft to 2
96169>>>>>            Set peAnchors to anTopRight
96170>>>>>
96170>>>>>            Procedure OnClick
96173>>>>>                Handle ho
96173>>>>>                Boolean bState
96173>>>>>
96173>>>>>                Move (oPassword_fm(Self)) to ho
96174>>>>>                Get Password_State of ho 0 to bState
96175>>>>>                Send Deactivate of ho
96176>>>>>                Set Password_State of ho to (not(bState))
96177>>>>>                // Finally we need to re-add the object to the focus tree or it will be invisible.
96177>>>>>                Send Activate of ho (Parent(Self))
96178>>>>>            End_Procedure
96179>>>>>
96179>>>>>        End_Object
96180>>>>>
96180>>>>>        Object oCheckLogin_btn is a cRDCButton
96182>>>>>            Set Size to 13 78
96183>>>>>            Set Location to 119 210
96184>>>>>            Set Label to "Check &Login"
96185>>>>>            Set psImage to "ActionLogin1.ico"
96186>>>>>            Set psToolTip to "You should always use this button when adding a new SQL Connection to ensure that the entered credentials are correct. (Ctrl+L)"
96187>>>>>            Set piImageMarginLeft to 3
96188>>>>>            Set peAnchors to anTopRight
96189>>>>>
96189>>>>>            Procedure OnClick
96192>>>>>                String sConnectionString sDriverID sError
96192>>>>>                Boolean bLoginSuccessful 
96192>>>>>                Integer iDriverID
96192>>>>>                Handle hoErrorObj
96192>>>>>
96192>>>>>                Send Cursor_Wait of Cursor_Control // Note: The Cursor_Wait changes the Err flag!
96193>>>>>                Move Error_Object_Id to hoErrorObj
96194>>>>>                Move Self to Error_Object_Id
96195>>>>>                Move False to Err
96196>>>>>
96196>>>>>                Set Value of oLoginInfo_tb to CS_LoginAttempt
96197>>>>>                Send PumpMsgQueue
96198>>>>>                
96198>>>>>                Get Value of oDriverID_cf to sDriverID
96199>>>>>                Move "" to sError
96200>>>>>                Get LoginString (&sError) to sConnectionString
96201>>>>>                If (sError <> "") Begin
96203>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
96204>>>>>                    Send Info_Box sError
96205>>>>>                    Procedure_Return
96206>>>>>                End
96206>>>>>>
96206>>>>>                
96206>>>>>                Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriverID
96207>>>>>                If (iDriverID = 0) Begin
96209>>>>>                    Set TextColor of oLoginInfo_tb to clRed
96210>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
96211>>>>>                    Send Info_Box ("The driver" * sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
96212>>>>>                    Procedure_Return
96213>>>>>                End
96213>>>>>>
96213>>>>>
96213>>>>>                Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
96216>>>>>
96216>>>>>                Move False to Err
96217>>>>>                Send CreateConnParamsFromConnectionString of ghoSQLConnectionHandler sDriverID sConnectionString
96218>>>>>
96218>>>>>                Move (Err = False) to bLoginSuccessful
96219>>>>>                If bLoginSuccessful Begin
96221>>>>>                    Set TextColor of oLoginInfo_tb to clGreen
96222>>>>>                    Set Value of oLoginInfo_tb to CS_LoginSuccessful 
96223>>>>>                    Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
96224>>>>>                    Set psConnectionString of ghoDbUpdateFunctionLibrary to sConnectionString
96225>>>>>                End
96225>>>>>>
96225>>>>>                Else Begin
96226>>>>>                    Set TextColor of oLoginInfo_tb to clRed
96227>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
96228>>>>>                End
96228>>>>>>
96228>>>>>
96228>>>>>                Move hoErrorObj to Error_Object_Id
96229>>>>>                Send Cursor_Ready of Cursor_Control
96230>>>>>            End_Procedure
96231>>>>>
96231>>>>>            // This method is here simply to intercept any error that may occur while logging in
96231>>>>>            // it does not have to do anything with the error, but it suppresses the normal error display
96231>>>>>            Procedure Error_Report Integer iErrNum Integer iErrLine String sErrMsg
96234>>>>>                If (LastErr = 25000) Begin
96236>>>>>                    If (Trim(sErrMsg) <> "") Begin
96238>>>>>                        Send Info_Box sErrMsg
96239>>>>>                    End
96239>>>>>>
96239>>>>>                End  
96239>>>>>>
96239>>>>>            End_Procedure   
96240>>>>>            
96240>>>>>        End_Object
96241>>>>>
96241>>>>>        Object oIndexTableSpace_fm is a cSQLForm
96243>>>>>            Set Size to 13 114
96244>>>>>            Set Location to 133 82
96245>>>>>            Set Label to "Index Table Space"
96246>>>>>            Set piItem to 14
96247>>>>>            Set psToolTip to "To set the name of the table space where indexes will be stored. Only applicable for IBM DB2, Oracle and PostgreSQL databases."
96248>>>>>            Set Prompt_Button_Mode to PB_PromptOn
96249>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
96250>>>>>            Set peAnchors to anTopLeftRight
96251>>>>>
96251>>>>>            Procedure Prompt
96254>>>>>                String[] sTheData
96255>>>>>                Handle ho
96255>>>>>                tSQLConnection SQLConnection
96255>>>>>                tSQLConnection SQLConnection
96255>>>>>
96255>>>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
96256>>>>>                Get ReadCurrentSQLSettings to SQLConnection
96257>>>>>
96257>>>>>                Get _SqlUtilEnumerateTablespaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
96258>>>>>
96258>>>>>                Get Prompt_Object to ho
96259>>>>>                Set psTheData     of ho to sTheData
96260>>>>>                Set Label of oShowInfo_tb to ""
96261>>>>>
96261>>>>>                Forward Send Prompt
96263>>>>>            End_Procedure
96264>>>>>
96264>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96267>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
96268>>>>>            End_Procedure
96269>>>>>
96269>>>>>        End_Object
96270>>>>>
96270>>>>>        Object oLoginInfo_tb is a TextBox
96272>>>>>            Set Auto_Size_State to False
96273>>>>>            Set Size to 9 78
96274>>>>>            Set Location to 135 210
96275>>>>>            Set TextColor to clGreen
96276>>>>>            Set peAnchors to anTopRight
96277>>>>>            Set Justification_Mode to JMode_Left
96278>>>>>        End_Object
96279>>>>>
96279>>>>>        Object oBaseTableSpace_fm is a cSQLForm
96281>>>>>            Set Size to 13 114
96282>>>>>            Set Location to 148 82
96283>>>>>            Set Label to "Table Space"
96284>>>>>            Set piItem to 12
96285>>>>>            Set psToolTip to "Sets the name of the table space where the data will be stored. Applicable for IBM DB2, Oracle and PostgreSQL databases. Table spaces allow you to assign a physical location to logical objects (tables). They can be used to improve performance or to increase the page size, thus increasing the maximum size of a record that can be stored in the table space. You can specify what table space must be used to store table, index or long data. The index and long data table space will only be set when the table tables pace is also set."
96286>>>>>            Set Prompt_Button_Mode to PB_PromptOn
96287>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
96288>>>>>            Set peAnchors to anTopLeftRight
96289>>>>>
96289>>>>>            Procedure Prompt
96292>>>>>                String[] sTheData
96293>>>>>                Handle ho
96293>>>>>                tSQLConnection SQLConnection
96293>>>>>                tSQLConnection SQLConnection
96293>>>>>
96293>>>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
96294>>>>>                Get ReadCurrentSQLSettings to SQLConnection
96295>>>>>                Get _SqlUtilEnumerateTablespaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
96296>>>>>
96296>>>>>                Get Prompt_Object to ho
96297>>>>>                Set psTheData  of ho to sTheData
96298>>>>>                Set Label of oShowInfo_tb to ""
96299>>>>>
96299>>>>>                Forward Send Prompt
96301>>>>>            End_Procedure
96302>>>>>
96302>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96305>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
96306>>>>>            End_Procedure
96307>>>>>
96307>>>>>        End_Object
96308>>>>>
96308>>>>>        Object oLongTableSpace_fm is a cSQLForm
96310>>>>>            Set Size to 13 114
96311>>>>>            Set Location to 163 82
96312>>>>>            Set Label to "Long Table Space"
96313>>>>>            Set piItem to 13
96314>>>>>            Set psToolTip to "Only applicable for IBM DB2 databases. If you are unsure on what to enter your best bet is to use the same value as for the 'Table Space' above."
96315>>>>>            Set Prompt_Button_Mode to PB_PromptOn
96316>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
96317>>>>>            Set peAnchors to anTopLeftRight
96318>>>>>
96318>>>>>            Procedure Prompt
96321>>>>>                String[] sTheData
96322>>>>>                Handle ho
96322>>>>>                tSQLConnection SQLConnection
96322>>>>>                tSQLConnection SQLConnection
96322>>>>>
96322>>>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
96323>>>>>                Get ReadCurrentSQLSettings to SQLConnection
96324>>>>>
96324>>>>>                Get _SqlUtilEnumerateTablespaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
96325>>>>>
96325>>>>>                Get Prompt_Object to ho
96326>>>>>                Set psTheData     of ho to sTheData
96327>>>>>                Set Label of oShowInfo_tb to ""
96328>>>>>
96328>>>>>                Forward Send Prompt
96330>>>>>            End_Procedure
96331>>>>>
96331>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96334>>>>>                Set Enabled_State to (iDbType = EN_dbTypeDB2)
96335>>>>>            End_Procedure
96336>>>>>
96336>>>>>        End_Object
96337>>>>>
96337>>>>>        Object oSchema_fm is a cSQLForm
96339>>>>>            Set Size to 13 78
96340>>>>>            Set Location to 163 210
96341>>>>>            Set Label to "Schema"
96342>>>>>            Set psToolTip to "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult your database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
96343>>>>>            Set piItem to 11
96344>>>>>            Set Enabled_State to False
96345>>>>>
96345>>>>>            Property String psSchemaToolTip "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult a database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
96347>>>>>            Property String psOwnerTooltip  "The owner name to use within the database where the tables must be placed. If you want to specify an owner of the table that will be converted you can do so, not specifying an owner will result in the default owner being used. The suggested owner name to use is 'dbo'"
96349>>>>>
96349>>>>>            Set peAnchors to anTopRight
96350>>>>>            Set Label_Justification_Mode to JMode_Top
96351>>>>>            Set Label_Col_Offset to 0
96352>>>>>
96352>>>>>            Procedure Prompt
96355>>>>>                String[] sTheData
96356>>>>>                Handle ho
96356>>>>>                tSQLConnection SQLConnection
96356>>>>>                tSQLConnection SQLConnection
96356>>>>>
96356>>>>>                Set Label of oShowInfo_tb to CS_LoadingSchemas
96357>>>>>                Get ReadCurrentSQLSettings to SQLConnection
96358>>>>>
96358>>>>>                Get SqlUtilEnumerateSchemas of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
96359>>>>>
96359>>>>>                Get Prompt_Object to ho
96360>>>>>                Set psTheData     of ho to sTheData
96361>>>>>                Set Label of oShowInfo_tb to ""
96362>>>>>
96362>>>>>                Forward Send Prompt
96364>>>>>            End_Procedure
96365>>>>>
96365>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96368>>>>>                String sValue
96368>>>>>
96368>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeMSSQL or iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
96369>>>>>                If (iDbType = EN_dbTypeMSSQL) Begin
96371>>>>>                    Set Label to CS_DF_File_Owner
96372>>>>>                    Set Prompt_Button_Mode to PB_PromptOff
96373>>>>>                    Set Prompt_Object to 0
96374>>>>>                    Set psToolTip to (psOwnerTooltip(Self))
96375>>>>>                    Get Value to sValue
96376>>>>>                    If (Trim(sValue) = "") Begin
96378>>>>>                        Set Value to "dbo"
96379>>>>>                    End
96379>>>>>>
96379>>>>>                End
96379>>>>>>
96379>>>>>                Else Begin
96380>>>>>                    Set Label to CS_DF_File_Schema
96381>>>>>                    Set Prompt_Button_Mode to PB_PromptOn
96382>>>>>                    Set Prompt_Object to (oSchemasSelection_sl(Self))
96383>>>>>                    Set psToolTip to (psSchemaToolTip(Self))
96384>>>>>                    If (Trim(sValue) = "dbo") Begin
96386>>>>>                        Set Value to ""
96387>>>>>                    End
96387>>>>>>
96387>>>>>                End
96387>>>>>>
96387>>>>>                If (Enabled_State(Self) = False) Begin
96389>>>>>                    Set Value to ""
96390>>>>>                End
96390>>>>>>
96390>>>>>            End_Procedure
96391>>>>>
96391>>>>>        End_Object
96392>>>>>
96392>>>>>        Object oDatabase_fm is a cSQLForm
96394>>>>>            Set Size to 13 114
96395>>>>>            Set Location to 178 82
96396>>>>>            Set Label to "Database"
96397>>>>>            Set peAnchors to anTopLeftRight
96398>>>>>            Set psToolTip to "Name of the SQL database. Note: If you are setting up your first connection for a workspace and your SQL database doesn't exist yet, leave the default 'Master' as it is always available. The 'SqlDatabaseCreate' function will take care of the rest when creating your new SQL database."
96399>>>>>            Set piItem to 6
96400>>>>>            Set Prompt_Button_Mode to PB_PromptOn
96401>>>>>
96401>>>>>            Procedure Prompt
96404>>>>>                String[] sTheData
96405>>>>>                Handle ho
96405>>>>>                tSQLConnection SQLConnection
96405>>>>>                tSQLConnection SQLConnection
96405>>>>>
96405>>>>>                Set Label of oShowInfo_tb to CS_LoadingDatabases
96406>>>>>                Get ReadCurrentSQLSettings to SQLConnection
96407>>>>>
96407>>>>>                Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID to sTheData
96408>>>>>
96408>>>>>                Get Prompt_Object to ho
96409>>>>>                Set psTheData     of ho to sTheData
96410>>>>>                Set Label of oShowInfo_tb to ""
96411>>>>>
96411>>>>>                Forward Send Prompt
96413>>>>>            End_Procedure
96414>>>>>
96414>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96417>>>>>                Boolean bAdd
96417>>>>>                String sValue
96417>>>>>
96417>>>>>                If (sDriverID <> "") Begin
96419>>>>>                    Set Enabled_State to (sDriverID = MSSQLDRV_ID or (sDriverID = ODBC_DRV_ID and iDbType <> EN_DbTypeOracle))
96420>>>>>                    If (Enabled_State(Self) = True) Begin
96422>>>>>                        Move (piCurrentRow(Self) = -1) to bAdd
96423>>>>>                        Get Value to sValue
96424>>>>>                        If (bAdd = True and sValue = "" and iDbType = EN_dbTypeMSSQL) Begin
96426>>>>>                            Set Value to "master"
96427>>>>>                        End
96427>>>>>>
96427>>>>>                        Else Begin
96428>>>>>                            Set Prompt_Button_Mode to PB_PromptOn
96429>>>>>                            Set Prompt_Object to (oDatabaseSelection_sl(Self))
96430>>>>>                            If (Value(Self) = "master") Begin
96432>>>>>                                Set Value to ""
96433>>>>>                            End
96433>>>>>>
96433>>>>>                        End
96433>>>>>>
96433>>>>>                    End
96433>>>>>>
96433>>>>>                    If (Enabled_State(Self) = False) Begin
96435>>>>>                        Set Value to ""
96436>>>>>                    End
96436>>>>>>
96436>>>>>                End
96436>>>>>>
96436>>>>>            End_Procedure
96437>>>>>
96437>>>>>        End_Object
96438>>>>>
96438>>>>>        Object oCreateDatabase_btn is a cRDCButton
96440>>>>>            Set Size to 13 78
96441>>>>>            Set Location to 178 210
96442>>>>>            Set Label to "Create Database..."
96443>>>>>            Set psImage to "ActionCreateDatabase1.ico"
96444>>>>>            Set pbAutoEnable to True
96445>>>>>            Set peAnchors to anTopRight
96446>>>>>        
96446>>>>>            Procedure OnClick                                                              
96449>>>>>                String sConnectionString sError sDriverID sLoginText sDatabaseName
96449>>>>>                
96449>>>>>                Get LoginString (&sError) to sConnectionString
96450>>>>>                If (sError <> "") Begin
96452>>>>>                    Send Info_Box sError
96453>>>>>                    Procedure_Return
96454>>>>>                End                         
96454>>>>>>
96454>>>>>                
96454>>>>>                Get Value of oDriverID_cf to sDriverID
96455>>>>>                Get Create_DataBase_Dialog of (Client_Id(phoMainPanel(ghoApplication))) sDriverID to sDatabaseName
96456>>>>>                If (sDatabaseName <> "") Begin
96458>>>>>                    Set Value of oDatabase_fm to sDatabaseName
96459>>>>>                End
96459>>>>>>
96459>>>>>            End_Procedure                
96460>>>>>            
96460>>>>>            Function IsEnabled Returns Boolean
96463>>>>>                Integer iDbType    
96463>>>>>                Boolean bReadOnly
96463>>>>>                Get SelectedDbType of oDbType_cf to iDbType
96464>>>>>                Get pbReadOnly to bReadOnly
96465>>>>>                Function_Return (bReadOnly = False and (iDbType = EN_DbTypeMSSQL or iDbType = EN_DbTypeDB2 or iDbType = EN_DbTypeMySQL or iDbType = EN_DbTypePostgre))
96466>>>>>            End_Function
96467>>>>>        
96467>>>>>        End_Object
96468>>>>>
96468>>>>>        Procedure DbTypeUpdate Integer iDbType String sDriverID
96471>>>>>            String sDbType
96471>>>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sDbType
96472>>>>>            Set Label to (sDbType * "Connection Details")
96473>>>>>        End_Procedure
96474>>>>>
96474>>>>>    End_Object
96475>>>>>
96475>>>>>    Object oOK_Btn is a cRDCButton
96477>>>>>        Set Label    to C_$OK
96478>>>>>        Set Location to 287 208 //281 208
96479>>>>>        Set peAnchors to anBottomRight
96480>>>>>
96480>>>>>        Procedure OnClick
96483>>>>>            String sLoginText
96483>>>>>            String[] sConnectionData
96484>>>>>            tSQLConnection SQLIniFileConnection
96484>>>>>            tSQLConnection SQLIniFileConnection
96484>>>>>            Boolean bNew bOK bShouldSave
96484>>>>>            Integer iRetval
96484>>>>>
96484>>>>>            Delegate Get Should_Save to bShouldSave
96486>>>>>            If (bShouldSave = False) Begin
96488>>>>>                Set pbChanged to False
96489>>>>>                Send Close_Panel
96490>>>>>                Procedure_Return
96491>>>>>            End
96491>>>>>>
96491>>>>>
96491>>>>>            Broadcast Recursive Send WriteConnectionData of (Parent(Self)) (&sConnectionData)
96493>>>>>
96493>>>>>            Get pbNew to bNew
96494>>>>>            Get MoveStringArrayToSQLConnection sConnectionData to SQLIniFileConnection
96495>>>>>            Case Begin
96495>>>>>                Case (SQLIniFileConnection.sDriverID = DB2_DRV_ID or SQLIniFileConnection.sDriverID = ODBC_DRV_ID)
96497>>>>>                    If (SQLIniFileConnection.sDriverID = DB2_DRV_ID) Begin
96499>>>>>                        Move "" to SQLIniFileConnection.sDatabase
96500>>>>>                    End
96500>>>>>>
96500>>>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
96502>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
96504>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "") to bOK
96505>>>>>                        End
96505>>>>>>
96505>>>>>                        Else Begin
96506>>>>>                            Move (SQLIniFileConnection.sServer <> "") to bOK
96507>>>>>                        End
96507>>>>>>
96507>>>>>                    End
96507>>>>>>
96507>>>>>                    Else Begin
96508>>>>>                        // It should probably be allowed to use an UID but no password...
96508>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
96510>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
96511>>>>>                        End
96511>>>>>>
96511>>>>>                        Else Begin
96512>>>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
96513>>>>>                        End
96513>>>>>>
96513>>>>>                    End
96513>>>>>>
96513>>>>>                    Case Break
96514>>>>>                Case (SQLIniFileConnection.sDriverID = MSSQLDRV_ID)
96517>>>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
96519>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
96521>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
96522>>>>>                        End
96522>>>>>>
96522>>>>>                        Else Begin
96523>>>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
96524>>>>>                        End
96524>>>>>>
96524>>>>>                    End
96524>>>>>>
96524>>>>>                    Else Begin
96525>>>>>                        // It should probably be allowed to use an UID but no password...
96525>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
96527>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
96528>>>>>                        End
96528>>>>>>
96528>>>>>                        Else Begin
96529>>>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
96530>>>>>                        End
96530>>>>>>
96530>>>>>                    End
96530>>>>>>
96530>>>>>                    Case Break
96531>>>>>            Case End
96531>>>>>
96531>>>>>            If (bOK = False) Begin
96533>>>>>                Send Info_Box "Please fill in all connection data."
96534>>>>>                Procedure_Return
96535>>>>>            End
96535>>>>>>
96535>>>>>
96535>>>>>            Move MBR_Yes to iRetval
96536>>>>>            Get Label of oLoginInfo_tb to sLoginText
96537>>>>>            If (sLoginText = CS_LoginFailed) Begin
96539>>>>>                Get YesNo_Box "The login failed. Are you sure you want to use these connection settings?" to iRetval
96540>>>>>            End
96540>>>>>>
96540>>>>>            Else If (sLoginText = "") Begin
96543>>>>>                Get YesNo_Box "The login has not been tested. Are you sure you want to use these connection settings?" to iRetval
96544>>>>>            End
96544>>>>>>
96544>>>>>            If (iRetval <> MBR_Yes) Begin
96546>>>>>                Procedure_Return
96547>>>>>            End
96547>>>>>>
96547>>>>>
96547>>>>>            Set pSQLConnectionData to SQLIniFileConnection
96548>>>>>            Set pbChanged to True
96549>>>>>            Send Close_Panel
96550>>>>>        End_Procedure
96551>>>>>
96551>>>>>    End_Object
96552>>>>>
96552>>>>>    Object oCancel_Btn is a cRDCButton
96554>>>>>        Set Label    to C_$Cancel
96555>>>>>        Set Location to 287 264 //281 264
96556>>>>>        Set peAnchors to anBottomRight
96557>>>>>
96557>>>>>        Procedure OnClick
96560>>>>>            Set pbChanged to False
96561>>>>>            Send Close_Panel
96562>>>>>        End_Procedure
96563>>>>>
96563>>>>>    End_Object
96564>>>>>
96564>>>>>    Object oHelp_Btn is a cRDCButton
96566>>>>>        Set Label to C_$Help
96567>>>>>        Set Location to 287 11 //281 11
96568>>>>>        Set peAnchors to anBottomLeft
96569>>>>>        Set psImage to "ActionHelp1.ico"
96570>>>>>
96570>>>>>        Procedure OnClick
96573>>>>>            Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
96574>>>>>        End_Procedure
96575>>>>>    End_Object
96576>>>>>
96576>>>>>    Object oConnectionType_grp is a cRDCHeaderGroup
96578>>>>>        Set Size to 60 303
96579>>>>>        Set Location to 8 11 //2 11
96580>>>>>        Set psImage to "SQLSettings1.ico"
96581>>>>>        Set psLabel to "Database Type Settings"
96582>>>>>
96582>>>>>        Object oDbType_cf is a cSQLComboForm
96584>>>>>            Set Size to 13 115
96585>>>>>            Set Location to 22 82
96586>>>>>            Set Label to "Database Type"
96587>>>>>            Set Entry_State to False
96588>>>>>            Set Combo_Sort_State to False
96589>>>>>            Set psToolTip to "Select a database type, then select a driver to use for the database"
96590>>>>>            Set piItem to 3
96591>>>>>            
96591>>>>>            Procedure Combo_Fill_List
96594>>>>>                Send Combo_Add_Item CS_dbTypeMSSQL
96595>>>>>                Send Combo_Add_Item CS_dbTypeMySQL
96596>>>>>                Send Combo_Add_Item CS_dbTypeOracle
96597>>>>>                Send Combo_Add_Item CS_dbTypeDB2
96598>>>>>                Send Combo_Add_Item CS_dbTypePostgre
96599>>>>>            End_Procedure
96600>>>>>
96600>>>>>            Procedure OnChange
96603>>>>>                Integer iDbType
96603>>>>>                String sDriverID
96603>>>>>    
96603>>>>>                Get SelectedDbType to iDbType
96604>>>>>                Send Refill_Comboform of oDriverID_cf iDbType
96605>>>>>                Get Value of oDriverID_cf to sDriverID
96606>>>>>                If (sDriverID = "") Begin
96608>>>>>                    Move MSSQLDRV_ID to sDriverID
96609>>>>>                End
96609>>>>>>
96609>>>>>                Send DbTypeUpdate of oSettings_grp iDbType sDriverID
96610>>>>>            End_Procedure
96611>>>>>    
96611>>>>>            Function SelectedDbType Returns Integer
96614>>>>>                Integer iRetval
96614>>>>>                String sDbType
96614>>>>>    
96614>>>>>                Get Value to sDbType
96615>>>>>                Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sDbType to iRetval
96616>>>>>    
96616>>>>>                Function_Return iRetval
96617>>>>>            End_Function
96618>>>>>
96618>>>>>        End_Object
96619>>>>>
96619>>>>>// This used to work, but it seems that the Ssms.exe is no longer part of Windows "global pathing (in DOS)".
96619>>>>>//        Object oStartSQLManager_btn is a cRDCButton
96619>>>>>//            Set Size to 13 78
96619>>>>>//            Set Location to 22 210
96619>>>>>//            Set Label to "SQL Manager"
96619>>>>>//            Set pbAutoEnable to True  
96619>>>>>//            Set psImage to "SSMS1.ico" 
96619>>>>>//            Set psToolTip to "Start Microsoft SQL Server Management Studio"
96619>>>>>//            Set peAnchors to anTopRight
96619>>>>>//        
96619>>>>>//            Procedure OnClick
96619>>>>>//                Runprogram Shell Background "Ssms.exe"    
96619>>>>>//            End_Procedure  
96619>>>>>//            
96619>>>>>//            Function IsEnabled Returns Boolean
96619>>>>>//                String sDbType
96619>>>>>//                Get Value of oDbType_cf to sDbType
96619>>>>>//                Function_Return (sDbType = CS_dbTypeMSSQL)
96619>>>>>//            End_Function
96619>>>>>//        
96619>>>>>//        End_Object
96619>>>>>
96619>>>>>        Object oDriverID_cf is a cSQLComboForm
96621>>>>>            Set Size to 13 115
96622>>>>>            Set Location to 37 82
96623>>>>>            Set Label to "Driver ID"
96624>>>>>            Set Entry_State to False
96625>>>>>            Set Combo_Sort_State to False
96626>>>>>            Set psToolTip to "Depending on the database type selected the comboform list will vary."
96627>>>>>            Set piItem to 4
96628>>>>>
96628>>>>>            Procedure Refill_Comboform Integer iDbType
96631>>>>>                String sValue
96631>>>>>
96631>>>>>                Send Combo_Delete_Data
96632>>>>>                Send Combo_Add_Item MSSQLDRV_ID
96633>>>>>                Send Combo_Add_Item DB2_DRV_ID
96634>>>>>                Send Combo_Add_Item ODBC_DRV_ID
96635>>>>>                Send Combo_Add_Item DATAFLEX_ID
96636>>>>>
96636>>>>>                Case Begin
96636>>>>>                    Case (iDbType = EN_dbTypeMSSQL)
96638>>>>>                        Move MSSQLDRV_ID to sValue
96639>>>>>                        Case Break
96640>>>>>                    Case (iDbType = EN_dbTypeMySQL)
96643>>>>>                        Move ODBC_DRV_ID to sValue
96644>>>>>                        Case Break
96645>>>>>                    Case (iDbType = EN_dbTypeOracle)
96648>>>>>                        Move ODBC_DRV_ID to sValue
96649>>>>>                        Case Break
96650>>>>>                    Case (iDbType = EN_dbTypeDB2)
96653>>>>>                        Move DB2_DRV_ID to sValue
96654>>>>>                        Case Break
96655>>>>>                    Case (iDbType = EN_dbTypePostgre)
96658>>>>>                        Move ODBC_DRV_ID to sValue
96659>>>>>                        Case Break
96660>>>>>                    Case Else
96660>>>>>                        Move DATAFLEX_ID to sValue
96661>>>>>                Case End
96661>>>>>                Set Value to sValue
96662>>>>>            End_Procedure
96663>>>>>
96663>>>>>            Procedure OnChange
96666>>>>>                String sDriverID
96666>>>>>                Integer iDbType
96666>>>>>
96666>>>>>                Get Value to sDriverID
96667>>>>>                If (sDriverID = "") Begin
96669>>>>>//                    Move MSSQLDRV_ID to sDriverID 
96669>>>>>                    Procedure_Return
96670>>>>>                End
96670>>>>>>
96670>>>>>                Get SelectedDbType of oDbType_cf to iDbType
96671>>>>>                Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
96673>>>>>            End_Procedure
96674>>>>>
96674>>>>>        End_Object
96675>>>>>
96675>>>>>        Object oShowDriverSettings_btn is a cRDCButton
96677>>>>>            Set Size to 13 78
96678>>>>>            Set Location to 37 210
96679>>>>>            Set Label to "Driver Settings"
96680>>>>>            Set Status_Help to "Shows settings for the selected driver."
96681>>>>>            Set psImage to "DriverSettings1.ico"
96682>>>>>            Set peAnchors to anTopRight
96683>>>>>
96683>>>>>            Procedure OnClick
96686>>>>>                String sDriver sPath 
96686>>>>>                
96686>>>>>                Get Value of oDriverID_cf to sDriver
96687>>>>>                Send PopupDriverSettings sDriver 
96688>>>>>            End_Procedure
96689>>>>>    
96689>>>>>        End_Object
96690>>>>>
96690>>>>>    End_Object
96691>>>>>
96691>>>>>    Function ReadCurrentSQLSettings Returns tSQLConnection
96694>>>>>        tSQLConnection SQLConnection
96694>>>>>        tSQLConnection SQLConnection
96694>>>>>
96694>>>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
96695>>>>>        Get SelectedDbType of oDbType_cf to SQLConnection.iDbType
96696>>>>>
96696>>>>>        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
96697>>>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
96698>>>>>        Get Value of oServer_fm          to SQLConnection.sServer
96699>>>>>        Get Value of oUserID_fm          to SQLConnection.sUserID
96700>>>>>        Get Value of oPassword_fm        to SQLConnection.sPassword     
96701>>>>>        Move False to Err
96702>>>>>        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) ;            SQLConnection.sDriverID SQLConnection.sServer "" SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
96703>>>>>        Set pSQLConnection of ghoSQLConnectionHandler to SQLConnection
96704>>>>>        Move Err to SQLConnection.bError
96705>>>>>        
96705>>>>>        Function_Return SQLConnection
96706>>>>>    End_Function
96707>>>>>
96707>>>>>    Function LoginString String ByRef sError Returns String
96710>>>>>        String sDriverID sServer sDatabase
96710>>>>>        tSQLConnection SQLConnection
96710>>>>>        tSQLConnection SQLConnection
96710>>>>>        
96710>>>>>        Get Value of oDriverID_cf to sDriverID
96711>>>>>        If (sDriverID = "") Begin
96713>>>>>            Move "Please select a driver first, then try again." to sError
96714>>>>>            Function_Return ""
96715>>>>>        End
96715>>>>>>
96715>>>>>
96715>>>>>        Get Value of oServer_fm   to sServer
96716>>>>>        If (sServer = "") Begin
96718>>>>>            Move "Please select a server first, then try again." to sError
96719>>>>>            Function_Return ""
96720>>>>>        End
96720>>>>>>
96720>>>>>
96720>>>>>        Get Value of oDatabase_fm to sDatabase
96721>>>>>        If (sDatabase = "" and sDriverID = MSSQLDRV_ID) Begin
96723>>>>>            Move "master" to sDatabase
96724>>>>>        End
96724>>>>>>
96724>>>>>
96724>>>>>        Get ReadCurrentSQLSettings to SQLConnection
96725>>>>>        If (SQLConnection.bError = True) Begin
96727>>>>>            Move "Login Error" to sError
96728>>>>>        End
96728>>>>>>
96728>>>>>
96728>>>>>        Function_Return SQLConnection.sConnectionString
96729>>>>>    End_Function
96730>>>>>
96730>>>>>    // Returns True if anything has changed.
96730>>>>>    Function Should_Save Returns Boolean
96733>>>>>        String[] sConnectionData sConnectionData2
96735>>>>>        tSQLConnection SQLConnectionData
96735>>>>>        tSQLConnection SQLConnectionData
96735>>>>>        Boolean bState
96735>>>>>
96735>>>>>        Broadcast Recursive Send WriteConnectionData (&sConnectionData)
96737>>>>>        Get pSQLConnectionData to SQLConnectionData
96738>>>>>        Get MoveSQLConnectionToStringArray SQLConnectionData to sConnectionData2
96739>>>>>        // We don't have a form here for the sConnectionString, so we "blank it out"
96739>>>>>        // to be able to compare properly.
96739>>>>>        Move "" to sConnectionData2[7]
96740>>>>>
96740>>>>>            Move (IsSameArray(sConnectionData, sConnectionData2)) to bState
96741>>>>>        Function_Return (bState = False)
96742>>>>>    End_Function
96743>>>>>
96743>>>>>    Function IsConnectionIDDuplicate tSQLConnection SQLConnection Returns Boolean
96746>>>>>        Integer iCount iSize iItems iCurrentRow
96746>>>>>        String sValue sConnectionID
96746>>>>>        Boolean bExists
96746>>>>>        tDataSourceRow[] TheData
96746>>>>>        tDataSourceRow[] TheData
96747>>>>>        tDataSourceRow TheRow
96747>>>>>        tDataSourceRow TheRow
96747>>>>>
96747>>>>>        Move 0 to iItems
96748>>>>>        Get piCurrentRow to iCurrentRow
96749>>>>>        Move SQLConnection.sConnectionID to sConnectionID
96750>>>>>        Get MoveSQLConnectionToGridRow SQLConnection to TheRow
96751>>>>>        Get pTheData to TheData
96752>>>>>        Move (SizeOfArray(TheData)) to iSize
96753>>>>>        If (iCurrentRow <> -1) Begin
96755>>>>>            // This is the sConnectionID:
96755>>>>>            Move TheRow.sValue[2] to TheData[iCurrentRow].sValue[2]
96756>>>>>        End
96756>>>>>>
96756>>>>>        Else Begin
96757>>>>>            Move TheRow to TheData[iSize]
96758>>>>>        End
96758>>>>>>
96758>>>>>        Move (SizeOfArray(TheData)) to iSize
96759>>>>>        Decrement iSize
96760>>>>>        For iCount from 0 to iSize
96766>>>>>>
96766>>>>>            Move TheData[iCount].sValue[2] to sValue
96767>>>>>            Move (sValue = sConnectionID) to bExists
96768>>>>>            If (bExists) Begin
96770>>>>>                Increment iItems
96771>>>>>            End
96771>>>>>>
96771>>>>>        Loop
96772>>>>>>
96772>>>>>
96772>>>>>        Function_Return (iItems > 1)
96773>>>>>    End_Function
96774>>>>>
96774>>>>>    // Transfers data between a tSQLConnection struct and a grid data row.
96774>>>>>    Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
96777>>>>>        tDataSourceRow TheRow
96777>>>>>        tDataSourceRow TheRow
96777>>>>>        Integer iDbType
96777>>>>>        String sValue
96777>>>>>
96777>>>>>        Move 0                                  to TheRow.sValue[0]
96778>>>>>        Move SQLConnection.bEnabled             to TheRow.sValue[1]
96779>>>>>        Move SQLConnection.sConnectionID        to TheRow.sValue[2]
96780>>>>>        Move SQLConnection.sDriverID            to TheRow.sValue[3]
96781>>>>>
96781>>>>>        // We only show three asterisks ("***") instead of the password in the grid.
96781>>>>>        Move (Replace(SQLConnection.sPassword, SQLConnection.sConnectionString, "***")) to sValue
96782>>>>>        Move sValue                             to TheRow.sValue[4]
96783>>>>>
96783>>>>>        Move SQLConnection.iDbType to iDbType
96784>>>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
96785>>>>>        Move sValue                             to TheRow.sValue[5]
96786>>>>>        Move SQLConnection.sServer              to TheRow.sValue[6]
96787>>>>>        Move SQLConnection.sDatabase            to TheRow.sValue[7]
96788>>>>>
96788>>>>>        // Hidden columns (to make Should_Save function work)
96788>>>>>        Move SQLConnection.sConnectionString    to TheRow.sValue[8] // "Untouched" connection string.
96789>>>>>        Move SQLConnection.bTrusted             to TheRow.sValue[9]
96790>>>>>        Move SQLConnection.sUserID              to TheRow.sValue[10]
96791>>>>>        Move SQLConnection.sPassword            to TheRow.sValue[11]
96792>>>>>        Move SQLConnection.sSchema              to TheRow.sValue[12]
96793>>>>>        Move SQLConnection.sBaseTableSpace      to TheRow.sValue[13]
96794>>>>>        Move SQLConnection.sLongTableSpace      to TheRow.sValue[14]
96795>>>>>        Move SQLConnection.sIndexTableSpace     to TheRow.sValue[15]
96796>>>>>        Move SQLConnection.bSilentLogin         to TheRow.sValue[16]
96797>>>>>//        Move SQLConnection.bDisabled            to TheRow.sValue[17]
96797>>>>>//        Move SQLConnection.iDriverIndex         to TheRow.sValue[18]
96797>>>>>
96797>>>>>        Function_Return TheRow
96798>>>>>    End_Function
96799>>>>>
96799>>>>>    Function MoveSQLConnectionToStringArray tSQLConnection SQLConnection Returns String[]
96802>>>>>        String[] sConnectionData
96803>>>>>        Integer iRetval
96803>>>>>
96803>>>>>        Move SQLConnection.bEnabled          to sConnectionData[1]
96804>>>>>        Move SQLConnection.sConnectionID     to sConnectionData[2]
96805>>>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary SQLConnection.iDbType to sConnectionData[3]
96806>>>>>        Move SQLConnection.sDriverID         to sConnectionData[4]
96807>>>>>        Move SQLConnection.sServer           to sConnectionData[5]
96808>>>>>        Move SQLConnection.sDatabase         to sConnectionData[6]
96809>>>>>        Move SQLConnection.sConnectionString to sConnectionData[7]
96810>>>>>        Move SQLConnection.bTrusted          to sConnectionData[8]
96811>>>>>        Move SQLConnection.sUserID           to sConnectionData[9]
96812>>>>>
96812>>>>>        If (SQLConnection.sPassword <> "") Begin
96814>>>>>            Move MBR_Yes to iRetval
96815>>>>>            If (pbDFConnId(Self) = True) Begin
96817>>>>>                Get YesNo_Box "You are working with a DAW 'DFConnId.ini' file. Although this program can both read/write to such a file, the password encryption/decryption algorithms are (obviously) different. Thus the password will not be touched. Continue?" to iRetval
96818>>>>>                If (iRetval = MBR_Yes) Begin
96820>>>>>                    Set psUncryptedPw to SQLConnection.sPassword
96821>>>>>                    Move "" to SQLConnection.sPassword 
96822>>>>>//                    Set Enabled_State of oCheckLogin_btn to False
96822>>>>>                End
96822>>>>>>
96822>>>>>                Else Begin
96823>>>>>                    Send Stop_UI
96824>>>>>                End
96824>>>>>>
96824>>>>>            End
96824>>>>>>
96824>>>>>            Else Begin
96825>>>>>                Move SQLConnection.sPassword to sConnectionData[10]
96826>>>>>            End
96826>>>>>>
96826>>>>>        End
96826>>>>>>
96826>>>>>
96826>>>>>        Move SQLConnection.sSchema           to sConnectionData[11]
96827>>>>>        Move SQLConnection.sBaseTableSpace   to sConnectionData[12]
96828>>>>>        Move SQLConnection.sLongTableSpace   to sConnectionData[13]
96829>>>>>        Move SQLConnection.sIndexTableSpace  to sConnectionData[14]
96830>>>>>        Move SQLConnection.bSilentLogin      to sConnectionData[15]
96831>>>>>
96831>>>>>        Function_Return sConnectionData
96832>>>>>    End_Function
96833>>>>>
96833>>>>>    Function MoveStringArrayToSQLConnection String[] sConnectionData Returns tSQLConnection
96836>>>>>        tSQLConnection SQLConnection
96836>>>>>        tSQLConnection SQLConnection
96836>>>>>
96836>>>>>        Move sConnectionData[1]  to SQLConnection.bEnabled
96837>>>>>        Move sConnectionData[2]  to SQLConnection.sConnectionID
96838>>>>>        Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sConnectionData[3] to SQLConnection.iDbType
96839>>>>>        Move sConnectionData[4]  to SQLConnection.sDriverID
96840>>>>>        Move sConnectionData[5]  to SQLConnection.sServer
96841>>>>>        Move sConnectionData[6]  to SQLConnection.sDatabase
96842>>>>>
96842>>>>>        Move sConnectionData[8]  to SQLConnection.bTrusted
96843>>>>>        Move sConnectionData[9]  to SQLConnection.sUserID
96844>>>>>
96844>>>>>        If (sConnectionData[10] <> "" and pbDFConnId(Self) = False) Begin
96846>>>>>            Move sConnectionData[10] to SQLConnection.sPassword
96847>>>>>        End
96847>>>>>>
96847>>>>>        // In case of we're dealing with a DfConnID.ini file (DF 19+) we don't want to change the password
96847>>>>>        // as DAW's 'Managed Connections' program has a different password encryption/decryption algorithm.
96847>>>>>        If (pbDFConnId(Self) = True) Begin
96849>>>>>            Get psUncryptedPw to SQLConnection.sPassword
96850>>>>>        End
96850>>>>>>
96850>>>>>
96850>>>>>        Move sConnectionData[11] to SQLConnection.sSchema
96851>>>>>        Move sConnectionData[12] to SQLConnection.sBaseTableSpace
96852>>>>>        Move sConnectionData[13] to SQLConnection.sLongTableSpace
96853>>>>>        Move sConnectionData[14] to SQLConnection.sIndexTableSpace
96854>>>>>        Move sConnectionData[15] to SQLConnection.bSilentLogin
96855>>>>>
96855>>>>>        // Connection string:
96855>>>>>        Get ConstructConnectionString of ghoSQLConnectionHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase ;                                                                 SQLConnection.bTrusted  SQLConnection.sUserID SQLConnection.sPassword ;                                      to SQLConnection.sConnectionString
96856>>>>>
96856>>>>>        Function_Return SQLConnection
96857>>>>>    End_Function
96858>>>>>
96858>>>>>    Procedure Popup
96861>>>>>        tSQLConnection SQLIniFileConnection
96861>>>>>        tSQLConnection SQLIniFileConnection
96861>>>>>        String[] sConnectionData
96862>>>>>        String sDriverID
96862>>>>>        Integer iDbType
96862>>>>>        Boolean bAdd
96862>>>>>
96862>>>>>        Move (piCurrentRow(Self) = -1) to bAdd
96863>>>>>        Get pSQLConnectionData to SQLIniFileConnection             
96864>>>>>        // we need these as the oConnectionType_grp has been moved to be the last object(s) in the dialog.
96864>>>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
96865>>>>>        Set Value of oDriverID_cf to ""
96866>>>>>        If (SQLIniFileConnection.bEnabled = False and bAdd = True) Begin
96868>>>>>            Move True to SQLIniFileConnection.bEnabled
96869>>>>>        End
96869>>>>>>
96869>>>>>        Get MoveSQLConnectionToStringArray SQLIniFileConnection to sConnectionData
96870>>>>>
96870>>>>>        Set Value of oDriverID_cf to SQLIniFileConnection.sDriverID
96871>>>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
96872>>>>>        Broadcast Recursive Send ReadConnectionData sConnectionData
96874>>>>>
96874>>>>>        // We need this message to "auto-default" certain fields.
96874>>>>>        If (bAdd = True) Begin
96876>>>>>            Get SelectedDbType of oDbType_cf to iDbType
96877>>>>>            Get Value of oDriverID_cf to sDriverID
96878>>>>>            If (sDriverID = "") Begin
96880>>>>>                Move MSSQLDRV_ID to sDriverID
96881>>>>>            End
96881>>>>>>
96881>>>>>            Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
96883>>>>>        End
96883>>>>>>
96883>>>>>
96883>>>>>        Set Password_State of oPassword_fm to True
96884>>>>>        Set Value of oLoginInfo_tb to ""
96885>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
96886>>>>>
96886>>>>>        Forward Send Popup
96888>>>>>    End_Procedure
96889>>>>>
96889>>>>>    Procedure Page Integer iPageObject
96892>>>>>        Boolean bNew bReadOnly
96892>>>>>        String sText
96892>>>>>        Handle hWnd
96892>>>>>
96892>>>>>        Send Cursor_Ready of Cursor_Control
96893>>>>>        Forward Send Page iPageObject
96895>>>>>
96895>>>>>        Set Icon to "SQLConnections1.ico"
96896>>>>>
96896>>>>>        Get pbNew to bNew
96897>>>>>        If (bNew = True) Begin
96899>>>>>            Move ("The" * CS_SQLIniFileName * "file doesn't exist yet for this workspace and needs to be created. Here's what you need to do:\n\n") to sText
96900>>>>>            Move (sText * "1. Enter a Connection ID (the same that is being used by your workspace .int files) and other data that is used to login to the database.\n") to sText
96901>>>>>            Move (sText * "2. Press the 'Test Login' button to ensure entered details are correct.\n") to sText
96902>>>>>            Move (sText * "3. Press the 'OK' button and then save your changes.\n") to sText
96903>>>>>            Send Info_Box sText
96904>>>>>        End
96904>>>>>>
96904>>>>>
96904>>>>>        If (ghoSkinFramework <> 0 and hWnd <> 0) Begin
96906>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
96907>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
96908>>>>>        End
96908>>>>>>
96908>>>>>
96908>>>>>        Get pbReadOnly to bReadOnly
96909>>>>>        If (bReadOnly = True) Begin
96911>>>>>            Broadcast Recursive Set Enabled_State    to (not(bReadOnly))
96913>>>>>            Set Enabled_State of oConnectionType_grp to True
96914>>>>>            Set Enabled_State of oSettings_grp       to True
96915>>>>>            Set Enabled_State of oPassword_fm        to True
96916>>>>>            Set Enabled_State of oViewPassword_btn   to True
96917>>>>>            Set Enabled_State of oCheckLogin_btn     to True
96918>>>>>            Set Enabled_State of oCancel_Btn         to True
96919>>>>>            Set Enabled_State of oHelp_Btn           to True
96920>>>>>            Set Enabled_State of oShowDriverSettings_btn to True
96921>>>>>            Set Enabled_State of oCreateDatabase_btn to False
96922>>>>>            Send Activate of oCancel_Btn
96923>>>>>        End
96923>>>>>>
96923>>>>>    End_Procedure
96924>>>>>
96924>>>>>    Function IniFileName Returns String
96927>>>>>        String sRetval
96927>>>>>        Function_Return sRetval
96928>>>>>    End_Function
96929>>>>>
96929>>>>>    // Put a status bar at the bottom of the panel, which makes
96929>>>>>    // status_help work and puts a gripper in the lower right corner.
96929>>>>>    Procedure End_Construct_Object
96932>>>>>        Integer iStyle iSize iOffset
96932>>>>>
96932>>>>>        Forward Send End_Construct_Object
96934>>>>>
96934>>>>>        Get Border_Style to iStyle
96935>>>>>        Move 8 to iOffset
96936>>>>>        If (iStyle = Border_Thick) Begin
96938>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
96940>>>>>                Object oStatusBar is a cCJStatusBar
96942>>>>>                    Set phoDialogCommandbar to Self
96943>>>>>                    Object oStatusIdle is a cCJStatusBarPane
96945>>>>>                        Set piId to sbpIDIdlePane
96946>>>>>                        Set pbStyleStretch to True
96947>>>>>                    End_Object
96948>>>>>                End_Object
96949>>>>>            End_Object
96950>>>>>
96950>>>>>            Get Size to iSize
96951>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
96952>>>>>        End
96952>>>>>>
96952>>>>>    End_Procedure
96953>>>>>
96953>>>>>    Procedure ShowProgramHelp
96956>>>>>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
96957>>>>>    End_Procedure
96958>>>>>
96958>>>>>    On_Key Key_F1         Send ShowProgramHelp
96959>>>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oCheckLogin_btn
96960>>>>>    On_Key kCancel        Send KeyAction of oCancel_Btn
96961>>>>>End_Object
96962>>>>>
96962>>>>>// General purpose access message                                                                                                           // If ini-file= "DFConnId.ini" (DAW file)
96962>>>>>Procedure Activate_SQLMaintainConnections_dg Boolean bNew Integer iCurrentRow tSQLConnection ByRef SQLConnectionData Boolean ByRef bChanged Boolean bDFConnId tDataSourceRow[] TheData
96965>>>>>    Handle ho
96965>>>>>    String sPath sSQLConnectionsFileName
96965>>>>>    Boolean bExists
96965>>>>>    
96965>>>>>    Send Cursor_Wait of Cursor_Control
96966>>>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
96967>>>>>    Set pbReadOnly              of ho to False
96968>>>>>    Set pbNew                   of ho to bNew
96969>>>>>    Set piCurrentRow            of ho to iCurrentRow
96970>>>>>    Set pbDFConnId              of ho to bDFConnId
96971>>>>>    Set pSQLConnectionData      of ho to SQLConnectionData
96972>>>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
96973>>>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
96974>>>>>    File_Exist (sPath + sSQLConnectionsFileName) bExists
96975>>>>>    If (bExists = True) Begin
96977>>>>>     Set Label  of ho to ("Connection Properties" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
96978>>>>>    End
96978>>>>>>
96978>>>>>    
96978>>>>>    Set pTheData                of ho to TheData
96979>>>>>
96979>>>>>    Send Popup                  of ho
96980>>>>>
96980>>>>>    Get pSQLConnectionData      of ho to SQLConnectionData
96981>>>>>    Get pbChanged               of ho to bChanged
96982>>>>>End_Procedure
96983>>>>>
96983>>>>>// Read-only access message
96983>>>>>Procedure Activate_ReadOnlySQLMaintainConnections_dg tSQLConnection SQLConnectionData
96986>>>>>    Handle ho
96986>>>>>    String sPath sSQLConnectionsFileName
96986>>>>>
96986>>>>>    Send Cursor_Wait of Cursor_Control
96987>>>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
96988>>>>>    Set pbReadOnly              of ho to True
96989>>>>>
96989>>>>>    Set pSQLConnectionData      of ho to SQLConnectionData
96990>>>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
96991>>>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
96992>>>>>    Set Label  of ho to ("Connection Properties (Read-Only)" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
96993>>>>>
96993>>>>>    Send Popup of ho
96994>>>>>End_Procedure
96995>>>>>
96995>>>
96995>>>Activate_View Activate_oSQLMaintainConnection for oSQLMaintainConnection
97005>>>>
97005>>>Object oSQLMaintainConnection is a dbView
97007>>>    Set Size to 135 538
97008>>>    Set Location to 2 2
97009>>>    Set Maximize_Icon to True
97010>>>    Set Minimize_Icon to False
97011>>>    Set Border_Style to Border_Thick
97012>>>    Set View_Mode to Viewmode_Zoom
97013>>>    Set pbAutoActivate to True
97014>>>    Set pbAcceptDropFiles to True
97015>>>
97015>>>    Set phoMainView of ghoApplication to Self
97016>>>    
97016>>>    Property Boolean pbEnabled False
97018>>>    Property Boolean pbNew False
97020>>>    Property tDataSourceRow[] pTheData
97022>>>
97022>>>    Function IniFileName Returns String
97025>>>        String sRetval
97025>>>        Get InfileName of oSQLConnections_grd to sRetval
97026>>>        Function_Return sRetval
97027>>>    End_Function
97028>>>
97028>>>    Object oGridInfo_tb is a TextBox
97030>>>        Set Auto_Size_State to False
97031>>>        Set Size to 9 368
97032>>>        Set Location to 10 34
97033>>>        Set Label to "Note: You can drag and drop a connection file on to the grid."
97034>>>        Set FontItalics to True
97035>>>        Set peAnchors to anTopLeftRight
97036>>>        Set Justification_Mode to JMode_Left
97037>>>    End_Object
97038>>>
97038>>>    Object oSQLConnections_grd is a cCJGrid
97040>>>        Set Size to 98 503
97041>>>        Set Location to 25 19
97042>>>        Set peAnchors to anAll
97043>>>        Set pbShowRowFocus to True
97044>>>        Set pbUseAlternateRowBackgroundColor to True
97045>>>        Set pbSelectionEnable to True
97046>>>        Set pbRestoreLayout to True
97047>>>        Set psLayoutSection to "oSQLConnections_grd"
97048>>>        Set piLayoutBuild to 13
97049>>>        Set pbShowFooter to True
97050>>>        Set pbAllowAppendRow to False
97051>>>        Set pbAllowEdit to False
97052>>>        Set pbAllowInsertRow to False
97053>>>        Set pbAutoAppend to False
97054>>>        Set pbAutoSave to False
97055>>>        Set pbEditOnTyping to False
97056>>>                Set peVisualTheme to xtpGridThemeExplorer
97057>>>        
97057>>>        Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
97059>>>            Set piWidth to 18
97060>>>        End_Object
97061>>>
97061>>>        Object oActive_Col is a cCJGridColumn
97063>>>            Set piWidth to 81
97064>>>            Set psCaption to "Enabled"
97065>>>            Set pbCheckbox to True
97066>>>            Set psToolTip to "Only one connection can be the active one at any time. Press the 'Edit' button or double-click on a row to edit."
97067>>>        End_Object
97068>>>
97068>>>        Object oConnectionID_Col is a cCJGridColumn
97070>>>            Set piWidth to 90
97071>>>            Set psCaption to "ID"
97072>>>        End_Object
97073>>>
97073>>>        Object oDbType_Col is a cCJGridColumn
97075>>>            Set piWidth to 150
97076>>>            Set psCaption to "Database Type"
97077>>>        End_Object
97078>>>
97078>>>        Object oServer_Col is a cCJGridColumn
97080>>>            Set piWidth to 138
97081>>>            Set psCaption to "Server"
97082>>>        End_Object
97083>>>
97083>>>        Object oDatabase_Col is a cCJGridColumn
97085>>>            Set piWidth to 92
97086>>>            Set psCaption to "Database"
97087>>>        End_Object
97088>>>
97088>>>        Object oDriver_Col is a cCJGridColumn
97090>>>            Set piWidth to 101
97091>>>            Set psCaption to "Driver ID"
97092>>>        End_Object
97093>>>
97093>>>        Object oConnectionString_Col is a cCJGridColumn
97095>>>            Set piWidth to 372
97096>>>            Set psCaption to "Connection String"
97097>>>            Set psTooltip to "The full connection string as read from the connections ini-file. Press the 'Edit' button or double-click on a row to edit."
97098>>>        End_Object
97099>>>
97099>>>        // The following columns are all hidden. The only reason they are here is to make the grid data exactly the same
97099>>>        // as the tSQLConnection data.
97099>>>        // See the "Should_Save" function
97099>>>        //
97099>>>        // "Untouched" connection string column. Needed when passing data between grid and popup dialog as we mask pw in connection string.
97099>>>        Object oConnectionStringFull_Col is a cCJGridColumn
97101>>>            Set piWidth to 50
97102>>>            Set psCaption to "Connection String (Untouched)"
97103>>>            Set pbVisible to False   
97104>>>            Set pbShowInFieldChooser to False
97105>>>        End_Object
97106>>>
97106>>>        Object oTrusted_Col is a cCJGridColumn
97108>>>            Set piWidth to 50
97109>>>            Set psCaption to "Trusted"
97110>>>            Set pbCheckbox to True
97111>>>            Set pbVisible to False
97112>>>        End_Object
97113>>>
97113>>>        Object oUserID_Col is a cCJGridColumn
97115>>>            Set piWidth to 50
97116>>>            Set psCaption to "UserID"
97117>>>            Set pbVisible to False
97118>>>        End_Object
97119>>>
97119>>>        Object oPassword_Col is a cCJGridColumn
97121>>>            Set piWidth to 50
97122>>>            Set psCaption to "Password"
97123>>>            Set pbVisible to False
97124>>>            Set pbShowInFieldChooser to False
97125>>>        End_Object
97126>>>
97126>>>        Object oSchema_Col is a cCJGridColumn
97128>>>            Set piWidth to 50
97129>>>            Set psCaption to "Schema"
97130>>>            Set pbVisible to False
97131>>>        End_Object
97132>>>
97132>>>        Object oBaseTableSpace_Col is a cCJGridColumn
97134>>>            Set piWidth to 50
97135>>>            Set psCaption to "Base Table Space"
97136>>>            Set pbVisible to False
97137>>>        End_Object
97138>>>
97138>>>        Object oLongTableSpace_Col is a cCJGridColumn
97140>>>            Set piWidth to 50
97141>>>            Set psCaption to "Long Table Space"
97142>>>            Set pbVisible to False
97143>>>        End_Object
97144>>>
97144>>>        Object oIndexTableSpace_Col is a cCJGridColumn
97146>>>            Set piWidth to 50
97147>>>            Set psCaption to "Index Table Space"
97148>>>            Set pbVisible to False
97149>>>        End_Object
97150>>>
97150>>>        Object oSilentLogin_Col is a cCJGridColumn
97152>>>            Set piWidth to 50
97153>>>            Set psCaption to "Silent Login"
97154>>>            Set pbCheckbox to True
97155>>>            Set pbVisible to False
97156>>>        End_Object
97157>>>
97157>>>//        Object oDisabled_Col is a cCJGridColumn
97157>>>//            Set piWidth to 50
97157>>>//            Set psCaption to "Disabled"
97157>>>//            Set pbVisible to False
97157>>>//        End_Object
97157>>>
97157>>>        Object oCJContextMenu is a cCJContextMenu
97159>>>            Set pbShowPopupBarToolTips of ghoCommandBars to True
97160>>>
97160>>>            Object oAddMenuItem is a cCJMenuItem
97162>>>                Set psCaption to "Add"
97163>>>                Set psTooltip to "Add new connection"
97164>>>                Set psImage to "ActionAdd1.ico"
97165>>>                Set psShortcut to "Ctrl+A"
97166>>>                Procedure OnExecute Variant vCommandBarControl
97169>>>                    Forward Send OnExecute vCommandBarControl
97171>>>                    Send AddItem
97172>>>                End_Procedure
97173>>>            End_Object
97174>>>
97174>>>            Object oEditMenuItem is a cCJMenuItem
97176>>>                Set psCaption to "Edit"
97177>>>                Set psTooltip to "Edit existing connection"
97178>>>                Set psImage to "ActionEdit1.ico"
97179>>>                Set psShortcut to "Ctrl+E"
97180>>>                Procedure OnExecute Variant vCommandBarControl
97183>>>                    Forward Send OnExecute vCommandBarControl
97185>>>                    Send EditItem
97186>>>                End_Procedure
97187>>>            End_Object
97188>>>
97188>>>            Object oDeleteMenuItem is a cCJMenuItem
97190>>>                Set psCaption to "Delete"
97191>>>                Set psTooltip to "Delete current connection"
97192>>>                Set psImage to "ActionDelete1.ico"
97193>>>                Set psShortcut to "Del"
97194>>>                Procedure OnExecute Variant vCommandBarControl
97197>>>                    Forward Send OnExecute vCommandBarControl
97199>>>                    Send DeleteItem 
97200>>>                End_Procedure
97201>>>            End_Object
97202>>>
97202>>>            Object oSaveMenuItem is a cCJMenuItem
97204>>>                Set pbControlBeginGroup to True
97205>>>                Set psCaption to "Save"
97206>>>                Set psTooltip to "Save changes"
97207>>>                Set psImage to "ActionSave1.ico" 
97208>>>                Set psShortcut to "Ctrl+S"
97209>>>                
97209>>>                Procedure OnExecute Variant vCommandBarControl
97212>>>                    Forward Send OnExecute vCommandBarControl
97214>>>                    Send SaveIniFile 
97215>>>                End_Procedure
97216>>>
97216>>>                Function IsEnabled Returns Boolean
97219>>>                    Boolean bState
97219>>>                    Get Should_Save to bState
97220>>>                    Function_Return (bState = True)
97221>>>                End_Function
97222>>>            End_Object
97223>>>
97223>>>            Object oSaveAsMenuItem is a cCJMenuItem
97225>>>                Set psCaption to "Save As"
97226>>>                Set psTooltip to "Save SQL Configuration File As"  
97227>>>                Set psImage to "ActionSaveAs1.ico"
97228>>>                
97228>>>                Procedure OnExecute Variant vCommandBarControl  
97231>>>                    String sPath sIniFileName sFileName
97231>>>
97231>>>                    Forward Send OnExecute vCommandBarControl
97233>>>                    
97233>>>                    Get psIniFilePath of ghoSQLConnectionHandler to sPath
97234>>>                    Get psIniFileName of ghoSQLConnectionHandler to sIniFileName
97235>>>                    Get vSelectSaveFile ".int" "Please enter a file name to save to" sPath sIniFileName to sFileName
97236>>>                    If (sFileName <> "") Begin
97238>>>                        Get ParseFolderName sFileName to sPath
97239>>>                        Get ParseFileName   sFileName to sIniFileName
97240>>>                        Set psIniFilePath of ghoSQLConnectionHandler to sPath
97241>>>                        Set psIniFileName of ghoSQLConnectionHandler to sIniFileName
97242>>>                        Send SaveIniFile  of (phoMainView(ghoApplication))
97243>>>                    End
97243>>>>
97243>>>                End_Procedure
97244>>>
97244>>>            End_Object   
97245>>>
97245>>>            Object oOpenMenuItem is a cCJMenuItem
97247>>>                Set pbControlBeginGroup to True
97248>>>                Set psCaption to "Open"
97249>>>                Set psTooltip to "Open SQL Connection ini-file"
97250>>>                Set psImage to "ActionOpen1.ico"
97251>>>                Set psShortcut to "Ctrl+O"
97252>>>                Procedure OnExecute Variant vCommandBarControl
97255>>>                    Forward Send OnExecute vCommandBarControl
97257>>>                    Send ActivateOpenDialog
97258>>>                End_Procedure
97259>>>            End_Object
97260>>>
97260>>>            Object oRefreshMenuItem is a cCJMenuItem
97262>>>                Set psCaption to "Refresh"
97263>>>                Set psTooltip to "Refresh grid (re-read values from ini-file)"
97264>>>                Set psImage to "ActionRefresh1.ico"
97265>>>                Set psShortcut to "Ctrl+R"
97266>>>
97266>>>                Procedure OnExecute Variant vCommandBarControl
97269>>>                    Forward Send OnExecute vCommandBarControl
97271>>>                    Send RefreshIniFile
97272>>>                End_Procedure
97273>>>
97273>>>                Function IsEnabled Returns Boolean
97276>>>                    Boolean bSave
97276>>>                    Get Should_Save to bSave
97277>>>                    Function_Return (bSave = True)
97278>>>                End_Function
97279>>>                
97279>>>            End_Object
97280>>>
97280>>>            Set phoContextMenu to Self
97281>>>        End_Object
97282>>>
97282>>>        Function Should_Save Returns Boolean
97285>>>            tDataSourceRow[] TheData1 TheData2
97285>>>            tDataSourceRow[] TheData1 TheData2
97287>>>            Handle hoDataSource
97287>>>            Boolean bShouldSave
97287>>>
97287>>>            Move True to bShouldSave
97288>>>            Get pTheData to TheData1
97289>>>            Get phoDataSource to hoDataSource
97290>>>            Get DataSource    of hoDataSource to TheData2
97291>>>                Move (not(IsSameArray(TheData1, TheData2))) to bShouldSave
97292>>>
97292>>>            Function_Return bShouldSave
97293>>>        End_Function
97294>>>
97294>>>        Function HasRecord Returns Boolean
97297>>>            tDataSourceRow[] TheData
97297>>>            tDataSourceRow[] TheData
97298>>>            Handle hoDataSource
97298>>>            Integer iSize
97298>>>
97298>>>            Get phoDataSource to hoDataSource
97299>>>            Get DataSource    of hoDataSource to TheData
97300>>>            Move (SizeOfArray(TheData)) to iSize
97301>>>
97301>>>            Function_Return (iSize > 0)
97302>>>        End_Function
97303>>>
97303>>>        Procedure ChangeHeaderText
97306>>>            Handle[] hoPanels
97307>>>            String sFileName
97307>>>
97307>>>            Send ChangeStatusRowText ""
97308>>>            Get IniFileName to sFileName
97309>>>            // Not sure why, but if the oStatusPane1 was set to "Set piID to sbpIDIdlePane",
97309>>>            // it wasn't always updated when this message was send. So instead change the
97309>>>            // text explicitly:
97309>>>            Get PaneObjects of (phoStatusBar(ghoCommandBars)) to hoPanels
97310>>>            Set psText of hoPanels[0] to sFileName
97311>>>        End_Procedure
97312>>>        
97312>>>        Function InFileName Returns String
97315>>>            String sFileName sPath
97315>>>            Handle ho
97315>>>            Boolean bChangesExist
97315>>>
97315>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97316>>>            Get psIniFilePath of ho to sPath
97317>>>            Get psIniFileName of ho to sFileName
97318>>>            If (sFileName = "") Begin
97320>>>                Move "" to sPath
97321>>>            End                 
97321>>>>
97321>>>            Else Begin
97322>>>                Get Should_Save to bChangesExist
97323>>>                If (bChangesExist = True) Begin
97325>>>                    Move (sFileName + "*") to sFileName
97326>>>                End
97326>>>>
97326>>>            End
97326>>>>
97326>>>            Function_Return (sPath + sFileName)
97327>>>        End_Function
97328>>>
97328>>>        Procedure LoadData
97331>>>            Handle hoDataSource ho
97331>>>            tDataSourceRow[] TheData
97331>>>            tDataSourceRow[] TheData
97332>>>            tDataSourceRow TheRow
97332>>>            tDataSourceRow TheRow
97332>>>            Integer iCount iSize
97332>>>            tSQLConnection[] SQLConnectionsArray
97332>>>            tSQLConnection[] SQLConnectionsArray
97333>>>
97333>>>            Send ChangeHeaderText
97334>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97335>>>
97335>>>            Get phoDataSource to hoDataSource
97336>>>            Send Reset of hoDataSource
97337>>>
97337>>>            Get ReadIniFile to SQLConnectionsArray
97338>>>            Move (SizeOfArray(SQLConnectionsArray)) to iSize
97339>>>            Decrement iSize
97340>>>
97340>>>            // Load data to the grid datasource array
97340>>>            For iCount from 0 to iSize
97346>>>>
97346>>>                Get MoveSQLConnectionToGridRow SQLConnectionsArray[iCount] to TheRow
97347>>>                Move TheRow to TheData[iCount]
97348>>>            Loop
97349>>>>
97349>>>
97349>>>            Set pTheData to TheData
97350>>>
97350>>>            // Initialize Grid with new data
97350>>>            Send InitializeData TheData
97351>>>
97351>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize +1))
97352>>>            Send MovetoFirstRow
97353>>>        End_Procedure    
97354>>>        
97354>>>        Procedure ClearData    
97357>>>            Handle hoDataSource
97357>>>            tDataSourceRow[] TheData
97357>>>            tDataSourceRow[] TheData
97358>>>
97358>>>            Send ChangeHeaderText
97359>>>            Set pTheData to TheData
97360>>>            Get phoDataSource to hoDataSource 
97361>>>            Send InitializeData TheData
97362>>>        End_Procedure
97363>>>
97363>>>        // Transfers data between a tSQLConnection struct and a grid data row.
97363>>>        Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
97366>>>            tDataSourceRow TheRow
97366>>>            tDataSourceRow TheRow
97366>>>            Integer iDbType
97366>>>            String sValue
97366>>>
97366>>>            Move SQLConnection.bEnabled             to TheRow.sValue[piColumnId(oActive_Col(Self))]
97367>>>            Move SQLConnection.sConnectionID        to TheRow.sValue[piColumnId(oConnectionID_Col(Self))]
97368>>>            Move SQLConnection.sDriverID            to TheRow.sValue[piColumnId(oDriver_Col(Self))]
97369>>>
97369>>>            // We only show three asterisks ("***") instead of the password in the grid.
97369>>>            Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97370>>>            Move sValue                             to TheRow.sValue[piColumnId(oConnectionString_Col(Self))]
97371>>>
97371>>>            Move SQLConnection.iDbType to iDbType
97372>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
97373>>>            Move sValue                             to TheRow.sValue[piColumnId(oDbType_Col(Self))]
97374>>>            Move SQLConnection.sServer              to TheRow.sValue[piColumnId(oServer_Col(Self))]
97375>>>            Move SQLConnection.sDatabase            to TheRow.sValue[piColumnId(oDatabase_Col(Self))]
97376>>>
97376>>>            // Hidden columns (to make Should_Save function work)
97376>>>            Move SQLConnection.sConnectionString    to TheRow.sValue[piColumnId(oConnectionStringFull_Col(Self))] // "Untouched" connection string.
97377>>>            Move SQLConnection.bTrusted             to TheRow.sValue[piColumnId(oTrusted_Col(Self))]
97378>>>            Move SQLConnection.sUserID              to TheRow.sValue[piColumnId(oUserID_Col(Self))]
97379>>>            Move SQLConnection.sPassword            to TheRow.sValue[piColumnId(oPassword_Col(Self))]
97380>>>            Move SQLConnection.sSchema              to TheRow.sValue[piColumnId(oSchema_Col(Self))]
97381>>>            Move SQLConnection.sBaseTableSpace      to TheRow.sValue[piColumnId(oBaseTableSpace_Col(Self))]
97382>>>            Move SQLConnection.sLongTableSpace      to TheRow.sValue[piColumnId(oLongTableSpace_Col(Self))]
97383>>>            Move SQLConnection.sIndexTableSpace     to TheRow.sValue[piColumnId(oIndexTableSpace_Col(Self))]
97384>>>            Move SQLConnection.bSilentLogin         to TheRow.sValue[piColumnId(oSilentLogin_Col(Self))]
97385>>>//            Move SQLConnection.bDisabled            to TheRow.sValue[piColumnId(oDisabled_Col(Self))]
97385>>>
97385>>>            Function_Return TheRow
97386>>>        End_Function
97387>>>
97387>>>        // Transfers data between a grid data row and a tSQLConnection struct.
97387>>>        Function MoveGridRowToSQLConnection tDataSourceRow TheRow Returns tSQLConnection
97390>>>            tSQLConnection SQLConnection
97390>>>            tSQLConnection SQLConnection
97390>>>            String sValue
97390>>>
97390>>>            Move TheRow.sValue[piColumnId(oActive_Col(Self))]               to SQLConnection.bEnabled
97391>>>            Move TheRow.sValue[piColumnId(oConnectionID_Col(Self))]         to SQLConnection.sConnectionID
97392>>>
97392>>>            Move TheRow.sValue[piColumnId(oDbType_Col(Self))]               to sValue
97393>>>            Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sValue to SQLConnection.iDbType
97394>>>            Move TheRow.sValue[piColumnId(oServer_Col(Self))]               to SQLConnection.sServer
97395>>>            Move TheRow.sValue[piColumnId(oDatabase_Col(Self))]             to SQLConnection.sDatabase
97396>>>            Move TheRow.sValue[piColumnId(oDriver_Col(Self))]               to SQLConnection.sDriverID
97397>>>
97397>>>            // Hidden columns (to make Should_Save function work)
97397>>>            Move TheRow.sValue[piColumnId(oConnectionStringFull_Col(Self))] to SQLConnection.sConnectionString
97398>>>            Move TheRow.sValue[piColumnId(oTrusted_Col(Self))]              to SQLConnection.bTrusted
97399>>>            Move TheRow.sValue[piColumnId(oUserID_Col(Self))]               to SQLConnection.sUserID
97400>>>            Move TheRow.sValue[piColumnId(oPassword_Col(Self))]             to SQLConnection.sPassword
97401>>>            Move TheRow.sValue[piColumnId(oSchema_Col(Self))]               to SQLConnection.sSchema
97402>>>            Move TheRow.sValue[piColumnId(oBaseTableSpace_Col(Self))]       to SQLConnection.sBaseTableSpace
97403>>>            Move TheRow.sValue[piColumnId(oLongTableSpace_Col(Self))]       to SQLConnection.sLongTableSpace
97404>>>            Move TheRow.sValue[piColumnId(oIndexTableSpace_Col(Self))]      to SQLConnection.sIndexTableSpace
97405>>>            Move TheRow.sValue[piColumnId(oSilentLogin_Col(Self))]          to SQLConnection.bSilentLogin
97406>>>//            Move TheRow.sValue[piColumnId(oDisabled_Col(Self))]             to SQLConnection.bDisabled
97406>>>
97406>>>            Function_Return SQLConnection
97407>>>        End_Function
97408>>>
97408>>>        // Called when the grid object is created:
97408>>>        Procedure Activating
97411>>>            Forward Send Activating
97413>>>            Send LoadData
97414>>>        End_Procedure
97415>>>
97415>>>        Function CurrentRow Returns Integer
97418>>>            Handle hoDataSource
97418>>>            Integer iRow
97418>>>
97418>>>            Get phoDataSource to hoDataSource
97419>>>            Get SelectedRow   of hoDataSource to iRow
97420>>>            Function_Return iRow
97421>>>        End_Function
97422>>>
97422>>>        Function CurrentRowData Returns tDataSourceRow
97425>>>            tDataSourceRow[] TheData
97425>>>            tDataSourceRow[] TheData
97426>>>            tDataSourceRow TheRow
97426>>>            tDataSourceRow TheRow
97426>>>            Handle ho hoDataSource
97426>>>            Integer iRow
97426>>>
97426>>>            Get phoDataSource  to hoDataSource
97427>>>            Get DataSource     of hoDataSource to TheData
97428>>>            Get SelectedRow    of hoDataSource to iRow
97429>>>            Move TheData[iRow] to TheRow
97430>>>
97430>>>            Function_Return TheRow
97431>>>        End_Function
97432>>>
97432>>>        Procedure OnRowChanged Integer iOldRow Integer iNewSelectedRow
97435>>>            Integer iRow
97435>>>            Handle hoDataSource
97435>>>            tDataSourceRow[] RowData
97435>>>            tDataSourceRow[] RowData
97436>>>
97436>>>            Forward Send OnRowChanged iOldRow iNewSelectedRow
97438>>>            Send ChangeHeaderText
97439>>>
97439>>>            Get phoDataSource to hoDataSource
97440>>>
97440>>>            Get SelectedRow of hoDataSource to iRow
97441>>>            If (iRow <> -1) Begin
97443>>>                Get DataSource of hoDataSource to RowData
97444>>>                Set pbEnabled to RowData[iRow].sValue[piColumnid(oActive_Col(Self))]
97445>>>            End
97445>>>>
97445>>>        End_Procedure
97446>>>
97446>>>        Procedure OnComRowDblClick Variant llRow Variant llItem
97449>>>            Forward Send OnComRowDblClick llRow llItem
97451>>>            Delegate Send EditItem 
97453>>>        End_Procedure
97454>>>
97454>>>        Procedure OnEnterKey
97457>>>            Forward Send OnEnterKey
97459>>>            Delegate Send EditItem 
97461>>>        End_Procedure
97462>>>
97462>>>        Procedure AddConnection tDataSourceRow TheRow
97465>>>            Integer iSize iCount
97465>>>            Handle hoDataSource
97465>>>            tDataSourceRow[] TheData
97465>>>            tDataSourceRow[] TheData
97466>>>            Boolean bEnabled
97466>>>
97466>>>            Get phoDataSource to hoDataSource
97467>>>            Get DataSource    of hoDataSource to TheData
97468>>>
97468>>>            Move (SizeOfArray(TheData)) to iSize
97469>>>            Move (TheRow.sValue[piColumnid(oActive_Col(Self))]) to bEnabled
97470>>>            If (bEnabled = True) Begin
97472>>>                // Then bEnabled state have changed; deactivate all current rows.
97472>>>                For iCount from 0 to (iSize -1)
97478>>>>
97478>>>                    Move False to TheData[iCount].sValue[piColumnId(oActive_Col(Self))]
97479>>>                Loop
97480>>>>
97480>>>            End
97480>>>>
97480>>>
97480>>>            Move TheRow to TheData[iSize]
97481>>>
97481>>>            // Initialize Grid with new data
97481>>>            Send InitializeData TheData True
97482>>>            Move (SizeOfArray(TheData)) to iSize
97483>>>            Send MoveToLastRow
97484>>>
97484>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
97485>>>        End_Procedure
97486>>>
97486>>>        Procedure UpdateConnection tDataSourceRow TheRow
97489>>>            Integer iRow iSize iCount
97489>>>            Handle hoDataSource
97489>>>            tDataSourceRow[] TheData
97489>>>            tDataSourceRow[] TheData
97490>>>            Boolean bEnabled
97490>>>
97490>>>            Get phoDataSource to hoDataSource
97491>>>            Get SelectedRow of hoDataSource to iRow
97492>>>            If (iRow <> -1) Begin
97494>>>                Get DataSource of hoDataSource to TheData
97495>>>
97495>>>                // If bEnabled state has changed; deactivate all rows.
97495>>>                Move (TheRow.sValue[piColumnId(oActive_Col(Self))]) to bEnabled
97496>>>                If (bEnabled = True) Begin
97498>>>                    Move (SizeOfArray(TheData)) to iSize
97499>>>                    Decrement iSize
97500>>>                    For iCount from 0 to iSize
97506>>>>
97506>>>                        Move False to TheData[iCount].sValue[piColumnId(oActive_Col(Self))]
97507>>>                    Loop
97508>>>>
97508>>>                End
97508>>>>
97508>>>
97508>>>                Move TheRow to TheData[iRow]
97509>>>            End
97509>>>>
97509>>>
97509>>>            // Initialize Grid with new data
97509>>>            Send ReInitializeData TheData True
97510>>>            Move (SizeOfArray(TheData)) to iSize
97511>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
97512>>>        End_Procedure
97513>>>
97513>>>        Procedure RemoveCurrentConnection
97516>>>            Integer iSize iRow iItem
97516>>>            Handle hoDataSource
97516>>>            tDataSourceRow[] TheData
97516>>>            tDataSourceRow[] TheData
97517>>>
97517>>>            Move 0 to iItem
97518>>>            Get phoDataSource to hoDataSource
97519>>>            Get DataSource of hoDataSource to TheData
97520>>>
97520>>>            Get SelectedRow of hoDataSource to iRow
97521>>>            If (iRow = -1) Begin
97523>>>                Procedure_Return
97524>>>            End
97524>>>>
97524>>>
97524>>>            Move False to Err
97525>>>            Send Request_Delete
97526>>>
97526>>>            Get DataSource of hoDataSource to TheData
97527>>>            Move (SizeOfArray(TheData)) to iSize
97528>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
97529>>>        End_Procedure
97530>>>
97530>>>        Function IsOneItemActive Returns Boolean
97533>>>            Handle hoDataSource ho
97533>>>            tDataSourceRow[] TheData
97533>>>            tDataSourceRow[] TheData
97534>>>            Integer iSize iCount
97534>>>            Boolean bRetval bExists
97534>>>            String sSection
97534>>>
97534>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97535>>>            Get psIniSectionName of ho to sSection
97536>>>            Get SectionExists    of ho sSection to bExists
97537>>>
97537>>>            Get phoDataSource to hoDataSource
97538>>>            Get DataSource of hoDataSource to TheData
97539>>>
97539>>>            Move (SizeOfArray(TheData)) to iSize
97540>>>            If (iSize = 0) Begin
97542>>>                Function_Return True
97543>>>            End
97543>>>>
97543>>>
97543>>>            Decrement iSize
97544>>>            For iCount from 0 to iSize
97550>>>>
97550>>>                If (TheData[iCount].sValue[piColumnId(oActive_Col(Self))] = True) Begin
97552>>>                    Move True to bRetval
97553>>>                End
97553>>>>
97553>>>            Loop
97554>>>>
97554>>>
97554>>>            Function_Return bRetval
97555>>>        End_Function
97556>>>
97556>>>        Function ReadIniFile Returns tSQLConnection[]
97559>>>            tSQLConnection[] SQLConnectionsArray
97559>>>            tSQLConnection[] SQLConnectionsArray
97560>>>            Handle ho
97560>>>
97560>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97561>>>            Get SQLIniFileReadConnections of ho to SQLConnectionsArray
97562>>>
97562>>>            Function_Return SQLConnectionsArray
97563>>>        End_Function
97564>>>
97564>>>        Procedure WriteIniFile
97567>>>            Integer iCount iSize iRetval
97567>>>            Handle hoDataSource ho
97567>>>            tDataSourceRow[] TheData
97567>>>            tDataSourceRow[] TheData
97568>>>            tDataSourceRow TheRow
97568>>>            tDataSourceRow TheRow
97568>>>            tSQLConnection[] SQLConnectionArray
97568>>>            tSQLConnection[] SQLConnectionArray
97569>>>            tSQLConnection SQLConnection
97569>>>            tSQLConnection SQLConnection
97569>>>            Boolean bIsOneActive bOK
97569>>>            String sPath sIniFileName
97569>>>            
97569>>>            Get psIniFileName of ghoSQLConnectionHandler to sIniFileName
97570>>>            If (sIniFileName = "") Begin
97572>>>                Get vSelectSaveFile ("SQLConnections ini-files (*.ini)|" + CS_SQLIniFileName + "|All Ini Files (*.ini)|*.ini|All Files (*.*)|*.*") "Select a connection ini-file" "" to sIniFileName
97573>>>                If (sIniFileName <> "") Begin
97575>>>                    Get ParseFolderName sIniFileName to sPath
97576>>>                    Set psIniFilePath of ghoSQLConnectionHandler to sPath
97577>>>                    Get ParseFileName sIniFileName to sIniFileName
97578>>>                    Set psIniFileName of ghoSQLConnectionHandler to sIniFileName
97579>>>                End  
97579>>>>
97579>>>                Else Begin
97580>>>                    Procedure_Return
97581>>>                End
97581>>>>
97581>>>            End
97581>>>>
97581>>>            
97581>>>            // 2018-07-14 I don't think this is necessary. In fact it can be quite practical in
97581>>>            // testing to disable all connections, or if e.g. customer's connections has been tested,
97581>>>            // that no longer are available locally.
97581>>>            Get IsOneItemActive to bIsOneActive
97582>>>//            If (bIsOneActive = False) Begin
97582>>>//                Send Info_Box "Sorry, you need to set one connection as active before changes can be saved."
97582>>>//                Procedure_Return
97582>>>//            End
97582>>>            If (bIsOneActive = False) Begin
97584>>>                Get YesNo_Box "Warning, no connection has been set to 'Enabled'. That means that the Database Framework will not read any information from here when initialized.\n\nAre you sure you want to continue to save without any connection Enabled?" to iRetval
97585>>>                If (iRetval = MBR_No) Begin
97587>>>                    Procedure_Return
97588>>>                End
97588>>>>
97588>>>            End
97588>>>>
97588>>>
97588>>>            Move 0 to iCount
97589>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97590>>>            Get phoDataSource to hoDataSource
97591>>>            Get DataSource of hoDataSource to TheData
97592>>>            Move (SizeOfArray(TheData)) to iSize
97593>>>            Decrement iSize
97594>>>
97594>>>            // Load data from the grid datasource array to SQLConnection array
97594>>>            For iCount from 0 to iSize
97600>>>>
97600>>>                Move TheData[iCount] to TheRow
97601>>>                Get MoveGridRowToSQLConnection TheRow to SQLConnection
97602>>>                Move SQLConnection to SQLConnectionArray[iCount]
97603>>>            Loop
97604>>>>
97604>>>
97604>>>            Get SQLIniFileWriteConnections of ho SQLConnectionArray to bOK
97605>>>            If (bOK = False) Begin
97607>>>                Send ChangeStatusRowText "Sorry, an error occured while saving the file and changes were not saved."
97608>>>                Procedure_Return
97609>>>            End
97609>>>>
97609>>>
97609>>>            // Update the view property with the newly saved values. (Used to check if anything has changed)
97609>>>            Set pTheData to TheData
97610>>>            Send ChangeHeaderText
97611>>>            Send ChangeStatusRowText "Ready! File saved."
97612>>>        End_Procedure
97613>>>
97613>>>        Procedure OnHeaderClick Integer iCol
97616>>>            String sPath sFileName
97616>>>            Handle ho
97616>>>
97616>>>            Forward Send OnHeaderClick iCol
97618>>>
97618>>>            Get vSelect_File ("SQLConnections ini-files (*.ini)|" + CS_SQLIniFileName + "|All Ini Files (*.ini)|*.ini|All Files (*.*)|*.*") "Select a connection ini-file" "" to sFileName
97619>>>            If (sFileName <> "") Begin
97621>>>                Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97622>>>                Get ParseFolderName sFileName to sPath
97623>>>                Set psIniFilePath of ho to sPath
97624>>>                Get ParseFileName sFileName to sFileName
97625>>>                Set psIniFileName of ho to sFilename
97626>>>                Set pbDFConnId of ho to (sFileName <> CS_SQLIniFileName)
97627>>>                Send LoadData of oSQLConnections_grd
97628>>>            End
97628>>>>
97628>>>        End_Procedure
97629>>>
97629>>>        Procedure OnCreateGridControl 
97632>>>            Handle hoObject  
97632>>>            Integer iToolTipStyle      
97632>>>            Boolean bIsBalloonStyleSupported
97632>>>            
97632>>>            Forward Send OnCreateGridControl
97634>>>    
97634>>>            Get phoToolTipContext to hoObject
97635>>>            If (hoObject <> 0) Begin
97637>>>                Move xtpToolTipStandard to iToolTipStyle    
97638>>>                // Baloon tooltip style requires IE 5.0 or later, so check if installed.
97638>>>                // The ComShowTitleAndDescription also requires IE 5.0.
97638>>>                Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
97639>>>                If (bIsBalloonStyleSupported = True) Begin
97641>>>                    Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
97642>>>                End                                                   
97642>>>>
97642>>>                Set ComStyle             of hoObject to iToolTipStyle
97643>>>                Set ComShowOfficeBorder  of hoObject to True
97644>>>                Set ComShowShadow        of hoObject to True
97645>>>                // Set the max width for a tooltip. 250 just seems to be a good
97645>>>                // compromise. After 250 pixels the text will wrap to the next line automatically.
97645>>>                Set ComMaxTipWidth       of hoObject to 250 // In pixels
97646>>>            End 
97646>>>>
97646>>>        End_Procedure
97647>>>
97647>>>        // These overrides the grid standar behaviour
97647>>>        On_Key kSave_Record Send SaveIniFile
97648>>>        On_Key Key_F5       Send RefreshIniFile
97649>>>    End_Object
97650>>>
97650>>>    // Public access methods: (used by menu/toolbar system)
97650>>>    Procedure ActivateOpenDialog
97653>>>        Send OnHeaderClick of oSQLConnections_grd 1
97654>>>    End_Procedure
97655>>>
97655>>>    Procedure RefreshIniFile
97658>>>        Boolean bChanged
97658>>>        Handle ho
97658>>>        Integer iRetval
97658>>>
97658>>>        Move (oSQLConnections_grd(Self)) to ho
97659>>>        Get Should_Save of ho to bChanged
97660>>>        If (bChanged = True) Begin
97662>>>            Get YesNo_Box "Changes exists! Press 'Yes' to refresh (changes will be lost)." "Refresh Question" to iRetval
97663>>>            If (iRetval <> MBR_Yes) Begin
97665>>>                Procedure_Return
97666>>>            End
97666>>>>
97666>>>        End
97666>>>>
97666>>>        Send ChangeStatusRowText ""
97667>>>        Send LoadData of oSQLConnections_grd
97668>>>    End_Procedure
97669>>>
97669>>>    Procedure AddItem
97672>>>        Boolean bChanged bDFConnId
97672>>>        tSQLConnection SQLConnection
97672>>>        tSQLConnection SQLConnection
97672>>>        tDataSourceRow[] TheData
97672>>>        tDataSourceRow[] TheData
97673>>>        tDataSourceRow   TheRow
97673>>>        tDataSourceRow   TheRow
97673>>>        Handle hoDataSource
97673>>>
97673>>>        Send ChangeStatusRowText ""
97674>>>        Get IsDFConnId to bDFConnId
97675>>>        Move EN_DbTypeMSSQL to SQLConnection.iDbType
97676>>>        Move MSSQLDRV_ID    to SQLConnection.sDriverID
97677>>>        Get phoDataSource of oSQLConnections_grd to hoDataSource
97678>>>        Get DataSource of hoDataSource to TheData
97679>>>        Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) -1 (&SQLConnection) (&bChanged) bDFConnId TheData
97680>>>        If (bChanged = True) Begin
97682>>>            Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
97683>>>            Send AddConnection of oSQLConnections_grd TheRow
97684>>>        End
97684>>>>
97684>>>    End_Procedure
97685>>>
97685>>>    Procedure EditItem
97688>>>        Boolean bEnabled bChanged bDFConnId
97688>>>        tSQLConnection SQLConnection
97688>>>        tSQLConnection SQLConnection
97688>>>        tDataSourceRow TheRow
97688>>>        tDataSourceRow TheRow
97688>>>        tDataSourceRow[] TheData
97688>>>        tDataSourceRow[] TheData
97689>>>        Handle hoDataSource
97689>>>        Integer iCurrentRow
97689>>>
97689>>>        Get CurrentRowData of oSQLConnections_grd to TheRow
97690>>>        Get MoveGridRowToSQLConnection of oSQLConnections_grd TheRow to SQLConnection
97691>>>        Send ChangeStatusRowText ""
97692>>>        Get pbEnabled to bEnabled
97693>>>        Get IsDFConnId to bDFConnId
97694>>>
97694>>>        Get phoDataSource of oSQLConnections_grd to hoDataSource
97695>>>        Get DataSource of hoDataSource to TheData
97696>>>        Get CurrentRow of oSQLConnections_grd to iCurrentRow
97697>>>
97697>>>        Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) iCurrentRow (&SQLConnection) (&bChanged) bDFConnId TheData
97698>>>        If (bChanged = True) Begin
97700>>>            Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
97701>>>            Send UpdateConnection of oSQLConnections_grd TheRow
97702>>>        End
97702>>>>
97702>>>    End_Procedure
97703>>>
97703>>>    Procedure SaveIniFile
97706>>>        Send ChangeStatusRowText ""
97707>>>        Send WriteIniFile of oSQLConnections_grd
97708>>>    End_Procedure
97709>>>
97709>>>    Procedure ClearIniFile
97712>>>        Handle ho
97712>>>        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97713>>>        Set psIniFilePath of ho to ""
97714>>>        Set psIniFileName of ho to ""
97715>>>        Set pbDFConnId of ho to False
97716>>>        Send ClearData of (oSQLConnections_grd(phoMainView(ghoApplication))) 
97717>>>    End_Procedure   
97718>>>                
97718>>>    Procedure DeleteItem
97721>>>        Send ChangeStatusRowText ""
97722>>>        Send RemoveCurrentConnection of oSQLConnections_grd
97723>>>    End_Procedure
97724>>>
97724>>>    Procedure ExitApplication
97727>>>        Send Exit_Application of ghoApplication
97728>>>    End_Procedure
97729>>>    
97729>>>    // Other messages used by the view:
97729>>>    Function IsDFConnId Returns Boolean
97732>>>        Boolean bDFConnId
97732>>>        Handle ho
97732>>>        String sFileName
97732>>>
97732>>>        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97733>>>        Get psIniFileName of ho to sFileName
97734>>>        Move (Uppercase(sFileName) = Uppercase(CS_SQLDF19IniFileName)) to bDFConnId
97735>>>        Set pbDFConnId of ho to bDFConnId
97736>>>
97736>>>        Function_Return bDFConnId
97737>>>    End_Function
97738>>>
97738>>>    Procedure OnFileDropped String sFilename Boolean bLast
97741>>>        Boolean bHasChange
97741>>>        Handle ho hoGrid
97741>>>        Integer iRetval
97741>>>        String sPath
97741>>>
97741>>>        Forward Send OnFileDropped sFilename bLast
97743>>>
97743>>>        If (bLast = True) Begin
97745>>>            Move (oSQLConnections_grd(Self)) to hoGrid
97746>>>            Get ParseFolderName sFilename to sPath
97747>>>            Get ParseFileName   sFilename to sFilename
97748>>>            If (Uppercase(sFilename) <> Uppercase(CS_SQLIniFileName) and Uppercase(sFilename) <> Uppercase(CS_SQLDF19IniFileName)) Begin
97750>>>                Send Info_Box ("Sorry, only" * CS_SQLIniFileName * "files can be dropped!")
97751>>>                Procedure_Return
97752>>>            End
97752>>>>
97752>>>            Get Should_Save of hoGrid to bHasChange
97753>>>            If (bHasChange = True) Begin
97755>>>                Get YesNo_Box "Changes exist! Do you still want to load the new file?" to iRetval
97756>>>                If (iRetval <> MBR_Yes) Begin
97758>>>                    Procedure_Return
97759>>>                End
97759>>>>
97759>>>            End
97759>>>>
97759>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97760>>>            Set psIniFilePath of ho to sPath
97761>>>            Set psIniFileName of ho to sFilename
97762>>>            Send LoadData of oSQLConnections_grd
97763>>>        End
97763>>>>
97763>>>    End_Procedure
97764>>>
97764>>>    // This is only being called when there is no SQLConnections.ini file;
97764>>>    // thus a new active/enabled DFConnection ID needs to be established.
97764>>>    Procedure ConnectionDoesNotExist
97767>>>        tSQLConnection SQLConnection
97767>>>        tSQLConnection SQLConnection
97767>>>        Boolean bChanged bDFConnId bEnabled
97767>>>        Handle ho
97767>>>        tDataSourceRow TheRow
97767>>>        tDataSourceRow TheRow
97767>>>        Handle hoDataSource
97767>>>        tDataSourceRow[] TheData
97767>>>        tDataSourceRow[] TheData
97768>>>
97768>>>        Get IsDFConnId to bDFConnId
97769>>>
97769>>>        Move (oSQLMaintainConnections_dg(Self)) to ho
97770>>>        Move True to bEnabled
97771>>>        Set pbNew to True
97772>>>        Set pbNew of ho to True
97773>>>
97773>>>        Get phoDataSource of oSQLConnections_grd to hoDataSource
97774>>>        Get DataSource of hoDataSource to TheData
97775>>>
97775>>>        Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) -1 (&SQLConnection) (&bChanged) bDFConnId TheData
97776>>>        If (bChanged = True) Begin
97778>>>            // We also need to tell the main connection object that we now have
97778>>>            // created a connection.
97778>>>            Set pSQLConnection            of ghoSQLConnectionHandler to SQLConnection
97779>>>            // And add the data to the grid.
97779>>>            Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
97780>>>            Send AddConnection of oSQLConnections_grd TheRow
97781>>>            // Not new anymore.
97781>>>            Set pbNew to False
97782>>>            Set pbNew of ho to False
97783>>>        End
97783>>>>
97783>>>    End_Procedure
97784>>>
97784>>>    Procedure ChangeStatusRowText String sText
97787>>>        Handle[] hoPanels
97788>>>        Get PaneObjects of (phoStatusBar(ghoCommandBars)) to hoPanels
97789>>>        Set psText of hoPanels[1] to sText
97790>>>    End_Procedure
97791>>>
97791>>>    // On idle handling:
97791>>>    Object oIdle is a cIdleHandler
97793>>>        Procedure OnIdle
97796>>>          Delegate Send OnIdle
97798>>>        End_Procedure
97799>>>    End_Object
97800>>>
97800>>>    Procedure OnIdle
97803>>>        Handle ho
97803>>>
97803>>>        Move (oSQLConnections_grd(Self)) to ho
97804>>>        Send ChangeHeaderText of ho
97805>>>    End_Procedure
97806>>>
97806>>>    Procedure Activating
97809>>>        Handle ho
97809>>>
97809>>>        Set Maximize_Icon to True
97810>>>        Set Minimize_Icon to False
97811>>>        Set Border_Style to Border_Thick
97812>>>        Set View_Mode to Viewmode_Zoom
97813>>>
97813>>>        // Note: The following line is essential for the resizing logic
97813>>>        // to work when starting the program.
97813>>>        Move (Client_Id(ghoCommandBars)) to ho
97814>>>        Set Border_Style of ho to Border_ClientEdge
97815>>>
97815>>>        Set pbEnabled of oIdle to True
97816>>>    End_Procedure
97817>>>
97817>>>    Procedure Deactivating
97820>>>        Set pbEnabled of oIdle to False
97821>>>        Forward Send Deactivating
97823>>>    End_Procedure
97824>>>
97824>>>    Function Verify_Exit_Application Returns Integer
97827>>>        Integer iRetval
97827>>>        Boolean bChanged
97827>>>
97827>>>        Get Should_Save of oSQLConnections_grd to bChanged
97828>>>        If (bChanged = False) Begin
97830>>>            Function_Return False
97831>>>        End
97831>>>>
97831>>>        Else Begin
97832>>>            Get YesNoCancel_Box "Changes exists. Save changes first?" to iRetval
97833>>>            If (iRetval = MBR_Cancel) Begin
97835>>>                Function_Return True
97836>>>            End
97836>>>>
97836>>>            If (iRetval = MBR_Yes) Begin
97838>>>                Send SaveIniFile //KeyAction of oSave_btn
97839>>>                Send Exit_Application
97840>>>            End
97840>>>>
97840>>>            If (iRetval = MBR_No) Begin
97842>>>                Function_Return False
97843>>>            End
97843>>>>
97843>>>        End
97843>>>>
97843>>>        Function_Return True
97844>>>    End_Function
97845>>>
97845>>>    On_Key kDelete_Character Send DeleteItem 
97846>>>    On_Key Key_Ctrl+Key_D    Send DeleteItem 
97847>>>    On_Key Key_Alt+Key_D     Send DeleteItem 
97848>>>    On_Key Key_Ctrl+Key_E    Send EditItem   
97849>>>    On_Key Key_Alt+Key_E     Send EditItem   
97850>>>    On_Key Key_Ctrl+Key_A    Send AddItem    
97851>>>    On_Key Key_Alt+Key_A     Send AddItem    
97852>>>    On_Key Key_F5            Send RefreshIniFile 
97853>>>    On_Key Key_Ctrl+Key_R    Send RefreshIniFile 
97854>>>    On_Key Key_Alt+Key_R     Send RefreshIniFile 
97855>>>    On_Key Key_Ctrl+Key_F5   Send ClearIniFile
97856>>>    On_Key kSave_Record      Send SaveIniFile    
97857>>>    On_Key Key_Ctrl+Key_S    Send SaveIniFile    
97858>>>    On_Key Key_F2            Send SaveIniFile    
97859>>>    On_Key Key_Ctrl+Key_X    Send ExitApplication
97860>>>    On_Key Key_Ctrl+Key_O    Send ActivateOpenDialog
97861>>>    On_Key Key_Alt+Key_O     Send ActivateOpenDialog
97862>>>    On_Key kCancel           Send None
97863>>>    On_Key Key_Ctrl+Key_F4   Send None
97864>>>End_Object
97865>        Use ManageSQLConnections.dg
97865>        Use AddToStudio.dg
Including file: AddToStudio.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\AddToStudio.dg)
97865>>>Use Windows.pkg
97865>>>Use Dfspnfrm.pkg
97865>>>Use cRegistry.pkg
97865>>>Use vWin32fh.pkg
97865>>>
97865>>>Enum_List
97865>>>    Define cx_RegKeyAlreadyExist
97865>>>    Define cx_RegKeyCreated
97865>>>    Define cx_RegkeyFailed
97865>>>    Define cx_RegKeyVDFKeyDoesNotExist
97865>>>    Define CX_InstalledOkVdfUnder16
97865>>>End_Enum_List
97865>>>
97865>>>// Note: The "Visual" part will automatically be removed if
97865>>>// the current DataFlex version is above 17.
97865>>>Define CS_StudioPath        for "Software\Data Access Worldwide\Visual DataFlex Tools\"
97865>>>Define CS_StudioTools       for "\Studio\Tools"
97865>>>Define CS_RegApplication    for "<application>"
97865>>>Define CS_RegWorkspace      for "<workspace>"
97865>>>Define CS_CommandLine       for "CommandLine"
97865>>>Define CS_Name              for "Name"
97865>>>Define CS_Separator         for "Separator"
97865>>>Define CS_Command           for "Command"
97865>>>
97865>>>Object oAddToStudio_dg is a ModalPanel
97867>>>    Set Size to 79 330
97868>>>    Set Label to "Add Program To DataFlex Studio's Tools Menu"
97869>>>    Set piMinSize to 79 211
97870>>>    Set Location to 5 4
97871>>>    Set Locate_Mode to Center_On_Parent
97872>>>
97872>>>    Property String psTag CS_RegApplication
97874>>>
97874>>>    Object oStudioIntegration_grp is a Group
97876>>>        Set Size to 45 299
97877>>>        Set Location to 8 15
97878>>>        Set Label to "DataFlex Studio Integration"
97879>>>
97879>>>        Object oStudioMajorVersion_sf is a SpinForm
97881>>>            Set Size to 12 27
97882>>>            Set Location to 18 168
97883>>>            Set Maximum_Position to 30
97884>>>            Set Minimum_Position to 14
97885>>>            Set Label_Col_Offset to 2
97886>>>            Set Label_Justification_Mode to JMode_Right
97887>>>            Set Label to "Add to Studio's Tools Menu:     Major Version"
97888>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
97889>>>            Set Value to FMAC_VERSION
97890>>>            Set peAnchors to anNone
97891>>>        End_Object
97892>>>
97892>>>        Object oStudioMinorVersion_sf is a SpinForm
97894>>>            Set Size to 12 27
97895>>>            Set Location to 18 254
97896>>>            Set Label_Col_Offset to 2
97897>>>            Set Label to "Minor Version"
97898>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
97899>>>            Set Maximum_Position to 9
97900>>>            Set Minimum_Position to 0
97901>>>            Set Value to FMAC_REVISION
97902>>>            Set Label_Justification_Mode to JMode_Right
97903>>>            Set peAnchors to anNone
97904>>>        End_Object
97905>>>
97905>>>    End_Object
97906>>>
97906>>>    Object oOK_btn is a Button
97908>>>        Set Location to 59 207
97909>>>        Set Label to "Add Now"
97910>>>        Set Status_Help to "Add to DataFlex Studio's Tools menu. The Studio version can be selected with the two spinforms. The program gets added to the Studios Tools menu."
97911>>>        Set peAnchors to anTopRight
97912>>>
97912>>>        Procedure OnClick
97915>>>            Integer iRetval iMajorVersion iMinorVersion
97915>>>            String sText sStudioVersion
97915>>>            Get Value of oStudioMajorVersion_sf to iMajorVersion
97916>>>            Get Value of oStudioMinorVersion_sf to iMinorVersion
97917>>>            Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
97918>>>            Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
97919>>>            Case Begin
97919>>>                Case (iRetval = cx_RegKeyAlreadyExist)
97921>>>                    Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
97922>>>                    Break
97923>>>                Case (iRetval = cx_RegKeyCreated)
97926>>>                    Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
97927>>>                    Break
97928>>>                Case (iRetval = cx_RegkeyFailed)
97931>>>                    Move "Failed. Could not create the registry key for adding the program to the DataFlex Studio's Tools menu." to sText
97932>>>                    Break
97933>>>                Case (iRetval = cx_RegKeyVDFKeyDoesNotExist)
97936>>>                    Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
97937>>>                    Break
97938>>>                Case (iRetval = CX_InstalledOkVdfUnder16)
97941>>>                    Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed for an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
97942>>>                    Break
97943>>>            Case End
97943>>>
97943>>>            Send Info_Box sText
97944>>>        End_Procedure
97945>>>    End_Object
97946>>>
97946>>>    Object oCancel_Btn is a Button
97948>>>        Set Label to C_$Close
97949>>>        Set Location to 59 264
97950>>>        Set peAnchors to anBottomRight
97951>>>
97951>>>        Procedure OnClick
97954>>>            Send Close_Panel
97955>>>        End_Procedure
97956>>>
97956>>>    End_Object
97957>>>
97957>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
97960>>>        Boolean bOk bExists bOpen
97960>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath
97960>>>        Handle hoReg hoArray
97960>>>        Integer i iItems iCreated iRetval
97960>>>
97960>>>        Move False to bOk
97961>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
97962>>>        If (sStudioVersion > "17.1") Begin
97964>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
97965>>>        End
97965>>>>
97965>>>
97965>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
97966>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
97967>>>        Get vFolderFormat sProgramPath to sProgramPath
97968>>>        Get psProduct     of (phoWorkspace(ghoApplication)) to sProduct
97969>>>        Get Module_Name to sProgram
97970>>>        Get Create (RefClass(cRegistry)) to hoReg
97971>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
97972>>>
97972>>>        // First check if the VDF version is installed
97972>>>        Get KeyExists of hoReg sStudioPath to bExists
97973>>>        If (bExists = False) Begin
97975>>>            Send Destroy of hoReg
97976>>>            Function_Return cx_RegKeyVDFKeyDoesNotExist
97977>>>        End
97977>>>>
97977>>>
97977>>>        // Then check if any tools have been installed in the Tools Menu.
97977>>>        // If no tools created yet, create the Tools registry key.
97977>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
97978>>>        Get KeyExists of hoReg sStudioPath to bExists
97979>>>        If (bExists = False) Begin
97981>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
97982>>>            Get CreateKey of hoReg sStudioPath to iCreated
97983>>>            If (iCreated <> 0) Begin
97985>>>                Move cx_RegkeyFailed to iRetval
97986>>>            End
97986>>>>
97986>>>            Else Begin
97987>>>                Move True to bExists
97988>>>            End
97988>>>>
97988>>>        End
97988>>>>
97988>>>
97988>>>        If (bExists = True) Begin
97990>>>            Get OpenKey of hoReg sStudioPath to bOk
97991>>>            If (bOk = True) Begin
97993>>>                Get Create (RefClass(Array)) to hoArray
97994>>>                Get GetSubkeys of hoReg hoArray to iItems
97995>>>                Decrement iItems
97996>>>                Move False to bExists
97997>>>                Set pfAccessRights of hoReg to KEY_READ
97998>>>                // Check if the key already exists:
97998>>>                For i from 0 to iItems
98004>>>>
98004>>>                    Get Value of hoArray i to sKey
98005>>>                    Move (sStudioPath + "\" + sKey) to sKey
98006>>>                    Get OpenKey of hoReg sKey to bOpen
98007>>>                    If (bOpen = True) Begin
98009>>>                        Get ReadString of hoReg CS_Name to sValue
98010>>>                        If (sValue = sProduct) Begin
98012>>>                            Move True to bExists
98013>>>                        End
98013>>>>
98013>>>                    End
98013>>>>
98013>>>                Loop
98014>>>>
98014>>>                Send Destroy of hoArray
98015>>>                If (bExists = False) Begin
98017>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
98018>>>                    // We need to create the next key number:
98018>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
98018>>>                    Increment iItems
98019>>>                    Increment iItems
98020>>>                    Get CreateKey of hoReg (sStudioPath + "\" + String(iItems)) to iCreated
98021>>>                    If (iCreated = 0) Begin
98023>>>                        Send WriteString of hoReg CS_Name sProduct
98024>>>                        // From DataFlex 16 and up the params for the Studio's Tools menu changed slightly:
98024>>>                        If (sStudioVersion >= "16.0") Begin
98026>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
98027>>>                            Send WriteString of hoReg CS_CommandLine (psTag(Self))
98028>>>                        End
98028>>>>
98028>>>                        Else Begin
98029>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * psTag(Self))
98030>>>                            Move CX_InstalledOkVdfUnder16 to iRetval
98031>>>                        End
98031>>>>
98031>>>                        Send WriteDword  of hoReg CS_Separator 1
98032>>>                        Move cx_RegKeyCreated to iRetval
98033>>>                    End
98033>>>>
98033>>>                    Else Begin
98034>>>                        Move cx_RegkeyFailed to iRetval
98035>>>                    End
98035>>>>
98035>>>                End
98035>>>>
98035>>>                Else Begin
98036>>>                    Move cx_RegKeyAlreadyExist to iRetval
98037>>>                End
98037>>>>
98037>>>                Send CloseKey of hoReg
98038>>>            End
98038>>>>
98038>>>        End
98038>>>>
98038>>>
98038>>>        Send Destroy of hoReg
98039>>>        Function_Return iRetval
98040>>>    End_Function
98041>>>
98041>>>    Procedure Page Integer iPageObject
98044>>>        Forward Send Page iPageObject
98046>>>        Set Icon to "ActionAddStudio1.ico"
98047>>>    End_Procedure
98048>>>
98048>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
98049>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
98050>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
98051>>>End_Object
98052>        Use CreateDatabase.dg
98052>
98052>        Procedure Activate_About
98055>            Send DoAbout "" "" ("Copyright 2016-2023" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "SQLConnections.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
98056>        End_Procedure
98057>
98057>    End_Object
98058>
98058>    Procedure ShowProgramHelp
98061>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
98062>    End_Procedure
98063>
98063>    On_Key Key_F1 Send ShowProgramHelp
98064>End_Object
98065>
98065>// Check if a SQLConnections.ini file exists;
98065>// else the user needs to setup a Connection ID and login info & save the new connection file.
98065>Procedure CheckIfConnectionExists
98067>    Boolean bIniFileExists
98067>    Get pbIniFileExists of ghoApplication to bIniFileExists
98068>    If (bIniFileExists = False) Begin
98070>        Send ConnectionDoesNotExist of (oSQLMaintainConnection(Client_Id(phoMainPanel(ghoApplication))))
98071>    End
98071>End_Procedure
98072>Send CheckIfConnectionExists
98073>
98073>Start_UI
98074>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 52234
Total Resources: 6
Total Commands : 98073
Total Windows  : 0
Total Pages    : 0
Static Data    : 771693
Message area   : 632931
Total Blocks   : 35300
