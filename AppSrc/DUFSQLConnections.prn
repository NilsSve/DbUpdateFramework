Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFSQLConnections.src
Memory Available: 2147483646
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files\DataFlex 23.0\Pkg\dfallent.pkd)
73414>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJStandardCommandBarSystem.pkg)
73414>>>// these are all the packages used in a standard MDI menubar/toolbar system
73414>>>
73414>>>Use cCJCommandBarSystem.pkg
73414>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJStandardMenuItemClasses.pkg)
73414>>>>>Use Dfpanel.pkg
73414>>>>>Use cCJCommandBarSystem.pkg
73414>>>>>Use LanguageText.pkg
73414>>>>>
73414>>>>>
73414>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73415>>>>>    
73415>>>>>    Procedure Construct_Object
73417>>>>>        Forward Send Construct_Object
73419>>>>>        Set psCaption   to C_$CaptionUndo
73420>>>>>        Set psToolTip to C_$ToolTipUndo
73421>>>>>        Set psDescription to C_$DescUndo
73422>>>>>        Set psImage to "ActionUndo.ico"
73423>>>>>        Set pbActiveUpdate to True
73424>>>>>        Set psCategory to C_$CategoryEdit
73425>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73426>>>>>    End_Procedure
73427>>>>>    
73427>>>>>    Procedure OnExecute Variant vCommandBarControl
73429>>>>>        Send Undo of (focus(Self))
73430>>>>>    End_Procedure
73431>>>>>    
73431>>>>>    Function IsEnabled Returns Boolean
73433>>>>>        Boolean bEnabled
73433>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73434>>>>>        Function_Return bEnabled
73435>>>>>    End_Function
73436>>>>>    
73436>>>>>End_Class
73437>>>>>
73437>>>>>
73437>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73438>>>>>    
73438>>>>>    Procedure Construct_Object
73440>>>>>        Forward Send Construct_Object
73442>>>>>        Set psCaption   to C_$CaptionDelete
73443>>>>>        Set psToolTip to C_$ToolTipDelete
73444>>>>>        Set psDescription to C_$DescDelete
73445>>>>>        Set psImage to "actionDelete.ico"
73446>>>>>        Set psShortcut to C_$Key_Delete
73447>>>>>        Set pbActiveUpdate to True
73448>>>>>        Set psCategory to C_$CategoryEdit
73449>>>>>    End_Procedure
73450>>>>>    
73450>>>>>    
73450>>>>>    Procedure OnExecute Variant vCommandBarControl
73452>>>>>        Send Delete of (focus(Self))
73453>>>>>    End_Procedure
73454>>>>>    
73454>>>>>    Function IsEnabled Returns Boolean
73456>>>>>        Boolean bEnabled
73456>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73457>>>>>        Function_Return bEnabled
73458>>>>>    End_Function
73459>>>>>    
73459>>>>>End_Class
73460>>>>>
73460>>>>>
73460>>>>>Class cCJCutMenuItem is a cCJMenuItem
73461>>>>>    
73461>>>>>    Procedure Construct_Object
73463>>>>>        Forward Send Construct_Object
73465>>>>>        Set psCaption   to C_$CaptionCut
73466>>>>>        Set psToolTip to C_$TooltipCut
73467>>>>>        Set psDescription to C_$DescCut
73468>>>>>        Set psImage to "actionCut.ico"
73469>>>>>        Set psShortcut to C_$Key_Ctrl_X
73470>>>>>        Set pbActiveUpdate to True
73471>>>>>        Set psCategory to C_$CategoryEdit
73472>>>>>    End_Procedure
73473>>>>>    
73473>>>>>    
73473>>>>>    Procedure OnExecute Variant vCommandBarControl
73475>>>>>        Send Cut of (focus(Self))
73476>>>>>    End_Procedure
73477>>>>>    
73477>>>>>    Function IsEnabled Returns Boolean
73479>>>>>        Boolean bEnabled
73479>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73480>>>>>        Function_Return bEnabled
73481>>>>>    End_Function
73482>>>>>    
73482>>>>>End_Class
73483>>>>>
73483>>>>>
73483>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73484>>>>>    
73484>>>>>    Procedure Construct_Object
73486>>>>>        Forward Send Construct_Object
73488>>>>>        Set psCaption   to C_$CaptionCopy
73489>>>>>        Set psToolTip to C_$ToolTipCopy
73490>>>>>        Set psDescription to C_$DescCopy
73491>>>>>        Set psImage to "actionCopy.ico"
73492>>>>>        Set psShortcut to C_$Key_Ctrl_C
73493>>>>>        Set pbActiveUpdate to True
73494>>>>>        Set psCategory to C_$CategoryEdit
73495>>>>>    End_Procedure
73496>>>>>    
73496>>>>>    
73496>>>>>    Procedure OnExecute Variant vCommandBarControl
73498>>>>>        Send Copy of (focus(Self))
73499>>>>>    End_Procedure
73500>>>>>    
73500>>>>>    Function IsEnabled Returns Boolean
73502>>>>>        Boolean bEnabled
73502>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73503>>>>>        Function_Return bEnabled
73504>>>>>    End_Function
73505>>>>>    
73505>>>>>End_Class
73506>>>>>
73506>>>>>
73506>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73507>>>>>    
73507>>>>>    Procedure Construct_Object
73509>>>>>        Forward Send Construct_Object
73511>>>>>        Set psCaption   to C_$CaptionPaste
73512>>>>>        Set psToolTip to C_$ToolTipPaste
73513>>>>>        Set psDescription to C_$DescPaste
73514>>>>>        Set psImage to "actionPaste.ico"
73515>>>>>        Set pbActiveUpdate to True
73516>>>>>        Set psShortcut to C_$Key_Ctrl_V
73517>>>>>        Set psCategory to C_$CategoryEdit
73518>>>>>    End_Procedure
73519>>>>>    
73519>>>>>    
73519>>>>>    Procedure OnExecute Variant vCommandBarControl
73521>>>>>        Send Paste of (focus(Self))
73522>>>>>    End_Procedure
73523>>>>>    
73523>>>>>    Function IsEnabled Returns Boolean
73525>>>>>        Boolean bEnabled
73525>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73526>>>>>        Function_Return bEnabled
73527>>>>>    End_Function
73528>>>>>    
73528>>>>>End_Class
73529>>>>>
73529>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73530>>>>>    
73530>>>>>    Procedure Construct_Object
73532>>>>>        Forward Send Construct_Object
73534>>>>>        Set psCaption   to C_$CaptionSelectAll
73535>>>>>        Set psToolTip to C_$ToolTipSelectAll
73536>>>>>        Set psDescription to C_$DescSelectAll
73537>>>>>        Set pbActiveUpdate to True
73538>>>>>        Set psShortcut to C_$Key_Ctrl_A
73539>>>>>        Set psCategory to C_$CategoryEdit
73540>>>>>    End_Procedure
73541>>>>>    
73541>>>>>    
73541>>>>>    Procedure OnExecute Variant vCommandBarControl
73543>>>>>        Send Select_All of (focus(Self))
73544>>>>>    End_Procedure
73545>>>>>    
73545>>>>>    Function IsEnabled Returns Boolean
73547>>>>>        Boolean bEnabled
73547>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73548>>>>>        Function_Return bEnabled
73549>>>>>    End_Function
73550>>>>>    
73550>>>>>End_Class
73551>>>>>
73551>>>>>
73551>>>>>Class cCJExitMenuItem is a cCJMenuItem
73552>>>>>    
73552>>>>>    Procedure Construct_Object
73554>>>>>        Forward Send Construct_Object
73556>>>>>        Set psCaption to C_$CaptionExit
73557>>>>>        Set psToolTip to C_$ToolTipExit
73558>>>>>        Set psDescription to C_$ToolTipExit
73559>>>>>        Set psShortcut to C_$Key_Alt_F4
73560>>>>>        Set psCategory to C_$CategoryFile
73561>>>>>    End_Procedure
73562>>>>>    
73562>>>>>    Procedure OnExecute Variant vCommandBarControl
73564>>>>>        Send Exit_Application of Desktop
73565>>>>>    End_Procedure
73566>>>>>    
73566>>>>>End_Class
73567>>>>>
73567>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73568>>>>>    
73568>>>>>    Procedure Construct_Object
73570>>>>>        Forward Send Construct_Object
73572>>>>>        Set psCaption to C_$CaptionHelp
73573>>>>>        Set psDescription to C_$ToolTipHelp
73574>>>>>        Set psToolTip to C_$DescHelp
73575>>>>>        Set psImage to "ActionHelp.ico"
73576>>>>>        Set psShortcut to "F1"
73577>>>>>        Set psCategory to C_$CategoryHelp
73578>>>>>    End_Procedure
73579>>>>>    
73579>>>>>    Procedure OnExecute Variant vCommandBarControl
73581>>>>>        Send Help of (Focus(Self))
73582>>>>>    End_Procedure
73583>>>>>    
73583>>>>>End_Class
73584>>>>>
73584>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73585>>>>>    
73585>>>>>    Procedure Construct_Object
73587>>>>>        Forward Send Construct_Object
73589>>>>>        Set psCaption to C_$CaptionAddStatusbar
73590>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73591>>>>>        Set psDescription to  C_$DescAddStatusbar
73592>>>>>        Set psCategory to C_$CategoryWindow
73593>>>>>    End_Procedure
73594>>>>>    
73594>>>>>    Procedure OnExecute Variant vCommandBarControl
73596>>>>>        Handle hoCommandBars hoClientArea
73596>>>>>        Get CommandBarSystemObject to hoCommandBars
73597>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73598>>>>>        If hoClientArea Begin
73600>>>>>            // the clientarea's parent panel has message
73600>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73601>>>>>        End
73601>>>>>>
73601>>>>>    End_Procedure
73602>>>>>    
73602>>>>>    Function IsChecked Returns Boolean
73604>>>>>        Boolean bOn
73604>>>>>        Handle hoCommandBars hoClientArea
73604>>>>>        Get CommandBarSystemObject to hoCommandBars
73605>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73606>>>>>        If hoClientArea Begin
73608>>>>>            // the clientarea's parent panel has message
73608>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73609>>>>>        End
73609>>>>>>
73609>>>>>        Function_Return bOn
73610>>>>>    End_Function
73611>>>>>End_Class
73612>>>>>
73612>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73613>>>>>    
73613>>>>>    Procedure Construct_Object
73615>>>>>        Forward Send Construct_Object
73617>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73618>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73619>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73620>>>>>        Set psCategory to C_$CategoryWindow
73621>>>>>    End_Procedure
73622>>>>>    
73622>>>>>    Procedure OnExecute Variant vCommandBarControl
73624>>>>>        Handle hoCommandBars hoClientArea
73624>>>>>        Get CommandBarSystemObject to hoCommandBars
73625>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73626>>>>>        If hoClientArea Begin
73628>>>>>            // the clientarea's parent panel has message
73628>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73629>>>>>        End
73629>>>>>>
73629>>>>>    End_Procedure
73630>>>>>    
73630>>>>>    Function IsChecked Returns Boolean
73632>>>>>        Boolean bOn
73632>>>>>        Handle hoCommandBars hoClientArea
73632>>>>>        Get CommandBarSystemObject to hoCommandBars
73633>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73634>>>>>        If hoClientArea Begin
73636>>>>>            // the clientarea's parent panel has message
73636>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73637>>>>>        End
73637>>>>>>
73637>>>>>        Function_Return bOn
73638>>>>>    End_Function
73639>>>>>End_Class
73640>>>>>
73640>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73641>>>>>    
73641>>>>>    Procedure Construct_Object
73643>>>>>        Forward Send Construct_Object
73645>>>>>        Set psCaption to C_$CaptionRestoreMenus
73646>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73647>>>>>        Set psDescription to C_$DescRestoreMenus
73648>>>>>        Set psCategory to C_$CategoryWindow
73649>>>>>    End_Procedure
73650>>>>>    
73650>>>>>    Procedure OnExecute Variant vCommandBarControl
73652>>>>>        Handle hoCommandBars
73652>>>>>        Get CommandBarSystemObject to hoCommandBars
73653>>>>>        Send RestoreLayout of hoCommandBars
73654>>>>>    End_Procedure
73655>>>>>    
73655>>>>>End_Class
73656>>>>>
73656>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73657>>>>>    
73657>>>>>    Procedure Construct_Object
73659>>>>>        Forward Send Construct_Object
73661>>>>>        Set psCaption to C_$CaptionCascade
73662>>>>>        Set psToolTip to C_$ToolTipCascade
73663>>>>>        Set psDescription to  C_$DescCascade
73664>>>>>        Set psImage to "ActionCascade.ico"
73665>>>>>        Set psCategory to C_$CategoryWindow
73666>>>>>    End_Procedure
73667>>>>>    
73667>>>>>    Procedure OnExecute Variant vCommandBarControl
73669>>>>>        Handle hoCommandBars hoClientArea
73669>>>>>        Get CommandBarSystemObject to hoCommandBars
73670>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73671>>>>>        If hoClientArea Begin
73673>>>>>            Send Cascade_Windows of hoClientArea
73674>>>>>        End
73674>>>>>>
73674>>>>>    End_Procedure
73675>>>>>End_Class
73676>>>>>
73676>>>>>Class cCJTileHorizontally is a cCJMenuItem
73677>>>>>    
73677>>>>>    Procedure Construct_Object
73679>>>>>        Forward Send Construct_Object
73681>>>>>        Set psCaption to C_$CaptionTileHorizontally
73682>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73683>>>>>        Set psDescription to  C_$DescTileHorizontally
73684>>>>>        Set psImage to "ActionTileHorizontally.ico"
73685>>>>>        Set psCategory to C_$CategoryWindow
73686>>>>>    End_Procedure
73687>>>>>    
73687>>>>>    Procedure OnExecute Variant vCommandBarControl
73689>>>>>        Handle hoCommandBars hoClientArea
73689>>>>>        Get CommandBarSystemObject to hoCommandBars
73690>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73691>>>>>        If hoClientArea Begin
73693>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73694>>>>>        End
73694>>>>>>
73694>>>>>    End_Procedure
73695>>>>>End_Class
73696>>>>>
73696>>>>>Class cCJTileVertically is a cCJMenuItem
73697>>>>>    
73697>>>>>    Procedure Construct_Object
73699>>>>>        Forward Send Construct_Object
73701>>>>>        Set psCaption to C_$CaptionTileVertically
73702>>>>>        Set psToolTip to C_$ToolTipTileVertically
73703>>>>>        Set psDescription to  C_$DescTileVertically
73704>>>>>        Set psImage to "ActionTileVertically.ico"
73705>>>>>        Set psCategory to C_$CategoryWindow
73706>>>>>    End_Procedure
73707>>>>>    
73707>>>>>    Procedure OnExecute Variant vCommandBarControl
73709>>>>>        Handle hoCommandBars hoClientArea
73709>>>>>        Get CommandBarSystemObject to hoCommandBars
73710>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73711>>>>>        If hoClientArea Begin
73713>>>>>            Send Tile_Windows_Vertical of hoClientArea
73714>>>>>        End
73714>>>>>>
73714>>>>>    End_Procedure
73715>>>>>End_Class
73716>>>>>
73716>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73717>>>>>    
73717>>>>>    Procedure Construct_Object
73719>>>>>        Forward Send Construct_Object
73721>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73722>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73723>>>>>        Set psDescription to  C_$DescMinimizeWindows
73724>>>>>        Set psCategory to C_$CategoryWindow
73725>>>>>    End_Procedure
73726>>>>>    
73726>>>>>    Procedure OnExecute Variant vCommandBarControl
73728>>>>>        Handle hoCommandBars hoClientArea
73728>>>>>        Get CommandBarSystemObject to hoCommandBars
73729>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73730>>>>>        If hoClientArea Begin
73732>>>>>            // the clientarea's parent panel has message
73732>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73733>>>>>        End
73733>>>>>>
73733>>>>>    End_Procedure
73734>>>>>End_Class
73735>>>>>
73735>>>>>
73735>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73736>>>>>    
73736>>>>>    Procedure Construct_Object
73738>>>>>        Forward Send Construct_Object
73740>>>>>        Set psCaption to C_$CaptionRestoreWindows
73741>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73742>>>>>        Set psDescription to  C_$DescRestoreWindows
73743>>>>>        Set psCategory to C_$CategoryWindow
73744>>>>>    End_Procedure
73745>>>>>    
73745>>>>>    Procedure OnExecute Variant vCommandBarControl
73747>>>>>        Handle hoCommandBars hoClientArea
73747>>>>>        Get CommandBarSystemObject to hoCommandBars
73748>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73749>>>>>        If hoClientArea Begin
73751>>>>>            // the clientarea's parent panel has message
73751>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73752>>>>>        End
73752>>>>>>
73752>>>>>    End_Procedure
73753>>>>>End_Class
73754>>>>>
73754>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73755>>>>>    
73755>>>>>    Procedure Construct_Object
73757>>>>>        Forward Send Construct_Object
73759>>>>>        Set psCaption to C_$CaptionArrangeIcons
73760>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73761>>>>>        Set psDescription to  C_$DescArrangeIcons
73762>>>>>        Set psCategory to C_$CategoryWindow
73763>>>>>    End_Procedure
73764>>>>>    
73764>>>>>    Procedure OnExecute Variant vCommandBarControl
73766>>>>>        Handle hoCommandBars hoClientArea
73766>>>>>        Get CommandBarSystemObject to hoCommandBars
73767>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73768>>>>>        If hoClientArea Begin
73770>>>>>            Send Arrange_Icons of hoClientArea
73771>>>>>        End
73771>>>>>>
73771>>>>>    End_Procedure
73772>>>>>    
73772>>>>>End_Class
73773>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJAboutMenuItem.pkg)
73773>>>>>Use cCJCommandBarSystem.pkg
73773>>>>>Use LanguageText.pkg
73773>>>>>
73773>>>>>// It is expected that if you use this class that you provide an about object that is
73773>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73773>>>>>// because you may wish to create your own custom about package.
73773>>>>>
73773>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73774>>>>>
73774>>>>>    Procedure Construct_Object
73776>>>>>        Forward Send Construct_Object
73778>>>>>        Set psCaption to C_$CaptionAbout
73779>>>>>        Set psDescription to C_$ToolTipAbout
73780>>>>>        Set psToolTip to C_$DescAbout
73781>>>>>        Set psImage to "ActionAbout.ico"
73782>>>>>        Set psCategory to C_$CategoryHelp
73783>>>>>    End_Procedure
73784>>>>>    
73784>>>>>    Procedure OnExecute Variant vCommandBarControl
73786>>>>>        Handle hoCommandBars hoClientArea
73786>>>>>        Get CommandBarSystemObject to hoCommandBars
73787>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73788>>>>>        If hoClientArea Begin
73790>>>>>            Send Activate_About of hoClientArea
73791>>>>>        End
73791>>>>>>
73791>>>>>    End_Procedure
73792>>>>>
73792>>>>>End_Class
73793>>>>>
73793>>>>>
73793>>>Use cCJDeoMenuItemClasses.pkg
73793>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJMDIWindowsMenuItem.pkg)
73793>>>>>Use cCJCommandBarSystem.pkg
73793>>>>>
73793>>>>>Register_Function Client_ID Returns Integer
73793>>>>>
73793>>>>>// only used by cCJMDIWIndowsMenuItem
73793>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73794>>>>>    
73794>>>>>    Procedure Construct_Object
73796>>>>>        Forward Send Construct_Object
73798>>>>>        Property Handle phWindow 0 // object id of view
73799>>>>>        Set pbControlFlagNoMovable to True
73800>>>>>        Set pbActiveUpdate to True
73801>>>>>    End_Procedure
73802>>>>>    
73802>>>>>    Procedure OnExecute Variant vCommandBarControl
73804>>>>>        Handle hWindow
73804>>>>>        Get phWindow to hWindow
73805>>>>>        Send Activate_View of hWindow
73806>>>>>    End_Procedure
73807>>>>>    
73807>>>>>End_Class
73808>>>>>
73808>>>>>
73808>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73809>>>>>    
73809>>>>>    Procedure Construct_Object
73811>>>>>        Forward Send Construct_Object
73813>>>>>        Property Handle[] phArrayOfWindows
73814>>>>>        Set peControlType to xtpControlPopup
73815>>>>>        Set psCategory to C_$CategoryWindow
73816>>>>>    End_Procedure
73817>>>>>    
73817>>>>>    // This adds MDI windows to the existing menu items.
73817>>>>>    // This removes any existing windows menus and always adds a new set to the end
73817>>>>>    
73817>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73819>>>>>        Handle  hClientArea hView
73819>>>>>        String  sLabel
73819>>>>>        Integer i iWindows
73819>>>>>        Handle[] hArrayOfWindows
73820>>>>>        Variant vItem
73820>>>>>        
73820>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73820>>>>>        // also assume that destroying an action removes all menu instances of that action
73820>>>>>        Get phArrayOfWindows to hArrayOfWindows
73821>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73822>>>>>        For i from 0 to (iWindows-1)
73828>>>>>>
73828>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73829>>>>>        Loop
73830>>>>>>
73830>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73831>>>>>        
73831>>>>>        // Add all views to this menu. Create the action and add the item
73831>>>>>        Move 0 to i
73832>>>>>        Get Client_Id to hClientArea // object id of client area
73833>>>>>        If (hClientArea > 0) Begin
73835>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73836>>>>>            While (hView <> 0)
73840>>>>>                If (Active_State(hView)) Begin
73842>>>>>                    // create the action
73842>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73843>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73844>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73845>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73846>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73848>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73849>>>>>                    End
73849>>>>>>
73849>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73850>>>>>                    If (i=0) Begin
73852>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73853>>>>>                    End
73853>>>>>>
73853>>>>>                    // Create a menu item for this action
73853>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73854>>>>>                    Increment i
73855>>>>>                End
73855>>>>>>
73855>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73856>>>>>            Loop
73857>>>>>>
73857>>>>>        End
73857>>>>>>
73857>>>>>        
73857>>>>>        Set phArrayOfWindows to hArrayOfWindows
73858>>>>>        
73858>>>>>    End_Procedure
73859>>>>>    
73859>>>>>End_Class
73860>Use vWin32fh.pkg
Including file: vwin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fh.pkg)
73860>>>// This code is part of VDF GUIdance
73860>>>// Visit us @ http://www.vdf-guidance.com
73860>>>// e-Mail us @ info@vdf-guidance.com
73860>>>// VDF GUIdance is a mutual project of
73860>>>// Frank Vandervelpen - Vandervelpen Systems and
73860>>>// Wil van Antwerpen  - Antwise Solutions
73860>>>// All software source code should be used <<AS IS>> without any warranty.
73860>>>//
73860>>>//
73860>>>// *** Windows 32bit file handling wrapper class ***
73860>>>//
73860>>>
73860>>>
73860>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
73860>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\cvFileDialogs.pkg)
73860>>>>>//***************************************************************************
73860>>>>>//*
73860>>>>>//* Class:        cvSaveAsDialog
73860>>>>>//* Package Name: cvFileDialogs.pkg
73860>>>>>//*
73860>>>>>//***************************************************************************
73860>>>>>
73860>>>>>Use File_dlg.pkg
73860>>>>>
73860>>>>>// *WvA: 13-01-1999 Created
73860>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
73860>>>>>// This function opens the Windows standard file open dialog and returns the selected
73860>>>>>// file_name.
73860>>>>>Class cvSelectFile_Dialog is an OpenDialog
73861>>>>>
73861>>>>>    Procedure Construct_Object Integer iImage_Id
73863>>>>>        Forward Send Construct_Object iImage_Id
73865>>>>>        Set HideReadOnly_State to True
73866>>>>>    End_Procedure
73867>>>>>
73867>>>>>    Function SelectedFileName Returns String
73869>>>>>        String sFileName
73869>>>>>        Move "" to sFileName
73870>>>>>        If (Show_Dialog(Self)) Begin
73872>>>>>            Move (RTrim(File_Name(Self))) to sFileName
73873>>>>>        End
73873>>>>>>
73873>>>>>        Function_Return sFileName
73874>>>>>    End_Function
73875>>>>>End_Class
73876>>>>>
73876>>>>>// *WvA: 13-01-1999 Created
73876>>>>>// This function opens the Windows standard file open dialog and returns the selected
73876>>>>>// file_name. Returns '' if the user didn't make a selection.
73876>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
73876>>>>>//                   file-open dialog
73876>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
73878>>>>>    String sSelectedFile
73878>>>>>    Integer hoOpenFileDialog
73878>>>>>
73878>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
73880>>>>>
73880>>>>>        Set Dialog_Caption    to sCaptionText
73881>>>>>        Set Filter_String     to sSupportedFileTypes
73882>>>>>        Set Initial_Folder    to sInitialFolder
73883>>>>>
73883>>>>>        Move Self       to hoOpenFileDialog
73884>>>>>    End_Object
73885>>>>>
73885>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
73886>>>>>    Send Destroy_Object to hoOpenFileDialog
73887>>>>>    Function_Return sSelectedFile
73888>>>>>End_Function
73889>>>>>
73889>>>>>Class cvSaveAsDialog is a SaveAsDialog
73890>>>>>
73890>>>>>    Procedure Construct_Object
73892>>>>>        Forward Send Construct_Object
73894>>>>>        Set HideReadOnly_State to True
73895>>>>>    End_Procedure
73896>>>>>
73896>>>>>    Function SelectedFileName Returns String
73898>>>>>        String sFileName
73898>>>>>        Move "" to sFileName
73899>>>>>        If (Show_Dialog(Self)) Begin
73901>>>>>            Move (RTrim(File_Name(Self))) to sFileName
73902>>>>>        End
73902>>>>>>
73902>>>>>        Function_Return sFileName
73903>>>>>    End_Function
73904>>>>>
73904>>>>>End_Class
73905>>>>>
73905>>>>>// Added optional default filename as suggested by Nils
73905>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
73907>>>>>    String sSelectedFile
73907>>>>>    Integer hoDialog
73907>>>>>
73907>>>>>    Move "" to sSelectedFile
73908>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
73909>>>>>    If (hoDialog) Begin
73911>>>>>    //Set NoChangeDir_State Of hoDialog To True
73911>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
73912>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
73913>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
73914>>>>>        If (Num_Arguments = 4) Begin
73916>>>>>            Set File_Title        of hoDialog to sDefaultFileName
73917>>>>>        End
73917>>>>>>
73917>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
73918>>>>>        Send Destroy of hoDialog
73919>>>>>    End
73919>>>>>>
73919>>>>>    Function_Return sSelectedFile
73920>>>>>End_Function
73921>>>Use Seq_chnl.pkg
73921>>>
73921>>>Use windows.pkg
73921>>>Use Dll.pkg
73921>>>
73921>>>Use vWin32fhW.pkg     // WinAPI Unicode version
Including file: vwin32fhW.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fhW.pkg)
73921>>>>>// This code is part of VDF GUIdance
73921>>>>>// Visit us @ http://www.vdf-guidance.com
73921>>>>>// e-Mail us @ info@vdf-guidance.com
73921>>>>>// VDF GUIdance is a mutual project of
73921>>>>>// Frank Vandervelpen - Vandervelpen Systems and
73921>>>>>// Wil van Antwerpen  - Antwise Solutions
73921>>>>>// All software source code should be used <<AS IS>> without any warranty.
73921>>>>>//
73921>>>>>//
73921>>>>>// *** Windows 32bit file handling wrapper class ***
73921>>>>>// Unicode variant
73921>>>>>
73921>>>>>Use vWin32fhW.h       // Header file with WinAPI Unicode declarations
Including file: vwin32fhW.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fhW.h)
73921>>>>>>>//TH-Header
73921>>>>>>>//*****************************************************************************************
73921>>>>>>>// Copyright (c)  2004 KURANT Project
73921>>>>>>>// All rights reserved.
73921>>>>>>>//
73921>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
73921>>>>>>>// $ProjectName : Windows 32 bits file handling
73921>>>>>>>// $Authors     : Wil van Antwerpen
73921>>>>>>>// $Created     : 19.02.2004  19:25
73921>>>>>>>// $Type        : BSD (as in do with it whatever you like)
73921>>>>>>>//
73921>>>>>>>// Contents:
73921>>>>>>>//  This file contains the Windows API external function call definitions and
73921>>>>>>>//  constants as they are used in the vWin32fh package.
73921>>>>>>>//*****************************************************************************************
73921>>>>>>>//TH-RevisionStart
73921>>>>>>>//TH-RevisionEnd
73921>>>>>>>
73921>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
73921>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
73921>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
73921>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
73921>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
73921>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
73921>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
73921>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
73921>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
73921>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
73921>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
73921>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
73921>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
73921>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
73921>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
73921>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
73921>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
73921>>>>>>>
73921>>>>>>>
73921>>>>>>>Define vMax_Path     For |CI260
73921>>>>>>>Define vMinChar      For |CI$80
73921>>>>>>>Define vMaxChar      For |CI$7F
73921>>>>>>>Define vMinShort     For |CI$8000
73921>>>>>>>Define vMaxShort     For |CI$7FFF
73921>>>>>>>Define vMinLong      For |CI$80000000
73921>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
73921>>>>>>>Define vMaxByte      For |CI$FF
73921>>>>>>>Define vMaxWord      For |CI$FFFF
73921>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
73921>>>>>>>
73921>>>>>>>
73921>>>>>>>
73921>>>>>>>// For FindFirstFile
73921>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
73921>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
73921>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
73921>>>>>>>
73921>>>>>>>// The defines below can be used to find out what kind of error has occurred if
73921>>>>>>>// the API-call ShellExecute is used.
73921>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
73921>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
73921>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
73921>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
73921>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
73921>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
73921>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
73921>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
73921>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
73921>>>>>>>Define vSE_ERR_FNF             For |CI0002
73921>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
73921>>>>>>>Define vSE_ERR_OOM             For |CI0008
73921>>>>>>>Define vSE_ERR_PNF             For |CI0003
73921>>>>>>>Define vSE_ERR_SHARE           For |CI0026
73921>>>>>>>
73921>>>>>>>
73921>>>>>>>// C-Structure
73921>>>>>>>//typedef struct _browseinfo {
73921>>>>>>>//    HWND hwndOwner;
73921>>>>>>>//    LPCITEMIDLIST pidlRoot;
73921>>>>>>>//    LPSTR pszDisplayName;
73921>>>>>>>//    LPCSTR lpszTitle;
73921>>>>>>>//    UINT ulFlags;
73921>>>>>>>//    BFFCALLBACK lpfn;
73921>>>>>>>//    LPARAM lParam;
73921>>>>>>>//    int iImage;
73921>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
73921>>>>>>>
73921>>>>>>>//declare C structure struct_browseinfo
73921>>>>>>>//as documented in MSDN under Windows Shell API
73921>>>>>>>Struct tvBrowseInfo
73921>>>>>>>  Handle    hWndOwner
73921>>>>>>>  Pointer   pIDLRoot
73921>>>>>>>  Pointer   pszDisplayName
73921>>>>>>>  Pointer   lpszTitle
73921>>>>>>>  DWord     ulFlags
73921>>>>>>>  Pointer   lpfnCallback
73921>>>>>>>  LongPtr   lParam
73921>>>>>>>  DWord     iImage
73921>>>>>>>End_Struct // tvBrowseInfo
73921>>>>>>>
73921>>>>>>>// Browsing for directory.
73921>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
73921>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
73921>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
73921>>>>>>>                                            // The callback function can set the status text by
73921>>>>>>>                                            // sending messages to the dialog box.
73921>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
73921>>>>>>>
73921>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
73921>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
73921>>>>>>>
73921>>>>>>>// message from browser
73921>>>>>>>//Define BFFM_INITIALIZED        1
73921>>>>>>>//Define BFFM_SELCHANGED         2
73921>>>>>>>
73921>>>>>>>// messages to browser
73921>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
73921>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
73921>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
73921>>>>>>>
73921>>>>>>>
73921>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolderW" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
73922>>>>>>>
73922>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDListW" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
73923>>>>>>>
73923>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
73924>>>>>>>
73924>>>>>>>
73924>>>>>>>
73924>>>>>>>
73924>>>>>>>Struct tvSecurity_attributes
73924>>>>>>>  DWord   nLength
73924>>>>>>>  Pointer lpDescriptor
73924>>>>>>>  Integer bInheritHandle
73924>>>>>>>End_Struct // tvSecurity_attributes
73924>>>>>>>
73924>>>>>>>//nLength:
73924>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
73924>>>>>>>// SECURITY_ATTRIBUTES structure.
73924>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
73924>>>>>>>// value of the nLength member. However, an application should still set it properly.
73924>>>>>>>// That ensures current, future, and cross-platform compatibility.
73924>>>>>>>//
73924>>>>>>>//lpSecurityDescriptor:
73924>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
73924>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
73924>>>>>>>// descriptor of the calling process.
73924>>>>>>>//
73924>>>>>>>//bInheritHandle:
73924>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
73924>>>>>>>// If this member is TRUE, the new process inherits the handle.
73924>>>>>>>
73924>>>>>>>
73924>>>>>>>// BOOL CreateDirectory(
73924>>>>>>>//    LPCTSTR lpPathName,
73924>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
73924>>>>>>>//   );
73924>>>>>>>//
73924>>>>>>>// lpPathName
73924>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
73924>>>>>>>//  to be created.
73924>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
73924>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
73924>>>>>>>// lpSecurityAttributes
73924>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
73924>>>>>>>//  determines whether the returned handle can be inherited by child processes.
73924>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
73924>>>>>>>// Returns:
73924>>>>>>>//  If the function succeeds, the return value is nonzero.
73924>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
73924>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryW" kernel32.dll ;  WString sPathName Pointer lpSecurity_Attributes Returns Integer
73925>>>>>>>
73925>>>>>>>
73925>>>>>>>// lpPathName
73925>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
73925>>>>>>>//  to be removed.
73925>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
73925>>>>>>>// Returns:
73925>>>>>>>//  If the function succeeds, the return value is nonzero.
73925>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
73925>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryW" kernel32.dll ;  WString sPathName Returns Integer
73926>>>>>>>
73926>>>>>>>
73926>>>>>>>
73926>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
73926>>>>>>>// executable file or a document file.
73926>>>>>>>//
73926>>>>>>>// Operation can be one of the following:
73926>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
73926>>>>>>>//            The file can be an executable file or a document file.
73926>>>>>>>//            The file can be a folder to open.
73926>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
73926>>>>>>>//            The file should be a document file. If the file is an executable file,
73926>>>>>>>//            the function opens the file, as if "open" had been specified.
73926>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
73926>>>>>>>//
73926>>>>>>>// Return Values:
73926>>>>>>>//
73926>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
73926>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
73926>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
73926>>>>>>>//
73926>>>>>>>// The following table lists these error values:
73926>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
73926>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
73926>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
73926>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
73926>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
73926>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
73926>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
73926>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
73926>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
73926>>>>>>>// Public Const SE_ERR_FNF = 2
73926>>>>>>>// Public Const SE_ERR_NOASSOC = 31
73926>>>>>>>// Public Const SE_ERR_OOM = 8
73926>>>>>>>// Public Const SE_ERR_PNF = 3
73926>>>>>>>// Public Const SE_ERR_SHARE = 26
73926>>>>>>>
73926>>>>>>>
73926>>>>>>>
73926>>>>>>>// Code to open the program that is associated with the selected file.
73926>>>>>>>//
73926>>>>>>>// External function call used in Procedure DoStartDocument
73926>>>>>>>External_function vWin32_ShellExecute "ShellExecuteW" shell32.dll ;  Handle  hWnd ;  WString wsOperation ;  WString wsFile ;  WString wsParameters ;  WString wsDirectory ;  Dword   iShowCmd Returns Handle
73927>>>>>>>
73927>>>>>>>
73927>>>>>>>
73927>>>>>>>
73927>>>>>>>Define vFO_MOVE                For |CI$0001
73927>>>>>>>Define vFO_COPY                For |CI$0002
73927>>>>>>>Define vFO_DELETE              For |CI$0003
73927>>>>>>>Define vFO_RENAME              For |CI$0004
73927>>>>>>>
73927>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
73927>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
73927>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
73927>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
73927>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
73927>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
73927>>>>>>>                                          // Must be freed using SHFreeNameMappings
73927>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
73927>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
73927>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
73927>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
73927>>>>>>>
73927>>>>>>>Struct tvShFileOpStruct
73927>>>>>>>  Handle   hWnd
73927>>>>>>>  UInteger wFunc
73927>>>>>>>  Pointer  pFrom
73927>>>>>>>  Pointer  pTo
73927>>>>>>>  Short    fFlags
73927>>>>>>>  Integer  fAnyOperationsAborted
73927>>>>>>>  Pointer  hNameMappings
73927>>>>>>>  Pointer  lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
73927>>>>>>>End_Struct // tvShFileOpStruct
73927>>>>>>>
73927>>>>>>>// hwnd
73927>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
73927>>>>>>>
73927>>>>>>>// wFunc
73927>>>>>>>//   Operation to perform. This member can be one of the following values:
73927>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
73927>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
73927>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
73927>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
73927>>>>>>>
73927>>>>>>>// pFrom
73927>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
73927>>>>>>>//   be null-separated. The list of names must be double null-terminated.
73927>>>>>>>
73927>>>>>>>// pTo
73927>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
73927>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
73927>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
73927>>>>>>>//   double null-terminated.
73927>>>>>>>
73927>>>>>>>// fAnyOperationsAborted
73927>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
73927>>>>>>>//   were completed or FALSE otherwise.
73927>>>>>>>
73927>>>>>>>
73927>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
73927>>>>>>>// This can be a file or a folder.
73927>>>>>>>// With thanks to Andrew S Kaplan
73927>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationW" Shell32.dll ;        Pointer lpFileOp Returns Integer
73928>>>>>>>
73928>>>>>>>
73928>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
73928>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryW" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
73929>>>>>>>
73929>>>>>>>
73929>>>>>>>
73929>>>>>>>// Courtesy Of Vincent Oorsprong
73929>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
73929>>>>>>>//   Pointer lpPathName ;
73929>>>>>>>//   Pointer lpPrefixString ;
73929>>>>>>>//   Integer uUnique ;
73929>>>>>>>//   Pointer lpTempFileName ;
73929>>>>>>>//   Returns Integer
73929>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
73929>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameW" kernel32.dll WString sPath ;        WString sPrefix Integer iUnique Pointer lpTempFileName Returns Integer
73930>>>>>>>
73930>>>>>>>External_function vWin32_GetTempPath "GetTempPathW" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
73931>>>>>>>
73931>>>>>>>External_function vWin32_DeleteFile "DeleteFileW" Kernel32.Dll ;   WString sFileName ;   Returns Integer
73932>>>>>>>
73932>>>>>>>// from:
73932>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
73932>>>>>>>//
73932>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
73932>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
73932>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
73932>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
73932>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
73932>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
73932>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
73932>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
73932>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
73932>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
73932>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
73932>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
73932>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
73932>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
73932>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
73932>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
73932>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
73932>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
73932>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
73932>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
73932>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
73932>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
73932>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
73932>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
73932>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
73932>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
73932>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
73932>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
73932>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
73932>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
73932>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
73932>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
73932>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
73932>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
73932>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
73932>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
73932>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
73932>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
73932>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
73932>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
73932>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
73932>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
73932>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
73932>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
73932>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
73932>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
73932>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
73932>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
73932>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
73932>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
73932>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
73932>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
73932>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
73932>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
73932>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
73932>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
73932>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
73932>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
73932>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
73932>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
73932>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
73932>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
73932>>>>>>>
73932>>>>>>>
73932>>>>>>>//HRESULT SHGetFolderPath(
73932>>>>>>>//    HWND hwndOwner,
73932>>>>>>>//    int nFolder,
73932>>>>>>>//    HANDLE hToken,
73932>>>>>>>//    DWORD dwFlags,
73932>>>>>>>//    LPTSTR pszPath
73932>>>>>>>//);
73932>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
73932>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
73932>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
73932>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
73932>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
73932>>>>>>>//
73932>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathW" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
73933>>>>>>>
73933>>>>>>>
73933>>>>>>>
73933>>>>>>>Struct tvWin32FindData
73933>>>>>>> Dword            dwFileAttributes
73933>>>>>>> Dword            ftCreationLowDateTime
73933>>>>>>> Dword            ftCreationHighDateTime
73933>>>>>>> dword            ftLastAccessLowDateTime
73933>>>>>>> Dword            ftLastAccessHighDateTime
73933>>>>>>> Dword            ftLastWriteLowDateTime
73933>>>>>>> Dword            ftLastWriteHighDateTime
73933>>>>>>> Dword            nFileSizeHigh
73933>>>>>>> Dword            nFileSizeLow
73933>>>>>>> Dword            dwReserved0
73933>>>>>>> Dword            dwReserved1
73933>>>>>>> Short[vMax_Path] cFileName
73933>>>>>>> Short[14]        cAlternateFileName
73933>>>>>>>End_Struct
73933>>>>>>>
73933>>>>>>>// Courtesy Of Vincent Oorsprong
73933>>>>>>>// lpFileName      : address of name of file to search for
73933>>>>>>>// lpFindFileData  : address of returned information
73933>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileW"  Kernel32.dll WString sFileName ;          Pointer lpFindFileData Returns Handle
73934>>>>>>>
73934>>>>>>>// Courtesy Of Vincent Oorsprong
73934>>>>>>>// hFindFile       : handle of search
73934>>>>>>>// lpFindFileData  : address of structure for data on found file
73934>>>>>>>External_function vWin32_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
73935>>>>>>>
73935>>>>>>>
73935>>>>>>>// Courtesy Of Vincent Oorsprong
73935>>>>>>>//  hFindFile      : file search handle
73935>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
73936>>>>>>>
73936>>>>>>>
73936>>>>>>>
73936>>>>>>>Struct tvFileTime
73936>>>>>>>  DWord dwLowDateTime
73936>>>>>>>  DWord dwHighDateTime
73936>>>>>>>End_Struct
73936>>>>>>>
73936>>>>>>>
73936>>>>>>>Struct tvSystemTime
73936>>>>>>>  UShort wYear
73936>>>>>>>  UShort wMonth
73936>>>>>>>  UShort wDayOfWeek
73936>>>>>>>  UShort wDay
73936>>>>>>>  UShort wHour
73936>>>>>>>  UShort wMinute
73936>>>>>>>  UShort wSecond
73936>>>>>>>  UShort wMilliSeconds
73936>>>>>>>End_Struct
73936>>>>>>>
73936>>>>>>>
73936>>>>>>>// Courtesy Of Vincent Oorsprong
73936>>>>>>>//  lpFileTime     : pointer to file time to convert
73936>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
73936>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
73937>>>>>>>
73937>>>>>>>// Courtesy Of Vincent Oorsprong
73937>>>>>>>// This function formats the time in a picture-string passed
73937>>>>>>>//
73937>>>>>>>// Picture      Meaning
73937>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
73937>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
73937>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
73937>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
73937>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
73937>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
73937>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
73937>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
73937>>>>>>>//    t         One character time marker string, such as A or P
73937>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
73937>>>>>>>//
73937>>>>>>>// For example, to get the time string  "11:29:40 PM"
73937>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
73937>>>>>>>
73937>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
73938>>>>>>>
73938>>>>>>>
73938>>>>>>>// Courtesy Of Vincent Oorsprong
73938>>>>>>>// This function formats the date in a picture-string passed
73938>>>>>>>//
73938>>>>>>>// Picture      Meaning
73938>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
73938>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
73938>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
73938>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
73938>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
73938>>>>>>>//              value associated with the specified locale.
73938>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
73938>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
73938>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
73938>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
73938>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
73938>>>>>>>//              associated with the specified locale.
73938>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
73938>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
73938>>>>>>>//    yyyy      Year represented hy full four digits.
73938>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
73938>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
73938>>>>>>>//              does not have an associated era or period string.
73938>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
73938>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
73938>>>>>>>
73938>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
73939>>>>>>>
73939>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
73939>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
73939>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
73939>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
73939>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
73939>>>>>>>
73939>>>>>>>//  Date Flags for GetDateFormatW.
73939>>>>>>>//
73939>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
73939>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
73939>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
73939>>>>>>>
73939>>>>>>>
73939>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
73940>>>>>>>
73940>>>>>>>
73940>>>>>>>// **WvA: 20-02-2004
73940>>>>>>>// While i was testing the format capabilities i stumbled over a very
73940>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
73940>>>>>>>// incorrectly into an unsigned integer.
73940>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
73940>>>>>>>// It does smell a bit fishy though
73940>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
73940>>>>>>>
73940>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
73940>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
73940>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
73940>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
73940>>>>>>>
73940>>>>>>>// Possible errors that can be returned by the shellformat function
73940>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
73940>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
73940>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
73940>>>>>>>
73940>>>>>>>
73940>>>>>>> // Courtesy Of Steve Walter,
73940>>>>>>> // USA Software, Inc
73940>>>>>>> // Format a disk
73940>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
73940>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
73941>>>>>>>
73941>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
73941>>>>>>>
73941>>>>>>>// SHCreateDirectoryEx
73941>>>>>>>
73941>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
73941>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
73941>>>>>>>//
73941>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
73941>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
73941>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
73941>>>>>>>//
73941>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
73941>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
73941>>>>>>>//        ERROR_CANCELLED.
73941>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
73941>>>>>>>
73941>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
73941>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
73941>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
73941>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
73941>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
73941>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
73941>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
73941>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
73941>>>>>>>
73941>>>>>>>//        int SHCreateDirectoryEx(
73941>>>>>>>//            HWND hwnd,
73941>>>>>>>//            LPCTSTR pszPath,
73941>>>>>>>//            const SECURITY_ATTRIBUTES *psa
73941>>>>>>>//        );
73941>>>>>>>
73941>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExW" shell32.dll Handle hWnd;                  WString wPath  Pointer lpSecurity_Attributes Returns Integer
73942>>>>>>>
73942>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryW" SHLWAPI.DLL WString wPath Returns Integer
73943>>>>>
73943>>>>>
73943>>>>>
73943>>>>>// Does the directory exist? - No = false, Yes = True
73943>>>>>// This also works with UNC path encoding and wildcards
73943>>>>>Function vFolderExists Global String sFolderName Returns Boolean
73945>>>>>    Boolean bFolderExists
73945>>>>>    Boolean bStop
73945>>>>>    String  sFolder sTmp
73945>>>>>    Integer iCh
73945>>>>>
73945>>>>>    If (sFolderName = "") Begin
73947>>>>>        Function_Return False
73948>>>>>    End
73948>>>>>>
73948>>>>>
73948>>>>>    Move True  to bFolderExists
73949>>>>>    Move False to bStop
73950>>>>>    Move "dir:" to sFolder
73951>>>>>    Append sFolder sFolderName
73952>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
73953>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
73955>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
73956>>>>>>
73956>>>>>        Function_Return False
73957>>>>>    End
73957>>>>>>
73957>>>>>    Direct_Input channel iCh sFolder
73959>>>>>    Repeat
73959>>>>>>
73959>>>>>        Readln channel iCh sTmp
73961>>>>>        Move (SeqEof) to bStop
73962>>>>>        If (Trim(sTmp)="") Begin
73964>>>>>            Move False to bFolderExists
73965>>>>>        End
73965>>>>>>
73965>>>>>        Else Begin
73966>>>>>            Move True to bFolderExists
73967>>>>>            Move True to bStop
73968>>>>>        End
73968>>>>>>
73968>>>>>    Until (bStop)
73970>>>>>    Close_Input channel iCh
73972>>>>>    Send Seq_Release_Channel iCh
73973>>>>>    Function_Return bFolderExists
73974>>>>>End_Function
73975>>>>>
73975>>>>>// returns folder name if a folder was selected, otherwise returns ""
73975>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
73977>>>>>    String  sPath
73977>>>>>    WString sFolder sTitle
73977>>>>>    Pointer lpItemIdList
73977>>>>>    Integer iFolderSelected iRetval
73977>>>>>    tvBrowseInfo BrowseInfo
73977>>>>>    tvBrowseInfo BrowseInfo
73977>>>>>
73977>>>>>    Move "" to sPath
73978>>>>>    If (sDialogTitle<>"") Begin
73980>>>>>        Move sDialogTitle to sTitle
73981>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
73981>>>>>        // disables showing some commonly used ascii characters like ascii 137 (ë)
73981>>>>>        // These chars are correctly shown if no toansi is used.
73981>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
73981>>>>>        // selected it will always be valid.
73981>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
73982>>>>>    End
73982>>>>>>
73982>>>>>
73982>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
73983>>>>>
73983>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
73983>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
73983>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
73984>>>>>
73984>>>>>    // null 128 chars into var (make space)
73984>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
73985>>>>>
73985>>>>>    // select folder
73985>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
73986>>>>>    // get selected folder name
73986>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
73987>>>>>
73987>>>>>    // release memory resources that are used by the ItemIdList
73987>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
73988>>>>>
73988>>>>>    If (iFolderSelected<>0) Begin
73990>>>>>        Move (CString(sFolder)) to sPath
73991>>>>>    End
73991>>>>>>
73991>>>>>    Function_Return  sPath
73992>>>>>End_Function
73993>>>>>
73993>>>>>// returns 0 if the folder is created.
73993>>>>>//         1 if the API-call returned an error.
73993>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
73995>>>>>    Integer  iRetval bFolderCreated
73995>>>>>    WString  sFolder
73995>>>>>    tvSecurity_attributes SA
73995>>>>>    tvSecurity_attributes SA
73995>>>>>
73995>>>>>    Move False to bFolderCreated
73996>>>>>    If (sNewFolder <> "") Begin
73998>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
73999>>>>>        Move  0                                  to SA.lpDescriptor
74000>>>>>        Move  1                                  to SA.bInheritHandle
74001>>>>>        Move (sNewFolder+Character(0)) to sFolder
74002>>>>>        Move (vWin32_CreateDirectory(sFolder, AddressOf(SA))) to bFolderCreated
74003>>>>>    End
74003>>>>>>
74003>>>>>
74003>>>>>    If (bFolderCreated=false) Begin
74005>>>>>        Move 1 to iRetVal
74006>>>>>    End
74006>>>>>>
74006>>>>>    Function_Return iRetVal
74007>>>>>End_Function
74008>>>>>
74008>>>>>// **WvA: 03-02-2002 Function created.
74008>>>>>// With this function one can remove a directory.
74008>>>>>// returns 0 if the folder is removed.
74008>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
74008>>>>>//         2 if the folder did not exist
74008>>>>>//         3 if the sFolder parameter passed is equal to ""
74008>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
74010>>>>>    Boolean bRemoved
74010>>>>>    WString sPath
74010>>>>>    Integer iRetval
74010>>>>>
74010>>>>>    Move 0     to iRetVal
74011>>>>>    Move False to bRemoved
74012>>>>>    Move (Trim(sFolder)) to sFolder
74013>>>>>    If (sFolder="") Begin
74015>>>>>        Move 3 to iRetVal
74016>>>>>    End
74016>>>>>>
74016>>>>>    If (vFolderExists(sFolder)=False) Begin
74018>>>>>        Move 2 to iRetVal
74019>>>>>    End
74019>>>>>>
74019>>>>>    If (iRetVal=0) Begin
74021>>>>>        // null MAX_PATH chars into var (make space)
74021>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
74022>>>>>        //
74022>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
74023>>>>>        Move (vWin32_RemoveDirectory(sPath)) to bRemoved
74024>>>>>    End
74024>>>>>>
74024>>>>>
74024>>>>>    If (iRetVal=0 And bRemoved=False) Begin
74026>>>>>        Move 1 to iRetVal
74027>>>>>    End
74027>>>>>>
74027>>>>>    Function_Return iRetVal
74028>>>>>End_Function
74029>>>>>
74029>>>>>// This will perform an operation on a file (e.g. open) with the application
74029>>>>>// registered in the Windows Registry to open that type of file (via its extension)
74029>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
74029>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
74031>>>>>    Handle  hInstance hWnd
74031>>>>>    // remove any leading/trailing spaces in the string
74031>>>>>    Move (Trim(sDocument)) to sDocument
74032>>>>>    Move (Trim(sPath))     to sPath
74033>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
74033>>>>>    Append sOperation   (Character(0))
74034>>>>>    Append sDocument    (Character(0))
74035>>>>>    Append sParameters  (Character(0))
74036>>>>>    Append sPath        (Character(0))
74037>>>>>
74037>>>>>    Get Window_Handle to hWnd
74038>>>>>    Move (vWin32_ShellExecute (hWnd, sOperation, sDocument, sParameters, sPath, 1)) to hInstance
74039>>>>>    If (hInstance <= 32) Begin
74041>>>>>        Send vDDE_Error_Handler hInstance
74042>>>>>    End
74042>>>>>>
74042>>>>>End_Procedure
74043>>>>>
74043>>>>>Class cShellFileOperations is a Array
74044>>>>>
74044>>>>>    Procedure Construct_Object
74046>>>>>        Forward Send Construct_Object
74048>>>>>        Property Integer piDeleteFlags        0
74049>>>>>        Property Integer piCopyFlags          0
74050>>>>>        Property Integer piMoveFlags          0
74051>>>>>        Property Integer piRenameFlags        0
74052>>>>>
74052>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
74053>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
74054>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
74055>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
74056>>>>>    End_Procedure
74057>>>>>
74057>>>>>    // This function uses the shell API to perform a file operation on the
74057>>>>>    // files supplied.
74057>>>>>    //
74057>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
74059>>>>>        Integer  iRetVal
74059>>>>>        Integer  iUserAbort
74059>>>>>        WString  wsSource wsDestination
74059>>>>>        tvShFileOpStruct FOS
74059>>>>>        tvShFileOpStruct FOS
74059>>>>>
74059>>>>>        Move (sSource+Character(0)+Character(0))      to wsSource
74060>>>>>        Move (sDestination+Character(0)+Character(0)) to wsDestination
74061>>>>>
74061>>>>>        If (eOperation <> vFO_DELETE) Begin
74063>>>>>            Move (AddressOf(wsDestination)) to FOS.pTo
74064>>>>>        End
74064>>>>>>
74064>>>>>
74064>>>>>        Move eOperation            to FOS.wFunc
74065>>>>>        Move (AddressOf(wsSource)) to FOS.pFrom
74066>>>>>        Move iFlags                to FOS.fFlags
74067>>>>>
74067>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
74068>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
74069>>>>>        If (iUserAbort <> 0) Begin
74071>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
74072>>>>>        End
74072>>>>>>
74072>>>>>        Function_Return (iRetVal)
74073>>>>>    End_Function
74074>>>>>
74074>>>>>    Function sfoDeleteFile String sFileName Returns Integer
74076>>>>>        Integer  iRetVal
74076>>>>>        Integer  iFlags
74076>>>>>
74076>>>>>        Get piDeleteFlags to iFlags
74077>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
74078>>>>>        Function_Return iRetVal
74079>>>>>    End_Function
74080>>>>>
74080>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
74082>>>>>        Integer  iRetVal
74082>>>>>        Integer  iFlags
74082>>>>>
74082>>>>>        Get piCopyFlags to iFlags
74083>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
74084>>>>>        Function_Return iRetVal
74085>>>>>    End_Function
74086>>>>>
74086>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
74088>>>>>        Integer  iRetVal
74088>>>>>        Integer  iFlags
74088>>>>>
74088>>>>>        Get piMoveFlags to iFlags
74089>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
74090>>>>>        Function_Return iRetVal
74091>>>>>    End_Function
74092>>>>>
74092>>>>>    // Rename a file or folder
74092>>>>>    // Returns a nonzero value if the operation failed.
74092>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
74094>>>>>        Integer  iRetVal
74094>>>>>        Integer  iFlags
74094>>>>>
74094>>>>>        Get piRenameFlags to iFlags
74095>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
74096>>>>>        Function_Return iRetVal
74097>>>>>    End_Function
74098>>>>>
74098>>>>>
74098>>>>>    //Example:
74098>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
74098>>>>>    //                                          mode.
74098>>>>>
74098>>>>>End_Class
74099>>>>>
74099>>>>>Object oShellFileOperations is a cShellFileOperations
74101>>>>>End_Object
74102>>>>>
74102>>>>>// Restore to the old way of working with the shell file operations.
74102>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
74102>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
74102>>>>>Procedure vWin32fhCompatibilityMode
74104>>>>>    Integer hoSFO
74104>>>>>    Integer iFlags
74104>>>>>
74104>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
74105>>>>>    Move (oShellFileOperations(Self)) to hoSFO
74106>>>>>
74106>>>>>    Set piDeleteFlags of hoSFO to iFlags
74107>>>>>    Set piCopyFlags   of hoSFO to iFlags
74108>>>>>    Set piMoveFlags   of hoSFO to iFlags
74109>>>>>    Set piRenameFlags of hoSFO to iFlags
74110>>>>>End_Procedure
74111>>>>>
74111>>>>>// Delete a file or folder
74111>>>>>// Returns a nonzero value if the operation failed.
74111>>>>>Function vDeleteFile Global String sFileName Returns Integer
74113>>>>>    Integer  iRetVal
74113>>>>>
74113>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
74114>>>>>    Function_Return iRetVal
74115>>>>>End_Function
74116>>>>>
74116>>>>>// Copy a file or folder
74116>>>>>// Returns a nonzero value if the operation failed.
74116>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
74118>>>>>    Integer  iRetVal
74118>>>>>
74118>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
74119>>>>>    Function_Return iRetVal
74120>>>>>End_Function
74121>>>>>
74121>>>>>// Move a file or folder
74121>>>>>// Returns a nonzero value if the operation failed.
74121>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
74123>>>>>    Integer  iRetVal
74123>>>>>
74123>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
74124>>>>>    Function_Return iRetVal
74125>>>>>End_Function
74126>>>>>
74126>>>>>// Rename a file or folder
74126>>>>>// Returns a nonzero value if the operation failed.
74126>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
74128>>>>>    Integer  iRetVal
74128>>>>>
74128>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
74129>>>>>    Function_Return iRetVal
74130>>>>>End_Function
74131>>>>>
74131>>>>>Function vGetWindowsDirectory Returns String
74133>>>>>    WString wDirectory
74133>>>>>    Integer iRetVal
74133>>>>>
74133>>>>>    Move (ZeroString(vMAX_PATH)) to wDirectory
74134>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), vMAX_PATH)) to iRetVal
74135>>>>>    If (iRetVal > vMAX_PATH) Begin
74137>>>>>        Move (ZeroString(iRetval)) to wDirectory
74138>>>>>        Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), iRetVal)) to iRetVal
74139>>>>>    End
74139>>>>>>
74139>>>>>    Function_Return (CString(wDirectory))
74140>>>>>End_Function
74141>>>>>
74141>>>>>Function vGetTempPath Returns String
74143>>>>>    Integer iRetVal
74143>>>>>    WString wTempPath
74143>>>>>
74143>>>>>    Move (ZeroString(vMAX_PATH)) to wTempPath
74144>>>>>    Move (vWin32_GetTempPath(vMAX_PATH, AddressOf(wTempPath))) to iRetVal
74145>>>>>    If (iRetVal > vMAX_PATH) Begin
74147>>>>>        Move (ZeroString(iRetval)) to wTempPath
74148>>>>>        Move (vWin32_GetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
74149>>>>>    End
74149>>>>>>
74149>>>>>    Function_Return (CString(wTempPath))
74150>>>>>End_Function
74151>>>>>
74151>>>>>// Courtesy of Marco Kuipers
74151>>>>>Function vMakeTempFile Returns String
74153>>>>>    Integer iRetval
74153>>>>>    String  sTempPath
74153>>>>>    String  sTempFileName
74153>>>>>    String  sPrefixString
74153>>>>>    WString wsTempFileName
74153>>>>>
74153>>>>>    Get vGetTempPath to sTempPath
74154>>>>>    If (sTempPath = "") Begin
74156>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
74157>>>>>        If (sTempPath<>"") Begin
74159>>>>>            Move (sTempPath+"\Temp\") to sTempPath
74160>>>>>        End
74160>>>>>>
74160>>>>>    End
74160>>>>>>
74160>>>>>
74160>>>>>    If (sTempPath = "") Begin
74162>>>>>        // second fallback we really do not want to get here as to be fair using current folder as temp
74162>>>>>        // makes little sense. Leaving this in as it was old behavior.
74162>>>>>        Get_Current_Directory to sTempPath
74163>>>>>    End
74163>>>>>>
74163>>>>>
74163>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
74164>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
74166>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
74167>>>>>>
74167>>>>>    End
74167>>>>>>
74167>>>>>
74167>>>>>    Move (ZeroString(vMax_Path)) to wsTempFileName
74168>>>>>    Move ("tmp"+Character(0))    to sPrefixString
74169>>>>>    Move (vWin32_GetTempFileName (sTempPath, sPrefixString, 0, AddressOf(wsTempFileName))) to iRetval
74170>>>>>    If (iRetval = 0) Begin  // The api call returns 0 if an error occurs
74172>>>>>    //Get ShowLastError to iRetval
74172>>>>>        Move "" to sTempFileName
74173>>>>>    End
74173>>>>>>
74173>>>>>    Move (Cstring(wsTempFileName)) to sTempFileName
74174>>>>>    Function_Return sTempFileName
74175>>>>>End_Function
74176>>>>>
74176>>>>>// This function creates a uniquely named temporary file in folder sPath
74176>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
74176>>>>>// Note that you will have to cleanup the tempfile yourself as the function
74176>>>>>// does not take care of that.
74176>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
74178>>>>>    Integer iRetVal
74178>>>>>    String  sTempFileName
74178>>>>>    WString wTempFileName
74178>>>>>
74178>>>>>    Move (sPath+Character(0))   to sPath
74179>>>>>    Move (sPrefix+Character(0)) to sPrefix
74180>>>>>    Move (Pad("", vMAX_PATH))   to wTempFileName
74181>>>>>
74181>>>>>    Move (vWin32_GetTempFileName(sPath, sPrefix, 0, AddressOf(wTempFileName))) to iRetVal
74182>>>>>    Move (Trim(Cstring(wTempFileName))) to sTempFileName
74183>>>>>    Function_Return sTempFileName
74184>>>>>End_Function
74185>>>>>
74185>>>>>//
74185>>>>>// Get a specific shell folder for example to get the desktop folder
74185>>>>>// simply call this function and pass it vCSIDL_DESKTOP
74185>>>>>//
74185>>>>>Function vSHGetFolderPath Integer eFolder Returns String
74187>>>>>    Integer iVoid
74187>>>>>    Handle  hWnd
74187>>>>>    String  sFolder
74187>>>>>    WString wFolder
74187>>>>>
74187>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
74188>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to wFolder
74189>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(wFolder))) To iVoid
74190>>>>>    Move (CString(wFolder)) to sFolder
74191>>>>>    Function_Return sFolder
74192>>>>>End_Function
74193>>>>>
74193>>>>>// Courtesy Of Vincent Oorsprong
74193>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
74195>>>>>    String  sFileDateTime
74195>>>>>    WString wFormattedTime wFormattedDate
74195>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
74195>>>>>    tvFileTime   FileTime
74195>>>>>    tvFileTime   FileTime
74195>>>>>    tvSystemTime SystemTime
74195>>>>>    tvSystemTime SystemTime
74195>>>>>
74195>>>>>    Move "" to sFileDateTime
74196>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
74197>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
74198>>>>>
74198>>>>>    Move 0 to SystemTime.wYear
74199>>>>>
74199>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
74200>>>>>    If (iSuccess = 1) Begin
74202>>>>>        Move (ZeroString(255))               to wFormattedTime
74203>>>>>        Move (SizeOfWString(wFormattedTime)) to iLenCcTime
74204>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedTime), iLenCcTime)) to iDataLength
74205>>>>>        Move (ZeroString(255))               to wFormattedDate
74206>>>>>        Move (SizeOfWString(wFormattedDate)) to iLenCcDate
74207>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedDate), iLenCcDate)) to iDataLength
74208>>>>>        Move (Cstring (wFormattedDate)  * Cstring (wFormattedTime)) to sFileDateTime
74209>>>>>    End
74209>>>>>>
74209>>>>>    Function_Return sFileDateTime
74210>>>>>End_Function
74211>>>>>
74211>>>>>// **WvA:
74211>>>>>// A windows replacement for the standard function FileExists.
74211>>>>>// This version will also return (true) for a file when it is open by an application.
74211>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
74211>>>>>// Example: Get vFilePathExists "C:\config.sy?"
74211>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
74211>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
74213>>>>>    String  sDirSep
74213>>>>>    Handle  hFindFile
74213>>>>>    Integer iVoid
74213>>>>>    tvWin32FindData FindData
74213>>>>>    tvWin32FindData FindData
74213>>>>>
74213>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
74214>>>>>    Move (Trim(sFilePathMask)) to sFilePathMask
74215>>>>>
74215>>>>>    If (Length(sFilePathMask)>0) Begin
74217>>>>>        // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
74217>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74218>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
74222>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
74223>>>>>        Loop
74224>>>>>>
74224>>>>>
74224>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
74225>>>>>        Move (vWin32_FindFirstFile (sFilePathMask, AddressOf(FindData))) to hFindFile
74226>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
74227>>>>>    End
74227>>>>>>
74227>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
74228>>>>>End_Function
74229>>>>>
74229>>>>>
74229>>>>>//
74229>>>>>// Returns the amount of files in the folder (if it exists)
74229>>>>>// Returns -1 if folder doesn't exist.
74229>>>>>// The files "." and ".." are not counted.
74229>>>>>//
74229>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
74231>>>>>    Boolean bFound
74231>>>>>    Handle  hFindFile
74231>>>>>    Integer iCount  iVoid
74231>>>>>    Integer iSuccess
74231>>>>>    String  sFileName
74231>>>>>    tvWin32FindData FindData
74231>>>>>    tvWin32FindData FindData
74231>>>>>
74231>>>>>    Move -1 to iCount
74232>>>>>    Get vFolderFormat sFolderName to sFolderName
74233>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
74234>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
74235>>>>>    Move (vWin32_FindFirstFile (sFolderName, AddressOf(FindData))) to hFindFile
74236>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
74237>>>>>    If (bFound) Begin
74239>>>>>        Move 0 to iCount
74240>>>>>    End
74240>>>>>>
74240>>>>>    While (bFound)
74244>>>>>        Increment iCount
74245>>>>>        Move (PointerToWString(AddressOf(FindData.cFileName))) to sFileName
74246>>>>>        If (sFileName="." or sFileName="..") Begin
74248>>>>>            Decrement iCount
74249>>>>>        End
74249>>>>>>
74249>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
74250>>>>>        Move (iSuccess<>0) to bFound
74251>>>>>    Loop
74252>>>>>>
74252>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
74253>>>>>    Function_Return iCount
74254>>>>>End_Function
74255>>>>>
74255>>>>>// Create the folder, including intermediate directories.
74255>>>>>// Don't panic if the folder already exists.
74255>>>>>// Michael Mullan June 2009.
74255>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
74257>>>>>    String  sFolder
74257>>>>>    Integer iRetval iFolderCreated
74257>>>>>    tvSecurity_attributes SA
74257>>>>>    tvSecurity_attributes SA
74257>>>>>
74257>>>>>    Move 0 to iFolderCreated
74258>>>>>
74258>>>>>    // null MAX_PATH chars into var (make space)
74258>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
74259>>>>>    If (sNewFolder <> "") Begin
74261>>>>>
74261>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
74262>>>>>        Move  0  to SA.lpDescriptor
74263>>>>>        Move  1  to SA.bInheritHandle
74264>>>>>
74264>>>>>        //
74264>>>>>        Move (sNewFolder+"") to sFolder
74265>>>>>        Move (vWin32_SHCreateDirectoryEx(0,sFolder, AddressOf(SA))) to iFolderCreated
74266>>>>>    End
74266>>>>>>
74266>>>>>
74266>>>>>    If (iFolderCreated <> 0) Begin
74268>>>>>        Move 1 to iRetVal
74269>>>>>        Case Begin
74269>>>>>            Case (iFolderCreated = 161)
74271>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
74272>>>>>>
74272>>>>>                Case Break
74273>>>>>            Case (iFolderCreated = 206)
74276>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
74277>>>>>>
74277>>>>>                Case Break
74278>>>>>            Case (iFolderCreated = 3)
74281>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
74282>>>>>>
74282>>>>>                Case Break
74283>>>>>            Case (iFolderCreated = 80)
74286>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
74287>>>>>                Case Break
74288>>>>>            Case (iFolderCreated = 183)
74291>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
74292>>>>>                Case Break
74293>>>>>            Case (iFolderCreated = 1223)
74296>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
74297>>>>>>
74297>>>>>                Case Break
74298>>>>>            Case Else
74298>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
74299>>>>>>
74299>>>>>        Case End
74299>>>>>    End
74299>>>>>>
74299>>>>>    Function_Return iRetVal
74300>>>>>End_Function
74301>>>>>
74301>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
74303>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
74303>>>>>    Integer iFileSize iVoid
74303>>>>>    Handle  hFindFile
74303>>>>>    tvWin32FindData FindData
74303>>>>>    tvWin32FindData FindData
74303>>>>>
74303>>>>>    Move (sFileName+"") to sFileName
74304>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
74305>>>>>    Move (vWin32_FindFirstFile (sFileName, AddressOf(FindData))) to hFindFile
74306>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
74308>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
74309>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
74310>>>>>    End
74310>>>>>>
74310>>>>>    Move (vWin32_FindClose(hFindFile)) to iVoid
74311>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
74312>>>>>
74312>>>>>    Function_Return iFileSize
74313>>>>>End_Function
74314>>>>>
74314>>>>>//
74314>>>>>// Based on code in Peter Crook's Browse folder workspace
74314>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
74314>>>>>//
74314>>>>>//=============================================================================
74314>>>>>// Verifies that a path is a valid directory.
74314>>>>>//
74314>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
74314>>>>>//
74314>>>>>// Parameters:
74314>>>>>//      sPath - Address of the path to verify.
74314>>>>>//=============================================================================
74314>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
74316>>>>>    Integer iResult
74316>>>>>    Boolean bRetVal
74316>>>>>
74316>>>>>    Move false to bRetVal
74317>>>>>    Move (sPath - Character (0)) to sPath
74318>>>>>    Move (vWin32_PathIsDirectory (sPath)) to iResult
74319>>>>>    If (iResult<>0) Begin
74321>>>>>        Move True to bRetVal
74322>>>>>    End
74322>>>>>>
74322>>>>>
74322>>>>>    Function_Return bRetVal
74323>>>>>End_Function
74324>>>>>
74324>>>
74324>>>//
74324>>>// Gets the string from the right of the last sStopChar in sFrom
74324>>>// If sStopChar has no occurences in the string an empty string is
74324>>>// returned.
74324>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
74326>>>    String  sRetVal
74326>>>    String  sChar
74326>>>    Integer iLength
74326>>>    Integer iPos
74326>>>    Boolean bStopChar
74326>>>    Move "" to sRetval
74327>>>    Move (Length(sFrom)) to iLength
74328>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
74330>>>        Move iLength   to iPos
74331>>>        Move (False)   to bStopChar
74332>>>        While Not bStopChar
74336>>>            Move (Mid(sFrom,1,iPos)) to sChar
74337>>>            Decrement iPos
74338>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
74340>>>                Move (True) to bStopChar
74341>>>            End
74341>>>>
74341>>>            Else Begin
74342>>>                Move (sChar+sRetVal) to sRetVal
74343>>>            End
74343>>>>
74343>>>        Loop
74344>>>>
74344>>>    End
74344>>>>
74344>>>    Function_Return sRetVal
74345>>>End_Function
74346>>>
74346>>>// Pre:  sFileName contains the complete path of the file.
74346>>>// Post: returns the complete path of the file.
74346>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
74346>>>Function ParseFolderName Global String sFileName Returns String
74348>>>    String sFile
74348>>>    String sFolderName
74348>>>    String sDirSep // this is "\" for windows, or "/" for unix
74348>>>
74348>>>    Move "" to sFolderName
74349>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74350>>>    If sDirSep In sFileName Begin
74352>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
74353>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
74354>>>    End
74354>>>>
74354>>>    Else If ":" In sFileName Begin
74357>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
74358>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
74359>>>    End
74359>>>>
74359>>>    Function_Return sFolderName
74360>>>End_Function
74361>>>
74361>>>// Pre:  sFileName contains the complete path of the file.
74361>>>// post: The returned filename has it's path removed, but will have a extension
74361>>>Function ParseFileName Global String sFileName Returns String
74363>>>    String sFolderName
74363>>>    String sDirSep // this is "\" for windows, or "/" for unix
74363>>>
74363>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74364>>>    Get ParseFolderName sFileName to sFolderName
74365>>>    If (sFolderName <> "") Begin
74367>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
74368>>>    End
74368>>>>
74368>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
74369>>>    Function_Return sFilename
74370>>>End_Function
74371>>>
74371>>>// Pre:  sFileName may contain the complete path of the file.
74371>>>//       or contain multiple dots in the filename, so temp.gif.bak will
74371>>>//       return "bak" as the extension and not "gif"
74371>>>// Post: returns the extension only, this extension can be a valid unixlike extension
74371>>>//       such as "html" or "java"
74371>>>Function ParseFileExtension Global String sFileName Returns String
74373>>>    String  sFileExtension
74373>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
74374>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
74375>>>    Function_Return sFileExtension
74376>>>End_Function
74377>>>
74377>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
74377>>>
74377>>>Function DDE_Error_To_String Integer iErrorID Returns String
74379>>>    String sMessage
74379>>>    Case Begin
74379>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
74381>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
74382>>>            Case Break
74383>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
74386>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
74387>>>            Case Break
74388>>>        Case (iErrorID = vERROR_BAD_FORMAT)
74391>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
74392>>>            Case Break
74393>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
74396>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
74397>>>            Case Break
74398>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
74401>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
74402>>>            Case Break
74403>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
74406>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
74407>>>            Case Break
74408>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
74411>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
74412>>>            Case Break
74413>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
74416>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
74417>>>            Case Break
74418>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
74421>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
74422>>>            Case Break
74423>>>        Case (iErrorID = vSE_ERR_NOASSOC)
74426>>>            Move CS_DDE_ERR_NOASSOC to sMessage
74427>>>            Case Break
74428>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
74431>>>            Move CS_DDE_ERR_OOM to sMessage
74432>>>            Case Break
74433>>>        Case (iErrorID = vSE_ERR_PNF)
74436>>>            Move CS_DDE_ERR_PNF to sMessage
74437>>>            Case Break
74438>>>        Case (iErrorID = vSE_ERR_SHARE)
74441>>>            Move CS_DDE_ERR_SHARE to sMessage
74442>>>            Case Break
74443>>>        Case Else
74443>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
74444>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
74445>>>            Case Break
74446>>>    Case End
74446>>>    Function_Return sMessage
74447>>>End_Function
74448>>>
74448>>>Procedure vDDE_Error_Handler Integer iErrorID
74450>>>    String sMessage
74450>>>    Get DDE_Error_To_String iErrorID to sMessage
74451>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
74452>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
74453>>>End_Procedure
74454>>>
74454>>>
74454>>>// This function informs the user that he entered a yet unknown folder and
74454>>>// asks if he/she wants to create the folder (Yes/No)
74454>>>// Choice: "Yes" - this creates the folder
74454>>>//                 if successful, the function returns false
74454>>>//                 else it will be true.
74454>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
74454>>>//                 For example: to stop a save
74454>>>// Precondition: A foldername must be entered. We do not check for empty paths
74454>>>// This function returns a non-zero value if the folder isn't created afterwards
74454>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
74456>>>    Integer bIsNotValid
74456>>>    Integer iUsers_Choice
74456>>>    String  sMessage
74456>>>
74456>>>    If (vFolderExists(sFolderName) Eq 0) Begin
74458>>>        Move "The folder '" to sMessage
74459>>>        Append sMessage sFolderName
74460>>>        Append sMessage "' does not yet exist,\n"
74461>>>        Append sMessage "Do you want to create it now?"
74462>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
74463>>>        Case Begin
74463>>>            Case (iUsers_Choice = MBR_Yes)
74465>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
74466>>>                If bIsNotValid Begin
74468>>>                    Move "An error occurred while trying to create folder '" to sMessage
74469>>>                    Append sMessage sFolderName "'.\n\n"
74471>>>                    Send Info_Box sMessage "Info"
74472>>>                End
74472>>>>
74472>>>                Case Break
74473>>>            Case (iUsers_Choice = MBR_No)
74476>>>                Move dfTrue to bIsNotValid // Cancel the save
74477>>>                Case Break
74478>>>        Case End
74478>>>    End
74478>>>>
74478>>>    Function_Return bIsNotValid
74479>>>End_Function
74480>>>
74480>>>// **WvA
74480>>>// Formats a foldername by first trimming it and after that by sticking a
74480>>>// directory separator (/\) to the end if it doesn't have one there already.
74480>>>// The folder may contain a drive letter or UNC encoding.
74480>>>Function vFolderFormat Global String sFolderName Returns String
74482>>>    String sDirSep
74482>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
74483>>>    Move (Trim(sFolderName)) to sFolderName
74484>>>    If (Right(sFolderName,1)<>sDirSep) Begin
74486>>>        Move (sFolderName+sDirSep) to sFolderName
74487>>>    End
74487>>>>
74487>>>    Function_Return sFolderName
74488>>>End_Function
74489>>>
74489>>>//
74489>>>// Gets the parent path of the currently supplied path
74489>>>// Returns "" when we are at the root folder.
74489>>>//
74489>>>Function vParentPath Global String sPath Returns String
74491>>>    String sStrip sDirSep
74491>>>
74491>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74492>>>    Move (Trim(sPath)) to sPath
74493>>>    If (Right(sPath,1) = sDirSep) Begin
74495>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
74496>>>    End
74496>>>>
74496>>>    If (Pos(sDirSep, sPath)) Begin
74498>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
74499>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
74500>>>    End
74500>>>>
74500>>>    Else Begin
74501>>>        Move "" to sPath
74502>>>    End
74502>>>>
74502>>>    Function_Return sPath
74503>>>End_Function
74504>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJSkinFramework.pkg)
74504>>>Use windows.pkg
74504>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJComSkinFramework.pkg)
74504>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v22.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v22.0.0.ocx
74504>>>>>Use FlexCom20.pkg
74504>>>>>
74504>>>>>// Changes to Imported package
74504>>>>>//     OLEXTPxx to XTPxx
74504>>>>>//     OLExtpxx to xtpxx
74504>>>>>//     OLESkinFramework to SkinFramework
74504>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
74504>>>>>//     cCom classes to cCJ
74504>>>>>//     cCJAutomationObject back to cComAutomationObject
74504>>>>>//     cCJActiveXControl back to cComActiveXControl
74504>>>>>//     cCJSkinFramework to cCJComSkinFramework
74504>>>>>//     Use statements as noted below (classes moved to these files)
74504>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
74504>>>>>
74504>>>>>// These have been extracted from this class and moved into seperate packages
74504>>>>>// because other Codejock classes use these.
74504>>>>>Use cCJColorManager.pkg     // cCJColorManager
74504>>>>>
74504>>>>>
74504>>>>>Define SkinFrameworkApplyOptions for Integer
74504>>>>>    Define xtpSkinApplyMetrics for 1
74504>>>>>    Define xtpSkinApplyFrame for 2
74504>>>>>    Define xtpSkinApplyColors for 4
74504>>>>>    Define xtpSkinApplyMenus for 8
74504>>>>>
74504>>>>>// CLSID: {C0DE2200-28D7-4F2C-87A7-7266367B4655}
74504>>>>>// Dispatch interface for SkinFramework Control
74504>>>>>Class cCJ_DSkinFramework is a Mixin
74505>>>>>
74505>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
74507>>>>>        SkinFrameworkApplyOptions retVal
74507>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
74508>>>>>        Function_Return retVal
74509>>>>>    End_Function
74510>>>>>
74510>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
74512>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
74513>>>>>    End_Procedure
74514>>>>>
74514>>>>>    Function ComAutoApplyNewWindows Returns Boolean
74516>>>>>        Boolean retVal
74516>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
74517>>>>>        Function_Return retVal
74518>>>>>    End_Function
74519>>>>>
74519>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
74521>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
74522>>>>>    End_Procedure
74523>>>>>
74523>>>>>    Function ComAutoApplyNewThreads Returns Boolean
74525>>>>>        Boolean retVal
74525>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
74526>>>>>        Function_Return retVal
74527>>>>>    End_Function
74528>>>>>
74528>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
74530>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
74531>>>>>    End_Procedure
74532>>>>>
74532>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
74534>>>>>        Handle hDispatchDriver
74534>>>>>        Boolean retVal
74534>>>>>        Get phDispatchDriver to hDispatchDriver
74535>>>>>        Send PrepareParams to hDispatchDriver 2
74536>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74537>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74538>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
74539>>>>>        Function_Return retVal
74540>>>>>    End_Function
74541>>>>>
74541>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
74543>>>>>        Handle hDispatchDriver
74543>>>>>        Get phDispatchDriver to hDispatchDriver
74544>>>>>        Send PrepareParams to hDispatchDriver 1
74545>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74546>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
74547>>>>>    End_Procedure
74548>>>>>
74548>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
74550>>>>>        Handle hDispatchDriver
74550>>>>>        Get phDispatchDriver to hDispatchDriver
74551>>>>>        Send PrepareParams to hDispatchDriver 2
74552>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74553>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
74554>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
74555>>>>>    End_Procedure
74556>>>>>
74556>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
74558>>>>>        Handle hDispatchDriver
74558>>>>>        Get phDispatchDriver to hDispatchDriver
74559>>>>>        Send PrepareParams to hDispatchDriver 1
74560>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74561>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
74562>>>>>    End_Procedure
74563>>>>>
74563>>>>>    Procedure ComRemoveAllWindows
74565>>>>>        Handle hDispatchDriver
74565>>>>>        Get phDispatchDriver to hDispatchDriver
74566>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
74567>>>>>    End_Procedure
74568>>>>>
74568>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
74570>>>>>        Handle hDispatchDriver
74570>>>>>        Get phDispatchDriver to hDispatchDriver
74571>>>>>        Send PrepareParams to hDispatchDriver 2
74572>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
74573>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
74574>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
74575>>>>>    End_Procedure
74576>>>>>
74576>>>>>    Procedure ComRemoveWindowClass String llClassName
74578>>>>>        Handle hDispatchDriver
74578>>>>>        Get phDispatchDriver to hDispatchDriver
74579>>>>>        Send PrepareParams to hDispatchDriver 1
74580>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
74581>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
74582>>>>>    End_Procedure
74583>>>>>
74583>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
74585>>>>>        Handle hDispatchDriver
74585>>>>>        Variant retVal
74585>>>>>        Get phDispatchDriver to hDispatchDriver
74586>>>>>        Send PrepareParams to hDispatchDriver 2
74587>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
74588>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
74589>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
74590>>>>>        Function_Return retVal
74591>>>>>    End_Function
74592>>>>>
74592>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
74594>>>>>        Handle hDispatchDriver
74594>>>>>        Variant retVal
74594>>>>>        Get phDispatchDriver to hDispatchDriver
74595>>>>>        Send PrepareParams to hDispatchDriver 1
74596>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
74597>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
74598>>>>>        Function_Return retVal
74599>>>>>    End_Function
74600>>>>>
74600>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74602>>>>>        Handle hDispatchDriver
74602>>>>>        OLE_COLOR retVal
74602>>>>>        Get phDispatchDriver to hDispatchDriver
74603>>>>>        Send PrepareParams to hDispatchDriver 1
74604>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74605>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
74606>>>>>        Function_Return retVal
74607>>>>>    End_Function
74608>>>>>
74608>>>>>    Procedure ComExcludeModule String llModuleName
74610>>>>>        Handle hDispatchDriver
74610>>>>>        Get phDispatchDriver to hDispatchDriver
74611>>>>>        Send PrepareParams to hDispatchDriver 1
74612>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
74613>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
74614>>>>>    End_Procedure
74615>>>>>
74615>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
74617>>>>>        Handle hDispatchDriver
74617>>>>>        Variant retVal
74617>>>>>        Get phDispatchDriver to hDispatchDriver
74618>>>>>        Send PrepareParams to hDispatchDriver 2
74619>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74620>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74621>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
74622>>>>>        Function_Return retVal
74623>>>>>    End_Function
74624>>>>>
74624>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
74626>>>>>        Handle hDispatchDriver
74626>>>>>        Get phDispatchDriver to hDispatchDriver
74627>>>>>        Send PrepareParams to hDispatchDriver 2
74628>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74629>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
74630>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
74631>>>>>    End_Procedure
74632>>>>>
74632>>>>>    Procedure ComAboutBox
74634>>>>>        Handle hDispatchDriver
74634>>>>>        Get phDispatchDriver to hDispatchDriver
74635>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
74636>>>>>    End_Procedure
74637>>>>>End_Class
74638>>>>>
74638>>>>>// CLSID: {C0DE2200-4463-4030-B324-AC6A8075FEC8}
74638>>>>>// Event interface for SkinFramework Control
74638>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
74639>>>>>
74639>>>>>    Procedure RegisterComEvents
74641>>>>>    End_Procedure
74642>>>>>End_Class
74643>>>>>
74643>>>>>// CoClass
74643>>>>>// ProgID: Codejock.SkinFramework.22.0.0
74643>>>>>// CLSID: {C0DE2200-2217-42EE-B1B0-82C890431F17}
74643>>>>>// SkinFramework Control
74643>>>>>Class cCJComSkinFramework is a cComActiveXControl
74644>>>>>    Import_Class_Protocol cCJ_DSkinFramework
74645>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
74646>>>>>
74646>>>>>    Procedure Construct_Object
74648>>>>>        Forward Send Construct_Object
74650>>>>>        Set psProgID to "{C0DE2200-2217-42EE-B1B0-82C890431F17}"
74651>>>>>        Set psEventId to "{C0DE2200-4463-4030-B324-AC6A8075FEC8}"
74652>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2022 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v22.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
74653>>>>>        Set peAutoCreate to acAutoCreate
74654>>>>>    End_Procedure
74655>>>>>End_Class
74656>>>>>
74656>>>>>// CLSID: {C0DE2200-CA9A-4AA9-8601-0AB7F551AA3D}
74656>>>>>// SkinFramework Global Settings
74656>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
74657>>>>>
74657>>>>>    Function ComLicense Returns String
74659>>>>>        String retVal
74659>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
74660>>>>>        Function_Return retVal
74661>>>>>    End_Function
74662>>>>>
74662>>>>>    Procedure Set ComLicense String value
74664>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
74665>>>>>    End_Procedure
74666>>>>>
74666>>>>>    Function ComTitle Returns String
74668>>>>>        String retVal
74668>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
74669>>>>>        Function_Return retVal
74670>>>>>    End_Function
74671>>>>>
74671>>>>>    Procedure Set ComTitle String value
74673>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
74674>>>>>    End_Procedure
74675>>>>>
74675>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74675>>>>>    Function ComUseLegacyCore Returns Boolean
74677>>>>>        Boolean retVal
74677>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
74678>>>>>        Function_Return retVal
74679>>>>>    End_Function
74680>>>>>
74680>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74680>>>>>    Procedure Set ComUseLegacyCore Boolean value
74682>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
74683>>>>>    End_Procedure
74684>>>>>
74684>>>>>    Function ComVersion Returns String
74686>>>>>        Handle hDispatchDriver
74686>>>>>        String retVal
74686>>>>>        Get phDispatchDriver to hDispatchDriver
74687>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
74688>>>>>        Function_Return retVal
74689>>>>>    End_Function
74690>>>>>
74690>>>>>    Function ComUnicode Returns Boolean
74692>>>>>        Handle hDispatchDriver
74692>>>>>        Boolean retVal
74692>>>>>        Get phDispatchDriver to hDispatchDriver
74693>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
74694>>>>>        Function_Return retVal
74695>>>>>    End_Function
74696>>>>>
74696>>>>>    Function ComOcxPath Returns String
74698>>>>>        Handle hDispatchDriver
74698>>>>>        String retVal
74698>>>>>        Get phDispatchDriver to hDispatchDriver
74699>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
74700>>>>>        Function_Return retVal
74701>>>>>    End_Function
74702>>>>>End_Class
74703>>>>>
74703>>>>>// CoClass
74703>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.22.0.0
74703>>>>>// CLSID: {C0DE2200-F744-4373-B38D-29CE83EF0EE5}
74703>>>>>// SkinFramework Global Settings
74703>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
74704>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
74705>>>>>
74705>>>>>    Procedure Construct_Object
74707>>>>>        Forward Send Construct_Object
74709>>>>>        Set psProgID to "{C0DE2200-F744-4373-B38D-29CE83EF0EE5}"
74710>>>>>        Set peAutoCreate to acNoAutoCreate
74711>>>>>    End_Procedure
74712>>>>>End_Class
74713>>>>>
74713>>>>>// CLSID: {C0DE2200-1038-498E-A936-361F08B4C4AA}
74713>>>>>Class cCJSkinIniFile is a cComAutomationObject
74714>>>>>
74714>>>>>    Function ComColorScheme Returns String
74716>>>>>        String retVal
74716>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74717>>>>>        Function_Return retVal
74718>>>>>    End_Function
74719>>>>>
74719>>>>>    Procedure Set ComColorScheme String value
74721>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74722>>>>>    End_Procedure
74723>>>>>
74723>>>>>    Function ComFontSize Returns String
74725>>>>>        String retVal
74725>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74726>>>>>        Function_Return retVal
74727>>>>>    End_Function
74728>>>>>
74728>>>>>    Procedure Set ComFontSize String value
74730>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74731>>>>>    End_Procedure
74732>>>>>
74732>>>>>    Function ComIniFileName Returns String
74734>>>>>        String retVal
74734>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
74735>>>>>        Function_Return retVal
74736>>>>>    End_Function
74737>>>>>
74737>>>>>    Procedure Set ComIniFileName String value
74739>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
74740>>>>>    End_Procedure
74741>>>>>End_Class
74742>>>>>
74742>>>>>// CLSID: {C0DE2200-4834-499E-95B4-30E0C3F43A10}
74742>>>>>Class cCJSkinDescription is a cComAutomationObject
74743>>>>>
74743>>>>>    Function ComName Returns String
74745>>>>>        String retVal
74745>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74746>>>>>        Function_Return retVal
74747>>>>>    End_Function
74748>>>>>
74748>>>>>    Procedure Set ComName String value
74750>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74751>>>>>    End_Procedure
74752>>>>>
74752>>>>>    Function ComPath Returns String
74754>>>>>        String retVal
74754>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74755>>>>>        Function_Return retVal
74756>>>>>    End_Function
74757>>>>>
74757>>>>>    Procedure Set ComPath String value
74759>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74760>>>>>    End_Procedure
74761>>>>>
74761>>>>>    Function ComCount Returns Integer
74763>>>>>        Handle hDispatchDriver
74763>>>>>        Integer retVal
74763>>>>>        Get phDispatchDriver to hDispatchDriver
74764>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74765>>>>>        Function_Return retVal
74766>>>>>    End_Function
74767>>>>>
74767>>>>>    Function ComIniFile Integer llIndex Returns Variant
74769>>>>>        Handle hDispatchDriver
74769>>>>>        Variant retVal
74769>>>>>        Get phDispatchDriver to hDispatchDriver
74770>>>>>        Send PrepareParams to hDispatchDriver 1
74771>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74772>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74773>>>>>        Function_Return retVal
74774>>>>>    End_Function
74775>>>>>
74775>>>>>    Function Com_NewEnum Returns Variant
74777>>>>>        Handle hDispatchDriver
74777>>>>>        Variant retVal
74777>>>>>        Get phDispatchDriver to hDispatchDriver
74778>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74779>>>>>        Function_Return retVal
74780>>>>>    End_Function
74781>>>>>End_Class
74782>>>>>
74782>>>>>// CLSID: {C0DE2200-FB37-4B08-A2B9-F6F8B253D697}
74782>>>>>Class cCJSkinDescriptions is a cComAutomationObject
74783>>>>>
74783>>>>>    Function ComCount Returns Integer
74785>>>>>        Handle hDispatchDriver
74785>>>>>        Integer retVal
74785>>>>>        Get phDispatchDriver to hDispatchDriver
74786>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74787>>>>>        Function_Return retVal
74788>>>>>    End_Function
74789>>>>>
74789>>>>>    Function ComSkin Integer llIndex Returns Variant
74791>>>>>        Handle hDispatchDriver
74791>>>>>        Variant retVal
74791>>>>>        Get phDispatchDriver to hDispatchDriver
74792>>>>>        Send PrepareParams to hDispatchDriver 1
74793>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74794>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74795>>>>>        Function_Return retVal
74796>>>>>    End_Function
74797>>>>>
74797>>>>>    Function Com_NewEnum Returns Variant
74799>>>>>        Handle hDispatchDriver
74799>>>>>        Variant retVal
74799>>>>>        Get phDispatchDriver to hDispatchDriver
74800>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74801>>>>>        Function_Return retVal
74802>>>>>    End_Function
74803>>>>>End_Class
74804>>>>>
74804>>>>>// CLSID: {C0DE2200-C56F-43C0-BCF1-8193B35FE4C4}
74804>>>>>Class cCJSkinSchema is a cComAutomationObject
74805>>>>>
74805>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74807>>>>>        Handle hDispatchDriver
74807>>>>>        OLE_COLOR retVal
74807>>>>>        Get phDispatchDriver to hDispatchDriver
74808>>>>>        Send PrepareParams to hDispatchDriver 1
74809>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74810>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
74811>>>>>        Function_Return retVal
74812>>>>>    End_Function
74813>>>>>End_Class
74814>>>Use cApplication.pkg
74814>>>
74814>>>Struct tSkinInformation
74814>>>    String sName     // description of the skin
74814>>>    String sSkinfile // file path. Can be relative or full
74814>>>    String sSkinIni  // section name
74814>>>End_Struct
74814>>>
74814>>>
74814>>>Class cCJSkinFramework is a cCJComSkinFramework
74815>>>    
74815>>>    Procedure Construct_Object
74817>>>        Forward Send Construct_Object
74819>>>        
74819>>>        Property String psSkinFile ""
74820>>>        Property String psSkinIni ""
74821>>>        Property Boolean pbLoadPreference False
74822>>>        
74822>>>        Set peAutoCreate to acAutoCreate
74823>>>        
74823>>>        Move Self to ghoSkinFramework
74824>>>    End_Procedure
74825>>>    
74825>>>    // return the default skin path, which is the programs directory.
74825>>>    // This requires an application object.
74825>>>    // If you want to different skin path, override this.
74825>>>    Function SkinPath Returns String
74827>>>        String sPath sPaths
74827>>>        Handle hoWorkspace
74827>>>        If ghoApplication Begin
74829>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74830>>>            Get psProgramPath of hoWorkspace to sPaths
74831>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
74832>>>        End
74832>>>>
74832>>>        Else Begin
74833>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74834>>>>
74834>>>        End
74834>>>>
74834>>>        Function_Return sPath
74835>>>    End_Function
74836>>>    
74836>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
74836>>>    // returns itself. If it is not, it uses SkinPath to get the path.
74836>>>    Function SkinQFile Returns String
74838>>>        String sFile sPath sSep
74838>>>        Boolean bQualified
74838>>>        Get psSkinFile to sFile
74839>>>        If not (IsFileNameQualified(sFile)) Begin
74841>>>            Get SkinPath to sPath
74842>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74843>>>            Move (sPath - sSep - sFile) to sFile
74844>>>        End
74844>>>>
74844>>>        Function_Return sFile
74845>>>    End_Function
74846>>>    
74846>>>    // defines the default VDF window class mapping.
74846>>>    Procedure OnAddVDFWindowClasses
74848>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
74849>>>        Send ComAddWindowClass "DFentry"                 "Edit"
74850>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
74851>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
74852>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
74853>>>        Send ComAddWindowClass "DFformlist"              "Edit"
74854>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
74855>>>        Send ComAddWindowClass "DFbutton"                "Button"
74856>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
74857>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
74858>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
74859>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
74860>>>        Send ComAddWindowClass "DFedit"                  "edit"
74861>>>        Send ComAddWindowClass "DFlistedit"              "edit"
74862>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
74863>>>        Send ComAddWindowClass "DFgroup"                 "Button"
74864>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74865>>>        // External class
74865>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74866>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74867>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74868>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74869>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74870>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74871>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74872>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74873>>>    End_Procedure
74874>>>    
74874>>>    // Used to support developer designed class mappings (e.g. COM controls)
74874>>>    Procedure OnAddCustomWindowClasses
74876>>>    End_Procedure
74877>>>    
74877>>>    // called when object is created during end_construct_object.
74877>>>    Procedure OnCreate
74879>>>        Integer iOpts
74879>>>        Boolean bUseWindowsFont
74879>>>        Forward Send OnCreate
74881>>>        
74881>>>        // if we are using the windows fonts we will disable the apply metrics which
74881>>>        // never really looked good anyway. This test only exists or legacy purposes
74881>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74882>>>        If bUseWindowsFont Begin
74884>>>            Get ComApplyOptions to iOpts
74885>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74886>>>        End
74886>>>>
74886>>>        
74886>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74886>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74886>>>        // and this was the suggested workaround.
74886>>>        Set ComAutoApplyNewThreads to False
74887>>>        
74887>>>        Send OnAddVDFWindowClasses
74888>>>        Send OnAddCustomWindowClasses
74889>>>        
74889>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74889>>>        If (pbLoadPreference(Self)) Begin
74891>>>            Send LoadSkinPreference
74892>>>        End
74892>>>>
74892>>>        // if a skin file name exists, we apply the skin.
74892>>>        If (psSkinFile(Self)<>"") Begin
74894>>>            Send ApplySkin
74895>>>        End
74895>>>>
74895>>>    End_Procedure
74896>>>    
74896>>>    // called by framework as part of application exit.
74896>>>    Procedure Broadcast_Notify_Exit_Application
74898>>>        Send Notify_Exit_Application
74899>>>    End_Procedure
74900>>>    
74900>>>    Procedure Notify_Exit_Application
74902>>>        If (pbLoadPreference(Self)) Begin
74904>>>            Send SaveSkinPreference
74905>>>        End
74905>>>>
74905>>>    End_Procedure
74906>>>    
74906>>>    Procedure NotifyPreApplySkin
74908>>>        Broadcast Send OnPreApplySkin of Desktop True
74910>>>    End_Procedure
74911>>>    
74911>>>    Procedure NotifyPostApplySkin
74913>>>        Broadcast Send OnPostApplySkin of Desktop True
74915>>>    End_Procedure
74916>>>    
74916>>>    // returns an array of all skins in the path. If path is "", use the default path.
74916>>>    // If the default path is used, returns the file names as relative names, else use full path.
74916>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74918>>>        tSkinInformation[] Skins
74918>>>        tSkinInformation[] Skins
74919>>>        String sSkinName sSkinFile sDefaultPath sSep
74919>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74919>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74919>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74919>>>        Integer iPos iDfltLen
74919>>>        Boolean bUseRelativePath
74919>>>        
74919>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74920>>>        
74920>>>        Get SkinPath to sDefaultPath
74921>>>        If (sPath="") Begin
74923>>>            Move sDefaultPath to sPath
74924>>>        End
74924>>>>
74924>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74925>>>        Move (Length(sDefaultPath)) to iDfltLen
74926>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74927>>>        
74927>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74928>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74930>>>            
74930>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74931>>>            Get Create U_cCJSkinDescription to hSkinDescription
74932>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74933>>>            
74933>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74934>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74935>>>            
74935>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74941>>>>
74941>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74942>>>                Set pvComObject of hSkinDescription to vSkinDescription
74943>>>                
74943>>>                Get ComCount of hSkinDescription to iNumSkins
74944>>>                
74944>>>                For iSkinsCount from 0 to (iNumSkins-1)
74950>>>>
74950>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74951>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74952>>>                    
74952>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74953>>>                    Get ComPath of hSkinDescription to sSkinFile
74954>>>                    If bUseRelativePath Begin
74956>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74957>>>                        If iPos Begin
74959>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74960>>>                            While (Left(sSkinFile,1)=sSep)
74964>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74965>>>                            Loop
74966>>>>
74966>>>                        End
74966>>>>
74966>>>                    End
74966>>>>
74966>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74967>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74968>>>                    
74968>>>                    Increment iArrayItem
74969>>>                Loop
74970>>>>
74970>>>            Loop
74971>>>>
74971>>>            
74971>>>            Send Destroy of hSkinDescriptions
74972>>>            Send Destroy of hSkinDescription
74973>>>            Send Destroy of hSkinIniFile
74974>>>            
74974>>>        End
74974>>>>
74974>>>        Function_Return Skins
74975>>>    End_Function
74976>>>    
74976>>>    // Save the skin preference. This requires an application object.
74976>>>    // Only do this if the application object allows it.
74976>>>    // This is called during startup if pbLoadPreference is True
74976>>>    // Suitable for override
74976>>>    Procedure SaveSkinPreference
74978>>>        String sSkin sIni
74978>>>        If ghoApplication Begin
74980>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74982>>>                Get psSkinFile to sSkin
74983>>>                Get psSkinIni to sIni
74984>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74985>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74986>>>            End
74986>>>>
74986>>>        End
74986>>>>
74986>>>        Else Begin
74987>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74988>>>>
74988>>>        End
74988>>>>
74988>>>    End_Procedure
74989>>>    
74989>>>    // Load the skin preference. This requires an application object.
74989>>>    // Only do this if the application object allows it.
74989>>>    // This is called during startup if pbLoadPreference is True
74989>>>    // Suitable for override
74989>>>    Procedure LoadSkinPreference
74991>>>        String sSkin sIni
74991>>>        Boolean bExists
74991>>>        If ghoApplication Begin
74993>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74995>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74996>>>                If bExists Begin
74998>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74999>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
75000>>>                    Set psSkinFile to sSkin
75001>>>                    Set psSkinIni to sIni
75002>>>                End
75002>>>>
75002>>>            End
75002>>>>
75002>>>        End
75002>>>>
75002>>>        Else Begin
75003>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
75004>>>>
75004>>>        End
75004>>>>
75004>>>    End_Procedure
75005>>>    
75005>>>    // Can be called to apply the current skin.
75005>>>    Procedure ApplySkin
75007>>>        Boolean bOk
75007>>>        String sSkin sIni
75007>>>        If (IsComObjectCreated(Self)) Begin
75009>>>            Get SkinQFile to sSkin
75010>>>            Get psSkinIni to sIni
75011>>>            
75011>>>            Send NotifyPreApplySkin
75012>>>            // when skins are used we don't want to use built in Visual Styles
75012>>>            Send EnableVisualStyles of Desktop (sSkin="")
75013>>>            Get ComLoadSkin sSkin sIni to bOK
75014>>>            If (sSkin<>"" and not(bOk)) Begin
75016>>>                // if not ok, no skin was appied. Enable visual styles
75016>>>                Send EnableVisualStyles of Desktop True
75017>>>            End
75017>>>>
75017>>>            Send NotifyPostApplySkin
75018>>>        End
75018>>>>
75018>>>    End_Procedure
75019>>>    
75019>>>    
75019>>>End_Class
75020>Use cCJCommandBarSystem.pkg                      
75020>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
75020>>>//****************************************************************************
75020>>>// $Module type: Class
75020>>>// $Module name: cSQLConnectionIniFile.pkg
75020>>>//
75020>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
75020>>>// Copyright (c) 2012 RDC Tools International
75020>>>// E-mail      : support@rdctools.com
75020>>>// Web-site    : http://www.rdctools.com
75020>>>//
75020>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
75020>>>//
75020>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
75020>>>//               properties of that object.
75020>>>//
75020>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
75020>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
75020>>>// This is free software; you can redistribute it and/or modify it under the terms of the
75020>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
75020>>>// in the help folder for more details.
75020>>>//
75020>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
75020>>>>>//****************************************************************************
75020>>>>>// $Module type: Include file
75020>>>>>// $Module name: cSQLConnectionIniFile.inc
75020>>>>>//
75020>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
75020>>>>>// Copyright (c) 2012 RDC Tools International
75020>>>>>// E-mail      : support@rdctools.com
75020>>>>>// Web-site    : http://www.rdctools.com
75020>>>>>//
75020>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
75020>>>>>//
75020>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
75020>>>>>//
75020>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
75020>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
75020>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
75020>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
75020>>>>>// in the help folder for more details.
75020>>>>>//
75020>>>>>Use Winkern.pkg
75020>>>>>Use cIniFile.pkg
75020>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCryptographerEx.pkg)
75020>>>>>>>Use VdfBase.pkg
75020>>>>>>>
75020>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 23.0\Pkg\CryptographerConstants.pkg)
75020>>>>>>>>>//   Author  : Ulbe Stellema
75020>>>>>>>>>// Algorithm classes
75020>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
75020>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
75020>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
75020>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
75020>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
75020>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
75020>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
75020>>>>>>>>>
75020>>>>>>>>>// Algorithm types
75020>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
75020>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
75020>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
75020>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
75020>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
75020>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
75020>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
75020>>>>>>>>>
75020>>>>>>>>>// Generic sub-ids
75020>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
75020>>>>>>>>>
75020>>>>>>>>>// RSA sub-ids
75020>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
75020>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
75020>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
75020>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
75020>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
75020>>>>>>>>>
75020>>>>>>>>>// DSS sub-ids
75020>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
75020>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
75020>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
75020>>>>>>>>>
75020>>>>>>>>>// DES sub_ids
75020>>>>>>>>>Define ALG_SID_DES                      for 1
75020>>>>>>>>>Define ALG_SID_3DES                     for 3
75020>>>>>>>>>Define ALG_SID_DESX                     for 4
75020>>>>>>>>>Define ALG_SID_IDEA                     for 5
75020>>>>>>>>>Define ALG_SID_CAST                     for 6
75020>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
75020>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
75020>>>>>>>>>Define ALG_SID_3DES_112                 for 9
75020>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
75020>>>>>>>>>Define ALG_SID_RC5                      for 13
75020>>>>>>>>>Define ALG_SID_AES_128                  for 14
75020>>>>>>>>>Define ALG_SID_AES_192                  for 15
75020>>>>>>>>>Define ALG_SID_AES_256                  for 16
75020>>>>>>>>>Define ALG_SID_AES                      for 17
75020>>>>>>>>>
75020>>>>>>>>>// Fortezza sub-ids
75020>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
75020>>>>>>>>>Define ALG_SID_TEK                      for 11
75020>>>>>>>>>
75020>>>>>>>>>// RC2 sub-ids
75020>>>>>>>>>Define ALG_SID_RC2                      for 2
75020>>>>>>>>>
75020>>>>>>>>>// Stream cipher sub-ids
75020>>>>>>>>>Define ALG_SID_RC4                      for 1
75020>>>>>>>>>Define ALG_SID_SEAL                     for 2
75020>>>>>>>>>
75020>>>>>>>>>// Diffie-Hellman sub-ids
75020>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
75020>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
75020>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
75020>>>>>>>>>Define ALG_SID_KEA                      for 4
75020>>>>>>>>>
75020>>>>>>>>>// Hash sub ids
75020>>>>>>>>>Define ALG_SID_MD2                      for 1
75020>>>>>>>>>Define ALG_SID_MD4                      for 2
75020>>>>>>>>>Define ALG_SID_MD5                      for 3
75020>>>>>>>>>Define ALG_SID_SHA                      for 4
75020>>>>>>>>>Define ALG_SID_SHA1                     for 4
75020>>>>>>>>>Define ALG_SID_MAC                      for 5
75020>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
75020>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
75020>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
75020>>>>>>>>>Define ALG_SID_HMAC                     for 9
75020>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
75020>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
75020>>>>>>>>>Define ALG_SID_SHA_256                  for 12
75020>>>>>>>>>Define ALG_SID_SHA_384                  for 13
75020>>>>>>>>>Define ALG_SID_SHA_512                  for 14
75020>>>>>>>>>
75020>>>>>>>>>// secure channel sub ids
75020>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
75020>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
75020>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
75020>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
75020>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
75020>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
75020>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
75020>>>>>>>>>
75020>>>>>>>>>// algorithm identifier definitions
75020>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
75020>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
75020>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
75020>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
75020>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
75020>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
75020>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
75020>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
75020>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
75020>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
75020>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
75020>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
75020>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
75020>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
75020>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
75020>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
75020>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
75020>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
75020>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
75020>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
75020>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
75020>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
75020>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
75020>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
75020>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
75020>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
75020>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
75020>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
75020>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
75020>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
75020>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
75020>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
75020>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
75020>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
75020>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
75020>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
75020>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
75020>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
75020>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
75020>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
75020>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
75020>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
75020>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
75020>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
75020>>>>>>>>>
75020>>>>>>>>>// Providers
75020>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
75020>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
75020>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
75020>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
75020>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
75020>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
75020>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
75020>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
75020>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
75020>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
75020>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
75020>>>>>>>>>
75020>>>>>>>>>// dwFlags definitions for CryptAcquireContext
75020>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
75020>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
75020>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
75020>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
75020>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
75020>>>>>>>>>
75020>>>>>>>>>// dwFlag definitions for CryptGenKey
75020>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
75020>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
75020>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
75020>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
75020>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
75020>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
75020>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
75020>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
75020>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
75020>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
75020>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
75020>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
75020>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
75020>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
75020>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
75020>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
75020>>>>>>>>>
75020>>>>>>>>>// Provider types
75020>>>>>>>>>Define PROV_RSA_FULL                    for 1
75020>>>>>>>>>Define PROV_RSA_SIG                     for 2
75020>>>>>>>>>Define PROV_DSS                         for 3
75020>>>>>>>>>Define PROV_FORTEZZA                    for 4
75020>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
75020>>>>>>>>>Define PROV_SSL                         for 6
75020>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
75020>>>>>>>>>Define PROV_DSS_DH                      for 13
75020>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
75020>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
75020>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
75020>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
75020>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
75020>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
75020>>>>>>>>>Define PROV_RNG                         for 21
75020>>>>>>>>>Define PROV_INTEL_SEC                   for 22
75020>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
75020>>>>>>>>>Define PROV_RSA_AES                     for 24
75020>>>>>>>>>
75020>>>>>>>>>// KP_MODE
75020>>>>>>>>>// KP_MODE
75020>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
75020>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
75020>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
75020>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
75020>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
75020>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
75020>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
75020>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
75020>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
75020>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
75020>>>>>>>>>
75020>>>>>>>>>// dwParam definitions for CryptGetKeyParam
75020>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
75020>>>>>>>>>Define KP_SALT                          for 2       // Salt value
75020>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
75020>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
75020>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
75020>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
75020>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
75020>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
75020>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
75020>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
75020>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
75020>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
75020>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
75020>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
75020>>>>>>>>>Define KP_Y                             for 15      // Y value
75020>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
75020>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
75020>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
75020>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
75020>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
75020>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
75020>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
75020>>>>>>>>>Define KP_RP                            for 23
75020>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
75020>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
75020>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
75020>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
75020>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
75020>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
75020>>>>>>>>>Define KP_KEYVAL                        for 30
75020>>>>>>>>>Define KP_ADMIN_PIN                     for 31
75020>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
75020>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
75020>>>>>>>>>Define KP_PREHASH                       for 34
75020>>>>>>>>>Define KP_ROUNDS                        for 35
75020>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
75020>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
75020>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
75020>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
75020>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
75020>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
75020>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
75020>>>>>>>>>
75020>>>>>>>>>// dwParam definitions for CryptGetHashParam
75020>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
75020>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
75020>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
75020>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
75020>>>>>>>>>
75020>>>>>>>>>// key BLOB types
75020>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
75020>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
75020>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
75020>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
75020>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
75020>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
75020>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
75020>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
75020>>>>>>>>>
75020>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
75020>>>>>>>>>
75020>>>>>>>>>// KP_PADDING
75020>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
75020>>>>>>>>>Define RANDOM_PADDING                   for 2
75020>>>>>>>>>Define ZERO_PADDING                     for 3
75020>>>>>>>>>
75020>>>>>>>>>//  Structure cryptimportkey
75020>>>>>>>>>Struct PUBLICKEYSTRUC
75020>>>>>>>>>    UChar    bType
75020>>>>>>>>>    UChar    bVersion
75020>>>>>>>>>    UShort   reserved
75020>>>>>>>>>    UInteger aiKeyAlg
75020>>>>>>>>>End_Struct
75020>>>>>>>>>
75020>>>>>>>>>Struct tPLAINTEXTKEYBLOB
75020>>>>>>>>>    PUBLICKEYSTRUC hdr
75020>>>>>>>>>    PUBLICKEYSTRUC hdr
75020>>>>>>>>>    UInteger       dwKeySize
75020>>>>>>>>>//    UChar[]        rgbKeyData
75020>>>>>>>>>End_Struct
75020>>>>>>>>>
75020>>>>>>>>>
75020>>>>>>>>>
75020>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
75020>>>>>>>>>Struct HMAC_INFO
75020>>>>>>>>>    UInteger HashAlgid
75020>>>>>>>>>    Pointer pbInnerString
75020>>>>>>>>>    DWord cbInnerString
75020>>>>>>>>>    Pointer pbOuterString
75020>>>>>>>>>    DWord cbOuterString
75020>>>>>>>>>End_Struct
75020>>>>>>>>>
75020>>>>>>>>>Struct BLOBHEADER
75020>>>>>>>>>    UChar   bType
75020>>>>>>>>>    UChar   bVersion
75020>>>>>>>>>    Short   reserved
75020>>>>>>>>>    Integer aiKeyAlg
75020>>>>>>>>>End_Struct
75020>>>>>>>>>
75020>>>>>>>>>Struct CryptoBlob
75020>>>>>>>>>    BLOBHEADER  header
75020>>>>>>>>>    BLOBHEADER  header
75020>>>>>>>>>    Integer     cbKeySize
75020>>>>>>>>>    UChar[32]   rgbKeyData
75020>>>>>>>>>End_Struct
75020>>>>>>>>>
75020>>>>>>>>>
75020>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
75020>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
75021>>>>>>>>>
75021>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
75021>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
75023>>>>>>>>>    
75023>>>>>>>>>    Boolean bResult
75023>>>>>>>>>    UWide   uwContainer uwProvider
75023>>>>>>>>>    UWide   uwContainer uwProvider
75023>>>>>>>>>
75023>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
75024>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
75025>>>>>>>>>    
75025>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
75026>>>>>>>>>
75026>>>>>>>>>    Function_Return bResult
75027>>>>>>>>>End_Function
75028>>>>>>>>>
75028>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
75029>>>>>>>>>
75029>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
75030>>>>>>>>>
75030>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
75031>>>>>>>>>
75031>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
75032>>>>>>>>>
75032>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
75033>>>>>>>>>
75033>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
75034>>>>>>>>>
75034>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
75035>>>>>>>>>
75035>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
75036>>>>>>>>>
75036>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
75037>>>>>>>>>    
75037>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
75038>>>>>>>>>
75038>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
75039>>>>>>>>>
75039>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
75040>>>>>>>>>
75040>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
75041>>>>>>>>>    
75041>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
75042>>>>>>>>>    
75042>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
75043>>>>>>>>>    
75043>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
75044>>>>>>>
75044>>>>>>>Class cCryptographerEx is a cObject
75045>>>>>>>    
75045>>>>>>>    Procedure Construct_Object
75047>>>>>>>        Forward Send Construct_Object
75049>>>>>>>        
75049>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
75050>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
75051>>>>>>>        Property Integer    piCipher    CALG_RC4
75052>>>>>>>        Property Integer    piHash      CALG_MD5
75053>>>>>>>        
75053>>>>>>>        // Private properties
75053>>>>>>>        Property Handle     Private_phProv
75054>>>>>>>        
75054>>>>>>>        // Block cipher properties
75054>>>>>>>        Property UChar[]    paKey
75055>>>>>>>        Property UChar[]    paIV
75056>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
75057>>>>>>>        Property Integer    piKeyType       CALG_AES_256
75058>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
75059>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
75060>>>>>>>        Property Integer    piBlockSize     16
75061>>>>>>>    End_Procedure
75062>>>>>>>    
75062>>>>>>>    
75062>>>>>>>    // Acquire key container handle
75062>>>>>>>    Function AcquireContext Returns Handle
75064>>>>>>>        Integer iProvider
75064>>>>>>>        WString wProvider
75064>>>>>>>        Handle hProv
75064>>>>>>>        Boolean bOk
75064>>>>>>>        Pointer pProv
75064>>>>>>>        
75064>>>>>>>        Move 0 to hProv
75065>>>>>>>        Get piProvider to iProvider
75066>>>>>>>        Get psProvider to wProvider
75067>>>>>>>        
75067>>>>>>>        //  Determine address to be passed as provider
75067>>>>>>>        If (Trim(wProvider) <> "") Begin
75069>>>>>>>            Move (AddressOf(wProvider)) to pProv
75070>>>>>>>        End
75070>>>>>>>>
75070>>>>>>>        Else Begin
75071>>>>>>>            Move 0 to pProv
75072>>>>>>>        End
75072>>>>>>>>
75072>>>>>>>        
75072>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
75072>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
75073>>>>>>>        If (not(bOk) or hProv = 0) Begin
75075>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
75076>>>>>>>        End
75076>>>>>>>>
75076>>>>>>>        
75076>>>>>>>        If (not(bOk) or hProv = 0) Begin
75078>>>>>>>            // Fallback to original
75078>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
75079>>>>>>>            
75079>>>>>>>            If (not(bOk) or hProv = 0) Begin
75081>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
75082>>>>>>>            End
75082>>>>>>>>
75082>>>>>>>        End
75082>>>>>>>>
75082>>>>>>>        Set Private_phProv to hProv
75083>>>>>>>        
75083>>>>>>>        Function_Return hProv
75084>>>>>>>    End_Function
75085>>>>>>>    
75085>>>>>>>    // Releases key container handle
75085>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
75087>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
75088>>>>>>>    End_Function
75089>>>>>>>    
75089>>>>>>>    // Creates hash object
75089>>>>>>>    Function CreateHash Handle hProv Returns Handle
75091>>>>>>>        Integer iAlgorithm
75091>>>>>>>        Handle hHash
75091>>>>>>>        Boolean bOk
75091>>>>>>>        
75091>>>>>>>        Move 0 to hHash
75092>>>>>>>        Get piHash to iAlgorithm
75093>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
75094>>>>>>>        
75094>>>>>>>        Function_Return hHash
75095>>>>>>>    End_Function
75096>>>>>>>    
75096>>>>>>>    // Destroys the hash object
75096>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
75098>>>>>>>        Function_Return (CryptDestroyHash(hHash))
75099>>>>>>>    End_Function
75100>>>>>>>    
75100>>>>>>>    // Adds data to hash object
75100>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
75102>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
75103>>>>>>>    End_Function
75104>>>>>>>    
75104>>>>>>>    // Generates session key
75104>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
75106>>>>>>>        Integer iAlgorithm
75106>>>>>>>        Handle hKey
75106>>>>>>>        Boolean bOk
75106>>>>>>>        
75106>>>>>>>        Move 0 to hKey
75107>>>>>>>        Get piCipher to iAlgorithm
75108>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
75109>>>>>>>        
75109>>>>>>>        Function_Return hKey
75110>>>>>>>    End_Function
75111>>>>>>>    
75111>>>>>>>    // Imports a plain text key
75111>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
75113>>>>>>>        tPLAINTEXTKEYBLOB blobhead
75113>>>>>>>        tPLAINTEXTKEYBLOB blobhead
75113>>>>>>>        Boolean   bSuccess
75113>>>>>>>        Handle    hKey
75113>>>>>>>        Integer   iHeadSize iKeySize
75113>>>>>>>        UChar[]   ucaKeyblob
75114>>>>>>>        Integer iVoid
75114>>>>>>>        
75114>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
75115>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
75116>>>>>>>        
75116>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
75117>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
75118>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
75119>>>>>>>        Move iKeySize           to blobhead.dwKeySize
75120>>>>>>>        
75120>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
75121>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
75122>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
75123>>>>>>>        
75123>>>>>>>        Move 0 to hKey
75124>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
75125>>>>>>>        If (not(bSuccess)) Begin
75127>>>>>>>            Move (ShowLastError()) to iVoid
75128>>>>>>>        End
75128>>>>>>>>
75128>>>>>>>        
75128>>>>>>>        Function_Return hKey
75129>>>>>>>    End_Function
75130>>>>>>>    
75130>>>>>>>    // Destroys the key
75130>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
75132>>>>>>>        Function_Return (CryptDestroyKey(hKey))
75133>>>>>>>    End_Function
75134>>>>>>>    
75134>>>>>>>    // Retrieves key data
75134>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
75136>>>>>>>        Integer iBuffer iLen
75136>>>>>>>        Boolean bOk
75136>>>>>>>        
75136>>>>>>>        Move (SizeOfType(Integer)) to iLen
75137>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
75138>>>>>>>        Function_Return iBuffer
75139>>>>>>>    End_Function
75140>>>>>>>    
75140>>>>>>>    // Retrieves a hash value
75140>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
75142>>>>>>>        UChar[] ucHash
75143>>>>>>>        Integer liResult
75143>>>>>>>        DWord   dwDataLen
75143>>>>>>>        
75143>>>>>>>        Move 0 to dwDataLen
75144>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
75145>>>>>>>        If (liResult = 0) ;            Function_Return ""
75148>>>>>>>        
75148>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
75149>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
75150>>>>>>>        If (liResult = 0) ;            Function_Return ""
75153>>>>>>>        
75153>>>>>>>        Function_Return ucHash
75154>>>>>>>    End_Function
75155>>>>>>>
75155>>>>>>>    // Encrypts data
75155>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
75157>>>>>>>        Handle hProv hHash hKey
75157>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
75157>>>>>>>        Boolean bOk
75157>>>>>>>        
75157>>>>>>>        Get AcquireContext to hProv
75158>>>>>>>        If (hProv) Begin
75160>>>>>>>            Get CreateHash hProv to hHash
75161>>>>>>>            If (hHash) Begin
75163>>>>>>>                Get HashData hHash ucPassword to bOk
75164>>>>>>>                If (bOk) Begin
75166>>>>>>>                    Get piCipher to iAlgorithm
75167>>>>>>>                    Get DeriveKey hProv hHash to hKey
75168>>>>>>>                End
75168>>>>>>>>
75168>>>>>>>                Get DestroyHash hHash to bOk
75169>>>>>>>            End
75169>>>>>>>>
75169>>>>>>>            
75169>>>>>>>            If (hKey) Begin
75171>>>>>>>                //  First call to determine resulting data size
75171>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
75172>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
75173>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
75174>>>>>>>                
75174>>>>>>>                //  Reserve space in string
75174>>>>>>>                If (iDataLen < iCipherLen) Begin
75176>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
75177>>>>>>>                End
75177>>>>>>>>
75177>>>>>>>                
75177>>>>>>>                //  Call to really decrypt
75177>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
75178>>>>>>>                //If (not(bOk)) Begin
75178>>>>>>>                //Move "" to sData
75178>>>>>>>                //Move (GetLastError()) to iErr
75178>>>>>>>                //End
75178>>>>>>>                
75178>>>>>>>                Get DestroyKey hKey to bOk
75179>>>>>>>            End 
75179>>>>>>>>
75179>>>>>>>            Get ReleaseContext hProv to bOk
75180>>>>>>>        End 
75180>>>>>>>>
75180>>>>>>>        Function_Return ucData
75181>>>>>>>    End_Function
75182>>>>>>>    
75182>>>>>>>    // Decrypts data
75182>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
75184>>>>>>>        Handle hProv hHash hKey
75184>>>>>>>        Integer iAlgorithm iDataLen
75184>>>>>>>        Boolean bOk
75184>>>>>>>        
75184>>>>>>>        Get AcquireContext to hProv
75185>>>>>>>        If (hProv) Begin
75187>>>>>>>            Get CreateHash hProv to hHash
75188>>>>>>>            If (hHash) Begin
75190>>>>>>>                Get HashData hHash ucPassword to bOk
75191>>>>>>>                If (bOk) Begin
75193>>>>>>>                    Get piCipher to iAlgorithm
75194>>>>>>>                    Get DeriveKey hProv hHash to hKey
75195>>>>>>>                End
75195>>>>>>>>
75195>>>>>>>                Get DestroyHash hHash to bOk
75196>>>>>>>            End
75196>>>>>>>>
75196>>>>>>>            
75196>>>>>>>            If (hKey) Begin
75198>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
75199>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
75200>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
75200>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
75202>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
75203>>>>>>>                End
75203>>>>>>>>
75203>>>>>>>                
75203>>>>>>>                Get DestroyKey hKey to bOk
75204>>>>>>>            End
75204>>>>>>>>
75204>>>>>>>            Get ReleaseContext hProv to bOk
75205>>>>>>>        End
75205>>>>>>>>
75205>>>>>>>        Function_Return ucData
75206>>>>>>>    End_Function
75207>>>>>>>    
75207>>>>>>>    // Creates a key
75207>>>>>>>    Function CreateKey Handle hProv Returns Handle
75209>>>>>>>        Integer iAlg iType iByte iLength iSize
75209>>>>>>>        CryptoBlob keyBlob
75209>>>>>>>        CryptoBlob keyBlob
75209>>>>>>>        Boolean bOk
75209>>>>>>>        Handle hKey
75209>>>>>>>        UChar[] aKey
75210>>>>>>>
75210>>>>>>>        Get paKey to aKey
75211>>>>>>>        Get piKeyAlg to iAlg
75212>>>>>>>        Get piKeyType to iType
75213>>>>>>>        Move iAlg                   to keyBlob.header.bType
75214>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
75215>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
75216>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
75217>>>>>>>        
75217>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
75218>>>>>>>        For iByte from 0 to iLength
75224>>>>>>>>
75224>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
75225>>>>>>>        Loop
75226>>>>>>>>
75226>>>>>>>        
75226>>>>>>>        Move 0 to hKey
75227>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
75228>>>>>>>        Function_Return hKey
75229>>>>>>>    End_Function
75230>>>>>>>    
75230>>>>>>>    // Sets the key parameters
75230>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
75232>>>>>>>        Integer iPadding iMode
75232>>>>>>>        Boolean bOk
75232>>>>>>>        UChar[] aIV
75233>>>>>>>        
75233>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
75233>>>>>>>        //For iByte from 0 to iLength
75233>>>>>>>        //    Move iByte to aIV[iByte]
75233>>>>>>>        //Loop
75233>>>>>>>
75233>>>>>>>        // Set initialization vector
75233>>>>>>>        Get paIV to aIV
75234>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
75235>>>>>>>        If (bOk) Begin
75237>>>>>>>            // Set padding
75237>>>>>>>            Get piKeyPadding to iPadding
75238>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
75239>>>>>>>            If (bOk) Begin
75241>>>>>>>                // Set move
75241>>>>>>>                Get piKeyMode to iMode
75242>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
75243>>>>>>>            End
75243>>>>>>>>
75243>>>>>>>        End
75243>>>>>>>>
75243>>>>>>>        Function_Return bOk        
75244>>>>>>>    End_Function
75245>>>>>>>    
75245>>>>>>>    // Encrypts using block cipher
75245>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
75247>>>>>>>        Handle hProv hKey
75247>>>>>>>        Integer iLen iSize iBlocks
75247>>>>>>>        Boolean bOk
75247>>>>>>>        
75247>>>>>>>        Get AcquireContext to hProv
75248>>>>>>>        If (hProv) Begin
75250>>>>>>>            // Create key
75250>>>>>>>            Get CreateKey hProv to hKey
75251>>>>>>>            If (hKey) Begin
75253>>>>>>>                Get SetKeyParameters hKey to bOk
75254>>>>>>>                If (bOk) Begin
75256>>>>>>>                    // Buffer for block ciphers can be up to block length larger
75256>>>>>>>                    Get piBlockSize to iSize
75257>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
75258>>>>>>>                    
75258>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
75259>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
75260>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
75261>>>>>>>                End
75261>>>>>>>>
75261>>>>>>>                Get DestroyKey hKey to bOk
75262>>>>>>>            End
75262>>>>>>>>
75262>>>>>>>            Get ReleaseContext hProv to bOk
75263>>>>>>>        End
75263>>>>>>>>
75263>>>>>>>        Function_Return ucData
75264>>>>>>>    End_Function
75265>>>>>>>    
75265>>>>>>>    // Decrypts using block cipher
75265>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
75267>>>>>>>        Handle hProv hKey
75267>>>>>>>        Integer iLen
75267>>>>>>>        Boolean bOk
75267>>>>>>>        
75267>>>>>>>        Get AcquireContext to hProv
75268>>>>>>>        If (hProv) Begin
75270>>>>>>>            // Create key
75270>>>>>>>            Get CreateKey hProv to hKey
75271>>>>>>>            If (hKey) Begin
75273>>>>>>>                Get SetKeyParameters hKey to bOk
75274>>>>>>>                If (bOk) Begin
75276>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
75277>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
75278>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
75279>>>>>>>                End
75279>>>>>>>>
75279>>>>>>>                Get DestroyKey hKey to bOk
75280>>>>>>>            End
75280>>>>>>>>
75280>>>>>>>            Get ReleaseContext hProv to bOk
75281>>>>>>>        End
75281>>>>>>>>
75281>>>>>>>        Function_Return ucData
75282>>>>>>>    End_Function
75283>>>>>>>    
75283>>>>>>>    
75283>>>>>>>    //  Generates random data.
75283>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
75285>>>>>>>        Handle hProv
75285>>>>>>>        UChar[] uaResult
75286>>>>>>>        Boolean bRes
75286>>>>>>>        
75286>>>>>>>        Get AcquireContext to hProv
75287>>>>>>>        
75287>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
75288>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
75289>>>>>>>        
75289>>>>>>>        Get ReleaseContext hProv to bRes
75290>>>>>>>        
75290>>>>>>>        Function_Return uaResult
75291>>>>>>>    End_Function
75292>>>>>>>    
75292>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
75292>>>>>>>    Function GenerateRandomString Integer iLength Returns String
75294>>>>>>>        String sResult
75294>>>>>>>        UChar[] ucData
75295>>>>>>>        Pointer pBase64
75295>>>>>>>        Integer iVoid
75295>>>>>>>        
75295>>>>>>>        Get GenerateRandom iLength to ucData
75296>>>>>>>        
75296>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
75297>>>>>>>        Move (PointerToString(pBase64)) to sResult
75298>>>>>>>        Move (Free(pBase64)) to iVoid
75299>>>>>>>        
75299>>>>>>>        Function_Return (Left(sResult, iLength))
75300>>>>>>>    End_Function
75301>>>>>>>    
75301>>>>>>>End_Class
75302>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
75302>>>>>>>//> This package enables base64 encoding and decoding of strings:
75302>>>>>>>//>
75302>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
75302>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
75302>>>>>>>//>
75302>>>>>>>//> Remember to set the "max argument size" if dealing with very large
75302>>>>>>>//> strings.
75302>>>>>>>//>
75302>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
75302>>>>>>>//> Base64Decode) that are built into the runtime.
75302>>>>>>>//>
75302>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
75302>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
75302>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
75302>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
75302>>>>>>>
75302>>>>>>>Use VdfBase.pkg
75302>>>>>>>
75302>>>>>>>// Functions in vdfBase64.dll
75302>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
75303>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
75304>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
75305>>>>>>>
75305>>>>>>>// Structure
75305>>>>>>>Struct txxfBase64Buffer
75305>>>>>>>    Pointer pData
75305>>>>>>>    Integer iLength
75305>>>>>>>End_Struct 
75305>>>>>>>
75305>>>>>>>Global_Variable Integer oBase64Functions
75305>>>>>>>
75305>>>>>>>Object _oBase64Functions is a cObject
75307>>>>>>>    Move Self to oBase64Functions
75308>>>>>>>
75308>>>>>>>
75308>>>>>>>    Function EncodeString String sValue Returns String
75311>>>>>>>        Address pBase64
75311>>>>>>>        String sResult
75311>>>>>>>        Integer iVoid
75311>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
75312>>>>>>>        Move (PointerToString(pBase64)) to sResult
75313>>>>>>>        Move (Free(pBase64)) to iVoid
75314>>>>>>>        Function_Return sResult
75315>>>>>>>    End_Function
75316>>>>>>>
75316>>>>>>>    Function DecodeString String sValue Returns String
75319>>>>>>>        Address pBinary
75319>>>>>>>        String sBinary
75319>>>>>>>        Integer iVoid iLen
75319>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
75320>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
75321>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
75322>>>>>>>        Move (Free(pBinary)) to iVoid
75323>>>>>>>        Function_Return sBinary
75324>>>>>>>    End_Function
75325>>>>>>>
75325>>>>>>>End_Object
75326>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\MSSqldrv.pkg)
75326>>>>>>>//     Package that declares MS SQL driver constants and functions.
75326>>>>>>>//     This package can be used by developers who want to add Data Access
75326>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75326>>>>>>>
75326>>>>>>>Use Cli.pkg
75326>>>>>>>Use SQL.pkg
75326>>>>>>>
75326>>>>>>>//   Driver Indentification
75326>>>>>>>
75326>>>>>>>//   Error number constants
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>// SQL Server spcific types.
75326>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75326>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75326>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75326>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75326>>>>>>>
75326>>>>>>>// SQL Server spcific types.
75326>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75326>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75326>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75326>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75326>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75326>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75326>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75326>>>>>>>//
75326>>>>>>>//     Setup a constraint for a file.
75326>>>>>>>
75326>>>>>>>
75326>>>>>>>Class cMSSQLHandler is a cCLIHandler
75327>>>>>>>    
75327>>>>>>>    Procedure Construct_Object
75329>>>>>>>        Forward Send Construct_Object
75331>>>>>>>        
75331>>>>>>>        Set psDriverID to MSSQLDRV_ID
75332>>>>>>>    End_Procedure
75333>>>>>>>    
75333>>>>>>>    
75333>>>>>>>    
75333>>>>>>>    //   Extract the list from the out connect string.
75333>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75335>>>>>>>        String  sItem
75335>>>>>>>        Integer iStart
75335>>>>>>>        Integer iEnd
75335>>>>>>>        
75335>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75338>>>>>>>        
75338>>>>>>>        Send Delete_Data to hoStore
75339>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75340>>>>>>>        While (iStart > 0)
75344>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75345>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75348>>>>>>>            Else Begin
75349>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75350>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75351>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75354>>>>>>>                
75354>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75357>>>>>>>                
75357>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75360>>>>>>>            End
75360>>>>>>>>
75360>>>>>>>        Loop
75361>>>>>>>>
75361>>>>>>>        
75361>>>>>>>        Function_Return (Item_Count(hoStore))
75362>>>>>>>    End_Procedure
75363>>>>>>>    
75363>>>>>>>    
75363>>>>>>>    
75363>>>>>>>    //   Call the driver's browse connect function
75363>>>>>>>    Function BrowseConnect String sInConnStr Returns String
75365>>>>>>>        String  sDriver
75365>>>>>>>        String  sOutConnStr
75365>>>>>>>        Integer iArg
75365>>>>>>>        Integer iRetval
75365>>>>>>>        
75365>>>>>>>        Get psDriverID to sDriver
75366>>>>>>>        If (sDriver <> "") Begin
75368>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75369>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75374>>>>>>>        End
75374>>>>>>>>
75374>>>>>>>        
75374>>>>>>>        Function_Return sOutConnStr
75375>>>>>>>    End_Function// BrowseConnect
75376>>>>>>>    
75376>>>>>>>    
75376>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
75378>>>>>>>        String  sDriver
75378>>>>>>>        String  sOutConnStr
75378>>>>>>>        Integer iArg
75378>>>>>>>        Integer iRetval
75378>>>>>>>        
75378>>>>>>>        Move 1 to iArg // Browses only local
75379>>>>>>>        
75379>>>>>>>        Get psDriverID to sDriver
75380>>>>>>>        If (sDriver <> "") Begin
75382>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75383>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75388>>>>>>>        End
75388>>>>>>>>
75388>>>>>>>        
75388>>>>>>>        Function_Return sOutConnStr
75389>>>>>>>    End_Function// BrowseConnect
75390>>>>>>>    
75390>>>>>>>    
75390>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
75392>>>>>>>        
75392>>>>>>>        String  sServerList
75392>>>>>>>        Integer iNumServers
75392>>>>>>>        Integer iDriver
75392>>>>>>>        Integer iClientVersion
75392>>>>>>>        String  sDriver
75392>>>>>>>        
75392>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75393>>>>>>>        
75393>>>>>>>        If (iDriver) Begin
75395>>>>>>>            
75395>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75398>>>>>>>            
75398>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
75399>>>>>>>            
75399>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
75400>>>>>>>            If (iNetworkLocal = 0) Begin
75402>>>>>>>                Get BrowseConnect sDriver to sServerList
75403>>>>>>>            End
75403>>>>>>>>
75403>>>>>>>            Else Begin
75404>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
75405>>>>>>>            End
75405>>>>>>>>
75405>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
75406>>>>>>>        End
75406>>>>>>>>
75406>>>>>>>        
75406>>>>>>>        Function_Return iNumServers
75407>>>>>>>        
75407>>>>>>>    End_Function
75408>>>>>>>    
75408>>>>>>>    //   Enumerate the available SQL Server database servers
75408>>>>>>>    //   This function will return all SQL Server instances on the network.
75408>>>>>>>    //   This may take a long time.
75408>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
75408>>>>>>>    Function EnumerateServers Returns Integer
75410>>>>>>>        
75410>>>>>>>        Integer iNumServers
75410>>>>>>>        Integer iNetworkLocal
75410>>>>>>>        
75410>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
75411>>>>>>>        
75411>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75412>>>>>>>        
75412>>>>>>>        Function_Return iNumServers
75413>>>>>>>        
75413>>>>>>>    End_Function
75414>>>>>>>    
75414>>>>>>>    
75414>>>>>>>    //   Enumerate the available SQL Server database servers
75414>>>>>>>    //   This function will return only return SQL Server instance on the local machine
75414>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
75414>>>>>>>    Function EnumerateServersLocal Returns Integer
75416>>>>>>>        
75416>>>>>>>        Integer iNumServers
75416>>>>>>>        Integer iNetworkLocal
75416>>>>>>>        
75416>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
75417>>>>>>>        
75417>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75418>>>>>>>        
75418>>>>>>>        Function_Return iNumServers
75419>>>>>>>        
75419>>>>>>>    End_Function
75420>>>>>>>    
75420>>>>>>>    
75420>>>>>>>    
75420>>>>>>>    //   Enumerate database in a given server.
75420>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
75422>>>>>>>        Integer hoSQL
75422>>>>>>>        String  sConnect
75422>>>>>>>        String  sDatabase
75422>>>>>>>        Integer hdbc
75422>>>>>>>        Integer hstmt
75422>>>>>>>        Integer iFetchResult
75422>>>>>>>        
75422>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
75425>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
75428>>>>>>>        
75428>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
75431>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
75433>>>>>>>        
75433>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
75435>>>>>>>            Move Current_Object to hoSQL
75436>>>>>>>        End_Object
75437>>>>>>>        
75437>>>>>>>        If (hoSQL <> 0) Begin
75439>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
75440>>>>>>>            If (hdbc <> 0) Begin
75442>>>>>>>                Get SQLOpen of hdbc to hstmt
75443>>>>>>>                If (hstmt <> 0) Begin
75445>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
75445>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
75445>>>>>>>                    //   approach in case meta data might change, the stored procedure will
75445>>>>>>>                    //   stay the same.
75445>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
75446>>>>>>>                    Send SQLCall to hstmt
75447>>>>>>>                    Repeat
75447>>>>>>>>
75447>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
75448>>>>>>>                        If (iFetchResult <> 0) Begin
75450>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
75451>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
75452>>>>>>>                        End
75452>>>>>>>>
75452>>>>>>>                    Until (iFetchResult = 0)
75454>>>>>>>                    
75454>>>>>>>                    Send SQLClose to hstmt
75455>>>>>>>                End
75455>>>>>>>>
75455>>>>>>>                Send SQLDisconnect to hdbc
75456>>>>>>>            End
75456>>>>>>>>
75456>>>>>>>        End
75456>>>>>>>>
75456>>>>>>>        Send Destroy_Object to hoSQL
75457>>>>>>>        
75457>>>>>>>        Function_Return (Item_Count(Current_Object))
75458>>>>>>>    End_Function
75459>>>>>>>    
75459>>>>>>>    
75459>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
75461>>>>>>>        
75461>>>>>>>        String  sSqlServerClientVersionName
75461>>>>>>>        
75461>>>>>>>        
75461>>>>>>>        Case Begin
75461>>>>>>>
75461>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
75463>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
75464>>>>>>>                Case Break
75465>>>>>>>            
75465>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
75468>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
75469>>>>>>>                Case Break
75470>>>>>>>                
75470>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
75473>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
75474>>>>>>>                Case Break
75475>>>>>>>            
75475>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
75478>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
75479>>>>>>>                Case Break
75480>>>>>>>            
75480>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
75483>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
75484>>>>>>>                Case Break
75485>>>>>>>            
75485>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
75488>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
75489>>>>>>>                Case Break
75490>>>>>>>            
75490>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
75493>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
75494>>>>>>>                Case Break
75495>>>>>>>            
75495>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
75498>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
75499>>>>>>>                Case Break
75500>>>>>>>            
75500>>>>>>>            Case Else
75500>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
75501>>>>>>>                
75501>>>>>>>        Case End
75501>>>>>>>        
75501>>>>>>>        
75501>>>>>>>        Function_Return sSqlServerClientVersionName
75502>>>>>>>        
75502>>>>>>>    End_Function
75503>>>>>>>
75503>>>>>>>
75503>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
75505>>>>>>>        
75505>>>>>>>        String  sSqlServerClientDriverName
75505>>>>>>>        
75505>>>>>>>        Case Begin
75505>>>>>>>
75505>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
75507>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
75508>>>>>>>                Case Break
75509>>>>>>>
75509>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
75512>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
75513>>>>>>>                Case Break
75514>>>>>>>                
75514>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
75517>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
75518>>>>>>>                Case Break
75519>>>>>>>            
75519>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
75522>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
75523>>>>>>>                Case Break
75524>>>>>>>            
75524>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
75527>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
75528>>>>>>>                Case Break
75529>>>>>>>            
75529>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
75532>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
75533>>>>>>>                Case Break
75534>>>>>>>            
75534>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
75537>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
75538>>>>>>>                Case Break
75539>>>>>>>            
75539>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
75542>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
75543>>>>>>>                Case Break
75544>>>>>>>            
75544>>>>>>>            Case Else
75544>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
75545>>>>>>>                
75545>>>>>>>        Case End
75545>>>>>>>        
75545>>>>>>>        
75545>>>>>>>        Function_Return sSqlServerClientDriverName
75546>>>>>>>        
75546>>>>>>>    End_Function
75547>>>>>>>    
75547>>>>>>>    
75547>>>>>>>End_Class
75548>>>>>>>
75548>>>>>>>
75548>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\db2_drv.pkg)
75548>>>>>>>// DB2_DRV.PKG                                                          
75548>>>>>>>//   Package that declares DB2 driver constants and functions.          
75548>>>>>>>//   This package can be used by developers who want to add DB2 driver  
75548>>>>>>>//   specific code to a DataFlex application.                           
75548>>>>>>>
75548>>>>>>>Use Cli.pkg
75548>>>>>>>
75548>>>>>>>// Driver attributes
75548>>>>>>>
75548>>>>>>>
75548>>>>>>>// Driver Indentification
75548>>>>>>>
75548>>>>>>>// Error number constants
75548>>>>>>>
75548>>>>>>>// Call driver function identifiers
75548>>>>>>>
75548>>>>>>>// DB2 specific data types
75548>>>>>>>Define SQL_CLOB           for   (-99)
75548>>>>>>>Define SQL_BLOB           for   (-98)
75548>>>>>>>Define SQL_XML            for   (-370)
75548>>>>>>>// DB2 Graphic types are Unicode types
75548>>>>>>>Define SQL_GRAPHIC        for   (-95)
75548>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
75548>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
75548>>>>>>>Define SQL_DBCLOB         for   (-350)
75548>>>>>>>
75548>>>>>>>
75548>>>>>>>// Extra DB2 commands
75548>>>>>>>
75548>>>>>>>
75548>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
75548>>>>>>>//   Setup a constraint for a file.                                     
75548>>>>>>>
75548>>>>>>>
75548>>>>>>>
75548>>>>>>>Class cDB2Handler is a cCLIHandler
75549>>>>>>>    
75549>>>>>>>    Procedure Construct_Object
75551>>>>>>>        Forward Send Construct_Object
75553>>>>>>>        
75553>>>>>>>        Set psDriverID to DB2_DRV_ID
75554>>>>>>>    End_Procedure
75555>>>>>>>    
75555>>>>>>>    
75555>>>>>>>    
75555>>>>>>>    // Reset the datasource list to the beginning
75555>>>>>>>    Procedure SeedDataSources
75557>>>>>>>        String  sDriver
75557>>>>>>>        String  sVoid
75557>>>>>>>        Integer iRetval
75557>>>>>>>        
75557>>>>>>>        Get psDriverID to sDriver
75558>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
75565>>>>>>>    End_Procedure
75566>>>>>>>    
75566>>>>>>>    
75566>>>>>>>    
75566>>>>>>>    // Call the driver's data sources function
75566>>>>>>>    Function DataSources Returns String
75568>>>>>>>        String  sDriver
75568>>>>>>>        String  sDataSource
75568>>>>>>>        String  sDescription
75568>>>>>>>        Integer iLength
75568>>>>>>>        Integer iRetval
75568>>>>>>>        
75568>>>>>>>        Get psDriverID to sDriver
75569>>>>>>>        If (sDriver <> "") Begin
75571>>>>>>>            Move 8192 to iLength
75572>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
75573>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
75574>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
75579>>>>>>>        End
75579>>>>>>>>
75579>>>>>>>        
75579>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
75582>>>>>>>        Else ;            Function_Return ""
75584>>>>>>>    End_Function
75585>>>>>>>    
75585>>>>>>>End_Class
75586>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\odbc_drv.pkg)
75586>>>>>>>//   Package that declares ODBC driver constants and functions.         
75586>>>>>>>//   This package can be used by developers who want to add Data Access 
75586>>>>>>>//   ODBC Client specific code to a DataFlex application.               
75586>>>>>>>
75586>>>>>>>Use Cli.pkg
75586>>>>>>>
75586>>>>>>>// Driver Indentification
75586>>>>>>>
75586>>>>>>>// Error number constants
75586>>>>>>>
75586>>>>>>>// Call driver function identifiers
75586>>>>>>>
75586>>>>>>>Class cODBCHandler is a cCLIHandler
75587>>>>>>>    
75587>>>>>>>    Procedure Construct_Object
75589>>>>>>>        Forward Send Construct_Object
75591>>>>>>>        
75591>>>>>>>        Set psDriverID to ODBC_DRV_ID
75592>>>>>>>    End_Procedure
75593>>>>>>>    
75593>>>>>>>    
75593>>>>>>>    
75593>>>>>>>    // Setup the type of data sources returned by the datasources function
75593>>>>>>>    Procedure Set DataSourceType Integer iNewType
75595>>>>>>>        String  sDriver
75595>>>>>>>        String  sVoid
75595>>>>>>>        Integer iRetval
75595>>>>>>>        
75595>>>>>>>        Get psDriverID to sDriver
75596>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
75603>>>>>>>    End_Procedure
75604>>>>>>>    
75604>>>>>>>    
75604>>>>>>>    // Call the driver's data sources function
75604>>>>>>>    Function DataSources Returns String
75606>>>>>>>        String  sDriver
75606>>>>>>>        String  sDataSource
75606>>>>>>>        String  sDescription
75606>>>>>>>        Integer iLength
75606>>>>>>>        Integer iRetval
75606>>>>>>>        
75606>>>>>>>        Get psDriverID to sDriver
75607>>>>>>>        If (sDriver <> "") Begin
75609>>>>>>>            Move 8192 to iLength
75610>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
75611>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
75612>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
75617>>>>>>>        End
75617>>>>>>>>
75617>>>>>>>        
75617>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
75620>>>>>>>        Else ;            Function_Return ""
75622>>>>>>>    End_Function
75623>>>>>>>    
75623>>>>>>>End_Class
75624>>>>>>>
75624>>>>>Use DFBtrDrv.pkg
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 23.0\Pkg\DFBTRDRV.PKG)
75624>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
75624>>>>>>>// Notice      : This package contains constants and commands, used to call
75624>>>>>>>//               specific functions in the DFBTRDRV.
75624>>>>>>>Use Ui
75624>>>>>>>//
75624>>>>>>>// Driver Indentification
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>// Driver attributes
75624>>>>>>>//
75624>>>>>>>// Call_Driver functions ID's
75624>>>>>>>//
75624>>>>>>>//
75624>>>>>>>// DFBTRFN_CONVERT_FILE options
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// DFBTRFN_SET_OWNER options
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to create all vars which may be needed
75624>>>>>>>// in other commands.
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to set the owner of a Btrieve file.
75624>>>>>>>// File must have been opened.
75624>>>>>>>// Filenumber needs to be passed.
75624>>>>>>>// To clear set the owner to "".
75624>>>>>>>// Examples:
75624>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
75624>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
75624>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
75624>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
75624>>>>>>>// To clear:
75624>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to parse DFBTR_SET_OWNVER
75624>>>>>>>// options.
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to parse for Callback
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to clear the owner of a Btrieve file.
75624>>>>>>>// File must have been opened.
75624>>>>>>>// Filenumber needs to be passed.
75624>>>>>>>// Examples:
75624>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to add a owner name to the internal list of ownernames
75624>>>>>>>// which will be tries when opening files.
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to remove all owners from the internal list of ownernames
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to set the owner name to be used when opening the DDF files.
75624>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
75624>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
75624>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to change the transaction type.
75624>>>>>>>// Valid types are:
75624>>>>>>>//     DFBTRTT_NONE
75624>>>>>>>//     DFBTRTT_EXCLUSIVE
75624>>>>>>>//     DFBTRTT_CONCURRENT
75624>>>>>>>//
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to get the current transaction type.
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to set explicit_locking
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to get explicit locking
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>//
75624>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
75624>>>>>>>//
75624>>>>>>>
75624>>>>>>>// Purpose: An instance of this class can be used as a broker object to
75624>>>>>>>//          call several Dfbtrdrv releated methods.
75624>>>>>>>
75624>>>>>>>Class cDFBtrDrvHandler is an Array
75625>>>>>>>    
75625>>>>>>>    Procedure Construct_Object Integer iImage
75627>>>>>>>        Forward Send Construct_object iImage
75629>>>>>>>        
75629>>>>>>>        Property String  psDriverID "DFBTRDRV"
75630>>>>>>>    End_Procedure
75631>>>>>>>    
75631>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
75631>>>>>>>    //
75631>>>>>>>    
75631>>>>>>>    Function CKRevision Returns String
75633>>>>>>>        String  sDriverID
75633>>>>>>>        String  sRevision
75633>>>>>>>        String  sVoid
75633>>>>>>>        Integer iRetval
75633>>>>>>>        
75633>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75633>>>>>>>        // This error would otherwise be raised when we have an older
75633>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75633>>>>>>>        Send Ignore_error to Error_object_Id 20491
75634>>>>>>>        Get psDriverID to sDriverID
75635>>>>>>>        Move (Repeat(" ", 255)) to sRevision
75636>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
75641>>>>>>>        Send Trap_Error to Error_object_Id 20491
75642>>>>>>>        If (Trim(sRevision) = "") Begin
75644>>>>>>>            // Unable to get the revision. return all zeroes.
75644>>>>>>>            Move "0.0.0.0" to sRevision
75645>>>>>>>        End
75645>>>>>>>>
75645>>>>>>>        Function_Return sRevision
75646>>>>>>>    End_Function
75647>>>>>>>    
75647>>>>>>>    Function CkUsesUri Returns Integer
75649>>>>>>>        String  sDriverID
75649>>>>>>>        String  sVoid1
75649>>>>>>>        String  sVoid2
75649>>>>>>>        Integer iRetval
75649>>>>>>>        
75649>>>>>>>        Get psDriverID to sDriverID
75650>>>>>>>        
75650>>>>>>>        Move 0 to iRetval
75651>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75651>>>>>>>        // This error would otherwise be raised when we have an older
75651>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
75651>>>>>>>        Send Ignore_error to Error_object_Id 20491
75652>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
75657>>>>>>>        Send Trap_Error to Error_object_Id 20491
75658>>>>>>>        
75658>>>>>>>        Function_Return iRetval
75659>>>>>>>    End_Function
75660>>>>>>>    
75660>>>>>>>    
75660>>>>>>>    
75660>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
75660>>>>>>>    //
75660>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
75660>>>>>>>    //
75660>>>>>>>    
75660>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
75662>>>>>>>        Integer iPartRev
75662>>>>>>>        Integer iCurrentPart
75662>>>>>>>        Integer iSeparatorPos
75662>>>>>>>        
75662>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
75665>>>>>>>        
75665>>>>>>>        Move 0 to iCurrentPart
75666>>>>>>>        Repeat
75666>>>>>>>>
75666>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
75667>>>>>>>            If (iSeparatorPos > 0) Begin
75669>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
75670>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
75671>>>>>>>                Increment iCurrentPart
75672>>>>>>>            End
75672>>>>>>>>
75672>>>>>>>            Else If (sRevision <> "") Begin
75675>>>>>>>                Move sRevision to iPartRev
75676>>>>>>>                Move "" to sRevision
75677>>>>>>>                Increment iCurrentPart
75678>>>>>>>            End
75678>>>>>>>>
75678>>>>>>>            Else ;                Move -1 to iPartRev
75680>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
75682>>>>>>>        
75682>>>>>>>        Function_Return iPartRev
75683>>>>>>>    End_Function
75684>>>>>>>    
75684>>>>>>>    
75684>>>>>>>    
75684>>>>>>>    //
75684>>>>>>>    //  Returns the major revision of the CK
75684>>>>>>>    //
75684>>>>>>>    
75684>>>>>>>    Function CKMajorRevision Returns Integer
75686>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
75687>>>>>>>    End_Function
75688>>>>>>>    
75688>>>>>>>    
75688>>>>>>>    
75688>>>>>>>    //  Returns the minor revision of the CK
75688>>>>>>>    //
75688>>>>>>>    
75688>>>>>>>    Function CKMinorRevision Returns Integer
75690>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
75691>>>>>>>    End_Function
75692>>>>>>>    
75692>>>>>>>    
75692>>>>>>>    //  Returns the release revision of the CK
75692>>>>>>>    //
75692>>>>>>>    
75692>>>>>>>    Function CKReleaseRevision Returns Integer
75694>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
75695>>>>>>>    End_Function
75696>>>>>>>    
75696>>>>>>>    
75696>>>>>>>    //  Returns the major revision of the CK
75696>>>>>>>    //
75696>>>>>>>    
75696>>>>>>>    Function CKBuildRevision Returns Integer
75698>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
75699>>>>>>>    End_Function
75700>>>>>>>    
75700>>>>>>>    
75700>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
75700>>>>>>>    //
75700>>>>>>>    
75700>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
75702>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
75705>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
75708>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
75711>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
75714>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
75717>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
75721>>>>>>>            End
75721>>>>>>>>
75721>>>>>>>        End
75721>>>>>>>>
75721>>>>>>>        
75721>>>>>>>        Function_Return (False)
75722>>>>>>>    End_Function
75723>>>>>>>    
75723>>>>>>>    //   Functions to query the Pervasive.SQL version:
75723>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
75723>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
75723>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
75723>>>>>>>    //
75723>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
75723>>>>>>>    //   in the following format:
75723>>>>>>>    //       <version>.<revision>.<type>
75723>>>>>>>    //   possible values for <type>:
75723>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
75723>>>>>>>    //         server using Workgroup authentication mode
75723>>>>>>>    //       C for client cache engine
75723>>>>>>>    //       D for DOS workstation
75723>>>>>>>    //       N for client Requester
75723>>>>>>>    //       S for NetWare server
75723>>>>>>>    //       T for 32-bit Windows server engine
75723>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
75723>>>>>>>    //
75723>>>>>>>    //   example:
75723>>>>>>>    //       8.50.T
75723>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
75723>>>>>>>    //   32-bits Windows server.
75723>>>>>>>    //
75723>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
75723>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
75723>>>>>>>    //
75723>>>>>>>    //   If the version information is not available or can not be obtained
75723>>>>>>>    //   the functions will return "0.0.0"
75723>>>>>>>    
75723>>>>>>>    //  Returns the version information of the
75723>>>>>>>    //           Pervasive.SQL Client requester.
75723>>>>>>>    
75723>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
75725>>>>>>>        
75725>>>>>>>        String  sDriverID
75725>>>>>>>        String  sVersion
75725>>>>>>>        String  sVoid
75725>>>>>>>        Integer iRetval
75725>>>>>>>        
75725>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75725>>>>>>>        // This error would otherwise be raised when we have an older
75725>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75725>>>>>>>        Send Ignore_error to Error_object_Id 20491
75726>>>>>>>        Get psDriverID to sDriverID
75727>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75728>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75733>>>>>>>        Send Trap_Error to Error_object_Id 20491
75734>>>>>>>        If (Trim(sVersion) = "") Begin
75736>>>>>>>            // Unable to get the revision. return all zeroes.
75736>>>>>>>            Move "0.0.0" to sVersion
75737>>>>>>>        End
75737>>>>>>>>
75737>>>>>>>        Function_Return sVersion
75738>>>>>>>    End_Function
75739>>>>>>>    
75739>>>>>>>    //           Pervasive.SQL Engine
75739>>>>>>>    
75739>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
75741>>>>>>>        
75741>>>>>>>        String  sDriverID
75741>>>>>>>        String  sVersion
75741>>>>>>>        String  sVoid
75741>>>>>>>        Integer iRetval
75741>>>>>>>        
75741>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75741>>>>>>>        // This error would otherwise be raised when we have an older
75741>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75741>>>>>>>        Send Ignore_error to Error_object_Id 20491
75742>>>>>>>        Get psDriverID to sDriverID
75743>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75744>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75749>>>>>>>        Send Trap_Error to Error_object_Id 20491
75750>>>>>>>        If (Trim(sVersion) = "") Begin
75752>>>>>>>            // Unable to get the revision. return all zeroes.
75752>>>>>>>            Move "0.0.0" to sVersion
75753>>>>>>>        End
75753>>>>>>>>
75753>>>>>>>        Function_Return sVersion
75754>>>>>>>    End_Function
75755>>>>>>>    
75755>>>>>>>    //  Returns the version information of the
75755>>>>>>>    //           Pervasive.SQL Server Engine
75755>>>>>>>    
75755>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
75757>>>>>>>        
75757>>>>>>>        String  sDriverID
75757>>>>>>>        String  sVersion
75757>>>>>>>        String  sVoid
75757>>>>>>>        Integer iRetval
75757>>>>>>>        
75757>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75757>>>>>>>        // This error would otherwise be raised when we have an older
75757>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75757>>>>>>>        Send Ignore_error to Error_object_Id 20491
75758>>>>>>>        Get psDriverID to sDriverID
75759>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75760>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75765>>>>>>>        Send Trap_Error to Error_object_Id 20491
75766>>>>>>>        If (Trim(sVersion) = "") Begin
75768>>>>>>>            // Unable to get the revision. return all zeroes.
75768>>>>>>>            Move "0.0.0" to sVersion
75769>>>>>>>        End
75769>>>>>>>>
75769>>>>>>>        Function_Return sVersion
75770>>>>>>>    End_Function
75771>>>>>>>    
75771>>>>>>>End_Class
75772>>>>>>>
75772>>>>>>>
75772>>>>>Use vWin32fh.pkg
75772>>>>>
75772>>>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
75772>>>>>>>// *** The Database Update Framework Include file for Languages ***
75772>>>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
75772>>>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
75772>>>>>>>//
75772>>>>>>>Use LanguageText.Pkg
75772>>>>>>>
75772>>>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
75772>>>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
75772>>>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
75772>>>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
75772>>>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
75772>>>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
75772>>>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
75772>>>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
75772>>>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
75772>>>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
75772>>>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
75772>>>>>>>    Define CS_DUF_CopyingData               for "Copying data"
75772>>>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
75772>>>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
75772>>>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
75772>>>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
75772>>>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
75772>>>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
75772>>>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
75772>>>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
75772>>>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
75772>>>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
75772>>>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
75772>>>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
75772>>>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
75772>>>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
75772>>>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
75772>>>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
75772>>>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
75772>>>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
75772>>>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile in the data-folder.\n\nThe program will now close."
75772>>>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
75772>>>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
75772>>>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
75772>>>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
75772>>>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
75772>>>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>>>
75772>>>>>
75772>>>>>    Define DATAFLEX_ID for "DATAFLEX"
75772>>>>>
75772>>>>>// Create a new PSQL identifier for the Btrieve driver.
75772>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
75772>>>>>
75772>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
75772>>>>>// They can have slightly different SQL keywords.
75772>>>>>// Note: If a new type is added to the list,
75772>>>>>//       the struct array xxx must be adjusted
75772>>>>>//       so that it is filled with all SQL
75772>>>>>//       keywords for that new type.
75772>>>>>Enum_List  
75772>>>>>        Define EN_DbTypeDataFlex   for 0
75772>>>>>        Define EN_DbTypeMSSQL      for 1
75772>>>>>        Define EN_DbTypeMySQL      for 2
75772>>>>>        Define EN_DbTypeOracle     for 3
75772>>>>>        Define EN_DbTypeDB2        for 4
75772>>>>>        Define EN_DbTypePostgre    for 5
75772>>>>>        Define EN_DbTypePervasive  for 6
75772>>>>>End_Enum_List
75772>>>>>
75772>>>>>// We need to have our "own" constants for the standard DataFlex data types.
75772>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
75772>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
75772>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
75772>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
75772>>>>>Define CS_DbTypeMySQL       for "MySQL"
75772>>>>>Define CS_DbTypeOracle      for "Oracle"
75772>>>>>Define CS_DbTypeDB2         for "IBM DB2"
75772>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
75772>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
75772>>>>>
75772>>>>>
75772>>>>>// SQLConnection.ini constants:
75772>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
75772>>>>>
75772>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
75772>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
75772>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
75772>>>>>Define CS_SQLIniSectionName             for "Connection"
75772>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
75772>>>>>
75772>>>>>// DF 19 ini-file settings:
75772>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
75772>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
75772>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
75772>>>>>Define CS_SQLIniUIDKeyword              for "UID"
75772>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
75772>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
75772>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
75772>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
75772>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
75772>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
75772>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
75772>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
75772>>>>>
75772>>>>>// Database Update Framework extended settings:
75772>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
75772>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
75772>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
75772>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
75772>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
75772>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
75772>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
75772>>>>>
75772>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
75772>>>>>Define CS_SQLIniConnectionYes           for "Yes"
75772>>>>>Define CS_SQLIniConnectionNo            for "No"
75772>>>>>
75772>>>>>Struct tSQLConnection
75772>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
75772>>>>>    String sConnectionID            // 2. The name of the connection ID.
75772>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
75772>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
75772>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
75772>>>>>    String sDatabase                // 6. SQL Database
75772>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
75772>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
75772>>>>>    String sUserID                  // 9. User ID
75772>>>>>    String sPassword                // 10. Password
75772>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
75772>>>>>    String sBaseTableSpace          // 12. DB2 specific
75772>>>>>    String sLongTableSpace          // 13. DB2 specific
75772>>>>>    String sIndexTableSpace         // 14. DB2 specific
75772>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
75772>>>>>    Boolean bError                  // 16. Set to true on error.
75772>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
75772>>>>>End_Struct
75772>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
75772>>>>>Use cSQLConnectionIniFile.inc
75772>>>>>
75772>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
75773>>>>>    Procedure Construct_Object
75775>>>>>        Forward Send Construct_Object
75777>>>>>        Property String psDriverID DATAFLEX_ID
75778>>>>>    End_Procedure
75779>>>>>
75779>>>>>    Function ServerKeyword String sServer Returns String
75781>>>>>        String sRetval
75781>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
75783>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
75784>>>>>        End                                        
75784>>>>>>
75784>>>>>        Else Begin
75785>>>>>            Move CS_SQLIniDSNKeyword to sRetval
75786>>>>>        End
75786>>>>>>
75786>>>>>            
75786>>>>>        Function_Return sRetval
75787>>>>>    End_Function
75788>>>>>
75788>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
75790>>>>>        String sConnect sServerKeyWord sDriverID
75790>>>>>
75790>>>>>        Get psDriverID to sDriverID
75791>>>>>        Get ServerKeyword sServer to sServerKeyWord
75792>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
75793>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
75795>>>>>            Move "" to sDatabase
75796>>>>>        End
75796>>>>>>
75796>>>>>        
75796>>>>>        // 2019-10-20 I think this was plain wrong for the DAW ODBC_DRV driver. At least it didn't work for login to an MS-SQL db.
75796>>>>>//        If (bTrusted = False and (sDriverID = ODBC_DRV_ID and sServerKeyWord = CS_SQLIniDSNKeyword)) Begin
75796>>>>>//            Function_Return sConnect
75796>>>>>//        End
75796>>>>>
75796>>>>>        If (sDatabase <> "") Begin
75798>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
75799>>>>>        End
75799>>>>>>
75799>>>>>        If (bTrusted = True) Begin
75801>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
75802>>>>>        End
75802>>>>>>
75802>>>>>        Else Begin
75803>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
75804>>>>>        End
75804>>>>>>
75804>>>>>        Function_Return sConnect
75805>>>>>    End_Function
75806>>>>>
75806>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
75808>>>>>        Boolean bLoginSuccessful
75808>>>>>        String sDriverID
75808>>>>>
75808>>>>>        Get psDriverID to sDriverID
75809>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
75811>>>>>            Function_Return True
75812>>>>>        End
75812>>>>>>
75812>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
75813>>>>>        If (bTrusted = False and sDatabase <> "") Begin
75815>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
75816>>>>>            Login sServer sUserId sPassword sDriverID  
75818>>>>>        End
75818>>>>>>
75818>>>>>        Else Begin
75819>>>>>            Login sConnectionString "" "" sDriverID
75821>>>>>        End
75821>>>>>>
75821>>>>>        Move (LastErr = 0) to bLoginSuccessful
75822>>>>>        Function_Return bLoginSuccessful
75823>>>>>    End_Function
75824>>>>>End_Class
75825>>>>>
75825>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
75826>>>>>    Function ServerKeyword String sServer Returns String
75828>>>>>        Function_Return CS_SQLIniServerKeyword
75829>>>>>    End_Function
75830>>>>>End_Class
75831>>>>>
75831>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
75832>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
75834>>>>>        Boolean bLoginSuccessful
75834>>>>>        String sDriverID
75834>>>>>
75834>>>>>        Get psDriverID to sDriverID
75835>>>>>        Move (Trim(sDriverID)) to sDriverID
75836>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
75838>>>>>            Function_Return True
75839>>>>>        End
75839>>>>>>
75839>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
75840>>>>>        If (bTrusted = False) Begin
75842>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
75844>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
75845>>>>>            End
75845>>>>>>
75845>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
75848>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
75849>>>>>            End
75849>>>>>>
75849>>>>>            Login sServer sUserId sPassword sDriverID  
75851>>>>>        End
75851>>>>>>
75851>>>>>        Else Begin
75852>>>>>            Login sConnectionString "" "" sDriverID
75854>>>>>        End
75854>>>>>>
75854>>>>>        Move (LastErr = 0) to bLoginSuccessful
75855>>>>>
75855>>>>>        Function_Return bLoginSuccessful
75856>>>>>    End_Function
75857>>>>>End_Class
75858>>>>>
75858>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
75859>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
75861>>>>>        Boolean bLoginSuccessful
75861>>>>>        String sDriverID
75861>>>>>
75861>>>>>        Move False to Err
75862>>>>>        Get psDriverID to sDriverID
75863>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
75865>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
75866>>>>>        End
75866>>>>>>
75866>>>>>        Login sServer sUserId sPassword sDriverID
75868>>>>>
75868>>>>>        Move (not(Err)) to bLoginSuccessful
75869>>>>>        Function_Return bLoginSuccessful
75870>>>>>    End_Function
75871>>>>>End_Class
75872>>>>>
75872>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
75873>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
75875>>>>>        Boolean bLoginSuccessful
75875>>>>>        String sDriverID
75875>>>>>
75875>>>>>        Move False to Err
75876>>>>>        Get psDriverID to sDriverID
75877>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
75877>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
75877>>>>>//        End
75877>>>>>        Login sServer sUserId sPassword sDriverID
75879>>>>>
75879>>>>>        Move (not(Err)) to bLoginSuccessful
75880>>>>>        Function_Return bLoginSuccessful
75881>>>>>    End_Function
75882>>>>>End_Class
75883>>>>>
75883>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
75884>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
75886>>>>>        Function_Return ""
75887>>>>>    End_Function
75888>>>>>End_Class
75889>>>>>
75889>>>>>Class cDbUpdateDatabaseDriver is a cObject
75890>>>>>    Procedure Construct_Object
75892>>>>>        Forward Send Construct_Object
75894>>>>>        Property String psDriverID DATAFLEX_ID
75895>>>>>        Property Handle phoDriverSpecificObject
75896>>>>>    End_Procedure
75897>>>>>
75897>>>>>    Function CreateDriver Returns Handle
75899>>>>>        String sDriverID
75899>>>>>        Handle hoDriver hcDriverClass
75899>>>>>
75899>>>>>        Get psDriverID to sDriverID
75900>>>>>        Case Begin
75900>>>>>            Case (sDriverID = MSSQLDRV_ID)
75902>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
75903>>>>>                Case Break
75904>>>>>            Case (sDriverID = ODBC_DRV_ID)
75907>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
75908>>>>>                Case Break
75909>>>>>            Case (sDriverID = DB2_DRV_ID)
75912>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
75913>>>>>                Case Break               
75914>>>>>            // DATAFLEX_ID = Default driver
75914>>>>>            Case Else
75914>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
75915>>>>>                Move DATAFLEX_ID to sDriverID
75916>>>>>        Case End
75916>>>>>
75916>>>>>        Get Create hcDriverClass to hoDriver
75917>>>>>        Set psDriverID of hoDriver to sDriverID
75918>>>>>        Set phoDriverSpecificObject to hoDriver
75919>>>>>
75919>>>>>        Function_Return hoDriver
75920>>>>>    End_Function
75921>>>>>
75921>>>>>    Procedure DestroyDriver
75923>>>>>        If (phoDriverSpecificObject(Self)) Begin
75925>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
75926>>>>>        End
75926>>>>>>
75926>>>>>    End_Procedure
75927>>>>>
75927>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
75929>>>>>        String sConnect
75929>>>>>        Handle hoDriver
75929>>>>>
75929>>>>>        Get CreateDriver to hoDriver
75930>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
75931>>>>>        Send DestroyDriver
75932>>>>>        Function_Return sConnect
75933>>>>>    End_Function
75934>>>>>
75934>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
75936>>>>>        Boolean bLoginSuccessful
75936>>>>>        Handle hoDriver
75936>>>>>
75936>>>>>        Get CreateDriver to hoDriver
75937>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
75938>>>>>        Send DestroyDriver
75939>>>>>        Function_Return bLoginSuccessful
75940>>>>>    End_Function
75941>>>>>
75941>>>>>End_Class
75942>>>
75942>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cLoginEncryption.pkg)
75942>>>>>Use cCryptographerEx.pkg
75942>>>>>
75942>>>>>Class cLoginEncryption is a cObject
75943>>>>>    
75943>>>>>    Procedure Construct_Object
75945>>>>>        Forward Send Construct_Object
75947>>>>>        // this must be set to a multi (40ish) character random key
75947>>>>>        Property String psEncryptPassword ""
75948>>>>>        
75948>>>>>        Object oDataCrypter is a cCryptographerEx
75950>>>>>            Set piHash to CALG_SHA_256
75951>>>>>            Set piCipher to CALG_AES_256
75952>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
75953>>>>>            Set piProvider to PROV_RSA_AES
75954>>>>>        End_Object
75955>>>>>    End_Procedure
75956>>>>>    
75956>>>>>    // This can be augmented to return a password encryption key using any
75956>>>>>    // hidden mechanism desired.
75956>>>>>    Function GetEncryptionPassword Returns String
75958>>>>>        String sPassword
75958>>>>>        Get psEncryptPassword to sPassword
75959>>>>>        Function_Return sPassword
75960>>>>>    End_Function
75961>>>>>    
75961>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
75961>>>>>    //
75961>>>>>    // Params:
75961>>>>>    //   sPlainText     String to encrypt.
75961>>>>>    // Returns:
75961>>>>>    //   Base64 encoded hash.
75961>>>>>    Function EncryptPassword String sPlainText Returns String
75963>>>>>        String sEncryptPassword sBase64
75963>>>>>        UChar[] ucBinary
75964>>>>>        Pointer pBase64
75964>>>>>        Integer iVoid
75964>>>>>        
75964>>>>>        //  Encrypt Key
75964>>>>>        Get GetEncryptionPassword to sEncryptPassword
75965>>>>>        If (sEncryptPassword = "") Begin
75967>>>>>            Error DFERR_PROGRAM "No encryption password set"
75968>>>>>>
75968>>>>>        End
75968>>>>>>
75968>>>>>        
75968>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
75969>>>>>        
75969>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
75971>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
75972>>>>>>
75972>>>>>            Function_Return ""
75973>>>>>        End
75973>>>>>>
75973>>>>>        
75973>>>>>        //  Encode binary hash to Base64
75973>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
75974>>>>>        Move (PointerToString(pBase64)) to sBase64
75975>>>>>        Move (Free(pBase64)) to iVoid
75976>>>>>        
75976>>>>>        Function_Return sBase64
75977>>>>>    End_Function
75978>>>>>    
75978>>>>>    
75978>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
75978>>>>>    //
75978>>>>>    // Params:
75978>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
75978>>>>>    // Returns:
75978>>>>>    //   Readable plain text password
75978>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
75980>>>>>        String sEncryptPassword
75980>>>>>        UChar[] ucBinary ucPlain
75982>>>>>        Boolean bIsHex
75982>>>>>        Integer iLen iVoid
75982>>>>>        Pointer pBinary
75982>>>>>        
75982>>>>>        If (sBase64EncryptedPassword <> "") Begin
75984>>>>>            //  Decode from Base64
75984>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
75985>>>>>            
75985>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
75986>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
75987>>>>>                        
75987>>>>>            Move (Free(pBinary)) to iVoid
75988>>>>>            
75988>>>>>            //  Encrypted binary hash to string
75988>>>>>            Get GetEncryptionPassword to sEncryptPassword
75989>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
75990>>>>>        End
75990>>>>>>
75990>>>>>        
75990>>>>>        Function_Return (UCharArrayToString(ucPlain))
75991>>>>>    End_Function
75992>>>>>End_Class
75993>>>
75993>>>Class cSQLConnectionIniFile is a cIniFile
75994>>>    Procedure Construct_Object
75996>>>        Forward Send Construct_Object
75998>>>
75998>>>        Property String Private_psIniFilePath
75999>>>        Property String Private_psIniFileName CS_SQLIniFileName
76000>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
76001>>>
76001>>>        Property Boolean pbDFConnId False
76002>>>
76002>>>        // *** You really want to change this value! ***
76002>>>        // It is used when encrypting/decrypting passwords.
76002>>>        Property String psHashString "zx!2139(LI0+?ips7433"
76003>>>
76003>>>    End_Procedure
76004>>>
76004>>>    Procedure End_Construct_Object
76006>>>        Forward Send End_Construct_Object
76008>>>    End_Procedure
76009>>>
76009>>>    Procedure Set psIniFilePath String sPath
76011>>>        String sIniFile
76011>>>        Get vFolderFormat sPath to sPath
76012>>>        Set private_psIniFilePath to sPath
76013>>>        Get psIniFileName to sIniFile
76014>>>        Set psFileName to (sPath + sIniFile)
76015>>>    End_Procedure
76016>>>
76016>>>    Function psIniFilePath Returns String
76018>>>        Function_Return (private_psIniFilePath(Self))
76019>>>    End_Function
76020>>>
76020>>>    Procedure Set psIniFileName String sFileName
76022>>>        String sPath
76022>>>        Get psIniFilePath to sPath
76023>>>        Set psFileName to (sPath + sFileName)
76024>>>        Set private_psIniFileName to sFileName
76025>>>    End_Procedure
76026>>>
76026>>>    Function psIniFileName Returns String
76028>>>        Function_Return (private_psIniFileName(Self))
76029>>>    End_Function
76030>>>
76030>>>    // *** Generalized messages to Get & Set values of the ini file.
76030>>>    // Sets a value in the program's ini file (write)
76030>>>    // Pass a section name, the value name parameter and the value itself to be written.
76030>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
76032>>>        String sIniFile sPath
76032>>>
76032>>>        Get psIniFilePath to sPath
76033>>>        Get psIniFileName to sIniFile
76034>>>        Move (sPath + sIniFile) to sIniFile
76035>>>        Set psFileName to sIniFile
76036>>>        Send WriteString sSection sValueName sValue
76037>>>    End_Procedure
76038>>>
76038>>>    // Get a value from program's ini-file (read)
76038>>>    // Pass a section name and the name of the value parameter & a default value.
76038>>>    // Returns the value
76038>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
76040>>>        String sValue sIniFile sPath
76040>>>
76040>>>        Get psIniFilePath to sPath
76041>>>        Get psIniFileName to sIniFile
76042>>>        Move (sPath + sIniFile) to sIniFile
76043>>>        Set psFileName to sIniFile
76044>>>        Get ReadString sSection sValueName sDefaultValue to sValue
76045>>>
76045>>>        Function_Return sValue
76046>>>    End_Function
76047>>>
76047>>>    // Sort function that first sorts on bEnabled & then on the connection string.
76047>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
76049>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
76052>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
76055>>>
76055>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
76058>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
76061>>>
76061>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
76064>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
76067>>>
76067>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
76070>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
76073>>>
76073>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
76076>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
76079>>>
76079>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
76082>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
76085>>>
76085>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
76088>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
76091>>>
76091>>>        Function_Return (EQ)
76092>>>    End_Function
76093>>>
76093>>>    Function SQLIniFileNumberOfConnections Returns Integer
76095>>>        Handle hoSections
76095>>>        Integer iItems
76095>>>
76095>>>        Send ReadSections hoSections
76096>>>        Move (Item_Count(hoSections)) to iItems
76097>>>        Function_Return iItems
76098>>>    End_Function
76099>>>
76099>>>    // The normal connection string looks something like this;
76099>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
76099>>>    // ...but the full connection string looks like this;
76099>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
76099>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
76099>>>//        String sSection
76099>>>//        Integer iCount
76099>>>//
76099>>>//        Move False to Err
76099>>>//        Get psIniSectionName to sSection
76099>>>//        Get SQLIniFileNumberOfConnections to iCount
76099>>>//        Increment iCount
76099>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
76099>>>//
76099>>>//        Function_Return (Err = False)
76099>>>//    End_Function
76099>>>
76099>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
76101>>>        Integer iCount
76101>>>        Boolean bExists
76101>>>        String sSection
76101>>>
76101>>>        Move False to Err
76102>>>        Move 1 to iCount
76103>>>        Get psIniSectionName to sSection
76104>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
76105>>>        While (bExists = True)
76109>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
76110>>>            Increment iCount
76111>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
76112>>>        Loop
76113>>>>
76113>>>        Function_Return (Err = False)
76114>>>    End_Function
76115>>>
76115>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
76117>>>        Integer iCount
76117>>>        String sSection
76117>>>        Boolean bExists
76117>>>
76117>>>        Move False to Err
76118>>>        Move 1 to iCount
76119>>>        Get psIniSectionName to sSection
76120>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
76121>>>        While (bExists = True)
76125>>>            If (iCount = iItem) Begin
76127>>>                Send DeleteSection sSection
76128>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
76128>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
76129>>>            End
76129>>>>
76129>>>            Increment iCount
76130>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
76131>>>        Loop
76132>>>>
76132>>>
76132>>>        Function_Return (Err = False)
76133>>>    End_Function
76134>>>
76134>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
76134>>>    // If it fails the returned struct member SQLConnection.bError = True.
76134>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
76136>>>        tSQLConnection[] SQLConnectionsArray
76136>>>        tSQLConnection[] SQLConnectionsArray
76137>>>        tSQLConnection   SQLConnection
76137>>>        tSQLConnection   SQLConnection
76137>>>        Integer iIndex
76137>>>
76137>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
76138>>>        If (iIndex = -1) Begin
76140>>>            Move True to SQLConnection.bError
76141>>>            Function_Return SQLConnection
76142>>>        End
76142>>>>
76142>>>
76142>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76143>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
76144>>>
76144>>>        Function_Return SQLConnection
76145>>>    End_Function
76146>>>
76146>>>    // Returns -1 if the passed connection ID was not found, else the item number.
76146>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
76148>>>        tSQLConnection[] SQLConnectionsArray
76148>>>        tSQLConnection[] SQLConnectionsArray
76149>>>        Integer iRetval iCount iSize
76149>>>        String sValue
76149>>>        Boolean bExists
76149>>>
76149>>>        Move -1 to iRetval
76150>>>
76150>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76151>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
76152>>>        Decrement iSize
76153>>>        For iCount from 0 to iSize
76159>>>>
76159>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
76160>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
76161>>>            If (bExists) Begin
76163>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
76164>>>                Move iSize to iCount         // We're done!
76165>>>            End
76165>>>>
76165>>>        Loop
76166>>>>
76166>>>
76166>>>        Function_Return iRetval
76167>>>    End_Function
76168>>>
76168>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
76168>>>    // Used to check that ConnectionID's are unique.
76168>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
76170>>>        Integer iCount iSize iItems
76170>>>        String sValue
76170>>>        Boolean bExists
76170>>>        tSQLConnection[] SQLConnectionsArray
76170>>>        tSQLConnection[] SQLConnectionsArray
76171>>>
76171>>>        Move 0 to iItems
76172>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76173>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
76174>>>        Decrement iSize
76175>>>        For iCount from 0 to iSize
76181>>>>
76181>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
76182>>>            Move (sValue = sConnectionID) to bExists
76183>>>            If (bExists) Begin
76185>>>                Increment iItems
76186>>>            End
76186>>>>
76186>>>        Loop
76187>>>>
76187>>>
76187>>>        Function_Return (iItems > 1)
76188>>>    End_Function
76189>>>
76189>>>    // To update the SQLConnections.ini file with a new default Connection ID.
76189>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
76191>>>        Boolean bOK
76191>>>        Integer iSize iCount
76191>>>        tSQLConnection[] SQLConnectionsArray
76191>>>        tSQLConnection[] SQLConnectionsArray
76192>>>        tSQLConnection SQLConnection
76192>>>        tSQLConnection SQLConnection
76192>>>        String sConnectionString
76192>>>
76192>>>        Move False to Err
76193>>>        Get psConnectionString to sConnectionString
76194>>>
76194>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76195>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
76196>>>        Decrement iSize
76197>>>        // Set all current connection to inactive.
76197>>>        For iCount from 0 to iSize
76203>>>>
76203>>>            Move False to SQLConnectionsArray[iCount].bEnabled
76204>>>        Loop
76205>>>>
76205>>>
76205>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
76206>>>        Move True              to SQLConnection.bEnabled
76207>>>        Move sConnectionString to SQLConnection.sConnectionString
76208>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
76209>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
76210>>>
76210>>>        Function_Return (bOK = True)
76211>>>    End_Function
76212>>>
76212>>>    // Used for updating an existing connection with new data.
76212>>>    // Returns True if successful.
76212>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
76214>>>        Boolean bOK
76214>>>        Integer iItem iSize iCount
76214>>>        tSQLConnection[] SQLConnectionsArray
76214>>>        tSQLConnection[] SQLConnectionsArray
76215>>>
76215>>>        Move False to Err
76216>>>        Move -1 to iItem
76217>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76218>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
76219>>>        Decrement iSize
76220>>>        // Set all current connection to inactive.
76220>>>        For iCount from 0 to iSize
76226>>>>
76226>>>            Move False to SQLConnectionsArray[iCount].bEnabled
76227>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
76229>>>                Move iCount to iItem
76230>>>            End
76230>>>>
76230>>>        Loop
76231>>>>
76231>>>
76231>>>        If (iItem <> -1) Begin
76233>>>            Move True to SQLConnection.bEnabled
76234>>>            Move SQLConnection to SQLConnectionsArray[iItem]
76235>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
76236>>>        End
76236>>>>
76236>>>
76236>>>        Function_Return (bOK = True)
76237>>>    End_Function
76238>>>
76238>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
76240>>>        tSQLConnection[] SQLConnectionsArray
76240>>>        tSQLConnection[] SQLConnectionsArray
76241>>>        String sSection sValue
76241>>>        Integer iCount
76241>>>        Boolean bExists
76241>>>
76241>>>        Get psIniSectionName to sSection
76242>>>        Get SectionExists sSection to bExists
76243>>>        If (bExists = False) Begin
76245>>>            Function_Return SQLConnectionsArray
76246>>>        End
76246>>>>
76246>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
76247>>>        If (bExists = True) Begin
76249>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
76250>>>>
76250>>>        End
76250>>>>
76250>>>
76250>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
76251>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
76252>>>
76252>>>        While (bExists = True)                 
76256>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
76256>>>            // We always put the enabled/active connection at the top
76256>>>//            Move (iCount = 1) to bEnabled
76256>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
76256>>>
76256>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
76257>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
76258>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
76259>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
76260>>>
76260>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
76260>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
76261>>>            If (sValue = "99") Begin
76263>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
76264>>>            End
76264>>>>
76264>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
76265>>>
76265>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
76266>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
76267>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
76269>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
76270>>>            End
76270>>>>
76270>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
76272>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
76273>>>            End
76273>>>>
76273>>>
76273>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
76274>>>
76274>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
76275>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
76276>>>
76276>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
76277>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
76278>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
76280>>>                Get DecryptPassword sValue to sValue
76281>>>            End
76281>>>>
76281>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
76282>>>
76282>>>            // Here we reconstruct the connection string to be complete with all params;
76282>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
76283>>>
76283>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
76284>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
76285>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
76286>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
76287>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
76288>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
76289>>>
76289>>>            Increment iCount
76290>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
76291>>>        Loop
76292>>>>
76292>>>
76292>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
76292>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
76294>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
76295>>>        End
76295>>>>
76295>>>
76295>>>        Function_Return SQLConnectionsArray
76296>>>    End_Function
76297>>>
76297>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
76299>>>        Integer iCount iSize
76299>>>        Boolean bOK
76299>>>        String sSection sValue
76299>>>
76299>>>        // First we need to _remove_ all current connections from the ini-file.
76299>>>        Move 0 to iCount
76300>>>        Get SQLIniFileDeleteAllConnections to bOK
76301>>>        If (bOK = False) Begin
76303>>>            Function_Return False
76304>>>        End
76304>>>>
76304>>>
76304>>>        Move False to Err
76305>>>        Get psIniSectionName to sSection
76306>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
76306>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
76307>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
76308>>>        Decrement iSize
76309>>>
76309>>>        For iCount from 0 to iSize
76315>>>>
76315>>>            // DF 19 compatible settings:
76315>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
76316>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
76317>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
76318>>>            
76318>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
76319>>>
76319>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
76320>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
76322>>>                Get EncryptPassword sValue to sValue
76323>>>            End
76323>>>>
76323>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
76324>>>
76324>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
76326>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
76327>>>            End
76327>>>>
76327>>>
76327>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
76328>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
76329>>>
76329>>>            // The Database Update Framework extended settings:
76329>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
76330>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
76331>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
76332>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
76333>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
76334>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
76335>>>        Loop
76336>>>>
76336>>>
76336>>>        Function_Return (bOK and Err = False)
76337>>>    End_Function
76338>>>
76338>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
76338>>>    //
76338>>>    // SQL utility function that returns a database type (string) constant
76338>>>    // corresponding to the passed iDbType.
76338>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
76340>>>        String sRetval
76340>>>        If (iDbType = EN_dbTypeMSSQL) Begin
76342>>>            Move CS_dbTypeMSSQL to sRetval
76343>>>        End
76343>>>>
76343>>>        If (iDbType = EN_dbTypeMySQL) Begin
76345>>>            Move CS_dbTypeMySQL to sRetval
76346>>>        End
76346>>>>
76346>>>        If (iDbType = EN_dbTypeOracle) Begin
76348>>>            Move CS_dbTypeOracle to sRetval
76349>>>        End
76349>>>>
76349>>>        If (iDbType = EN_dbTypeDB2) Begin
76351>>>            Move CS_dbTypeDB2 to sRetval
76352>>>        End
76352>>>>
76352>>>        If (iDbType = EN_dbTypePostgre) Begin
76354>>>            Move CS_dbTypePostgre to sRetval
76355>>>        End
76355>>>>
76355>>>        If (iDbType = EN_DbTypePervasive) Begin
76357>>>            Move CS_DbTypePervasive to sRetval
76358>>>        End
76358>>>>
76358>>>        Function_Return sRetval
76359>>>    End_Function
76360>>>
76360>>>    // SQL utility function that returns a database type constant (integer)
76360>>>    // corresponding to the passed sDbType string constant.
76360>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
76362>>>        Integer iRetval
76362>>>        If (sDbType = CS_dbTypeMSSQL) Begin
76364>>>            Move EN_dbTypeMSSQL to iRetval
76365>>>        End
76365>>>>
76365>>>        If (sDbType = CS_dbTypeMySQL) Begin
76367>>>            Move EN_dbTypeMySQL to iRetval
76368>>>        End
76368>>>>
76368>>>        If (sDbType = CS_dbTypeOracle) Begin
76370>>>            Move EN_dbTypeOracle to iRetval
76371>>>        End
76371>>>>
76371>>>        If (sDbType = CS_dbTypeDB2) Begin
76373>>>            Move EN_dbTypeDB2 to iRetval
76374>>>        End
76374>>>>
76374>>>        If (sDbType = CS_dbTypePostgre) Begin
76376>>>            Move EN_dbTypePostgre to iRetval
76377>>>        End
76377>>>>
76377>>>        If (sDbType = CS_DbTypePervasive) Begin
76379>>>            Move EN_DbTypePervasive to iRetval
76380>>>        End
76380>>>>
76380>>>        Function_Return iRetval
76381>>>    End_Function
76382>>>
76382>>>    // Pass an integer DbType and function returns the database type integer as a string value.
76382>>>    // Used e.g. when reading a connection ini-file to display the database type in
76382>>>    // the SQL Connection program's grid.
76382>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
76384>>>        String sRetval
76384>>>        If (iDbType = EN_dbTypeMSSQL) Begin
76386>>>            Move "EN_dbTypeMSSQL" to sRetval
76387>>>        End
76387>>>>
76387>>>        If (iDbType = EN_dbTypeMySQL) Begin
76389>>>            Move "EN_dbTypeMySQL" to sRetval
76390>>>        End
76390>>>>
76390>>>        If (iDbType = EN_dbTypeOracle) Begin
76392>>>            Move "EN_dbTypeOracle" to sRetval
76393>>>        End
76393>>>>
76393>>>        If (iDbType = EN_dbTypeDB2) Begin
76395>>>            Move "EN_dbTypeDB2" to sRetval
76396>>>        End
76396>>>>
76396>>>        If (iDbType = EN_dbTypePostgre) Begin
76398>>>            Move "EN_dbTypePostgre" to sRetval
76399>>>        End
76399>>>>
76399>>>        If (iDbType = EN_DbTypePervasive) Begin
76401>>>            Move "EN_dbTypePervasive" to sRetval
76402>>>        End
76402>>>>
76402>>>        Function_Return sRetval
76403>>>    End_Function
76404>>>
76404>>>    // Pass a driver id and the function will return
76404>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
76404>>>    // quite work and always returns "MS SQL Server"
76404>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
76406>>>        Integer iRetval
76406>>>        If (sDriverID = MSSQLDRV_ID) Begin
76408>>>            Move EN_dbTypeMSSQL to iRetval
76409>>>        End
76409>>>>
76409>>>        If (sDriverID = ODBC_DRV_ID) Begin
76411>>>            Move EN_dbTypeMSSQL to iRetval
76412>>>        End
76412>>>>
76412>>>        If (sDriverID = DB2_DRV_ID) Begin
76414>>>            Move EN_dbTypeDB2 to iRetval
76415>>>        End
76415>>>>
76415>>>        If (sDriverID = DFBTRDRV_ID) Begin
76417>>>            Move EN_DbTypePervasive to iRetval
76418>>>        End
76418>>>>
76418>>>        Function_Return iRetval
76419>>>    End_Function
76420>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
76420>>>>
76420>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
76422>>>>    Integer iStart iEnd
76422>>>>    String sRetval
76422>>>>
76422>>>>    Move (Trim(sConnect)) to sConnect
76423>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
76424>>>>    If (iStart = 0) Begin
76426>>>>        Function_Return ""
76427>>>>    End
76427>>>>>
76427>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
76428>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
76429>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
76431>>>>        Move (Pos(",", sRetval))          to iEnd
76432>>>>    End
76432>>>>>
76432>>>>    Else Begin
76433>>>>        Move (Pos(";", sRetval))          to iEnd
76434>>>>    End
76434>>>>>
76434>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
76436>>>>        Move (Pos(",", sRetval))          to iEnd
76437>>>>        Decrement iEnd
76438>>>>    End
76438>>>>>
76438>>>>    If (iEnd <> 0) Begin
76440>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
76441>>>>    End
76441>>>>>
76441>>>>    Move (Replace("=", sRetval, ""))      to sRetval
76442>>>>
76442>>>>    Function_Return (Trim(sRetval))
76443>>>>End_Function
76444>>>>
76444>>>>
76444>>>
76444>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76446>>>        String sConnect
76446>>>        Handle hoDriver
76446>>>
76446>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
76447>>>        Set psDriverID of hoDriver to sDriverID
76448>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
76449>>>        Send Destroy of hoDriver
76450>>>
76450>>>        Function_Return sConnect
76451>>>    End_Function
76452>>>
76452>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
76452>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
76454>>>        String sConnect
76454>>>
76454>>>        Case Begin
76454>>>            Case (sDriverID = MSSQLDRV_ID)
76456>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
76457>>>                If (sDatabase <> "") Begin
76459>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
76460>>>                End
76460>>>>
76460>>>                Case Break
76461>>>
76461>>>            Case (sDriverID = ODBC_DRV_ID)
76464>>>                If (Uppercase(sServer) contains ".DSN") Begin
76466>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
76467>>>                End
76467>>>>
76467>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
76470>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
76471>>>                End
76471>>>>
76471>>>
76471>>>                If (sDatabase <> "") Begin
76473>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
76474>>>                End
76474>>>>
76474>>>                Case Break
76475>>>
76475>>>            Case (sDriverID = DB2_DRV_ID)
76478>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
76479>>>                If (sDatabase <> "") Begin
76481>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
76482>>>                End
76482>>>>
76482>>>                Case Break
76483>>>
76483>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
76486>>>                Break
76487>>>
76487>>>            Case Else
76487>>>                Move "" to sConnect
76488>>>        Case End
76488>>>
76488>>>        Function_Return sConnect
76489>>>    End_Function
76490>>>
76490>>>    // Use Base64
76490>>>    Function EncryptPassword String sPassword Returns String
76492>>>        String sRetval
76492>>>        Handle hoLoginEncryption
76492>>>
76492>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
76493>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
76494>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
76495>>>        Send Destroy of hoLoginEncryption
76496>>>          
76496>>>        Function_Return sRetval
76497>>>    End_Function
76498>>>
76498>>>    Function DecryptPassword String sPassword Returns String
76500>>>        String sRetval
76500>>>        Handle hoLoginEncryption
76500>>>
76500>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
76501>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
76502>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
76503>>>        Send Destroy of hoLoginEncryption
76504>>>
76504>>>        Function_Return sRetval
76505>>>    End_Function
76506>>>
76506>>>    // Returns the full path of the Application (no trailing "\")
76506>>>    Function ApplicationPath Returns String
76508>>>        String sApplicationFileName sPath
76508>>>        Integer iNumChars iRetval
76508>>>
76508>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
76509>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
76510>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
76511>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
76512>>>        Move (CString(sApplicationFileName)) to sPath
76513>>>
76513>>>        Function_Return sPath
76514>>>    End_Function
76515>>>
76515>>>    // Pass a filename including the extension. The return value
76515>>>    // will be the path of of the first found "sSearchFileName in the workspace.
76515>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
76515>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
76517>>>        Boolean bExists
76517>>>        Handle hoPaths hoIniFile
76517>>>        String[] asWorkSpaceFiles
76518>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
76518>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
76518>>>        
76518>>>        Get psIniFilePath to sProgramsPath
76519>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
76520>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
76521>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
76522>>>        If (bExists = True) Begin
76524>>>            Function_Return sProgramsPath
76525>>>        End                      
76525>>>>
76525>>>    
76525>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
76526>>>        If (Right(sProgramsPath, 1) ="\") Begin
76528>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
76529>>>        End                                              
76529>>>>
76529>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
76530>>>        
76530>>>        Move False to bExists
76531>>>        Get Create (RefClass(Array)) to hoPaths
76532>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
76533>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
76534>>>        Decrement iSize       
76535>>>        
76535>>>        For iCount from 0 to iSize
76541>>>>
76541>>>            Move asWorkspaceFiles[iCount] to sFileName
76542>>>            Get Create (Refclass(cIniFile)) to hoIniFile
76543>>>            Set psFileName of hoIniFile to sFileName
76544>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
76545>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
76551>>>>
76551>>>                Get Value of hoPaths iPath to sSection    
76552>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
76553>>>                // Check if there are more than one path specified;
76553>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
76554>>>                If (iNoOfPaths > 1) Begin         
76556>>>                    Move sRelativePath to sRelativePaths
76557>>>                    For iCountPath from 1 to iNoOfPaths
76563>>>>
76563>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
76564>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
76565>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
76566>>>                        Get vFolderFormat sPath to sPath
76567>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
76568>>>                        If (bExists = True) Begin
76570>>>                            Move iNoOfPaths to iCountPath
76571>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
76572>>>                            Move iSize to iCount
76573>>>                        End                                                    
76573>>>>
76573>>>                    Loop
76574>>>>
76574>>>                End
76574>>>>
76574>>>                Else Begin
76575>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
76576>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
76577>>>                    Get vFolderFormat sPath to sPath
76578>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
76579>>>                    If (bExists = True) Begin
76581>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
76582>>>                        Move iSize to iCount
76583>>>                    End                                                    
76583>>>>
76583>>>                End
76583>>>>
76583>>>            Loop
76584>>>>
76584>>>            If (bExists = False) Begin
76586>>>                Move "" to sPath    
76587>>>            End
76587>>>>
76587>>>            Send Destroy of hoIniFile          
76588>>>        Loop        
76589>>>>
76589>>>        Send Destroy of hoPaths
76590>>>        
76590>>>        // Then not found in workspace, look for the file in DFSysPath;
76590>>>        If (sPath = "") Begin
76592>>>            Get_File_Path sSearchFileName to sFileName   
76593>>>            Get ParseFolderName sFileName to sPath
76594>>>        End                  
76594>>>>
76594>>>        
76594>>>        Function_Return sPath    
76595>>>    End_Function
76596>>>    
76596>>>    // Pass the path to the workspace Programs folder - returns a string array
76596>>>    // with one or more .ws file names.
76596>>>    // First checks if there is a .sws file - and if so reads the name of the
76596>>>    // workspace file (.ws) and returns it as a string array.
76596>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
76596>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
76598>>>        String[] asSWSFiles asWorkspaceFiles   
76600>>>        String sFile sHomePath sDirSep
76600>>>        Integer iCh iSize
76600>>>        Boolean bExists      
76600>>>        Handle hoIniFile 
76600>>>        
76600>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
76601>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
76602>>>        If (Right(sProgramsPath, 1) ="\") Begin
76604>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
76605>>>        End                                              
76605>>>>
76605>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
76606>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
76607>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
76608>>>        Get vFolderFormat sHomePath to sHomePath 
76609>>>        
76609>>>        // First check if theres an .sws file. If there is we will open it and
76609>>>        // read the name of the .ws file name.
76609>>>        File_Exist (sHomePath + "*.sws") bExists
76610>>>        If (bExists = True) Begin
76612>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
76613>>>            If (iCh < 0) Begin
76615>>>                Function_Return asSWSFiles
76616>>>            End                                 
76616>>>>
76616>>>            
76616>>>            Repeat
76616>>>>
76616>>>                Readln channel iCh sFile
76618>>>                If (Trim(sFile) <> "") Begin
76620>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
76621>>>                End
76621>>>>
76621>>>            Until (SeqEof = True)
76623>>>            Send Seq_Close_Channel iCh    
76624>>>            
76624>>>            Move (SizeOfArray(asSWSFiles)) to iSize
76625>>>            If (iSize <> 0) Begin
76627>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
76628>>>                // Use the file with that is last as it might have the DataFlex version in it,
76628>>>                // and thus is the latest one and it is more likely it is accurate (?)...
76628>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
76629>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
76630>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
76631>>>                If (sFile <> "") Begin
76633>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
76634>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
76635>>>                    File_Exist sFile bExists
76636>>>                    If (bExists = True) Begin
76638>>>                        Move sFile to asWorkspaceFiles[0] 
76639>>>                    End
76639>>>>
76639>>>                End
76639>>>>
76639>>>                Send Destroy of hoIniFile
76640>>>            End
76640>>>>
76640>>>        End
76640>>>>
76640>>>        
76640>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
76640>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
76642>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
76643>>>            File_Exist (sProgramsPath + "*.ws") bExists
76644>>>            If (bExists = False) Begin
76646>>>                Function_Return asWorkspaceFiles
76647>>>            End
76647>>>>
76647>>>        
76647>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
76648>>>            If (iCh < 0) Begin
76650>>>                Function_Return asWorkspaceFiles
76651>>>            End                                 
76651>>>>
76651>>>            
76651>>>            Repeat
76651>>>>
76651>>>                Readln channel iCh sFile
76653>>>                If (Trim(sFile) <> "") Begin
76655>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
76656>>>                End
76656>>>>
76656>>>            Until (SeqEof = True)
76658>>>            Send Seq_Close_Channel iCh
76659>>>        End
76659>>>>
76659>>>        
76659>>>        Function_Return asWorkspaceFiles
76660>>>    End_Function
76661>>>
76661>>>End_Class
76662>
76662>Object oHtmlHelp is a cHtmlHelp
76664>    Set pbAlwaysOnTop to False
76665>End_Object
76666>
76666>Object oApplication is a cApplication
76668>    Set peHelpType to htHtmlHelp
76669>    Set psHelpFile to "Developer5.chm"
76670>    Set psCompany to "RDC Tools International"
76671>    Set psProduct to "DUF - SQL Connections Manager"
76672>    Set psVersion to (String(piVersionMajor(phoVersionInfo(Self))) + "." + String(piVersionMinor(phoVersionInfo(Self))))
76673>    Set psAutoOpenWorkspace to ""
76674>
76674>    Property String psCommandLineIniFilePath ""
76676>    Property Boolean pbIniFileExists False     
76678>    Property Handle phoMainView 0
76680>
76680>    Property String psCompileDateAndTime
76682>    // This is used by the About object to display the compile date & time:
76682>    Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_LINE
76682>        
76682>    // If the folder contains exactly one workspace file (*.ws), it will be
76682>    // returned. Else an empty string ("") will be returned.
76682>    Function FindWorkspaceFile String sPath Returns String
76685>        String sSingleWorkspaceFile
76685>        Handle hoSQLIniFile                  
76685>        String[] aWsFiles
76686>        Integer iSize
76686>        
76686>        Get Create (RefClass(cSQLConnectionIniFile)) to hoSQLIniFile
76687>        Get WorkspaceIniFiles of hoSQLIniFile sPath to aWsFiles
76688>        Move (SizeOfArray(aWsFiles)) to iSize
76689>        If (iSize = 1) Begin
76691>            Move aWsFiles[0] to sSingleWorkspaceFile
76692>        End                    
76692>        Else Begin
76693>            Move "" to sSingleWorkspaceFile
76694>        End
76694>        Send Destroy of hoSQLIniFile      
76695>        Function_Return sSingleWorkspaceFile
76696>    End_Function
76697>
76697>    Procedure OnCreate
76700>        Integer eOpened
76700>        Handle hoCmdLine
76700>        String sArgument sPath sFileName sWsFile
76700>        Integer iRetval
76700>        Boolean bExists
76700>
76700>        Get phoCommandLine to hoCmdLine
76701>        Get Argument of hoCmdLine 1 to sArgument
76702>        If (sArgument <> "") Begin
76704>            Get ParseFolderName sArgument to sPath
76705>            Get vFolderExists sPath to iRetval
76706>            If (iRetval = True) Begin
76708>                Set psCommandLineIniFilePath to sPath
76709>                Get vFilePathExists (sPath + CS_SQLIniFileName) to bExists
76710>                Set pbIniFileExists to bExists
76711>            End
76711>        End
76711>
76711>        Get OpenWorkspaceFile of (phoWorkspace(Self)) "config.ws" to eOpened
76712>        If (eOpened <> wsWorkspaceOpened) Begin
76714>            Get GetApplicationPath to sPath     
76715>            Get FindWorkspaceFile sPath to sWsFile
76716>            If (sWsFile = "") Begin
76718>                Get vSelect_File "Workspace Files (*.ws)|*.ws|All Files (*.*)|*.*" "Please select a Workspace file (*.ws)" sPath to sWsFile
76719>                Get vFilePathExists sWsFile to bExists
76720>                If (bExists = False) Begin
76722>                    Send Stop_Box "No Workspace file selected. Cannot continue!"
76723>                    Send Exit_Application
76724>                End
76724>            End
76724>            Get OpenWorkspaceFile of (phoWorkspace(Self)) sWsFile to eOpened
76725>            If (eOpened <> wsWorkspaceOpened) Begin
76727>                Set psHome          of (phoWorkspace(Self)) to sPath
76728>                Set psProgramPath   of (phoWorkspace(Self)) to sPath
76729>                Set psDataPath      of (phoWorkspace(Self)) to sPath
76730>                Set psFileList      of (phoWorkspace(Self)) to sPath
76731>                Set psHelpPath      of (phoWorkspace(Self)) to sPath
76732>                Set psBitmapPath    of (phoWorkspace(Self)) to sPath
76733>            End
76733>        End
76733>    End_Procedure  
76734>    
76734>
76734>    Procedure End_Construct_Object
76737>        String sCompileTime  
76737>        Integer iPos
76737>        
76737>        Forward Send End_Construct_Object
76739>        Direct_Input "resource: res_CompileHeader"
76740>        Readln sCompileTime
76741>        Move (Pos('"', sCompileTime)) to iPos
76742>        If (iPos <> 0) Begin
76744>            Move (Mid(sCompileTime, Length(sCompileTime), (iPos + 1))) to sCompileTime
76745>            Move (Replaces('"', sCompileTime, '')) to sCompileTime
76746>            Set psCompileDateAndTime to sCompileTime
76747>        End
76747>        Close_Input
76748>    End_Procedure
76749>
76749>End_Object
76750>
76750>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
76750>>>//****************************************************************************
76750>>>// $Module type: Class
76750>>>// $Module name: cDbUpdateFunctionLibrary
76750>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
76750>>>// Web-site    : http://www.rdctools.com
76750>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
76750>>>//
76750>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
76750>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
76750>>>//               functions to make db changes to Sql databases with DAW drivers,
76750>>>//               with the help of Sql-scripts.
76750>>>//
76750>>>// $Rev History:
76750>>>//    2014-09-05  Module header created
76750>>>//
76750>>>//****************************************************************************
76750>>>//
76750>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
76750>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
76750>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
76750>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
76750>>>// decimals you may Get truncation that again may cause problems with finding.
76750>>>//
76750>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
76750>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
76750>>>
76750>>>
76750>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
76750>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
76750>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
76750>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
76750>>>//
76750>>>Use cBaseDbUpdateFuncLib.pkg
Including file: cBaseDbUpdateFuncLib.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cBaseDbUpdateFuncLib.pkg)
76750>>>>>//****************************************************************************
76750>>>>>// $Module type: Class
76750>>>>>// $Module name: cBaseDbUpdateFuncLib
76750>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
76750>>>>>// Web-site    : http://www.rdctools.com
76750>>>>>// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
76750>>>>>//
76750>>>>>// Description : The class consists of the basis/parent for the cDbUpdateFunctionLibrary class
76750>>>>>//               It contains helper functions for the cDbUpdateFunctionLibrary class
76750>>>>>//
76750>>>>>// $Rev History:
76750>>>>>//    2023-11-06  Module header created
76750>>>>>//
76750>>>>>//****************************************************************************
76750>>>>>Use cApplication.pkg
76750>>>>>Use seq_chnl.pkg
76750>>>>>Use GlobalFunctionsProcedures.pkg
76750>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
76750>>>>>Use Dfcursor.pkg
76750>>>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
76750>>>>>>>// StatPnl.pkg - creates the standard status_panel object.
76750>>>>>>>//
76750>>>>>>>//
76750>>>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
76750>>>>>>>// invoke the standard status panel. The standard has always been that the package name
76750>>>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
76750>>>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
76750>>>>>>>// prior revisions has been replace with status panel that is part of the application.
76750>>>>>>>// This should work much better and faster than the old sentinel based solution.
76750>>>>>>>// While the way this operates has changed, the interface has not and therefore this should work
76750>>>>>>>// with most applications.
76750>>>>>>>//
76750>>>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
76750>>>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
76750>>>>>>>// a cleaner more robust interface.
76750>>>>>>>//
76750>>>>>>>//
76750>>>>>>>// Compatibility Note:
76750>>>>>>>//
76750>>>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
76750>>>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
76750>>>>>>>//
76750>>>>>>>// If for some reason you application will not work using this as a replacement for the old status
76750>>>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
76750>>>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
76750>>>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
76750>>>>>>>//
76750>>>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
76750>>>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
76750>>>>>>>//
76750>>>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
76750>>>>>>>// can still access the new object via the ghoStatusPanel handle.
76750>>>>>>>//
76750>>>>>>>//
76750>>>>>>>// Creating your own Status Panel objects
76750>>>>>>>//
76750>>>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
76750>>>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
76750>>>>>>>// with a different file and object name and direct your status panel request to the new object.
76750>>>>>>>//
76750>>>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
76750>>>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
76750>>>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
76750>>>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
76750>>>>>>>// e.g.
76750>>>>>>>//       Procedure UpdateStatusBar
76750>>>>>>>//           Send DoAdvance of oProgressBar
76750>>>>>>>//           Send ProcessEvents
76750>>>>>>>//       End_Procedure
76750>>>>>>>//
76750>>>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
76750>>>>>>>// messages this will be done for you.
76750>>>>>>>//
76750>>>>>>>// the standard Interface for status panels are:
76750>>>>>>>//
76750>>>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
76750>>>>>>>// Send Start_StatusPanel      - start the status panel
76750>>>>>>>// Send Stop_StatusPanel       - stop the status panel
76750>>>>>>>// Send Update_StatusPanel     - update the status panel's action area
76750>>>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
76750>>>>>>>//
76750>>>>>>>// Get/Set Caption_Text - updates the caption bar
76750>>>>>>>// Get/Set Title_Text   - updates the title area
76750>>>>>>>// Get/Set Message_Text - updates the Message area
76750>>>>>>>// Get/Set Action_Text  - updates the action area
76750>>>>>>>// Get/Set Button_Text  - updates the button area
76750>>>>>>>//
76750>>>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
76750>>>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
76750>>>>>>>//
76750>>>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
76750>>>>>>>Use cProcessStatusPanel.pkg
76750>>>>>>>Use cCJSkinFramework.pkg
76750>>>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cProgressBar.pkg)
76750>>>>>>>>>Use Windows.pkg
76750>>>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cWinControl.pkg)
76750>>>>>>>>>>>Use Windows.pkg
76750>>>>>>>>>>>
76750>>>>>>>>>>>// Key State Masks for Mouse Messages
76750>>>>>>>>>>>
76750>>>>>>>>>>>Define MK_LBUTTON  for |CI$0001
76750>>>>>>>>>>>Define MK_RBUTTON  for |CI$0002
76750>>>>>>>>>>>Define MK_SHIFT    for |CI$0004
76750>>>>>>>>>>>Define MK_CONTROL  for |CI$0008
76750>>>>>>>>>>>Define MK_MBUTTON  for |CI$0010
76750>>>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
76750>>>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
76750>>>>>>>>>>>
76750>>>>>>>>>>>Enum_List // Mouse Key Flags
76750>>>>>>>>>>>    Define mkLeft    for MK_LBUTTON
76750>>>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
76750>>>>>>>>>>>    Define mkRight   for MK_RBUTTON
76750>>>>>>>>>>>    Define mkX1      for MK_XBUTTON1
76750>>>>>>>>>>>    Define mkX2      for MK_XBUTTON2
76750>>>>>>>>>>>    Define mkShift   for MK_SHIFT
76750>>>>>>>>>>>    Define mkControl for MK_CONTROL
76750>>>>>>>>>>>End_Enum_List
76750>>>>>>>>>>>
76750>>>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
76750>>>>>>>>>>>    Define mbLeft
76750>>>>>>>>>>>    Define mbMiddle
76750>>>>>>>>>>>    Define mbRight
76750>>>>>>>>>>>    Define mbX1
76750>>>>>>>>>>>    Define mbX2
76750>>>>>>>>>>>End_Enum_List
76750>>>>>>>>>>>
76750>>>>>>>>>>>Class cWinControl is a DfBaseControl
76751>>>>>>>>>>>    Procedure Construct_Object
76753>>>>>>>>>>>        Forward Send Construct_Object
76755>>>>>>>>>>>        Property Integer private_pbEnabled True
76756>>>>>>>>>>>        Property Integer private_pbVisible True
76757>>>>>>>>>>>    End_Procedure
76758>>>>>>>>>>>    
76758>>>>>>>>>>>    Procedure End_Construct_Object
76760>>>>>>>>>>>        Forward Send End_Construct_Object
76762>>>>>>>>>>>        
76762>>>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
76763>>>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
76764>>>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
76765>>>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
76766>>>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
76767>>>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
76768>>>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
76769>>>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
76770>>>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
76771>>>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
76772>>>>>>>>>>>    End_Procedure
76773>>>>>>>>>>>    
76773>>>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
76775>>>>>>>>>>>        //Intentionally cancelled
76775>>>>>>>>>>>    End_Procedure
76776>>>>>>>>>>>    
76776>>>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
76778>>>>>>>>>>>        //Intentionally cancelled
76778>>>>>>>>>>>    End_Procedure
76779>>>>>>>>>>>    
76779>>>>>>>>>>>    Procedure DoRecreateWindow
76781>>>>>>>>>>>        // Recreates the window
76781>>>>>>>>>>>        If (Window_Handle(Self)) Begin
76783>>>>>>>>>>>            // attempt to do this without disturbing the focus tree.
76783>>>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
76784>>>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
76785>>>>>>>>>>>        End
76785>>>>>>>>>>>>
76785>>>>>>>>>>>    End_Procedure
76786>>>>>>>>>>>    
76786>>>>>>>>>>>    Procedure DoUpdateWindow
76788>>>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
76788>>>>>>>>>>>        Handle hWnd
76788>>>>>>>>>>>        
76788>>>>>>>>>>>        Get Window_Handle to hWnd
76789>>>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
76792>>>>>>>>>>>    End_Procedure
76793>>>>>>>>>>>    
76793>>>>>>>>>>>    Procedure Page Integer iState
76795>>>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
76796>>>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
76797>>>>>>>>>>>        Forward Send Page iState
76799>>>>>>>>>>>    End_Procedure
76800>>>>>>>>>>>    
76800>>>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
76802>>>>>>>>>>>        Integer x y eButton
76802>>>>>>>>>>>        
76802>>>>>>>>>>>        Move (Hi(lParam))  to y
76803>>>>>>>>>>>        Move (Low(lParam)) to x
76804>>>>>>>>>>>        
76804>>>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
76805>>>>>>>>>>>    End_Procedure
76806>>>>>>>>>>>    
76806>>>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
76808>>>>>>>>>>>        Integer x y eButton
76808>>>>>>>>>>>        
76808>>>>>>>>>>>        Move (Hi(lParam))  to y
76809>>>>>>>>>>>        Move (Low(lParam)) to x
76810>>>>>>>>>>>        
76810>>>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
76811>>>>>>>>>>>    End_Procedure
76812>>>>>>>>>>>    
76812>>>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
76814>>>>>>>>>>>        Integer x y eButton
76814>>>>>>>>>>>        
76814>>>>>>>>>>>        Move (Hi(lParam))  to y
76815>>>>>>>>>>>        Move (Low(lParam)) to x
76816>>>>>>>>>>>        
76816>>>>>>>>>>>        Send OnMouseUp mbRight x y wParam
76817>>>>>>>>>>>    End_Procedure
76818>>>>>>>>>>>    
76818>>>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
76820>>>>>>>>>>>        Integer x y eButton fKeys
76820>>>>>>>>>>>        
76820>>>>>>>>>>>        Move (Hi(lParam))  to y
76821>>>>>>>>>>>        Move (Low(lParam)) to x
76822>>>>>>>>>>>        
76822>>>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
76823>>>>>>>>>>>    End_Procedure
76824>>>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
76826>>>>>>>>>>>        Integer x y eButton
76826>>>>>>>>>>>        
76826>>>>>>>>>>>        Move (Hi(lParam))  to y
76827>>>>>>>>>>>        Move (Low(lParam)) to x
76828>>>>>>>>>>>        
76828>>>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
76829>>>>>>>>>>>    End_Procedure
76830>>>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
76832>>>>>>>>>>>        Integer x y eButton
76832>>>>>>>>>>>        
76832>>>>>>>>>>>        Move (Hi(lParam))  to y
76833>>>>>>>>>>>        Move (Low(lParam)) to x
76834>>>>>>>>>>>        
76834>>>>>>>>>>>        Send OnMouseDown mbRight x y wParam
76835>>>>>>>>>>>    End_Procedure
76836>>>>>>>>>>>    
76836>>>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
76838>>>>>>>>>>>        Integer x y eButton
76838>>>>>>>>>>>        
76838>>>>>>>>>>>        Move (Hi(lParam))  to y
76839>>>>>>>>>>>        Move (Low(lParam)) to x
76840>>>>>>>>>>>        
76840>>>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
76841>>>>>>>>>>>    End_Procedure
76842>>>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
76844>>>>>>>>>>>        Integer x y eButton
76844>>>>>>>>>>>        
76844>>>>>>>>>>>        Move (Hi(lParam))  to y
76845>>>>>>>>>>>        Move (Low(lParam)) to x
76846>>>>>>>>>>>        
76846>>>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
76847>>>>>>>>>>>    End_Procedure
76848>>>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
76850>>>>>>>>>>>        Integer x y eButton
76850>>>>>>>>>>>        
76850>>>>>>>>>>>        Move (Hi(lParam))  to y
76851>>>>>>>>>>>        Move (Low(lParam)) to x
76852>>>>>>>>>>>        
76852>>>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
76853>>>>>>>>>>>    End_Procedure
76854>>>>>>>>>>>    
76854>>>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
76856>>>>>>>>>>>        Integer x y eButton
76856>>>>>>>>>>>        
76856>>>>>>>>>>>        Move (Hi(lParam))  to y
76857>>>>>>>>>>>        Move (Low(lParam)) to x
76858>>>>>>>>>>>        
76858>>>>>>>>>>>        Send OnMouseMove x y wParam
76859>>>>>>>>>>>    End_Procedure
76860>>>>>>>>>>>    
76860>>>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
76862>>>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
76862>>>>>>>>>>>        //String sButton
76862>>>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
76862>>>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
76862>>>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
76862>>>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
76862>>>>>>>>>>>        
76862>>>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
76862>>>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
76862>>>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
76862>>>>>>>>>>>    End_Procedure
76863>>>>>>>>>>>    
76863>>>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
76865>>>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
76865>>>>>>>>>>>        //String sButton
76865>>>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
76865>>>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
76865>>>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
76865>>>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
76865>>>>>>>>>>>        
76865>>>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
76865>>>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
76865>>>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
76865>>>>>>>>>>>    End_Procedure
76866>>>>>>>>>>>    
76866>>>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
76868>>>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
76868>>>>>>>>>>>        //String sButton
76868>>>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
76868>>>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
76868>>>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
76868>>>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
76868>>>>>>>>>>>        
76868>>>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
76868>>>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
76868>>>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
76868>>>>>>>>>>>    End_Procedure
76869>>>>>>>>>>>    
76869>>>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
76871>>>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
76871>>>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
76871>>>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
76871>>>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
76871>>>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
76871>>>>>>>>>>>        
76871>>>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
76871>>>>>>>>>>>    End_Procedure
76872>>>>>>>>>>>    
76872>>>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
76874>>>>>>>>>>>        Handle hWnd
76874>>>>>>>>>>>        
76874>>>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
76876>>>>>>>>>>>            Set private_pbEnabled to bEnabled
76877>>>>>>>>>>>            Get Window_Handle to hWnd
76878>>>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
76881>>>>>>>>>>>        End
76881>>>>>>>>>>>>
76881>>>>>>>>>>>    End_Procedure
76882>>>>>>>>>>>    Function pbEnabled Returns Boolean
76884>>>>>>>>>>>        Function_Return (private_pbEnabled(Self))
76885>>>>>>>>>>>    End_Function
76886>>>>>>>>>>>    
76886>>>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
76888>>>>>>>>>>>        Handle  hWnd
76888>>>>>>>>>>>        Integer iVoid
76888>>>>>>>>>>>        
76888>>>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
76890>>>>>>>>>>>            Set private_pbVisible to bVisible
76891>>>>>>>>>>>            Get Window_Handle to hWnd
76892>>>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
76895>>>>>>>>>>>        End
76895>>>>>>>>>>>>
76895>>>>>>>>>>>    End_Procedure
76896>>>>>>>>>>>    Function pbVisible Returns Boolean
76898>>>>>>>>>>>        Function_Return (private_pbVisible(Self))
76899>>>>>>>>>>>    End_Function
76900>>>>>>>>>>>    
76900>>>>>>>>>>>End_Class
76901>>>>>>>>>Use CommCtrl.pkg
76901>>>>>>>>>
76901>>>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
76901>>>>>>>>>Class cProgressBar is a cWinControl
76902>>>>>>>>>    
76902>>>>>>>>>    Procedure Construct_Object
76904>>>>>>>>>        Forward Send Construct_Object
76906>>>>>>>>>        Property Integer private_piMinimum
76907>>>>>>>>>        Property Integer private_piMaximum   100
76908>>>>>>>>>        Property Integer private_piAdvanceBy 10
76909>>>>>>>>>        Property Integer private_piPosition
76910>>>>>>>>>        Property Integer private_pbVertical  False
76911>>>>>>>>>        Property Integer private_pbSmooth    False
76912>>>>>>>>>        Property Integer private_piBackColor clDefault
76913>>>>>>>>>        Property Integer private_piBarColor  clDefault
76914>>>>>>>>>        
76914>>>>>>>>>        Send Define_ToolTip_Support_Mixin
76915>>>>>>>>>        
76915>>>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
76916>>>>>>>>>        Set Focus_Mode to NonFocusable
76917>>>>>>>>>        Set Skip_State to True
76918>>>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
76919>>>>>>>>>    End_Procedure
76920>>>>>>>>>    
76920>>>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
76921>>>>>>>>>    
76921>>>>>>>>>    Procedure Set piMinimum Integer iMin
76923>>>>>>>>>        Integer iMax
76923>>>>>>>>>        
76923>>>>>>>>>        Set private_piMinimum to iMin
76924>>>>>>>>>        Get private_piMaximum to iMax
76925>>>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
76926>>>>>>>>>    End_Procedure
76927>>>>>>>>>    Function piMinimum Returns Integer
76929>>>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
76932>>>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
76934>>>>>>>>>    End_Function
76935>>>>>>>>>    
76935>>>>>>>>>    Procedure Set piMaximum Integer iMax
76937>>>>>>>>>        Integer iMin
76937>>>>>>>>>        
76937>>>>>>>>>        Set private_piMaximum to iMax
76938>>>>>>>>>        Get private_piMinimum to iMin
76939>>>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
76940>>>>>>>>>    End_Procedure
76941>>>>>>>>>    Function piMaximum Returns Integer
76943>>>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
76946>>>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
76948>>>>>>>>>    End_Function
76949>>>>>>>>>    
76949>>>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
76951>>>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
76952>>>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
76953>>>>>>>>>    End_Procedure
76954>>>>>>>>>    Function piAdvanceBy Returns Integer
76956>>>>>>>>>        Function_Return (private_piAdvanceBy(Self))
76957>>>>>>>>>    End_Function
76958>>>>>>>>>    
76958>>>>>>>>>    Procedure Set piPosition Integer iPos
76960>>>>>>>>>        Set private_piPosition to iPos
76961>>>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
76962>>>>>>>>>    End_Procedure
76963>>>>>>>>>    
76963>>>>>>>>>    Function piPosition Returns Integer
76965>>>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
76968>>>>>>>>>        Else;            Function_Return (private_piPosition(Self))
76970>>>>>>>>>    End_Function
76971>>>>>>>>>    
76971>>>>>>>>>    Procedure Set pbVertical Boolean bVertical
76973>>>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
76975>>>>>>>>>            Set private_pbVertical to bVertical
76976>>>>>>>>>            Send DoRecreateWindow
76977>>>>>>>>>        End
76977>>>>>>>>>>
76977>>>>>>>>>    End_Procedure
76978>>>>>>>>>    
76978>>>>>>>>>    Function pbVertical Returns Boolean
76980>>>>>>>>>        Function_Return (private_pbVertical(Self))
76981>>>>>>>>>    End_Function
76982>>>>>>>>>    
76982>>>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
76984>>>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
76986>>>>>>>>>            Set private_pbSmooth to bSmooth
76987>>>>>>>>>            Send DoRecreateWindow
76988>>>>>>>>>        End
76988>>>>>>>>>>
76988>>>>>>>>>    End_Procedure
76989>>>>>>>>>    Function pbSmooth Returns Boolean
76991>>>>>>>>>        Function_Return (private_pbSmooth(Self))
76992>>>>>>>>>    End_Function
76993>>>>>>>>>    
76993>>>>>>>>>    Procedure Set piBackColor Integer rgbColor
76995>>>>>>>>>        Set private_piBackColor to rgbColor
76996>>>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
76997>>>>>>>>>    End_Procedure
76998>>>>>>>>>    Function piBackColor Returns Integer
77000>>>>>>>>>        Function_Return (private_piBackColor(Self))
77001>>>>>>>>>    End_Function
77002>>>>>>>>>    
77002>>>>>>>>>    Procedure Set piBarColor Integer rgbColor
77004>>>>>>>>>        Set private_piBarColor to rgbColor
77005>>>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
77006>>>>>>>>>    End_Procedure
77007>>>>>>>>>    Function piBarColor Returns Integer
77009>>>>>>>>>        Function_Return (private_piBarColor(Self))
77010>>>>>>>>>    End_Function
77011>>>>>>>>>    
77011>>>>>>>>>    Procedure DoAdvance
77013>>>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
77014>>>>>>>>>    End_Procedure
77015>>>>>>>>>    
77015>>>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
77017>>>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
77018>>>>>>>>>    End_Procedure
77019>>>>>>>>>    
77019>>>>>>>>>    Procedure private_DoInitWindow
77021>>>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
77022>>>>>>>>>        Set piBackColor to (private_piBackColor(Self))
77023>>>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
77024>>>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
77025>>>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
77026>>>>>>>>>        Set piPosition  to (private_piPosition(Self))
77027>>>>>>>>>    End_Procedure
77028>>>>>>>>>    
77028>>>>>>>>>    Procedure Page_Object Integer iState
77030>>>>>>>>>        Handle hWnd
77030>>>>>>>>>        
77030>>>>>>>>>        Get Window_Handle to hWnd
77031>>>>>>>>>        If (hWnd=0 and iState) Begin
77033>>>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
77034>>>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
77035>>>>>>>>>            Forward Send Page_Object True
77037>>>>>>>>>        End
77037>>>>>>>>>>
77037>>>>>>>>>        Else ;            Forward Send Page_Object iState
77040>>>>>>>>>        
77040>>>>>>>>>        // Handle tooltip support....
77040>>>>>>>>>        If (iState = 0) Begin
77042>>>>>>>>>            Send RequestDeleteToolTip
77043>>>>>>>>>        End
77043>>>>>>>>>>
77043>>>>>>>>>        Else Begin
77044>>>>>>>>>            Send RequestAddToolTip
77045>>>>>>>>>        End
77045>>>>>>>>>>
77045>>>>>>>>>    End_Procedure
77046>>>>>>>>>    
77046>>>>>>>>>    Procedure Page Integer iState
77048>>>>>>>>>        Forward Send Page iState
77050>>>>>>>>>        If (iState =1);            Send private_DoInitWindow
77053>>>>>>>>>    End_Procedure
77054>>>>>>>>>    
77054>>>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
77054>>>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
77054>>>>>>>>>    // is implemented in a mixin class.
77054>>>>>>>>>    Procedure RequestAddToolTip
77056>>>>>>>>>        Send AddToolTip
77057>>>>>>>>>    End_Procedure
77058>>>>>>>>>    
77058>>>>>>>>>    
77058>>>>>>>>>    // Called by Page_Object. Handles tooltip removal.
77058>>>>>>>>>    Procedure RequestDeleteToolTip
77060>>>>>>>>>        Send DeleteToolTip
77061>>>>>>>>>    End_Procedure
77062>>>>>>>>>End_Class
77063>>>>>>>Use Windows.pkg
77063>>>>>>>Use DUFLanguageConstants.inc
77063>>>>>>>Use Statpnl.pkg
77063>>>>>>>
77063>>>>>>>
77063>>>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
77063>>>>>>>
77063>>>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
77063>>>>>>>
77063>>>>>>>Object Status_Panel is a cProcessStatusPanel
77065>>>>>>>    Set Size to 152 222
77066>>>>>>>    Set Border_Style to Border_Dialog
77067>>>>>>>    Set Icon to "Default.ico"
77068>>>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
77069>>>>>>>
77069>>>>>>>    Property Boolean Cancel_Button_Visible_State True
77071>>>>>>>
77071>>>>>>>    Procedure Activate
77074>>>>>>>        Integer iSizeBefore
77074>>>>>>>        Get GuiSize to iSizeBefore
77075>>>>>>>        Forward Send Activate
77077>>>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
77078>>>>>>>    End_Procedure
77079>>>>>>>
77079>>>>>>>    Procedure End_Construct_Object
77082>>>>>>>        Forward Send End_Construct_Object
77084>>>>>>>        Set Label of oTitleTxt      to ""
77085>>>>>>>        Set Label of oTableNameTxt  to ""
77086>>>>>>>        Set Label of oMessageTxt    to ""
77087>>>>>>>        Set Label of oActionTxt     to ""
77088>>>>>>>    End_Procedure
77089>>>>>>>
77089>>>>>>>    Object oTitleTxt is a TextBox
77091>>>>>>>        Set Location to 5 21
77092>>>>>>>        Set Size to 8 179
77093>>>>>>>        Set Auto_Size_State to False
77094>>>>>>>        Set Justification_Mode  to jMode_Center
77095>>>>>>>        Set Label to "This is the Title Text"
77096>>>>>>>    End_Object
77097>>>>>>>
77097>>>>>>>    Object oTableNameTxt is a TextBox
77099>>>>>>>        Set Size to 19 204
77100>>>>>>>        Set Location to 18 9
77101>>>>>>>        Set Auto_Size_State to False
77102>>>>>>>        Set Justification_Mode to JMode_Left
77103>>>>>>>        Set Label to "This is the TableName Text"
77104>>>>>>>    End_Object
77105>>>>>>>
77105>>>>>>>    Object oMessageTxt is a TextBox
77107>>>>>>>        Set Location to 39 9
77108>>>>>>>        Set Size to 19 204
77109>>>>>>>        Set Auto_Size_State to False
77110>>>>>>>        Set Justification_Mode to JMode_Left
77111>>>>>>>        Set Label to "This is the Message text"
77112>>>>>>>    End_Object
77113>>>>>>>
77113>>>>>>>    Object oActionTxt is a TextBox
77115>>>>>>>        Set Size to 16 204
77116>>>>>>>        Set Location to 60 9
77117>>>>>>>        Set Auto_Size_State to False
77118>>>>>>>        Set Justification_Mode to JMode_Left
77119>>>>>>>        Set Label to "This is the Action Text"
77120>>>>>>>    End_Object
77121>>>>>>>
77121>>>>>>>    Object oStopButton is a Button
77123>>>>>>>        Set Location to 123 82
77124>>>>>>>        Set Label to C_$Cancel
77125>>>>>>>
77125>>>>>>>        Procedure OnClick 
77128>>>>>>>            Integer iRetval
77128>>>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
77129>>>>>>>            If (iRetval = MBR_Yes) Begin
77131>>>>>>>                Send Exit_Application
77132>>>>>>>            End
77132>>>>>>>>
77132>>>>>>>        End_Procedure
77133>>>>>>>
77133>>>>>>>    End_Object
77134>>>>>>>
77134>>>>>>>    Object oPercentage_tb is a TextBox
77136>>>>>>>        Set Location to 74 196
77137>>>>>>>        Set Size to 10 25
77138>>>>>>>//        Set Label to "% Done"
77138>>>>>>>    End_Object
77139>>>>>>>
77139>>>>>>>    Object oCopyRight is a TextBox
77141>>>>>>>        Set Location to 140 21
77142>>>>>>>        Set Size to 9 197
77143>>>>>>>        Set FontPointHeight to 8
77144>>>>>>>        Set Auto_Size_State to False
77145>>>>>>>        Set Justification_Mode  to jMode_Center
77146>>>>>>>        Set Label to "Copyright 2001-2020 RDC Tools International"
77147>>>>>>>    End_Object
77148>>>>>>>
77148>>>>>>>    Object oProgressBar is a cProgressBar
77150>>>>>>>        Set Size to 10 179
77151>>>>>>>        Set Location to 83 22
77152>>>>>>>        Set pbVisible to True // default
77153>>>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
77154>>>>>>>    End_Object
77155>>>>>>>
77155>>>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
77158>>>>>>>        Set pbVisible of ghoProgressBar to bVisible
77159>>>>>>>    End_Procedure
77160>>>>>>>
77160>>>>>>>    Function Progress_Bar_Visible_State Returns Boolean
77163>>>>>>>        Boolean bVisible
77163>>>>>>>        Get pbVisible of ghoProgressBar to bVisible
77164>>>>>>>        Function_Return (bVisible)
77165>>>>>>>    End_Function
77166>>>>>>>
77166>>>>>>>    Object oProgressBarOverall is a cProgressBar
77168>>>>>>>        Set Size to 10 179
77169>>>>>>>        Set Location to 107 22
77170>>>>>>>        Set pbVisible to True // default
77171>>>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
77172>>>>>>>    End_Object
77173>>>>>>>
77173>>>>>>>    Object oOverallProgress_tb is a TextBox
77175>>>>>>>        Set Size to 10 65
77176>>>>>>>        Set Location to 95 24
77177>>>>>>>        Set Label to "Overall Progress"
77178>>>>>>>    End_Object
77179>>>>>>>
77179>>>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
77182>>>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
77183>>>>>>>    End_Procedure
77184>>>>>>>
77184>>>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
77187>>>>>>>        Boolean bVisible
77187>>>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
77188>>>>>>>        Function_Return (bVisible)
77189>>>>>>>    End_Function
77190>>>>>>>
77190>>>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
77190>>>>>>>    // objects defined within this instance of the status panel.
77190>>>>>>>
77190>>>>>>>    // note: all of the messages that change text should be forwarded
77190>>>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
77190>>>>>>>
77190>>>>>>>    Procedure Set Message_Text String sText
77193>>>>>>>        Set Label of oMessageTxt to sText
77194>>>>>>>        Forward Set Message_Text to sText
77196>>>>>>>    End_Procedure
77197>>>>>>>
77197>>>>>>>    Function Message_Text Returns String
77200>>>>>>>        Function_Return (Label(oMessageTxt))
77201>>>>>>>    End_Function
77202>>>>>>>
77202>>>>>>>    Procedure Set Action_Text String sText
77205>>>>>>>        Set Label of oActionTxt to sText
77206>>>>>>>        Forward Set Action_Text to sText
77208>>>>>>>    End_Procedure
77209>>>>>>>
77209>>>>>>>    Function Action_Text Returns String
77212>>>>>>>        Function_Return (Label(oActionTxt))
77213>>>>>>>    End_Function
77214>>>>>>>
77214>>>>>>>    Procedure Set Button_Text String sText
77217>>>>>>>        Set Label of oStopButton to sText
77218>>>>>>>        Forward Set Button_Text to sText
77220>>>>>>>    End_Procedure
77221>>>>>>>
77221>>>>>>>    Function Button_Text Returns String
77224>>>>>>>        Function_Return (Label(oStopButton))
77225>>>>>>>    End_Function
77226>>>>>>>
77226>>>>>>>    Procedure Set Title_Text String sText
77229>>>>>>>        Set Label of oTitleTxt to sText
77230>>>>>>>        Forward Set Title_Text to sText
77232>>>>>>>    End_Procedure
77233>>>>>>>
77233>>>>>>>    Function Title_Text Returns String
77236>>>>>>>        Function_Return (Label(oTitleTxt))
77237>>>>>>>    End_Function
77238>>>>>>>
77238>>>>>>>    Procedure Set TableName_Text String sText
77241>>>>>>>        Set Label of oTableNameTxt to sText
77242>>>>>>>    End_Procedure
77243>>>>>>>
77243>>>>>>>    Function TableName_Text Returns String
77246>>>>>>>        Function_Return (Label(oTableNameTxt))
77247>>>>>>>    End_Function
77248>>>>>>>
77248>>>>>>>    Procedure Set License_Text String sText
77251>>>>>>>//        Set Label of oLicense_txt to sText
77251>>>>>>>    End_Procedure
77252>>>>>>>
77252>>>>>>>    // gets called when status panel is activated passing whether a button
77252>>>>>>>    // should appear
77252>>>>>>>    Procedure EnableCancelButton Boolean bEnable
77255>>>>>>>        Boolean bVisible
77255>>>>>>>        Get Cancel_Button_Visible_State to bVisible
77256>>>>>>>        If (bEnable = False) Begin
77258>>>>>>>            Set Visible_State of oStopButton to bVisible
77259>>>>>>>        End
77259>>>>>>>>
77259>>>>>>>        Set Enabled_State of oStopButton to bEnable
77260>>>>>>>    End_Procedure
77261>>>>>>>
77261>>>>>>>    Procedure Reset_StatusPanel
77264>>>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
77265>>>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
77266>>>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
77267>>>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
77268>>>>>>>    End_Procedure
77269>>>>>>>
77269>>>>>>>//    Object oProgressBar is a cProgressBar
77269>>>>>>>//        Move Self to ghoProgressBar
77269>>>>>>>//        Set Location to 1 25
77269>>>>>>>//        Set Size to 9 173
77269>>>>>>>//        Set piMinimum        to 0
77269>>>>>>>//        Set piMaximum        to 2000
77269>>>>>>>//        Set piAdvanceBy      to 100
77269>>>>>>>//        Set pbSmooth to True
77269>>>>>>>//
77269>>>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
77269>>>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
77269>>>>>>>//        // color will show correctly.
77269>>>>>>>//        Procedure Page Integer iPageObject
77269>>>>>>>//            Handle hWin
77269>>>>>>>//            Forward Send Page iPageObject
77269>>>>>>>//            If (ghoSkinFramework <> 0) Begin
77269>>>>>>>//                Get Window_Handle to hWin
77269>>>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
77269>>>>>>>//            End
77269>>>>>>>//        End_Procedure
77269>>>>>>>//    End_Object
77269>>>>>>>
77269>>>>>>>End_Object
77270>>>>>>>
77270>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
77270>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
77270>>>>>>>//
77270>>>>>>>// We need to create a mixin class for the library.
77270>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
77270>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
77270>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
77270>>>>>>>// Note: This class should _not_ have a construct_object defined.
77270>>>>>>>//
77270>>>>>>>Use VdfBase.pkg
77270>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 23.0\Pkg\WinUuid.pkg)
77270>>>>>>>>>Use Unicode.Pkg
77270>>>>>>>>>
77270>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
77271>>>>>>>>>
77271>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
77272>>>>>>>>>
77272>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
77273>>>>>>>>>
77273>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
77274>>>>>>>>>
77274>>>>>>>>>
77274>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
77274>>>>>>>>>Function RandomHexUUID Global Returns String
77276>>>>>>>>>    Pointer pUUID pUUIDStr
77276>>>>>>>>>    Integer iRetval iOffset iChar
77276>>>>>>>>>    String sUUID
77276>>>>>>>>>    
77276>>>>>>>>>    Move (Alloc(16)) to pUUID
77277>>>>>>>>>    
77277>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
77278>>>>>>>>>    
77278>>>>>>>>>    If (iRetval = 0) Begin
77280>>>>>>>>>        Move 0 to pUUIDStr
77281>>>>>>>>>        
77281>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
77282>>>>>>>>>        If (iRetval = 0) Begin
77284>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
77285>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
77286>>>>>>>>>            
77286>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
77287>>>>>>>>>        End
77287>>>>>>>>>>
77287>>>>>>>>>    End
77287>>>>>>>>>>
77287>>>>>>>>>    
77287>>>>>>>>>    Move (Free(pUUID)) to iRetval
77288>>>>>>>>>    
77288>>>>>>>>>    Function_Return sUUID
77289>>>>>>>>>End_Function
77290>>>>>>>>>
77290>>>>>>>>>
77290>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
77290>>>>>>>>>Function SeqHexUUID Global Returns String
77292>>>>>>>>>    Pointer pUUID pUUIDStr
77292>>>>>>>>>    Integer iRetval iOffset iChar
77292>>>>>>>>>    String sUUID
77292>>>>>>>>>    
77292>>>>>>>>>    Move (Alloc(16)) to pUUID
77293>>>>>>>>>    
77293>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
77294>>>>>>>>>    
77294>>>>>>>>>    If (iRetval = 0) Begin
77296>>>>>>>>>        Move 0 to pUUIDStr
77297>>>>>>>>>        
77297>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
77298>>>>>>>>>        If (iRetval = 0) Begin
77300>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
77301>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
77302>>>>>>>>>            
77302>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
77303>>>>>>>>>        End
77303>>>>>>>>>>
77303>>>>>>>>>    End
77303>>>>>>>>>>
77303>>>>>>>>>    
77303>>>>>>>>>    Move (Free(pUUID)) to iRetval
77304>>>>>>>>>    
77304>>>>>>>>>    Function_Return sUUID
77305>>>>>>>>>End_Function
77306>>>>>>>Use cli.pkg
77306>>>>>>>Use sql.pkg
77306>>>>>>>Use MSSqldrv.pkg
77306>>>>>>>Use db2_drv.pkg
77306>>>>>>>Use odbc_drv.pkg
77306>>>>>>>Use DFBTRDRV.PKG
77306>>>>>>>Use cSQLConnectionIniFile.inc
77306>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
77306>>>>>>>>>Use DUFLanguageConstants.inc
77306>>>>>>>>>
77306>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
77306>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
77306>>>>>>>>>
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_OEM_Txt for "OEM"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_SERVER for "SERVER"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
77306>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
77306>>>>>>>>>
77306>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
77306>>>>>>>>>
77306>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
77306>>>>>>>>>    Global_Variable Handle ghoDbUpdateHandler    
77306>>>>>>>>>    Move 0 to ghoDbUpdateHandler
77307>>>>>>>>>
77307>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
77307>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
77308>>>>>>>>>
77308>>>>>>>>>Struct tSQLScriptArray
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>    Boolean bArgumentSizeChanged
77308>>>>>>>>>    Integer iOrgArgumentSize
77308>>>>>>>>>    String[] sSQLScriptArray
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tSqlErrorArray
77308>>>>>>>>>    String[]  sSqlErrorArray
77308>>>>>>>>>    String[]  sSqlStatementArray
77308>>>>>>>>>    Integer[] iSqlErrorArray
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tSqlColumnNew
77308>>>>>>>>>    String  sBaseColumnName
77308>>>>>>>>>    String  sBaseTableName
77308>>>>>>>>>    String  sLabel
77308>>>>>>>>>    Integer iSqlType
77308>>>>>>>>>    Integer iSize
77308>>>>>>>>>    Integer iPrecision
77308>>>>>>>>>    Integer iDFType
77308>>>>>>>>>    Integer iDFNativeType
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tColumnType
77308>>>>>>>>>    String  sSQLType
77308>>>>>>>>>    Integer iSQLType
77308>>>>>>>>>    Boolean bCanEditSize
77308>>>>>>>>>    Integer iDefaultSize
77308>>>>>>>>>    Integer iMinSize
77308>>>>>>>>>    Number  nMaxSize
77308>>>>>>>>>    String  sDataFlexType
77308>>>>>>>>>    Integer iDataFlexType
77308>>>>>>>>>    Boolean bNativeDataType
77308>>>>>>>>>    String  sPrecision
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
77308>>>>>>>>>// Various SQL back-ends can have slightly different
77308>>>>>>>>>// keywords.
77308>>>>>>>>>Struct tSQLKeyWords
77308>>>>>>>>>    Integer iSQLWord
77308>>>>>>>>>    Integer iSQLDbType
77308>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tSQLRelation
77308>>>>>>>>>    Integer iFileNumber
77308>>>>>>>>>    Integer iFieldNumber
77308>>>>>>>>>    String  sFileName
77308>>>>>>>>>    String  sFieldName
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tSQLLoggedInUser
77308>>>>>>>>>    String sUser
77308>>>>>>>>>    String sProgram
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
77308>>>>>>>>>Enumeration_List
77308>>>>>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
77308>>>>>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
77308>>>>>>>>>End_Enumeration_List
77308>>>>>>>>>
77308>>>>>>>>>// We need to re-define the standard constants because several driver constants
77308>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
77308>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
77308>>>>>>>>>// They can have slightly different SQL keywords.
77308>>>>>>>>>// Note: If a new type is added to the list,
77308>>>>>>>>>//       the struct array xxx must be adjusted
77308>>>>>>>>>//       so that it is filled with all SQL
77308>>>>>>>>>//       keywords for that new type.
77308>>>>>>>>>Enum_List
77308>>>>>>>>>//    Define EN_DbTypeMSSQL
77308>>>>>>>>>//    Define EN_DbTypeMySQL
77308>>>>>>>>>//    Define EN_DbTypeOracle
77308>>>>>>>>>//    Define EN_DbTypeDB2
77308>>>>>>>>>//    Define EN_DbTypePostgre
77308>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
77308>>>>>>>>>End_Enum_List
77308>>>>>>>>>
77308>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
77308>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
77308>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
77308>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
77308>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
77308>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
77308>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
77308>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
77308>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
77308>>>>>>>>>
77308>>>>>>>>>// We need to re-define the standard constants because several driver constants
77308>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
77308>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
77308>>>>>>>>>Enum_List
77308>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
77308>>>>>>>>>    Define DF_BCD_DUF       for -1499
77308>>>>>>>>>    Define DF_DATE_DUF      for -1498
77308>>>>>>>>>    Define DF_TEXT_DUF      for -1495
77308>>>>>>>>>    Define DF_BINARY_DUF    for -1494
77308>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
77308>>>>>>>>>End_Enum_List
77308>>>>>>>>>
77308>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
77308>>>>>>>>>
77308>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
77308>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
77308>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
77308>>>>>>>>>
77308>>>>>>>>>// These are not defined pre DF 18:
77308>>>>>>>>>
77308>>>>>>>>>Struct tSQLIntTableInfo
77308>>>>>>>>>    String sDriverName
77308>>>>>>>>>    String sServerName
77308>>>>>>>>>    String sDatabaseName
77308>>>>>>>>>    String sSchemaName
77308>>>>>>>>>    Boolean bRecnumTable
77308>>>>>>>>>    Integer iPrimaryIndex
77308>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
77308>>>>>>>>>    String sTableCharacterFormat
77308>>>>>>>>>    Boolean bUseDummyZeroDate
77308>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
77308>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
77308>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
77308>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
77308>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
77308>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
77308>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
77308>>>>>>>>>    String sFileIndexTablespace
77308>>>>>>>>>    String sFileLongTablespace
77308>>>>>>>>>    String sTableTablespace
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tSQLIntColumnInfo
77308>>>>>>>>>    Integer iFieldNumber
77308>>>>>>>>>    Integer iFieldIndex
77308>>>>>>>>>    Integer iFieldRelatedFile
77308>>>>>>>>>    Integer iFieldRelatedField
77308>>>>>>>>>    Integer iIndexNumber
77308>>>>>>>>>    Integer iIndexNumberSegments
77308>>>>>>>>>    Integer iIndexSegmentField1
77308>>>>>>>>>    Integer iIndexSegmentField2
77308>>>>>>>>>    Integer iIndexSegmentFieldn
77308>>>>>>>>>    String  sIndexName
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPIColumn
77308>>>>>>>>>    Integer iFieldNumber
77308>>>>>>>>>    String  sFieldName
77308>>>>>>>>>    Integer iType
77308>>>>>>>>>    String  sType
77308>>>>>>>>>    Integer iLength
77308>>>>>>>>>    Integer iPrecision
77308>>>>>>>>>    Integer iOptions
77308>>>>>>>>>    Boolean bIsSQLType
77308>>>>>>>>>    Boolean bAllowNULL
77308>>>>>>>>>    String  sDefaultValue
77308>>>>>>>>>    Boolean bShouldChange
77308>>>>>>>>>    Boolean bCancel
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPIColumnCompare
77308>>>>>>>>>    Integer iFieldNumber
77308>>>>>>>>>    // FROM database:
77308>>>>>>>>>    Boolean bExistsFrom
77308>>>>>>>>>    String  sFieldNameFrom
77308>>>>>>>>>    Integer iTypeFrom
77308>>>>>>>>>    String  sTypeFrom
77308>>>>>>>>>    Integer iLengthFrom
77308>>>>>>>>>    Integer iPrecisionFrom
77308>>>>>>>>>    Integer iOptionsFrom
77308>>>>>>>>>    Boolean bIsSQLTypeFrom
77308>>>>>>>>>    Boolean bAllowNULLFrom
77308>>>>>>>>>    String  sDefaultValueFrom
77308>>>>>>>>>    Boolean bShouldChangeFrom
77308>>>>>>>>>    Boolean bCancelFrom
77308>>>>>>>>>    Boolean bErrorFrom
77308>>>>>>>>>    // TO database:
77308>>>>>>>>>    Boolean bExistsTo
77308>>>>>>>>>    Integer iFieldNumberTo
77308>>>>>>>>>    String  sFieldNameTo
77308>>>>>>>>>    Integer iTypeTo
77308>>>>>>>>>    String  sTypeTo
77308>>>>>>>>>    Integer iLengthTo
77308>>>>>>>>>    Integer iPrecisionTo
77308>>>>>>>>>    Integer iOptionsTo
77308>>>>>>>>>    Boolean bIsSQLTypeTo
77308>>>>>>>>>    Boolean bAllowNULLTo
77308>>>>>>>>>    String  sDefaultValueTo
77308>>>>>>>>>    Boolean bShouldChangeTo
77308>>>>>>>>>    Boolean bCancelTo
77308>>>>>>>>>    Boolean bErrorTo
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPIRelation
77308>>>>>>>>>    Handle  hTableFrom
77308>>>>>>>>>    Integer iColumnFrom
77308>>>>>>>>>    Handle  hTableTo
77308>>>>>>>>>    Integer iColumnTo
77308>>>>>>>>>    String  sLogicalNameFrom
77308>>>>>>>>>    String  sLogicalNameTo
77308>>>>>>>>>    String  sFieldNameFrom
77308>>>>>>>>>    String  sFieldNameTo
77308>>>>>>>>>    Boolean bShouldChange
77308>>>>>>>>>    Boolean bCancel
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPIRelationCompare
77308>>>>>>>>>    // Common:
77308>>>>>>>>>    Handle  hTableFrom
77308>>>>>>>>>    Integer iColumnFrom
77308>>>>>>>>>    Handle  hTableTo
77308>>>>>>>>>    Integer iColumnTo
77308>>>>>>>>>    // FROM database:
77308>>>>>>>>>    Boolean bExistsFrom
77308>>>>>>>>>    String  sLogicalNameFrom_From
77308>>>>>>>>>    String  sLogicalNameTo_From
77308>>>>>>>>>    String  sFieldNameFrom_From
77308>>>>>>>>>    String  sFieldNameTo_From
77308>>>>>>>>>    Boolean bShouldChange_From
77308>>>>>>>>>    Boolean bCancel_From
77308>>>>>>>>>    Boolean bError_From
77308>>>>>>>>>    // TO database:
77308>>>>>>>>>    Boolean bExistsTo
77308>>>>>>>>>    String  sLogicalNameFrom_To
77308>>>>>>>>>    String  sLogicalNameTo_To
77308>>>>>>>>>    String  sFieldNameFrom_To
77308>>>>>>>>>    String  sFieldNameTo_To
77308>>>>>>>>>    Boolean bShouldChange_To
77308>>>>>>>>>    Boolean bCancel_To
77308>>>>>>>>>    Boolean bError_To
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPIIndexSegment
77308>>>>>>>>>    Integer iFieldNumber
77308>>>>>>>>>    String  sFieldName
77308>>>>>>>>>    Boolean bUppercase
77308>>>>>>>>>    Boolean bAscending
77308>>>>>>>>>    Boolean bShouldChange
77308>>>>>>>>>    Boolean bCancel
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPIIndex
77308>>>>>>>>>    Integer iIndexNumber
77308>>>>>>>>>    Integer iPrimaryIndex
77308>>>>>>>>>    String  sSQLIndexName
77308>>>>>>>>>    Integer iSQLIndexType
77308>>>>>>>>>    Boolean bIsSQLClustered
77308>>>>>>>>>    Boolean bIsSQLPrimaryKey
77308>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
77308>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
77308>>>>>>>>>    Boolean bShouldChange
77308>>>>>>>>>    Boolean bCancel
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPIIndexCompare
77308>>>>>>>>>    // Common:
77308>>>>>>>>>    Integer iIndexNumber
77308>>>>>>>>>    // FROM database:
77308>>>>>>>>>    Boolean bExistsFrom
77308>>>>>>>>>    Integer iPrimaryIndexFrom
77308>>>>>>>>>    String  sSQLIndexNameFrom
77308>>>>>>>>>    Integer iSQLIndexTypeFrom
77308>>>>>>>>>    Boolean bIsSQLClusteredFrom
77308>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
77308>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
77308>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
77308>>>>>>>>>    Boolean bShouldChangeFrom
77308>>>>>>>>>    Boolean bCancelFrom
77308>>>>>>>>>    Boolean bErrorFrom
77308>>>>>>>>>    // TO database:
77308>>>>>>>>>    Boolean bExistsTo
77308>>>>>>>>>    Integer iPrimaryIndexTo
77308>>>>>>>>>    String  sSQLIndexNameTo
77308>>>>>>>>>    Integer iSQLIndexTypeTo
77308>>>>>>>>>    Boolean bIsSQLClusteredTo
77308>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
77308>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
77308>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
77308>>>>>>>>>    Boolean bShouldChangeTo
77308>>>>>>>>>    Boolean bCancelTo
77308>>>>>>>>>    Boolean bErrorTo
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPITableNameInfo
77308>>>>>>>>>    Integer iTableNumber
77308>>>>>>>>>    String  sRootName
77308>>>>>>>>>    String  sLogicalName
77308>>>>>>>>>    String  sDisplayName
77308>>>>>>>>>    String  sDriverID
77308>>>>>>>>>    Boolean bIsAlias
77308>>>>>>>>>    Boolean bIsSQL
77308>>>>>>>>>    Boolean bIsSystemFile
77308>>>>>>>>>    Boolean bShouldChange
77308>>>>>>>>>    Boolean bCancel
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPITableNameInfoCompare
77308>>>>>>>>>    Integer iTableNumber
77308>>>>>>>>>    // FROM
77308>>>>>>>>>    Boolean bExistsFrom
77308>>>>>>>>>    String  sRootNameFrom
77308>>>>>>>>>    String  sLogicalNameFrom
77308>>>>>>>>>    String  sDisplayNameFrom
77308>>>>>>>>>    String  sDriverIDFrom
77308>>>>>>>>>    Boolean bIsAliasFrom
77308>>>>>>>>>    Boolean bIsSQLFrom
77308>>>>>>>>>    Boolean bIsSystemFileFrom
77308>>>>>>>>>    // TO database:
77308>>>>>>>>>    Boolean bExistsTo
77308>>>>>>>>>    String  sRootNameTo
77308>>>>>>>>>    String  sLogicalNameTo
77308>>>>>>>>>    String  sDisplayNameTo
77308>>>>>>>>>    String  sDriverIDTo
77308>>>>>>>>>    Boolean bIsAliasTo
77308>>>>>>>>>    Boolean bIsSQLTo
77308>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
77308>>>>>>>>>    Boolean bShouldChange
77308>>>>>>>>>    Boolean bCancel
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPITable
77308>>>>>>>>>    Handle hTable
77308>>>>>>>>>    Boolean bFromTable
77308>>>>>>>>>    Boolean bToTable
77308>>>>>>>>>    tAPITableNameInfo ApiTableInfo
77308>>>>>>>>>    tAPITableNameInfo ApiTableInfo
77308>>>>>>>>>    tAPIColumn[]      aApiColumns
77308>>>>>>>>>    tAPIColumn[]      aApiColumns
77308>>>>>>>>>    tAPIIndex[]       aApiIndexes
77308>>>>>>>>>    tAPIIndex[]       aApiIndexes
77308>>>>>>>>>    tAPIRelation[]    aApiRelations
77308>>>>>>>>>    tAPIRelation[]    aApiRelations
77308>>>>>>>>>    Boolean bShouldChange
77308>>>>>>>>>    Boolean bCancel
77308>>>>>>>>>    Boolean bError
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPITableCompare
77308>>>>>>>>>    Handle hTable
77308>>>>>>>>>    // FROM database:
77308>>>>>>>>>    Boolean bExistsFrom
77308>>>>>>>>>    // TO database:
77308>>>>>>>>>    Boolean bExistsTo
77308>>>>>>>>>    // Both:
77308>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
77308>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
77308>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
77308>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
77308>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
77308>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
77308>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
77308>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
77308>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
77308>>>>>>>>>    Boolean bCancel         // User cancel
77308>>>>>>>>>    Boolean bError          // Error occured while collecting data
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Struct tAPITableBooleans
77308>>>>>>>>>    Boolean bApiTableUpdateAuto
77308>>>>>>>>>    Boolean bCompareDate_DateTime
77308>>>>>>>>>    Boolean bCompareIndexAscending
77308>>>>>>>>>    Boolean bCompareIndexUppercase
77308>>>>>>>>>    Boolean bCompareFilelistUppercase
77308>>>>>>>>>End_Struct
77308>>>>>>>>>
77308>>>>>>>>>Define C_tAPIColumn_None for 0
77308>>>>>>>>>Define C_tAPIColumn_Identity for 1
77308>>>>>>>>>
77308>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
77308>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
77308>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
77308>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
77308>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
77308>>>>>>>>>Enum_List
77308>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
77308>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
77308>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
77308>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
77308>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
77308>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
77308>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
77308>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
77308>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
77308>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
77308>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
77308>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
77308>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
77308>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
77308>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
77308>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
77308>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
77308>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
77308>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
77308>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
77308>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
77308>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
77308>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
77308>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
77308>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
77308>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
77308>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
77308>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
77308>>>>>>>>>    Define CI_SQLTo                    //for "TO"
77308>>>>>>>>>    Define CI_SQLGO                    //for "GO"
77308>>>>>>>>>    Define CI_SQLUse                   //for "USE"
77308>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
77308>>>>>>>>>
77308>>>>>>>>>    Define CI_SQLName                  //for "NAME"
77308>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
77308>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
77308>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
77308>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
77308>>>>>>>>>    Define CI_SQLID                    //for "ID"
77308>>>>>>>>>    Define CI_SQLAND                   //for "AND"
77308>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
77308>>>>>>>>>    Define CI_SQLSet                   //for "SET"
77308>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
77308>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
77308>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
77308>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
77308>>>>>>>>>End_Enum_List
77308>>>>>>>>>
77308>>>>>>>>>
77308>>>>>>>
77308>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
77309>>>>>>>
77309>>>>>>>    Procedure CreateDbUpdateLibraryProperties
77311>>>>>>>        Handle hoSQLManagerMT
77311>>>>>>>
77311>>>>>>>        Property String private.psUseDatabase ""
77312>>>>>>>
77312>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
77312>>>>>>>        Property Handle  private.phCurrentTable 0
77313>>>>>>>        Property Integer private.piCurrentField 0
77314>>>>>>>
77314>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
77315>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
77316>>>>>>>
77316>>>>>>>        Property Handle phoSQLManagerMT
77317>>>>>>>
77317>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
77318>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
77319>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
77320>>>>>>>        Property Handle phoSQLConnectionHandler 0
77321>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
77322>>>>>>>
77322>>>>>>>        Property Boolean pbHandleQueryErrors True
77323>>>>>>>
77323>>>>>>>        Property tSqlColumnNew[] paQueryColumns
77324>>>>>>>        Property String[] paSQLFetchResults
77325>>>>>>>
77325>>>>>>>        // Error handling
77325>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
77326>>>>>>>        Property Boolean pbSqlError False
77327>>>>>>>        Property tSqlErrorArray paSqlErrorArray
77328>>>>>>>        Property Boolean pbProcessingError False
77329>>>>>>>
77329>>>>>>>        // Statistics on query
77329>>>>>>>        Property TimeSpan ptsTotalQueryTime
77330>>>>>>>        Property TimeSpan ptsQueryExec
77331>>>>>>>        Property TimeSpan ptsFetchResults
77332>>>>>>>        Property Integer piColumns 0
77333>>>>>>>        Property Integer piRows 0
77334>>>>>>>        Property Integer piRowType 0
77335>>>>>>>        Property String[] paQueryMessages
77336>>>>>>>        Property String psSQLStatementString
77337>>>>>>>
77337>>>>>>>        Property Integer[] paTableConvertExceptions
77338>>>>>>>
77338>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
77339>>>>>>>
77339>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
77339>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
77339>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
77339>>>>>>>        Property Integer piChunkMax 500
77340>>>>>>>
77340>>>>>>>        // Fill the paSQLKeywordArray array with values;
77340>>>>>>>        Send SetupSQLKeywordArray
77341>>>>>>>    End_Procedure
77342>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
77342>>>>>>>>
77342>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
77344>>>>>>>>    Integer iStart iEnd
77344>>>>>>>>    String sRetval
77344>>>>>>>>
77344>>>>>>>>    Move (Trim(sConnect)) to sConnect
77345>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
77346>>>>>>>>    If (iStart = 0) Begin
77348>>>>>>>>        Function_Return ""
77349>>>>>>>>    End
77349>>>>>>>>>
77349>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
77350>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
77351>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
77353>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77354>>>>>>>>    End
77354>>>>>>>>>
77354>>>>>>>>    Else Begin
77355>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
77356>>>>>>>>    End
77356>>>>>>>>>
77356>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
77358>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77359>>>>>>>>        Decrement iEnd
77360>>>>>>>>    End
77360>>>>>>>>>
77360>>>>>>>>    If (iEnd <> 0) Begin
77362>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
77363>>>>>>>>    End
77363>>>>>>>>>
77363>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
77364>>>>>>>>
77364>>>>>>>>    Function_Return (Trim(sRetval))
77365>>>>>>>>End_Function
77366>>>>>>>>
77366>>>>>>>>
77366>>>>>>>
77366>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
77366>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
77368>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
77370>>>>>>>            Function_Return (EQ)
77371>>>>>>>        End
77371>>>>>>>>
77371>>>>>>>        Function_Return (GT)
77372>>>>>>>    End_Function
77373>>>>>>>
77373>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
77373>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
77375>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
77378>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
77381>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
77384>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
77387>>>>>>>
77387>>>>>>>        Function_Return (EQ)
77388>>>>>>>    End_Function
77389>>>>>>>
77389>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
77391>>>>>>>        tSQLKeyWords[] SQLKeywordArray
77391>>>>>>>        tSQLKeyWords[] SQLKeywordArray
77392>>>>>>>        Integer iSize
77392>>>>>>>
77392>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
77393>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
77394>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
77395>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
77396>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
77397>>>>>>>
77397>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
77398>>>>>>>    End_Procedure
77399>>>>>>>
77399>>>>>>>    // Creates a struct array with all SQL keywords
77399>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
77399>>>>>>>    // have slightly different wording.
77399>>>>>>>    // If a new EN_dbTypexxx type is added; additions
77399>>>>>>>    // needs to be done for every keyword group below.
77399>>>>>>>    Procedure SetupSQLKeywordArray
77401>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
77401>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
77403>>>>>>>
77403>>>>>>>        // This should only be called once; but in case it is
77403>>>>>>>        // we delete the array first.
77403>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
77404>>>>>>>
77404>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
77404>>>>>>>        //
77404>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
77405>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
77406>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
77407>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
77408>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
77409>>>>>>>
77409>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
77410>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
77411>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
77412>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
77413>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
77414>>>>>>>
77414>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
77415>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
77416>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
77417>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
77418>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
77419>>>>>>>
77419>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
77420>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
77421>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
77422>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
77423>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
77424>>>>>>>
77424>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
77425>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
77426>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
77427>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
77428>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
77429>>>>>>>
77429>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
77430>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
77431>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
77432>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
77433>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
77434>>>>>>>
77434>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
77435>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
77436>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
77437>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
77438>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
77439>>>>>>>
77439>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
77440>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
77441>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
77442>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
77443>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
77444>>>>>>>
77444>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
77445>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
77446>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
77447>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
77448>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
77449>>>>>>>
77449>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
77450>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
77451>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
77452>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
77453>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
77454>>>>>>>
77454>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
77455>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
77456>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
77457>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
77458>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
77459>>>>>>>
77459>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
77460>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
77461>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
77462>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
77463>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
77464>>>>>>>
77464>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
77465>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
77466>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
77467>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
77468>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
77469>>>>>>>
77469>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
77470>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
77471>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
77472>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
77473>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
77474>>>>>>>
77474>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
77475>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
77476>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
77477>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
77478>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
77479>>>>>>>
77479>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
77480>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
77481>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
77482>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
77483>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
77484>>>>>>>
77484>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
77485>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
77486>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
77487>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
77488>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
77489>>>>>>>
77489>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
77490>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
77491>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
77492>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
77493>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
77494>>>>>>>
77494>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
77495>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
77496>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
77497>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
77498>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
77499>>>>>>>
77499>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
77500>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
77501>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
77502>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
77503>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
77504>>>>>>>
77504>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
77505>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
77506>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
77507>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
77508>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
77509>>>>>>>
77509>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
77510>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
77511>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
77512>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
77513>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
77514>>>>>>>
77514>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
77515>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
77516>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
77517>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
77518>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
77519>>>>>>>
77519>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
77520>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
77521>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
77522>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
77523>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
77524>>>>>>>
77524>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
77525>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
77526>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
77527>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
77528>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
77529>>>>>>>
77529>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
77530>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
77531>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
77532>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
77533>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
77534>>>>>>>
77534>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
77535>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
77536>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
77537>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
77538>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
77539>>>>>>>
77539>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
77540>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
77541>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
77542>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
77543>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
77544>>>>>>>
77544>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
77545>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
77546>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
77547>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
77548>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
77549>>>>>>>
77549>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
77550>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
77551>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
77552>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
77553>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
77554>>>>>>>
77554>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
77555>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
77556>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
77557>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
77558>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
77559>>>>>>>
77559>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
77560>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
77561>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
77562>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
77563>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
77564>>>>>>>
77564>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
77565>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
77566>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
77567>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
77568>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
77569>>>>>>>
77569>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
77570>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
77571>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
77572>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
77573>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
77574>>>>>>>
77574>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
77575>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
77576>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
77577>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
77578>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
77579>>>>>>>
77579>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
77580>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
77581>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
77582>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
77583>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
77584>>>>>>>
77584>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
77585>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
77586>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
77587>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
77588>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
77589>>>>>>>
77589>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
77590>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
77591>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
77592>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
77593>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
77594>>>>>>>
77594>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
77595>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
77596>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
77597>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
77598>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
77599>>>>>>>
77599>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
77600>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
77601>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
77602>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
77603>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
77604>>>>>>>
77604>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
77605>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
77606>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
77607>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
77608>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
77609>>>>>>>
77609>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
77610>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
77611>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
77612>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
77613>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
77614>>>>>>>
77614>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
77615>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
77616>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
77617>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
77618>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
77619>>>>>>>
77619>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
77620>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
77621>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
77622>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
77623>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
77624>>>>>>>
77624>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
77624>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
77625>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
77626>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
77627>>>>>>>
77627>>>>>>>    End_Procedure
77628>>>>>>>
77628>>>>>>>End_Class
77629>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
77629>>>>>>>//****************************************************************************
77629>>>>>>>// $Module type: Class
77629>>>>>>>// $Module name: cSQLConnectionHandler.pkg
77629>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
77629>>>>>>>// Web-site    : http://www.rdctools.com
77629>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
77629>>>>>>>//
77629>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
77629>>>>>>>//
77629>>>>>>>// $Rev History:
77629>>>>>>>//    2015-08-11  Module header created
77629>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
77629>>>>>>>//                Added a new structure for passing connection data back & forth.
77629>>>>>>>//                Added better error handling.
77629>>>>>>>//                Added a decompose message for the connection string.
77629>>>>>>>//    2017-01-09  Added support for Mertech drivers
77629>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
77629>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
77629>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
77629>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
77629>>>>>>>//    2023-11-06 *** REMOVED ALL SUPPORT FOR MERTECH DRIVERS ***
77629>>>>>>>//****************************************************************************
77629>>>>>>>Use cli.pkg
77629>>>>>>>Use MSSqldrv.pkg
77629>>>>>>>Use db2_drv.pkg
77629>>>>>>>Use odbc_drv.pkg
77629>>>>>>>Use cSQLConnectionIniFile.pkg
77629>>>>>>>Use cDbUpdateDatabaseDriver.pkg
77629>>>>>>>Use vWin32fh.pkg
77629>>>>>>>
77629>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
77629>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
77629>>>>>>>
77629>>>>>>>// We're making references to this object handle so we need it defined
77629>>>>>>>// here as well as for the cDbUpdateHandler class
77629>>>>>>>
77629>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
77629>>>>>>>    Move 0 to ghoSQLConnectionHandler
77630>>>>>>>
77630>>>>>>>Class cSQLConnectionHandler is a cObject
77631>>>>>>>
77631>>>>>>>    Procedure Construct_Object
77633>>>>>>>        Forward Send Construct_Object
77635>>>>>>>        Move Self to ghoSQLConnectionHandler
77636>>>>>>>
77636>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
77637>>>>>>>
77637>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
77637>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
77637>>>>>>>        // methods to this class.
77637>>>>>>>        Property Boolean pbUseConnectionID True
77638>>>>>>>        Property Boolean pbToANSI          True
77639>>>>>>>        Property Boolean pbRecnum          True
77640>>>>>>>        Property Boolean pbCopyData        True
77641>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
77642>>>>>>>        Property Boolean pbCompareDate_DateTime  False
77643>>>>>>>        Property Boolean pbCompareIndexAscending False
77644>>>>>>>        Property Boolean pbCompareIndexUppercase False
77645>>>>>>>
77645>>>>>>>        // Driver default value settings:
77645>>>>>>>        // Note: When the object is created the corresponding values
77645>>>>>>>        // from the driver .int files are read.
77645>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
77645>>>>>>>        Property String psDriverDefaultValueASCII    ""
77646>>>>>>>        Property String psDriverDefaultValueBinary   ""
77647>>>>>>>        Property String psDriverDefaultValueDate     ""
77648>>>>>>>        Property String psDriverDefaultValueDateTime ""
77649>>>>>>>        Property String psDriverDefaultValueNumeric  ""
77650>>>>>>>        Property String psDriverDefaultValueText     ""
77651>>>>>>>
77651>>>>>>>        // Driver "nullability" settings:
77651>>>>>>>        // Note: When the object is created the corresponding values
77651>>>>>>>        // from the driver .int files are read.
77651>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
77651>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
77652>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
77653>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
77654>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
77655>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
77656>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
77657>>>>>>>
77657>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
77657>>>>>>>        //     It is private because the get/set version also updates the DAW
77657>>>>>>>        //     driver interfaces.
77657>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
77657>>>>>>>        //     of the struct they are all routed throu this struct property.
77657>>>>>>>        Property tSQLConnection Private.pSQLConnection
77658>>>>>>>
77658>>>>>>>    End_Procedure
77659>>>>>>>
77659>>>>>>>    Procedure End_Construct_Object
77661>>>>>>>        tSQLConnection SQLConnection
77661>>>>>>>        tSQLConnection SQLConnection
77661>>>>>>>
77661>>>>>>>        Forward Send End_Construct_Object
77663>>>>>>>
77663>>>>>>>        // Now is the time to read and apply SQL connection settings.
77663>>>>>>>        Get SetupSQLConnection True True to SQLConnection
77664>>>>>>>        Set Private.pSQLConnection to SQLConnection
77665>>>>>>>    End_Procedure
77666>>>>>>>
77666>>>>>>>    // *** Properties ***
77666>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
77666>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
77666>>>>>>>    // merely here for conveniance.
77666>>>>>>>    //
77666>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
77666>>>>>>>    // where we update data to/from the DAW driver interfaces and this framework.
77666>>>>>>>    // This struct property contains all the connection data.
77666>>>>>>>    //
77666>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
77668>>>>>>>        Boolean bOK
77668>>>>>>>
77668>>>>>>>        Set Private.pSQLConnection to SQLConnection
77669>>>>>>>
77669>>>>>>>        // When starting a program we might not have a connection id yet:
77669>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
77671>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
77671>>>>>>>            Procedure_Return
77672>>>>>>>        End
77672>>>>>>>>
77672>>>>>>>
77672>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
77672>>>>>>>        // be logged in already and don't want to do it again.
77672>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
77674>>>>>>>            // After we have set the class property we need to tell the DAW
77674>>>>>>>            // driver interfaces about the change & make a new login.
77674>>>>>>>            Get SQLLogin SQLConnection to bOK
77675>>>>>>>            If (bOK = False) Begin
77677>>>>>>>                Error DFERR_PROGRAM "Login error."
77678>>>>>>>>
77678>>>>>>>            End
77678>>>>>>>>
77678>>>>>>>        End
77678>>>>>>>>
77678>>>>>>>
77678>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
77678>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
77679>>>>>>>
77679>>>>>>>    End_Procedure
77680>>>>>>>
77680>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
77680>>>>>>>    // attempt to load the driver.
77680>>>>>>>    // Returns true if the passed driver is SQL based.
77680>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
77682>>>>>>>        Boolean bOK
77682>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
77683>>>>>>>        Function_Return bOK
77684>>>>>>>    End_Function
77685>>>>>>>
77685>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
77685>>>>>>>    Procedure SetupDriverDefaults String sDriverID
77687>>>>>>>        String sAttributeValue
77687>>>>>>>        Integer iDriverID
77687>>>>>>>        Boolean bNULL bSQLDriver
77687>>>>>>>
77687>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
77688>>>>>>>        If (bSQLDriver = False) Begin
77690>>>>>>>            Procedure_Return
77691>>>>>>>        End                                      
77691>>>>>>>>
77691>>>>>>>        
77691>>>>>>>        Get DriverIndex sDriverID to iDriverID
77692>>>>>>>
77692>>>>>>>        // Driver default values for various data types:
77692>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
77695>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
77696>>>>>>>
77696>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
77699>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
77700>>>>>>>
77700>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
77703>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
77704>>>>>>>
77704>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
77707>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
77708>>>>>>>
77708>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
77711>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
77712>>>>>>>
77712>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
77715>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
77716>>>>>>>
77716>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
77716>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
77719>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
77720>>>>>>>
77720>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
77723>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
77724>>>>>>>
77724>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
77727>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
77728>>>>>>>
77728>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
77731>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
77732>>>>>>>
77732>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
77735>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
77736>>>>>>>
77736>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
77739>>>>>>>        Set pbDriverDefaultNullableText to bNULL
77740>>>>>>>
77740>>>>>>>    End_Procedure
77741>>>>>>>
77741>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
77743>>>>>>>        Boolean bOK bIsDaw
77743>>>>>>>        String sConnectionString
77743>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
77743>>>>>>>        Integer iDriverID
77743>>>>>>>
77743>>>>>>>        Move False to bOK
77744>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
77745>>>>>>>
77745>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
77746>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
77747>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
77748>>>>>>>        If (iDriverID = 0) Begin
77750>>>>>>>            Move hoErrorObj to Error_Object_Id
77751>>>>>>>            Function_Return False
77752>>>>>>>        End
77752>>>>>>>>
77752>>>>>>>
77752>>>>>>>        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
77755>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
77756>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
77757>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
77758>>>>>>>        Send Destroy   of hoDriver
77759>>>>>>>
77759>>>>>>>        Function_Return bOK
77760>>>>>>>    End_Function
77761>>>>>>>
77761>>>>>>>    Function pSQLConnection Returns tSQLConnection
77763>>>>>>>        tSQLConnection SQLConnection
77763>>>>>>>        tSQLConnection SQLConnection
77763>>>>>>>        Get Private.pSQLConnection to SQLConnection
77764>>>>>>>        Function_Return SQLConnection
77765>>>>>>>    End_Function
77766>>>>>>>
77766>>>>>>>    Procedure Set psConnectionID String sValue
77768>>>>>>>        tSQLConnection SQLConnection
77768>>>>>>>        tSQLConnection SQLConnection
77768>>>>>>>
77768>>>>>>>        Get Private.pSQLConnection to SQLConnection
77769>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
77771>>>>>>>            Move sValue to SQLConnection.sConnectionID
77772>>>>>>>        End
77772>>>>>>>>
77772>>>>>>>
77772>>>>>>>        // Else we might want to change the current connection ID
77772>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
77775>>>>>>>            Move False to Err
77776>>>>>>>            Logout SQLConnection.sDriverID
77777>>>>>>>            // This will also make a login to the new server.
77777>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
77778>>>>>>>        End
77778>>>>>>>>
77778>>>>>>>        Set pSQLConnection to SQLConnection
77779>>>>>>>    End_Procedure
77780>>>>>>>
77780>>>>>>>    Function psConnectionID Returns String
77782>>>>>>>        tSQLConnection SQLConnection
77782>>>>>>>        tSQLConnection SQLConnection
77782>>>>>>>        Get Private.pSQLConnection to SQLConnection
77783>>>>>>>        Function_Return SQLConnection.sConnectionID
77784>>>>>>>    End_Function
77785>>>>>>>
77785>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
77785>>>>>>>    //       the psDriverID *must* be the first property that is changed!
77785>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
77785>>>>>>>    //       for a connection string has the wrong format for that driver.
77785>>>>>>>    Procedure Set psDriverID String sValue
77787>>>>>>>        tSQLConnection SQLConnection
77787>>>>>>>        tSQLConnection SQLConnection
77787>>>>>>>        Get pSQLConnection to SQLConnection
77788>>>>>>>        Move sValue        to SQLConnection.sDriverID
77789>>>>>>>        Set pSQLConnection to SQLConnection
77790>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
77792>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77793>>>>>>>        End
77793>>>>>>>>
77793>>>>>>>    End_Procedure
77794>>>>>>>
77794>>>>>>>    Function psDriverID Returns String
77796>>>>>>>        tSQLConnection SQLConnection
77796>>>>>>>        tSQLConnection SQLConnection
77796>>>>>>>        Get Private.pSQLConnection to SQLConnection
77797>>>>>>>        If (SQLConnection.sDriverID = "") Begin
77799>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
77800>>>>>>>        End
77800>>>>>>>>
77800>>>>>>>        Function_Return SQLConnection.sDriverID
77801>>>>>>>    End_Function
77802>>>>>>>
77802>>>>>>>    Procedure Set psConnectionString String sValue
77804>>>>>>>        tSQLConnection SQLConnection
77804>>>>>>>        tSQLConnection SQLConnection
77804>>>>>>>        Get Private.pSQLConnection to SQLConnection
77805>>>>>>>        Move sValue        to SQLConnection.sConnectionString
77806>>>>>>>        Set pSQLConnection to SQLConnection
77807>>>>>>>    End_Procedure
77808>>>>>>>
77808>>>>>>>    Function psConnectionString Returns String
77810>>>>>>>        tSQLConnection SQLConnection
77810>>>>>>>        tSQLConnection SQLConnection
77810>>>>>>>        Get Private.pSQLConnection to SQLConnection
77811>>>>>>>        Function_Return SQLConnection.sConnectionString
77812>>>>>>>    End_Function
77813>>>>>>>
77813>>>>>>>    Procedure Set psServer String sValue
77815>>>>>>>        tSQLConnection SQLConnection
77815>>>>>>>        tSQLConnection SQLConnection
77815>>>>>>>        Get Private.pSQLConnection to SQLConnection
77816>>>>>>>        Move sValue        to SQLConnection.sServer
77817>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77818>>>>>>>        Set pSQLConnection to SQLConnection
77819>>>>>>>    End_Procedure
77820>>>>>>>
77820>>>>>>>    Function psServer Returns String
77822>>>>>>>        tSQLConnection SQLConnection
77822>>>>>>>        tSQLConnection SQLConnection
77822>>>>>>>        Get Private.pSQLConnection to SQLConnection
77823>>>>>>>        Function_Return SQLConnection.sServer
77824>>>>>>>    End_Function
77825>>>>>>>
77825>>>>>>>    Procedure Set psDatabase String sValue
77827>>>>>>>        tSQLConnection SQLConnection
77827>>>>>>>        tSQLConnection SQLConnection
77827>>>>>>>        Get Private.pSQLConnection to SQLConnection
77828>>>>>>>        Move sValue        to SQLConnection.sDatabase
77829>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77830>>>>>>>        Set pSQLConnection to SQLConnection
77831>>>>>>>    End_Procedure
77832>>>>>>>
77832>>>>>>>    Function psDatabase Returns String
77834>>>>>>>        tSQLConnection SQLConnection
77834>>>>>>>        tSQLConnection SQLConnection
77834>>>>>>>        Get Private.pSQLConnection to SQLConnection
77835>>>>>>>        Function_Return SQLConnection.sDatabase
77836>>>>>>>    End_Function
77837>>>>>>>
77837>>>>>>>    Procedure Set psUserID String sValue
77839>>>>>>>        tSQLConnection SQLConnection
77839>>>>>>>        tSQLConnection SQLConnection
77839>>>>>>>        Get Private.pSQLConnection to SQLConnection
77840>>>>>>>        Move sValue        to SQLConnection.sUserID
77841>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77842>>>>>>>        Set pSQLConnection to SQLConnection
77843>>>>>>>    End_Procedure
77844>>>>>>>
77844>>>>>>>    Function psUserID Returns String
77846>>>>>>>        tSQLConnection SQLConnection
77846>>>>>>>        tSQLConnection SQLConnection
77846>>>>>>>        Get Private.pSQLConnection to SQLConnection
77847>>>>>>>        Function_Return SQLConnection.sUserID
77848>>>>>>>    End_Function
77849>>>>>>>
77849>>>>>>>    // This is the uncrypted password
77849>>>>>>>    Procedure Set psPassword String sValue
77851>>>>>>>        tSQLConnection SQLConnection
77851>>>>>>>        tSQLConnection SQLConnection
77851>>>>>>>        Get Private.pSQLConnection to SQLConnection
77852>>>>>>>        Move sValue        to SQLConnection.sPassword
77853>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77854>>>>>>>        Set pSQLConnection to SQLConnection
77855>>>>>>>    End_Procedure
77856>>>>>>>
77856>>>>>>>    Function psPassword Returns String
77858>>>>>>>        tSQLConnection SQLConnection
77858>>>>>>>        tSQLConnection SQLConnection
77858>>>>>>>        Get Private.pSQLConnection to SQLConnection
77859>>>>>>>        Function_Return SQLConnection.sPassword
77860>>>>>>>    End_Function
77861>>>>>>>
77861>>>>>>>    Procedure Set pbTrusted Boolean bValue
77863>>>>>>>        tSQLConnection SQLConnection
77863>>>>>>>        tSQLConnection SQLConnection
77863>>>>>>>        Get Private.pSQLConnection to SQLConnection
77864>>>>>>>        Move bValue        to SQLConnection.bTrusted
77865>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77866>>>>>>>        Set pSQLConnection to SQLConnection
77867>>>>>>>    End_Procedure
77868>>>>>>>
77868>>>>>>>    Function pbTrusted Returns Boolean
77870>>>>>>>        tSQLConnection SQLConnection
77870>>>>>>>        tSQLConnection SQLConnection
77870>>>>>>>        Get Private.pSQLConnection to SQLConnection
77871>>>>>>>        Function_Return SQLConnection.bTrusted
77872>>>>>>>    End_Function
77873>>>>>>>
77873>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
77873>>>>>>>    //     Thus they are not propagated to the DAW classes and that is why
77873>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
77873>>>>>>>    //     the central pSQLConnection "hub".
77873>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
77875>>>>>>>        tSQLConnection SQLConnection
77875>>>>>>>        tSQLConnection SQLConnection
77875>>>>>>>        Get Private.pSQLConnection to SQLConnection
77876>>>>>>>        Move bValue to SQLConnection.bTrusted
77877>>>>>>>        Set Private.pSQLConnection to SQLConnection
77878>>>>>>>    End_Procedure
77879>>>>>>>
77879>>>>>>>    Function pbSilentLogin Returns Boolean
77881>>>>>>>        tSQLConnection SQLConnection
77881>>>>>>>        tSQLConnection SQLConnection
77881>>>>>>>        Get Private.pSQLConnection to SQLConnection
77882>>>>>>>        Function_Return SQLConnection.bSilentLogin
77883>>>>>>>    End_Function
77884>>>>>>>
77884>>>>>>>    Procedure Set piDbType Integer iValue
77886>>>>>>>        tSQLConnection SQLConnection
77886>>>>>>>        tSQLConnection SQLConnection
77886>>>>>>>        Get Private.pSQLConnection to SQLConnection
77887>>>>>>>        Move iValue to SQLConnection.iDbType
77888>>>>>>>        Set Private.pSQLConnection to SQLConnection
77889>>>>>>>    End_Procedure
77890>>>>>>>
77890>>>>>>>    Function piDbType Returns Integer
77892>>>>>>>        tSQLConnection SQLConnection
77892>>>>>>>        tSQLConnection SQLConnection
77892>>>>>>>        Get Private.pSQLConnection to SQLConnection
77893>>>>>>>        Function_Return SQLConnection.iDbType
77894>>>>>>>    End_Function
77895>>>>>>>
77895>>>>>>>    Procedure Set psBaseTableSpace String sValue
77897>>>>>>>        tSQLConnection SQLConnection
77897>>>>>>>        tSQLConnection SQLConnection
77897>>>>>>>        Get Private.pSQLConnection to SQLConnection
77898>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
77899>>>>>>>        Set Private.pSQLConnection to SQLConnection
77900>>>>>>>    End_Procedure
77901>>>>>>>
77901>>>>>>>    Function psBaseTableSpace Returns String
77903>>>>>>>        tSQLConnection SQLConnection
77903>>>>>>>        tSQLConnection SQLConnection
77903>>>>>>>        Get Private.pSQLConnection to SQLConnection
77904>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
77905>>>>>>>    End_Function
77906>>>>>>>
77906>>>>>>>    Procedure Set psIndexTableSpace String sValue
77908>>>>>>>        tSQLConnection SQLConnection
77908>>>>>>>        tSQLConnection SQLConnection
77908>>>>>>>        Get Private.pSQLConnection to SQLConnection
77909>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
77910>>>>>>>        Set Private.pSQLConnection to SQLConnection
77911>>>>>>>    End_Procedure
77912>>>>>>>
77912>>>>>>>    Function psIndexTableSpace Returns String
77914>>>>>>>        tSQLConnection SQLConnection
77914>>>>>>>        tSQLConnection SQLConnection
77914>>>>>>>        Get Private.pSQLConnection to SQLConnection
77915>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
77916>>>>>>>    End_Function
77917>>>>>>>
77917>>>>>>>    Procedure Set psLongTableSpace String sValue
77919>>>>>>>        tSQLConnection SQLConnection
77919>>>>>>>        tSQLConnection SQLConnection
77919>>>>>>>        Get Private.pSQLConnection to SQLConnection
77920>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
77921>>>>>>>        Set Private.pSQLConnection to SQLConnection
77922>>>>>>>    End_Procedure
77923>>>>>>>
77923>>>>>>>    Function psLongTableSpace Returns String
77925>>>>>>>        tSQLConnection SQLConnection
77925>>>>>>>        tSQLConnection SQLConnection
77925>>>>>>>        Get Private.pSQLConnection to SQLConnection
77926>>>>>>>        Function_Return SQLConnection.sLongTableSpace
77927>>>>>>>    End_Function
77928>>>>>>>
77928>>>>>>>    Procedure Set psSchema String sValue
77930>>>>>>>        tSQLConnection SQLConnection
77930>>>>>>>        tSQLConnection SQLConnection
77930>>>>>>>        Get Private.pSQLConnection to SQLConnection
77931>>>>>>>        Move sValue to SQLConnection.sSchema
77932>>>>>>>        Set Private.pSQLConnection to SQLConnection
77933>>>>>>>    End_Procedure
77934>>>>>>>
77934>>>>>>>    Function psSchema Returns String
77936>>>>>>>        tSQLConnection SQLConnection
77936>>>>>>>        tSQLConnection SQLConnection
77936>>>>>>>        Get Private.pSQLConnection to SQLConnection
77937>>>>>>>        Function_Return SQLConnection.sSchema
77938>>>>>>>    End_Function
77939>>>>>>>
77939>>>>>>>    Procedure Set pbEnabled Boolean bValue
77941>>>>>>>        tSQLConnection SQLConnection
77941>>>>>>>        tSQLConnection SQLConnection
77941>>>>>>>        Get Private.pSQLConnection to SQLConnection
77942>>>>>>>        Move bValue to SQLConnection.bEnabled
77943>>>>>>>        Set Private.pSQLConnection to SQLConnection
77944>>>>>>>    End_Procedure
77945>>>>>>>
77945>>>>>>>    Function pbEnabled Returns Boolean
77947>>>>>>>        tSQLConnection SQLConnection
77947>>>>>>>        tSQLConnection SQLConnection
77947>>>>>>>        Get Private.pSQLConnection to SQLConnection
77948>>>>>>>        Function_Return SQLConnection.bEnabled
77949>>>>>>>    End_Function
77950>>>>>>>
77950>>>>>>>
77950>>>>>>>    // ************************************
77950>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
77952>>>>>>>        tSQLConnection SQLConnection
77952>>>>>>>        tSQLConnection SQLConnection
77952>>>>>>>
77952>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
77952>>>>>>>        // deferr reading SQL connection values until later.
77952>>>>>>>        If (bReadDFConnSettings = True) Begin
77954>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
77954>>>>>>>            If (ghoConnection > 0) Begin
77956>>>>>>>                Get ReadcConnections to SQLConnection
77957>>>>>>>            End
77957>>>>>>>>
77957>>>>>>>
77957>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
77957>>>>>>>            // object is used.
77957>>>>>>>            If (bReadSQLConnections = True) Begin
77959>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
77960>>>>>>>            End
77960>>>>>>>>
77960>>>>>>>        End
77960>>>>>>>>
77960>>>>>>>
77960>>>>>>>        Function_Return SQLConnection
77961>>>>>>>    End_Function
77962>>>>>>>
77962>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
77962>>>>>>>    Function ReadcConnections Returns tSQLConnection
77964>>>>>>>        tConnection Connection
77964>>>>>>>        tConnection Connection
77964>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
77964>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
77964>>>>>>>        Integer iRetval iDbType
77964>>>>>>>        Boolean bOK bConnected
77964>>>>>>>        String sConnectionID
77964>>>>>>>
77964>>>>>>>            tConnection[] Connections
77964>>>>>>>            tConnection[] Connections
77965>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
77965>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
77965>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
77965>>>>>>>            //   we then generate an error and abort the program...
77965>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
77966>>>>>>>            If (bOK = False) Begin
77968>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
77969>>>>>>>>
77969>>>>>>>                Abort
77970>>>>>>>>
77970>>>>>>>            End
77970>>>>>>>>
77970>>>>>>>            If (sConnectionID = "") Begin
77972>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
77973>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
77975>>>>>>>                    Move Connections[0].sId to sConnectionID
77976>>>>>>>                End
77976>>>>>>>>
77976>>>>>>>            End
77976>>>>>>>>
77976>>>>>>>
77976>>>>>>>            Move 0 to iRetval
77977>>>>>>>            // DAW DF19 connection info:
77977>>>>>>>            // We first check that the connection is OK:
77977>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
77978>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
77978>>>>>>>            If (iRetval = -1) Begin
77980>>>>>>>                Function_Return SQLConnectionEmpty
77981>>>>>>>            End
77981>>>>>>>>
77981>>>>>>>
77981>>>>>>>            If (sConnectionID <> "") Begin
77983>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
77984>>>>>>>            End
77984>>>>>>>>
77984>>>>>>>            If (Connection.sId = "") Begin
77986>>>>>>>                Move True to SQLConnectionEmpty.bError
77987>>>>>>>                Function_Return SQLConnectionEmpty
77988>>>>>>>            End
77988>>>>>>>>
77988>>>>>>>
77988>>>>>>>            // DUF connection info struct property:
77988>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
77989>>>>>>>
77989>>>>>>>            Move Connection.sId to sConnectionID
77990>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
77991>>>>>>>
77991>>>>>>>            If (bConnected = False) Begin
77993>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
77994>>>>>>>                If (iRetval <> 0) Begin
77996>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
77997>>>>>>>                    Send Exit_Application
77998>>>>>>>                End
77998>>>>>>>>
77998>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
77999>>>>>>>                // We need to get the DAW connection info again as it might have
77999>>>>>>>                // been changed in the DAW db login dialog.
77999>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78000>>>>>>>            End
78000>>>>>>>>
78000>>>>>>>
78000>>>>>>>            Move True                                        to SQLConnection.bEnabled
78001>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
78002>>>>>>>
78002>>>>>>>            // Not used in DUF:
78002>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
78002>>>>>>>
78002>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
78003>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
78004>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
78005>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
78006>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
78007>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
78008>>>>>>>
78008>>>>>>>            // Not used in DUF:
78008>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
78008>>>>>>>
78008>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
78008>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
78008>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
78010>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
78011>>>>>>>            End
78011>>>>>>>>
78011>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
78013>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
78014>>>>>>>                If (SQLConnection.sServer = "") Begin
78016>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78017>>>>>>>                End
78017>>>>>>>>
78017>>>>>>>            End
78017>>>>>>>>
78017>>>>>>>
78017>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
78018>>>>>>>
78018>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
78018>>>>>>>            // the value from the driver id:
78018>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
78019>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
78019>>>>>>>            Get piDbType                                     to iDbType
78020>>>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
78022>>>>>>>                Move iDbType to SQLConnection.iDbType
78023>>>>>>>            End
78023>>>>>>>>
78023>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
78024>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
78025>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
78026>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
78027>>>>>>>
78027>>>>>>>            // We finally set the struct property to the newly fetched values.
78027>>>>>>>            Set pSQLConnection to SQLConnection
78028>>>>>>>
78028>>>>>>>        Function_Return SQLConnection
78029>>>>>>>    End_Function
78030>>>>>>>
78030>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
78030>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
78030>>>>>>>    // connection id for a particular driver.
78030>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
78030>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
78030>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
78030>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
78030>>>>>>>    // connections of the DAW cConnect class.
78030>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
78032>>>>>>>        tConnection[] ConnIdArray
78032>>>>>>>        tConnection[] ConnIdArray
78033>>>>>>>        Integer iCount iSize iConnectionIDCounter
78033>>>>>>>        Boolean bEnabled bFound
78033>>>>>>>        String sConnectionID2 sDriverID sDriverConn
78033>>>>>>>
78033>>>>>>>        Move False to bFound
78034>>>>>>>        If (ghoConnection > 0) Begin
78036>>>>>>>
78036>>>>>>>            // The property of the cDbUpdateHandler container object
78036>>>>>>>            Get psDriverID to sDriverID
78037>>>>>>>
78037>>>>>>>            Move 0 to iConnectionIDCounter
78038>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
78038>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
78039>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
78040>>>>>>>            Decrement iSize
78041>>>>>>>            For iCount from 0 to iSize
78047>>>>>>>>
78047>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
78048>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
78049>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
78050>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
78050>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
78050>>>>>>>                If (sConnectionID = "") Begin
78052>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
78053>>>>>>>                End
78053>>>>>>>>
78053>>>>>>>                Else Begin
78054>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
78056>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
78057>>>>>>>                    End
78057>>>>>>>>
78057>>>>>>>                End
78057>>>>>>>>
78057>>>>>>>
78057>>>>>>>                If (bFound = True) Begin
78059>>>>>>>                    Increment iConnectionIDCounter
78060>>>>>>>                End
78060>>>>>>>>
78060>>>>>>>            Loop
78061>>>>>>>>
78061>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
78062>>>>>>>            If (bFound = True) Begin
78064>>>>>>>                Move sConnectionID2 to sConnectionID
78065>>>>>>>            End
78065>>>>>>>>
78065>>>>>>>        End
78065>>>>>>>>
78065>>>>>>>
78065>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
78065>>>>>>>        // but no DFConn.ini record has been created.
78065>>>>>>>        If (iSize = -1) Begin
78067>>>>>>>            Move True to bFound
78068>>>>>>>        End
78068>>>>>>>>
78068>>>>>>>
78068>>>>>>>        Function_Return bFound
78069>>>>>>>    End_Function
78070>>>>>>>
78070>>>>>>>    // Send on object creation to read the default connection string settings, and
78070>>>>>>>    // create a connection to the server.
78070>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
78072>>>>>>>        String sPath sFileName
78072>>>>>>>        Boolean bExists bActive
78072>>>>>>>        tSQLConnection[] SQLConnectionArray
78072>>>>>>>        tSQLConnection[] SQLConnectionArray
78073>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78073>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78073>>>>>>>        Handle hoIniFile
78073>>>>>>>        Integer iSize iCount iRetval
78073>>>>>>>
78073>>>>>>>        Get psIniFilePath to sPath
78074>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78075>>>>>>>        If (sPath = "") Begin
78077>>>>>>>            Get ApplicationPath of hoIniFile to sPath
78078>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
78079>>>>>>>        End
78079>>>>>>>>
78079>>>>>>>        Get vFolderFormat sPath to sPath
78080>>>>>>>        Get psIniFileName to sFileName
78081>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
78082>>>>>>>
78082>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
78083>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
78084>>>>>>>        If (iSize = 0) Begin
78086>>>>>>>            // This may have been set by the "ReadcConnections" function,
78086>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
78086>>>>>>>            // in the cApplication object.
78086>>>>>>>            Get pSQLConnection to SQLConnection
78087>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
78089>>>>>>>                Function_Return SQLConnectionEmpty
78090>>>>>>>            End
78090>>>>>>>>
78090>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
78091>>>>>>>            Move 1 to iSize
78092>>>>>>>        End
78092>>>>>>>>
78092>>>>>>>
78092>>>>>>>        Move False to bActive
78093>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
78093>>>>>>>        Decrement iSize
78094>>>>>>>        For iCount from 0 to iSize
78100>>>>>>>>
78100>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
78101>>>>>>>            If (SQLConnection.bEnabled = True) Begin
78103>>>>>>>                Move True to bActive
78104>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
78105>>>>>>>            End
78105>>>>>>>>
78105>>>>>>>        Loop
78106>>>>>>>>
78106>>>>>>>
78106>>>>>>>        // In case all connections have been disabled, we're out of here.
78106>>>>>>>        If (bActive = False) Begin
78108>>>>>>>            Function_Return SQLConnectionEmpty
78109>>>>>>>        End
78109>>>>>>>>
78109>>>>>>>
78109>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
78110>>>>>>>
78110>>>>>>>        Set pSQLConnection to SQLConnection
78111>>>>>>>        Get AutoSetConnectionID to iRetval
78112>>>>>>>
78112>>>>>>>        Function_Return SQLConnection
78113>>>>>>>    End_Function
78114>>>>>>>
78114>>>>>>>    Procedure Set psIniFilePath String sPath
78116>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
78117>>>>>>>    End_Procedure
78118>>>>>>>
78118>>>>>>>    Function psIniFilePath Returns String
78120>>>>>>>        String sRetval
78120>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
78121>>>>>>>        Function_Return sRetval
78122>>>>>>>    End_Function
78123>>>>>>>
78123>>>>>>>    Procedure Set psIniFileName String sFileName
78125>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
78126>>>>>>>    End_Procedure
78127>>>>>>>
78127>>>>>>>    Function psIniFileName Returns String
78129>>>>>>>        String sRetval
78129>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
78130>>>>>>>        Function_Return sRetval
78131>>>>>>>    End_Function
78132>>>>>>>
78132>>>>>>>    Procedure Set psIniSectionName String sSection
78134>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
78135>>>>>>>    End_Procedure
78136>>>>>>>
78136>>>>>>>    Function psIniSectionName Returns String
78138>>>>>>>        String sRetval
78138>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
78139>>>>>>>        Function_Return sRetval
78140>>>>>>>    End_Function
78141>>>>>>>
78141>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
78143>>>>>>>        Handle ho
78143>>>>>>>        Get phoSQLConnectionIniFile to ho
78144>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
78145>>>>>>>    End_Procedure
78146>>>>>>>
78146>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
78148>>>>>>>        Handle ho
78148>>>>>>>        String sRetval
78148>>>>>>>        Get phoSQLConnectionIniFile to ho
78149>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
78150>>>>>>>        Function_Return sRetval
78151>>>>>>>    End_Function
78152>>>>>>>
78152>>>>>>>    Function SectionExists String sSection Returns Boolean
78154>>>>>>>        Handle ho
78154>>>>>>>        Boolean bRetval
78154>>>>>>>        Get phoSQLConnectionIniFile to ho
78155>>>>>>>        Get SectionExists of ho sSection to bRetval
78156>>>>>>>        Function_Return bRetval
78157>>>>>>>    End_Function
78158>>>>>>>
78158>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
78160>>>>>>>        Handle ho
78160>>>>>>>        Boolean bRetval
78160>>>>>>>        Get phoSQLConnectionIniFile to ho
78161>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
78162>>>>>>>        Function_Return bRetval
78163>>>>>>>    End_Function
78164>>>>>>>
78164>>>>>>>    Function EncryptPassword String sPassword Returns String
78166>>>>>>>        Handle ho
78166>>>>>>>        String sRetval
78166>>>>>>>        Get phoSQLConnectionIniFile to ho
78167>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
78168>>>>>>>        Function_Return sRetval
78169>>>>>>>    End_Function
78170>>>>>>>
78170>>>>>>>    Function DecryptPassword String sPassword Returns String
78172>>>>>>>        Handle ho
78172>>>>>>>        String sRetval
78172>>>>>>>        Get phoSQLConnectionIniFile to ho
78173>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
78174>>>>>>>        Function_Return sRetval
78175>>>>>>>    End_Function
78176>>>>>>>
78176>>>>>>>    // *** Main Connection Message ***
78176>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
78178>>>>>>>        Handle hoDriver
78178>>>>>>>        String sConnectionString sError
78178>>>>>>>        Boolean bLoginSuccessful
78178>>>>>>>
78178>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
78179>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78180>>>>>>>        Set psDriverID of hoDriver to sDriverID
78181>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
78182>>>>>>>        If (bLoginSuccessful = False) Begin
78184>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
78185>>>>>>>>
78185>>>>>>>            If (bExitProgram = True) Begin
78187>>>>>>>                Send Exit_Application
78188>>>>>>>            End
78188>>>>>>>>
78188>>>>>>>        End
78188>>>>>>>>
78188>>>>>>>        Send Destroy of hoDriver
78189>>>>>>>    End_Procedure
78190>>>>>>>
78190>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
78192>>>>>>>        Integer iRetval
78192>>>>>>>        Handle hoCLI
78192>>>>>>>        String sDriverID
78192>>>>>>>
78192>>>>>>>        Get psDriverID to sDriverID
78193>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
78194>>>>>>>        If (hoCLI <> 0) Begin
78196>>>>>>>            Set psDriverID of hoCLI to sDriverID
78197>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
78198>>>>>>>            Send Destroy of hoCLI
78199>>>>>>>        End
78199>>>>>>>>
78199>>>>>>>
78199>>>>>>>        Function_Return iRetval
78200>>>>>>>    End_Function
78201>>>>>>>
78201>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
78203>>>>>>>        tSQLConnection SQLConnection
78203>>>>>>>        tSQLConnection SQLConnection
78203>>>>>>>
78203>>>>>>>        Set psDriverID to sDriverID
78204>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
78205>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
78206>>>>>>>    End_Procedure
78207>>>>>>>
78207>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
78207>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
78207>>>>>>>    // or the one in the DataFlex Bin folder.)
78207>>>>>>>    // We then need to delete the current one before creating a new one.
78207>>>>>>>    // This is because the parameters may differ between the program code and the
78207>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
78207>>>>>>>    // when one tries to create a Connection ID that already exists.
78207>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
78209>>>>>>>        Integer iResult iDriver iNumConn iConn
78209>>>>>>>        Handle hoCLI
78209>>>>>>>        String sID
78209>>>>>>>
78209>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
78211>>>>>>>            Procedure_Return
78212>>>>>>>        End
78212>>>>>>>>
78212>>>>>>>
78212>>>>>>>        Move 0 to iResult
78213>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78214>>>>>>>        If (hoCLI <> 0) Begin
78216>>>>>>>            Set psDriverID of hoCLI to sDriverID
78217>>>>>>>            Get DriverIndex sDriverID to iDriver
78218>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78221>>>>>>>            Decrement iNumConn
78222>>>>>>>            For iConn from 0 to iNumConn
78228>>>>>>>>
78228>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78231>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78233>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
78234>>>>>>>                End
78234>>>>>>>>
78234>>>>>>>            Loop
78235>>>>>>>>
78235>>>>>>>            Send Destroy of hoCLI
78236>>>>>>>        End
78236>>>>>>>>
78236>>>>>>>
78236>>>>>>>    End_Procedure
78237>>>>>>>
78237>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
78239>>>>>>>        Integer iResult iDriver iNumConn iConn
78239>>>>>>>        Handle hoCLI
78239>>>>>>>        String sID sConnectionString sVal sDatabase
78239>>>>>>>        tSQLConnection SQLConnection
78239>>>>>>>        tSQLConnection SQLConnection
78239>>>>>>>        Boolean bTrusted
78239>>>>>>>
78239>>>>>>>        Move 0 to iResult
78240>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78241>>>>>>>        If (hoCLI <> 0) Begin
78243>>>>>>>            Set psDriverID of hoCLI to sDriverID
78244>>>>>>>            Get DriverIndex sDriverID to iDriver
78245>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78248>>>>>>>            Decrement iNumConn
78249>>>>>>>            For iConn from 0 to iNumConn
78255>>>>>>>>
78255>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78258>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78260>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
78261>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
78264>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
78267>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
78268>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
78271>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
78272>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
78273>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
78274>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
78275>>>>>>>
78275>>>>>>>                    Case Begin
78275>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
78277>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
78278>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
78279>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
78280>>>>>>>                            Case Break
78281>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
78284>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78285>>>>>>>                            Case Break
78286>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
78289>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78290>>>>>>>                            If (SQLConnection.sServer = "") Begin
78292>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78293>>>>>>>                            End
78293>>>>>>>>
78293>>>>>>>                            Case Break
78294>>>>>>>                        Case Else
78294>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
78295>>>>>>>>
78295>>>>>>>                            Case Break
78296>>>>>>>                    Case End
78296>>>>>>>                End
78296>>>>>>>>
78296>>>>>>>            Loop
78297>>>>>>>>
78297>>>>>>>            Send Destroy of hoCLI
78298>>>>>>>        End
78298>>>>>>>>
78298>>>>>>>
78298>>>>>>>        Function_Return SQLConnection
78299>>>>>>>    End_Function
78300>>>>>>>
78300>>>>>>>    Function DriverIndex String sDriverID Returns Integer
78302>>>>>>>        String  sCurrentDriver
78302>>>>>>>        Integer iNumberOfDrivers iDriver iCount
78302>>>>>>>
78302>>>>>>>        Move 0 to iDriver
78303>>>>>>>        Move 0 to iCount
78304>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78307>>>>>>>        For iCount from 1 to iNumberOfDrivers
78313>>>>>>>>
78313>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
78316>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
78318>>>>>>>                Function_Return iCount
78319>>>>>>>            End
78319>>>>>>>>
78319>>>>>>>        Loop
78320>>>>>>>>
78320>>>>>>>
78320>>>>>>>        // If driver not previously loaded; attempt to do so now.
78320>>>>>>>        If (iDriver = 0) Begin
78322>>>>>>>            Move 0 to LastErr
78323>>>>>>>            Load_Driver sDriverID
78324>>>>>>>            // If driver could not be loaded.
78324>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
78326>>>>>>>                Move -1 to iCount
78327>>>>>>>            End
78327>>>>>>>>
78327>>>>>>>        End
78327>>>>>>>>
78327>>>>>>>        Function_Return iCount
78328>>>>>>>    End_Function
78329>>>>>>>
78329>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
78329>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
78331>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
78331>>>>>>>        Boolean bTrusted bSilent
78331>>>>>>>        Integer iRetval
78331>>>>>>>
78331>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
78332>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
78333>>>>>>>        Move SQLConnection.sServer       to sServer
78334>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
78335>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
78336>>>>>>>        Move SQLConnection.sUserID       to sUserID
78337>>>>>>>        Move SQLConnection.sPassword     to sPassword
78338>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
78339>>>>>>>
78339>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
78340>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
78340>>>>>>>        Get AutoSetConnectionID to iRetval
78341>>>>>>>    End_Procedure
78342>>>>>>>
78342>>>>>>>    // Called when the object is constructed.
78342>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
78342>>>>>>>    // as psConnectionID property. It is later used whenever a login to
78342>>>>>>>    // the database is needed.
78342>>>>>>>    Function AutoSetConnectionID Returns Boolean
78344>>>>>>>        String sConnectionID sDriverID sConnectionString
78344>>>>>>>        Integer iDriver iRetval
78344>>>>>>>        Handle hoCLI
78344>>>>>>>        Boolean bOK bSilent
78344>>>>>>>
78344>>>>>>>        Get pbSilentLogin      to bSilent
78345>>>>>>>        Get psConnectionID     to sConnectionID
78346>>>>>>>        Get psConnectionString to sConnectionString
78347>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
78347>>>>>>>        Get psDriverID to sDriverID
78348>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78349>>>>>>>        If (bOK = False) Begin
78351>>>>>>>            Function_Return False
78352>>>>>>>        End
78352>>>>>>>>
78352>>>>>>>
78352>>>>>>>        Get DriverIndex sDriverID          to iDriver
78353>>>>>>>        // If driver not loaded; load it.
78353>>>>>>>        If (iDriver = 0) Begin
78355>>>>>>>            Load_Driver sDriverID
78356>>>>>>>            Get DriverIndex sDriverID      to iDriver
78357>>>>>>>        End
78357>>>>>>>>
78357>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
78357>>>>>>>        If (iDriver = 0) Begin
78359>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
78360>>>>>>>>
78360>>>>>>>            Function_Return False
78361>>>>>>>        End           
78361>>>>>>>>
78361>>>>>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
78364>>>>>>>        
78364>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78365>>>>>>>        Set psDriverID of hoCLI            to sDriverID
78366>>>>>>>        // Delete the connection first; in case it exists
78366>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
78367>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
78368>>>>>>>        Send Destroy of hoCLI
78369>>>>>>>
78369>>>>>>>        Function_Return (iRetval = 0)
78370>>>>>>>    End_Function
78371>>>>>>>
78371>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
78373>>>>>>>        Boolean bOK
78373>>>>>>>
78373>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78374>>>>>>>
78374>>>>>>>        If (bOK = False) Begin
78376>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
78377>>>>>>>>
78377>>>>>>>            Function_Return False
78378>>>>>>>        End
78378>>>>>>>>
78378>>>>>>>
78378>>>>>>>        Function_Return True
78379>>>>>>>    End_Function
78380>>>>>>>
78380>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78382>>>>>>>        Boolean bOK
78382>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
78383>>>>>>>        Function_Return bOK
78384>>>>>>>    End_Function
78385>>>>>>>
78385>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78387>>>>>>>        Handle hoIniFile
78387>>>>>>>        String sConnect
78387>>>>>>>
78387>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78388>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
78389>>>>>>>
78389>>>>>>>        Function_Return sConnect
78390>>>>>>>    End_Function
78391>>>>>>>
78391>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
78391>>>>>>>    // Pass a complete driver connection string
78391>>>>>>>    // Returns the following as a struct:
78391>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
78391>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
78391>>>>>>>    //
78391>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
78393>>>>>>>        tSQLConnection SQLConnection
78393>>>>>>>        tSQLConnection SQLConnection
78393>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
78393>>>>>>>        Boolean bTrusted bSilent bOK
78393>>>>>>>        Integer iPos
78393>>>>>>>
78393>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78394>>>>>>>        If (bOK = False) Begin
78396>>>>>>>            Function_Return SQLConnection
78397>>>>>>>        End
78397>>>>>>>>
78397>>>>>>>
78397>>>>>>>        Move False to bTrusted
78398>>>>>>>        Move False to bSilent
78399>>>>>>>
78399>>>>>>>        Case Begin
78399>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
78401>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78402>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78403>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78404>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78405>>>>>>>                If (bTrusted = False) Begin
78407>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78408>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78409>>>>>>>                End
78409>>>>>>>>
78409>>>>>>>                Case Break
78410>>>>>>>
78410>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
78413>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
78415>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
78416>>>>>>>                End
78416>>>>>>>>
78416>>>>>>>                Else Begin
78417>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78418>>>>>>>                End
78418>>>>>>>>
78418>>>>>>>
78418>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78419>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78420>>>>>>>                If (bTrusted = False) Begin
78422>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78423>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78424>>>>>>>                End
78424>>>>>>>>
78424>>>>>>>                Case Break
78425>>>>>>>
78425>>>>>>>            Case (sDriverID = DB2_DRV_ID)
78428>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78429>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78430>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78431>>>>>>>                Case Break
78432>>>>>>>
78432>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78435>>>>>>>                Break
78436>>>>>>>        Case End
78436>>>>>>>
78436>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
78437>>>>>>>
78437>>>>>>>        // bSilent?
78437>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
78438>>>>>>>        If (iPos = 0) Begin
78440>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
78441>>>>>>>        End
78441>>>>>>>>
78441>>>>>>>        If (iPos = 0) Begin
78443>>>>>>>            Move "0"                                                            to sValue
78444>>>>>>>        End
78444>>>>>>>>
78444>>>>>>>        Else Begin
78445>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
78446>>>>>>>        End
78446>>>>>>>>
78446>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
78447>>>>>>>
78447>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
78448>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
78449>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
78450>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
78451>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
78452>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
78453>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
78454>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
78455>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
78456>>>>>>>
78456>>>>>>>        Function_Return SQLConnection
78457>>>>>>>    End_Function
78458>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78458>>>>>>>>
78458>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78460>>>>>>>>    Integer iStart iEnd
78460>>>>>>>>    String sRetval
78460>>>>>>>>
78460>>>>>>>>    Move (Trim(sConnect)) to sConnect
78461>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78462>>>>>>>>    If (iStart = 0) Begin
78464>>>>>>>>        Function_Return ""
78465>>>>>>>>    End
78465>>>>>>>>>
78465>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78466>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78467>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78469>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78470>>>>>>>>    End
78470>>>>>>>>>
78470>>>>>>>>    Else Begin
78471>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
78472>>>>>>>>    End
78472>>>>>>>>>
78472>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78474>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78475>>>>>>>>        Decrement iEnd
78476>>>>>>>>    End
78476>>>>>>>>>
78476>>>>>>>>    If (iEnd <> 0) Begin
78478>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78479>>>>>>>>    End
78479>>>>>>>>>
78479>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78480>>>>>>>>
78480>>>>>>>>    Function_Return (Trim(sRetval))
78481>>>>>>>>End_Function
78482>>>>>>>>
78482>>>>>>>>
78482>>>>>>>
78482>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
78482>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78484>>>>>>>        Handle ho
78484>>>>>>>        Integer iIndex
78484>>>>>>>        Boolean bRetval bOK
78484>>>>>>>        tSQLConnection SQLConnection
78484>>>>>>>        tSQLConnection SQLConnection
78484>>>>>>>
78484>>>>>>>        Get pSQLConnection to SQLConnection
78485>>>>>>>        Get phoSQLConnectionIniFile to ho
78486>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
78487>>>>>>>        If (iIndex = -1) Begin
78489>>>>>>>            Function_Return False
78490>>>>>>>        End
78490>>>>>>>>
78490>>>>>>>
78490>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
78491>>>>>>>        Send UpdateConnectionString SQLConnection
78492>>>>>>>        If (ghoConnection > 0) Begin
78494>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
78495>>>>>>>            If (iIndex <> -1) Begin
78497>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
78498>>>>>>>            End
78498>>>>>>>>
78498>>>>>>>        End
78498>>>>>>>>
78498>>>>>>>
78498>>>>>>>        Function_Return bRetval
78499>>>>>>>    End_Function
78500>>>>>>>
78500>>>>>>>End_Class
78501>>>>>Use vWin32fh.pkg
78501>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout20\DfAbout.pkg)
78501>>>>>>>Use LanguageText.pkg
78501>>>>>>>Use Windows.pkg
78501>>>>>>>Use Dfclient.pkg
78501>>>>>>>Use DFbitmap.pkg
78501>>>>>>>Use GlobalFunctionsProcedures.pkg
78501>>>>>>>Use cRichEdit.pkg
78501>>>>>>>Use cTextEdit.pkg
78501>>>>>>>Use cRichEdit.pkg
78501>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 23.0\Pkg\gFormatNumbers.pkg)
78501>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cFormatter.pkg)
78501>>>>>>>>>>>Use VDFBase.pkg
78501>>>>>>>>>>>
78501>>>>>>>>>>>Class cFormatter is an cObject
78502>>>>>>>>>>>    
78502>>>>>>>>>>>    Procedure Construct_object
78504>>>>>>>>>>>        Integer iCh
78504>>>>>>>>>>>        Forward Send construct_object
78506>>>>>>>>>>>        Property String  psCurrencySymbol
78507>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
78508>>>>>>>>>>>        
78508>>>>>>>>>>>        Property String  psLeft
78509>>>>>>>>>>>        Property String  psright
78510>>>>>>>>>>>        Property Integer pbThousandsSep
78511>>>>>>>>>>>        Property Integer piPoints
78512>>>>>>>>>>>        
78512>>>>>>>>>>>        Property String  psCurPosLeft
78513>>>>>>>>>>>        Property String  psCurPosright
78514>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
78515>>>>>>>>>>>        Property Integer piCurPosPoints
78516>>>>>>>>>>>        
78516>>>>>>>>>>>        Property String  psCurNegLeft
78517>>>>>>>>>>>        Property String  psCurNegright
78518>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
78519>>>>>>>>>>>        Property Integer piCurNegPoints
78520>>>>>>>>>>>        
78520>>>>>>>>>>>        Property String  psNumPosLeft
78521>>>>>>>>>>>        Property String  psNumPosright
78522>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
78523>>>>>>>>>>>        Property Integer piNumPosPoints
78524>>>>>>>>>>>        
78524>>>>>>>>>>>        Property String  psNumNegLeft
78525>>>>>>>>>>>        Property String  psNumNegright
78526>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
78527>>>>>>>>>>>        Property Integer piNumNegPoints
78528>>>>>>>>>>>        
78528>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
78529>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
78530>>>>>>>>>>>        
78530>>>>>>>>>>>    End_Procedure
78531>>>>>>>>>>>    
78531>>>>>>>>>>>    // internal
78531>>>>>>>>>>>    // parse passed format string and set temporary properties with result
78531>>>>>>>>>>>    Procedure ParseFormat String sFmt
78533>>>>>>>>>>>        
78533>>>>>>>>>>>        String sLeft sRight sDigit
78533>>>>>>>>>>>        Integer bSep iPos i iDigits
78533>>>>>>>>>>>        
78533>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
78533>>>>>>>>>>>        // some literals are special. $ . , / #
78533>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
78534>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
78535>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
78536>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
78537>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
78538>>>>>>>>>>>        Move (Character(9)) to sDigit
78539>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
78540>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
78541>>>>>>>>>>>        
78541>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
78542>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
78545>>>>>>>>>>>        
78545>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
78546>>>>>>>>>>>        
78546>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
78547>>>>>>>>>>>        
78547>>>>>>>>>>>        // Move all the special literals back into place before parsing
78547>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
78548>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
78549>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
78550>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
78551>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
78552>>>>>>>>>>>        
78552>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
78554>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
78555>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
78557>>>>>>>>>>>                Move -2 to iDigits
78558>>>>>>>>>>>                Increment i
78559>>>>>>>>>>>            End
78559>>>>>>>>>>>>
78559>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
78563>>>>>>>>>>>                Increment i
78564>>>>>>>>>>>            Loop
78565>>>>>>>>>>>>
78565>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
78566>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
78569>>>>>>>>>>>            //
78569>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
78570>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
78574>>>>>>>>>>>                Increment i
78575>>>>>>>>>>>            Loop
78576>>>>>>>>>>>>
78576>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
78577>>>>>>>>>>>        End
78577>>>>>>>>>>>>
78577>>>>>>>>>>>        Else Begin                             // we have no decinal
78578>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
78579>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
78580>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
78582>>>>>>>>>>>                Move sFmt to sLeft
78583>>>>>>>>>>>                Move ""   to sRight
78584>>>>>>>>>>>            End
78584>>>>>>>>>>>>
78584>>>>>>>>>>>            Else Begin
78585>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
78586>>>>>>>>>>>                Move 1 to i
78587>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
78591>>>>>>>>>>>                    Increment i
78592>>>>>>>>>>>                Loop
78593>>>>>>>>>>>>
78593>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
78594>>>>>>>>>>>            End
78594>>>>>>>>>>>>
78594>>>>>>>>>>>        End
78594>>>>>>>>>>>>
78594>>>>>>>>>>>        // set temporary format properties and exit
78594>>>>>>>>>>>        Set pbThousandsSep to bSep
78595>>>>>>>>>>>        Set psLeft         to sLeft
78596>>>>>>>>>>>        Set psRight        to sRight
78597>>>>>>>>>>>        Set piPoints       to iDigits
78598>>>>>>>>>>>    End_Procedure
78599>>>>>>>>>>>    
78599>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
78599>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
78599>>>>>>>>>>>    //
78599>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
78599>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
78601>>>>>>>>>>>        String sPos sNeg
78601>>>>>>>>>>>        Integer iPos
78601>>>>>>>>>>>        
78601>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78602>>>>>>>>>>>        If iPos Begin
78604>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
78605>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
78606>>>>>>>>>>>        End
78606>>>>>>>>>>>>
78606>>>>>>>>>>>        Else Begin
78607>>>>>>>>>>>            Move sFmt         to sPos
78608>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
78609>>>>>>>>>>>        End
78609>>>>>>>>>>>>
78609>>>>>>>>>>>        Send ParseFormat sPos
78610>>>>>>>>>>>        If bCurrency Begin
78612>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
78613>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
78614>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
78615>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
78616>>>>>>>>>>>        End
78616>>>>>>>>>>>>
78616>>>>>>>>>>>        Else Begin
78617>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
78618>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
78619>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
78620>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
78621>>>>>>>>>>>        End
78621>>>>>>>>>>>>
78621>>>>>>>>>>>        
78621>>>>>>>>>>>        Send ParseFormat sNeg
78622>>>>>>>>>>>        If bCurrency Begin
78624>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
78625>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
78626>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
78627>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
78628>>>>>>>>>>>        End
78628>>>>>>>>>>>>
78628>>>>>>>>>>>        Else Begin
78629>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
78630>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
78631>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
78632>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
78633>>>>>>>>>>>        End
78633>>>>>>>>>>>>
78633>>>>>>>>>>>    End_Procedure
78634>>>>>>>>>>>    
78634>>>>>>>>>>>    // low level formatting. Pass parameters
78634>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
78636>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
78636>>>>>>>>>>>        Integer bIsNegative iDec iLen iCh
78636>>>>>>>>>>>        
78636>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
78639>>>>>>>>>>>        Move (Character(iCh)) to sDec
78640>>>>>>>>>>>        
78640>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
78641>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
78642>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
78643>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
78644>>>>>>>>>>>        // format for decimal separator
78644>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
78647>>>>>>>>>>>        
78647>>>>>>>>>>>        // format for thousand sep.
78647>>>>>>>>>>>        If bSep Begin
78649>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
78652>>>>>>>>>>>            Move (Character(iCh)) to sSep
78653>>>>>>>>>>>            Move (Length(sLeft)) to iLen
78654>>>>>>>>>>>            While (iLen>3)
78658>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
78659>>>>>>>>>>>                Move (iLen-3) to iLen
78660>>>>>>>>>>>            Loop
78661>>>>>>>>>>>>
78661>>>>>>>>>>>        End
78661>>>>>>>>>>>>
78661>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
78661>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
78664>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
78665>>>>>>>>>>>    End_Function
78666>>>>>>>>>>>    
78666>>>>>>>>>>>    // Public: Format for currency
78666>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
78668>>>>>>>>>>>        String  sLeft sRight
78668>>>>>>>>>>>        Integer bSep
78668>>>>>>>>>>>        If (nNumber<0) Begin
78670>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
78671>>>>>>>>>>>            Get psCurNegLeft         to sLeft
78672>>>>>>>>>>>            Get psCurNegRight        to sRight
78673>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
78676>>>>>>>>>>>        End
78676>>>>>>>>>>>>
78676>>>>>>>>>>>        Else Begin
78677>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
78678>>>>>>>>>>>            Get psCurPosLeft         to sLeft
78679>>>>>>>>>>>            Get psCurPosRight        to sRight
78680>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
78683>>>>>>>>>>>        End
78683>>>>>>>>>>>>
78683>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78684>>>>>>>>>>>    End_Function
78685>>>>>>>>>>>    
78685>>>>>>>>>>>    // Public: Format for numeric
78685>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
78687>>>>>>>>>>>        String  sLeft sRight
78687>>>>>>>>>>>        Integer bSep
78687>>>>>>>>>>>        If (nNumber<0) Begin
78689>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
78690>>>>>>>>>>>            Get psNumNegLeft         to sLeft
78691>>>>>>>>>>>            Get psNumNegRight        to sRight
78692>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
78695>>>>>>>>>>>        End
78695>>>>>>>>>>>>
78695>>>>>>>>>>>        Else Begin
78696>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
78697>>>>>>>>>>>            Get psNumPosLeft         to sLeft
78698>>>>>>>>>>>            Get psNumPosRight        to sRight
78699>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
78702>>>>>>>>>>>        End
78702>>>>>>>>>>>>
78702>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78703>>>>>>>>>>>    End_Function
78704>>>>>>>>>>>    
78704>>>>>>>>>>>    
78704>>>>>>>>>>>    // Public: Format passing format string
78704>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
78706>>>>>>>>>>>        Integer iPos bIsNeg
78706>>>>>>>>>>>        String  sLeft sRight
78706>>>>>>>>>>>        Integer iPoints bSep
78706>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
78707>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78708>>>>>>>>>>>        Case Begin
78708>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
78711>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
78715>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
78719>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
78721>>>>>>>>>>>        Case End
78721>>>>>>>>>>>        Send ParseFormat sFmt
78722>>>>>>>>>>>        Get pbThousandsSep to bSep
78723>>>>>>>>>>>        Get psLeft         to sLeft
78724>>>>>>>>>>>        Get psRight        to sRight
78725>>>>>>>>>>>        Get piPoints       to iPoints
78726>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78727>>>>>>>>>>>    End_Function
78728>>>>>>>>>>>    
78728>>>>>>>>>>>End_Class
78729>>>>>>>>>
78729>>>>>>>>>Global_Variable Handle ghoFormatter
78729>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
78730>>>>>>>>>
78730>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
78732>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
78733>>>>>>>>>End_Function
78734>>>>>>>>>
78734>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
78736>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
78737>>>>>>>>>End_Function
78738>>>>>>>>>
78738>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
78740>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
78741>>>>>>>>>End_Function
78742>>>>>>>>>
78742>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
78744>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
78745>>>>>>>>>End_Procedure
78746>>>>>>>>>
78746>>>>>>>>>Procedure SetNumberFormat Global String sFmt
78748>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
78749>>>>>>>>>End_Procedure
78750>>>>>>>>>
78750>>>>>>>>>
78750>>>>>>>Use tWinStructs.pkg
78750>>>>>>>
78750>>>>>>>Use cli.pkg
78750>>>>>>>Use DFBTRDRV.PKG
78750>>>>>>>Use MSSqldrv.pkg
78750>>>>>>>Use db2_drv.pkg
78750>>>>>>>Use odbc_drv.pkg
78750>>>>>>>Use seq_chnl.pkg
78750>>>>>>>
78750>>>>>>>Register_Function phoWorkspace Returns Handle
78750>>>>>>>Register_Function Help_filename Returns String
78750>>>>>>>Register_Function GetHelpFile Returns String
78750>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
78750>>>>>>>
78750>>>>>>>// *** Constant Declarations: ***
78750>>>>>>>//
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>// System icon menu constants. If the upper left hand
78750>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
78750>>>>>>>    Define SC_RESTORE  for |CI$F120
78750>>>>>>>    Define SC_MOVE     for |CI$F010
78750>>>>>>>    Define SC_SIZE     for |CI$F000
78750>>>>>>>    Define SC_MINIMIZE for |CI$F020
78750>>>>>>>    Define SC_MAXIMIZE for |CI$F030
78750>>>>>>>    Define SC_CLOSE    for |CI$F060
78750>>>>>>>    Define SC_KEYMENU  for |CI$F100
78750>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
78750>>>>>>>    Define SC_PREVWINDOW for |CI$F050
78750>>>>>>>
78750>>>>>>>Define CS_SignProgram        for "signtool.exe"
78750>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
78750>>>>>>>Define CS_VerifyCredentials  for "verify"
78750>>>>>>>Define CS_VerifyFileParam    for "/a"
78750>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
78750>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
78750>>>>>>>
78750>>>>>>>// *** Struct Declarations: ***
78750>>>>>>>Struct AboutSHELLEXECUTEINFO
78750>>>>>>>    DWord   cbSize
78750>>>>>>>    Integer fMask
78750>>>>>>>    Handle  hwnd
78750>>>>>>>    Pointer lpVerb
78750>>>>>>>    Pointer lpFile
78750>>>>>>>    Pointer lpParameters
78750>>>>>>>    Pointer lpDirectory
78750>>>>>>>    Integer nShow
78750>>>>>>>    Pointer hInstApp
78750>>>>>>>    Pointer lpIDList
78750>>>>>>>    Pointer lpClass
78750>>>>>>>    Handle  hkeyClass
78750>>>>>>>    DWord   dwHotKey
78750>>>>>>>    Handle  hIconMonitor // Union
78750>>>>>>>    //Handle  hMonitor     // Union
78750>>>>>>>    Handle  hProcess
78750>>>>>>>End_Struct
78750>>>>>>>
78750>>>>>>>
78750>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
78750>>>>>>>//Type MEMORYSTATUS
78750>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
78750>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
78750>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
78750>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
78750>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
78750>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
78750>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
78750>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
78750>>>>>>>//End_Type
78750>>>>>>>
78750>>>>>>>// *** External Function calls: ***
78750>>>>>>>//
78750>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
78751>>>>>>>
78751>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
78752>>>>>>>
78752>>>>>>>// Do not call directly, use the wrapper function instead
78752>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
78753>>>>>>>
78753>>>>>>>    // Wrapper Function WNetGetUser
78753>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
78755>>>>>>>
78755>>>>>>>        DWord   dwResult
78755>>>>>>>        UWide   uwName uwUserName
78755>>>>>>>        UWide   uwName uwUserName
78755>>>>>>>
78755>>>>>>>        Send StringToWide lpName (&uwName)
78756>>>>>>>
78756>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
78757>>>>>>>
78757>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
78758>>>>>>>
78758>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
78759>>>>>>>
78759>>>>>>>        Function_Return dwResult
78760>>>>>>>    End_Function
78761>>>>>>>
78761>>>>>>>
78761>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
78762>>>>>>>
78762>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
78763>>>>>>>
78763>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
78764>>>>>>>
78764>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
78765>>>>>>>
78765>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
78766>>>>>>>
78766>>>>>>>// *** Global/Desktop Function Declarations: ***
78766>>>>>>>
78766>>>>>>>Function ComputerName Desktop Returns String
78768>>>>>>>    String sName
78768>>>>>>>    Get_Environment "COMPUTERNAME" to sName
78769>>>>>>>>
78769>>>>>>>    Function_Return sName
78770>>>>>>>End_Function
78771>>>>>>>
78771>>>>>>>Function Network_User_Name Desktop Returns String
78773>>>>>>>    WString wName
78773>>>>>>>    Integer iRetval iLength
78773>>>>>>>
78773>>>>>>>    Move 0 to iLength
78774>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
78775>>>>>>>    Move (ZeroString(iLength)) to wName
78776>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
78777>>>>>>>
78777>>>>>>>    If (iRetval = NO_ERROR) Begin
78779>>>>>>>        Function_Return (CString (wName))
78780>>>>>>>    End
78780>>>>>>>>
78780>>>>>>>
78780>>>>>>>    Function_Return "User Unknown"
78781>>>>>>>End_Function
78782>>>>>>>
78782>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
78784>>>>>>>    String sClient sDriver sClientDriver
78784>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
78784>>>>>>>    Handle hoMsqlDrv
78784>>>>>>>
78784>>>>>>>    Move 0 to iDriver
78785>>>>>>>    Move "" to sClient
78786>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78789>>>>>>>    For iCount from 1 to iNumberOfDrivers
78795>>>>>>>>
78795>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
78798>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
78800>>>>>>>            Move iCount to iDriver
78801>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
78802>>>>>>>        End
78802>>>>>>>>
78802>>>>>>>    Loop
78803>>>>>>>>
78803>>>>>>>
78803>>>>>>>    // This info is (at current) only available for the MS SQL driver:
78803>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
78805>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
78808>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
78809>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
78810>>>>>>>        Send Destroy of hoMsqlDrv
78811>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
78812>>>>>>>    End
78812>>>>>>>>
78812>>>>>>>
78812>>>>>>>    Function_Return sClient
78813>>>>>>>End_Function
78814>>>>>>>
78814>>>>>>>// *** Class Declarations: ***
78814>>>>>>>//
78814>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
78815>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
78817>>>>>>>        Send Mouse_Up iWindowNumber iPosition
78818>>>>>>>    End_Procedure
78819>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
78821>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
78823>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
78824>>>>>>>    End_Procedure
78825>>>>>>>End_Class
78826>>>>>>>
78826>>>>>>>Class cCopyEditorContentButton is a Button
78827>>>>>>>    Procedure Construct_Object
78829>>>>>>>        Forward Send Construct_Object
78831>>>>>>>        Property Handle phoEditorHandle
78832>>>>>>>        Set psToolTip to C_$DescCopy
78833>>>>>>>    End_Procedure
78834>>>>>>>
78834>>>>>>>    Procedure CopyToWindowsClipboard
78836>>>>>>>        Handle hoEditor
78836>>>>>>>        Boolean bCanCopy
78836>>>>>>>        Address aEditorAddress
78836>>>>>>>
78836>>>>>>>        Get phoEditorHandle to hoEditor
78837>>>>>>>        Send Select_All of hoEditor
78838>>>>>>>        Get CanCopy of hoEditor to bCanCopy
78839>>>>>>>        If (bCanCopy = True) Begin
78841>>>>>>>            Get paValue of hoEditor to aEditorAddress
78842>>>>>>>            Send Copy   of hoEditor
78843>>>>>>>            // Remove the selection after text is copied to the clipboard.
78843>>>>>>>            Send Beginning_of_Data of hoEditor
78844>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
78845>>>>>>>        End
78845>>>>>>>>
78845>>>>>>>    End_Procedure
78846>>>>>>>End_Class
78847>>>>>>>
78847>>>>>>>Class SysinfoDisplay is a cTextEdit
78848>>>>>>>    Procedure Construct_Object
78850>>>>>>>        Forward Send Construct_Object
78852>>>>>>>
78852>>>>>>>        Set Size to 100 245
78853>>>>>>>        Set Location to 6 6
78854>>>>>>>        Set Border_Style to Border_None
78855>>>>>>>        Set Read_Only_State to True
78856>>>>>>>        Set pbWrap to True
78857>>>>>>>        Set peAnchors to anAll
78858>>>>>>>    End_Procedure
78859>>>>>>>
78859>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
78859>>>>>>>
78859>>>>>>>    Procedure AppendTextLn String sText
78861>>>>>>>        String sWorkspaceWSFile
78861>>>>>>>
78861>>>>>>>        // Only works for English:
78861>>>>>>>        If (ghoApplication > 0) Begin
78863>>>>>>>            If (sText contains "Workspace Name") Begin
78865>>>>>>>                Move "Workspace Config Filename:" to sText
78866>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
78867>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
78868>>>>>>>            End
78868>>>>>>>>
78868>>>>>>>        End
78868>>>>>>>>
78868>>>>>>>        Send AppendText sText
78869>>>>>>>        Send AppendText (character(10))
78870>>>>>>>    End_Procedure
78871>>>>>>>
78871>>>>>>>    //    This method will show the name Of the current directory in the system
78871>>>>>>>    //    information box
78871>>>>>>>    Procedure Show_Current_Directory
78873>>>>>>>        String sDir
78873>>>>>>>
78873>>>>>>>        Get_Current_Directory To sDir
78874>>>>>>>
78874>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
78875>>>>>>>    End_Procedure
78876>>>>>>>
78876>>>>>>>    Procedure Show_Windows_Directory
78878>>>>>>>        String sWindir
78878>>>>>>>
78878>>>>>>>        Get_Windows_Directory To sWindir
78879>>>>>>>
78879>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
78880>>>>>>>    End_Procedure
78881>>>>>>>
78881>>>>>>>    Procedure Show_Current_User
78883>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
78884>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
78885>>>>>>>    End_Procedure
78886>>>>>>>
78886>>>>>>>    Procedure Show_Number_Format
78888>>>>>>>        Integer iFormat
78888>>>>>>>        String sFormatText
78888>>>>>>>
78888>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
78891>>>>>>>        Move (Character (iFormat)) To sFormatText
78892>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
78893>>>>>>>
78893>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
78896>>>>>>>        Move (Character (iFormat)) to sFormatText
78897>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
78898>>>>>>>    End_Procedure
78899>>>>>>>
78899>>>>>>>    Procedure Show_Filelist_Name
78901>>>>>>>        String sFilename
78901>>>>>>>
78901>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
78904>>>>>>>
78904>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
78905>>>>>>>    End_Procedure
78906>>>>>>>
78906>>>>>>>    Procedure Show_Lock_Delay
78908>>>>>>>        Integer iLockdelay
78908>>>>>>>
78908>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
78911>>>>>>>
78911>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
78912>>>>>>>    End_Procedure
78913>>>>>>>
78913>>>>>>>    Procedure Show_Lock_Timeout
78915>>>>>>>        Integer iLockTimeout
78915>>>>>>>
78915>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
78918>>>>>>>
78918>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
78919>>>>>>>    End_Procedure
78920>>>>>>>
78920>>>>>>>    Procedure Show_Screen_Size
78922>>>>>>>        Integer iYscreensize iXscreensize
78922>>>>>>>
78922>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
78923>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
78924>>>>>>>
78924>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
78925>>>>>>>    End_Procedure
78926>>>>>>>
78926>>>>>>>    Procedure Show_Page_Size
78928>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
78929>>>>>>>    End_procedure
78930>>>>>>>
78930>>>>>>>    Procedure Show_Date
78932>>>>>>>        Date dToday
78932>>>>>>>
78932>>>>>>>        Move (CurrentDateTime()) to dToday
78933>>>>>>>
78933>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
78934>>>>>>>    End_procedure
78935>>>>>>>
78935>>>>>>>    Procedure Show_Date_Format
78937>>>>>>>        Integer iDateFormat
78937>>>>>>>        String sDateFormat
78937>>>>>>>
78937>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
78940>>>>>>>        Case Begin
78940>>>>>>>            Case (iDateFormat = DF_DATE_USA)
78942>>>>>>>                Move C_$USA To sDateFormat
78943>>>>>>>                Case Break
78944>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
78947>>>>>>>                Move C_$European To sDateFormat
78948>>>>>>>                Case Break
78949>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
78952>>>>>>>                Move C_$Military To sDateFormat
78953>>>>>>>                Case Break
78954>>>>>>>            Case Else
78954>>>>>>>                Move C_$UnknownDateType To sDateFormat
78955>>>>>>>                Case Break
78956>>>>>>>        Case End
78956>>>>>>>
78956>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
78957>>>>>>>    End_Procedure
78958>>>>>>>
78958>>>>>>>    // 2013-08-14 NGS
78958>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
78958>>>>>>>    Procedure Show_Systemresources
78960>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
78960>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
78960>>>>>>>        Integer iRetval
78960>>>>>>>        Number nValue
78960>>>>>>>        String sValue
78960>>>>>>>
78960>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
78961>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
78962>>>>>>>        If (iRetval = 0) Begin
78964>>>>>>>            Move (ShowLastError ()) to iRetval
78965>>>>>>>            Procedure_Return
78966>>>>>>>        End
78966>>>>>>>>
78966>>>>>>>
78966>>>>>>>        Send AppendTextLn ""
78967>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
78968>>>>>>>
78968>>>>>>>        // Show memory in Gigabytes:
78968>>>>>>>        Move (nValue/1024/1024/1024) to nValue
78969>>>>>>>        Move (Round(nValue)) to nValue
78970>>>>>>>        Get FormatNumber nValue 2 to sValue
78971>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
78972>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
78973>>>>>>>
78973>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
78973>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
78974>>>>>>>        Move (Round(nValue)) to nValue
78975>>>>>>>        Get FormatNumber nValue 0 to sValue
78976>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
78977>>>>>>>
78977>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
78977>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
78978>>>>>>>        Move (Round(nValue)) to nValue
78979>>>>>>>        Get FormatNumber nValue 0 to sValue
78980>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
78981>>>>>>>
78981>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
78981>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
78982>>>>>>>        Move (Round(nValue)) to nValue
78983>>>>>>>        Get FormatNumber nValue 0 to sValue
78984>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
78985>>>>>>>
78985>>>>>>>        // Add an empty row after the memory information:
78985>>>>>>>        Send AppendTextLn ""
78986>>>>>>>    End_Procedure
78987>>>>>>>
78987>>>>>>>    Procedure Show_Registration
78989>>>>>>>        String sRegName
78989>>>>>>>        Integer iSN iUsersMax iUserCount
78989>>>>>>>
78989>>>>>>>        Registration sRegName iSN
78990>>>>>>>>
78990>>>>>>>        Get_Licensed_Max_Users to iUsersMax
78991>>>>>>>        Get_Current_User_Count to iUserCount
78992>>>>>>>
78992>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
78993>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
78994>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
78995>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
78996>>>>>>>    End_Procedure
78997>>>>>>>
78997>>>>>>>    //****************************************************************************
78997>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
78997>>>>>>>    // To the workspace object passing the an object and message To send back
78997>>>>>>>    // To this object. It is expected that the workspace object will send this
78997>>>>>>>    // message for every line Of information it wants displayed (passing the
78997>>>>>>>    // information To be displayed
78997>>>>>>>    //****************************************************************************
78997>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
78997>>>>>>>
78997>>>>>>>    Procedure Show_ServicePack
78999>>>>>>>        String sKey sVersion sDataFlex
78999>>>>>>>        Handle hoRegistry
78999>>>>>>>        Boolean bExists bOpened
78999>>>>>>>
78999>>>>>>>        Move "DataFlex"        to sDataFlex
79000>>>>>>>
79000>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
79001>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
79002>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
79003>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
79004>>>>>>>
79004>>>>>>>        If (bExists) Begin
79006>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79007>>>>>>>        End
79007>>>>>>>>
79007>>>>>>>        Else Begin
79008>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79009>>>>>>>        End
79009>>>>>>>>
79009>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
79010>>>>>>>        If (bExists) Begin
79012>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
79013>>>>>>>            If (bOpened) Begin
79015>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
79016>>>>>>>                If (bExists) Begin
79018>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
79019>>>>>>>                End
79019>>>>>>>>
79019>>>>>>>                Send CloseKey of hoRegistry
79020>>>>>>>            End
79020>>>>>>>>
79020>>>>>>>        End
79020>>>>>>>>
79020>>>>>>>        Send Destroy of hoRegistry
79021>>>>>>>
79021>>>>>>>        If (sVersion <> "") Begin
79023>>>>>>>           Send AppendTextLn sVersion
79024>>>>>>>           Send AppendTextLn ""
79025>>>>>>>        End
79025>>>>>>>>
79025>>>>>>>    End_Procedure
79026>>>>>>>
79026>>>>>>>    Procedure Show_WorkspaceInformation
79028>>>>>>>        Integer hoWorkspace
79028>>>>>>>
79028>>>>>>>        If (ghoApplication <> 0) Begin
79030>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79031>>>>>>>            If (hoWorkspace <> 0) Begin
79033>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
79034>>>>>>>            End
79034>>>>>>>>
79034>>>>>>>        End
79034>>>>>>>>
79034>>>>>>>    End_Procedure
79035>>>>>>>
79035>>>>>>>    //****************************************************************************
79035>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
79035>>>>>>>    // to the connection manager object passing the an object and message to send
79035>>>>>>>    // back to this object. It is expected that the connection manager object will
79035>>>>>>>    // send this message for every line Of information it wants displayed (passing
79035>>>>>>>    // the information To be displayed
79035>>>>>>>    //****************************************************************************
79035>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
79035>>>>>>>
79035>>>>>>>    Procedure Show_ConnectionIdInformation
79037>>>>>>>        If (ghoConnection > 0) Begin
79039>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79040>>>>>>>            Send AppendTextLn ""
79041>>>>>>>        End
79041>>>>>>>>
79041>>>>>>>    End_Procedure
79042>>>>>>>
79042>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
79044>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
79045>>>>>>>    End_Function
79046>>>>>>>
79046>>>>>>>    Procedure Show_Versions
79048>>>>>>>        Integer iVersion iRevision iBuild
79048>>>>>>>
79048>>>>>>>        Version_information iVersion iRevision iBuild
79050>>>>>>>
79050>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
79051>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
79052>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
79053>>>>>>>        Send AppendTextLn "This is a 32-bit exe file"
79054>>>>>>>    End_Procedure
79055>>>>>>>
79055>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
79057>>>>>>>        Boolean bOK
79057>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
79058>>>>>>>        Function_Return bOK
79059>>>>>>>    End_Function
79060>>>>>>>
79060>>>>>>>    //***
79060>>>>>>>    //*** BW
79060>>>>>>>    //*** Procedure: Show_Drivers
79060>>>>>>>    //*** Purpose  : Show loaded database drivers
79060>>>>>>>    //***
79060>>>>>>>
79060>>>>>>>//#IF (Required_FMAC_Build > 106)
79060>>>>>>>//    #Warning -3
79060>>>>>>>//#ENDIF
79060>>>>>>>    Procedure Show_Drivers
79062>>>>>>>        String sDriverID sVersion sClient sValue
79062>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
79062>>>>>>>        Handle hoCLIHandler hoBtrvHandler
79062>>>>>>>        Boolean bStudioLicense bIsDAWDriver
79062>>>>>>>
79062>>>>>>>        Move False to bStudioLicense
79063>>>>>>>
79063>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
79064>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
79065>>>>>>>
79065>>>>>>>        // For testing purposes:
79065>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79065>>>>>>>//        Load_Driver MSSQLDRV_ID
79065>>>>>>>//        Load_Driver ODBC_DRV_ID
79065>>>>>>>//        Load_Driver DB2_DRV_ID
79065>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79065>>>>>>>//
79065>>>>>>>        Move False to Err
79066>>>>>>>
79066>>>>>>>        // Loop through all loaded drivers.
79066>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79069>>>>>>>        If (iNumberOfDrivers > 1) Begin
79071>>>>>>>            Send AppendTextLn ""
79072>>>>>>>        End
79072>>>>>>>>
79072>>>>>>>        For iDriver from 1 to iNumberOfDrivers
79078>>>>>>>>
79078>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79079>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
79082>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79083>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
79084>>>>>>>
79084>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True) Begin
79086>>>>>>>
79086>>>>>>>                // Pervasive/Btrieve database
79086>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
79088>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
79089>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
79090>>>>>>>                    If (sClient <> "0.0.0") Begin
79092>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
79093>>>>>>>                    End
79093>>>>>>>>
79093>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
79094>>>>>>>                    If (sClient <> "0.0.0") Begin
79096>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
79097>>>>>>>                    End
79097>>>>>>>>
79097>>>>>>>                End
79097>>>>>>>>
79097>>>>>>>
79097>>>>>>>                Else Begin
79098>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
79099>>>>>>>                    Move 0 to iNumServers
79100>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
79102>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
79105>>>>>>>                    End
79105>>>>>>>>
79105>>>>>>>
79105>>>>>>>                    If (bIsDAWDriver = True) Begin
79107>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
79109>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
79110>>>>>>>                        End
79110>>>>>>>>
79110>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
79111>>>>>>>                    End
79111>>>>>>>>
79111>>>>>>>
79111>>>>>>>                    // If the serialnumber is = 0, it means that the
79111>>>>>>>                    // Studio licens is in use and there is no
79111>>>>>>>                    // number of max users defined because the driver is
79111>>>>>>>                    // relying on the info from the VDF license.
79111>>>>>>>                    If (bStudioLicense = False) Begin
79113>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
79114>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
79115>>>>>>>                    End
79115>>>>>>>>
79115>>>>>>>                End
79115>>>>>>>>
79115>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
79116>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
79118>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
79119>>>>>>>                End
79119>>>>>>>>
79119>>>>>>>                If (iNumServers <> 0) Begin
79121>>>>>>>                    For iCount from 1 to iNumServers
79127>>>>>>>>
79127>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
79130>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
79132>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
79133>>>>>>>                        End
79133>>>>>>>>
79133>>>>>>>                    Loop
79134>>>>>>>>
79134>>>>>>>                End
79134>>>>>>>>
79134>>>>>>>            End
79134>>>>>>>>
79134>>>>>>>        Loop
79135>>>>>>>>
79135>>>>>>>
79135>>>>>>>        Send AppendTextLn ""
79136>>>>>>>        If (bStudioLicense = False) Begin
79138>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
79139>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
79140>>>>>>>        End
79140>>>>>>>>
79140>>>>>>>        Else Begin
79141>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
79142>>>>>>>        End
79142>>>>>>>>
79142>>>>>>>        Send Destroy of hoCLIHandler
79143>>>>>>>        Send Destroy of hoBtrvHandler
79144>>>>>>>    End_Procedure
79145>>>>>>>
79145>>>>>>>    Procedure Show_HelpFile
79147>>>>>>>        String sHelpFile
79147>>>>>>>        Integer eHelpType
79147>>>>>>>
79147>>>>>>>        If (ghoApplication <> 0) Begin
79149>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
79150>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
79152>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
79153>>>>>>>            End
79153>>>>>>>>
79153>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
79156>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
79157>>>>>>>            End
79157>>>>>>>>
79157>>>>>>>            Else Begin
79158>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
79159>>>>>>>            End
79159>>>>>>>>
79159>>>>>>>
79159>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
79160>>>>>>>        End
79160>>>>>>>>
79160>>>>>>>    End_Procedure
79161>>>>>>>
79161>>>>>>>    Procedure Show_EnterAsTab
79163>>>>>>>        Boolean bEnterKeyAsTabKey
79163>>>>>>>        String sText
79163>>>>>>>
79163>>>>>>>        If (ghoApplication <> 0) Begin
79165>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
79166>>>>>>>            If (bEnterKeyAsTabKey) Begin
79168>>>>>>>                Move "True" To sText
79169>>>>>>>            End
79169>>>>>>>>
79169>>>>>>>            Else Begin
79170>>>>>>>                Move "False" To sText
79171>>>>>>>            End
79171>>>>>>>>
79171>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
79172>>>>>>>        End
79172>>>>>>>>
79172>>>>>>>    End_Procedure
79173>>>>>>>
79173>>>>>>>    //    During activation we will remove the old information and add the newly
79173>>>>>>>    //    found systeminformation
79173>>>>>>>    Procedure Add_Focus Integer hoRoot
79175>>>>>>>        Forward Send Add_Focus hoRoot
79177>>>>>>>
79177>>>>>>>        Send Delete_Data
79178>>>>>>>
79178>>>>>>>        Set Changed_State To False
79179>>>>>>>        Set Read_Only_State To True
79180>>>>>>>
79180>>>>>>>        Send Show_Registration
79181>>>>>>>        Send Show_Drivers
79182>>>>>>>        Send Show_ServicePack
79183>>>>>>>        Send Show_Versions
79184>>>>>>>        Send AppendTextLn ""
79185>>>>>>>
79185>>>>>>>        If (ghoApplication <> 0) Begin
79187>>>>>>>            Send Show_WorkSpaceInformation
79188>>>>>>>            Send Show_HelpFile
79189>>>>>>>            Send AppendTextLn ""
79190>>>>>>>        End
79190>>>>>>>>
79190>>>>>>>        Else Begin
79191>>>>>>>            Send AppendTextLn ""
79192>>>>>>>        End
79192>>>>>>>>
79192>>>>>>>
79192>>>>>>>        If (ghoConnection <> 0) Begin
79194>>>>>>>            Send Show_ConnectionIdInformation
79195>>>>>>>        End
79195>>>>>>>>
79195>>>>>>>
79195>>>>>>>        Send Show_Current_User
79196>>>>>>>        Send Show_Windows_Directory
79197>>>>>>>        Send Show_Current_Directory
79198>>>>>>>
79198>>>>>>>        // This is already shown in the workspace details,
79198>>>>>>>        // unless no workspace object is present:
79198>>>>>>>        If (ghoApplication = 0) Begin
79200>>>>>>>            Send Show_Filelist_Name
79201>>>>>>>        End
79201>>>>>>>>
79201>>>>>>>
79201>>>>>>>        If (ghoApplication <> 0) Begin
79203>>>>>>>            Send AppendTextLn ""
79204>>>>>>>            Send Show_EnterAsTab
79205>>>>>>>        End
79205>>>>>>>>
79205>>>>>>>
79205>>>>>>>        Send Show_Screen_Size
79206>>>>>>>        Send Show_Page_Size
79207>>>>>>>        Send Show_Number_Format
79208>>>>>>>        Send Show_Date_Format
79209>>>>>>>        Send Show_Lock_Delay
79210>>>>>>>        Send Show_Lock_Timeout
79211>>>>>>>        Send Show_Date
79212>>>>>>>        Send Show_Systemresources
79213>>>>>>>        Send Beginning_of_Data
79214>>>>>>>
79214>>>>>>>        Set Icon to 'default.ico'
79215>>>>>>>    End_Procedure
79216>>>>>>>End_Class
79217>>>>>>>
79217>>>>>>>Class SysInfoDialog is a ModalPanel
79218>>>>>>>    Procedure Construct_Object
79220>>>>>>>        Forward Send Construct_Object
79222>>>>>>>
79222>>>>>>>        Set Label to C_$SystemInformation
79223>>>>>>>        Set Size to 140 267
79224>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79225>>>>>>>        Set Border_Style to Border_Thick
79226>>>>>>>        Set Sysmenu_Icon to False
79227>>>>>>>
79227>>>>>>>        // "+1" will make the panel to paint correctly.
79227>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
79228>>>>>>>
79228>>>>>>>        // 2014-09-14 NGS
79228>>>>>>>        // Added a container object around the cTexteditor
79228>>>>>>>        // object to get a border around the text.
79228>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
79230>>>>>>>            Set Location to 2 4
79231>>>>>>>            Set Size to 110 255
79232>>>>>>>            Set Border_Style to Border_ClientEdge
79233>>>>>>>            Set Color to clWhite
79234>>>>>>>            Set peAnchors to anAll
79235>>>>>>>
79235>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
79237>>>>>>>            End_Object
79238>>>>>>>
79238>>>>>>>        End_Object
79239>>>>>>>
79239>>>>>>>        Object oCloseButton is a Button
79241>>>>>>>            Set Label to C_$Close
79242>>>>>>>            Set Location to 120 210
79243>>>>>>>            CompilerWarnings Off
79243>>>>>>>            Set Message Item 0 to msg_Close_Panel
79244>>>>>>>            CompilerWarnings On
79244>>>>>>>            Set Default_State To True
79245>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
79245>>>>>>>            // and changes its peAnchors, we might as well prepare this object
79245>>>>>>>            // for that situation.
79245>>>>>>>            Set peAnchors to anBottomRight
79246>>>>>>>        End_Object
79247>>>>>>>
79247>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79249>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79250>>>>>>>            Set Size to 14 50
79251>>>>>>>            Set Location to 120 158
79252>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79252>>>>>>>            // we might as well prepare the object for it.
79252>>>>>>>            Set peAnchors to anBottomRight
79253>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
79254>>>>>>>        End_Object
79255>>>>>>>
79255>>>>>>>        On_Key kCancel Send Close_Panel
79256>>>>>>>    End_Procedure
79257>>>>>>>
79257>>>>>>>    Procedure Page Integer iPageObject
79259>>>>>>>        Handle hMenu
79259>>>>>>>        Integer iPrevState
79259>>>>>>>
79259>>>>>>>        Forward Send Page iPageObject
79261>>>>>>>
79261>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
79261>>>>>>>        //
79261>>>>>>>    End_Procedure
79262>>>>>>>
79262>>>>>>>End_Class
79263>>>>>>>
79263>>>>>>>Class cAboutEdit is an cRichEdit
79264>>>>>>>    Procedure Construct_Object
79266>>>>>>>        Forward Send Construct_Object
79268>>>>>>>
79268>>>>>>>        Property String psContentText
79269>>>>>>>
79269>>>>>>>        Set Size to 77 153
79270>>>>>>>        Set Location to 8 60
79271>>>>>>>        Set Read_Only_State to True
79272>>>>>>>        Set Skip_State to True
79273>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
79273>>>>>>>        // or 1/20 of a printer's point.
79273>>>>>>>        Set piRightMargin to (0.1 * 1440)
79274>>>>>>>        Set Border_Style  to Border_None
79275>>>>>>>    End_Procedure
79276>>>>>>>
79276>>>>>>>    // Adds a line of text to the edit object
79276>>>>>>>    Procedure Add_Line String sText
79278>>>>>>>        String sContentText
79278>>>>>>>        Get psContentText to sContentText
79279>>>>>>>        Move (sContentText + String(sText)) to sContentText
79280>>>>>>>        Set psContentText to sContentText
79281>>>>>>>    End_Procedure
79282>>>>>>>
79282>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
79282>>>>>>>    // Note that we use a property psContentText and add to it,
79282>>>>>>>    // because the object isn't paged yet when we add these
79282>>>>>>>    // values and the COM edit object needs to be paged
79282>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
79282>>>>>>>    Procedure Add_LineLn String sText
79284>>>>>>>        String sContentText sCR
79284>>>>>>>
79284>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
79285>>>>>>>        Get psContentText to sContentText
79286>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
79287>>>>>>>        Set psContentText to sContentText
79288>>>>>>>    End_Procedure
79289>>>>>>>
79289>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
79291>>>>>>>        String sLinkText
79291>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
79292>>>>>>>        Send Show_HomePage sLinkText
79293>>>>>>>    End_Procedure
79294>>>>>>>
79294>>>>>>>    Procedure Page Integer iPageObject
79296>>>>>>>        String sContentText
79296>>>>>>>
79296>>>>>>>        Forward Send Page iPageObject
79298>>>>>>>        Get psContentText to sContentText
79299>>>>>>>        Send AppendText sContentText
79300>>>>>>>        send Beginning_of_Data
79301>>>>>>>    End_Procedure
79302>>>>>>>
79302>>>>>>>End_Class
79303>>>>>>>
79303>>>>>>>Class AboutDialog is a ModalPanel
79304>>>>>>>    Procedure Construct_Object
79306>>>>>>>
79306>>>>>>>        Forward Send Construct_Object
79308>>>>>>>
79308>>>>>>>        Set Label to C_$About
79309>>>>>>>        Set Size to 118 230
79310>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79311>>>>>>>        Set Border_Style to Border_Thick
79312>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
79313>>>>>>>
79313>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
79315>>>>>>>        End_Object
79316>>>>>>>
79316>>>>>>>        Object oBox is a Container3d
79318>>>>>>>            Set Border_Style to Border_Normal
79319>>>>>>>            Set Size to 90 220
79320>>>>>>>            Set Location to 4 5
79321>>>>>>>            Set Color to clWhite
79322>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79322>>>>>>>            // we might as well prepare the object for it.
79322>>>>>>>            Set peAnchors to anAll
79323>>>>>>>
79323>>>>>>>            Object oAboutGraphic is a BitmapContainer
79325>>>>>>>                Set Border_Style To Border_None
79326>>>>>>>                Set Bitmap_Style to Bitmap_Center
79327>>>>>>>                Set Color to clWhite
79328>>>>>>>                Set Size to 45 50
79329>>>>>>>                Set Location to 0 3
79330>>>>>>>            End_Object
79331>>>>>>>
79331>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
79333>>>>>>>                Set Border_Style to Border_None
79334>>>>>>>                Set Bitmap_Style to Bitmap_Center
79335>>>>>>>                Set Color to clWhite
79336>>>>>>>                Set Size to 30 55
79337>>>>>>>                Set Location to 50 3
79338>>>>>>>            End_Object
79339>>>>>>>
79339>>>>>>>            Object oInfoList_Editor is an cAboutEdit
79341>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
79341>>>>>>>                // we might as well prepare the object for it.
79341>>>>>>>                Set peAnchors to anAll
79342>>>>>>>            End_Object
79343>>>>>>>
79343>>>>>>>            // These objects are here for backwards compatability only.
79343>>>>>>>            // They are not used.
79343>>>>>>>            Object oProductName is a TextBox
79345>>>>>>>                Set Label To C_$ProductName
79346>>>>>>>                Set Size To 10 45
79347>>>>>>>                Set Location To 8 53
79348>>>>>>>                Set Visible_State to False
79349>>>>>>>                Set Focus_Mode to NonFocusable
79350>>>>>>>            End_Object
79351>>>>>>>
79351>>>>>>>            Object oVersion is a TextBox
79353>>>>>>>                Set Label To C_$Version
79354>>>>>>>                Set Size To 10 25
79355>>>>>>>                Set Location To 21 53
79356>>>>>>>                Set Visible_State to False
79357>>>>>>>                Set Focus_Mode to NonFocusable
79358>>>>>>>            End_Object
79359>>>>>>>
79359>>>>>>>            Object oCopyright is a TextBox
79361>>>>>>>                Set Label To C_$Copyright
79362>>>>>>>                Set Size To 10 31
79363>>>>>>>                Set Location To 34 53
79364>>>>>>>                Set Visible_State to False
79365>>>>>>>                Set Focus_Mode to NonFocusable
79366>>>>>>>            End_Object
79367>>>>>>>
79367>>>>>>>            Object oAuthor is a TextBox
79369>>>>>>>                Set Label To C_$Author
79370>>>>>>>                Set Size To 10 22
79371>>>>>>>                Set Location To 46 53
79372>>>>>>>                Set Visible_State to False
79373>>>>>>>                Set Focus_Mode to NonFocusable
79374>>>>>>>            End_Object
79375>>>>>>>
79375>>>>>>>        End_Object
79376>>>>>>>
79376>>>>>>>        Object oOKButton is a Button
79378>>>>>>>            On_Item C_$Close Send Close_Panel
79379>>>>>>>            Set Location to 98 176
79380>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79380>>>>>>>            // we might as well prepare the object for it.
79380>>>>>>>            Set peAnchors to anBottomRight
79381>>>>>>>        End_Object
79382>>>>>>>
79382>>>>>>>        Object oSysInfoButton is a Button
79384>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
79385>>>>>>>            Set Location to 98 123
79386>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79386>>>>>>>            // we might as well prepare the object for it.
79386>>>>>>>            Set peAnchors to anBottomRight
79387>>>>>>>        End_Object
79388>>>>>>>
79388>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79390>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79391>>>>>>>            Set Size to 14 50
79392>>>>>>>            Set Location to 98 70
79393>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79393>>>>>>>            // we might as well prepare the object for it.
79393>>>>>>>            Set peAnchors to anBottomRight
79394>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
79395>>>>>>>        End_Object
79396>>>>>>>
79396>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
79397>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
79398>>>>>>>        Set LogoDF to "DF32.bmp"
79399>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
79399>>>>>>>    End_Procedure
79400>>>>>>>
79400>>>>>>>    Procedure Page Integer iPageObject
79402>>>>>>>        Handle hMenu
79402>>>>>>>        Integer iPrevState
79402>>>>>>>
79402>>>>>>>        Forward Send Page iPageObject
79404>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
79404>>>>>>>        Set Icon to "Default.ico"
79405>>>>>>>
79405>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
79405>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
79406>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79407>>>>>>>        // The "Move" menu command may come in handy to have.
79407>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79407>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79408>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79409>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79410>>>>>>>        // The "Close" menu command may be good to have.
79410>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79410>>>>>>>    End_Procedure
79411>>>>>>>
79411>>>>>>>    Procedure Set ProductName String sText
79413>>>>>>>        Set Value of oProductName to sText
79414>>>>>>>    End_Procedure
79415>>>>>>>
79415>>>>>>>    Procedure Set Copyright String sText
79417>>>>>>>        Set Value of oCopyright to sText
79418>>>>>>>    End_Procedure
79419>>>>>>>
79419>>>>>>>    Procedure Set Author String sText
79421>>>>>>>        Set Value of oAuthor to sText
79422>>>>>>>    End_Procedure
79423>>>>>>>
79423>>>>>>>    Procedure Set Version String sVersion
79425>>>>>>>        Handle hoVersionInfo
79425>>>>>>>        Boolean bIncluded
79425>>>>>>>        Integer iMajor iMinor iRelease iBuild
79425>>>>>>>//        Date dCompileDate
79425>>>>>>>        String sCertInfo sCompileDateAndTime
79425>>>>>>>
79425>>>>>>>        If (sVersion = "") Begin
79427>>>>>>>            // This automatically shows the program version of the program, if available.
79427>>>>>>>            // It will be displayed as the second item in the edit object.
79427>>>>>>>            If (ghoApplication <> 0) Begin
79429>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
79430>>>>>>>                If (hoVersionInfo <> 0) Begin
79432>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
79433>>>>>>>                    If (bIncluded) Begin
79435>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
79436>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
79437>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
79438>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
79439>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
79440>>>>>>>                    End
79440>>>>>>>>
79440>>>>>>>                End
79440>>>>>>>>
79440>>>>>>>            End
79440>>>>>>>>
79440>>>>>>>        End
79440>>>>>>>>
79440>>>>>>>
79440>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
79440>>>>>>>        Get psCompileDateAndTime of ghoApplication to sCompileDateAndTime
79441>>>>>>>        If (sCompileDateAndTime <> "") Begin
79443>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
79444>>>>>>>        End
79444>>>>>>>>
79444>>>>>>>//        Get GetCompileDate to dCompileDate
79444>>>>>>>//        If (sVersion <> "") Begin
79444>>>>>>>//            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
79444>>>>>>>//        End
79444>>>>>>>
79444>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
79445>>>>>>>        If (sCertInfo <> "-1") Begin
79447>>>>>>>            If (sCertInfo <> "") Begin
79449>>>>>>>                Send Add_LineLn sCertInfo
79450>>>>>>>            End
79450>>>>>>>>
79450>>>>>>>            Else Begin
79451>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
79452>>>>>>>            End
79452>>>>>>>>
79452>>>>>>>        End
79452>>>>>>>>
79452>>>>>>>    End_Procedure
79453>>>>>>>
79453>>>>>>>    Function IsDate String sDate Returns Boolean
79455>>>>>>>        Boolean bIsDate
79455>>>>>>>        String sGoodCharacters sChar
79455>>>>>>>        Integer iCount iLength
79455>>>>>>>
79455>>>>>>>        Move True to bIsDate
79456>>>>>>>        Move "0123456789-/" to sGoodCharacters
79457>>>>>>>        Move (Length(sDate)) to iLength
79458>>>>>>>        For iCount from 1 to iLength
79464>>>>>>>>
79464>>>>>>>            Move (Left(sDate, 1)) to sChar
79465>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
79466>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
79467>>>>>>>            If (bIsDate = False) Begin
79469>>>>>>>                Move iLength to iCount
79470>>>>>>>            End
79470>>>>>>>>
79470>>>>>>>        Loop
79471>>>>>>>>
79471>>>>>>>        Function_Return bIsDate
79472>>>>>>>    End_Function
79473>>>>>>>
79473>>>>>>>    Function GetCompileDate Returns Date
79475>>>>>>>        Date dCompileDate
79475>>>>>>>        String sAppFilename sProgram sData sCompileDate
79475>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
79475>>>>>>>        Boolean bIsValid   
79475>>>>>>>        
79475>>>>>>>        Move 0 to dCompileDate
79476>>>>>>>        // Get full path to the current running executable
79476>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
79477>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
79478>>>>>>>
79478>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
79478>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
79479>>>>>>>
79479>>>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
79481>>>>>>>        Move (Pos(sProgram, sData)) to iPos
79482>>>>>>>        If (iPos > 0) Begin
79484>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
79484>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
79485>>>>>>>
79485>>>>>>>            // If the current date format is non US, we need to temporary
79485>>>>>>>            // change the format and then move the string to the date variable.
79485>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
79488>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
79491>>>>>>>            Send Ignore_Error of Error_Object_Id 16 
79492>>>>>>>            If (Left(sCompileDate, 1) = "0") Begin
79494>>>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
79495>>>>>>>            End
79495>>>>>>>>
79495>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
79496>>>>>>>            Send Trap_Error of Error_Object_Id 16
79497>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79500>>>>>>>        End
79500>>>>>>>>
79500>>>>>>>        Else Begin
79501>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
79502>>>>>>>>
79502>>>>>>>        End
79502>>>>>>>>
79502>>>>>>>
79502>>>>>>>        Send Seq_Close_Channel iChannel
79503>>>>>>>
79503>>>>>>>        Function_Return dCompileDate
79504>>>>>>>    End_Function
79505>>>>>>>
79505>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
79505>>>>>>>    // (the passed program), has been finished
79505>>>>>>>    // The DOS box does also _not_ flash briefly.
79505>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
79507>>>>>>>        Handle hProcess
79507>>>>>>>        Integer iVoid
79507>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79507>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79507>>>>>>>
79507>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
79508>>>>>>>
79508>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
79509>>>>>>>        Move SW_SHOW                 to sInfo.nShow
79510>>>>>>>
79510>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
79511>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
79512>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
79512>>>>>>>        Move 0                       to sInfo.nShow
79513>>>>>>>
79513>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
79514>>>>>>>        Move sInfo.hProcess to hProcess
79515>>>>>>>        If (hProcess) Begin
79517>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
79518>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
79519>>>>>>>        End
79519>>>>>>>>
79519>>>>>>>    End_Procedure
79520>>>>>>>
79520>>>>>>>    Function AddFolderDelimiter String sPath Returns String
79522>>>>>>>        String sDirSep
79522>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79523>>>>>>>        Move (Trim(sPath)) to sPath
79524>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79526>>>>>>>            Move (sPath + sDirSep) to sPath
79527>>>>>>>        End
79527>>>>>>>>
79527>>>>>>>        Function_Return sPath
79528>>>>>>>    End_Function
79529>>>>>>>
79529>>>>>>>    // Returns an empty string if the current program is not digitally signed,
79529>>>>>>>    // or there is a problem with the certificate.
79529>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
79529>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
79529>>>>>>>    Function IsProgramDigitallySigned Returns String
79531>>>>>>>        Boolean bExists
79531>>>>>>>        String sPath sProgram sParams sRetval
79531>>>>>>>        Integer iCh
79531>>>>>>>
79531>>>>>>>        Move "" to sRetval
79532>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
79533>>>>>>>        Get AddFolderDelimiter sPath to sPath
79534>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
79535>>>>>>>        If (bExists = False) Begin
79537>>>>>>>            Function_Return "-1"
79538>>>>>>>        End
79538>>>>>>>>
79538>>>>>>>
79538>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
79539>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
79540>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
79541>>>>>>>        Move (sParams * String("| clip"))    to sParams
79542>>>>>>>        Get Seq_New_Channel to iCh
79543>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
79545>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
79548>>>>>>>        Close_Output channel iCh
79550>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
79550>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
79551>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
79553>>>>>>>            Readln channel iCh sRetval
79555>>>>>>>            Readln channel iCh sRetval
79557>>>>>>>            Readln channel iCh sRetval
79559>>>>>>>            Readln channel iCh sRetval
79561>>>>>>>        Close_Input channel iCh
79563>>>>>>>        Send Seq_Release_Channel iCh
79564>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
79566>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
79567>>>>>>>        End
79567>>>>>>>>
79567>>>>>>>        Else Begin
79568>>>>>>>            Move "" to sRetval
79569>>>>>>>        End
79569>>>>>>>>
79569>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
79569>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
79570>>>>>>>>
79570>>>>>>>        Function_Return sRetval
79571>>>>>>>    End_Function
79572>>>>>>>
79572>>>>>>>    Procedure Add_LineLn String sValue
79574>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
79575>>>>>>>    End_Procedure
79576>>>>>>>
79576>>>>>>>    Procedure Add_Line String sValue
79578>>>>>>>        Send Add_Line of oInfoList_Editor sValue
79579>>>>>>>    End_Procedure
79580>>>>>>>
79580>>>>>>>    Procedure Set Logo string sLogo
79582>>>>>>>        // Square bitmaps of 80x80 work best
79582>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
79583>>>>>>>    End_Procedure
79584>>>>>>>
79584>>>>>>>    Procedure Set LogoDF String sLogo
79586>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
79587>>>>>>>    End_Procedure
79588>>>>>>>
79588>>>>>>>    Procedure Show_Sysinfo
79590>>>>>>>        Send Popup_Modal of oSysinfoDialog
79591>>>>>>>    End_Procedure
79592>>>>>>>
79592>>>>>>>    Procedure Show_HomePage String sWebpage
79594>>>>>>>        Handle hWnd
79594>>>>>>>        Get Window_Handle to hWnd
79595>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
79596>>>>>>>    End_Procedure
79597>>>>>>>
79597>>>>>>>End_Class
79598>>>>>
79598>>>>>    Function piOrgErrorHandlerID Returns Integer
79600>>>>>    End_Function
79601>>>>>
79601>>>>>Class cBaseDbUpdateFuncLib is a cObject
79602>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
79603>>>>>>
79603>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
79605>>>>>>    Integer iStart iEnd
79605>>>>>>    String sRetval
79605>>>>>>
79605>>>>>>    Move (Trim(sConnect)) to sConnect
79606>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
79607>>>>>>    If (iStart = 0) Begin
79609>>>>>>        Function_Return ""
79610>>>>>>    End
79610>>>>>>>
79610>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
79611>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
79612>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
79614>>>>>>        Move (Pos(",", sRetval))          to iEnd
79615>>>>>>    End
79615>>>>>>>
79615>>>>>>    Else Begin
79616>>>>>>        Move (Pos(";", sRetval))          to iEnd
79617>>>>>>    End
79617>>>>>>>
79617>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
79619>>>>>>        Move (Pos(",", sRetval))          to iEnd
79620>>>>>>        Decrement iEnd
79621>>>>>>    End
79621>>>>>>>
79621>>>>>>    If (iEnd <> 0) Begin
79623>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
79624>>>>>>    End
79624>>>>>>>
79624>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
79625>>>>>>
79625>>>>>>    Function_Return (Trim(sRetval))
79626>>>>>>End_Function
79627>>>>>>
79627>>>>>>
79627>>>>>    
79627>>>>>    Procedure Construct_Object
79629>>>>>        Handle ho
79629>>>>>        Forward Send Construct_Object
79631>>>>>        Move Self to ghoDbUpdateFunctionLibrary
79632>>>>>        
79632>>>>>        Send CreateDbUpdateLibraryProperties
79633>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
79634>>>>>
79634>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
79634>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
79634>>>>>        // etc settings.
79634>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79636>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
79637>>>>>            Set phoSQLConnectionHandler to ho
79638>>>>>        End
79638>>>>>>
79638>>>>>
79638>>>>>    End_Procedure
79639>>>>>
79639>>>>>    Procedure End_Construct_Object
79641>>>>>        Forward Send End_Construct_Object
79643>>>>>
79643>>>>>    End_Procedure
79644>>>>>
79644>>>>>    // Latin1_General_CI_AS = General Insensitive collation
79644>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
79644>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
79644>>>>>    // Good read about which collation to select:
79644>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
79644>>>>>    Procedure Set psCollation String sCollation
79646>>>>>        Set private.psCollation to sCollation
79647>>>>>        If (ghoDbUpdateHandler > 0) Begin
79649>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
79650>>>>>        End
79650>>>>>>
79650>>>>>    End_Procedure
79651>>>>>
79651>>>>>    Function psCollation Returns String
79653>>>>>        String sCollation
79653>>>>>        If (ghoDbUpdateHandler > 0) Begin
79655>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
79656>>>>>        End   
79656>>>>>>
79656>>>>>        Else Begin
79657>>>>>            Get private.psCollation to sCollation
79658>>>>>        End
79658>>>>>>
79658>>>>>        Function_Return sCollation
79659>>>>>    End_Function
79660>>>>>
79660>>>>>    // Array sorting helper functions:
79660>>>>>    Function __UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
79662>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
79664>>>>>            Function_Return (EQ)
79665>>>>>        End
79665>>>>>>
79665>>>>>
79665>>>>>        Function_Return (GT)
79666>>>>>    End_Function
79667>>>>>
79667>>>>>    Function __SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
79669>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
79672>>>>>
79672>>>>>        Function_Return (GT)
79673>>>>>    End_Function
79674>>>>>
79674>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
79674>>>>>    // Note that it first removes any driver prefixes in the rootname.
79674>>>>>    Function _ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
79676>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
79676>>>>>        Handle hTable
79676>>>>>        Boolean bIsSame
79676>>>>>
79676>>>>>        Move APITableInfo.iTableNumber      to hTable
79677>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
79678>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
79681>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
79682>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
79685>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
79688>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
79689>>>>>
79689>>>>>        If (bCompareFilelistUppercase = True) Begin
79691>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
79692>>>>>        End
79692>>>>>>
79692>>>>>        Else Begin
79693>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
79694>>>>>        End
79694>>>>>>
79694>>>>>
79694>>>>>        Function_Return bIsSame
79695>>>>>    End_Function
79696>>>>>
79696>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
79698>>>>>        Integer iRetval
79698>>>>>        Move 1 to iRetval
79699>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
79701>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
79702>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
79703>>>>>        End
79703>>>>>>
79703>>>>>        Function_Return (iRetval = 0)
79704>>>>>    End_Function
79705>>>>>
79705>>>>>    Function _AddFolderDelimiter String sPath Returns String
79707>>>>>        String sDirSep
79707>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79708>>>>>        Move (Trim(sPath)) to sPath
79709>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79711>>>>>            Move (sPath + sDirSep) to sPath
79712>>>>>        End
79712>>>>>>
79712>>>>>        Function_Return sPath
79713>>>>>    End_Function
79714>>>>>
79714>>>>>    Procedure _SqlColumnInfo Handle hoStmt
79716>>>>>        Integer i iCols iItem
79716>>>>>        tSqlColumnNew[] aQueryColumns
79716>>>>>        tSqlColumnNew[] aQueryColumns
79717>>>>>
79717>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
79718>>>>>        For i from 1 to iCols
79724>>>>>>
79724>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
79725>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
79726>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
79727>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
79728>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
79729>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
79730>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
79731>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
79732>>>>>        Loop
79733>>>>>>
79733>>>>>        Set piColumns to iCols
79734>>>>>        Set paQueryColumns to aQueryColumns
79735>>>>>    End_Procedure
79736>>>>>
79736>>>>>    // *** Property Messages ***
79736>>>>>    //
79736>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
79736>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
79736>>>>>    //
79736>>>>>    Function pSQLConnection Returns tSQLConnection
79738>>>>>        tSQLConnection SQLConnection
79738>>>>>        tSQLConnection SQLConnection
79738>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79740>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
79740>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79741>>>>>>
79741>>>>>            Function_Return
79742>>>>>        End
79742>>>>>>
79742>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
79743>>>>>        Function_Return SQLConnection
79744>>>>>    End_Function
79745>>>>>
79745>>>>>    // * Dummy function for the Studio's Code Explorer *
79745>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
79747>>>>>        Function_Return False
79748>>>>>    End_Function
79749>>>>>
79749>>>>>    Procedure Set psServer String sValue
79751>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79753>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
79753>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79754>>>>>>
79754>>>>>            Procedure_Return
79755>>>>>        End
79755>>>>>>
79755>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
79756>>>>>    End_Procedure
79757>>>>>
79757>>>>>    Function psServer Returns String
79759>>>>>        String sValue
79759>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79761>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79762>>>>>>
79762>>>>>            Function_Return
79763>>>>>        End
79763>>>>>>
79763>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
79764>>>>>        Function_Return sValue
79765>>>>>    End_Function
79766>>>>>
79766>>>>>    Procedure Set psDatabase String sValue
79768>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79770>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79771>>>>>>
79771>>>>>            Procedure_Return
79772>>>>>        End
79772>>>>>>
79772>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
79773>>>>>    End_Procedure
79774>>>>>
79774>>>>>    Function psDatabase Returns String
79776>>>>>        String sValue
79776>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79778>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79779>>>>>>
79779>>>>>            Function_Return
79780>>>>>        End
79780>>>>>>
79780>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
79781>>>>>        Function_Return sValue
79782>>>>>    End_Function
79783>>>>>
79783>>>>>    Procedure Set psUserID String sValue
79785>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79787>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79788>>>>>>
79788>>>>>            Procedure_Return
79789>>>>>        End
79789>>>>>>
79789>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
79790>>>>>    End_Procedure
79791>>>>>
79791>>>>>    Function psUserID Returns String
79793>>>>>        String sValue
79793>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79795>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79796>>>>>>
79796>>>>>            Function_Return
79797>>>>>        End
79797>>>>>>
79797>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
79798>>>>>        Function_Return sValue
79799>>>>>    End_Function
79800>>>>>
79800>>>>>    Procedure Set psPassword String sValue
79802>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79804>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79805>>>>>>
79805>>>>>            Procedure_Return
79806>>>>>        End
79806>>>>>>
79806>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
79807>>>>>    End_Procedure
79808>>>>>
79808>>>>>    Function psPassword Returns String
79810>>>>>        String sValue
79810>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79812>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79813>>>>>>
79813>>>>>            Function_Return
79814>>>>>        End
79814>>>>>>
79814>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
79815>>>>>        Function_Return sValue
79816>>>>>    End_Function
79817>>>>>
79817>>>>>    Procedure Set pbTrusted Boolean bValue
79819>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79821>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79822>>>>>>
79822>>>>>            Procedure_Return
79823>>>>>        End
79823>>>>>>
79823>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
79824>>>>>    End_Procedure
79825>>>>>
79825>>>>>    Function pbTrusted Returns Boolean
79827>>>>>        Boolean bValue
79827>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79829>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79830>>>>>>
79830>>>>>            Function_Return
79831>>>>>        End
79831>>>>>>
79831>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
79832>>>>>        Function_Return bValue
79833>>>>>    End_Function
79834>>>>>
79834>>>>>    Procedure Set pbSilentLogin Boolean bValue
79836>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79838>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79839>>>>>>
79839>>>>>            Procedure_Return
79840>>>>>        End
79840>>>>>>
79840>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
79841>>>>>    End_Procedure
79842>>>>>
79842>>>>>    Function pbSilentLogin Returns Boolean
79844>>>>>        Boolean bValue
79844>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79846>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79847>>>>>>
79847>>>>>            Function_Return
79848>>>>>        End
79848>>>>>>
79848>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
79849>>>>>        Function_Return bValue
79850>>>>>    End_Function
79851>>>>>
79851>>>>>    Procedure Set psConnectionID String sValue
79853>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79855>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79856>>>>>>
79856>>>>>            Procedure_Return
79857>>>>>        End
79857>>>>>>
79857>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
79858>>>>>    End_Procedure
79859>>>>>
79859>>>>>    Function psConnectionID Returns String
79861>>>>>        String sValue
79861>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79863>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79864>>>>>>
79864>>>>>            Function_Return
79865>>>>>        End
79865>>>>>>
79865>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
79866>>>>>        Function_Return sValue
79867>>>>>    End_Function
79868>>>>>
79868>>>>>    Procedure Set psConnectionString String sValue
79870>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79872>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79873>>>>>>
79873>>>>>            Procedure_Return
79874>>>>>        End
79874>>>>>>
79874>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
79875>>>>>    End_Procedure
79876>>>>>
79876>>>>>    Function psConnectionString Returns String
79878>>>>>        String sValue
79878>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79880>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79881>>>>>>
79881>>>>>            Function_Return
79882>>>>>        End
79882>>>>>>
79882>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
79883>>>>>        Function_Return sValue
79884>>>>>    End_Function
79885>>>>>
79885>>>>>    // The normal connection string looks something like this;
79885>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
79885>>>>>    // ...and the full connection string looks like this;
79885>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
79885>>>>>    Function psFullConnectionString Returns String
79887>>>>>        String sConnectionID sConnectionString
79887>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79889>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79890>>>>>>
79890>>>>>            Function_Return
79891>>>>>        End
79891>>>>>>
79891>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
79892>>>>>        Move (Trim(sConnectionID)) to sConnectionID
79893>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
79894>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
79895>>>>>    End_Function
79896>>>>>
79896>>>>>    Function piConnectionOptions Returns Integer
79898>>>>>        Integer iValue
79898>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79900>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79901>>>>>>
79901>>>>>            Function_Return
79902>>>>>        End
79902>>>>>>
79902>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
79903>>>>>        Function_Return iValue
79904>>>>>    End_Function
79905>>>>>
79905>>>>>    Procedure Set psSchema String sValue
79907>>>>>        tSQLConnection SQLConnection
79907>>>>>        tSQLConnection SQLConnection
79907>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79909>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79910>>>>>>
79910>>>>>            Procedure_Return
79911>>>>>        End
79911>>>>>>
79911>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
79912>>>>>    End_Procedure
79913>>>>>
79913>>>>>    Function psSchema Returns String
79915>>>>>        String sRetval
79915>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79917>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79918>>>>>>
79918>>>>>            Function_Return
79919>>>>>        End
79919>>>>>>
79919>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
79920>>>>>        Function_Return sRetval
79921>>>>>    End_Function
79922>>>>>
79922>>>>>    Procedure Set psBaseTableSpace String sValue
79924>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79926>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79927>>>>>>
79927>>>>>            Procedure_Return
79928>>>>>        End
79928>>>>>>
79928>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
79929>>>>>    End_Procedure
79930>>>>>
79930>>>>>    Function psBaseTableSpace Returns String
79932>>>>>        String sRetval
79932>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79934>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79935>>>>>>
79935>>>>>            Function_Return
79936>>>>>        End
79936>>>>>>
79936>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
79937>>>>>        Function_Return sRetval
79938>>>>>    End_Function
79939>>>>>
79939>>>>>    Procedure Set psLongTableSpace String sValue
79941>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79943>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79944>>>>>>
79944>>>>>            Procedure_Return
79945>>>>>        End
79945>>>>>>
79945>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
79946>>>>>    End_Procedure
79947>>>>>
79947>>>>>    Function psLongTableSpace Returns String
79949>>>>>        String sRetval
79949>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79951>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79952>>>>>>
79952>>>>>            Function_Return
79953>>>>>        End
79953>>>>>>
79953>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
79954>>>>>        Function_Return sRetval
79955>>>>>    End_Function
79956>>>>>
79956>>>>>    Procedure Set psIndexTableSpace String sValue
79958>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79960>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79961>>>>>>
79961>>>>>            Procedure_Return
79962>>>>>        End
79962>>>>>>
79962>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
79963>>>>>    End_Procedure
79964>>>>>
79964>>>>>    Function psIndexTableSpace Returns String
79966>>>>>        String sRetval
79966>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79968>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79969>>>>>>
79969>>>>>            Function_Return
79970>>>>>        End
79970>>>>>>
79970>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
79971>>>>>        Function_Return sRetval
79972>>>>>    End_Function
79973>>>>>
79973>>>>>    Procedure Set pbUseConnectionID Boolean bState
79975>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79977>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79978>>>>>>
79978>>>>>            Procedure_Return
79979>>>>>        End
79979>>>>>>
79979>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
79980>>>>>    End_Procedure
79981>>>>>
79981>>>>>    Function pbUseConnectionID Returns Boolean
79983>>>>>        Boolean bState
79983>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79985>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79986>>>>>>
79986>>>>>            Function_Return
79987>>>>>        End
79987>>>>>>
79987>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
79988>>>>>        Function_Return bState
79989>>>>>    End_Function
79990>>>>>
79990>>>>>    Procedure Set pbToANSI Boolean bState
79992>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79994>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79995>>>>>>
79995>>>>>            Procedure_Return
79996>>>>>        End
79996>>>>>>
79996>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
79997>>>>>    End_Procedure
79998>>>>>
79998>>>>>    Function pbToANSI Returns Boolean
80000>>>>>        Boolean bState
80000>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80002>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80003>>>>>>
80003>>>>>            Function_Return
80004>>>>>        End
80004>>>>>>
80004>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
80005>>>>>        Function_Return bState
80006>>>>>    End_Function
80007>>>>>
80007>>>>>    Procedure Set pbRecnum Boolean bState
80009>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80011>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80012>>>>>>
80012>>>>>            Procedure_Return
80013>>>>>        End
80013>>>>>>
80013>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
80014>>>>>    End_Procedure
80015>>>>>
80015>>>>>    Function pbRecnum Returns Boolean
80017>>>>>        Boolean bState
80017>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80019>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80020>>>>>>
80020>>>>>            Function_Return
80021>>>>>        End
80021>>>>>>
80021>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
80022>>>>>        Function_Return bState
80023>>>>>    End_Function
80024>>>>>
80024>>>>>    Procedure Set pbCopyData Boolean bState
80026>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80028>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80029>>>>>>
80029>>>>>            Procedure_Return
80030>>>>>        End
80030>>>>>>
80030>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
80031>>>>>    End_Procedure
80032>>>>>
80032>>>>>    Function pbCopyData Returns Boolean
80034>>>>>        Boolean bState
80034>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80036>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80037>>>>>>
80037>>>>>            Function_Return
80038>>>>>        End
80038>>>>>>
80038>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
80039>>>>>        Function_Return bState
80040>>>>>    End_Function
80041>>>>>
80041>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
80043>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80045>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80046>>>>>>
80046>>>>>            Procedure_Return
80047>>>>>        End
80047>>>>>>
80047>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80048>>>>>    End_Procedure
80049>>>>>
80049>>>>>    Function pbApiTableUpdateAuto Returns Boolean
80051>>>>>        Boolean bState
80051>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80053>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80054>>>>>>
80054>>>>>            Function_Return
80055>>>>>        End
80055>>>>>>
80055>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80056>>>>>        Function_Return bState
80057>>>>>    End_Function
80058>>>>>
80058>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
80060>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80062>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80063>>>>>>
80063>>>>>            Procedure_Return
80064>>>>>        End
80064>>>>>>
80064>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80065>>>>>    End_Procedure
80066>>>>>
80066>>>>>    Function pbCompareDate_DateTime Returns Boolean
80068>>>>>        Boolean bState
80068>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80070>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80071>>>>>>
80071>>>>>            Function_Return
80072>>>>>        End
80072>>>>>>
80072>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80073>>>>>        Function_Return bState
80074>>>>>    End_Function
80075>>>>>
80075>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
80077>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80079>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80080>>>>>>
80080>>>>>            Procedure_Return
80081>>>>>        End
80081>>>>>>
80081>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80082>>>>>    End_Procedure
80083>>>>>
80083>>>>>    Function pbCompareIndexAscending Returns Boolean
80085>>>>>        Boolean bState
80085>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80087>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80088>>>>>>
80088>>>>>            Function_Return
80089>>>>>        End
80089>>>>>>
80089>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80090>>>>>        Function_Return bState
80091>>>>>    End_Function
80092>>>>>
80092>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
80094>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80096>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80097>>>>>>
80097>>>>>            Procedure_Return
80098>>>>>        End
80098>>>>>>
80098>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80099>>>>>    End_Procedure
80100>>>>>
80100>>>>>    Function pbCompareIndexUppercase Returns Boolean
80102>>>>>        Boolean bState
80102>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80104>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80105>>>>>>
80105>>>>>            Function_Return
80106>>>>>        End
80106>>>>>>
80106>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80107>>>>>        Function_Return bState
80108>>>>>    End_Function
80109>>>>>
80109>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
80111>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80113>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80114>>>>>>
80114>>>>>            Procedure_Return
80115>>>>>        End
80115>>>>>>
80115>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
80116>>>>>    End_Procedure
80117>>>>>
80117>>>>>    Function psDriverDefaultValueASCII Returns String
80119>>>>>        String sRetval
80119>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80121>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80122>>>>>>
80122>>>>>            Function_Return
80123>>>>>        End
80123>>>>>>
80123>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
80124>>>>>        Function_Return sRetval
80125>>>>>    End_Function
80126>>>>>
80126>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
80128>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80130>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80131>>>>>>
80131>>>>>            Procedure_Return
80132>>>>>        End
80132>>>>>>
80132>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
80133>>>>>    End_Procedure
80134>>>>>
80134>>>>>    Function psDriverDefaultValueBinary Returns String
80136>>>>>        String sRetval
80136>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80138>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80139>>>>>>
80139>>>>>            Function_Return
80140>>>>>        End
80140>>>>>>
80140>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
80141>>>>>        Function_Return sRetval
80142>>>>>    End_Function
80143>>>>>
80143>>>>>    Procedure Set psDriverDefaultValueDate String sValue
80145>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80147>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80148>>>>>>
80148>>>>>            Procedure_Return
80149>>>>>        End
80149>>>>>>
80149>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
80150>>>>>    End_Procedure
80151>>>>>
80151>>>>>    Function psDriverDefaultValueDate Returns String
80153>>>>>        String sRetval
80153>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80155>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80156>>>>>>
80156>>>>>            Function_Return
80157>>>>>        End
80157>>>>>>
80157>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
80158>>>>>        Function_Return sRetval
80159>>>>>    End_Function
80160>>>>>
80160>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
80162>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80164>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80165>>>>>>
80165>>>>>            Procedure_Return
80166>>>>>        End
80166>>>>>>
80166>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
80167>>>>>    End_Procedure
80168>>>>>
80168>>>>>    Function psDriverDefaultValueDateTime Returns String
80170>>>>>        String sRetval
80170>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80172>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80173>>>>>>
80173>>>>>            Function_Return
80174>>>>>        End
80174>>>>>>
80174>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
80175>>>>>        Function_Return sRetval
80176>>>>>    End_Function
80177>>>>>
80177>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
80179>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80181>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80182>>>>>>
80182>>>>>            Procedure_Return
80183>>>>>        End
80183>>>>>>
80183>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
80184>>>>>    End_Procedure
80185>>>>>
80185>>>>>    Function psDriverDefaultValueNumeric Returns String
80187>>>>>        String sRetval
80187>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80189>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80190>>>>>>
80190>>>>>            Function_Return
80191>>>>>        End
80191>>>>>>
80191>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
80192>>>>>        Function_Return sRetval
80193>>>>>    End_Function
80194>>>>>
80194>>>>>    Procedure Set psDriverDefaultValueText String sValue
80196>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80198>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80199>>>>>>
80199>>>>>            Procedure_Return
80200>>>>>        End
80200>>>>>>
80200>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
80201>>>>>    End_Procedure
80202>>>>>
80202>>>>>    Function psDriverDefaultValueText Returns String
80204>>>>>        String sRetval
80204>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80206>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80207>>>>>>
80207>>>>>            Function_Return
80208>>>>>        End
80208>>>>>>
80208>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
80209>>>>>        Function_Return sRetval
80210>>>>>    End_Function
80211>>>>>
80211>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
80213>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80215>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80216>>>>>>
80216>>>>>            Procedure_Return
80217>>>>>        End
80217>>>>>>
80217>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80218>>>>>    End_Procedure
80219>>>>>
80219>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
80221>>>>>        Boolean bState
80221>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80223>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80224>>>>>>
80224>>>>>            Function_Return
80225>>>>>        End
80225>>>>>>
80225>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80226>>>>>        Function_Return bState
80227>>>>>    End_Function
80228>>>>>
80228>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
80230>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80232>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80233>>>>>>
80233>>>>>            Procedure_Return
80234>>>>>        End
80234>>>>>>
80234>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80235>>>>>    End_Procedure
80236>>>>>
80236>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
80238>>>>>        Boolean bState
80238>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80240>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80241>>>>>>
80241>>>>>            Function_Return
80242>>>>>        End
80242>>>>>>
80242>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80243>>>>>        Function_Return bState
80244>>>>>    End_Function
80245>>>>>
80245>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
80247>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80249>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80250>>>>>>
80250>>>>>            Procedure_Return
80251>>>>>        End
80251>>>>>>
80251>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80252>>>>>    End_Procedure
80253>>>>>
80253>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
80255>>>>>        Boolean bState
80255>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80257>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80258>>>>>>
80258>>>>>            Function_Return
80259>>>>>        End
80259>>>>>>
80259>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80260>>>>>        Function_Return bState
80261>>>>>    End_Function
80262>>>>>
80262>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
80264>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80266>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80267>>>>>>
80267>>>>>            Procedure_Return
80268>>>>>        End
80268>>>>>>
80268>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80269>>>>>    End_Procedure
80270>>>>>
80270>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
80272>>>>>        Boolean bState
80272>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80274>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80275>>>>>>
80275>>>>>            Function_Return
80276>>>>>        End
80276>>>>>>
80276>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80277>>>>>        Function_Return bState
80278>>>>>    End_Function
80279>>>>>
80279>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
80281>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80283>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80284>>>>>>
80284>>>>>            Procedure_Return
80285>>>>>        End
80285>>>>>>
80285>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80286>>>>>    End_Procedure
80287>>>>>
80287>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
80289>>>>>        Boolean bState
80289>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80291>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80292>>>>>>
80292>>>>>            Function_Return
80293>>>>>        End
80293>>>>>>
80293>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80294>>>>>        Function_Return bState
80295>>>>>    End_Function
80296>>>>>
80296>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
80298>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80300>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80301>>>>>>
80301>>>>>            Procedure_Return
80302>>>>>        End
80302>>>>>>
80302>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80303>>>>>    End_Procedure
80304>>>>>
80304>>>>>    Function pbDriverDefaultNullableText Returns Boolean
80306>>>>>        Boolean bState
80306>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80308>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80309>>>>>>
80309>>>>>            Function_Return
80310>>>>>        End
80310>>>>>>
80310>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80311>>>>>        Function_Return bState
80312>>>>>    End_Function
80313>>>>>
80313>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
80313>>>>>    //       the psDriverID *must* be the first property that gets changed!
80313>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
80313>>>>>    //       for a connection string has the wrong format for that driver.
80313>>>>>    Procedure Set psDriverID String sValue
80315>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80316>>>>>        Delegate Set psDriverID to sValue
80318>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80319>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
80320>>>>>    End_Procedure
80321>>>>>
80321>>>>>    Function psDriverID Returns String
80323>>>>>        String sDriverID
80323>>>>>
80323>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80324>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
80324>>>>>        Delegate Get psDriverID to sDriverID
80326>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80327>>>>>        Move False to Err
80328>>>>>
80328>>>>>        // ...and in case it didn't use property of this class. Then the library is
80328>>>>>        // probably used as "utilites" from a special made program and
80328>>>>>        // the ghoSQLConnectionHandler must have been setup
80328>>>>>        If (sDriverID = "") Begin
80330>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
80331>>>>>        End
80331>>>>>>
80331>>>>>        Function_Return sDriverID
80332>>>>>    End_Function
80333>>>>>
80333>>>>>    Procedure Set piDbType Integer iValue
80335>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80336>>>>>        Delegate Set piDbType to iValue
80338>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80339>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
80340>>>>>    End_Procedure
80341>>>>>
80341>>>>>    Function piDbType Returns Integer
80343>>>>>        Integer iRetval
80343>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
80344>>>>>        Function_Return iRetval
80345>>>>>    End_Function
80346>>>>>
80346>>>>>    // Returns the index for the passed sTableName
80346>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
80346>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
80348>>>>>        Integer iIndex iSize iCount
80348>>>>>        String[] sTablesArray
80349>>>>>        String sDatabase sSchema sVal sConnectionString
80349>>>>>
80349>>>>>        Move -1 to iIndex
80350>>>>>        Get psConnectionString to sConnectionString
80351>>>>>        Get psDatabase to sDatabase
80352>>>>>        Get psSchema   to sSchema
80353>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
80354>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
80355>>>>>        Decrement iSize
80356>>>>>        For iCount from 0 to iSize
80362>>>>>>
80362>>>>>            Move sTablesArray[iCount] to sVal
80363>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
80365>>>>>                Move iCount to iIndex // We found it!
80366>>>>>                Move iSize to iCount  // End the loop
80367>>>>>            End
80367>>>>>>
80367>>>>>        Loop
80368>>>>>>
80368>>>>>
80368>>>>>        Function_Return iIndex
80369>>>>>    End_Function
80370>>>>>
80370>>>>>    // Returns all schemas as a string array for the passed driver id.
80370>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
80372>>>>>        String[] sReturnArray
80373>>>>>        Boolean bOK
80373>>>>>
80373>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80374>>>>>        If (bOK = False) Begin
80376>>>>>            Function_Return sReturnArray
80377>>>>>        End
80377>>>>>>
80377>>>>>
80377>>>>>        Case Begin
80377>>>>>            Case (sDriverID = DB2_DRV_ID)
80379>>>>>                Get _SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
80380>>>>>                Case Break
80381>>>>>
80381>>>>>            Case Else
80381>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
80382>>>>>>
80382>>>>>                Case Break
80383>>>>>        Case End
80383>>>>>
80383>>>>>        Function_Return sReturnArray
80384>>>>>    End_Function
80385>>>>>
80385>>>>>    // Returns a string array with all tables for the current database.
80385>>>>>    Function _SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
80387>>>>>        String[] sReturnArray sArray
80389>>>>>        String sConnectionString sSelect
80389>>>>>        Integer iSize iCount iDbType
80389>>>>>        Boolean bOK
80389>>>>>
80389>>>>>        If (sDriverID = DATAFLEX_ID) Begin
80391>>>>>            Function_Return sArray
80392>>>>>        End
80392>>>>>>
80392>>>>>
80392>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80393>>>>>        If (bOK = False) Begin
80395>>>>>            Function_Return sReturnArray
80396>>>>>        End
80396>>>>>>
80396>>>>>        If (sSchema = "") Begin
80398>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
80399>>>>>        End
80399>>>>>>
80399>>>>>
80399>>>>>        Get psConnectionString to sConnectionString
80400>>>>>
80400>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80400>>>>>        // the dbType.
80400>>>>>        Get piDbType to iDbType
80401>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
80403>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
80405>>>>>                Move MSSQLDRV_ID to sDriverID
80406>>>>>            End
80406>>>>>>
80406>>>>>            If (iDbType = EN_DbTypeDB2) Begin
80408>>>>>                Move DB2_DRV_ID to sDriverID
80409>>>>>            End
80409>>>>>>
80409>>>>>            If (iDbType = EN_DbTypePostgre) Begin
80411>>>>>                Move ODBC_DRV_ID to sDriverID
80412>>>>>            End
80412>>>>>>
80412>>>>>        End
80412>>>>>>
80412>>>>>
80412>>>>>        Case Begin
80412>>>>>            Case (sDriverID = MSSQLDRV_ID)
80414>>>>>                Get _SqlTableArrayDAW to sReturnArray
80415>>>>>                Case Break
80416>>>>>
80416>>>>>            Case (sDriverID = DB2_DRV_ID)
80419>>>>>                Get _SqlTableArrayDAW to sReturnArray
80420>>>>>                Case Break
80421>>>>>
80421>>>>>            Case (sDriverID = ODBC_DRV_ID)
80424>>>>>                Get _SqlTableArrayDAW to sReturnArray
80425>>>>>                Case Break
80426>>>>>
80426>>>>>            Case Else
80426>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTables function."
80427>>>>>>
80427>>>>>                Case Break
80428>>>>>        Case End
80428>>>>>
80428>>>>>        Function_Return sReturnArray
80429>>>>>    End_Function
80430>>>>>
80430>>>>>    // Returns all table spaces as a string array for the passed driver id.
80430>>>>>    Function _SqlUtilEnumerateTablespaces String sDriverID Returns String[]
80432>>>>>        String[] sReturnArray
80433>>>>>        Boolean bOK
80433>>>>>
80433>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80434>>>>>        If (bOK = False) Begin
80436>>>>>            Function_Return sReturnArray
80437>>>>>        End
80437>>>>>>
80437>>>>>
80437>>>>>        Case Begin
80437>>>>>            Case (sDriverID = DB2_DRV_ID)
80439>>>>>                Get _SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
80440>>>>>                Case Break
80441>>>>>
80441>>>>>            Case Else
80441>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTablespaces function."
80442>>>>>>
80442>>>>>                Case Break
80443>>>>>        Case End
80443>>>>>
80443>>>>>        Function_Return sReturnArray
80444>>>>>    End_Function
80445>>>>>
80445>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
80445>>>>>    Function _SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
80447>>>>>        String[] sReturnArray
80448>>>>>        String sConnectionString sSelect sSchema
80448>>>>>        Boolean bOK
80448>>>>>        Integer iDbType
80448>>>>>
80448>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80449>>>>>        If (bOK = False) Begin
80451>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80452>>>>>>
80452>>>>>            Function_Return sReturnArray
80453>>>>>        End
80453>>>>>>
80453>>>>>
80453>>>>>        Get psConnectionString to sConnectionString
80454>>>>>        Get psSchema to sSchema
80455>>>>>
80455>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80455>>>>>        // the dbType.
80455>>>>>        Get piDbType to iDbType
80456>>>>>
80456>>>>>        Case Begin
80456>>>>>            Case (sDriverID = ODBC_DRV_ID)
80458>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
80460>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
80461>>>>>                End
80461>>>>>>
80461>>>>>                If (iDbType = EN_DbTypePostgre) Begin
80463>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
80464>>>>>                End
80464>>>>>>
80464>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
80466>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80467>>>>>                End
80467>>>>>>
80467>>>>>
80467>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80468>>>>>                Case Break
80469>>>>>
80469>>>>>            Case (sDriverID = MSSQLDRV_ID)
80472>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80473>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80474>>>>>                Case Break
80475>>>>>
80475>>>>>            Case (sDriverID = DB2_DRV_ID)
80478>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
80479>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80480>>>>>                Case Break
80481>>>>>
80481>>>>>            Case Else
80481>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateColumns function."
80482>>>>>>
80482>>>>>                Case Break
80483>>>>>        Case End
80483>>>>>
80483>>>>>        Function_Return sReturnArray
80484>>>>>    End_Function
80485>>>>>
80485>>>>>
80485>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
80485>>>>>    Function _SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
80487>>>>>        String[] sReturnArray sReturnArray2
80489>>>>>        String sConnectionString sSelect sSchema
80489>>>>>        Boolean bOK
80489>>>>>        Integer iCount iSize
80489>>>>>
80489>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80490>>>>>        If (bOK = False) Begin
80492>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80493>>>>>>
80493>>>>>            Function_Return sReturnArray
80494>>>>>        End
80494>>>>>>
80494>>>>>
80494>>>>>        Get psConnectionString to sConnectionString
80495>>>>>        Get psSchema to sSchema
80496>>>>>
80496>>>>>        Case Begin
80496>>>>>            Case (sDriverID = MSSQLDRV_ID)
80498>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
80499>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80500>>>>>                Case Break
80501>>>>>
80501>>>>>            Case (sDriverID = DB2_DRV_ID)
80504>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80505>>>>>>
80505>>>>>//                Move () to sSelect
80505>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80505>>>>>                Case Break
80506>>>>>
80506>>>>>            Case Else
80506>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateIndexes function."
80507>>>>>>
80507>>>>>                Case Break
80508>>>>>        Case End
80508>>>>>
80508>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
80509>>>>>        Decrement iSize
80510>>>>>        For iCount from 0 to iSize
80516>>>>>>
80516>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
80518>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
80519>>>>>            End
80519>>>>>>
80519>>>>>        Loop
80520>>>>>>
80520>>>>>
80520>>>>>        Function_Return sReturnArray2
80521>>>>>    End_Function
80522>>>>>
80522>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
80522>>>>>    // The format of the array is "TableName.FieldName"
80522>>>>>    Function _SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
80524>>>>>        String[] sFileNameArray sFieldNameArray
80526>>>>>        tSQLRelation[] sRelationsArray
80526>>>>>        tSQLRelation[] sRelationsArray
80527>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
80527>>>>>        Boolean bOK
80527>>>>>        Integer iCount iSize iLength
80527>>>>>
80527>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80528>>>>>        If (bOK = False) Begin
80530>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80531>>>>>>
80531>>>>>            Function_Return sRelationsArray
80532>>>>>        End
80532>>>>>>
80532>>>>>
80532>>>>>        Get psConnectionString to sConnectionString
80533>>>>>        Get psSchema to sSchema
80534>>>>>
80534>>>>>        Case Begin
80534>>>>>            Case (sDriverID = MSSQLDRV_ID)
80536>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
80537>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
80538>>>>>                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80539>>>>>                Case Break
80540>>>>>
80540>>>>>            Case (sDriverID = DB2_DRV_ID)
80543>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80544>>>>>>
80544>>>>>//                Move () to sSelect
80544>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80544>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80544>>>>>                Case Break
80545>>>>>
80545>>>>>            Case Else
80545>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the _SqlUtilEnumerateRelations function."
80546>>>>>>
80546>>>>>                Case Break
80547>>>>>        Case End
80547>>>>>
80547>>>>>        Move (Length(sTableName)) to iLength
80548>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
80549>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
80550>>>>>        Decrement iSize
80551>>>>>        For iCount from 0 to iSize
80557>>>>>>
80557>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
80559>>>>>                Move sFileNameArray[iCount]         to sFileName
80560>>>>>                Move sFieldNameArray[iCount]        to sFieldName
80561>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
80562>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
80563>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
80564>>>>>            End
80564>>>>>>
80564>>>>>        Loop
80565>>>>>>
80565>>>>>
80565>>>>>        Function_Return sRelationsArray
80566>>>>>    End_Function
80567>>>>>
80567>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
80569>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80569>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80570>>>>>        String[] sUsers sPrograms
80572>>>>>        String sSelect
80572>>>>>        Integer iSize iCount
80572>>>>>
80572>>>>>        Case Begin
80572>>>>>            Case (sDriverID = MSSQLDRV_ID)
80574>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
80575>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sUsers
80576>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sPrograms
80577>>>>>                Case Break
80578>>>>>            Case Else
80578>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
80579>>>>>>
80579>>>>>        Case End
80579>>>>>
80579>>>>>        Move (SizeOfArray(sUsers)) to iSize
80580>>>>>        Decrement iSize
80581>>>>>        For iCount from 0 to iSize
80587>>>>>>
80587>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
80588>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
80589>>>>>        Loop
80590>>>>>>
80590>>>>>
80590>>>>>        Function_Return SQLLoggedInUser
80591>>>>>    End_Function
80592>>>>>
80592>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
80592>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
80592>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
80594>>>>>        String[] sFilesData
80595>>>>>        Boolean bExists
80595>>>>>        Integer iCh
80595>>>>>        String sFileName sExt
80595>>>>>
80595>>>>>        Get vFolderExists sDataPath to bExists
80596>>>>>        If (bExists = True) Begin
80598>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
80599>>>>>            Move ("dir:" + sDataPath)      to sDataPath
80600>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
80601>>>>>            Direct_Input channel iCh sDataPath
80603>>>>>                Repeat
80603>>>>>>
80603>>>>>                    Readln channel iCh sFileName
80605>>>>>                    Get ParseFileExtension sFileName to sExt
80606>>>>>                    If (Uppercase(sExt) = "INT") Begin
80608>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
80610>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
80611>>>>>                        End
80611>>>>>>
80611>>>>>                    End
80611>>>>>>
80611>>>>>                Until (SeqEof = True)
80613>>>>>            Close_Input channel iCh
80615>>>>>            Send Seq_Release_Channel iCh
80616>>>>>        End
80616>>>>>>
80616>>>>>        Function_Return sFilesData
80617>>>>>    End_Function
80618>>>>>
80618>>>>>    // Only done for MSSQLDRV_ID so far...
80618>>>>>    Function _SqlEnumerateDatabaseCollations String sDriverID Returns String[]
80620>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
80620>>>>>        String sDescription sFrom sSys sValue sPrevious
80620>>>>>        Handle hStmt hoSQLManager hoSQLConnect
80620>>>>>        Integer iFetchResult iRows iColumn iPos
80620>>>>>        tSQLConnection SQLConnection
80620>>>>>        tSQLConnection SQLConnection
80620>>>>>        String[] asCollations
80621>>>>>        
80621>>>>>        If (sDriverID = "") Begin
80623>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
80624>>>>>>
80624>>>>>            Function_Return asCollations
80625>>>>>        End
80625>>>>>>
80625>>>>>
80625>>>>>        // Only done for MSSQLDRV_ID so far...
80625>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
80627>>>>>            Function_Return asCollations
80628>>>>>        End                 
80628>>>>>>
80628>>>>>
80628>>>>>        Get phoSQLManager to hoSQLManager
80629>>>>>        Get psConnectionID     to sConnectionID
80630>>>>>        Get psConnectionString to sConnectionString
80631>>>>>        Move 0 to LastErr
80632>>>>>
80632>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80633>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
80634>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80635>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
80637>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
80638>>>>>>
80638>>>>>            Function_Return asCollations
80639>>>>>        End
80639>>>>>>
80639>>>>>
80639>>>>>        Get SqlOpen of hoSQLConnect to hStmt
80640>>>>>
80640>>>>>        If (hStmt = 0) Begin
80642>>>>>            Send SqlDisconnect of hoSQLManager
80643>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
80644>>>>>>
80644>>>>>            Function_Return asCollations
80645>>>>>        End
80645>>>>>>
80645>>>>>
80645>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
80646>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
80647>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
80648>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
80649>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
80650>>>>>
80650>>>>>        // MS-SQL Syntax:  
80650>>>>>        // SELECT name, description
80650>>>>>        //   from sys.fn_helpcollations();
80650>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
80651>>>>>
80651>>>>>        Move 1 to iColumn
80652>>>>>        Send SqlExecDirect of hStmt sSQL
80653>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
80654>>>>>        Repeat
80654>>>>>>
80654>>>>>            Get SQLFetch of hStmt to iFetchResult
80655>>>>>            If (iFetchResult <> 0) Begin
80657>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
80658>>>>>                If (sValue <> sPrevious) Begin         
80660>>>>>                    // We need to skip all collations starting with "SQL" because they
80660>>>>>                    // are obsolete and for pre-SQL Server 2000.
80660>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
80661>>>>>                    If (iPos <> 1) Begin
80663>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
80664>>>>>                    End
80664>>>>>>
80664>>>>>                End
80664>>>>>>
80664>>>>>                Move sValue to sPrevious
80665>>>>>            End
80665>>>>>>
80665>>>>>        Until (iFetchResult = 0)
80667>>>>>        Send SQLClose of hStmt
80668>>>>>        Send SQLDisconnect of hoSQLConnect
80669>>>>>
80669>>>>>        Function_Return asCollations
80670>>>>>    End_Function
80671>>>>>
80671>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
80671>>>>>    // for DAW drivers.
80671>>>>>    // Returns: A string array.
80671>>>>>    Function _SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
80673>>>>>        String[] sReturnArray
80674>>>>>        String sValue sPrevious
80674>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
80674>>>>>        Integer iFetchResult iRows
80674>>>>>        tSQLConnection SQLConnection
80674>>>>>        tSQLConnection SQLConnection
80674>>>>>
80674>>>>>        Get phoSQLManager to hoSQLHandler
80675>>>>>
80675>>>>>        If (hoSQLHandler <> 0) Begin
80677>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80678>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
80679>>>>>
80679>>>>>            If (hoSQLConnect <> 0) Begin
80681>>>>>                Get SQLOpen of hoSQLConnect to hstmt
80682>>>>>                If (hstmt <> 0) Begin
80684>>>>>                    Send SqlExecDirect of hstmt sStmt
80685>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
80686>>>>>                    Repeat
80686>>>>>>
80686>>>>>                        Get SQLFetch of hstmt to iFetchResult
80687>>>>>                        If (iFetchResult <> 0) Begin
80689>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
80690>>>>>                            If (sValue <> sPrevious) Begin
80692>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
80693>>>>>                            End
80693>>>>>>
80693>>>>>                            Move sValue to sPrevious
80694>>>>>                        End
80694>>>>>>
80694>>>>>                    Until (iFetchResult = 0)
80696>>>>>                    Send SQLClose of hstmt
80697>>>>>                End
80697>>>>>>
80697>>>>>                Send SQLDisconnect of hoSQLConnect
80698>>>>>            End
80698>>>>>>
80698>>>>>        End
80698>>>>>>
80698>>>>>
80698>>>>>        Function_Return sReturnArray
80699>>>>>    End_Function
80700>>>>>
80700>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
80702>>>>>        String[] sReturnArray
80703>>>>>        String sDataSource
80703>>>>>        Handle hoSQLHandler
80703>>>>>        Integer iItem
80703>>>>>
80703>>>>>        Get phoDB2SQLHandler to hoSQLHandler
80704>>>>>        Send SeedDataSources of hoSQLHandler
80705>>>>>
80705>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80706>>>>>
80706>>>>>        Repeat
80706>>>>>>
80706>>>>>            Get DataSources of hoSQLHandler to sDataSource
80707>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
80708>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
80709>>>>>            Increment iItem
80710>>>>>        Until (sDataSource = "")
80712>>>>>
80712>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80713>>>>>
80713>>>>>        Function_Return sReturnArray
80714>>>>>    End_Function
80715>>>>>
80715>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
80717>>>>>        String[] sReturnArray
80718>>>>>        String sDataSource
80718>>>>>        Handle hoSQLHandler
80718>>>>>        Integer iItem
80718>>>>>
80718>>>>>        Get phoODBCSQLHandler to hoSQLHandler
80719>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80720>>>>>
80720>>>>>        Send SeedDataSources of hoSQLHandler
80721>>>>>
80721>>>>>        Repeat
80721>>>>>>
80721>>>>>            Get DataSources of hoSQLHandler to sDataSource
80722>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
80724>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
80725>>>>>                Increment iItem
80726>>>>>            End
80726>>>>>>
80726>>>>>        Until (sDataSource = "")
80728>>>>>
80728>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80729>>>>>
80729>>>>>        Function_Return sReturnArray
80730>>>>>    End_Function
80731>>>>>
80731>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
80733>>>>>        String[] sDataSources
80734>>>>>        tSQLConnection SQLConnection
80734>>>>>        tSQLConnection SQLConnection
80734>>>>>        tSQLIntTableInfo[] sReturnArray
80734>>>>>        tSQLIntTableInfo[] sReturnArray
80735>>>>>        Integer iDataSources iCount iItem
80735>>>>>        String sConnection sServer sDatabase sKey sSubKey
80735>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
80735>>>>>        Boolean bExists bKeyOpened
80735>>>>>
80735>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80736>>>>>        Move SQLConnection.sConnectionString to sConnection
80737>>>>>        Move SQLConnection.sServer           to sServer
80738>>>>>
80738>>>>>        // FileDSN - read DATABASE name from DSN ini-file
80738>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
80740>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
80741>>>>>            Set psFileName of hoIniFile to sServer
80742>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
80743>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
80744>>>>>            Send Destroy of hoIniFile
80745>>>>>        End
80745>>>>>>
80745>>>>>
80745>>>>>        // DSN - read DATABASE name from the registry
80745>>>>>        Else Begin
80746>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
80747>>>>>
80747>>>>>            // We start with checking the "System DNS" area in the registry as it is the
80747>>>>>            // most probably place the info is kept that we're after.
80747>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
80748>>>>>            Set pfAccessRights of hoRegistry to Key_Read
80749>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
80750>>>>>            If (bExists = True) Begin
80752>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
80753>>>>>            End
80753>>>>>>
80753>>>>>            Else Begin
80754>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
80755>>>>>            End
80755>>>>>>
80755>>>>>
80755>>>>>            Get KeyExists of hoRegistry sKey to bExists
80756>>>>>            If (bExists) Begin
80758>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
80759>>>>>                If (bKeyOpened) Begin
80761>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
80762>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
80763>>>>>                    If (iDataSources > 0) Begin
80765>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
80766>>>>>                        Decrement iDataSources
80767>>>>>                        for iCount from 0 to iDataSources
80773>>>>>>
80773>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
80774>>>>>                        Loop
80775>>>>>>
80775>>>>>                        Move 0 to iItem
80776>>>>>                        for iCount from 0 to iDataSources
80782>>>>>>
80782>>>>>                            Move sDataSources[iCount] to sSubKey
80783>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
80784>>>>>                            If (bKeyOpened = True) Begin
80786>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
80787>>>>>                                If (bExists = True) Begin
80789>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
80790>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
80791>>>>>                                    Increment iItem
80792>>>>>                                End
80792>>>>>>
80792>>>>>                            End
80792>>>>>>
80792>>>>>                        Loop
80793>>>>>>
80793>>>>>                    End
80793>>>>>>
80793>>>>>                    Send CloseKey of hoRegistry
80794>>>>>                    Send Destroy of hoODBCDataSources
80795>>>>>                End
80795>>>>>>
80795>>>>>            End
80795>>>>>>
80795>>>>>
80795>>>>>            // We then check the "User DNS" area in the registry.
80795>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
80796>>>>>            Set pfAccessRights of hoRegistry to Key_Read
80797>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
80798>>>>>            Get KeyExists of hoRegistry sKey to bExists
80799>>>>>
80799>>>>>            If (bExists) Begin
80801>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
80802>>>>>                If (bKeyOpened) Begin
80804>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
80805>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
80806>>>>>                    If (iDataSources > 0) Begin
80808>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
80809>>>>>                        Decrement iDataSources
80810>>>>>                        for iCount from 0 to iDataSources
80816>>>>>>
80816>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
80817>>>>>                        Loop
80818>>>>>>
80818>>>>>                        for iCount from 0 to iDataSources
80824>>>>>>
80824>>>>>                            Move sDataSources[iCount] to sSubKey
80825>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
80826>>>>>                            If (bKeyOpened = True) Begin
80828>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
80829>>>>>                                If (bExists = True) Begin
80831>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
80832>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
80833>>>>>                                    Increment iItem
80834>>>>>                                End
80834>>>>>>
80834>>>>>                            End
80834>>>>>>
80834>>>>>                        Loop
80835>>>>>>
80835>>>>>                    End
80835>>>>>>
80835>>>>>                    Send CloseKey of hoRegistry
80836>>>>>                    Send Destroy of hoODBCDataSources
80837>>>>>                End
80837>>>>>>
80837>>>>>            End
80837>>>>>>
80837>>>>>
80837>>>>>            Send Destroy of hoRegistry
80838>>>>>        End
80838>>>>>>
80838>>>>>
80838>>>>>        Function_Return sReturnArray
80839>>>>>    End_Function
80840>>>>>
80840>>>>>    // We might have a split Sql script where the info about which database to use is
80840>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
80840>>>>>    // insert it for scriplets to come after the first one.
80840>>>>>    Function _SqlFormatStatement String sStmt Returns String
80842>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
80842>>>>>        Integer iStart iEnd iDbType
80842>>>>>        Boolean bOK
80842>>>>>
80842>>>>>        Get piDbType to iDbType
80843>>>>>        Get psDriverID to sDriverID
80844>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
80845>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
80846>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
80847>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
80848>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
80849>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
80851>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
80852>>>>>            Move (Pos("]", sTmp)) to iEnd
80853>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
80854>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
80855>>>>>            Set Private.psUseDatabase to sUseDatabase
80856>>>>>        End
80856>>>>>>
80856>>>>>        Else Begin
80857>>>>>            Move (Uppercase(sStmt)) to sTmp
80858>>>>>
80858>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
80858>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
80860>>>>>                Get Private.psUseDatabase to sUseDatabase
80861>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
80862>>>>>            End
80862>>>>>>
80862>>>>>
80862>>>>>            // This is a bit special to place here but was done so because it was easier that way.
80862>>>>>            // We will get an error when trying to create a view if it already exists.
80862>>>>>            // So to avoid such errors; we first remove it & then recreate it.
80862>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
80865>>>>>                // Make sure we only have one space between statements/words.
80865>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
80866>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
80867>>>>>                Move (Trim(sTmp)) to sTmp
80868>>>>>                Move (Pos(" ", sTmp)) to iEnd
80869>>>>>                Move (Left(sTmp, iEnd)) to sTmp
80870>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
80872>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
80873>>>>>                End
80873>>>>>>
80873>>>>>                Move (Trim(sTmp)) to sTmp
80874>>>>>                // Remove data view as it already exists!
80874>>>>>                Get _SqlViewRemove sDriverID sTmp to bOK
80875>>>>>            End
80875>>>>>>
80875>>>>>        End
80875>>>>>>
80875>>>>>
80875>>>>>        Function_Return sStmt
80876>>>>>    End_Function
80877>>>>>
80877>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
80877>>>>>    Function _SqlViewRemove String sDataView Returns Boolean
80879>>>>>        String sDriverID sSQLString sDropViewKeyWord
80879>>>>>        Integer iRetval
80879>>>>>        Boolean bOK
80879>>>>>
80879>>>>>        Get psDriverID to sDriverID
80880>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
80881>>>>>
80881>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
80882>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
80883>>>>>        Set psSQLStatementString to sSQLString
80884>>>>>
80884>>>>>        // As we don't check if the view exist or not, it might happen
80884>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
80884>>>>>        Move False to Err
80885>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
80886>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
80887>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
80888>>>>>        Move 0 to LastErr
80889>>>>>
80889>>>>>        // We also need to remove the cache-file since the table has been changed
80889>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
80890>>>>>
80890>>>>>        Function_Return (Err = False)
80891>>>>>    End_Function
80892>>>>>
80892>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
80892>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
80894>>>>>        String sRetval
80894>>>>>        Integer iDbType iIndex
80894>>>>>        tSQLKeyWords[] SQLKeywordArray
80894>>>>>        tSQLKeyWords[] SQLKeywordArray
80895>>>>>        tSQLKeyWords   SQLKeyWords
80895>>>>>        tSQLKeyWords   SQLKeyWords
80895>>>>>
80895>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
80895>>>>>        Move "" to sRetval
80896>>>>>        Get piDbType to iDbType
80897>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
80898>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
80899>>>>>
80899>>>>>        Get paSQLKeywordArray to SQLKeywordArray
80900>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
80901>>>>>        If (iIndex >= 0) Begin
80903>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
80904>>>>>        End
80904>>>>>>
80904>>>>>
80904>>>>>        Function_Return sRetval
80905>>>>>    End_Function
80906>>>>>
80906>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
80906>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
80908>>>>>        String[] sSQLScriptArray
80909>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
80909>>>>>        Integer iSize iCount
80909>>>>>        Boolean bCommentStart bCommentEnd bDashComment
80909>>>>>
80909>>>>>        Move False to bCommentStart
80910>>>>>        Move False to bCommentEnd
80911>>>>>        Move False to bDashComment
80912>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
80913>>>>>        Move "*/"  to sCommentEnd
80914>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
80915>>>>>
80915>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
80916>>>>>        Decrement iSize
80917>>>>>        Move "" to sText
80918>>>>>
80918>>>>>        for iCount from 0 to iSize
80924>>>>>>
80924>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
80925>>>>>            Move (Trim(sLine)) to sTmp
80926>>>>>            If (sTmp <> "") Begin
80928>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
80929>>>>>                If (bCommentStart = False) Begin
80931>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
80932>>>>>                    If (bCommentStart = False) Begin
80934>>>>>                    End
80934>>>>>>
80934>>>>>                End
80934>>>>>>
80934>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
80935>>>>>                If (bCommentEnd = True) Begin
80937>>>>>                    Move False to bCommentStart
80938>>>>>                End
80938>>>>>>
80938>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
80940>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
80941>>>>>                End
80941>>>>>>
80941>>>>>            End
80941>>>>>>
80941>>>>>        Loop
80942>>>>>>
80942>>>>>
80942>>>>>        // Update the retval struct array:
80942>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
80943>>>>>        Function_Return SqlScriptArray
80944>>>>>    End_Function
80945>>>>>
80945>>>>>    // Helper function that builds a string like;
80945>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
80945>>>>>    Function _SqlSelectFromWhereName Returns String
80947>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
80947>>>>>
80947>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
80948>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
80949>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
80950>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
80951>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
80952>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
80953>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
80954>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
80955>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
80956>>>>>        Function_Return sRetval
80957>>>>>    End_Function
80958>>>>>
80958>>>>>    // Helper function to create a SQL statement like;
80958>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
80958>>>>>    // Used for checking if an index exists.
80958>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
80960>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
80960>>>>>
80960>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
80961>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
80962>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
80963>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
80964>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
80965>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
80966>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
80967>>>>>
80967>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
80968>>>>>
80968>>>>>        Function_Return sRetval
80969>>>>>    End_Function
80970>>>>>
80970>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
80970>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
80970>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
80972>>>>>        String sRetval
80972>>>>>        If (iLength <> 0) Begin
80974>>>>>            Move ("(" + String(iLength)) to sRetval
80975>>>>>            If (iDecimals <> 0) Begin
80977>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
80978>>>>>            End
80978>>>>>>
80978>>>>>            Move (sRetval + ")") to sRetval
80979>>>>>        End
80979>>>>>>
80979>>>>>        Function_Return sRetval
80980>>>>>    End_Function
80981>>>>>
80981>>>>>    // Checks that the passed sDriverID is defined.
80981>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
80981>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
80983>>>>>        Boolean bOK
80983>>>>>        Integer iDriver
80983>>>>>
80983>>>>>        If (sDriverID = DATAFLEX_ID) Begin
80985>>>>>            Function_Return False
80986>>>>>        End
80986>>>>>>
80986>>>>>
80986>>>>>        Get IsDAWSQLDriver sDriverID to bOK
80987>>>>>
80987>>>>>        If (bOK = False) Begin
80989>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, or ODBC_DRV"
80990>>>>>>
80990>>>>>            Function_Return False
80991>>>>>        End
80991>>>>>>
80991>>>>>
80991>>>>>        Get DriverIndex sDriverID to iDriver
80992>>>>>        If (iDriver = 0) Begin
80994>>>>>            Load_Driver sDriverID
80995>>>>>        End
80995>>>>>>
80995>>>>>
80995>>>>>        Function_Return True
80996>>>>>    End_Function
80997>>>>>
80997>>>>>    // Checks that the length parameter has been passed correctly.
80997>>>>>    // This is only of concern for certain SQL data types.
80997>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
80999>>>>>        Integer iLength
80999>>>>>        Boolean bOK bCheckTypeLength
80999>>>>>
80999>>>>>        If (num_arguments > 1) Begin
81001>>>>>            Move iLen to iLength
81002>>>>>        End
81002>>>>>>
81002>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
81003>>>>>
81003>>>>>        If (bCheckTypeLength = True) Begin
81005>>>>>            Move (iLength > 0) to bOK
81006>>>>>        End
81006>>>>>>
81006>>>>>
81006>>>>>        Function_Return (bOK = True)
81007>>>>>    End_Function
81008>>>>>
81008>>>>>    Function _SqlProperTableName String sTableName Returns String
81010>>>>>        String sVal sSchema sDriverID
81010>>>>>        Integer iDbType
81010>>>>>
81010>>>>>        If (Trim(sTableName) = "") Begin
81012>>>>>            Function_Return ""
81013>>>>>        End
81013>>>>>>
81013>>>>>
81013>>>>>        Get psDriverID to sDriverID
81014>>>>>        Get piDbType   to iDbType
81015>>>>>        If (iDbType = EN_dbTypeOracle) Begin
81017>>>>>            Get psUserID to sSchema
81018>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
81018>>>>>            Move (Uppercase(sSchema)) to sSchema
81019>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
81020>>>>>            Function_Return sTableName
81021>>>>>        End
81021>>>>>>
81021>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
81023>>>>>            Get psDatabase to sVal
81024>>>>>            Move (sVal + "." + sTableName) to sTableName
81025>>>>>            Function_Return sTableName
81026>>>>>        End
81026>>>>>>
81026>>>>>        If (iDbType = EN_DbTypePostgre) Begin
81028>>>>>            Move ('"' + sTableName + '"') to sTableName
81029>>>>>            Function_Return sTableName
81030>>>>>        End
81030>>>>>>
81030>>>>>
81030>>>>>        Get psSchema to sSchema
81031>>>>>        If (sSchema = "") Begin
81033>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81034>>>>>        End
81034>>>>>>
81034>>>>>
81034>>>>>        Move (Uppercase(sTableName)) to sVal
81035>>>>>        If (not(sVal contains (sSchema + "."))) Begin
81037>>>>>            If (iDbType = EN_dbTypeDB2) Begin
81039>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
81040>>>>>            End
81040>>>>>>
81040>>>>>            Else Begin
81041>>>>>                Move (sSchema + "." + sTableName) to sTableName
81042>>>>>            End
81042>>>>>>
81042>>>>>        End
81042>>>>>>
81042>>>>>
81042>>>>>        Function_Return sTableName
81043>>>>>    End_Function
81044>>>>>
81044>>>>>    // SQL column names can be case-sensitive. This function is used to check that
81044>>>>>    // the passed sFieldName has the correct spelling.
81044>>>>>    // Used with Embedded SQL statement calls.
81044>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
81044>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
81046>>>>>        String sRetval sValue sDriverID
81046>>>>>        String[] sColumnNamesArray
81047>>>>>        Integer iCount iColumns
81047>>>>>
81047>>>>>        Move "" to sRetval
81048>>>>>        Get psDriverID to sDriverID
81049>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
81050>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
81051>>>>>        Decrement iColumns
81052>>>>>
81052>>>>>        For iCount from 0 to iColumns
81058>>>>>>
81058>>>>>            Move sColumnNamesArray[iCount] to sValue
81059>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
81061>>>>>                Move sValue to sRetval
81062>>>>>                Move iColumns to iCount // We're done.
81063>>>>>            End
81063>>>>>>
81063>>>>>        Loop
81064>>>>>>
81064>>>>>
81064>>>>>        Function_Return sRetval
81065>>>>>    End_Function
81066>>>>>
81066>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
81068>>>>>        String[] sReturnArray
81069>>>>>        Handle hoSQLHandler
81069>>>>>        Integer iCount iSize iItem
81069>>>>>        String sServer
81069>>>>>        tSQLConnection SQLConnection
81069>>>>>        tSQLConnection SQLConnection
81069>>>>>
81069>>>>>        Get phoMSSQLHandler to hoSQLHandler
81070>>>>>        Send Delete_Data    of hoSQLHandler
81071>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
81072>>>>>
81072>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81073>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
81074>>>>>        Decrement iSize
81075>>>>>
81075>>>>>        For iCount from 0 to iSize
81081>>>>>>
81081>>>>>            Get String_Value of hoSQLHandler iCount to sServer
81082>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
81083>>>>>            Increment iItem
81084>>>>>        Loop
81085>>>>>>
81085>>>>>
81085>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81086>>>>>
81086>>>>>        Function_Return sReturnArray
81087>>>>>    End_Function
81088>>>>>
81088>>>>>    Function _SqlTableArrayDAW Returns String[]
81090>>>>>        String[] sReturnArray
81091>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
81091>>>>>        Handle hoSQLHandler
81091>>>>>        Integer iCount iSize iItem iPos
81091>>>>>        Boolean bOK
81091>>>>>        tSQLConnection SQLConnection
81091>>>>>        tSQLConnection SQLConnection
81091>>>>>
81091>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81092>>>>>        If (SQLConnection.sConnectionString = "") Begin
81094>>>>>            Function_Return sReturnArray
81095>>>>>        End
81095>>>>>>
81095>>>>>
81095>>>>>        Move SQLConnection.sSchema      to sDefSchema
81096>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
81097>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
81098>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
81099>>>>>
81099>>>>>        Get phoCLIHandler to hoSQLHandler
81100>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
81101>>>>>        Send Delete_Data  of hoSQLHandler
81102>>>>>
81102>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81103>>>>>        Move SQLConnection.sConnectionString to sConnectionString
81104>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
81104>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
81104>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
81104>>>>>//                Move (Pos(";", sConnectionString)) to iPos
81104>>>>>//                If (iPos > 0) Begin
81104>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
81104>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
81104>>>>>//                End
81104>>>>>//            End
81104>>>>>//        End
81104>>>>>
81104>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
81105>>>>>        Move False to Err
81106>>>>>        Move 0 to iItem
81107>>>>>
81107>>>>>        // Note that the enumeration starts from table no 1. (not zero)
81107>>>>>        For iCount from 1 to iSize
81113>>>>>>
81113>>>>>            Get TableName    of hoSQLHandler iCount to sTable
81114>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
81115>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
81116>>>>>            If (sSchema = "") Begin
81118>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
81119>>>>>            End
81119>>>>>>
81119>>>>>            Get TableComment of hoSQLHandler iCount to sComment
81120>>>>>            Move (Trim(sTable)) to sTable
81121>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
81123>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
81124>>>>>            End
81124>>>>>>
81124>>>>>            Else Begin
81125>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
81126>>>>>            End
81126>>>>>>
81126>>>>>            If (bOK = True) Begin
81128>>>>>                Move sTable to sReturnArray[iItem]
81129>>>>>                Increment iItem
81130>>>>>            End
81130>>>>>>
81130>>>>>        Loop
81131>>>>>>
81131>>>>>
81131>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81132>>>>>
81132>>>>>        Function_Return sReturnArray
81133>>>>>    End_Function
81134>>>>>
81134>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
81136>>>>>        String[] sReturnArray
81137>>>>>        String sValue
81137>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
81137>>>>>        Integer iRetval iCols iFetchResult
81137>>>>>        tSQLConnection SQLConnection
81137>>>>>        tSQLConnection SQLConnection
81137>>>>>
81137>>>>>        Get phoSQLManager to hoSQLHandler
81138>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81139>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81140>>>>>
81140>>>>>        If (hoSQLConnect <> 0) Begin
81142>>>>>            Get SqlOpen of hoSQLConnect to hStmt
81143>>>>>            If (hStmt <> 0) Begin
81145>>>>>                Send SqlSetProcedurename of hStmt sStmt
81146>>>>>                If (sArgument <> "") Begin
81148>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
81149>>>>>                End
81149>>>>>>
81149>>>>>
81149>>>>>                Send SqlCall             of hStmt
81150>>>>>                Get SqlReturnValue       of hStmt to iRetval
81151>>>>>                If (iRetval = 0) Begin
81153>>>>>                    Repeat
81153>>>>>>
81153>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
81154>>>>>                        If (iCols > 0) Begin
81156>>>>>                            Repeat
81156>>>>>>
81156>>>>>                                Get SqlFetch of hStmt to iFetchResult
81157>>>>>                                If (iFetchResult <> 0) Begin
81159>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
81160>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
81161>>>>>                                End
81161>>>>>>
81161>>>>>                            Until (iFetchResult = 0)
81163>>>>>                        End
81163>>>>>>
81163>>>>>                        Get SqlNextResultSet of hStmt to iRetval
81164>>>>>                    Until (iRetval = 0)
81166>>>>>                    Send SqlClose of hStmt
81167>>>>>                End
81167>>>>>>
81167>>>>>            End
81167>>>>>>
81167>>>>>            Send SqlDisconnect of hoSQLConnect
81168>>>>>        End
81168>>>>>>
81168>>>>>        Function_Return sReturnArray
81169>>>>>    End_Function
81170>>>>>
81170>>>>>    Function _SqlUtilUpdateIntFile Integer hTable Returns Boolean
81172>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
81172>>>>>        Boolean bOpened bOK
81172>>>>>
81172>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
81172>>>>>        // which makes the program unable to run because they can't be opened.
81172>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
81172>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
81172>>>>>        // proper .int files for the two tables.
81172>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
81174>>>>>            Function_Return True
81175>>>>>        End
81175>>>>>>
81175>>>>>
81175>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81178>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81179>>>>>        Move CS_OEM_Txt  to sOrgFormat
81180>>>>>        Move CS_ANSI_Txt to sNewFormat
81181>>>>>        Get AutoConnectionIDLogin to bOK
81182>>>>>
81182>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
81182>>>>>        Sleep 1
81183>>>>>
81183>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81186>>>>>        If (bOpened = False) Begin
81188>>>>>            Open hTable
81190>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
81193>>>>>        End
81193>>>>>>
81193>>>>>        If (bOpened = False) Begin
81195>>>>>            Function_Return False
81196>>>>>        End
81196>>>>>>
81196>>>>>
81196>>>>>        Get psDriverID to sDriverID
81197>>>>>
81197>>>>>        Move False to Err
81198>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81201>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
81202>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81202>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81202>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81203>>>>>
81203>>>>>        Move False to Err
81204>>>>>
81204>>>>>        If (hTable > 0) Begin
81206>>>>>            Structure_Start hTable
81207>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81210>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81213>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
81215>>>>>        End
81215>>>>>>
81215>>>>>        Else Begin
81216>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81219>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81222>>>>>        End
81222>>>>>>
81222>>>>>        Function_Return (Err = False)
81223>>>>>    End_Function
81224>>>>>
81224>>>>>    // Subfunction to the ApiTableUpdate function (et al)
81224>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
81226>>>>>        Handle hTable
81226>>>>>        String sConnectionID
81226>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
81226>>>>>
81226>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
81227>>>>>        If (bSameTableNames = True) Begin
81229>>>>>            Function_Return True
81230>>>>>        End
81230>>>>>>
81230>>>>>
81230>>>>>        Move True to bOK
81231>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
81232>>>>>        Set Private.phCurrentTable              to hTable
81233>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
81236>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
81239>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
81242>>>>>
81242>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
81244>>>>>            Get psConnectionID to sConnectionID
81245>>>>>            Get _UtilTableExists hTable to bTableExists
81246>>>>>            If (bTableExists = True) Begin
81248>>>>>                Get _SqlUtilUpdateIntFile hTable to bOK
81249>>>>>            End
81249>>>>>>
81249>>>>>            Else Begin
81250>>>>>                Get pbToANSI to bANSI
81251>>>>>                Get _SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
81252>>>>>            End
81252>>>>>>
81252>>>>>        End
81252>>>>>>
81252>>>>>
81252>>>>>        Function_Return bOK
81253>>>>>    End_Function
81254>>>>>
81254>>>>>    // The table must already exist in the filelist for this function to work.
81254>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
81254>>>>>    Function _SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
81256>>>>>        Boolean bOK bExists bUseConnectionID 
81256>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
81256>>>>>        String[] sIndexArray
81257>>>>>        Integer iCount iCh iSize
81257>>>>>
81257>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
81258>>>>>        Get psConnectionString to sConnectionString
81259>>>>>
81259>>>>>        Move CS_ANSI_Txt to sANSI_OEM
81260>>>>>        If (bANSI = False) Begin
81262>>>>>            Move CS_OEM_Txt to sANSI_OEM
81263>>>>>        End
81263>>>>>>
81263>>>>>
81263>>>>>        Get psDataPathFirstPart to sDataPath
81264>>>>>        Get vFolderExists sDataPath to bOK
81265>>>>>        If (bOK = False) Begin
81267>>>>>            Error DFERR_PROGRAM "Function _SqlUtilCreateIntFile; psDataPath not found!"
81268>>>>>>
81268>>>>>            Function_Return False
81269>>>>>        End
81269>>>>>>
81269>>>>>        Get vFolderFormat sDataPath to sDataPath
81270>>>>>
81270>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81273>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81276>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81277>>>>>        Move sLogicalName  to sPhysicalFileName
81278>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
81279>>>>>
81279>>>>>        Get psSchema hTable to sSchemaName
81280>>>>>        If (sSchemaName = "") Begin
81282>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
81283>>>>>        End
81283>>>>>>
81283>>>>>
81283>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
81283>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
81284>>>>>        If (bExists = True) Begin
81286>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
81287>>>>>        End
81287>>>>>>
81287>>>>>
81287>>>>>        Get _UtilDeleteCacheFile sRootName to bOK
81288>>>>>        Get _SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
81289>>>>>
81289>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
81290>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
81295>>>>>            If (bUseConnectionID = True) Begin
81297>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
81304>>>>>            End
81304>>>>>>
81304>>>>>            Else Begin
81305>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
81312>>>>>            End
81312>>>>>>
81312>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
81317>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
81322>>>>>            // There seems to be a new order how these are set from DF19.
81322>>>>>            If (bSysFile = True) Begin
81324>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
81329>>>>>            End
81329>>>>>>
81329>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
81334>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
81339>>>>>            If (bSysFile = True) Begin
81341>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
81346>>>>>            End
81346>>>>>>
81346>>>>>
81346>>>>>            If (bSysFile = False) Begin
81348>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
81349>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
81350>>>>>                If (iSize > 0) Begin
81352>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
81355>>>>>                    Writeln channel iCh // Just an empty line
81357>>>>>                End
81357>>>>>>
81357>>>>>                Decrement iSize
81358>>>>>                for iCount from 0 to iSize
81364>>>>>>
81364>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
81367>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
81370>>>>>                    Writeln channel iCh
81372>>>>>                Loop
81373>>>>>>
81373>>>>>            End
81373>>>>>>
81373>>>>>        Send Seq_Close_Channel iCh
81374>>>>>
81374>>>>>        // Wait a sec for Windows to finish writing the file:
81374>>>>>        Sleep 1
81375>>>>>
81375>>>>>        Function_Return (bOK = True)
81376>>>>>    End_Function
81377>>>>>
81377>>>>>    Function _UtilDeleteCacheFile String sTableName Returns Boolean
81379>>>>>        String sDataPath sDriverID
81379>>>>>        Boolean bOK
81379>>>>>        Integer iPos
81379>>>>>
81379>>>>>        If (sTableName contains ".") Begin
81381>>>>>            Move (Pos(".", sTableName)) to iPos
81382>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
81383>>>>>        End
81383>>>>>>
81383>>>>>
81383>>>>>        Get psDriverID to sDriverID
81384>>>>>        Get psDataPathFirstPart to sDataPath
81385>>>>>        // First delete the cache file:
81385>>>>>        Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
81386>>>>>
81386>>>>>        Function_Return bOK
81387>>>>>    End_Function
81388>>>>>
81388>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
81388>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
81388>>>>>    // if it is an SQL table
81388>>>>>    Function _UtilTableExists Handle hTable Returns Boolean
81390>>>>>        Boolean bExists bIsSQLTable
81390>>>>>        String sDataPath sRootName
81390>>>>>
81390>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81391>>>>>        If (bExists = False) Begin
81393>>>>>            Function_Return False
81394>>>>>        End
81394>>>>>>
81394>>>>>
81394>>>>>        Move False to bIsSQLTable
81395>>>>>        If (hTable > 0) Begin
81397>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81400>>>>>            Move (sRootName contains ":") to bIsSQLTable
81401>>>>>        End
81401>>>>>>
81401>>>>>        If (bIsSQLTable = True) Begin
81403>>>>>            Get _UtilTableIsSql hTable to bExists
81404>>>>>            Function_Return bExists
81405>>>>>        End
81405>>>>>>
81405>>>>>        Else Begin
81406>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81407>>>>>            Get vFolderFormat sDataPath to sDataPath
81408>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
81409>>>>>        End
81409>>>>>>
81409>>>>>
81409>>>>>        Function_Return bExists
81410>>>>>    End_Function
81411>>>>>
81411>>>>>    // Pass a table handle
81411>>>>>    // Returns True if the table exists in filelist.cfg.
81411>>>>>    Function _UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
81413>>>>>        Handle hTable
81413>>>>>        Boolean bFound
81413>>>>>
81413>>>>>        Move False to bFound
81414>>>>>        Move 0 to hTable
81415>>>>>        Repeat
81415>>>>>>
81415>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81418>>>>>            If (hTable > 0) Begin
81420>>>>>                If (hTable = hCheckTable) Begin
81422>>>>>                    Move True to bFound
81423>>>>>                End
81423>>>>>>
81423>>>>>            End
81423>>>>>>
81423>>>>>            If (bFound = True) ;                Break
81426>>>>>        Until (hTable = 0)
81428>>>>>
81428>>>>>        Function_Return (bFound = True)
81429>>>>>    End_Function
81430>>>>>
81430>>>>>    // DataFlex Embedded Database Data Types:
81430>>>>>    // Helper function for _UtilEnumerateColumnTypes
81430>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
81432>>>>>        tColumnType[] ColumnType
81432>>>>>        tColumnType[] ColumnType
81433>>>>>        Integer i
81433>>>>>
81433>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
81434>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
81435>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
81436>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
81437>>>>>        Move "254"              to ColumnType[i].sPrecision
81438>>>>>        Increment i
81439>>>>>
81439>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
81440>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
81441>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
81442>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
81443>>>>>        Move "14.8"             to ColumnType[i].sPrecision
81444>>>>>        Increment i
81445>>>>>
81445>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
81446>>>>>        Move "Date"             to ColumnType[i].sSQLType
81447>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
81448>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
81449>>>>>        Move "6.0"              to ColumnType[i].sPrecision
81450>>>>>        Move True               to ColumnType[i].bCanEditSize
81451>>>>>        Increment i
81452>>>>>
81452>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
81453>>>>>        Move "Text"             to ColumnType[i].sSQLType
81454>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
81455>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
81456>>>>>        Move "16384"            to ColumnType[i].sPrecision
81457>>>>>        Increment i
81458>>>>>
81458>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
81459>>>>>        Move "Binary"           to ColumnType[i].sSQLType
81460>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
81461>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
81462>>>>>        Move "16384"            to ColumnType[i].sPrecision
81463>>>>>        Increment i
81464>>>>>
81464>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
81465>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
81466>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
81467>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
81468>>>>>        Move "23"               to ColumnType[i].sPrecision
81469>>>>>        Move True               to ColumnType[i].bCanEditSize
81470>>>>>        Increment i
81471>>>>>
81471>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
81472>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
81473>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
81474>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
81475>>>>>        Move "0.0"              to ColumnType[i].sPrecision
81476>>>>>
81476>>>>>        Function_Return ColumnType
81477>>>>>    End_Function
81478>>>>>
81478>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
81480>>>>>        tColumnType[] aColumnType
81480>>>>>        tColumnType[] aColumnType
81481>>>>>        Integer i
81481>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
81481>>>>>>// Generated By The Database Update Framework
81481>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
81481>>>>>>// Driver COLUMN DATA TYPES
81481>>>>>>//
81481>>>>>>// Created: 2019-07-18 18:57:13.935
81481>>>>>>
81481>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
81482>>>>>>            Move -5                                      to aColumnType[i].iSQLType
81483>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81484>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81485>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81486>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81487>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81488>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81489>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81490>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81491>>>>>>            Increment i
81492>>>>>>
81492>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
81493>>>>>>            Move -2                                      to aColumnType[i].iSQLType
81494>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81495>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81496>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81497>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81498>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81499>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81500>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81501>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81502>>>>>>            Increment i
81503>>>>>>
81503>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
81504>>>>>>            Move -7                                      to aColumnType[i].iSQLType
81505>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81506>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81507>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81508>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81509>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81510>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81511>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81512>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81513>>>>>>            Increment i
81514>>>>>>
81514>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
81515>>>>>>            Move 1                                       to aColumnType[i].iSQLType
81516>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81517>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81518>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81519>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81520>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81521>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81522>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81523>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81524>>>>>>            Increment i
81525>>>>>>
81525>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
81526>>>>>>            Move 91                                      to aColumnType[i].iSQLType
81527>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81528>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81529>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81530>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81531>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81532>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81533>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81534>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81535>>>>>>            Increment i
81536>>>>>>
81536>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
81537>>>>>>            Move 93                                      to aColumnType[i].iSQLType
81538>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81539>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81540>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81541>>>>>>            Move -1                                      to aColumnType[i].iMinSize
81542>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
81543>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81544>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81545>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81546>>>>>>            Increment i
81547>>>>>>
81547>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
81548>>>>>>            Move -200                                    to aColumnType[i].iSQLType
81549>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81550>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81551>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
81552>>>>>>            Move 23                                      to aColumnType[i].iMinSize
81553>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
81554>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81555>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81556>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81557>>>>>>            Increment i
81558>>>>>>
81558>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
81559>>>>>>            Move -155                                    to aColumnType[i].iSQLType
81560>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81561>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81562>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
81563>>>>>>            Move 34                                      to aColumnType[i].iMinSize
81564>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
81565>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81566>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81567>>>>>>            Move 34                                      to aColumnType[i].sPrecision
81568>>>>>>            Increment i
81569>>>>>>
81569>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
81570>>>>>>            Move 3                                       to aColumnType[i].iSQLType
81571>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81572>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81573>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81574>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81575>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81576>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81577>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81578>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81579>>>>>>            Increment i
81580>>>>>>
81580>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
81581>>>>>>            Move 6                                       to aColumnType[i].iSQLType
81582>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81583>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81584>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81585>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81586>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81587>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
81588>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
81589>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81590>>>>>>            Increment i
81591>>>>>>
81591>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
81592>>>>>>            Move -4                                      to aColumnType[i].iSQLType
81593>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81594>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81595>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81596>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81597>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81598>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81599>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81600>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81601>>>>>>            Increment i
81602>>>>>>
81602>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
81603>>>>>>            Move 4                                       to aColumnType[i].iSQLType
81604>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81605>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81606>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
81607>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81608>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
81609>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81610>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81611>>>>>>            Move 10                                      to aColumnType[i].sPrecision
81612>>>>>>            Increment i
81613>>>>>>
81613>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
81614>>>>>>            Move -204                                    to aColumnType[i].iSQLType
81615>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81616>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81617>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81618>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81619>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81620>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81621>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81622>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81623>>>>>>            Increment i
81624>>>>>>
81624>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
81625>>>>>>            Move -8                                      to aColumnType[i].iSQLType
81626>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81627>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81628>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81629>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81630>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
81631>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81632>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81633>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
81634>>>>>>            Increment i
81635>>>>>>
81635>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
81636>>>>>>            Move -10                                     to aColumnType[i].iSQLType
81637>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81638>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81639>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81640>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81641>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81642>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81643>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81644>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81645>>>>>>            Increment i
81646>>>>>>
81646>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
81647>>>>>>            Move 2                                       to aColumnType[i].iSQLType
81648>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81649>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81650>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81651>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81652>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81653>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
81654>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
81655>>>>>>            Move 6                                       to aColumnType[i].sPrecision
81656>>>>>>            Increment i
81657>>>>>>
81657>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
81658>>>>>>            Move -9                                      to aColumnType[i].iSQLType
81659>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81660>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81661>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81662>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81663>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
81664>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81665>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81666>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
81667>>>>>>            Increment i
81668>>>>>>
81668>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
81669>>>>>>            Move -202                                    to aColumnType[i].iSQLType
81670>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81671>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81672>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81673>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81674>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81675>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81676>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81677>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81678>>>>>>            Increment i
81679>>>>>>
81679>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
81680>>>>>>            Move 7                                       to aColumnType[i].iSQLType
81681>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81682>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81683>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81684>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81685>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81686>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81687>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81688>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81689>>>>>>            Increment i
81690>>>>>>
81690>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
81691>>>>>>            Move -206                                    to aColumnType[i].iSQLType
81692>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81693>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81694>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81695>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81696>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81697>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81698>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81699>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81700>>>>>>            Increment i
81701>>>>>>
81701>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
81702>>>>>>            Move 5                                       to aColumnType[i].iSQLType
81703>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81704>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81705>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
81706>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81707>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
81708>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81709>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81710>>>>>>            Move 5                                       to aColumnType[i].sPrecision
81711>>>>>>            Increment i
81712>>>>>>
81712>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
81713>>>>>>            Move -205                                    to aColumnType[i].iSQLType
81714>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81715>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81716>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81717>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81718>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81719>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81720>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81721>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81722>>>>>>            Increment i
81723>>>>>>
81723>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
81724>>>>>>            Move -1                                      to aColumnType[i].iSQLType
81725>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81726>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81727>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81728>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81729>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81730>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81731>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81732>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81733>>>>>>            Increment i
81734>>>>>>
81734>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
81735>>>>>>            Move -154                                    to aColumnType[i].iSQLType
81736>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81737>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81738>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
81739>>>>>>            Move 10                                      to aColumnType[i].iMinSize
81740>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
81741>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81742>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81743>>>>>>            Move 19                                      to aColumnType[i].sPrecision
81744>>>>>>            Increment i
81745>>>>>>
81745>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
81746>>>>>>            Move -6                                      to aColumnType[i].iSQLType
81747>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81748>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81749>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
81750>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81751>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
81752>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81753>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81754>>>>>>            Move 3                                       to aColumnType[i].sPrecision
81755>>>>>>            Increment i
81756>>>>>>
81756>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
81757>>>>>>            Move -11                                     to aColumnType[i].iSQLType
81758>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81759>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81760>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81761>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81762>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81763>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81764>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81765>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81766>>>>>>            Increment i
81767>>>>>>
81767>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
81768>>>>>>            Move -3                                      to aColumnType[i].iSQLType
81769>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81770>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81771>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
81772>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81773>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81774>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81775>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81776>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81777>>>>>>            Increment i
81778>>>>>>
81778>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
81779>>>>>>            Move -203                                    to aColumnType[i].iSQLType
81780>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81781>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81782>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81783>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81784>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81785>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81786>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81787>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81788>>>>>>            Increment i
81789>>>>>>
81789>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
81790>>>>>>            Move 12                                      to aColumnType[i].iSQLType
81791>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81792>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81793>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81794>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81795>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81796>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81797>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81798>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81799>>>>>>            Increment i
81800>>>>>>
81800>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
81801>>>>>>            Move -201                                    to aColumnType[i].iSQLType
81802>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81803>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81804>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81805>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81806>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81807>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81808>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81809>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81810>>>>>>            Increment i
81811>>>>>>
81811>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
81812>>>>>>            Move -152                                    to aColumnType[i].iSQLType
81813>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81814>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81815>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81816>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81817>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81818>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81819>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81820>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81821>>>>>>            Increment i
81822>>>>>>
81822>>>>>>
81822>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
81822>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "16384"            to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
81822>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
81822>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
81822>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
81822>>>>>//        Move "16384"            to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
81822>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
81822>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
81822>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
81822>>>>>//        Move "254"              to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        // ToDo: We need to change the sType when using this!
81822>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
81822>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
81822>>>>>//        Move "254"                  to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
81822>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
81822>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
81822>>>>>//        Move True               to ColumnType[i].bCanEditSize
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
81822>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "16384"            to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
81822>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
81822>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
81822>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
81822>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
81822>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
81822>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
81822>>>>>//        Move "255"              to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
81822>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
81822>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "32000"            to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
81822>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "32000"            to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
81822>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "32000"            to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
81822>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
81822>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
81822>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
81822>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
81822>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
81822>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
81822>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
81822>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
81822>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
81822>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
81822>>>>>//        Move True               to ColumnType[i].bCanEditSize
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
81822>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
81822>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
81822>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
81822>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
81822>>>>>//        Move True               to ColumnType[i].bCanEditSize
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
81822>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "16384"            to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        // ToDo: We need to change the sType when using this!
81822>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
81822>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
81822>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
81822>>>>>//        Move "16384"                to ColumnType[i].sPrecision
81822>>>>>//        Increment i
81822>>>>>//
81822>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
81822>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "16384"            to ColumnType[i].sPrecision
81822>>>>>//
81822>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
81822>>>>>//        Move "XML"              to ColumnType[i].sSQLType
81822>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
81822>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
81822>>>>>//        Move "16384"            to ColumnType[i].sPrecision
81822>>>>>
81822>>>>>        Function_Return aColumnType
81823>>>>>    End_Function
81824>>>>>
81824>>>>>    // Microsoft SQL Server Database Data Types:
81824>>>>>    // Helper function for _UtilEnumerateColumnTypes
81824>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
81826>>>>>        tColumnType[] aColumnType
81826>>>>>        tColumnType[] aColumnType
81827>>>>>        Integer i
81827>>>>>
81827>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
81829>>>>>>// Generated By The Database Update Framework
81829>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
81829>>>>>>// Driver COLUMN DATA TYPES
81829>>>>>>//
81829>>>>>>// Created: 2019-11-15 21:57:51.001
81829>>>>>>
81829>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
81830>>>>>>            Move -5                                      to aColumnType[i].iSQLType
81831>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81832>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81833>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81834>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81835>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81836>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81837>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81838>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81839>>>>>>            Increment i
81840>>>>>>
81840>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
81841>>>>>>            Move -2                                      to aColumnType[i].iSQLType
81842>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81843>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81844>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81845>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81846>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81847>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
81848>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
81849>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81850>>>>>>            Increment i
81851>>>>>>
81851>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
81852>>>>>>            Move -7                                      to aColumnType[i].iSQLType
81853>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81854>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81855>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81856>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81857>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81858>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81859>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81860>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81861>>>>>>            Increment i
81862>>>>>>
81862>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
81863>>>>>>            Move 1                                       to aColumnType[i].iSQLType
81864>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81865>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81866>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81867>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81868>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81869>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81870>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81871>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81872>>>>>>            Increment i
81873>>>>>>
81873>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
81874>>>>>>            Move 91                                      to aColumnType[i].iSQLType
81875>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81876>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81877>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81878>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81879>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81880>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
81881>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
81882>>>>>>            Move 6                                       to aColumnType[i].sPrecision
81883>>>>>>            Increment i
81884>>>>>>
81884>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
81885>>>>>>            Move 93                                      to aColumnType[i].iSQLType
81886>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81887>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81888>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81889>>>>>>            Move -1                                      to aColumnType[i].iMinSize
81890>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
81891>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
81892>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
81893>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81894>>>>>>            Increment i
81895>>>>>>
81895>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
81896>>>>>>            Move -200                                    to aColumnType[i].iSQLType
81897>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81898>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81899>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
81900>>>>>>            Move 23                                      to aColumnType[i].iMinSize
81901>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
81902>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
81903>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
81904>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81905>>>>>>            Increment i
81906>>>>>>
81906>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
81907>>>>>>            Move -155                                    to aColumnType[i].iSQLType
81908>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81909>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81910>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
81911>>>>>>            Move 34                                      to aColumnType[i].iMinSize
81912>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
81913>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
81914>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
81915>>>>>>            Move 34                                      to aColumnType[i].sPrecision
81916>>>>>>            Increment i
81917>>>>>>
81917>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
81918>>>>>>            Move 3                                       to aColumnType[i].iSQLType
81919>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81920>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81921>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81922>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81923>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81924>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81925>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81926>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81927>>>>>>            Increment i
81928>>>>>>
81928>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
81929>>>>>>            Move 6                                       to aColumnType[i].iSQLType
81930>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81931>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81932>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81933>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81934>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81935>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81936>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81937>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81938>>>>>>            Increment i
81939>>>>>>
81939>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
81940>>>>>>            Move -4                                      to aColumnType[i].iSQLType
81941>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81942>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81943>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81944>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81945>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81946>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
81947>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
81948>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81949>>>>>>            Increment i
81950>>>>>>
81950>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
81951>>>>>>            Move 4                                       to aColumnType[i].iSQLType
81952>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81953>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81954>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
81955>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81956>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
81957>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81958>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81959>>>>>>            Move 10                                      to aColumnType[i].sPrecision
81960>>>>>>            Increment i
81961>>>>>>
81961>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
81962>>>>>>            Move -204                                    to aColumnType[i].iSQLType
81963>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81964>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81965>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81966>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81967>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81968>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81969>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81970>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81971>>>>>>            Increment i
81972>>>>>>
81972>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
81973>>>>>>            Move -8                                      to aColumnType[i].iSQLType
81974>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81975>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81976>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81977>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81978>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
81979>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81980>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81981>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
81982>>>>>>            Increment i
81983>>>>>>
81983>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
81984>>>>>>            Move -10                                     to aColumnType[i].iSQLType
81985>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81986>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81987>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81988>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81989>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81990>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
81991>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
81992>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81993>>>>>>            Increment i
81994>>>>>>
81994>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
81995>>>>>>            Move 2                                       to aColumnType[i].iSQLType
81996>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81997>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81998>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81999>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82000>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82001>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82002>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82003>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82004>>>>>>            Increment i
82005>>>>>>
82005>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82006>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82007>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82008>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82009>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82010>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82011>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82012>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82013>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82014>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82015>>>>>>            Increment i
82016>>>>>>
82016>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82017>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82018>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82019>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82020>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82021>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82022>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82023>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82024>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82025>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82026>>>>>>            Increment i
82027>>>>>>
82027>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82028>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82029>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82030>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82031>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82032>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82033>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82034>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82035>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82036>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82037>>>>>>            Increment i
82038>>>>>>
82038>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82039>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82040>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82041>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82042>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82043>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82044>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82045>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82046>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82047>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82048>>>>>>            Increment i
82049>>>>>>
82049>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82050>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82051>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82052>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82053>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82054>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82055>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82056>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82057>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82058>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82059>>>>>>            Increment i
82060>>>>>>
82060>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82061>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82062>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82063>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82064>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82065>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82066>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82067>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82068>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82069>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82070>>>>>>            Increment i
82071>>>>>>
82071>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82072>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82073>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82074>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82075>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82076>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82077>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82078>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82079>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82080>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82081>>>>>>            Increment i
82082>>>>>>
82082>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82083>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82084>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82085>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82086>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82087>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82088>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82089>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82090>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82091>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82092>>>>>>            Increment i
82093>>>>>>
82093>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82094>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82095>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82096>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82097>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82098>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82099>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82100>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82101>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82102>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82103>>>>>>            Increment i
82104>>>>>>
82104>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82105>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82106>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82107>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82108>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82109>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82110>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82111>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82112>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82113>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82114>>>>>>            Increment i
82115>>>>>>
82115>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82116>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82117>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82118>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82119>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82120>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82121>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82122>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82123>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82124>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82125>>>>>>            Increment i
82126>>>>>>
82126>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82127>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82128>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82129>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82130>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82131>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82132>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82133>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82134>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82135>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82136>>>>>>            Increment i
82137>>>>>>
82137>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82138>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82139>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82140>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82141>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82142>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82143>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82144>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82145>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82146>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82147>>>>>>            Increment i
82148>>>>>>
82148>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82149>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82150>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82151>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82152>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82153>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82154>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82155>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82156>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82157>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82158>>>>>>            Increment i
82159>>>>>>
82159>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82160>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82161>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82162>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82163>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82164>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82165>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82166>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82167>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82168>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82169>>>>>>            Increment i
82170>>>>>>
82170>>>>>>
82170>>>>>
82170>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
82170>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
82170>>>>>//            Move "binary"           to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
82170>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
82170>>>>>//            Move "bit"              to ColumnType[i].sSQLType
82170>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82170>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82170>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
82170>>>>>//            Move "char"             to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
82170>>>>>//            Move "date"             to ColumnType[i].sSQLType
82170>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
82170>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82170>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82170>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82170>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
82170>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
82170>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
82170>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
82170>>>>>//            Move True                to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
82170>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
82170>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
82170>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
82170>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
82170>>>>>//            Move "float"            to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
82170>>>>>//            Move "int"              to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
82170>>>>>//            Move "money"            to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
82170>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
82170>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
82170>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
82170>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
82170>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
82170>>>>>//            Move "real"             to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
82170>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
82170>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
82170>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
82170>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
82170>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
82170>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
82170>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
82170>>>>>//            Move "text"             to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
82170>>>>>//            Move "time"             to ColumnType[i].sSQLType
82170>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82170>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82170>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
82170>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82170>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82170>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
82170>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
82170>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82170>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82170>>>>>//            Move "36"               to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
82170>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82170>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82170>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
82170>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
82170>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82170>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82170>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
82170>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82170>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
82170>>>>>//            Move "xml"              to ColumnType[i].sSQLType
82170>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
82170>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
82170>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82170>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
82170>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
82170>>>>>//            Move "time"             to ColumnType[i].sSQLType
82170>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82170>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82170>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>//
82170>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
82170>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82170>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82170>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82170>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
82170>>>>>//            Move True               to ColumnType[i].bCanEditSize
82170>>>>>//            Increment i
82170>>>>>
82170>>>>>        End
82170>>>>>>
82170>>>>>
82170>>>>>        Function_Return aColumnType
82171>>>>>    End_Function
82172>>>>>
82172>>>>>    // MySQL Data Types
82172>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
82174>>>>>        tColumnType[] aColumnType
82174>>>>>        tColumnType[] aColumnType
82175>>>>>        Integer i
82175>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
82175>>>>>>// Generated By The Database Update Framework
82175>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
82175>>>>>>// Driver COLUMN DATA TYPES
82175>>>>>>//
82175>>>>>>// Created: 2018-03-14 23:46:49.593
82175>>>>>>
82175>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82176>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82177>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82178>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82179>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82180>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82181>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82182>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82183>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82184>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82185>>>>>>            Increment i
82186>>>>>>
82186>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82187>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82188>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82189>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82190>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82191>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82192>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
82193>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82194>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82195>>>>>>            Move 64                                      to aColumnType[i].sPrecision
82196>>>>>>            Increment i
82197>>>>>>
82197>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82198>>>>>>            Move 252                                     to aColumnType[i].iSQLType
82199>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82200>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82201>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82202>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82203>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82204>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82205>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82206>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82207>>>>>>            Increment i
82208>>>>>>
82208>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82209>>>>>>            Move 254                                     to aColumnType[i].iSQLType
82210>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82211>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82212>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82213>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82214>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82215>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82216>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82217>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82218>>>>>>            Increment i
82219>>>>>>
82219>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82220>>>>>>            Move 10                                      to aColumnType[i].iSQLType
82221>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82222>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82223>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82224>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82225>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82226>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82227>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82228>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82229>>>>>>            Increment i
82230>>>>>>
82230>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82231>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82232>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82233>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82234>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82235>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82236>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82237>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82238>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82239>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82240>>>>>>            Increment i
82241>>>>>>
82241>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82242>>>>>>            Move 246                                     to aColumnType[i].iSQLType
82243>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82244>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82245>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82246>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82247>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82248>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82249>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82250>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82251>>>>>>            Increment i
82252>>>>>>
82252>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
82253>>>>>>            Move 0                                       to aColumnType[i].iSQLType
82254>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82255>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82256>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82257>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82258>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82259>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82260>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82261>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82262>>>>>>            Increment i
82263>>>>>>
82263>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82264>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82265>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82266>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82267>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82268>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82269>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82270>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82271>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82272>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82273>>>>>>            Increment i
82274>>>>>>
82274>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
82275>>>>>>            Move 247                                     to aColumnType[i].iSQLType
82276>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82277>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82278>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82279>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82280>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82281>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82282>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82283>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82284>>>>>>            Increment i
82285>>>>>>
82285>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82286>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82287>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82288>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82289>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82290>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82291>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82292>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82293>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82294>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82295>>>>>>            Increment i
82296>>>>>>
82296>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82297>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82298>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82299>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82300>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82301>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82302>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82303>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82304>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82305>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82306>>>>>>            Increment i
82307>>>>>>
82307>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
82308>>>>>>            Move 251                                     to aColumnType[i].iSQLType
82309>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82310>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82311>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82312>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82313>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82314>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82315>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82316>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82317>>>>>>            Increment i
82318>>>>>>
82318>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
82319>>>>>>            Move -251                                    to aColumnType[i].iSQLType
82320>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82321>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82322>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82323>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82324>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82325>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82326>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82327>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82328>>>>>>            Increment i
82329>>>>>>
82329>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
82330>>>>>>            Move 250                                     to aColumnType[i].iSQLType
82331>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82332>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82333>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82334>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82335>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82336>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82337>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82338>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82339>>>>>>            Increment i
82340>>>>>>
82340>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
82341>>>>>>            Move 9                                       to aColumnType[i].iSQLType
82342>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82343>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82344>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
82345>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82346>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
82347>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82348>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82349>>>>>>            Move 9                                       to aColumnType[i].sPrecision
82350>>>>>>            Increment i
82351>>>>>>
82351>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
82352>>>>>>            Move -250                                    to aColumnType[i].iSQLType
82353>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82354>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82355>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82356>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82357>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82358>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82359>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82360>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82361>>>>>>            Increment i
82362>>>>>>
82362>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
82363>>>>>>            Move 248                                     to aColumnType[i].iSQLType
82364>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82365>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82366>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82367>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82368>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82369>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82370>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82371>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82372>>>>>>            Increment i
82373>>>>>>
82373>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82374>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82375>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82376>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82377>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82378>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82379>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82380>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82381>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82382>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82383>>>>>>            Increment i
82384>>>>>>
82384>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82385>>>>>>            Move -252                                    to aColumnType[i].iSQLType
82386>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82387>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82388>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82389>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82390>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82391>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82392>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82393>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82394>>>>>>            Increment i
82395>>>>>>
82395>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82396>>>>>>            Move 11                                      to aColumnType[i].iSQLType
82397>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82398>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82399>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82400>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82401>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82402>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82403>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82404>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82405>>>>>>            Increment i
82406>>>>>>
82406>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82407>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82408>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82409>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82410>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82411>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82412>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82413>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82414>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82415>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82416>>>>>>            Increment i
82417>>>>>>
82417>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
82418>>>>>>            Move 249                                     to aColumnType[i].iSQLType
82419>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82420>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82421>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82422>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82423>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82424>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82425>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82426>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82427>>>>>>            Increment i
82428>>>>>>
82428>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82429>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82430>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82431>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82432>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82433>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82434>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
82435>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82436>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82437>>>>>>            Move 4                                       to aColumnType[i].sPrecision
82438>>>>>>            Increment i
82439>>>>>>
82439>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
82440>>>>>>            Move -249                                    to aColumnType[i].iSQLType
82441>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82442>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82443>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82444>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82445>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82446>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82447>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82448>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82449>>>>>>            Increment i
82450>>>>>>
82450>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82451>>>>>>            Move 253                                     to aColumnType[i].iSQLType
82452>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82453>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82454>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82455>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82456>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82457>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82458>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82459>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82460>>>>>>            Increment i
82461>>>>>>
82461>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
82462>>>>>>            Move 13                                      to aColumnType[i].iSQLType
82463>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82464>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82465>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82466>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82467>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82468>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82469>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82470>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82471>>>>>>            Increment i
82472>>>>>>
82472>>>>>>
82472>>>>>
82472>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
82472>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
82472>>>>>//        Move "bit"              to ColumnType[i].sSQLType
82472>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82472>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82472>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82472>>>>>//        Move True               to ColumnType[i].bCanEditSize
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
82472>>>>>//        Move "blob"             to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82472>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82472>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
82472>>>>>//        Move "char"             to ColumnType[i].sSQLType
82472>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82472>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82472>>>>>//        Move "254"              to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
82472>>>>>//        Move "date"             to ColumnType[i].sSQLType
82472>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82472>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82472>>>>>//        Move True               to ColumnType[i].bCanEditSize
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
82472>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
82472>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82472>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82472>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82472>>>>>//        Move True               to ColumnType[i].bCanEditSize
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
82472>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
82472>>>>>//        Move "double"           to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
82472>>>>>//        Move "enum"             to ColumnType[i].sSQLType
82472>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82472>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82472>>>>>//        Move "254"              to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
82472>>>>>//        Move "float"            to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82472>>>>>//        Move "int"              to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
82472>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82472>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
82472>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
82472>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82472>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
82472>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82472>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82472>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82472>>>>>//
82472>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
82472>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
82472>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82472>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
82472>>>>>//        Move "set"              to ColumnType[i].sSQLType
82472>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82472>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82472>>>>>//        Move "254"              to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
82472>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
82472>>>>>//        Move "text"             to ColumnType[i].sSQLType
82472>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82472>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
82472>>>>>//        Move "time"             to ColumnType[i].sSQLType
82472>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82472>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82472>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
82472>>>>>//        Move True               to ColumnType[i].bCanEditSize
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
82472>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
82472>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82472>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82472>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82472>>>>>//        Move True               to ColumnType[i].bCanEditSize
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
82472>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82472>>>>>//        Move "254"              to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
82472>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
82472>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
82472>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82472>>>>>//        Move "254"              to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
82472>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
82472>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82472>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82472>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82472>>>>>//        Increment i
82472>>>>>//
82472>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
82472>>>>>//        Move "year"             to ColumnType[i].sSQLType
82472>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82472>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82472>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82472>>>>>//        Move True               to ColumnType[i].bCanEditSize
82472>>>>>//        Increment i
82472>>>>>
82472>>>>>        Function_Return aColumnType
82473>>>>>    End_Function
82474>>>>>
82474>>>>>    // Oracle Data Types
82474>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
82476>>>>>        tColumnType[] aColumnType
82476>>>>>        tColumnType[] aColumnType
82477>>>>>        Integer i
82477>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
82477>>>>>>// Generated By The Database Update Framework
82477>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
82477>>>>>>// Driver COLUMN DATA TYPES
82477>>>>>>//
82477>>>>>>// Created: 2018-03-14 23:47:34.82
82477>>>>>>
82477>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82478>>>>>>            Move 113                                     to aColumnType[i].iSQLType
82479>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82480>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82481>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82482>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82483>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82484>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82485>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82486>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82487>>>>>>            Increment i
82488>>>>>>
82488>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82489>>>>>>            Move 96                                      to aColumnType[i].iSQLType
82490>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82491>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82492>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82493>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82494>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82495>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82496>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82497>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82498>>>>>>            Increment i
82499>>>>>>
82499>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
82500>>>>>>            Move 112                                     to aColumnType[i].iSQLType
82501>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82502>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82503>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82504>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82505>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82506>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82507>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82508>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82509>>>>>>            Increment i
82510>>>>>>
82510>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82511>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82512>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82513>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82514>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82515>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82516>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82517>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82518>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82519>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82520>>>>>>            Increment i
82521>>>>>>
82521>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82522>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82523>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82524>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82525>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82526>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82527>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82528>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82529>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82530>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82531>>>>>>            Increment i
82532>>>>>>
82532>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82533>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82534>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82535>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82536>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82537>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82538>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82539>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82540>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82541>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82542>>>>>>            Increment i
82543>>>>>>
82543>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
82544>>>>>>            Move 190                                     to aColumnType[i].iSQLType
82545>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82546>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82547>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82548>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82549>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82550>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82551>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82552>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82553>>>>>>            Increment i
82554>>>>>>
82554>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
82555>>>>>>            Move 189                                     to aColumnType[i].iSQLType
82556>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82557>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82558>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82559>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82560>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82561>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82562>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82563>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82564>>>>>>            Increment i
82565>>>>>>
82565>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
82566>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82567>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82568>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82569>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82570>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82571>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82572>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82573>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82574>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82575>>>>>>            Increment i
82576>>>>>>
82576>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
82577>>>>>>            Move 24                                      to aColumnType[i].iSQLType
82578>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82579>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82580>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82581>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82582>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82583>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82584>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82585>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82586>>>>>>            Increment i
82587>>>>>>
82587>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82588>>>>>>            Move 286                                     to aColumnType[i].iSQLType
82589>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82590>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82591>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82592>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82593>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82594>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82595>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82596>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82597>>>>>>            Increment i
82598>>>>>>
82598>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
82599>>>>>>            Move 288                                     to aColumnType[i].iSQLType
82600>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82601>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82602>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82603>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82604>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82605>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82606>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82607>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82608>>>>>>            Increment i
82609>>>>>>
82609>>>>>>            Move "number"                                to aColumnType[i].sSQLType
82610>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82611>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82612>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82613>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82614>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82615>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82616>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82617>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82618>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82619>>>>>>            Increment i
82620>>>>>>
82620>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
82621>>>>>>            Move 287                                     to aColumnType[i].iSQLType
82622>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82623>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82624>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82625>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82626>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82627>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82628>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82629>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82630>>>>>>            Increment i
82631>>>>>>
82631>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
82632>>>>>>            Move 23                                      to aColumnType[i].iSQLType
82633>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82634>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82635>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82636>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82637>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82638>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82639>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82640>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82641>>>>>>            Increment i
82642>>>>>>
82642>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82643>>>>>>            Move 187                                     to aColumnType[i].iSQLType
82644>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82645>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82646>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82647>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82648>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82649>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82650>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82651>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82652>>>>>>            Increment i
82653>>>>>>
82653>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
82654>>>>>>            Move 232                                     to aColumnType[i].iSQLType
82655>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82656>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82657>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82658>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82659>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82660>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82661>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82662>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82663>>>>>>            Increment i
82664>>>>>>
82664>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
82665>>>>>>            Move 188                                     to aColumnType[i].iSQLType
82666>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82667>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82668>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82669>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82670>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82671>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82672>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82673>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82674>>>>>>            Increment i
82675>>>>>>
82675>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
82676>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82677>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82678>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82679>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82680>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82681>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82682>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82683>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82684>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82685>>>>>>            Increment i
82686>>>>>>
82686>>>>>>
82686>>>>>
82686>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
82686>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
82686>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82686>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
82686>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
82686>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "2000"             to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
82686>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
82686>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
82686>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
82686>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82686>>>>>//        Move True               to ColumnType[i].bCanEditSize
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
82686>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
82686>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
82686>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
82686>>>>>//        Move "INT"              to ColumnType[i].sSQLType
82686>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
82686>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
82686>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
82686>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82686>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82686>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82686>>>>>//        Move True               to ColumnType[i].bCanEditSize
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
82686>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
82686>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
82686>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
82686>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
82686>>>>>//        Move True                to ColumnType[i].bCanEditSize
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
82686>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
82686>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82686>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
82686>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
82686>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82686>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
82686>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
82686>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "2000"             to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
82686>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
82686>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
82686>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
82686>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
82686>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
82686>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
82686>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "4000"             to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
82686>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
82686>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82686>>>>>//        Move "2000"             to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
82686>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
82686>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
82686>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
82686>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82686>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82686>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
82686>>>>>//        Move True               to ColumnType[i].bCanEditSize
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
82686>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
82686>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
82686>>>>>//        Move True                   to ColumnType[i].bCanEditSize
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
82686>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
82686>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
82686>>>>>//        Move True                   to ColumnType[i].bCanEditSize
82686>>>>>//        Increment i
82686>>>>>//
82686>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
82686>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
82686>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82686>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82686>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82686>>>>>
82686>>>>>        Function_Return aColumnType
82687>>>>>    End_Function
82688>>>>>
82688>>>>>    // PostgreSQL Data Types
82688>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
82690>>>>>        tColumnType[] aColumnType
82690>>>>>        tColumnType[] aColumnType
82691>>>>>        Integer i
82691>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
82691>>>>>>// Generated By The Database Update Framework
82691>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
82691>>>>>>// Driver COLUMN DATA TYPES
82691>>>>>>//
82691>>>>>>// Created: 2018-03-14 23:47:02.984
82691>>>>>>
82691>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82692>>>>>>            Move 20                                      to aColumnType[i].iSQLType
82693>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82694>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82695>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82696>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82697>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82698>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82699>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82700>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82701>>>>>>            Increment i
82702>>>>>>
82702>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82703>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
82704>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82705>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82706>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82707>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82708>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82709>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82710>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82711>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82712>>>>>>            Increment i
82713>>>>>>
82713>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
82714>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82715>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82716>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82717>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82718>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82719>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82720>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82721>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82722>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82723>>>>>>            Increment i
82724>>>>>>
82724>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
82725>>>>>>            Move 17                                      to aColumnType[i].iSQLType
82726>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82727>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82728>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82729>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82730>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82731>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82732>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82733>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82734>>>>>>            Increment i
82735>>>>>>
82735>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82736>>>>>>            Move 18                                      to aColumnType[i].iSQLType
82737>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82738>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82739>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82740>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82741>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82742>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82743>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82744>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82745>>>>>>            Increment i
82746>>>>>>
82746>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
82747>>>>>>            Move -25                                     to aColumnType[i].iSQLType
82748>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82749>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82750>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82751>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82752>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82753>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82754>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82755>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82756>>>>>>            Increment i
82757>>>>>>
82757>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82758>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
82759>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82760>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82761>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82762>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82763>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82764>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82765>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82766>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82767>>>>>>            Increment i
82768>>>>>>
82768>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82769>>>>>>            Move 701                                     to aColumnType[i].iSQLType
82770>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82771>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82772>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82773>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82774>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82775>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82776>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82777>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82778>>>>>>            Increment i
82779>>>>>>
82779>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
82780>>>>>>            Move 23                                      to aColumnType[i].iSQLType
82781>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82782>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82783>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
82784>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82785>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82786>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82787>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82788>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82789>>>>>>            Increment i
82790>>>>>>
82790>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82791>>>>>>            Move 790                                     to aColumnType[i].iSQLType
82792>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82793>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82794>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
82795>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82796>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
82797>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82798>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82799>>>>>>            Move 30                                      to aColumnType[i].sPrecision
82800>>>>>>            Increment i
82801>>>>>>
82801>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82802>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
82803>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82804>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82805>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82806>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82807>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82808>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82809>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82810>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82811>>>>>>            Increment i
82812>>>>>>
82812>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
82813>>>>>>            Move 26                                      to aColumnType[i].iSQLType
82814>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82815>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82816>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
82817>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82818>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82819>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82820>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82821>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82822>>>>>>            Increment i
82823>>>>>>
82823>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82824>>>>>>            Move 700                                     to aColumnType[i].iSQLType
82825>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82826>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82827>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82828>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82829>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82830>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82831>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82832>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82833>>>>>>            Increment i
82834>>>>>>
82834>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
82835>>>>>>            Move 24                                      to aColumnType[i].iSQLType
82836>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82837>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82838>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
82839>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82840>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82841>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82842>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82843>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82844>>>>>>            Increment i
82845>>>>>>
82845>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82846>>>>>>            Move 21                                      to aColumnType[i].iSQLType
82847>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82848>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82849>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82850>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82851>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82852>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82853>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82854>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82855>>>>>>            Increment i
82856>>>>>>
82856>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82857>>>>>>            Move 25                                      to aColumnType[i].iSQLType
82858>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82859>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82860>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82861>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82862>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82863>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82864>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82865>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82866>>>>>>            Increment i
82867>>>>>>
82867>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82868>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
82869>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82870>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82871>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
82872>>>>>>            Move 8                                       to aColumnType[i].iMinSize
82873>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
82874>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82875>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82876>>>>>>            Move 15                                      to aColumnType[i].sPrecision
82877>>>>>>            Increment i
82878>>>>>>
82878>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82879>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
82880>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82881>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82882>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82883>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82884>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82885>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82886>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82887>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82888>>>>>>            Increment i
82889>>>>>>
82889>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
82890>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
82891>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82892>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82893>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82894>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82895>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82896>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82897>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82898>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82899>>>>>>            Increment i
82900>>>>>>
82900>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
82901>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
82902>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82903>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82904>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
82905>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82906>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82907>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82908>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82909>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82910>>>>>>            Increment i
82911>>>>>>
82911>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
82912>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
82913>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82914>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82915>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82916>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82917>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82918>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82919>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82920>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82921>>>>>>            Increment i
82922>>>>>>
82922>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82923>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
82924>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82925>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82926>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82927>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82928>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82929>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82930>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82931>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82932>>>>>>            Increment i
82933>>>>>>
82933>>>>>>
82933>>>>>
82933>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
82933>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82933>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82933>>>>>//        Move True               to ColumnType[i].bCanEditSize
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
82933>>>>>//        Move "bit"              to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
82933>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
82933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82933>>>>>//        Move "1"                to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
82933>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
82933>>>>>//        Move "char"             to ColumnType[i].sSQLType
82933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82933>>>>>//        Move "2000"             to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
82933>>>>>//        Move "citext"           to ColumnType[i].sSQLType
82933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82933>>>>>//        Move "254"              to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
82933>>>>>//        Move "date"             to ColumnType[i].sSQLType
82933>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82933>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82933>>>>>//        Move True               to ColumnType[i].bCanEditSize
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
82933>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
82933>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
82933>>>>>//        Move "double"           to ColumnType[i].sSQLType
82933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82933>>>>>//        Move "22"               to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
82933>>>>>//        Move "integer"          to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82933>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
82933>>>>>//        Move "money"            to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82933>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
82933>>>>>//        Move "oid"              to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
82933>>>>>//        Move "real"             to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
82933>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
82933>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
82933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82933>>>>>//        Move "64"               to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
82933>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
82933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82933>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
82933>>>>>//        Move "text"             to ColumnType[i].sSQLType
82933>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82933>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
82933>>>>>//        Move "time"             to ColumnType[i].sSQLType
82933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82933>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82933>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
82933>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
82933>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82933>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82933>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82933>>>>>//        Move True               to ColumnType[i].bCanEditSize
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
82933>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
82933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82933>>>>>//        Move "40"               to ColumnType[i].sPrecision
82933>>>>>//        Move True               to ColumnType[i].bCanEditSize
82933>>>>>//        Increment i
82933>>>>>//
82933>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
82933>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
82933>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82933>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
82933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82933>>>>>//        Increment i
82933>>>>>
82933>>>>>        Function_Return aColumnType
82934>>>>>    End_Function
82935>>>>>
82935>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
82935>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
82937>>>>>        Integer iValue iSize iCount iStart
82937>>>>>        tColumnType[] ColumnTypeArray
82937>>>>>        tColumnType[] ColumnTypeArray
82938>>>>>        tColumnType RetvalType
82938>>>>>        tColumnType RetvalType
82938>>>>>        String sValue
82938>>>>>        Boolean bFrameworkDataFlexType
82938>>>>>
82938>>>>>        Move "Undefined" to RetvalType.sSQLType
82939>>>>>        Move -1999       to RetvalType.iSQLType
82940>>>>>
82940>>>>>        Move 0 to iStart
82941>>>>>        Move (Uppercase(sType)) to sType
82942>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
82943>>>>>        If (bFrameworkDataFlexType = True) Begin
82945>>>>>            Get _UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
82946>>>>>            Function_Return RetvalType
82947>>>>>        End
82947>>>>>>
82947>>>>>
82947>>>>>        Get _UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
82948>>>>>
82948>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
82949>>>>>        Decrement iSize
82950>>>>>
82950>>>>>        For iCount from iStart to iSize
82956>>>>>>
82956>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
82957>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
82958>>>>>            If (bIntegerInputType = True) Begin
82960>>>>>                If (iValue = iType) Begin
82962>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
82963>>>>>                    Move iType                                  to RetvalType.iSQLType
82964>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
82965>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
82966>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
82967>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
82968>>>>>                    Move iSize to iCount // We're done!
82969>>>>>                End
82969>>>>>>
82969>>>>>            End
82969>>>>>>
82969>>>>>            Else Begin
82970>>>>>                Move (Uppercase(sValue)) to sValue
82971>>>>>                If (sValue = sType) Begin
82973>>>>>                    Move sType                                  to RetvalType.sSQLType
82974>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
82975>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
82976>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
82977>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
82978>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
82979>>>>>                    Move iSize to iCount // We're done!
82980>>>>>                End
82980>>>>>>
82980>>>>>            End
82980>>>>>>
82980>>>>>        Loop
82981>>>>>>
82981>>>>>
82981>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
82981>>>>>        // In which case we search for a match in DataFlex standard types:
82981>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
82983>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
82984>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
82985>>>>>            Decrement iSize
82986>>>>>
82986>>>>>            For iCount from iStart to iSize
82992>>>>>>
82992>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
82993>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
82994>>>>>                If (iValue = iType) Begin
82996>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
82997>>>>>                    Move iType                                  to RetvalType.iSQLType
82998>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
82999>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83000>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83001>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83002>>>>>                    Move iSize to iCount // We're done!
83003>>>>>                End
83003>>>>>>
83003>>>>>            Loop
83004>>>>>>
83004>>>>>        End
83004>>>>>>
83004>>>>>
83004>>>>>        Function_Return RetvalType
83005>>>>>    End_Function
83006>>>>>
83006>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
83006>>>>>    Function _UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
83008>>>>>        tColumnType[] ColumnType
83008>>>>>        tColumnType[] ColumnType
83009>>>>>
83009>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
83009>>>>>        // the dbType.
83009>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83011>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
83013>>>>>                Move ODBC_DRV_ID to sDriverID
83014>>>>>            End
83014>>>>>>
83014>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
83016>>>>>                Move MSSQLDRV_ID to sDriverID
83017>>>>>            End
83017>>>>>>
83017>>>>>            If (iDbType = EN_DbTypeDB2) Begin
83019>>>>>                Move DB2_DRV_ID to sDriverID
83020>>>>>            End
83020>>>>>>
83020>>>>>            If (iDbType = EN_DbTypePostgre) Begin
83022>>>>>                Move ODBC_DRV_ID to sDriverID
83023>>>>>            End
83023>>>>>>
83023>>>>>        End
83023>>>>>>
83023>>>>>
83023>>>>>        Case Begin
83023>>>>>            Case (iDbType = EN_dbTypeDataFlex)
83025>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
83026>>>>>                Case Break
83027>>>>>
83027>>>>>            Case (iDbType = EN_DbTypeDB2)
83030>>>>>                Get _UtilEnumerateDB2Types to ColumnType
83031>>>>>                Case Break
83032>>>>>
83032>>>>>            Case (iDbType = EN_DbTypeMSSQL)
83035>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
83036>>>>>                Case Break
83037>>>>>        Case End
83037>>>>>
83037>>>>>        Function_Return ColumnType
83038>>>>>    End_Function
83039>>>>>
83039>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
83039>>>>>    // are mapped to a DUF data type.
83039>>>>>    Function _UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
83041>>>>>        tColumnType ColumnType
83041>>>>>        tColumnType ColumnType
83041>>>>>        String sDataType
83041>>>>>        Integer iDriverID iCount
83041>>>>>
83041>>>>>        Move 0 to iCount
83042>>>>>        Get DriverIndex sDriverID to iDriverID
83043>>>>>
83043>>>>>        Case Begin
83043>>>>>            // DF_ASCII
83043>>>>>            Case (iType = DF_ASCII_DUF)
83045>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83047>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
83050>>>>>                End
83050>>>>>>
83050>>>>>                Else Begin
83051>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
83054>>>>>                End
83054>>>>>>
83054>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
83055>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
83056>>>>>                Move sDataType   to ColumnType.sSQLType
83057>>>>>                Move DF_ASCII    to ColumnType.iSQLType
83058>>>>>                Move False       to ColumnType.bCanEditSize
83059>>>>>                Case Break
83060>>>>>
83060>>>>>            // DF_BINARY
83060>>>>>            Case (iType = DF_BINARY_DUF)
83063>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83065>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
83068>>>>>                End
83068>>>>>>
83068>>>>>                Else Begin
83069>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
83072>>>>>                End
83072>>>>>>
83072>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
83073>>>>>                Move "Binary"    to ColumnType.sDataFlexType
83074>>>>>                Move sDataType   to ColumnType.sSQLType
83075>>>>>                Move DF_BINARY   to ColumnType.iSQLType
83076>>>>>                Move False       to ColumnType.bCanEditSize
83077>>>>>                Case Break
83078>>>>>
83078>>>>>            // DF_DATE
83078>>>>>            Case (iType = DF_DATE_DUF)
83081>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83083>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83086>>>>>                End
83086>>>>>>
83086>>>>>                Else Begin
83087>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83090>>>>>                End
83090>>>>>>
83090>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
83091>>>>>                Move "Date"      to ColumnType.sDataFlexType
83092>>>>>                Move sDataType   to ColumnType.sSQLType
83093>>>>>                Move DF_DATE     to ColumnType.iSQLType
83094>>>>>                Move True        to ColumnType.bCanEditSize
83095>>>>>                Case Break
83096>>>>>
83096>>>>>            // DF_DATETIME
83096>>>>>            Case (iType = DF_DATETIME_DUF)
83099>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83101>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
83104>>>>>                End
83104>>>>>>
83104>>>>>                Else Begin
83105>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
83108>>>>>                End
83108>>>>>>
83108>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
83109>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
83110>>>>>                Move sDataType   to ColumnType.sSQLType
83111>>>>>                Move DF_DATETIME to ColumnType.iSQLType
83112>>>>>                Move True        to ColumnType.bCanEditSize
83113>>>>>                Case Break
83114>>>>>
83114>>>>>            // DF_NUMERIC
83114>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
83114>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
83114>>>>>            // we make them here all "Numeric"...
83114>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
83114>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83114>>>>>            // End
83114>>>>>            // Else Begin
83114>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83114>>>>>            // End
83114>>>>>            // ToDo: How should we find the best "Numeric" data type here?
83114>>>>>            Case (iType = DF_BCD_DUF)
83117>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
83118>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
83119>>>>>                Move "Numeric"   to ColumnType.sSQLType
83120>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
83121>>>>>                Move False       to ColumnType.bCanEditSize
83122>>>>>                Case Break
83123>>>>>
83123>>>>>            // DF_TEXT
83123>>>>>            Case (iType = DF_TEXT_DUF)
83126>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83128>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
83131>>>>>                End
83131>>>>>>
83131>>>>>                Else Begin
83132>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
83135>>>>>                End
83135>>>>>>
83135>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
83136>>>>>                Move "Text"      to ColumnType.sDataFlexType
83137>>>>>                Move sDataType   to ColumnType.sSQLType
83138>>>>>                Move DF_TEXT     to ColumnType.iSQLType
83139>>>>>                Move False       to ColumnType.bCanEditSize
83140>>>>>                Case Break
83141>>>>>
83141>>>>>            Case Else
83141>>>>>                Move -1999       to ColumnType.iDataFlexType
83142>>>>>                Move "Undefined" to ColumnType.sDataFlexType
83143>>>>>                Move "Undefined" to ColumnType.sSQLType
83144>>>>>                Move -1999       to ColumnType.iSQLType
83145>>>>>                Move True        to ColumnType.bCanEditSize
83146>>>>>
83146>>>>>        Case End
83146>>>>>
83146>>>>>        Function_Return ColumnType
83147>>>>>    End_Function
83148>>>>>
83148>>>>>    Function _AllTablesToConvert Returns Integer[]
83150>>>>>        Integer[] aTableConvertExceptions iTablesArray
83152>>>>>        Handle hTable
83152>>>>>        Integer iIndex
83152>>>>>        String sTableName
83152>>>>>        Boolean bFlexErrs
83152>>>>>
83152>>>>>        // a) Get the exception table array the developer has specified
83152>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
83153>>>>>
83153>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
83153>>>>>        Repeat
83153>>>>>>
83153>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83156>>>>>            If (hTable <> 0) Begin
83158>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83161>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83162>>>>>                If (bFlexErrs = False) Begin
83164>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
83166>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83167>>>>>                        If (iIndex = -1) Begin
83169>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
83170>>>>>                        End
83170>>>>>>
83170>>>>>                    End
83170>>>>>>
83170>>>>>                End
83170>>>>>>
83170>>>>>            End
83170>>>>>>
83170>>>>>        Until (hTable = 0)
83172>>>>>
83172>>>>>        Move 0 to hTable
83173>>>>>
83173>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83173>>>>>        Repeat
83173>>>>>>
83173>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83176>>>>>            If (hTable > 0) Begin
83178>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83181>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83182>>>>>                If (bFlexErrs = False) Begin
83184>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83185>>>>>                    If (iIndex = -1) Begin
83187>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83188>>>>>                    End
83188>>>>>>
83188>>>>>                End
83188>>>>>>
83188>>>>>            End
83188>>>>>>
83188>>>>>        Until (hTable = 0)
83190>>>>>
83190>>>>>        Function_Return iTablesArray
83191>>>>>    End_Function
83192>>>>>
83192>>>>>    Function _AllTablesDateCorrections Returns Integer[]
83194>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
83196>>>>>        Handle hTable
83196>>>>>        Integer iIndex
83196>>>>>        String sTableName
83196>>>>>        Boolean bFlexErrs
83196>>>>>
83196>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83197>>>>>        Move 0 to hTable
83198>>>>>
83198>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83198>>>>>        Repeat
83198>>>>>>
83198>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83201>>>>>            If (hTable > 0) Begin
83203>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83206>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83207>>>>>                If (bFlexErrs = False) Begin
83209>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
83210>>>>>                    If (iIndex = -1) Begin
83212>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83213>>>>>                    End
83213>>>>>>
83213>>>>>                End
83213>>>>>>
83213>>>>>            End
83213>>>>>>
83213>>>>>        Until (hTable = 0)
83215>>>>>
83215>>>>>        Function_Return iTablesArray
83216>>>>>    End_Function
83217>>>>>
83217>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
83219>>>>>        tAPIColumn NewAPIColumn
83219>>>>>        tAPIColumn NewAPIColumn
83219>>>>>
83219>>>>>        Move sFieldName to NewAPIColumn.sFieldName
83220>>>>>        Move iType      to NewAPIColumn.iType
83221>>>>>        Move iLength    to NewAPIColumn.iLength
83222>>>>>        Move iPrecision to NewAPIColumn.iPrecision
83223>>>>>        Move iOptions   to NewAPIColumn.iOptions
83224>>>>>
83224>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
83225>>>>>
83225>>>>>        Function_Return aCurrent
83226>>>>>    End_Function
83227>>>>>
83227>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
83229>>>>>        String sRetval sFieldName
83229>>>>>        Integer iCount iSize
83229>>>>>
83229>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
83230>>>>>        Decrement iSize
83231>>>>>        For iCount from 0 to iSize
83237>>>>>>
83237>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
83238>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
83239>>>>>        Loop
83240>>>>>>
83240>>>>>        Move (Trim(sRetval)) to sRetval
83241>>>>>
83241>>>>>        Function_Return sRetval
83242>>>>>    End_Function
83243>>>>>
83243>>>>>    // *** Miscellaneous other functions ***
83243>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
83243>>>>>    //
83243>>>>>
83243>>>>>    // Callback functionality used when e.g. calling driver functions directly.
83243>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
83245>>>>>        Integer iPerc
83245>>>>>        Number nReady nTotal
83245>>>>>
83245>>>>>        Send DoAdvance of ghoProgressBar
83246>>>>>
83246>>>>>        If (sCallback_Text contains "Copy records") Begin
83248>>>>>            Move CS_DUF_CopyingData to sCallback_Text
83249>>>>>        End
83249>>>>>>
83249>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
83251>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83252>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83253>>>>>        End
83253>>>>>>
83253>>>>>        If (sCallback_Text contains "Creating index") Begin
83255>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
83256>>>>>        End
83256>>>>>>
83256>>>>>
83256>>>>>        Case Begin
83256>>>>>            Case (iCallback_Type = DF_Message_Text)
83258>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83259>>>>>                Set Action_Text  of ghoStatusPanel to ""
83260>>>>>                Case Break
83261>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
83264>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83265>>>>>                Set Action_Text  of ghoStatusPanel to ""
83266>>>>>                Case Break
83267>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
83270>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83271>>>>>                Set Action_Text  of ghoStatusPanel to ""
83272>>>>>                Case Break
83273>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
83276>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83277>>>>>                Set Action_Text  of ghoStatusPanel to ""
83278>>>>>                Case Break
83279>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
83282>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83283>>>>>                Set Action_Text  of ghoStatusPanel to ""
83284>>>>>                Case Break
83285>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
83288>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83289>>>>>                Set Action_Text  of ghoStatusPanel to ""
83290>>>>>                Case Break
83291>>>>>            Case (iCallback_Type = DF_Message_Warning)
83294>>>>>                Send None
83295>>>>>                Case Break
83296>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
83299>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83300>>>>>                Set Action_Text  of ghoStatusPanel to ""
83301>>>>>                Case Break
83302>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
83305>>>>>                //*** Interpret numbers
83305>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
83306>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
83307>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
83308>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
83309>>>>>                Case Break
83310>>>>>            Case Else
83310>>>>>                Set Message_Text to ""
83311>>>>>                Set Action_Text  to ""
83312>>>>>        Case End
83312>>>>>
83312>>>>>        Send ProcessEvents of ghoStatusPanel
83313>>>>>        Function_Return False
83314>>>>>    End_Function
83315>>>>>
83315>>>>>    // * Dummy function for the Studio's Code Explorer *
83315>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
83317>>>>>        Function_Return False
83318>>>>>    End_Function
83319>>>>>
83319>>>>>    // *** Helper functions with compiled sql script code ***
83319>>>>>    //
83319>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
83319>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83319>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
83319>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
83319>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83319>>>>>    //   ALTER TABLE MyTable
83319>>>>>    //       REBUILD
83319>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
83321>>>>>        Boolean bOK
83321>>>>>
83321>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83323>>>>>            Function_Return False
83324>>>>>        End
83324>>>>>>
83324>>>>>
83324>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
83324>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
83325>>>>>
83325>>>>>        Function_Return (bOK = True)
83326>>>>>    End_Function
83327>>>>>
83327>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
83327>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83327>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
83327>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
83327>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83327>>>>>    //   ALTER TABLE MyTable
83327>>>>>    //       REBUILD
83327>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
83329>>>>>        tSQLScriptArray SQLScriptArray
83329>>>>>        tSQLScriptArray SQLScriptArray
83329>>>>>        String sDriverID
83329>>>>>        Boolean bOK
83329>>>>>        Integer iSize iCount
83329>>>>>
83329>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83331>>>>>            Function_Return False
83332>>>>>        End
83332>>>>>>
83332>>>>>
83332>>>>>        Get psDriverID to sDriverID
83333>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83334>>>>>        If (SQLScriptArray.bError = True) Begin
83336>>>>>            Function_Return False
83337>>>>>        End
83337>>>>>>
83337>>>>>
83337>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83338>>>>>        Decrement iSize
83339>>>>>
83339>>>>>        For iCount from 0 to iSize
83345>>>>>>
83345>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
83347>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
83348>>>>>            End
83348>>>>>>
83348>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
83350>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
83351>>>>>            End
83351>>>>>>
83351>>>>>        Loop
83352>>>>>>
83352>>>>>
83352>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83353>>>>>
83353>>>>>        Function_Return (bOK = True)
83354>>>>>    End_Function
83355>>>>>
83355>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
83355>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
83355>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
83355>>>>>    Function _SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
83357>>>>>        Integer iChannel iArgumentSize iCount
83357>>>>>        Number nByteCount
83357>>>>>        String sSQLScript
83357>>>>>        tSQLScriptArray SqlScriptArray
83357>>>>>        tSQLScriptArray SqlScriptArray
83357>>>>>        UChar[] uCharData
83358>>>>>
83358>>>>>        Move False to Err
83359>>>>>        Get Seq_New_Channel to iChannel
83360>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83362>>>>>            Error DFERR_PROGRAM 'No channel available...'
83363>>>>>>
83363>>>>>            Move True to SqlScriptArray.bError
83364>>>>>            Function_Return SqlScriptArray
83365>>>>>        End
83365>>>>>>
83365>>>>>
83365>>>>>        // First decide the size of the script
83365>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83367>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
83369>>>>>        Close_Input channel iChannel
83371>>>>>
83371>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
83372>>>>>        If (nByteCount  < 1) Begin
83374>>>>>            Send Seq_Release_Channel iChannel
83375>>>>>            Move True to SqlScriptArray.bError
83376>>>>>            Function_Return SqlScriptArray
83377>>>>>        End
83377>>>>>>
83377>>>>>
83377>>>>>        // If necessary change the string argument_size
83377>>>>>        // Read the script file from memory line-by-line
83377>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83379>>>>>            Move 0 to iCount
83380>>>>>            Repeat
83380>>>>>>
83380>>>>>                Readln channel iChannel sSQLScript
83382>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
83383>>>>>                Increment iCount
83384>>>>>            Until (SeqEof = True)
83386>>>>>        Close_Input channel iChannel
83388>>>>>        Send Seq_Release_Channel iChannel
83389>>>>>
83389>>>>>        // Finally "sanitize" the script by removing all comments.
83389>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
83390>>>>>
83390>>>>>        Function_Return SqlScriptArray
83391>>>>>    End_Function
83392>>>>>
83392>>>>>    Function _SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
83394>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
83394>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
83394>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
83394>>>>>        String[] sMsg aSQLQueryMessages
83396>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
83396>>>>>        TimeSpan tsQuery
83396>>>>>        tSqlErrorArray aSqlErrorArray
83396>>>>>        tSqlErrorArray aSqlErrorArray
83396>>>>>        tSQLConnection SQLConnection
83396>>>>>        tSQLConnection SQLConnection
83396>>>>>        Boolean bShowProgress
83396>>>>>
83396>>>>>        If (num_arguments > 4) Begin
83398>>>>>            Move bShowProgr to bShowProgress
83399>>>>>        End
83399>>>>>>
83399>>>>>        Get phoSQLManager to hoSql
83400>>>>>
83400>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
83401>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
83401>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
83401>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
83401>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
83401>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
83401>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
83401>>>>>        Get piChunkMax to iChunkMax
83402>>>>>        Move 0 to iChunkCounter
83403>>>>>        Move "" to sStmt
83404>>>>>
83404>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
83405>>>>>        Move (Character(13) + Character(10)) to sCR
83406>>>>>
83406>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83407>>>>>
83407>>>>>        Get phoSQLManager  to hoSQL
83408>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83410>>>>>            If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
83412>>>>>                Move (Pos(";", SQLConnection.sConnectionString)) to iPos
83413>>>>>                If (iPos > 0) Begin
83415>>>>>                    Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
83416>>>>>                    Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
83417>>>>>                End
83417>>>>>>
83417>>>>>            End
83417>>>>>>
83417>>>>>        End
83417>>>>>>
83417>>>>>        Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
83418>>>>>        Get SqlConnect     of hoSQL "" "" to hoSQLConnect
83419>>>>>
83419>>>>>        If (hoSQLConnect <> 0) Begin
83421>>>>>            Move False to Err
83422>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
83423>>>>>            If (hoStmt <> 0) Begin
83425>>>>>
83425>>>>>                // If the embedded resource should be written as a script file to disk:
83425>>>>>                If (bCreateScriptFile = True) Begin
83427>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
83428>>>>>                    Get vFolderFormat sExportFile to sExportFile
83429>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
83430>>>>>                    Get Seq_New_Channel to iOut
83431>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83433>>>>>                        Direct_Output channel iOut sExportFile
83435>>>>>                    End
83435>>>>>>
83435>>>>>                End
83435>>>>>>
83435>>>>>
83435>>>>>                // Record starting date/time stamp
83435>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
83436>>>>>                // Turn on error handling if enabled
83436>>>>>                If (pbHandleQueryErrors(Self)) Begin
83438>>>>>                    Set pbSqlError to False
83439>>>>>                    Set paSqlErrorArray to aSqlErrorArray
83440>>>>>                    Move Error_Object_Id to hoError
83441>>>>>                    Move Self to Error_Object_Id
83442>>>>>                End
83442>>>>>>
83442>>>>>
83442>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
83443>>>>>                Decrement iRows
83444>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
83446>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
83447>>>>>                End
83447>>>>>>
83447>>>>>
83447>>>>>                for iCount from 0 to iRows
83453>>>>>>
83453>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
83454>>>>>
83454>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
83456>>>>>                        If (sSQLVal <> "") Begin
83458>>>>>                            Move (sSQLVal + sCR) to sSQLVal
83459>>>>>                        End
83459>>>>>>
83459>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
83460>>>>>                    End
83460>>>>>>
83460>>>>>
83460>>>>>                    // - Each time we encounter a "GO" statement we execute it,
83460>>>>>                    // or if at the very end of the script.
83460>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
83462>>>>>
83462>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
83462>>>>>                        // instead of all in one go.
83462>>>>>                        Send SqlExecDirect of hoStmt sStmt
83463>>>>>
83463>>>>>                        If (bCreateScriptFile = True) Begin
83465>>>>>                            Write channel iOut sStmt
83467>>>>>                        End
83467>>>>>>
83467>>>>>                        Move "" to sStmt
83468>>>>>                        Move 0 to iChunkCounter
83469>>>>>                    End
83469>>>>>>
83469>>>>>                    Increment iChunkCounter
83470>>>>>                Loop
83471>>>>>>
83471>>>>>
83471>>>>>                Repeat
83471>>>>>>
83471>>>>>                    If (pbHandleQueryErrors(Self)) Begin
83473>>>>>                        Move hoError to Error_Object_Id
83474>>>>>                    End
83474>>>>>>
83474>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
83475>>>>>
83475>>>>>                    Send _SqlColumnInfo hoStmt
83476>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
83477>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83478>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
83479>>>>>                    Set piRows    to iRows
83480>>>>>                    Set piRowType to iRowType
83481>>>>>
83481>>>>>                    If (iMsgs <> 0) Begin
83483>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83485>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83486>>>>>                        End
83486>>>>>>
83486>>>>>                        for i from 1 to iMsgs
83492>>>>>>
83492>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
83493>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
83494>>>>>                            If (bShowProgress = True) Begin
83496>>>>>                                If (Active_State(ghoStatusPanel)) Begin
83498>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83499>>>>>                                End
83499>>>>>>
83499>>>>>                                Else Begin
83500>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83502>>>>>                                End
83502>>>>>>
83502>>>>>                            End
83502>>>>>>
83502>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
83503>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
83504>>>>>                        Loop
83505>>>>>>
83505>>>>>
83505>>>>>
83505>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83507>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83508>>>>>                        End
83508>>>>>>
83508>>>>>                        Set paQueryMessages to sMsg
83509>>>>>                    End
83509>>>>>>
83509>>>>>
83509>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
83510>>>>>                Until (iNextSet = 0)
83512>>>>>
83512>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
83513>>>>>            End
83513>>>>>>
83513>>>>>
83513>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
83514>>>>>            Set ptsQueryExec to tsQuery
83515>>>>>            Send SqlClose of hoStmt
83516>>>>>
83516>>>>>            If (bCreateScriptFile = True) Begin
83518>>>>>                Close_Output channel iOut
83520>>>>>                Send Seq_Release_Channel iOut
83521>>>>>            End
83521>>>>>>
83521>>>>>        End
83521>>>>>>
83521>>>>>        Send SqlDisconnect of hoSQLConnect
83522>>>>>
83522>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
83523>>>>>    End_Function
83524>>>>>
83524>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83526>>>>>        tSQLScriptArray SQLScriptArray
83526>>>>>        tSQLScriptArray SQLScriptArray
83526>>>>>        String sDriverID sCollation
83526>>>>>        Boolean bOK
83526>>>>>        Integer iSize iCount
83526>>>>>
83526>>>>>        If (Trim(sDatabaseName) = "") Begin
83528>>>>>            Function_Return False
83529>>>>>        End
83529>>>>>>
83529>>>>>
83529>>>>>        Get psDriverID  to sDriverID
83530>>>>>        Get psCollation to sCollation
83531>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83532>>>>>        If (SQLScriptArray.bError = True) Begin
83534>>>>>            Function_Return False
83535>>>>>        End
83535>>>>>>
83535>>>>>
83535>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83536>>>>>        Decrement iSize
83537>>>>>
83537>>>>>        For iCount from 0 to iSize
83543>>>>>>
83543>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83545>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83546>>>>>            End
83546>>>>>>
83546>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83548>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83549>>>>>            End
83549>>>>>>
83549>>>>>        Loop
83550>>>>>>
83550>>>>>
83550>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83551>>>>>
83551>>>>>        Function_Return (bOK = True)
83552>>>>>    End_Function
83553>>>>>
83553>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83555>>>>>        tSQLScriptArray SQLScriptArray
83555>>>>>        tSQLScriptArray SQLScriptArray
83555>>>>>        String sDriverID sCollation
83555>>>>>        Boolean bOK
83555>>>>>        Integer iSize iCount
83555>>>>>
83555>>>>>        If (Trim(sDatabaseName) = "") Begin
83557>>>>>            Function_Return False
83558>>>>>        End
83558>>>>>>
83558>>>>>
83558>>>>>        Get psDriverID  to sDriverID
83559>>>>>        Get psCollation to sCollation
83560>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83561>>>>>        If (SQLScriptArray.bError = True) Begin
83563>>>>>            Function_Return False
83564>>>>>        End
83564>>>>>>
83564>>>>>
83564>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83565>>>>>        Decrement iSize
83566>>>>>
83566>>>>>        For iCount from 0 to iSize
83572>>>>>>
83572>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83574>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83575>>>>>            End
83575>>>>>>
83575>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83577>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83578>>>>>            End
83578>>>>>>
83578>>>>>        Loop
83579>>>>>>
83579>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
83579>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83580>>>>>
83580>>>>>        Function_Return (bOK = True)
83581>>>>>    End_Function
83582>>>>>
83582>>>>>    Function _StrToFieldNumber Integer iFile String sField Returns Integer
83584>>>>>        Integer iMax iPos
83584>>>>>        String sName
83584>>>>>
83584>>>>>        Move (Lowercase(sField)) to sField
83585>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
83588>>>>>        For iPos from 0 to iMax
83594>>>>>>
83594>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
83597>>>>>            Move (Lowercase(sName)) to sName
83598>>>>>            If (sName = sField) Begin
83600>>>>>                Function_Return iPos
83601>>>>>            End
83601>>>>>>
83601>>>>>        Loop
83602>>>>>>
83602>>>>>        Function_Return -1
83603>>>>>    End_Function
83604>>>>>
83604>>>>>    // Checks if the passed connection id exists in the CLI interface.
83604>>>>>    // This might be needed by API-methods when a connection id is to be used and
83604>>>>>    // the connection id hasn't been established with the driver's CLI interface.
83604>>>>>    // NOTE: Only applicable for DAW drivers.
83604>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
83606>>>>>        String sID sConnString
83606>>>>>        Integer iDriver iNumConn iCount
83606>>>>>        Handle hoCLI
83606>>>>>        Boolean bOK
83606>>>>>
83606>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83607>>>>>        If (bOK = False) Begin
83609>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers."
83610>>>>>>
83610>>>>>            Function_Return False
83611>>>>>        End
83611>>>>>>
83611>>>>>
83611>>>>>        Move False to bOK
83612>>>>>        Get phoCLIHandler to hoCLI
83613>>>>>        If (hoCLI <> 0) Begin
83615>>>>>            Set psDriverID of hoCLI to sDriverID
83616>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
83617>>>>>
83617>>>>>            // If driver not loaded; load it.
83617>>>>>            If (iDriver = 0) Begin
83619>>>>>                Load_Driver sDriverID
83620>>>>>                Get DriverIndex sDriverID to iDriver
83621>>>>>            End
83621>>>>>>
83621>>>>>            If (iDriver <> 0) Begin
83623>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
83626>>>>>                Decrement iNumConn
83627>>>>>                For iCount from 0 to iNumConn
83633>>>>>>
83633>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
83636>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
83639>>>>>                    If (sID = sConnectionID) Begin
83641>>>>>                        Move True to bOK
83642>>>>>                    End
83642>>>>>>
83642>>>>>                Loop
83643>>>>>>
83643>>>>>            End
83643>>>>>>
83643>>>>>        End
83643>>>>>>
83643>>>>>
83643>>>>>        Function_Return bOK
83644>>>>>    End_Function
83645>>>>>
83645>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
83647>>>>>        Boolean bOK
83647>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
83648>>>>>        Function_Return bOK
83649>>>>>    End_Function
83650>>>>>
83650>>>>>    Function IsMSSQLDriver Returns Boolean
83652>>>>>        Integer iDriverIndex
83652>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
83653>>>>>        Function_Return (iDriverIndex <> 0)
83654>>>>>    End_Function
83655>>>>>
83655>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
83655>>>>>    // attempt to load the driver.
83655>>>>>    // Returns true if the passed driver is SQL based.
83655>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
83657>>>>>        Boolean bOK
83657>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83658>>>>>        Function_Return bOK
83659>>>>>    End_Function
83660>>>>>
83660>>>>>    // *** Error Handler ***
83660>>>>>    //
83660>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
83660>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
83660>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
83662>>>>>        Integer iSize iErrorMode
83662>>>>>        tSqlErrorArray aSqlErrorArray
83662>>>>>        tSqlErrorArray aSqlErrorArray
83662>>>>>
83662>>>>>        If (pbProcessingError(Self)) Begin
83664>>>>>            Procedure_Return
83665>>>>>        End
83665>>>>>>
83665>>>>>
83665>>>>>        Get Error_Report_Mode to iErrorMode
83666>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
83668>>>>>            Procedure_Return
83669>>>>>        End
83669>>>>>>
83669>>>>>
83669>>>>>        Set pbProcessingError to True
83670>>>>>        Set pbSqlError to True
83671>>>>>        Get paSqlErrorArray      to aSqlErrorArray
83672>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
83673>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
83674>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
83675>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
83676>>>>>        Set paSqlErrorArray      to aSqlErrorArray
83677>>>>>        Set pbProcessingError to False
83678>>>>>    End_Procedure
83679>>>>>
83679>>>>>    // *** Miscellanous Helper Functions ***
83679>>>>>    //
83679>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
83679>>>>>    // returns the table name only; stripped of any path or filename extension.
83679>>>>>    Function _TableNameOnly String sName Returns String
83681>>>>>        String sPath sExt
83681>>>>>
83681>>>>>        Get ParseFolderName sName to sPath
83682>>>>>        If (sPath <> "") Begin
83684>>>>>            Move (Replace(sPath, sName, "")) to sName
83685>>>>>        End
83685>>>>>>
83685>>>>>        Get ParseFileExtension sName to sExt
83686>>>>>        If (sExt <> "") Begin
83688>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
83689>>>>>        End
83689>>>>>>
83689>>>>>
83689>>>>>        Function_Return sName
83690>>>>>    End_Function
83691>>>>>
83691>>>>>    // Removes any prefix to a table name.
83691>>>>>    // Example mssqldrv:mytable returns mytable
83691>>>>>    //         dbo.mytable returns mytable
83691>>>>>    Function _TableNoPrefix String sName Returns String
83693>>>>>        Integer iPos
83693>>>>>
83693>>>>>        Move (Pos(":", sName)) to iPos
83694>>>>>        If (iPos <> 0) Begin
83696>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
83697>>>>>        End
83697>>>>>>
83697>>>>>        Move (Pos(".", sName)) to iPos
83698>>>>>        If (iPos <> 0) Begin
83700>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
83701>>>>>        End
83701>>>>>>
83701>>>>>
83701>>>>>        Function_Return sName
83702>>>>>    End_Function
83703>>>>>
83703>>>>>    // Returns the first datapath found in the psDataPath property.
83703>>>>>    // The returned path always ends with a "\"
83703>>>>>    Function psDataPathFirstPart Returns String
83705>>>>>        String sDataPath
83705>>>>>        Integer iCount
83705>>>>>
83705>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
83706>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
83707>>>>>        If (iCount > 1) Begin
83709>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
83710>>>>>        End
83710>>>>>>
83710>>>>>        If (sDataPath <> "") Begin
83712>>>>>            Get vFolderFormat sDataPath to sDataPath
83713>>>>>        End
83713>>>>>>
83713>>>>>
83713>>>>>        Function_Return sDataPath
83714>>>>>    End_Function
83715>>>>>
83715>>>>>    Function psLogTextFileWithPath Returns String
83717>>>>>        String sFileName
83717>>>>>        Handle hoLogFile
83717>>>>>        Get phoLogFile to hoLogFile
83718>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
83719>>>>>        Function_Return sFileName
83720>>>>>    End_Function
83721>>>>>
83721>>>>>    Function phoLogFile Returns Handle
83723>>>>>        Handle hoLogFile   
83723>>>>>        Boolean bErr
83723>>>>>        
83723>>>>>        Move Err to bErr
83724>>>>>        Move 0 to hoLogFile
83725>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
83726>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
83727>>>>>        Delegate Get phoLogFile to hoLogFile
83729>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
83730>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
83731>>>>>        Move bErr to Err
83732>>>>>        
83732>>>>>        Function_Return hoLogFile
83733>>>>>    End_Function
83734>>>>>
83734>>>>>    Function pnCurrentVersionUpdate Returns Number
83736>>>>>        Number nCurrentVersionUpdate
83736>>>>>
83736>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
83737>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
83739>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
83740>>>>>
83740>>>>>        Function_Return nCurrentVersionUpdate
83741>>>>>    End_Function
83742>>>>>
83742>>>>>    Procedure LogError String sText Boolean bError
83744>>>>>        Handle hoLogFile
83744>>>>>        Number nCurrentVersionUpdate
83744>>>>>
83744>>>>>        Get phoLogFile to hoLogFile
83745>>>>>        If (hoLogFile = 0) Begin
83747>>>>>            Procedure_Return
83748>>>>>        End
83748>>>>>>
83748>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
83749>>>>>
83749>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
83750>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
83751>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
83752>>>>>    End_Procedure
83753>>>>>
83753>>>>>    Function pbContinueOnError Returns Boolean
83755>>>>>        Boolean bContinueOnError
83755>>>>>        If (ghoDbUpdateHandler > 0) Begin
83757>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
83758>>>>>        End
83758>>>>>>
83758>>>>>        Function_Return bContinueOnError
83759>>>>>    End_Function
83760>>>>>
83760>>>>>
83760>>>>>    Function _UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
83762>>>>>        Integer iChIn iChOut // iCount
83762>>>>>        Boolean bExists
83762>>>>>        String sExistingColumn
83762>>>>>
83762>>>>>        Move False to bExists
83763>>>>>        Get Seq_New_Channel to iChIn
83764>>>>>        Get Seq_New_Channel to iChOut
83765>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83767>>>>>            Function_Return True
83768>>>>>        End
83768>>>>>>
83768>>>>>
83768>>>>>        Move False to Err
83769>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
83769>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
83771>>>>>        While (not(SeqEof))
83775>>>>>            Readln channel iChIn sExistingColumn
83777>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
83779>>>>>                Move True to bExists
83780>>>>>            End
83780>>>>>>
83780>>>>>            If (Trim(sExistingColumn) = "") Begin
83782>>>>>                Move True to SeqEof
83783>>>>>            End
83783>>>>>>
83783>>>>>        Loop
83784>>>>>>
83784>>>>>        Close_Input channel iChIn
83786>>>>>        Send Seq_Release_Channel iChIn
83787>>>>>
83787>>>>>        If (bExists = False) Begin
83789>>>>>            Append_Output channel iChOut sFullTAGFileName
83791>>>>>            Writeln channel iChOut sColumnName
83794>>>>>            Close_Output channel iChOut
83796>>>>>            Send Seq_Release_Channel iChOut
83797>>>>>        End
83797>>>>>>
83797>>>>>
83797>>>>>        Function_Return (Err = False)
83798>>>>>    End_Function
83799>>>>>
83799>>>>>    // Changes source code files.
83799>>>>>    // Pass a file name with full path and a value to search for, together with the value
83799>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
83799>>>>>    // to use a Connection ID.
83799>>>>>    // Sample: Get _UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
83799>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
83799>>>>>    // Returns True if no errors occured.
83799>>>>>    Function _UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
83801>>>>>        Integer iCh iRow iItems iCount
83801>>>>>        String sValue sRow
83801>>>>>        String[] sFileArray
83802>>>>>        Boolean bExists bIsActive
83802>>>>>
83802>>>>>        Move False to Err
83803>>>>>        Move 0 to iRow
83804>>>>>
83804>>>>>        If (ghoStatusPanel <> 0) Begin
83806>>>>>            Get Active_state of ghoStatusPanel to bIsActive
83807>>>>>        End
83807>>>>>>
83807>>>>>
83807>>>>>        Get vFilePathExists sFileName to bExists
83808>>>>>        If (bExists = False) Begin
83810>>>>>            If (bShowResult = True) Begin
83812>>>>>                If (bIsActive = True) Begin
83814>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
83815>>>>>                End
83815>>>>>>
83815>>>>>                Else Begin
83816>>>>>                    Showln "File does not exist: " sFileName
83819>>>>>                End
83819>>>>>>
83819>>>>>            End
83819>>>>>>
83819>>>>>            Function_Return False
83820>>>>>        End
83820>>>>>>
83820>>>>>
83820>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
83821>>>>>        If (iCh < 1) Begin
83823>>>>>            Function_Return False
83824>>>>>        End
83824>>>>>>
83824>>>>>
83824>>>>>        If (bShowResult = True) Begin
83826>>>>>            If (ghoStatusPanel <> 0) Begin
83828>>>>>                Get Active_state of ghoStatusPanel to bIsActive
83829>>>>>                If (bIsActive = True) Begin
83831>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
83832>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
83833>>>>>                    Send DoAdvance of ghoProgressBar
83834>>>>>                End
83834>>>>>>
83834>>>>>            End
83834>>>>>>
83834>>>>>            Else Begin
83835>>>>>                Showln ""
83837>>>>>                Showln "sFileName = " sFileName
83840>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
83845>>>>>            End
83845>>>>>>
83845>>>>>        End
83845>>>>>>
83845>>>>>
83845>>>>>        While (not(SeqEof))
83849>>>>>            Readln channel iCh sRow
83851>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
83853>>>>>//                If (bShowResult = True) Begin
83853>>>>>//                    If (bIsActive = True) Begin
83853>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
83853>>>>>//                    End
83853>>>>>//                    Else Begin
83853>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
83853>>>>>//                    End
83853>>>>>//                End
83853>>>>>                // Change the whole line to the new connection id:
83853>>>>>                Move sChangeTo to sRow
83854>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
83854>>>>>            End
83854>>>>>>
83854>>>>>            Move sRow to sFileArray[iRow]
83855>>>>>            Increment iRow
83856>>>>>        Loop
83857>>>>>>
83857>>>>>        Send Seq_Close_Channel iCh
83858>>>>>
83858>>>>>        Sleep 1 // Wait for Windows to close the file
83859>>>>>
83859>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
83860>>>>>        If (iCh < 1) Begin
83862>>>>>            Function_Return False
83863>>>>>        End
83863>>>>>>
83863>>>>>        Move (SizeOfArray(sFileArray)) to iItems
83864>>>>>        Decrement iItems
83865>>>>>
83865>>>>>        for iCount from 0 to iItems
83871>>>>>>
83871>>>>>            Move sFileArray[iCount] to sValue
83872>>>>>            Writeln channel iCh sValue
83875>>>>>        Loop
83876>>>>>>
83876>>>>>        Send Seq_Close_Channel iCh
83877>>>>>
83877>>>>>        Function_Return (Err = False)
83878>>>>>    End_Function
83879>>>>>
83879>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
83879>>>>>    // and opens it in "notepad.exe".
83879>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
83879>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
83879>>>>>    Procedure _UtilShowErrorList
83881>>>>>        tSqlErrorArray aSqlErrorArray
83881>>>>>        tSqlErrorArray aSqlErrorArray
83881>>>>>        Integer iRows iCount iCh iErrorNum
83881>>>>>        String sPath sFileName sErrorTxt sStatement
83881>>>>>
83881>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
83882>>>>>        Get vFolderFormat sPath to sPath
83883>>>>>        Move "SQLErrorLog.txt"  to sFileName
83884>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
83885>>>>>            Get paSqlErrorArray to aSqlErrorArray
83886>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
83887>>>>>            If (iRows > 0) Begin
83889>>>>>                Decrement iRows
83890>>>>>                for iCount from 0 to iRows
83896>>>>>>
83896>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
83897>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
83898>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
83899>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
83905>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
83909>>>>>                Loop
83910>>>>>>
83910>>>>>            End
83910>>>>>>
83910>>>>>        Send Seq_Close_Channel iCh
83911>>>>>
83911>>>>>        If (iRows > 0) Begin
83913>>>>>            Runprogram Shell Background (sPath + sFileName)
83914>>>>>        End
83914>>>>>>
83914>>>>>    End_Procedure
83915>>>>>
83915>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
83915>>>>>    // and the table needs to exist as an SQL table.
83915>>>>>    Function _UtilTableIsSql Handle hTable Returns Boolean
83917>>>>>        String sRootName sDriverID
83917>>>>>        Boolean bIsSQL
83917>>>>>
83917>>>>>        Move False to bIsSQL
83918>>>>>        If (hTable > 0) Begin
83920>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
83923>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
83924>>>>>            If (bIsSQL = True) Begin
83926>>>>>                Get psDriverID to sDriverID
83927>>>>>                Get _TableNameOnly sRootName to sRootName
83928>>>>>                Get _SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
83929>>>>>            End
83929>>>>>>
83929>>>>>        End
83929>>>>>>
83929>>>>>
83929>>>>>        Function_Return bIsSQL
83930>>>>>    End_Function
83931>>>>>
83931>>>>>    Function _UtilTableIsSqlByRootName String sRootName Returns Boolean
83933>>>>>        Boolean bIsSQL
83933>>>>>        Move (sRootName contains ":") to bIsSQL
83934>>>>>        Function_Return bIsSQL
83935>>>>>    End_Function
83936>>>>>
83936>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
83936>>>>>    Function _SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
83938>>>>>        String sDatabase sSchema sVal
83938>>>>>        Boolean bExists
83938>>>>>        String[] sTablesArray
83939>>>>>        Integer iSize iCount
83939>>>>>
83939>>>>>        Move False to bExists
83940>>>>>        Get psDatabase to sDatabase
83941>>>>>        Get psSchema   to sSchema
83942>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
83943>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
83944>>>>>        Decrement iSize
83945>>>>>        for iCount from 0 to iSize
83951>>>>>>
83951>>>>>            Move sTablesArray[iCount] to sVal
83952>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
83954>>>>>                Move True to bExists
83955>>>>>                Move iSize to iCount // We're done!
83956>>>>>            End
83956>>>>>>
83956>>>>>        Loop
83957>>>>>>
83957>>>>>
83957>>>>>        Function_Return bExists
83958>>>>>    End_Function
83959>>>>>
83959>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
83959>>>>>    // that the embedded .dat file exists on disk.
83959>>>>>    Function _UtilTableIsEmbedded Handle hTable Returns Boolean
83961>>>>>        Boolean bExists bIsEmbedded
83961>>>>>        String sDataPath sRootName
83961>>>>>
83961>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
83962>>>>>        If (bExists = False) Begin
83964>>>>>            Function_Return False
83965>>>>>        End
83965>>>>>>
83965>>>>>
83965>>>>>        Move False to bIsEmbedded
83966>>>>>        If (hTable > 0) Begin
83968>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
83971>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
83972>>>>>        End
83972>>>>>>
83972>>>>>        If (bIsEmbedded = True) Begin
83974>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
83975>>>>>            Get vFolderFormat sDataPath to sDataPath
83976>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
83977>>>>>        End
83977>>>>>>
83977>>>>>
83977>>>>>        Function_Return bIsEmbedded
83978>>>>>    End_Function
83979>>>>>
83979>>>>>End_Class
83980>>>
83980>>>Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib
83981>>>
83981>>>    Procedure Construct_Object
83983>>>        Forward Send Construct_Object
83985>>>        Move Self to ghoDbUpdateFunctionLibrary
83986>>>    End_Procedure
83987>>>
83987>>>    Procedure End_Construct_Object
83989>>>        Forward Send End_Construct_Object
83991>>>    End_Procedure
83992>>>
83992>>>    // *** SQL Messages for making changes to the SQL back-end ***
83992>>>    //
83992>>>    // * Dummy function for the Studio's Code Explorer *
83992>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
83994>>>        Function_Return False
83995>>>    End_Function
83996>>>
83996>>>    // Function for creating a new *Database*.
83996>>>    // Note: This is for creating SQL DATABASES - not tables!
83996>>>    // Returns True if successful.
83996>>>    // ToDo: Currently only works for MS-SQL...
83996>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
83998>>>        String sSQL sSQL1 sConnectionID sConnectionString
83998>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
83998>>>        Handle hConnection hStmt hoSQLManager
83998>>>        Integer iFetchResult iDbType
83998>>>        Boolean bOK bExists
83998>>>
83998>>>        Get piDbType to iDbType
83999>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
84001>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 drivers"
84002>>>>
84002>>>            Function_Return False
84003>>>        End
84003>>>>
84003>>>
84003>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
84004>>>        If (bExists = True) Begin
84006>>>            Function_Return True
84007>>>        End
84007>>>>
84007>>>
84007>>>        Get phoSQLManager to hoSQLManager
84008>>>
84008>>>        Get psConnectionID     to sConnectionID
84009>>>        Get psConnectionString to sConnectionString
84010>>>        Move 0 to LastErr
84011>>>
84011>>>        If (sDriverID = ODBC_DRV_ID) Begin
84013>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
84013>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
84013>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
84013>>>//                Move (Pos(";", sConnectionString)) to iPos
84013>>>//                If (iPos > 0) Begin
84013>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
84013>>>//                    Move (Trim(sConnectionString)) to sConnectionString
84013>>>//                End
84013>>>//            End
84013>>>        End
84013>>>>
84013>>>
84013>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84014>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84015>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84016>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84018>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
84019>>>>
84019>>>            Function_Return False
84020>>>        End
84020>>>>
84020>>>
84020>>>        Get SqlOpen of hConnection to hStmt
84021>>>
84021>>>        If (hStmt = 0) Begin
84023>>>            Send SqlDisconnect of hoSQLManager
84024>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84025>>>>
84025>>>            Function_Return False
84026>>>        End
84026>>>>
84026>>>
84026>>>        Get psCollation to sCollation
84027>>>
84027>>>        Case Begin
84027>>>            Case (sDriverID = MSSQLDRV_ID)
84029>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84030>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
84031>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
84032>>>
84032>>>                // Check if database exists
84032>>>                Send SqlExecDirect of hStmt sSQL
84033>>>                Get SqlFetch of hStmt to iFetchResult
84034>>>                Send SqlClose of hStmt
84035>>>                Send SqlDisconnect of hConnection
84036>>>                // If database already exists we're out of here!
84036>>>                // Note that we return True as this is not an error.
84036>>>                If (iFetchResult > 0) Begin
84038>>>                    Function_Return True
84039>>>                End
84039>>>>
84039>>>                // Database doesn't exist, create it.
84039>>>                If (iFetchResult = 0) Begin
84041>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84042>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84043>>>                    If (sCollation <> "") Begin
84045>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84046>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
84047>>>                    End
84047>>>>
84047>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
84048>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84049>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
84051>>>                        Function_Return False
84052>>>                    End
84052>>>>
84052>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84052>>>                    Sleep 1
84053>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
84054>>>                End
84054>>>>
84054>>>                Case Break
84055>>>
84055>>>            Case (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID)
84058>>>                // ToDo: How should this be set/checked?
84058>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
84058>>>//                    Set psCollation to "utf8"
84058>>>//                End
84058>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
84058>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
84059>>>                Case Break
84060>>>
84060>>>            Case Else
84060>>>                Error DFERR_PROGRAM "Unsupported database type"
84061>>>>
84061>>>        Case End
84061>>>
84061>>>        If (Err = False) Begin
84063>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
84064>>>        End
84064>>>>
84064>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
84064>>>        // the one we just created.
84064>>>        If (bUpdateConnectionString = True and Err = False) Begin
84066>>>            Set psDatabase to sDatabase
84067>>>            //...and perhaps also the SQLConnections.ini file setting.
84067>>>            If (bPermanantly = True) Begin
84069>>>                If (ghoSQLConnectionHandler <> 0) Begin
84071>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84072>>>                End
84072>>>>
84072>>>            End
84072>>>>
84072>>>        End
84072>>>>
84072>>>
84072>>>        Function_Return (Err = False)
84073>>>    End_Function
84074>>>
84074>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
84074>>>    // will be used.
84074>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
84076>>>        Boolean bOK bExists bShowProgress bErr
84076>>>        String sStatement sDriverID
84076>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84076>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84076>>>        Integer iDbType
84076>>>
84076>>>        If (sDatabase = "") Begin
84078>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84079>>>>
84079>>>            Function_Return False
84080>>>        End
84080>>>>
84080>>>        If (sBackupName = "") Begin
84082>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84083>>>>
84083>>>            Function_Return False
84084>>>        End
84084>>>>
84084>>>
84084>>>        // Create backup-folder if it doesn't exist
84084>>>        Get vFolderExists sPath to bExists
84085>>>        If (bExists = False) Begin
84087>>>            Get vCreateDirectory sPath to bErr
84088>>>            If (bErr = True) Begin
84090>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
84091>>>>
84091>>>                Function_Return False
84092>>>            End
84092>>>>
84092>>>        End
84092>>>>
84092>>>        // Make sure the path ends with a back-slash
84092>>>        If (sPath <> "") Begin
84094>>>            Get vFolderFormat sPath to sPath
84095>>>        End
84095>>>>
84095>>>
84095>>>        Get psDriverID to sDriverID
84096>>>        Get piDbType   to iDbType
84097>>>        If (num_arguments > 3) Begin
84099>>>            Move bShowProg to bShowProgress
84100>>>        End
84100>>>>
84100>>>
84100>>>        Case Begin
84100>>>            Case (iDbType = EN_DbTypeMSSQL)
84102>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
84102>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
84102>>>                Get _SqlUtilReadResource  "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
84103>>>                Get _SqlUtilReadResource "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
84104>>>
84104>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84105>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
84106>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
84107>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
84108>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
84109>>>                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" bShowProgress to bOK
84110>>>                Case Break
84111>>>            Case Else
84111>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84112>>>        Case End
84112>>>
84112>>>        Function_Return bOK
84113>>>    End_Function
84114>>>
84114>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
84116>>>        String sStatement sDriverID sRetval //sPrevious
84116>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84116>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84116>>>        Integer iDbType iRows iFetchResult //iColumn
84116>>>        Handle hoSQLHandler hoSQLConnect hstmt
84116>>>        tSQLConnection SQLConnection
84116>>>        tSQLConnection SQLConnection
84116>>>
84116>>>        If (sDatabase = "") Begin
84118>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
84119>>>>
84119>>>            Function_Return ""
84120>>>        End
84120>>>>
84120>>>
84120>>>        Move "" to sRetval
84121>>>        Get psDriverID to sDriverID
84122>>>        Get piDbType   to iDbType
84123>>>
84123>>>        Case Begin
84123>>>            Case (iDbType = EN_DbTypeMSSQL)
84125>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
84125>>>                Get _SqlUtilReadResource "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
84126>>>
84126>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84127>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
84128>>>                Get phoSQLManager to hoSQLHandler
84129>>>
84129>>>                If (hoSQLHandler <> 0) Begin
84131>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84132>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
84133>>>
84133>>>                    If (hoSQLConnect <> 0) Begin
84135>>>                        Get SQLOpen of hoSQLConnect to hstmt
84136>>>                        If (hstmt <> 0) Begin
84138>>>                            Send SqlExecDirect of hstmt sStatement
84139>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
84140>>>                            Get SQLFetch of hstmt to iFetchResult
84141>>>                            If (iFetchResult <> 0) Begin
84143>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
84144>>>                            End
84144>>>>
84144>>>                            Send SQLClose of hstmt
84145>>>                        End
84145>>>>
84145>>>                        Send SQLDisconnect of hoSQLConnect
84146>>>                    End
84146>>>>
84146>>>                End
84146>>>>
84146>>>                Case Break
84147>>>            Case Else
84147>>>                If (bSilent = False) Begin
84149>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
84150>>>                End
84150>>>>
84150>>>        Case End
84150>>>
84150>>>        Function_Return sRetval
84151>>>    End_Function
84152>>>
84152>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
84154>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
84154>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
84154>>>        Handle hConnection hStmt hoSQLManager
84154>>>        Integer iDbType // iFetchResult
84154>>>
84154>>>        If (sDatabase = "") Begin
84156>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84157>>>>
84157>>>            Function_Return False
84158>>>        End
84158>>>>
84158>>>
84158>>>        If (sSQLCollation = "") Begin
84160>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84161>>>>
84161>>>            Function_Return False
84162>>>        End
84162>>>>
84162>>>
84162>>>        Get psDriverID to sDriverID
84163>>>        Get piDbType   to iDbType
84164>>>
84164>>>        Get phoSQLManager to hoSQLManager
84165>>>        Get psConnectionID     to sConnectionID
84166>>>        Get psConnectionString to sConnectionString
84167>>>        Move 0 to LastErr
84168>>>
84168>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84169>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84170>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84171>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84173>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84174>>>>
84174>>>            Function_Return False
84175>>>        End
84175>>>>
84175>>>
84175>>>        Get SqlOpen of hConnection to hStmt
84176>>>
84176>>>        If (hStmt = 0) Begin
84178>>>            Send SqlDisconnect of hoSQLManager
84179>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84180>>>>
84180>>>            Function_Return False
84181>>>        End
84181>>>>
84181>>>
84181>>>        // Check if collation already exists
84181>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
84182>>>        // If the current collate is the same as the new; do nothing.
84182>>>        If (sSQLCollation = sSQLCollationCheck) Begin
84184>>>            Function_Return True
84185>>>        End
84185>>>>
84185>>>
84185>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
84186>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
84187>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
84188>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
84189>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
84190>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
84191>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
84192>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84193>>>
84193>>>        // MS-SQL Syntax:
84193>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
84193>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
84193>>>        // ALTER DATABASE [database] SET MULTI_USER;
84193>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
84194>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84195>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
84196>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84196>>>
84196>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84197>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
84198>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84199>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
84201>>>           Function_Return False
84202>>>        End
84202>>>>
84202>>>
84202>>>        Function_Return (Err = False)
84203>>>    End_Function
84204>>>
84204>>>
84204>>>    // * Dummy function for the Studio's Code Explorer *
84204>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
84206>>>        Function_Return False
84207>>>    End_Function
84208>>>
84208>>>    // Converts from SQL to Embedded (DataFlex .dat files).
84208>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
84208>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
84208>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
84208>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
84208>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
84210>>>        Handle hToTable
84210>>>        Boolean bOK bExists bOpened bCopyData
84210>>>        String sDriverID sPhysicalName sRootName sDisplayName
84210>>>        tSQLConnection SQLConnection
84210>>>        tSQLConnection SQLConnection
84210>>>        Integer iPos iMaxRecords
84210>>>
84210>>>        Get psDriverID to sDriverID
84211>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
84212>>>        If (bExists = False) Begin
84214>>>            Function_Return False
84215>>>        End
84215>>>>
84215>>>
84215>>>        If (num_arguments > 1) Begin
84217>>>            Move bCpyDat to bCopyData
84218>>>        End
84218>>>>
84218>>>        Else Begin
84219>>>            Move False to bCopyData
84220>>>        End
84220>>>>
84220>>>
84220>>>        Open hTable
84222>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84225>>>        If (bOpened = False) Begin
84227>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
84228>>>>
84228>>>            Function_Return False
84229>>>        End
84229>>>>
84229>>>        Move 0 to hToTable
84230>>>
84230>>>        Move 16711679 to iMaxRecords
84231>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84234>>>        Move (Pos(".", sDisplayName)) to iPos
84235>>>        If (iPos > 0) Begin
84237>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
84238>>>        End
84238>>>>
84238>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84241>>>        Get _TableNameOnly sRootName                 to sRootName
84242>>>        Move (sRootName + ".dat")                    to sPhysicalName
84243>>>
84243>>>        If (ghoProgressBar <> 0) Begin
84245>>>            Send DoAdvance of ghoProgressBar
84246>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
84247>>>        End
84247>>>>
84247>>>
84247>>>        Move False to Err
84248>>>
84248>>>        Structure_Start hToTable DATAFLEX_ID
84249>>>            Structure_Copy hTable to hToTable
84250>>>
84250>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
84253>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
84256>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
84259>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
84262>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
84265>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84266>>>
84266>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84268>>>
84268>>>        Set Action_Text of ghoStatusPanel to ""
84269>>>        Move (not(Err)) to bOK
84270>>>        If (bOK = True and bCopyData = True) Begin
84272>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
84273>>>        End
84273>>>>
84273>>>
84273>>>        // This must be after copying data...
84273>>>        If (Err = False) Begin
84275>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84278>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84281>>>        End
84281>>>>
84281>>>        Move (not(Err)) to bOK
84282>>>
84282>>>        Function_Return (bOK = True)
84283>>>    End_Function
84284>>>
84284>>>    // Creates an SQL Table at the SQL end by its filelist number;
84284>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84284>>>    Function SqlTableCreate Integer hTable Returns Boolean
84286>>>        String sTableName sSQLString sPath sCreateTable sDriverID
84286>>>        Integer iDbType
84286>>>        Boolean bExists
84286>>>
84286>>>        Get psDriverID to sDriverID
84287>>>        Get UtilTableHandleToString hTable to sTableName
84288>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84289>>>        If (bExists = True) Begin
84291>>>            Function_Return False
84292>>>        End
84292>>>>
84292>>>
84292>>>        Get psDataPathFirstPart to sPath
84293>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84294>>>
84294>>>        Get piDbType to iDbType
84295>>>        Get _SqlProperTableName sTableName to sTableName
84296>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84297>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84298>>>
84298>>>        Move False to Err
84299>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84300>>>
84300>>>        Function_Return (Err = False)
84301>>>    End_Function
84302>>>
84302>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
84302>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84302>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
84304>>>        String sSQLString sPath sCreateTable sDriverID
84304>>>        Integer iDbType
84304>>>        Boolean bExists
84304>>>
84304>>>        Get psDriverID to sDriverID
84305>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84306>>>        If (bExists = True) Begin
84308>>>            Function_Return False
84309>>>        End
84309>>>>
84309>>>
84309>>>        Get psDataPathFirstPart to sPath
84310>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84311>>>        If (bExists = True) Begin
84313>>>            // ToDo: What should we do if an .int file already exists?
84313>>>        End
84313>>>>
84313>>>
84313>>>        Get piDbType to iDbType
84314>>>        Get _SqlProperTableName sTableName to sTableName
84315>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84316>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84317>>>
84317>>>        Move False to Err
84318>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84319>>>
84319>>>        Function_Return (Err = False)
84320>>>    End_Function
84321>>>    
84321>>>    // ToDo: 2019-09-23 This needs to be finilized 
84321>>>    // It resets SQL constraints after a Structure_End, if necessary.
84321>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
84323>>>        Boolean bOK                                                            
84323>>>        String sStatement
84323>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
84324>>>        Function_Return bOK
84325>>>    End_Function
84326>>>    
84326>>>    // First deletes the data cache file and then drops the passed SQL table.
84326>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
84326>>>    //       else try using the SqlTableRemoveByTableName message.
84326>>>    Function SqlTableRemove Handle hTable Returns Boolean
84328>>>        String sSQLString sPath sDropTable sTableName sDriverID
84328>>>        Integer iRetval iDbType
84328>>>        Boolean bExists bOK
84328>>>
84328>>>        Get psDriverID to sDriverID
84329>>>        Get UtilTableHandleToString hTable to sTableName
84330>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84331>>>        If (bExists = False) Begin
84333>>>            Function_Return False
84334>>>        End
84334>>>>
84334>>>
84334>>>        Get psDataPathFirstPart to sPath
84335>>>        Get _UtilDeleteCacheFile sTableName to iRetval
84336>>>
84336>>>        Get piDbType to iDbType
84337>>>        Get _SqlProperTableName sTableName to sTableName
84338>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84339>>>        Move (sDropTable * String(sTableName)) to sSQLString
84340>>>
84340>>>        Move False to Err
84341>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84342>>>
84342>>>        // We also need to remove the cache-file since the table has been changed
84342>>>        Get _UtilDeleteCacheFile sTableName to bOK
84343>>>
84343>>>        Function_Return (Err = False)
84344>>>    End_Function
84345>>>
84345>>>    // First deletes the data cache file and then drops the passed data table.
84345>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
84347>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
84347>>>        Integer iRetval iDbType
84347>>>        Boolean bOK
84347>>>
84347>>>        Get psDriverID to sDriverID
84348>>>        Get psDataPathFirstPart to sPath
84349>>>        Get _UtilDeleteCacheFile sTableName to iRetval
84350>>>
84350>>>        Get piDbType to iDbType
84351>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84352>>>        Get psSchema to sSchema
84353>>>        If (sSchema = "") Begin
84355>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
84356>>>        End
84356>>>>
84356>>>        Move (Uppercase(sTableName)) to sVal
84357>>>        If (not(sVal contains (sSchema + "."))) Begin
84359>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
84360>>>        End
84360>>>>
84360>>>        Move (sDropTable * String(sTableName)) to sSQLString
84361>>>
84361>>>        Move False to Err
84362>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84363>>>
84363>>>        // We also need to remove the cache-file since the table has been changed
84363>>>        Get _UtilDeleteCacheFile sTableName to bOK
84364>>>
84364>>>        Function_Return (Err = False)
84365>>>    End_Function
84366>>>
84366>>>    // *** Sql View Messages ***
84366>>>
84366>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
84368>>>        Boolean bOK
84368>>>        Integer iDbType
84368>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
84368>>>
84368>>>        Get psDriverID to sDriverID
84369>>>        Get piDbType   to iDbType
84370>>>
84370>>>        Case Begin
84370>>>            Case (iDbType = EN_DbTypeDB2)
84372>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84373>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84374>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84375>>>            Break
84376>>>
84376>>>            Case (iDbType = EN_DbTypeMSSQL)
84379>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84380>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84381>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
84382>>>            Break
84383>>>
84383>>>            Case (iDbType = EN_DbTypeOracle)
84386>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84387>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84388>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84389>>>            Break
84390>>>
84390>>>            Case (iDbType = EN_DbTypePostgre)
84393>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84394>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84395>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84396>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
84397>>>            Break
84398>>>
84398>>>            Case (iDbType = EN_DbTypeMySQL)
84401>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84402>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84403>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
84404>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84405>>>            Break
84406>>>        Case End
84406>>>
84406>>>        Move False to Err
84407>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84408>>>        Move (Err = False) to bOK
84409>>>
84409>>>        Function_Return bOK
84410>>>    End_Function
84411>>>
84411>>>    // * Dummy function for the Studio's Code Explorer *
84411>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
84413>>>        Function_Return False
84414>>>    End_Function
84415>>>
84415>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
84415>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84417>>>        Integer iLength iDecimals
84417>>>        String sColumnValue
84417>>>        String sTableName sDriverID
84417>>>        Boolean bOK bInitializeValue
84417>>>
84417>>>        Get psDriverID to sDriverID
84418>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84419>>>        If (bOK = False) Begin
84421>>>            Function_Return False
84422>>>        End
84422>>>>
84422>>>
84422>>>        Get UtilTableHandleToString hTable to sTableName
84423>>>        If (sTableName = "") Begin
84425>>>            Function_Return False
84426>>>        End
84426>>>>
84426>>>
84426>>>        If (num_arguments > 3) Begin
84428>>>            Move iLen     to iLength
84429>>>            Move iDec     to iDecimals
84430>>>            Move bInitVal to bInitializeValue
84431>>>            Move sColVal  to sColumnValue
84432>>>        End
84432>>>>
84432>>>
84432>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
84433>>>
84433>>>        Function_Return (bOK = True)
84434>>>    End_Function
84435>>>
84435>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
84435>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84437>>>        Integer iDbType iLength iDecimals iDriver
84437>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
84437>>>        String sDriverID sNotNull
84437>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
84437>>>        Handle hTable
84437>>>
84437>>>        Get psDriverID to sDriverID
84438>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84439>>>        If (bOK = False) Begin
84441>>>            Function_Return True
84442>>>        End
84442>>>>
84442>>>
84442>>>        Get UtilTableNameToHandle sTableName to hTable
84443>>>        If (hTable = 0) Begin
84445>>>            Get NextFreeFilelistSlot to hTable
84446>>>        End
84446>>>>
84446>>>
84446>>>        Get piDbType to iDbType
84447>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
84447>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84448>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
84450>>>            Function_Return True
84451>>>        End
84451>>>>
84451>>>
84451>>>        Get DriverIndex sDriverID to iDriver
84452>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84455>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84458>>>
84458>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84459>>>        If (num_arguments > 3) Begin
84461>>>            Move iLen     to iLength
84462>>>            Move iDec     to iDecimals
84463>>>            Move bInitVal to bInitializeValue
84464>>>            Move sColVal  to sColumnValue
84465>>>        End
84465>>>>
84465>>>
84465>>>        Get _SqlProperTableName sTableName   to sTableName
84466>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
84467>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
84468>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84469>>>
84469>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84470>>>        If (bFixed = False) Begin
84472>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84473>>>        End
84473>>>>
84473>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84474>>>
84474>>>        Move False to Err
84475>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84476>>>
84476>>>        If (bInitializeValue = True and Err = False) Begin
84478>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
84479>>>        End
84479>>>>
84479>>>
84479>>>        If (Err = False) Begin
84481>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
84482>>>        End
84482>>>>
84482>>>
84482>>>        Move (not(Err)) to bRetval
84483>>>
84483>>>        // We also need to remove the cache-file since the table has been changed
84483>>>        Get _UtilDeleteCacheFile sTableName to bOK
84484>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84487>>>
84487>>>        Function_Return bRetval
84488>>>    End_Function
84489>>>
84489>>>    // To update all current rows for a table column with a common value.
84489>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
84491>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
84491>>>        Boolean bRetval bSQLDriver
84491>>>        Integer iCurrErr iDbType
84491>>>
84491>>>        Move False to bRetval
84492>>>        Get piDbType to iDbType
84493>>>        Get psDriverID to sDriverID
84494>>>        Get IsSQLDriver sDriverID to bSQLDriver
84495>>>        If (bSQLDriver = False) Begin
84497>>>            Function_Return bRetval
84498>>>        End
84498>>>>
84498>>>        Get UtilTableHandleToString hTable to sTableName
84499>>>
84499>>>        Move Err to iCurrErr
84500>>>        Move False to Err
84501>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
84502>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
84503>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
84504>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
84504>>>        If (iDbType = EN_DbTypeMySQL) Begin
84506>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
84507>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84508>>>        End
84508>>>>
84508>>>        Else Begin
84509>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84510>>>        End
84510>>>>
84510>>>
84510>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84511>>>        Move (Err = False) to bRetval
84512>>>        Move iCurrErr to Err
84513>>>
84513>>>        Function_Return bRetval
84514>>>    End_Function
84515>>>
84515>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84515>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84515>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84517>>>        String sDriverID sTableName
84517>>>        Boolean bOK
84517>>>
84517>>>        Get psDriverID to sDriverID
84518>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84519>>>        If (bOK = False) Begin
84521>>>            Function_Return False
84522>>>        End
84522>>>>
84522>>>
84522>>>        Get UtilTableHandleToString hTable to sTableName
84523>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
84524>>>
84524>>>        Function_Return (Err = False)
84525>>>    End_Function
84526>>>
84526>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
84526>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84526>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84526>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84528>>>        Integer iDbType iLength iDecimals
84528>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
84528>>>        Boolean bExists bOK bFixed
84528>>>        Handle hTable
84528>>>
84528>>>        Get psDriverID to sDriverID
84529>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84530>>>        If (bOK = False) Begin
84532>>>            Function_Return False
84533>>>        End
84533>>>>
84533>>>
84533>>>        Get UtilTableNameToHandle sTableName to hTable
84534>>>        If (hTable = 0) Begin
84536>>>            Get NextFreeFilelistSlot to hTable
84537>>>        End
84537>>>>
84537>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
84538>>>        If (bExists = False) Begin
84540>>>            Function_Return False
84541>>>        End
84541>>>>
84541>>>
84541>>>        If (num_arguments > 3) Begin
84543>>>            Move iLen to iLength
84544>>>        End
84544>>>>
84544>>>        If (num_arguments > 4) Begin
84546>>>            Move iDec to iDecimals
84547>>>        End
84547>>>>
84547>>>
84547>>>        Get piDbType to iDbType
84548>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84549>>>
84549>>>        Move False to Err
84550>>>        Get _SqlProperTableName sTableName    to sTableName
84551>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84552>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
84553>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84554>>>
84554>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84555>>>        If (bFixed = False) Begin
84557>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84558>>>        End
84558>>>>
84558>>>
84558>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84559>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84560>>>
84560>>>        // We also need to remove the cache-file since the table has been changed
84560>>>        Get _UtilDeleteCacheFile sTableName to bOK
84561>>>
84561>>>        Function_Return (Err = False)
84562>>>    End_Function
84563>>>
84563>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
84565>>>        Boolean bOK bErr bIsSQLDriver
84565>>>        String sDriverID
84565>>>        Integer iDataType
84565>>>
84565>>>        Get psDriverID to sDriverID
84566>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84567>>>        If (bIsSQLDriver = False) Begin
84569>>>            Function_Return False
84570>>>        End
84570>>>>
84570>>>
84570>>>        Move Err to bErr
84571>>>        Move False to bErr
84572>>>
84572>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
84572>>>        // inserts randomly character(10) and spaces, so we correct from that here:
84572>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
84573>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
84576>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
84578>>>            Move ("[" + String(sValue) + "]") to sValue
84579>>>        End
84579>>>>
84579>>>
84579>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
84582>>>        Move (not(Err)) to bOK
84583>>>        Move bErr to Err
84584>>>
84584>>>        Function_Return bOK
84585>>>    End_Function
84586>>>
84586>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
84588>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
84588>>>        String sDriverID
84588>>>
84588>>>        Get psDriverID to sDriverID
84589>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84590>>>        If (bIsSQLDriver = False) Begin
84592>>>            Function_Return False
84593>>>        End
84593>>>>
84593>>>
84593>>>        Move Err to bErr
84594>>>        Move False to bErr
84595>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
84598>>>        If (bNullable = bCurrentState) Begin
84600>>>            Function_Return True
84601>>>        End
84601>>>>
84601>>>
84601>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
84604>>>        If (bOpen = False) Begin
84606>>>            Get AutoConnectionIDLogin to bOK
84607>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84608>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84609>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84610>>>            Open hTable
84612>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84613>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84614>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84615>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
84618>>>        End
84618>>>>
84618>>>        If (bOpen = True) Begin
84620>>>            Structure_Start hTable sDriverID
84621>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
84624>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
84625>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84627>>>            Set Action_Text of ghoStatusPanel to ""
84628>>>        End
84628>>>>
84628>>>
84628>>>        Move (not(Err)) to bOK
84629>>>        Move bErr to Err
84630>>>
84630>>>        Function_Return bOK
84631>>>    End_Function
84632>>>
84632>>>    // Drop column by its table handle
84632>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
84634>>>        String sDriverID sTableName
84634>>>        Boolean bOK
84634>>>
84634>>>        Get psDriverID to sDriverID
84635>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84636>>>        If (bOK = False) Begin
84638>>>            Function_Return False
84639>>>        End
84639>>>>
84639>>>
84639>>>        Get UtilTableHandleToString hTable to sTableName
84640>>>        If (sTableName = "") Begin
84642>>>            Function_Return False
84643>>>        End
84643>>>>
84643>>>
84643>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
84644>>>
84644>>>        Function_Return (bOK = True)
84645>>>    End_Function
84646>>>
84646>>>    // Drop column by its table name as a string.
84646>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
84648>>>        Integer iDbType iDriver
84648>>>        String sDriverID sStmt sAlterTable sDropColumn
84648>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
84648>>>        Handle hTable
84648>>>
84648>>>        Get psDriverID to sDriverID
84649>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84650>>>        If (bOK = False) Begin
84652>>>            Function_Return False
84653>>>        End
84653>>>>
84653>>>
84653>>>        Get DriverIndex sDriverID to iDriver
84654>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84657>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84660>>>
84660>>>        Get UtilTableNameToHandle sTableName to hTable
84661>>>        If (hTable <> 0) Begin
84663>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
84664>>>            If (bExists = False) Begin
84666>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84669>>>                Function_Return False
84670>>>            End
84670>>>>
84670>>>        End
84670>>>>
84670>>>
84670>>>        Get piDbType to iDbType
84671>>>        If (iDbType = EN_DbTypeMSSQL) Begin
84673>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
84674>>>            Get _UtilDeleteCacheFile sTableName to bOK
84675>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84678>>>            Function_Return bOK
84679>>>        End
84679>>>>
84679>>>
84679>>>        Move False to Err
84680>>>        Get _SqlProperTableName sTableName    to sTableName
84681>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84682>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
84683>>>
84683>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
84684>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84685>>>        Move (not(Err)) to bRetval
84686>>>
84686>>>        // We also need to remove the cache-file since the table has been changed
84686>>>        Get _UtilDeleteCacheFile sTableName to bOK
84687>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84690>>>
84690>>>        Function_Return bRetval
84691>>>    End_Function
84692>>>
84692>>>    // Rename a field/column by table handle (filelist number)
84692>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
84694>>>        String sDriverID sTableName
84694>>>        Boolean bOK
84694>>>
84694>>>        Get psDriverID to sDriverID
84695>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84696>>>        If (bOK = False) Begin
84698>>>            Function_Return False
84699>>>        End
84699>>>>
84699>>>
84699>>>        Get UtilTableHandleToString hTable to sTableName
84700>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
84701>>>
84701>>>        Function_Return (Err = False)
84702>>>    End_Function
84703>>>
84703>>>    // Rename a field/column by table name.
84703>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
84705>>>        Integer iDbType iDataType
84705>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
84705>>>        Boolean bOK bRetval
84705>>>        Handle hTable
84705>>>
84705>>>        Move sTableName to sOrgTableName
84706>>>        Get psDriverID to sDriverID
84707>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84708>>>        If (bOK = False) Begin
84710>>>            Function_Return False
84711>>>        End
84711>>>>
84711>>>
84711>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84712>>>        If (sVal = "") Begin
84714>>>            Function_Return False
84715>>>        End
84715>>>>
84715>>>
84715>>>        Get piDbType to iDbType
84716>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
84717>>>        Get _SqlProperTableName sTableName     to sTableName
84718>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
84719>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
84720>>>
84720>>>        Case Begin
84720>>>            Case (iDbType = EN_dbTypeMSSQL)
84722>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
84723>>>                Case Break
84724>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
84724>>>            Case (iDbType = EN_dbTypeOracle)
84727>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84728>>>                Case Break
84729>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
84729>>>            Case (iDbType = EN_dbTypeDB2)
84732>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84733>>>                Case Break
84734>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
84734>>>            Case (iDbType = EN_dbTypePostgre)
84737>>>                Move sOrgTableName to sTableName
84738>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84739>>>                Case Break
84740>>>            Case (iDbType = EN_dbTypeMySQL)
84743>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
84743>>>                Move sOrgTableName to sTableName
84744>>>                Get psDatabase to sDatabase
84745>>>                Get UtilTableNameToHandle sTableName to hTable
84746>>>                If (hTable = 0) Begin
84748>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
84749>>>                    If (bOK = False) Begin
84751>>>                        Function_Return False
84752>>>                    End
84752>>>>
84752>>>                    Get NextFreeFilelistSlot to hTable
84753>>>                End
84753>>>>
84753>>>                Else Begin
84754>>>                    Open hTable
84756>>>                End
84756>>>>
84756>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
84757>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
84758>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
84759>>>                Case Break
84760>>>            Case Else
84760>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
84761>>>        Case End
84761>>>
84761>>>        Move False to Err
84762>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84763>>>        Move (Err = False) to bRetval
84764>>>        // We also need to remove the cache-file since the table has been changed
84764>>>        Get _UtilDeleteCacheFile sTableName to bOK
84765>>>
84765>>>        Function_Return bRetval
84766>>>    End_Function
84767>>>
84767>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
84769>>>        Handle hoSQLHandler hSQLConnect hStmt
84769>>>        Integer iNumCols iCount iDataType
84769>>>        String sValue
84769>>>
84769>>>        Get phoSQLManager to hoSQLHandler
84770>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
84771>>>        If (hSQLConnect <> 0) Begin
84773>>>            Get SQLOpen of hSQLConnect to hStmt
84774>>>            If (hStmt <> 0) Begin
84776>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
84777>>>
84777>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
84778>>>                For iCount from 1 to iNumCols
84784>>>>
84784>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
84785>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
84787>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
84788>>>                        Move iNumCols to iCount // We're out of here
84789>>>                    End
84789>>>>
84789>>>                Loop
84790>>>>
84790>>>
84790>>>                Send SQLClose of hStmt
84791>>>            End
84791>>>>
84791>>>            Send SQLDisconnect of hSQLConnect
84792>>>        End
84792>>>>
84792>>>
84792>>>        Function_Return iDataType
84793>>>    End_Function
84794>>>
84794>>>    // * Dummy function for the Studio's Code Explorer *
84794>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
84796>>>        Function_Return False
84797>>>    End_Function
84798>>>
84798>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
84800>>>        String sMessage // sConnectionString
84800>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
84800>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
84800>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
84803>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
84803>>>        TimeSpan tsQuery tsFetch
84803>>>        tSqlErrorArray aSqlErrorArray
84803>>>        tSqlErrorArray aSqlErrorArray
84803>>>        Boolean bOK bShowProgress
84803>>>        tSQLConnection SQLConnection
84803>>>        tSQLConnection SQLConnection
84803>>>
84803>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84804>>>        If (bOK = False) Begin
84806>>>            Procedure_Return
84807>>>        End
84807>>>>
84807>>>
84807>>>        If (num_arguments > 2) Begin
84809>>>            Move bShowProgr to bShowProgress
84810>>>        End
84810>>>>
84810>>>
84810>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84811>>>        Get phoSQLManager to hoSqlHandler
84812>>>        Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
84813>>>        Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
84814>>>
84814>>>        If (hoSQLConnect <> 0) Begin
84816>>>            Get SqlOpen of hoSQLConnect to hoStmt
84817>>>            If (hoStmt <> 0) Begin
84819>>>                // record starting date/time stamp
84819>>>                Move (CurrentDateTime()) to dtQueryExecStart
84820>>>                // turn on error handling if enabled
84820>>>                If (pbHandleQueryErrors(Self)) Begin
84822>>>                    Set pbSqlError to False
84823>>>                    Set paSqlErrorArray to aSqlErrorArray
84824>>>                    Move Error_Object_Id to hoError
84825>>>                    If (ghoDbUpdateHandler <> 0) Begin
84827>>>                        Move ghoDbUpdateHandler to Error_Object_Id
84828>>>                    End
84828>>>>
84828>>>                    Else Begin
84829>>>                        Move Self to Error_Object_Id
84830>>>                    End
84830>>>>
84830>>>                End
84830>>>>
84830>>>
84830>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
84830>>>                Set psSQLStatementString to sStmt
84831>>>                Send Cursor_Wait of Cursor_Control
84832>>>                Send SqlExecDirect of hoStmt sStmt
84833>>>                Send Cursor_Ready of Cursor_Control
84834>>>
84834>>>                If (pbHandleQueryErrors(Self)) Begin
84836>>>                    Move hoError to Error_Object_Id
84837>>>                End
84837>>>>
84837>>>
84837>>>                Move 0 to iMsgs
84838>>>                Move Err to iErr
84839>>>                Move LastErr to iLastErr
84840>>>                Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
84841>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
84842>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
84843>>>                Send _SqlColumnInfo hoStmt
84844>>>                Send Ignore_Error of Error_Object_Id 12289
84845>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84846>>>                Repeat
84846>>>>
84846>>>                    Get SqlFetch of hoStmt to iFetchResult
84847>>>                    If (iFetchResult <> 0) Begin
84849>>>                        Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
84850>>>                    End
84850>>>>
84850>>>                Until (iFetchResult = 0)
84852>>>                Send Trap_Error of Error_Object_Id 12289
84853>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
84854>>>                Move iErr to Err
84855>>>                Move iLastErr to LastErr
84856>>>                Set paSQLFetchResults to aSQLFetchResults
84857>>>
84857>>>                Set piRows    to iRows
84858>>>                Set piRowType to iRowType
84859>>>                Move (CurrentDateTime()) to dtQueryExecEnd
84860>>>                Move (CurrentDateTime()) to dtFetchStart
84861>>>
84861>>>                If (iMsgs <> 0) Begin
84863>>>                    If (ghoDbUpdateHandler > 0) Begin
84865>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
84866>>>                    End
84866>>>>
84866>>>                    For i from 1 to iMsgs
84872>>>>
84872>>>                        Get SqlGetMessage of hoStmt i to sMessage
84873>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
84874>>>                        If (bShowProgress = True) Begin
84876>>>                            If (Active_State(ghoStatusPanel)) Begin
84878>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
84879>>>                            End
84879>>>>
84879>>>                            Else Begin
84880>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
84882>>>                            End
84882>>>>
84882>>>                        End
84882>>>>
84882>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
84883>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
84884>>>                    Loop
84885>>>>
84885>>>                    If (ghoDbUpdateHandler > 0) Begin
84887>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
84888>>>                    End
84888>>>>
84888>>>                    Set paQueryMessages to sMsg
84889>>>                End
84889>>>>
84889>>>                Else Begin
84890>>>                    If (bShowProgress = True) Begin
84892>>>                        Get paSqlErrorArray to aSqlErrorArray
84893>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
84895>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
84896>>>                            Decrement iMsgs
84897>>>                            For i from 0 to iMsgs
84903>>>>
84903>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
84906>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
84909>>>                            Loop
84910>>>>
84910>>>                        End
84910>>>>
84910>>>                    End
84910>>>>
84910>>>                End
84910>>>>
84910>>>                Move (CurrentDateTime()) to dtFetchEnd
84911>>>            End
84911>>>>
84911>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
84912>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
84913>>>            Set ptsQueryExec to tsQuery
84914>>>            Set ptsFetchResults to tsFetch
84915>>>            Send SqlClose of hoStmt
84916>>>        End
84916>>>>
84916>>>
84916>>>        Send SqlDisconnect of hoSQLConnect
84917>>>    End_Procedure
84918>>>
84918>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
84918>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
84918>>>    // Returns False if no error occured.
84918>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
84920>>>        Boolean bOK bShowProgress
84920>>>        tSQLScriptArray SQLScriptArray
84920>>>        tSQLScriptArray SQLScriptArray
84920>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
84920>>>        TimeSpan tsTotalTime
84920>>>
84920>>>        Move (CurrentDateTime()) to dtTotalQueryStart
84921>>>        Get _SqlUtilReadResource sMemFileName to SQLScriptArray
84922>>>        If (SQLScriptArray.bError = True) Begin
84924>>>            Function_Return False
84925>>>        End
84925>>>>
84925>>>
84925>>>        If (num_arguments > 3) Begin
84927>>>            Move bShowProgr to bShowProgress
84928>>>        End
84928>>>>
84928>>>
84928>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84929>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
84930>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84931>>>
84931>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
84932>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
84933>>>        Set ptsTotalQueryTime to tsTotalTime
84934>>>
84934>>>        Function_Return bOK
84935>>>    End_Function
84936>>>
84936>>>    // * Dummy function for the Studio's Code Explorer *
84936>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
84938>>>        Function_Return False
84939>>>    End_Function
84940>>>
84940>>>    // Does three things with auxilirary files;
84940>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
84940>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
84940>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
84940>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
84942>>>        String sDataPath sDDSrcPath sDriverID
84942>>>        Boolean bOK bExists
84942>>>        Integer iCount iCh iPos
84942>>>
84942>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
84942>>>        If (sTableName contains ".") Begin
84944>>>            Move (Pos(".", sTableName)) to iPos
84945>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
84946>>>        End
84946>>>>
84946>>>
84946>>>        Get psDriverID to sDriverID
84947>>>        Get psDataPathFirstPart to sDataPath
84948>>>        Get vFolderExists sDataPath to bOK
84949>>>        If (bOK = False) Begin
84951>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
84952>>>>
84952>>>            Function_Return False
84953>>>        End
84953>>>>
84953>>>
84953>>>        // First delete the cache file:
84953>>>        Get _UtilDeleteCacheFile sTableName to bOK
84954>>>
84954>>>        Get Seq_New_Channel to iCh
84955>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84957>>>            Function_Return False
84958>>>        End
84958>>>>
84958>>>
84958>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
84959>>>        If (bExists = False) Begin
84961>>>            Function_Return False
84962>>>        End
84962>>>>
84962>>>
84962>>>        Get _SqlUtilUpdateIntFile hTable to bOK
84963>>>        // Add the new column name to the .tag filen (if it doesn't exist):
84963>>>        Get _UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
84964>>>
84964>>>        // If in development environment; output new .fd file:
84964>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
84965>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
84966>>>        If (iCount > 1) Begin
84968>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
84969>>>        End
84969>>>>
84969>>>        Get vFolderExists sDDSrcPath to bExists
84970>>>        If (bExists = True) Begin
84972>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
84973>>>            Move False to Err
84974>>>            Get AutoConnectionIDLogin to bOK
84975>>>            If (hTable <> 0) Begin
84977>>>                Open hTable
84979>>>            End
84979>>>>
84979>>>            Else Begin
84980>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
84981>>>            End
84981>>>>
84981>>>
84981>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
84984>>>            If (bOK = True) Begin
84986>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
84988>>>            End
84988>>>>
84988>>>            If (Err = True) Begin
84990>>>                Move False to bOK
84991>>>            End
84991>>>>
84991>>>        End
84991>>>>
84991>>>
84991>>>        Function_Return (bOK = True)
84992>>>    End_Function
84993>>>
84993>>>    // Message for changing .int files to use connection ID's
84993>>>    //
84993>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
84993>>>    // OR changes an existing connection id to a new id.
84993>>>    // Pass the full path to the data folder and the name of the connection id (string value).
84993>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
84993>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
84995>>>        String sFileName sDriverID sDriverFile sConnectionString
84995>>>        String[] sFilesData
84996>>>        Boolean bOK bCancel
84996>>>        Integer iSize iCount
84996>>>
84996>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
84997>>>        Move (SizeOfArray(sFilesData))    to iSize
84998>>>        If (iSize = 0) Begin
85000>>>            If (ghoStatusPanel <> 0) Begin
85002>>>                If (Active_State(ghoStatusPanel)) Begin
85004>>>                    Send Stop_StatusPanel of ghoStatusPanel
85005>>>                End
85005>>>>
85005>>>            End
85005>>>>
85005>>>            Send Info_Box CS_DUF_NoIntFilesFound
85006>>>            Procedure_Return
85007>>>        End
85007>>>>
85007>>>
85007>>>        Move (Trim(sConnectionID)) to sConnectionID
85008>>>        Get vFolderFormat sDataPath to sDataPath
85009>>>        Decrement iSize
85010>>>        For iCount from 0 to iSize
85016>>>>
85016>>>            Move sFilesData[iCount] to sFileName
85017>>>            // This makes sure that we also can change an existing connection id to something new:
85017>>>            Get _UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
85018>>>            If (ghoStatusPanel <> 0) Begin
85020>>>                If (Active_State(ghoStatusPanel)) Begin
85022>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
85023>>>                    If (bCancel = True) Begin
85025>>>                        Send Deactivate of ghoStatusPanel
85026>>>                        Procedure_Return
85027>>>                    End
85027>>>>
85027>>>                End
85027>>>>
85027>>>            End
85027>>>>
85027>>>        Loop
85028>>>>
85028>>>
85028>>>        Get psDriverID to sDriverID
85029>>>
85029>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85029>>>        Move "" to sFileName
85030>>>        If (sDriverID = MSSQLDRV_ID) Begin
85032>>>            Move "MSSQLDrv.int" to sFileName
85033>>>        End
85033>>>>
85033>>>        If (sDriverID = DB2_DRV_ID) Begin
85035>>>            Move "DB2_Drv.int" to sFileName
85036>>>        End
85036>>>>
85036>>>        If (sDriverID = ODBC_DRV_ID) Begin
85038>>>            Move "ODBC_Drv.int" to sFileName
85039>>>        End
85039>>>>
85039>>>        If (sFileName <> "") Begin
85041>>>            Move "" to sDriverFile
85042>>>            Get_File_Path sFileName to sDriverFile
85043>>>            If (sDriverFile <> "") Begin
85045>>>                Get psConnectionString to sConnectionString
85046>>>                Get _UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85047>>>            End
85047>>>>
85047>>>        End
85047>>>>
85047>>>    End_Procedure
85048>>>
85048>>>    // Checks if the database exists in SQL. Returns = True if it does.
85048>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85050>>>        String[] sDatabaseArray
85051>>>        String sVal sServer sDriverID
85051>>>        Integer iCount iSize iPos
85051>>>        Boolean bExists
85051>>>        tSQLConnection SQLConnection
85051>>>        tSQLConnection SQLConnection
85051>>>
85051>>>        Move False to bExists
85052>>>        Get psDriverID to sDriverID
85053>>>        // DB2 doesn't have a "Database" name, so we always return True.
85053>>>        If (sDriverID = DB2_DRV_ID) Begin
85055>>>            Function_Return bExists
85056>>>        End
85056>>>>
85056>>>
85056>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
85057>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
85059>>>            Function_Return False
85060>>>        End
85060>>>>
85060>>>
85060>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85061>>>        Move SQLConnection.sServer to sServer
85062>>>
85062>>>        // Special code to handle a FILEDSN that also can contain "/"
85062>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
85064>>>            Move sDatabaseArray[0] to sVal  // Dummy!
85065>>>        End
85065>>>>
85065>>>        Else If (sServer contains "/") Begin
85068>>>            Move (Pos("/", sServer)) to iPos
85069>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
85070>>>        End
85070>>>>
85070>>>
85070>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
85071>>>        Decrement iSize
85072>>>        For iCount from 0 to iSize
85078>>>>
85078>>>            Move sDatabaseArray[iCount] to sVal
85079>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
85081>>>                Move True to bExists
85082>>>                If (bExists = True) Begin
85084>>>                    Move iSize to iCount // We're done.
85085>>>                End
85085>>>>
85085>>>            End
85085>>>>
85085>>>        Loop
85086>>>>
85086>>>
85086>>>        Function_Return bExists
85087>>>    End_Function
85088>>>
85088>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85088>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85090>>>        String sDatabase sSchema sTableName sVal
85090>>>        Boolean bExists
85090>>>        String[] sTablesArray
85091>>>        Integer iSize iCount
85091>>>
85091>>>        Move False to bExists
85092>>>        Get UtilTableHandleToString hTable to sTableName
85093>>>        Get psDatabase to sDatabase
85094>>>        Get psSchema   to sSchema
85095>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85096>>>        Move (SizeOfArray(sTablesArray)) to iSize
85097>>>        Decrement iSize
85098>>>        For iCount from 0 to iSize
85104>>>>
85104>>>            Move sTablesArray[iCount] to sVal
85105>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85107>>>                Move True to bExists
85108>>>                Move iSize to iCount // We're done!
85109>>>            End
85109>>>>
85109>>>        Loop
85110>>>>
85110>>>
85110>>>        Function_Return bExists
85111>>>    End_Function
85112>>>
85112>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
85114>>>        String sVal sTableSpelledCorrectly
85114>>>        Boolean bExists
85114>>>        String[] sTablesArray
85115>>>        Integer iSize iCount
85115>>>
85115>>>        Move False to bExists
85116>>>        Move sTableName to sTableSpelledCorrectly
85117>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85118>>>        Move (SizeOfArray(sTablesArray)) to iSize
85119>>>        Decrement iSize
85120>>>        For iCount from 0 to iSize
85126>>>>
85126>>>            Move sTablesArray[iCount] to sVal
85127>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85129>>>                Move sVal to sTableSpelledCorrectly
85130>>>                Move iSize to iCount // We're done!
85131>>>            End
85131>>>>
85131>>>        Loop
85132>>>>
85132>>>
85132>>>        Function_Return sTableSpelledCorrectly
85133>>>    End_Function
85134>>>
85134>>>    // ToDo: This index name function needs to be finished...
85134>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85136>>>        String sSchema sTableName sDriverID
85136>>>        Boolean bExists
85136>>>
85136>>>        Get psDriverID to sDriverID
85137>>>        Get psSchema to sSchema
85138>>>        Get UtilTableHandleToString hTable to sTableName
85139>>>
85139>>>        Function_Return bExists
85140>>>    End_Function
85141>>>
85141>>>    // Checks if a column/field name exists in a SQL table definition
85141>>>    // Returns True if it does
85141>>>    // Sample:
85141>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
85141>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
85143>>>        Integer iNumColumns iColumn
85143>>>        String sColumn sDriverID
85143>>>        String[] sColumnsArray
85144>>>        Boolean bExists bOK
85144>>>
85144>>>        Move False to bExists
85145>>>        Get AutoConnectionIDLogin to bOK
85146>>>        Get psDriverID to sDriverID
85147>>>
85147>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
85148>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
85149>>>        Decrement iNumColumns
85150>>>        For iColumn from 0 to iNumColumns
85156>>>>
85156>>>            Move sColumnsArray[iColumn] to sColumn
85157>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
85159>>>                Move True to bExists
85160>>>                Move iNumColumns to iColumn // We're out of here
85161>>>            End
85161>>>>
85161>>>        Loop
85162>>>>
85162>>>
85162>>>        Function_Return bExists
85163>>>    End_Function
85164>>>
85164>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
85166>>>        Integer iNumColumns iColumn iDFType iNativeType
85166>>>        Boolean bOpened bOK
85166>>>        String sColumnName sNativeTypeName
85166>>>
85166>>>        Get AutoConnectionIDLogin to bOK
85167>>>        Get OpenTableExclusive hTable to bOK
85168>>>        If (bOK = False) Begin
85170>>>            Function_Return False
85171>>>        End
85171>>>>
85171>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85174>>>        If (bOpened = False) Begin
85176>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
85177>>>>
85177>>>            Function_Return False
85178>>>        End
85178>>>>
85178>>>
85178>>>        Move False to Err
85179>>>
85179>>>        Structure_Start hTable
85180>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
85183>>>
85183>>>            For iColumn from 1 to iNumColumns
85189>>>>
85189>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
85192>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
85195>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
85198>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
85201>>>
85201>>>                Case Begin
85201>>>                    Case (iDFType = DF_DATE)
85203>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85205>>>                            // Convert datetime to date
85205>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
85208>>>                        End
85208>>>>
85208>>>                        Case Break
85209>>>                    Case (iDFType = DF_DATETIME)
85212>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85214>>>                            // Convert datetime to datetime2
85214>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
85217>>>                        End
85217>>>>
85217>>>                        Case Break
85218>>>                    Case (iDFType = DF_ASCII)
85221>>>                        If (iNativeType = SQL_CHAR) Begin
85223>>>                            // Convert char to varchar
85223>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85226>>>                        End
85226>>>>
85226>>>                        Case Break
85227>>>                    Case (iDFType = DF_TEXT)
85230>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
85232>>>                            // Convert text to varchar(max)
85232>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85235>>>                        End
85235>>>>
85235>>>                        Case Break
85236>>>                    Case (iDFType = DF_BINARY)
85239>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
85241>>>                            // Convert image to varbinary(max)
85241>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
85244>>>                        End
85244>>>>
85244>>>                        Case Break
85245>>>                Case End
85245>>>            Loop
85246>>>>
85246>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85247>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85249>>>
85249>>>        Set Action_Text of ghoStatusPanel to ""
85250>>>        Function_Return (Err = False)
85251>>>    End_Function
85252>>>
85252>>>
85252>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
85252>>>    // the DbUpdateVersion database revision in.
85252>>>    // Also pass the file number of the current (embedded?) table number used in development.
85252>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
85252>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
85254>>>        Boolean bOK bOpened
85254>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
85254>>>
85254>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85257>>>        Get _TableNameOnly sTableName to sTableName
85258>>>        If (sTableName = "") Begin
85260>>>            Function_Return False
85261>>>        End
85261>>>>
85261>>>
85261>>>        // This just creates the table and a "dummy" column.
85261>>>        Get SqlTableCreate hTable sDriverID to bOK
85262>>>        If (bOK = False) Begin
85264>>>            Function_Return False
85265>>>        End
85265>>>>
85265>>>
85265>>>        Close hTable
85266>>>        Move False to Err
85267>>>
85267>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
85268>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
85269>>>        Move "Decimal" to sDataType
85270>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
85271>>>
85271>>>        // Adds the "sColumnName" passed to the function
85271>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
85272>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85273>>>
85273>>>        // Now we can delete the dummy column:
85273>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
85274>>>
85274>>>        // Finally, we attach to the newly created table.
85274>>>        If (Err = False) Begin
85276>>>            Get ApiTableAttachToSQL hTable True to bOK
85277>>>        End
85277>>>>
85277>>>        Open hTable
85279>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85282>>>
85282>>>        Function_Return (Err = False and bOK = True and bOpened = True)
85283>>>    End_Function
85284>>>
85284>>>    // Returns a handle to the SQL server associated with the passed driver ID.
85284>>>    // Pass e.g. the psServer property to determine the current connection server.
85284>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
85284>>>    // This handle can be used to obtain attributes about the server, such as default
85284>>>    // column types.
85284>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
85286>>>        Handle hDatabase
85286>>>        Integer iDriver iServers iCount
85286>>>        String sValue
85286>>>
85286>>>        If (sServer = "") Begin
85288>>>            Function_Return 0
85289>>>        End
85289>>>>
85289>>>
85289>>>        Get DriverIndex sDriverID to iDriver
85290>>>        If (iDriver = 0) Begin
85292>>>            Function_Return 0
85293>>>        End
85293>>>>
85293>>>
85293>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
85296>>>        For iCount from 1 to iServers
85302>>>>
85302>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
85305>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
85307>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
85310>>>            End
85310>>>>
85310>>>        Loop
85311>>>>
85311>>>
85311>>>        Function_Return hDatabase
85312>>>    End_Function
85313>>>
85313>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
85313>>>//        String sRootName
85313>>>//        Boolean bOK
85313>>>//
85313>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85313>>>//        Move (sRootName contains sDriverID) to bOK
85313>>>//
85313>>>//        Function_Return bOK
85313>>>//    End_Function
85313>>>
85313>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
85313>>>//        String sDriverID sRootName sDisplayName sSchema sVal
85313>>>//        Integer iDbType
85313>>>//        Boolean bOK
85313>>>//
85313>>>//        Get UtilIsFilelistEntryDriverBased to bOK
85313>>>//        If (bOK = True) Begin
85313>>>//            Function_Return False
85313>>>//        End
85313>>>//
85313>>>//        Get psDriverID to sDriverID
85313>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85313>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
85313>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85313>>>//
85313>>>//        Get psDriverID to sDriverID
85313>>>//        Get piDbType   to iDbType
85313>>>//        Get psSchema   to sSchema
85313>>>//        If (sSchema = "") Begin
85313>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85313>>>//        End
85313>>>//
85313>>>//        Move (Uppercase(sDisplayName)) to sVal
85313>>>//        If (not(sVal contains (sSchema + "."))) Begin
85313>>>//            If (iDbType = EN_dbTypeDB2) Begin
85313>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85313>>>//            End
85313>>>//            Else Begin
85313>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
85313>>>//            End
85313>>>//        End
85313>>>//
85313>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85313>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85313>>>//
85313>>>//        Function_Return True
85313>>>//    End_Function
85313>>>
85313>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
85313>>>    // from the passed filelist.
85313>>>    // Returns the number of tables affected.
85313>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
85315>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
85315>>>        Integer iRetval
85315>>>        Handle hTable
85315>>>
85315>>>        // We first save the current filelist as the passed filelist name
85315>>>        // may come from another workspace, to restore it when we're ready.
85315>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
85318>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
85321>>>        Move 0 to hTable
85322>>>        Move 0 to iRetval
85323>>>
85323>>>        Repeat
85323>>>>
85323>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85326>>>            If (hTable <> 0) Begin
85328>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85331>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85334>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85337>>>                Move (Uppercase(sRootName)) to sVal
85338>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
85340>>>                    // Prefixes:
85340>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
85341>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
85342>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
85343>>>                    // Suffixes:
85343>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
85344>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
85345>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
85346>>>
85346>>>                    // Change Filelist entry:
85346>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
85349>>>
85349>>>                    Move (Lowercase(sDisplayName)) to sVal
85350>>>                    If (sVal contains "dbo.") Begin
85352>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
85353>>>
85353>>>                        // Change Filelist entry:
85353>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
85356>>>                    End
85356>>>>
85356>>>                    Increment iRetval
85357>>>                End
85357>>>>
85357>>>            End
85357>>>>
85357>>>        Until (hTable = 0)
85359>>>
85359>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
85362>>>
85362>>>        Function_Return iRetval
85363>>>    End_Function
85364>>>
85364>>>    // To open all Sql based tables in Filelist.cfg
85364>>>    Procedure SqlUtilOpenAllTables
85366>>>        Handle hTable
85366>>>        String sRoot sDriverID
85366>>>        Boolean bOK
85366>>>
85366>>>        Move 0 to hTable
85367>>>        Move "" to sDriverID
85368>>>        Get AutoConnectionIDLogin to bOK
85369>>>
85369>>>        Repeat
85369>>>>
85369>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85372>>>            If (hTable > 0) Begin
85374>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85377>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
85379>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
85382>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
85384>>>                        Open hTable
85386>>>                    End
85386>>>>
85386>>>                End
85386>>>>
85386>>>            End
85386>>>>
85386>>>
85386>>>        Until (hTable = 0)
85388>>>    End_Procedure
85389>>>
85389>>>//    Function SqlUtilSchemaName Handle hTable Returns String
85389>>>//        String sRetval sDriverID
85389>>>//        String sTableName
85389>>>//        Integer iDbType iIndex
85389>>>//        Boolean bOK
85389>>>//
85389>>>//        Get psDriverID to sDriverID
85389>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
85389>>>//        If (hTable = 0 or bOK = False) Begin
85389>>>//            Function_Return ""
85389>>>//        End
85389>>>//
85389>>>//        Move False to Err
85389>>>//        Get UtilTableHandleToString hTable to sTableName
85389>>>//        Get piDbType to iDbType
85389>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
85389>>>//        If (iIndex = -1) Begin
85389>>>//            Function_Return ""
85389>>>//        End
85389>>>//
85389>>>//        Function_Return sRetval
85389>>>//    End_Function
85389>>>
85389>>>    // Checks if the passed Table;
85389>>>    // 1) Already has a Filelist entry that points to SQL and
85389>>>    // 2) It has an .int file.
85389>>>    // If both is True it should already be connected to SQL
85389>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
85391>>>        Boolean bExists bRootName
85391>>>        String sRootName sDataPath
85391>>>
85391>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85394>>>        Move (sRootName contains sDriverID) to bRootName
85395>>>
85395>>>        Get psDataPathFirstPart to sDataPath
85396>>>        Get vFolderExists sDataPath to bExists
85397>>>        If (bExists = False) Begin
85399>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
85399>>>            Function_Return False
85400>>>        End
85400>>>>
85400>>>
85400>>>        Get vFolderFormat sDataPath to sDataPath
85401>>>        Get _TableNameOnly sRootName to sRootName
85402>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
85403>>>
85403>>>        Function_Return (bRootName = True and bExists = True)
85404>>>    End_Function
85405>>>
85405>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
85407>>>        Boolean bViewTableType bOpen bOK
85407>>>        Integer iTableCount iNumTables
85407>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
85407>>>        Handle hoCliHandler
85407>>>        tSQLConnection SQLConnection
85407>>>        tSQLConnection SQLConnection
85407>>>
85407>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85410>>>        If (bOpen = False) Begin
85412>>>            Get AutoConnectionIDLogin to bOK
85413>>>            Open hTable
85415>>>        End
85415>>>>
85415>>>
85415>>>        Get pSQLConnection to SQLConnection
85416>>>        Get phoCLIHandler to hoCliHandler
85417>>>        Set psDriverID of hoCliHandler to sDriverID
85418>>>
85418>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85421>>>        Get _TableNameOnly sTableName to sTableName
85422>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
85425>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
85426>>>
85426>>>        For iTableCount from 1 to iNumTables
85432>>>>
85432>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
85433>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
85434>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
85436>>>                Get TableType of hoCliHandler iTableCount to sTableType
85437>>>                Move iNumTables to iTableCount // We're done.
85438>>>            End
85438>>>>
85438>>>        Loop
85439>>>>
85439>>>
85439>>>        Move (sTableType = "VIEW") to bViewTableType
85440>>>        If (bOpen = False) Begin
85442>>>            Close hTable
85443>>>        End
85443>>>>
85443>>>
85443>>>        Function_Return bViewTableType
85444>>>    End_Function
85445>>>
85445>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
85445>>>    //
85445>>>    // SQL utility function that returns a database type (string) constant
85445>>>    // corresponding to the passed iDbType.
85445>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
85447>>>        String sRetval
85447>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85448>>>        Function_Return sRetval
85449>>>    End_Function
85450>>>
85450>>>    // SQL utility function that returns a database type constant (integer)
85450>>>    // corresponding to the passed sDbType string constant.
85450>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
85452>>>        Integer iRetval
85452>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
85453>>>        Function_Return iRetval
85454>>>    End_Function
85455>>>
85455>>>    // Pass an integer DbType and function returns the database type integer as a string value.
85455>>>    // Used e.g. when reading a connection ini-file to display the database type in
85455>>>    // the SQL Connection program's grid.
85455>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
85457>>>        String sRetval
85457>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85458>>>        Function_Return sRetval
85459>>>    End_Function
85460>>>
85460>>>    // Pass a driver name as a string and the function will return
85460>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
85460>>>    // quite work and always returns "MS SQL Server"
85460>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
85462>>>        Integer iRetval
85462>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
85463>>>        Function_Return iRetval
85464>>>    End_Function
85465>>>
85465>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
85465>>>    // that "fits" in the max allowed length for table names.
85465>>>    // Max number of characters allowed for table names;
85465>>>    // IBM DB2      = 128
85465>>>    // MS-SQL       = 128
85465>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
85465>>>    // MySQL        = 64
85465>>>    // PostgreSQL   = 64
85465>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
85467>>>        String sGUIDName
85467>>>        Integer iDbType iLength
85467>>>
85467>>>        Get piDbType to iDbType
85468>>>        Move (RandomHexUUID()) to sGUIDName
85469>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
85470>>>        Move (Length(sGUIDName)) to iLength
85471>>>
85471>>>        Case Begin
85471>>>            Case (iDbType = EN_DbTypeDB2)
85473>>>            If (iLength > 128) Begin
85475>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85476>>>            End
85476>>>>
85476>>>            Case Break
85477>>>
85477>>>            Case (iDbType = EN_DbTypeMSSQL)
85480>>>            If (iLength > 128) Begin
85482>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85483>>>            End
85483>>>>
85483>>>            Case Break
85484>>>
85484>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
85487>>>            If (iLength > 128) Begin
85489>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85490>>>            End
85490>>>>
85490>>>            Case Break
85491>>>
85491>>>            Case (iDbType = EN_DbTypeMySQL)
85494>>>            If (iLength > 64) Begin
85496>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85497>>>            End
85497>>>>
85497>>>            Case Break
85498>>>
85498>>>            Case (iDbType = EN_DbTypePostgre)
85501>>>            If (iLength > 64) Begin
85503>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85504>>>            End
85504>>>>
85504>>>        Case End
85504>>>
85504>>>        Function_Return sGUIDName
85505>>>    End_Function
85506>>>
85506>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
85506>>>    // Pass the memory resource file reference and the filename to be created,
85506>>>    // including full path.
85506>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
85508>>>        String sText
85508>>>        Integer iCh iSize iArgSize
85508>>>
85508>>>        Move ("Resource:" + sMemFileName) to sMemFileName
85509>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
85510>>>        Get_Channel_Size iCh to iSize
85511>>>        Read_Block channel iCh sText iSize
85513>>>        Send Seq_Close_Channel iCh
85514>>>
85514>>>        Get Seq_Open_Output_Channel sFileName to iCh
85515>>>            Write channel iCh sText
85517>>>        Send Seq_Close_Channel iCh
85518>>>
85518>>>        // Wait for file to be written to disk.
85518>>>        Sleep 2
85519>>>    End_Procedure
85520>>>
85520>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
85522>>>        String sNotNull sRetval sDefaultValue
85522>>>        Boolean bOK
85522>>>
85522>>>        Get IsSQLDriver sDriverID to bOK
85523>>>        If (bOK = False) Begin
85525>>>            Function_Return ""
85526>>>        End
85526>>>>
85526>>>
85526>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
85527>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
85528>>>
85528>>>        Case Begin
85528>>>            Case (iDbType = EN_dbTypeMSSQL)
85530>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
85531>>>                Case Break
85532>>>            Case (iDbType = EN_dbTypeMySQL)
85535>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85536>>>                Case Break
85537>>>            Case (iDbType = EN_dbTypePostgre)
85540>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85541>>>                Case Break
85542>>>            Case (iDbType = EN_dbTypeDB2)
85545>>>                Move (String(sNotNull))                                     to sRetval
85546>>>                Case Break
85547>>>
85547>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
85547>>>            // ToDo: We need to look deeper into how Oracle handles NULL
85547>>>            Case (iDbType = EN_dbTypeOracle)
85550>>>                Move  ""                                                    to sRetval
85551>>>                Case Break
85552>>>
85552>>>            Case Else
85552>>>                Move  ""                                                    to sRetval
85553>>>        Case End
85553>>>
85553>>>        Function_Return sRetval
85554>>>    End_Function
85555>>>
85555>>>    // * Dummy function for the Studio's Code Explorer *
85555>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
85557>>>        Function_Return False
85558>>>    End_Function
85559>>>
85559>>>    // Enumerate SQL Servers.
85559>>>    // Pass a driver id. Returns a string array.
85559>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
85559>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
85559>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
85561>>>        String[] sReturnArray
85562>>>        Handle hoSQLHandler
85562>>>        String sServer
85562>>>        Integer iCount iNumItems iDataSourceType
85562>>>
85562>>>        If (num_arguments > 1) Begin
85564>>>            Move iDatSrcType to iDataSourceType
85565>>>        End
85565>>>>
85565>>>
85565>>>        Case Begin
85565>>>            Case (sDriverID = MSSQLDRV_ID)
85567>>>                Get phoMSSQLHandler to hoSQLHandler
85568>>>                Get EnumerateServers of hoSQLHandler to iNumItems
85569>>>                For iCount from 0 to (iNumItems - 1)
85575>>>>
85575>>>                    Get String_Value of hoSQLHandler iCount to sServer
85576>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
85577>>>                Loop
85578>>>>
85578>>>                Case Break
85579>>>
85579>>>            Case (sDriverID = DB2_DRV_ID)
85582>>>                Get phoDB2SQLHandler to hoSQLHandler
85583>>>                Send SeedDataSources of hoSQLHandler
85584>>>                Move 0 to iCount
85585>>>                Repeat
85585>>>>
85585>>>                    Get DataSources of hoSQLHandler to sServer
85586>>>                    If (sServer <> "") Begin
85588>>>                        Move (Replace(",", sServer, "")) to sServer
85589>>>                        Move sServer to sReturnArray[iCount]
85590>>>                    End
85590>>>>
85590>>>                    Increment iCount
85591>>>                Until (sServer = "")
85593>>>                Case Break
85594>>>
85594>>>            Case (sDriverID = ODBC_DRV_ID)
85597>>>                Get phoODBCSQLHandler to hoSQLHandler
85598>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
85599>>>                Move 0 to iCount
85600>>>                Repeat
85600>>>>
85600>>>                    Get DataSources of hoSQLHandler to sServer
85601>>>                    If (sServer <> "") Begin
85603>>>                        Move (Replace(",", sServer, ", ")) to sServer
85604>>>                        Move sServer to sReturnArray[iCount]
85605>>>                    End
85605>>>>
85605>>>                    Increment iCount
85606>>>                Until (sServer = "")
85608>>>                Case Break
85609>>>
85609>>>            Case Else
85609>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
85610>>>>
85610>>>        Case End
85610>>>
85610>>>        Function_Return sReturnArray
85611>>>    End_Function
85612>>>
85612>>>    // Returns all databases as a string array for the passed driver id.
85612>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
85614>>>        String[] sReturnArray
85615>>>        String sServer sVal
85615>>>        tSQLIntTableInfo[] sReturnStructArray
85615>>>        tSQLIntTableInfo[] sReturnStructArray
85616>>>        tSQLConnection SQLConnection
85616>>>        tSQLConnection SQLConnection
85616>>>        Boolean bOK
85616>>>        Integer iCount iSize
85616>>>
85616>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85617>>>        If (bOK = False) Begin
85619>>>            Function_Return sReturnArray
85620>>>        End
85620>>>>
85620>>>
85620>>>        Case Begin
85620>>>            Case (sDriverID = MSSQLDRV_ID)
85622>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
85623>>>                Case Break
85624>>>            Case (sDriverID = DB2_DRV_ID)
85627>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
85628>>>                Case Break
85629>>>
85629>>>            // This is needed to be able to check if a database exists or not.
85629>>>            Case (sDriverID = ODBC_DRV_ID)
85632>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
85633>>>                If (SizeOfArray(sReturnStructArray)) Begin
85635>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
85637>>>                        // If a FILEDSN: (can only be one database name)
85637>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
85638>>>                    End
85638>>>>
85638>>>                    Else Begin
85639>>>                        // Else the DSN's were read from the registry.
85639>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85640>>>                        Move SQLConnection.sServer to sServer
85641>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
85642>>>                        Decrement iSize
85643>>>                        for iCount from 0 to iSize
85649>>>>
85649>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
85650>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
85652>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
85653>>>                                Move iSize to iCount // We're done.
85654>>>                            End
85654>>>>
85654>>>                        Loop
85655>>>>
85655>>>                    End
85655>>>>
85655>>>                End
85655>>>>
85655>>>                Case Break
85656>>>
85656>>>            Case Else
85656>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
85656>>>        Case End
85656>>>
85656>>>        Function_Return sReturnArray
85657>>>    End_Function
85658>>>
85658>>>    
85658>>>    // *** Database API Functions: ***
85658>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
85658>>>    // make changes/updates to the database.
85658>>>
85658>>>    // * Dummy function for the Studio's Code Explorer *
85658>>>    Function API_TABLE_FUNCTIONS Returns Boolean
85660>>>        Function_Return False
85661>>>    End_Function
85662>>>
85662>>>    // This might not do what you think - Here's what it does:
85662>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
85662>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
85662>>>    // to the SQL table.
85662>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
85662>>>    // already exists in SQL.
85662>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
85662>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
85662>>>    // restructuring an existing table.
85662>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
85664>>>        Boolean bExists bOpened bOK bSystemFile bUseConnectionID bIsAlias
85664>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
85664>>>        Handle hToTable
85664>>>
85664>>>        Move True to bUseConnectionID
85665>>>        If (num_arguments > 1) Begin
85667>>>            Move bUseConnID to bUseConnectionID
85668>>>        End
85668>>>>
85668>>>
85668>>>        Get psDriverID to sDriverID
85669>>>        // If the table doesn't exist on the SQL back-end we do nothing.
85669>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
85670>>>        If (bExists = False) Begin
85672>>>            Function_Return False
85673>>>        End
85673>>>>
85673>>>
85673>>>        Get UtilTableIsAlias hTable to bIsAlias
85674>>>
85674>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85675>>>        If (bOK = False) Begin
85677>>>            Function_Return False
85678>>>        End
85678>>>>
85678>>>
85678>>>        // Then we need to check that the function hasn't been called before; which in case
85678>>>        // we do nothing
85678>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
85679>>>        If (bExists = True) Begin
85681>>>            Function_Return False
85682>>>        End
85682>>>>
85682>>>
85682>>>        Get psConnectionID     to sConnectionID
85683>>>        Get psConnectionString to sConnectionString
85684>>>        If (sConnectionID = "" or sConnectionString = "") Begin
85686>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
85687>>>>
85687>>>            Function_Return False
85688>>>        End
85688>>>>
85688>>>
85688>>>        Set Private.phCurrentTable to hTable
85689>>>        Get psSchema to sSchema
85690>>>        If (sSchema = "") Begin
85692>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85693>>>        End
85693>>>>
85693>>>
85693>>>        // If we should use a connection id we need to check it exists;
85693>>>        // else we create it before attempting creating the table
85693>>>        If (bUseConnectionID = True) Begin
85695>>>            Get AutoConnectionIDLogin to bOK
85696>>>            If (bOk = False) Begin
85698>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
85699>>>>
85699>>>                Function_Return False
85700>>>            End
85700>>>>
85700>>>        End
85700>>>>
85700>>>
85700>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85703>>>        Get _TableNameOnly sRootName to sRootName
85704>>>        If (sRootName = "") Begin
85706>>>            Function_Return False
85707>>>        End
85707>>>>
85707>>>        Move (sRootName + ".int")                    to sPhysicalName
85708>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85711>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85714>>>
85714>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
85714>>>        //
85714>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
85714>>>        // because then the table should not be visible to users.
85714>>>//        Move (Pos("@", sDisplayName)) to iPos
85714>>>//        If (iPos <> 1) Begin
85714>>>//            If (sDisplayName contains ".") Begin
85714>>>//                Move (Pos(".", sDisplayName)) to iPos
85714>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
85714>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
85714>>>//            End
85714>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
85714>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85714>>>//            End
85714>>>//        End
85714>>>
85714>>>        If (bIsAlias = False) Begin
85716>>>            Get OpenTableExclusive hTable to bOpened
85717>>>            If (bOpened = False) Begin
85719>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
85720>>>>
85720>>>                Function_Return False
85721>>>            End
85721>>>>
85721>>>        End
85721>>>>
85721>>>
85721>>>        If (ghoProgressBar <> 0) Begin
85723>>>            Send DoAdvance of ghoProgressBar
85724>>>            Set Message_Text of ghoStatusPanel to ""
85725>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
85726>>>        End
85726>>>>
85726>>>        // Note: The hToTable will get changed by the Structure_xxx command...
85726>>>        Move hTable to hToTable
85727>>>        Move False to Err
85728>>>
85728>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
85728>>>        // then we do a pseudo .int file change with the "_SqlUtilUpdateIntFile" function. After that we have
85728>>>        // a proper and updated .int file.
85728>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
85731>>>        Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
85732>>>
85732>>>        If (bIsAlias = False) Begin
85734>>>            Structure_Start hToTable sDriverID
85735>>>                Set Private.phCurrentTable to hTable
85736>>>                If (bUseConnectionID = True) Begin
85738>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
85741>>>                End
85741>>>>
85741>>>                Else Begin
85742>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
85745>>>                End
85745>>>>
85745>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
85748>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
85748>>>                Move False to Err
85749>>>                Move 0 to LastErr
85750>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85751>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85753>>>            Set Action_Text of ghoStatusPanel to ""
85754>>>        End
85754>>>>
85754>>>
85754>>>        Move (not(Err)) to bOK
85755>>>        If (bOK = True) Begin
85757>>>            // The attributes set above will always trigger an error
85757>>>            // We also adjust the Filelist entries
85757>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
85760>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85763>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85766>>>
85766>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
85766>>>            Get _SqlUtilUpdateIntFile hTable to bOK
85767>>>        End
85767>>>>
85767>>>
85767>>>        Function_Return (bOK = True)
85768>>>    End_Function
85769>>>
85769>>>    // Sample usage:
85769>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
85769>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
85769>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
85771>>>        Boolean bOK bIsSQLTable
85771>>>
85771>>>        Get AutoConnectionIDLogin to bOK
85772>>>        Move False to Err
85773>>>        Get OpenTableExclusive hTable to bOK
85774>>>        If (bOK = False) Begin
85776>>>            Function_Return False
85777>>>        End
85777>>>>
85777>>>
85777>>>        // ToDo: Add to all table change functions!
85777>>>            Get _UtilTableIsSql hTable to bIsSQLTable
85778>>>            If (bIsSQLTable = True) Begin
85780>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85783>>>            End
85783>>>>
85783>>>
85783>>>        Set Private.phCurrentTable to hTable
85784>>>        Structure_Start hTable
85785>>>            Set_Attribute iAttribute of hTable to iValue
85788>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85789>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85791>>>
85791>>>        Set Action_Text of ghoStatusPanel to ""
85792>>>        Function_Return (Err = False)
85793>>>    End_Function
85794>>>
85794>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
85796>>>        Boolean bOK
85796>>>        
85796>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
85797>>>        If (bOK = True) Begin
85799>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
85800>>>        End
85800>>>>
85800>>>        
85800>>>        Function_Return (bOK = True)
85801>>>    End_Function
85802>>>    
85802>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
85802>>>    // or to change the filelist slot names.
85802>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
85804>>>        String sFileListName
85804>>>        
85804>>>        Move False to Err
85805>>>
85805>>>        If (ghoProgressBar <> 0) Begin
85807>>>            Send DoAdvance of ghoProgressBar
85808>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
85809>>>        End
85809>>>>
85809>>>        // If all strings are empty it means that we should remove this entry from filelist.
85809>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
85811>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
85814>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
85817>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
85820>>>            Function_Return (Err = False) // And we're done.
85821>>>        End
85821>>>>
85821>>>
85821>>>        If (sDriverID <> DATAFLEX_ID) Begin
85823>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
85823>>>            Move (sDriverID + ":" + sRootName) to sRootName
85824>>>        End
85824>>>>
85824>>>//        Else Begin
85824>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85824>>>//        End
85824>>>//
85824>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
85824>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
85824>>>
85824>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
85827>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
85830>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
85833>>>        
85833>>>        Function_Return (Err = False)
85834>>>    End_Function
85835>>>
85835>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
85837>>>        Boolean bOK
85837>>>
85837>>>        Get AutoConnectionIDLogin to bOK
85838>>>        Move False to Err
85839>>>        Get OpenTableExclusive hTable to bOK
85840>>>        If (bOK = False) Begin
85842>>>            Function_Return False
85843>>>        End
85843>>>>
85843>>>
85843>>>        Set Private.phCurrentTable to hTable
85844>>>        Structure_Start hTable
85845>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
85848>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85849>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85851>>>
85851>>>        Set Action_Text of ghoStatusPanel to ""
85852>>>        Function_Return (Err = False)
85853>>>    End_Function
85854>>>
85854>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
85856>>>        Boolean bOK bIsSQLTable
85856>>>
85856>>>        Move False to Err
85857>>>        Get AutoConnectionIDLogin to bOK
85858>>>        Open hToTable
85860>>>        Get OpenTableExclusive hTable to bOK
85861>>>        If (bOK = False) Begin
85863>>>            Function_Return False
85864>>>        End
85864>>>>
85864>>>
85864>>>            Get _UtilTableIsSql hTable to bIsSQLTable
85865>>>            If (bIsSQLTable = True) Begin
85867>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85870>>>            End
85870>>>>
85870>>>
85870>>>        Set Private.phCurrentTable to hTable
85871>>>        Structure_Start hTable
85872>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
85875>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
85878>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85879>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85881>>>
85881>>>        Set Action_Text of ghoStatusPanel to ""
85882>>>        Function_Return (Err = False)
85883>>>    End_Function
85884>>>
85884>>>    Procedure ApiTableConvertAllAddException Integer hTable
85886>>>        Integer[] aTableConvertExceptions
85887>>>        Get paTableConvertExceptions to aTableConvertExceptions
85888>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
85889>>>        Set paTableConvertExceptions to aTableConvertExceptions
85890>>>    End_Procedure
85891>>>
85891>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
85893>>>        Integer[] aTableDateCorrectionExceptions
85894>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
85895>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
85896>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
85897>>>    End_Procedure
85898>>>
85898>>>    Procedure ApiTableConvertALLToSql
85900>>>        Integer[] iTablesArray
85901>>>        Integer iSize iCount
85901>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
85901>>>        String sDriverID
85901>>>
85901>>>        Get psDriverID to sDriverID
85902>>>        Get pbUseConnectionID to bUseConnectionID
85903>>>        Get pbToANSI          to bToANSI
85904>>>        Get pbRecnum          to bRecnum
85905>>>        Get pbCopyData        to bCopyData
85906>>>        If (ghoDbUpdateHandler > 0) Begin
85908>>>            Get pbContinueOnError to bContinueOnError
85909>>>        End
85909>>>>
85909>>>
85909>>>        Get _AllTablesToConvert to iTablesArray
85910>>>        Move (SizeOfArray(iTablesArray)) to iSize
85911>>>        Set pbVisible   of ghoProgressBarOverall to True
85912>>>        Set piPosition  of ghoProgressBarOverall to 0
85913>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
85914>>>        Set piMaximum   of ghoProgressBarOverall to iSize
85915>>>
85915>>>        Decrement iSize
85916>>>        For iCount from 0 to iSize
85922>>>>
85922>>>            Set piPosition of ghoProgressBarOverall to iCount
85923>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
85924>>>            // Probably the right logic here is to just continue trying to convert every table even
85924>>>            // if there was an error converting one table...
85924>>>            //If (bContinueOnError = False and bOK = False) Break
85924>>>        Loop
85925>>>>
85925>>>
85925>>>    End_Procedure
85926>>>
85926>>>    Procedure ApiTableAttachALLToSql
85928>>>        Integer[] iTablesArray
85929>>>        Integer iSize iCount
85929>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
85929>>>        String sDriverID
85929>>>
85929>>>        Get psDriverID to sDriverID
85930>>>        Get pbUseConnectionID to bUseConnectionID
85931>>>        Get pbToANSI          to bToANSI
85932>>>        Get pbRecnum          to bRecnum
85933>>>        Get pbCopyData        to bCopyData
85934>>>        If (ghoDbUpdateHandler > 0) Begin
85936>>>            Get pbContinueOnError to bContinueOnError
85937>>>        End
85937>>>>
85937>>>
85937>>>        Get _AllTablesToConvert to iTablesArray
85938>>>        Move (SizeOfArray(iTablesArray)) to iSize
85939>>>        Decrement iSize
85940>>>        For iCount from 0 to iSize
85946>>>>
85946>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
85947>>>        Loop
85948>>>>
85948>>>
85948>>>    End_Procedure
85949>>>
85949>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
85951>>>        Handle hToTable hoLogFile
85951>>>        Boolean bOK bExists bOpened bDAWDriver bContinueOnError bIsAlias
85951>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
85951>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
85951>>>        tSQLConnection SQLConnection
85951>>>        tSQLConnection SQLConnection
85951>>>
85951>>>        Get _UtilTableExists hTable to bExists
85952>>>        If (bExists = False) Begin
85954>>>            Set Private.phCurrentTable to hTable
85955>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
85956>>>>
85956>>>            Function_Return False
85957>>>        End
85957>>>>
85957>>>
85957>>>        Get UtilTableIsAlias hTable to bIsAlias
85958>>>        // If this is an Alias file there is nothing to convert to SQL.
85958>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
85958>>>        If (bIsAlias = True) Begin
85960>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85963>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
85965>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
85968>>>                Get psConnectionID to sConnectionID
85969>>>                Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
85970>>>            End
85970>>>>
85970>>>            Function_Return True
85971>>>        End
85971>>>>
85971>>>
85971>>>        Set Private.phCurrentTable to hTable
85972>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85975>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85978>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85981>>>
85981>>>        If (ghoProgressBar <> 0) Begin
85983>>>            Send DoAdvance of ghoProgressBar
85984>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
85985>>>            Set Message_Text   of ghoStatusPanel to ""
85986>>>            Set Action_Text    of ghoStatusPanel to ""
85987>>>        End
85987>>>>
85987>>>
85987>>>        // Marco Kuipers suggestion;
85987>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
85987>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
85987>>>        // SQL table.
85987>>>        Get _UtilTableIsSql hTable to bOK
85988>>>        If (bOK = False) Begin
85990>>>            Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
85991>>>            If (bExists = True) Begin
85993>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
85993>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
85993>>>                Get phoLogFile to hoLogFile
85994>>>                If (hoLogFile <> 0) Begin          
85996>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
85997>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
85997>>>                    Send LogError sWarning False
85998>>>                End
85998>>>>
85998>>>                Else Begin
85999>>>                    Error DFERR_PROGRAM sWarning
86000>>>>
86000>>>                End                                                       
86000>>>>
86000>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
86001>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
86002>>>            End
86002>>>>
86002>>>        End
86002>>>>
86002>>>
86002>>>        // Does the rootname contain a driver?
86002>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86004>>>            // Does the table already exist as an SQL table?
86004>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86005>>>            // It can happen that the table is missing from Filelist.cfg but still
86005>>>            // exist on the SQL side, in case we want to search for the table by its name.
86005>>>            If (bExists = False) Begin
86007>>>                Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86008>>>            End
86008>>>>
86008>>>            If (bExists = True) Begin
86010>>>                Set TableName_Text of ghoStatusPanel to ""
86011>>>                Function_Return False
86012>>>            End
86012>>>>
86012>>>        End
86012>>>>
86012>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
86013>>>
86013>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
86014>>>        If (bUseConnectionID = True) Begin
86016>>>            Move False to bUseConnectionID
86017>>>        End
86017>>>>
86017>>>
86017>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86018>>>        Move SQLConnection.sSchema           to sSchema
86019>>>        If (sSchema = "") Begin
86021>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
86022>>>            Move (Lowercase(sSchema))        to sSchema
86023>>>        End
86023>>>>
86023>>>
86023>>>        Move SQLConnection.sDatabase         to sDatabase
86024>>>        Move SQLConnection.sConnectionID     to sConnectionID
86025>>>        Move SQLConnection.sConnectionString to sConnectionString
86026>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86028>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
86029>>>>
86029>>>            Function_Return False
86030>>>        End
86030>>>>
86030>>>
86030>>>        Get AutoConnectionIDLogin to bOK
86031>>>        Open hTable
86033>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86036>>>        If (bOpened = False) Begin
86038>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
86039>>>>
86039>>>            Function_Return False
86040>>>        End
86040>>>>
86040>>>
86040>>>        If (ghoProgressBar <> 0) Begin
86042>>>            Send DoAdvance of ghoProgressBar
86043>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
86044>>>        End
86044>>>>
86044>>>
86044>>>        Move 0 to hToTable
86045>>>        Get _TableNameOnly sRootName                 to sRootName
86046>>>        Move (sRootName + ".int")                    to sPhysicalName
86047>>>
86047>>>        Case Begin
86047>>>            Case (sDriverID = MSSQLDRV_ID)
86049>>>                Case Break
86050>>>            Case (sDriverID = ODBC_DRV_ID)
86053>>>                Case Break
86054>>>            Case (sDriverID = DB2_DRV_ID)
86057>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
86058>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
86059>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
86060>>>                Case Break
86061>>>            Case (sDriverID = DATAFLEX_ID)
86064>>>                Case Break
86065>>>            Case Else
86065>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
86066>>>>
86066>>>                Case Break
86067>>>        Case End
86067>>>
86067>>>        Move False to Err
86068>>>
86068>>>        Structure_Start hToTable sDriverID
86069>>>            Structure_Copy hTable to hToTable
86070>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
86073>>>
86073>>>            If (sDriverID <> DATAFLEX_ID) Begin
86075>>>                If (bUseConnectionID = True) Begin
86077>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86080>>>                End
86080>>>>
86080>>>                Else Begin
86081>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
86084>>>                End
86084>>>>
86084>>>
86084>>>                Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
86087>>>
86087>>>                If (sSchema <> "") Begin
86089>>>                    Set_Attribute DF_FILE_OWNER of hToTable to sSchema
86092>>>                End
86092>>>>
86092>>>
86092>>>                If (sDriverID = DB2_DRV_ID) Begin
86094>>>                    If (sLongTableSpace <> "") Begin
86096>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
86099>>>                    End
86099>>>>
86099>>>                    If (sBaseTableSpace <> "") Begin
86101>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
86104>>>                    End
86104>>>>
86104>>>                    If (sIndexTableSpace <> "") Begin
86106>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
86109>>>                    End
86109>>>>
86109>>>                End
86109>>>>
86109>>>            End
86109>>>>
86109>>>
86109>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86110>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86112>>>        Set Action_Text of ghoStatusPanel to ""
86113>>>
86113>>>        Move (not(Err)) to bOK
86114>>>
86114>>>        If (bOK = True and bCopyData = True) Begin
86116>>>            Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
86117>>>
86117>>>            If (ghoDbUpdateHandler > 0) Begin
86119>>>                Get pbContinueOnError to bContinueOnError
86120>>>            End
86120>>>>
86120>>>            // If the data copy failed we will keep the newly created SQL table but
86120>>>            // rename it by adding a GUID to the end of the table name
86120>>>            // - or as much as "fit" because different SQL back-ends have
86120>>>            // different rules how long a table name can be.
86120>>>            // The new table will probably contain data but something went
86120>>>            // wrong while converting the data from embedded to SQL.
86120>>>            If (bOK = False and bContinueOnError = False) Begin
86122>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86123>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86124>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
86125>>>>
86125>>>            End
86125>>>>
86125>>>        End
86125>>>>
86125>>>
86125>>>        // This must be after copying data...
86125>>>        If (Err = False) Begin
86127>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86130>>>            // It seems the Studio does not do this any more, so commented out.
86130>>>            // We also adjust the display name by prefixing it by the schema name;
86130>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86130>>>            //                // The max length for the display_name is 31 characters...
86130>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
86130>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
86130>>>            //                End
86130>>>            //            End
86130>>>        End
86130>>>>
86130>>>
86130>>>        Close hTable
86131>>>        Move (not(Err)) to bOK
86132>>>        Function_Return bOK
86133>>>    End_Function
86134>>>
86134>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
86134>>>    // It will first drop all indicies, copy the data and then recreate indicies.
86134>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
86134>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
86136>>>        Boolean bOpened bOK
86136>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
86136>>>        String sErrorFile sEmpty sPath
86136>>>
86136>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
86139>>>        Get AutoConnectionIDLogin to bOK
86140>>>        If (sDriverID = DATAFLEX_ID) Begin
86142>>>            Send IncreaseSortBufferSize
86143>>>//            Send SetAllIndexesToBatch hToTable
86143>>>        End
86143>>>>
86143>>>
86143>>>        Move False to Err
86144>>>        Open sPhysicalName as hToTable
86146>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
86149>>>        If (bOpened = False) Begin
86151>>>            Function_Return False
86152>>>        End
86152>>>>
86152>>>
86152>>>        If (ghoStatusPanel <> 0) Begin
86154>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
86155>>>            Set piMinimum of ghoProgressBar to 0
86156>>>            Set piMaximum of ghoProgressBar to 100 // 100%
86157>>>        End
86157>>>>
86157>>>
86157>>>        Move "" to sEmpty
86158>>>        Move False to Err
86159>>>        Move True to bOK
86160>>>        Set Private.phCurrentTable to hToTable
86161>>>
86161>>>        // No need to get the record identifier
86161>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
86164>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86167>>>        If (sDriverID <> DATAFLEX_ID) Begin
86169>>>            // Remove all indices to speed up copying of data:
86169>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86174>>>            If (iRetval <> 0) Begin       
86176>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86177>>>>
86177>>>                Close hToTable
86178>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86181>>>                Function_Return False
86182>>>            End
86182>>>>
86182>>>        End
86182>>>>
86182>>>
86182>>>        Move (sRootName + ".err") to sErrorFile
86183>>>        Move 0 to iIndex
86184>>>        Move False to Err
86185>>>
86185>>>        If (sDriverID = MSSQLDRV_ID) Begin
86187>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
86190>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
86195>>>            If (iRetval <> 0) Begin
86197>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86198>>>>
86198>>>                Close hToTable
86199>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86202>>>                Function_Return False
86203>>>            End
86203>>>>
86203>>>        End
86203>>>>
86203>>>        Else Begin
86204>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
86207>>>        End
86207>>>>
86207>>>
86207>>>        If (Err = False) Begin
86209>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
86210>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
86211>>>        End
86211>>>>
86211>>>
86211>>>        If (sDriverID <> DATAFLEX_ID) Begin
86213>>>            // Recreate indices:
86213>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86218>>>            If (iRetval <> 0) Begin
86220>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86221>>>>
86221>>>                Close hToTable
86222>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86225>>>                Function_Return False
86226>>>            End
86226>>>>
86226>>>        End
86226>>>>
86226>>>
86226>>>        Close hToTable
86227>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86230>>>
86230>>>        If (bOK = True) Begin
86232>>>            Move (not(Err)) to bOK
86233>>>        End
86233>>>>
86233>>>
86233>>>        If (ghoStatusPanel <> 0) Begin
86235>>>            Set TableName_Text of ghoStatusPanel to ""
86236>>>            Set Message_Text   of ghoStatusPanel to ""
86237>>>            Set Action_Text    of ghoStatusPanel to ""
86238>>>        End
86238>>>>
86238>>>
86238>>>        Function_Return (bOK = True)
86239>>>    End_Function
86240>>>
86240>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
86240>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
86240>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
86242>>>        Handle hFile
86242>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
86242>>>        Integer iIdentityType iDataType iDbType iCount iSize
86242>>>        Boolean bOk bExists bSqlDriver bDeleteDummy bExistsInFilelist bSysFile
86242>>>        tSQLConnection SQLConnection
86242>>>        tSQLConnection SQLConnection
86242>>>        tAPIColumn[] aColumns
86242>>>        tAPIColumn[] aColumns
86243>>>        tColumnType ColumnType
86243>>>        tColumnType ColumnType
86243>>>
86243>>>        // First check if the passed filenumber already exists; in case we do nothing
86243>>>        Get _UtilTableExists hTable to bOk
86244>>>        If (bOk = True) Begin
86246>>>            Function_Return False
86247>>>        End
86247>>>>
86247>>>
86247>>>        Set Private.phCurrentTable to hTable
86248>>>        Move sLogicalName to sTableName
86249>>>        If (ghoProgressBar <> 0) Begin
86251>>>            Send DoAdvance of ghoProgressBar
86252>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
86253>>>        End
86253>>>>
86253>>>
86253>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
86254>>>        Get psDriverID to sDriverID
86255>>>        Get IsSQLDriver sDriverID to bSqlDriver
86256>>>        Get piDbType to iDbType
86257>>>
86257>>>        // If no columns passed in, we need to create a "dummy" column
86257>>>        Move False to bDeleteDummy
86258>>>        If (Num_Arguments = 8) Begin
86260>>>            Move aColumnIn to aColumns
86261>>>        End
86261>>>>
86261>>>        If ((SizeOfArray(aColumns)) = 0) Begin
86263>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
86264>>>            Move ColumnType.iSQLType to iDataType
86265>>>            If (bRecnum = False) Begin
86267>>>                Move C_tAPIColumn_Identity to iIdentityType
86268>>>            End
86268>>>>
86268>>>            Else Begin
86269>>>                Move C_tAPIColumn_None     to iIdentityType
86270>>>            End
86270>>>>
86270>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
86271>>>            Move True to bDeleteDummy
86272>>>        End
86272>>>>
86272>>>
86272>>>        // If columns have been passed as an array we need to check if an identity column
86272>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
86272>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
86272>>>        // two identity columns and SQL doesn't like that and throws an error.
86272>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
86274>>>            Move (SizeOfArray(aColumns)) to iSize
86275>>>            Decrement iSize
86276>>>            for iCount from 0 to iSize
86282>>>>
86282>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
86284>>>                    Move False to bRecnum
86285>>>                    Move iSize to iCount
86286>>>                End
86286>>>>
86286>>>            Loop
86287>>>>
86287>>>        End
86287>>>>
86287>>>
86287>>>        // If this is a SQL based driver we also check if the table exists
86287>>>        // in the SQL back end; in case we do nothing.
86287>>>        If (bSqlDriver = True) Begin
86289>>>            // Get all connection properties
86289>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86290>>>            Move SQLConnection.sSchema to sSchema
86291>>>            If (sSchema = "") Begin
86293>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
86294>>>            End
86294>>>>
86294>>>
86294>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86295>>>            // It can happen that the table is missing from Filelist.cfg but still
86295>>>            // exist on the SQL side, in case we want to search for the table by its name.
86295>>>            If (bExists = False) Begin
86297>>>                Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
86298>>>            End
86298>>>>
86298>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
86298>>>            // we will just add it to Filelist.cfg
86298>>>            If (bExists = True) Begin
86300>>>                If (bExistsInFilelist = False) Begin
86302>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86304>>>                        Move (sDriverID + ":" + sRootName) to sRootName
86305>>>                    End
86305>>>>
86305>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86308>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86311>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86314>>>                    Move False to bSysFile
86315>>>                    Get _SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
86316>>>                End
86316>>>>
86316>>>                Function_Return False
86317>>>            End
86317>>>>
86317>>>        End
86317>>>>
86317>>>
86317>>>        Move CS_ANSI_Txt to sANSI_OEM
86318>>>        If (num_arguments > 6) Begin
86320>>>            If (bANSI = False) Begin
86322>>>                Move CS_OEM_Txt to sANSI_OEM
86323>>>            End
86323>>>>
86323>>>        End
86323>>>>
86323>>>
86323>>>        Move False to Err
86324>>>        If (sDriverID = DATAFLEX_ID) Begin
86326>>>            Move sRootName to sPhysicalFile
86327>>>        End
86327>>>>
86327>>>
86327>>>        If (sDriverID <> DATAFLEX_ID) Begin
86329>>>            Move SQLConnection.sConnectionID to sConnectionID
86330>>>
86330>>>            // If DAW driver and we should use a connection id we need to
86330>>>            // check if the connection ID exists; else we create it before attempting creating the table
86330>>>            If (bUseConnectionID = True) Begin
86332>>>                Get IsConnectionID sConnectionID sDriverID to bExists
86333>>>                If (bExists = False) Begin
86335>>>                    Get AutoSetConnectionID sConnectionID to bOk
86336>>>                    If (bOk = False) Begin
86338>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86339>>>>
86339>>>                        Function_Return False
86340>>>                    End
86340>>>>
86340>>>                End
86340>>>>
86340>>>            End
86340>>>>
86340>>>
86340>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86342>>>                Move (sTableName + ".int") to sPhysicalFile
86343>>>            End
86343>>>>
86343>>>            Else Begin
86344>>>                Move (sRootName + ".int") to sPhysicalFile
86345>>>            End
86345>>>>
86345>>>            Move (Uppercase(sDisplayName)) to sVal
86346>>>//            If (not(sVal contains (sSchema + "."))) Begin
86346>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
86346>>>//            End
86346>>>        End
86346>>>>
86346>>>        Move False to Err
86347>>>        Move 0 to hFile
86348>>>
86348>>>        Structure_Start hFile sDriverID
86349>>>            If (sDriverID <> DATAFLEX_ID) Begin
86351>>>                If (bUseConnectionID = True) Begin
86353>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
86356>>>                End
86356>>>>
86356>>>                Else Begin
86357>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
86360>>>                End
86360>>>>
86360>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
86363>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
86366>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
86369>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
86372>>>
86372>>>                If (sSchema <> "") Begin
86374>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
86377>>>                End
86377>>>>
86377>>>
86377>>>                If (sDriverID = DB2_DRV_ID) Begin
86379>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
86381>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
86384>>>                    End
86384>>>>
86384>>>                End
86384>>>>
86384>>>                If (sDriverID = DB2_DRV_ID) Begin
86386>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
86388>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
86391>>>                    End
86391>>>>
86391>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
86393>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
86396>>>                    End
86396>>>>
86396>>>                End
86396>>>>
86396>>>            End
86396>>>>
86396>>>
86396>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
86399>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
86400>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86401>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86403>>>        Set Action_Text of ghoStatusPanel to ""
86404>>>
86404>>>        Move (not(Err)) to bOK
86405>>>        If (bOk = True) Begin
86407>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86409>>>                Move (sDriverID + ":" + sRootName) to sRootName
86410>>>            End
86410>>>>
86410>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86413>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86416>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86419>>>
86419>>>            // Lastly we remove the temporary column we created above, if all went well.
86419>>>            If (bDeleteDummy) Begin
86421>>>                Get ApiColumnRemove hTable "temp" to bOk
86422>>>            End
86422>>>>
86422>>>        End
86422>>>>
86422>>>
86422>>>        Set TableName_Text of ghoStatusPanel to ""
86423>>>        Close hTable
86424>>>        Function_Return (bOK = True)
86425>>>    End_Function
86426>>>
86426>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
86428>>>        Move False to Err
86429>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
86432>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
86435>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
86438>>>
86438>>>        Function_Return (Err = False)
86439>>>    End_Function
86440>>>
86440>>>    // ToDo: Needs to be revised
86440>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
86442>>>        Handle hTable
86442>>>        String sDEFName sDataPath
86442>>>        Boolean bExists
86442>>>
86442>>>        // Do nothing if MSSQL Driver.
86442>>>//        Get IsMSSQLDriver to bExists
86442>>>//        If (bExists = True) Begin
86442>>>//            Procedure_Return
86442>>>//        End
86442>>>
86442>>>        Get psDataPathFirstPart to sDataPath
86443>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
86444>>>        If (bExists = True) Begin
86446>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
86446>>>            // still be missing from the filelist and needs to be added.
86446>>>            Get _UtilTableNumberIsInUse iFilelistSlot to bExists
86447>>>            If (bExists = True) Begin
86449>>>                Procedure_Return
86450>>>            End
86450>>>>
86450>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
86450>>>            Else Begin
86451>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
86454>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
86457>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
86460>>>                Procedure_Return
86461>>>            End
86461>>>>
86461>>>        End
86461>>>>
86461>>>
86461>>>        Move (sPath + sFileName + ".def") to sDEFName
86462>>>        Move 0 to hTable
86463>>>        Move False to Err
86464>>>
86464>>>        Structure_Start hTable DATAFLEX_ID
86465>>>            Load_Def sDEFName Onto hTable
86466>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
86469>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86470>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86472>>>        Set Action_Text of ghoStatusPanel to ""
86473>>>
86473>>>        Move iFilelistSlot to hTable
86474>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
86477>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86480>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86483>>>
86483>>>    End_Procedure
86484>>>
86484>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
86486>>>        Boolean bTmp bErr bOK
86486>>>        String sTableName sDisplayName sFileName
86486>>>
86486>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
86486>>>        Move Err to bTmp
86487>>>        Move False to Err
86488>>>
86488>>>        Get AutoConnectionIDLogin to bOK
86489>>>        // First get the info for the current filelist slot:
86489>>>        Open iFromFileSlot
86491>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
86494>>>        If (bOK = True) Begin
86496>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
86499>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
86502>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
86505>>>
86505>>>            //...then move it.
86505>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
86508>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
86511>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
86514>>>
86514>>>            //...and finally remove the old filelist values.
86514>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
86517>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
86520>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
86523>>>        End
86523>>>>
86523>>>        Close iFromFileSlot
86524>>>
86524>>>        Move Err to bErr
86525>>>        Move bTmp to Err
86526>>>        Function_Return (bErr = False)
86527>>>    End_Function
86528>>>
86528>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
86530>>>        Handle hTable
86530>>>        Boolean bOK
86530>>>        String sDriverID
86530>>>
86530>>>        Get _UtilTableExists hTableFrom to bOK
86531>>>        If (bOK = False) Begin
86533>>>            Set Private.phCurrentTable to hTableFrom
86534>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86535>>>>
86535>>>            Function_Return False
86536>>>        End
86536>>>>
86536>>>
86536>>>        Get _UtilTableExists hTableTo to bOK
86537>>>        If (bOK = False) Begin
86539>>>            Set Private.phCurrentTable to hTableTo
86540>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86541>>>>
86541>>>            Function_Return False
86542>>>        End
86542>>>>
86542>>>
86542>>>        Get AutoConnectionIDLogin to bOK
86543>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
86544>>>        If (bOK = False) Begin
86546>>>            Function_Return False
86547>>>        End
86547>>>>
86547>>>
86547>>>        Move False to Err
86548>>>        Open hTableTo
86550>>>
86550>>>        Move hTableFrom to hTable
86551>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86554>>>        Set Private.phCurrentTable to hTable
86555>>>
86555>>>        Structure_Start hTable sDriverID
86556>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
86559>>>            If (iColumnTo <> 0) Begin
86561>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
86564>>>            End
86564>>>>
86564>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86565>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86567>>>        Set Action_Text of ghoStatusPanel to ""
86568>>>
86568>>>        If (hTableTo > 0) Begin
86570>>>            Close hTableTo
86571>>>        End
86571>>>>
86571>>>
86571>>>        Function_Return (Err = False)
86572>>>    End_Function
86573>>>
86573>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
86573>>>    Function ApiTableRemove Handle hTable Returns Boolean
86575>>>        String sTableName sDriverID
86575>>>        Boolean bOk
86575>>>        String sDataPath
86575>>>
86575>>>        Get AutoConnectionIDLogin to bOK
86576>>>        Move False to Err
86577>>>        Get psDriverID to sDriverID
86578>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
86579>>>        If (sTableName = "") Begin
86581>>>            Function_Return False
86582>>>        End
86582>>>>
86582>>>
86582>>>        Set Private.phCurrentTable to hTable
86583>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
86584>>>        Delete_db sTableName
86585>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
86586>>>
86586>>>        If (sDriverID <> DATAFLEX_ID) Begin
86588>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
86588>>>            Get psDataPathFirstPart to sDataPath
86589>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
86590>>>        End
86590>>>>
86590>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
86590>>>        If (hTable <> 0) Begin
86592>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86595>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86598>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86601>>>        End
86601>>>>
86601>>>
86601>>>        Close hTable
86602>>>        Function_Return (hTable <> 0)
86603>>>    End_Function
86604>>>
86604>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
86606>>>        Handle hTable
86606>>>        Boolean bOK
86606>>>
86606>>>        Get AutoConnectionIDLogin to bOK
86607>>>        Move False to Err
86608>>>        Open hTableFrom Mode DF_EXCLUSIVE
86610>>>        Move hTableFrom to hTable
86611>>>
86611>>>        Structure_Start hTable
86612>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
86615>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86616>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86618>>>        Set Action_Text of ghoStatusPanel to ""
86619>>>
86619>>>        Close hTableFrom
86620>>>        Function_Return (Err = False)
86621>>>    End_Function
86622>>>
86622>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
86624>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
86624>>>        Boolean bOK bExists bOpened
86624>>>        tAPITableNameInfo APITableNameInfo
86624>>>        tAPITableNameInfo APITableNameInfo
86624>>>
86624>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86627>>>        If (bOpened = False) Begin
86629>>>            Get OpenTableExclusive hTable to bOpened
86630>>>            If (bOpened = False) Begin
86632>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
86633>>>                Function_Return False
86634>>>            End
86634>>>>
86634>>>        End
86634>>>>
86634>>>
86634>>>        Set Private.phCurrentTable to hTable
86635>>>        Move hTable         to APITableNameInfo.iTableNumber
86636>>>        Move sRootName      to APITableNameInfo.sRootName
86637>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
86638>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
86639>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfo to bExists
86640>>>        If (bExists = True) Begin
86642>>>            Function_Return True
86643>>>        End
86643>>>>
86643>>>
86643>>>        Set Private.phCurrentTable to hTable
86644>>>        Move False to Err
86645>>>        Get psDataPathFirstPart to sDataPath
86646>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
86649>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
86652>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
86655>>>
86655>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86658>>>        Close hTable
86659>>>        If (sDriverID = DATAFLEX_ID) Begin
86661>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
86662>>>            If (bExists = True) Begin
86664>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
86666>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
86669>>>                    // We need a short break here before attempting to delete the physical old files or Windows
86669>>>                    // might report "File in use..." and the deletion will fail.
86669>>>                    Sleep 2
86670>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
86671>>>                End
86671>>>>
86671>>>            End
86671>>>>
86671>>>        End
86671>>>>
86671>>>
86671>>>        If (sDriverID <> DATAFLEX_ID) Begin
86673>>>            If (not(sPhysicalName contains ".")) Begin
86675>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
86676>>>            End
86676>>>>
86676>>>
86676>>>            // Change the table name in the .int file to the new table new:
86676>>>            Get _UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
86677>>>            If (bOK = False) Begin
86679>>>                Function_Return False
86680>>>            End
86680>>>>
86680>>>
86680>>>            // Change table name at the SQL side:
86680>>>            Get psSchema to sSchema
86681>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
86682>>>
86682>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
86683>>>            // Remove cache file and Rename the physical file names:
86683>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
86684>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
86685>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
86686>>>            Move (sDriverID + ":" + sRootName) to sRootName
86687>>>
86687>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86687>>>//            If (not(sDisplayName contains ".")) Begin
86687>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
86687>>>//            End
86687>>>        End
86687>>>>
86687>>>
86687>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86690>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86693>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86696>>>
86696>>>        Function_Return (Err = False)
86697>>>    End_Function
86698>>>
86698>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
86700>>>        Move False to Err
86701>>>        Set Private.phCurrentTable to hTable
86702>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86705>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86708>>>
86708>>>        Function_Return (Err = False)
86709>>>    End_Function
86710>>>
86710>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
86710>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
86712>>>        Handle hTable
86712>>>        String sTableName
86712>>>        String sDriverIDFrom sDriverIDTo
86712>>>        Integer iDbType
86712>>>        Boolean bOk bOpened bApiTableUpdateAuto
86712>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
86712>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
86712>>>        tSQLConnection SQLConnection
86712>>>        tSQLConnection SQLConnection
86712>>>        tAPITable      APITableFrom APITableTo
86712>>>        tAPITable      APITableFrom APITableTo
86712>>>        tColumnType    ColumnType
86712>>>        tColumnType    ColumnType
86712>>>        tAPIColumnCompare[]   aAPIColumnCompare
86712>>>        tAPIColumnCompare[]   aAPIColumnCompare
86713>>>        tAPIIndexCompare[]    aAPIIndexCompare
86713>>>        tAPIIndexCompare[]    aAPIIndexCompare
86714>>>        tAPIRelationCompare[] aAPIRelationCompare
86714>>>        tAPIRelationCompare[] aAPIRelationCompare
86715>>>
86715>>>        // We don't allow changes to the framework's DbVersion table.
86715>>>        If (Lowercase(sTableName) = "dbversion") Begin
86717>>>            Function_Return False
86718>>>        End
86718>>>>
86718>>>
86718>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
86719>>>        Get piDbType                            to iDbType
86720>>>        Get pbRecnum                            to bRecnum
86721>>>        Get pbToANSI                            to bToANSI
86722>>>        Get pbCopyData                          to bCopyData
86723>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
86724>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
86725>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
86726>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
86727>>>        Get pbUseConnectionID                   to bUseConnectionID
86728>>>
86728>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
86729>>>        Set Private.phCurrentTable              to hTable
86730>>>        Get _UtilTableExists  hTable             to bTableExists
86731>>>
86731>>>        If (ghoProgressBar <> 0) Begin
86733>>>            Send DoAdvance of ghoProgressBar
86734>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
86735>>>            Set Message_Text   of ghoStatusPanel to ""
86736>>>            Set Action_Text    of ghoStatusPanel to ""
86737>>>        End
86737>>>>
86737>>>
86737>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
86738>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
86739>>>        Get _UtilTableIsSql hTable               to bIsSQLTableTo
86740>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
86741>>>        Move True                               to APITableFrom.bFromTable
86742>>>        Move hTable                             to APITableFrom.hTable
86743>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
86744>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
86745>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
86746>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
86747>>>
86747>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
86749>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
86750>>>            If (bOk = True) Begin
86752>>>                Get ApiTableAttachToSql hTable True to bOk
86753>>>                Function_Return bOk
86754>>>            End 
86754>>>>
86754>>>        End
86754>>>>
86754>>>
86754>>>        If (bTableExists = True) Begin
86756>>>            If (bIsSQLTableTo = True) Begin
86758>>>                Get _UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
86759>>>            End
86759>>>>
86759>>>
86759>>>            Get OpenTableExclusive hTable to bOpened
86760>>>            If (bOpened = False) Begin
86762>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
86763>>>                Function_Return False
86764>>>            End
86764>>>>
86764>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
86765>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
86766>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
86767>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
86768>>>        End
86768>>>>
86768>>>
86768>>>        Move False to Err
86769>>>        Case Begin
86769>>>            // Alias table:
86769>>>            Case (bIsAliasFrom = True)
86771>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
86772>>>                Case Break
86773>>>
86773>>>            // New Table:
86773>>>            Case (bTableExists = False)
86776>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
86777>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
86777>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
86779>>>                    Get ApiTableChangeAttribute hTable DF_FILE_IS_SYSTEM_FILE True to bOK
86780>>>                End                                                                 
86780>>>>
86780>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
86781>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
86782>>>                Case Break
86783>>>
86783>>>            // Update table:
86783>>>            Case (bTableExists = True)
86786>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
86787>>>                If (bIsSame = True) Begin
86789>>>                    Case Break
86790>>>                End
86790>>>>
86790>>>                If (bFilelistError = True) Begin
86792>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
86793>>>                    If (bOk = False) Begin
86795>>>                        Case Break
86796>>>                    End
86796>>>>
86796>>>                End
86796>>>>
86796>>>
86796>>>                If (ghoProgressBar <> 0) Begin
86798>>>                    Send DoAdvance of ghoProgressBar
86799>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
86800>>>                End
86800>>>>
86800>>>
86800>>>                // Columns:
86800>>>                Move True to bOk
86801>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
86802>>>                If (bIsSame = False) Begin
86804>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
86805>>>                End
86805>>>>
86805>>>                If (bOk = False) Begin
86807>>>                    Case Break
86808>>>                End
86808>>>>
86808>>>
86808>>>                // Indexes:
86808>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
86809>>>                If (bIsSame = False) Begin
86811>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
86812>>>                End
86812>>>>
86812>>>
86812>>>                // Relations:
86812>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
86813>>>                If (bIsSame = False) Begin
86815>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
86816>>>                    If (bOk = False) Begin
86818>>>                        Case Break
86819>>>                    End
86819>>>>
86819>>>                End
86819>>>>
86819>>>
86819>>>                Case Break
86820>>>
86820>>>            Case Else
86820>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
86821>>>>
86821>>>                Move False to bOk
86822>>>        Case End
86822>>>        
86822>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
86822>>>        // or convert an embedded table to SQL
86822>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
86824>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
86825>>>            If (bOk = False) Begin
86827>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
86828>>>            End
86828>>>>
86828>>>        End
86828>>>>
86828>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
86831>>>            Get SqlTableConvertToEmbedded hTable True to bOk
86832>>>        End
86832>>>>
86832>>>        
86832>>>        // Filelist Names:
86832>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
86833>>>        Close hTable
86834>>>        Set TableName_Text of ghoStatusPanel to ""
86835>>>
86835>>>        Function_Return (bOK = True)
86836>>>    End_Function
86837>>>
86837>>>    // * Dummy function for the Studio's Code Explorer *
86837>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
86839>>>        Function_Return False
86840>>>    End_Function
86841>>>
86841>>>    // Adds a column name to the passed table number.
86841>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
86843>>>        Integer iColumn iCount iFile iPrecision iLastErr
86843>>>        Boolean bExists bOK bInitializeValue bRetval
86843>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
86843>>>
86843>>>        Get UtilColumnExists hTable sFieldName to bExists
86844>>>        If (bExists = True) Begin
86846>>>            Function_Return False
86847>>>        End
86847>>>>
86847>>>
86847>>>        Move False to Err
86848>>>        If (num_arguments > 4) Begin
86850>>>            Move iPrec to iPrecision
86851>>>        End
86851>>>>
86851>>>        If (num_arguments > 6) Begin
86853>>>            Move bInitVal to bInitializeValue
86854>>>            Move sColVal  to sColumnValue
86855>>>        End
86855>>>>
86855>>>        If (iType < -1490) Begin
86857>>>            Move (iType + 1500) to iType
86858>>>        End
86858>>>>
86858>>>
86858>>>        Move hTable to iFile
86859>>>        Get psDriverID to sDriverID
86860>>>        Get AutoConnectionIDLogin to bOK
86861>>>        Move False to Err
86862>>>        Move LastErr to iLastErr
86863>>>        Get OpenTableExclusive iFile to bOK
86864>>>        Set Private.phCurrentTable to hTable
86865>>>
86865>>>        Structure_Start iFile sDriverID
86866>>>            Move 0 to iColumn
86867>>>            Set Private.piCurrentField to iColumn
86868>>>            Create_Field hTable At iColumn
86869>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
86872>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
86875>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
86878>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
86881>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86882>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86884>>>
86884>>>        Set Action_Text of ghoStatusPanel to ""
86885>>>
86885>>>        // If in development environment; create .fd file:
86885>>>        Open hTable
86887>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
86888>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
86889>>>        If (iCount > 1) Begin
86891>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
86892>>>        End
86892>>>>
86892>>>        Get vFolderExists sDDSrcPath to bExists
86893>>>        If (bExists = True) Begin
86895>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
86896>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86899>>>            Get _TableNameOnly sTableName to sTableName
86900>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
86902>>>        End
86902>>>>
86902>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
86904>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
86905>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
86906>>>            If (iCount > 1) Begin
86908>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
86909>>>            End
86909>>>>
86909>>>            Get vFolderFormat sDataPath to sDataPath
86910>>>            // Add the new column name to the .tag filen (if it doesn't exist):
86910>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
86910>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
86910>>>        End
86910>>>>
86910>>>        // Check for a default value
86910>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
86912>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
86913>>>        End
86913>>>>
86913>>>        Close hTable
86914>>>
86914>>>        Function_Return (Err = False)
86915>>>    End_Function
86916>>>
86916>>>    // Adds a column name to the passed table number.
86916>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
86918>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
86918>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
86918>>>        String sDdSrcPath sTableName
86918>>>
86918>>>        Get UtilColumnExists hTable sFieldName to bExists
86919>>>        Move False to Err
86920>>>        If (bExists = True) Begin
86922>>>            Function_Return False
86923>>>        End
86923>>>>
86923>>>        If (num_arguments > 4) Begin
86925>>>            Move iPrec to iPrecision
86926>>>        End
86926>>>>
86926>>>        If (iType < -1490) Begin
86928>>>            Move (iType + 1500) to iType
86929>>>        End
86929>>>>
86929>>>
86929>>>        Get AutoConnectionIDLogin to bOK
86930>>>        Move False to Err
86931>>>        Get _UtilTableIsSql hTable to bIsSQLTypeTo
86932>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
86932>>>        // data types between Embedded and SQL, else we can't compare the data types. 
86932>>>        Get piDbType to iDbType
86933>>>        If (bIsSQLTypeTo = False) Begin
86935>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
86936>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
86938>>>                Move DF_DATE to iType
86939>>>            End
86939>>>>
86939>>>        End
86939>>>>
86939>>>
86939>>>        // Structure_start will change the value of hTable...
86939>>>        Move hTable to iFile
86940>>>        Get OpenTableExclusive iFile to bOK
86941>>>        If (bOK = False) Begin
86943>>>            Function_Return False
86944>>>        End
86944>>>>
86944>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
86947>>>
86947>>>        // If the passed column number is higher than the current number of fields
86947>>>        // in the table, this means we should _not_ insert a field but rather add
86947>>>        // a new field to the end:
86947>>>        If (iColumn > iNumberOfFields) Begin
86949>>>            Move 0 to iColumn
86950>>>        End
86950>>>>
86950>>>
86950>>>        Set Private.phCurrentTable to hTable
86951>>>        Set Private.piCurrentField to iColumn
86952>>>
86952>>>        Structure_Start iFile
86953>>>            Create_Field iFile At iColumn
86954>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
86957>>>            If (bIsSQLTypeTo = False) Begin
86959>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
86962>>>            End
86962>>>>
86962>>>            Else Begin
86963>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
86966>>>            End
86966>>>>
86966>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
86967>>>            If (bIsDateType = False) Begin
86969>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
86972>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
86975>>>            End
86975>>>>
86975>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86976>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86978>>>
86978>>>        Set Action_Text of ghoStatusPanel to ""
86979>>>        // If in development environment; create .fd file:
86979>>>        Open hTable
86981>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
86982>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
86983>>>        If (iCount > 1) Begin
86985>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
86986>>>        End
86986>>>>
86986>>>        Get vFolderExists sDDSrcPath to bExists
86987>>>        If (bExists = True) Begin
86989>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
86990>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86993>>>            Get _TableNameOnly sTableName to sTableName
86994>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
86996>>>        End
86996>>>>
86996>>>
86996>>>        // Check for a default value
86996>>>        Close hTable
86997>>>
86997>>>        Function_Return (Err = False)
86998>>>    End_Function
86999>>>
86999>>>    // To update all records for a table column with a fixed value.
86999>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
87001>>>        Integer iRecs iCurrErr iField iRecord
87001>>>        Boolean bRetval bOpen
87001>>>
87001>>>        Move 0 to iRecs
87002>>>        Move False to bRetval
87003>>>        Move Err to iCurrErr
87004>>>        Move False to Err
87005>>>
87005>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87008>>>        If (bOpen = False) Begin
87010>>>            Open hTable
87012>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87015>>>            If (bOpen = False) Begin
87017>>>                Function_Return bRetval
87018>>>            End
87018>>>>
87018>>>        End
87018>>>>
87018>>>
87018>>>        Field_Map hTable sFieldName to iField
87020>>>        If (iField <> 0) Begin
87022>>>            Set Private.phCurrentTable to hTable
87023>>>            Set Private.piCurrentField to iField
87024>>>            Clear hTable
87025>>>            Repeat
87025>>>>
87025>>>                Vfind hTable 0 GT
87027>>>                If (Found) Begin
87029>>>                    If (ghoStatusPanel <> 0) Begin
87031>>>                        Get_Field_Value hTable 0 to iRecord
87034>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
87035>>>                    End
87035>>>>
87035>>>                    Reread hTable
87039>>>                        Set_Field_Value hTable iField to sColumnValue
87042>>>                        SaveRecord hTable
87043>>>                    Unlock
87044>>>>
87044>>>                End
87044>>>>
87044>>>           Until (not(Found))
87046>>>        End
87046>>>>
87046>>>
87046>>>        Move (Err = False) to bRetval
87047>>>        Move iCurrErr to Err
87048>>>
87048>>>        Function_Return bRetval
87049>>>    End_Function
87050>>>
87050>>>    // Note: This can only be used from within a Structure_Start/End construct.
87050>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
87052>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
87052>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
87052>>>        String sFieldName sDriverID sTableName sDefaultValue
87052>>>
87052>>>        Get psDriverID to sDriverID
87053>>>        Get piDbType to iDbType
87054>>>        Get UtilTableHandleToString hTable to sTableName
87055>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
87056>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
87057>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87058>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
87060>>>            Move True to bIsSqlTable
87061>>>        End
87061>>>>
87061>>>        Move False to bIsOpen
87062>>>        If (hTable > 0) Begin
87064>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87067>>>        End
87067>>>>
87067>>>        If (bIsOpen = True) Begin
87069>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87072>>>        End
87072>>>>
87072>>>        Else Begin
87073>>>            Get pbRecnum to bRecnumTable
87074>>>        End
87074>>>>
87074>>>
87074>>>        Move False to Err
87075>>>        Move (SizeOfArray(aColumns)) to iSize
87076>>>        Decrement iSize
87077>>>        for iCount from 0 to iSize
87083>>>>
87083>>>            Move aColumns[iCount].sFieldName to sFieldName
87084>>>            If (hTable > 0) Begin
87086>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87087>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87088>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
87091>>>                Move (Trim(sFieldName) <> "") to bFieldExists
87092>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87093>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87094>>>            End
87094>>>>
87094>>>            Else Begin
87095>>>                Move False to bFieldExists
87096>>>            End
87096>>>>
87096>>>
87096>>>            If (bFieldExists = False) Begin
87098>>>                Move 0 to iColumn
87099>>>                Create_Field hTable At iColumn
87100>>>            End
87100>>>>
87100>>>            Else Begin
87101>>>                Move iCount to iColumn
87102>>>            End
87102>>>>
87102>>>
87102>>>            Set Private.piCurrentField to iColumn
87103>>>
87103>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
87104>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
87107>>>
87107>>>            Move aColumns[iCount].iType to iType
87108>>>            Move (not(iType < -1490)) to bNativeType
87109>>>            If (iType < -1490) Begin
87111>>>                Move (iType + 1500) to iType
87112>>>            End
87112>>>>
87112>>>
87112>>>            If (bIsSqlTable = True) Begin
87114>>>                If (aColumns[iCount].bIsSQLType = True) Begin
87116>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
87117>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
87120>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
87123>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
87126>>>
87126>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
87127>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87129>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87130>>>                    End
87130>>>>
87130>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
87133>>>
87133>>>                End
87133>>>>
87133>>>                Else Begin
87134>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
87137>>>                End
87137>>>>
87137>>>            End
87137>>>>
87137>>>            Else Begin
87138>>>                If (bCreating = False) Begin
87140>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
87141>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87143>>>                        Move DF_DATE to iType
87144>>>                    End
87144>>>>
87144>>>                End
87144>>>>
87144>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
87147>>>            End
87147>>>>
87147>>>
87147>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
87148>>>            If (bIsDateType = False) Begin
87150>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
87153>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
87156>>>            End
87156>>>>
87156>>>
87156>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
87158>>>                Move 0 to iIndex
87159>>>                Create_Index hTable at iIndex
87160>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
87163>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
87166>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
87169>>>
87169>>>                // If we have an identity table - we must create a primary_key table.
87169>>>                If (bIsSqlTable = True) Begin
87171>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
87174>>>                        Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
87177>>>                End
87177>>>>
87177>>>            End
87177>>>>
87177>>>        Loop
87178>>>>
87178>>>
87178>>>        Function_Return (Err = False)
87179>>>    End_Function
87180>>>
87180>>>    // Changes a field type, length and precision for the passed table number and field name
87180>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
87182>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
87182>>>        Boolean bOK bIsSqlTable
87182>>>        String sFieldNameTo
87182>>>
87182>>>        If (num_arguments > 4) Begin
87184>>>            Move iPrec to iPrecFrom
87185>>>        End
87185>>>>
87185>>>        If (iTypeFrom < -1490) Begin
87187>>>            Move (iTypeFrom + 1500) to iTypeFrom
87188>>>        End
87188>>>>
87188>>>
87188>>>        Get AutoConnectionIDLogin to bOK
87189>>>        Move False to Err
87190>>>        Get OpenTableExclusive hTable to bOK
87191>>>        If (bOK = False) Begin
87193>>>            Function_Return False
87194>>>        End
87194>>>>
87194>>>
87194>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87195>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87196>>>        Field_Map hTable sFieldNameFrom to iColumn
87198>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87199>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87200>>>        If (Err = True) Begin
87202>>>            Function_Return False
87203>>>        End
87203>>>>
87203>>>
87203>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
87206>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87207>>>        If (bIsSqlTable = False) Begin
87209>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
87212>>>        End
87212>>>>
87212>>>        Else Begin
87213>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
87216>>>        End
87216>>>>
87216>>>        // Let the driver decide the other values;
87216>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
87219>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
87222>>>
87222>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
87224>>>            Function_Return False
87225>>>        End
87225>>>>
87225>>>
87225>>>        Set Private.phCurrentTable to hTable
87226>>>        Set Private.piCurrentField to iColumn
87227>>>
87227>>>        Structure_Start hTable
87228>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
87231>>>//            If (bIsSqlTable = False) Begin
87231>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87234>>>//            End
87234>>>//            Else Begin
87234>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87234>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
87234>>>//            End
87234>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
87237>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
87240>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87241>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87243>>>
87243>>>        Set Action_Text of ghoStatusPanel to ""
87244>>>        Function_Return (Err = False)
87245>>>    End_Function
87246>>>
87246>>>    // Changes a field type, length and precision for the passed table number and field name
87246>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
87248>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
87248>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
87248>>>        String sFieldNameTo sDriverIDTo
87248>>>        tColumnType ColumnType
87248>>>        tColumnType ColumnType
87248>>>
87248>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
87249>>>        Get piDbType to iDbType
87250>>>        If (num_arguments > 4) Begin
87252>>>            Move iPrec to iPrecFrom
87253>>>            Move iOpt  to iOptionFrom
87254>>>        End
87254>>>>
87254>>>        If (iTypeFrom < -1490) Begin
87256>>>            Move (iTypeFrom + 1500) to iTypeFrom
87257>>>        End
87257>>>>
87257>>>
87257>>>        Get AutoConnectionIDLogin to bOK
87258>>>        Move False to Err
87259>>>        Close hTable
87260>>>        Get OpenTableExclusive hTable to bOK
87261>>>        If (bOK = False) Begin
87263>>>            Function_Return False
87264>>>        End
87264>>>>
87264>>>
87264>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
87267>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
87270>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
87271>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87273>>>            Move DF_DATE to iDataFlexType
87274>>>        End
87274>>>>
87274>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
87277>>>
87277>>>        If (bIsSQLTableTo = True) Begin
87279>>>                Get_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeTo
87282>>>        End
87282>>>>
87282>>>        Else Begin
87283>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
87286>>>        End
87286>>>>
87286>>>
87286>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
87289>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
87292>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
87295>>>
87295>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87295>>>        // data types between Embedded and SQL, else we can't compare the data types.
87295>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87297>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
87298>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87300>>>                Move DF_DATE to iTypeTo  
87301>>>            End
87301>>>>
87301>>>        End
87301>>>>
87301>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87304>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
87305>>>        End
87305>>>>
87305>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
87306>>>
87306>>>        If (bCompareDate_DateTime = False) Begin
87308>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
87309>>>            If (bSkip = True) Begin
87311>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87313>>>                    Function_Return True
87314>>>                End
87314>>>>
87314>>>            End
87314>>>>
87314>>>        End
87314>>>>
87314>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87317>>>            Function_Return True
87318>>>        End
87318>>>>
87318>>>
87318>>>        Set Private.phCurrentTable to hTable
87319>>>        Set Private.piCurrentField to iColumn
87320>>>
87320>>>        Structure_Start hTable
87321>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
87323>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
87326>>>            End
87326>>>>
87326>>>
87326>>>            If (bIsSameDataType = False) Begin
87328>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
87331>>>                If (bIsSQLTableTo = True) Begin
87333>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeFrom
87336>>>                End
87336>>>>
87336>>>            End
87336>>>>
87336>>>
87336>>>            If (iLengthFrom <> iLengthTo) Begin
87338>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
87341>>>            End
87341>>>>
87341>>>            If (iPrecFrom <> iPrecTo) Begin
87343>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
87346>>>            End
87346>>>>
87346>>>
87346>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
87348>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
87348>>>                If (bRecnumTable = True) Begin
87350>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
87353>>>                End
87353>>>>
87353>>>
87353>>>                // We might need to create an index here.
87353>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
87353>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
87353>>>                // index update checking logic.
87353>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
87356>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
87358>>>                    Create_Index hTable At iIndex
87359>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
87362>>>                End
87362>>>>
87362>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
87365>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
87368>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
87371>>>                If (bIsSQLTableTo = True) Begin
87373>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
87376>>>                End
87376>>>>
87376>>>            End
87376>>>>
87376>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87377>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87379>>>
87379>>>        Set Action_Text of ghoStatusPanel to ""
87380>>>        Function_Return (Err = False)
87381>>>    End_Function
87382>>>
87382>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
87384>>>        Boolean bOK
87384>>>
87384>>>        Get AutoConnectionIDLogin to bOK
87385>>>        Move False to Err
87386>>>        Get OpenTableExclusive hTable to bOK
87387>>>        If (bOK = False) Begin
87389>>>            Function_Return False
87390>>>        End
87390>>>>
87390>>>
87390>>>        Structure_Start hTable
87391>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
87394>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87395>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87397>>>
87397>>>        Set Action_Text of ghoStatusPanel to ""
87398>>>        Function_Return (Err = False)
87399>>>    End_Function
87400>>>
87400>>>    // To move an existing field to another position in a table.
87400>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
87402>>>        String sColumn sDriverID
87402>>>        Integer iType
87402>>>        Boolean bOK bIsDate
87402>>>
87402>>>        Close hTable
87403>>>        Get AutoConnectionIDLogin to bOK
87404>>>        Get OpenTableExclusive hTable to bOK
87405>>>        If (bOK = False) Begin
87407>>>            Function_Return False
87408>>>        End
87408>>>>
87408>>>
87408>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87411>>>        If (sDriverID = DFBTRDRV_ID) Begin
87413>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
87414>>>>
87414>>>            Function_Return False
87415>>>        End
87415>>>>
87415>>>
87415>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
87418>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
87421>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
87422>>>
87422>>>        Set Private.phCurrentTable to hTable
87423>>>        Set Private.piCurrentField to iOld
87424>>>
87424>>>//        If (bIsDate = False) Begin
87424>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
87424>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
87424>>>//        End
87424>>>//        Else Begin
87424>>>//            Move 6 to iLength
87424>>>//            Move 0 to iPrecision
87424>>>//        End
87424>>>
87424>>>        Move False to Err
87425>>>
87425>>>        Structure_Start hTable
87426>>>            Delete_Field hTable iOld
87427>>>            Create_Field hTable At iNew
87428>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
87431>>>
87431>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
87434>>>            If (bIsSQLType = False) Begin
87436>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87439>>>            End
87439>>>>
87439>>>            Else Begin
87440>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87443>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
87443>>>            End
87443>>>>
87443>>>
87443>>>            If (bIsDate = False) Begin
87445>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
87448>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
87451>>>            End
87451>>>>
87451>>>
87451>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87452>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87454>>>
87454>>>        Set Action_Text of ghoStatusPanel to ""
87455>>>        Function_Return (Err = False)
87456>>>    End_Function
87457>>>
87457>>>    // Deletes a column name for the passed table number (and column number).
87457>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
87459>>>        Integer iColumn
87459>>>        Boolean bOK
87459>>>
87459>>>        Get AutoConnectionIDLogin to bOK
87460>>>        Move False to Err
87461>>>        Close hTable
87462>>>        Get OpenTableExclusive hTable to bOK
87463>>>        If (bOK = False) Begin
87465>>>            Function_Return False
87466>>>        End
87466>>>>
87466>>>
87466>>>        If (not(Err)) Begin
87468>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87469>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87470>>>            Field_Map hTable sFieldName to iColumn
87472>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87473>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87474>>>            If (iColumn = 0) Begin
87476>>>                Move 0 to LastErr
87477>>>                Function_Return False
87478>>>            End
87478>>>>
87478>>>            Move False to Err
87479>>>
87479>>>            Set Private.phCurrentTable to hTable
87480>>>            Set Private.piCurrentField to iColumn
87481>>>
87481>>>            Structure_Start hTable
87482>>>                Delete_Field hTable iColumn
87483>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87484>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87486>>>            Set Action_Text of ghoStatusPanel to ""
87487>>>        End
87487>>>>
87487>>>        Else Begin
87488>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
87489>>>>
87489>>>        End
87489>>>>
87489>>>
87489>>>        Function_Return (Err = False)
87490>>>    End_Function
87491>>>
87491>>>    // Renames a field for the passed table number & old field name & new field name
87491>>>    // Returns True if no errors occured.
87491>>>    // Sample usage:
87491>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
87491>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
87493>>>        Integer iField
87493>>>        Boolean bOK bExists bIsOpen
87493>>>
87493>>>        Get UtilColumnExists hTable sNewFieldName to bExists
87494>>>        If (bExists = True) Begin
87496>>>            Function_Return False
87497>>>        End
87497>>>>
87497>>>
87497>>>        // Note: The Field_Map command does _not_ work if the table has been
87497>>>        //       opened exclusively, so we first open it in normal mode.
87497>>>        Close hTable
87498>>>        Open hTable
87500>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87503>>>        If (bIsOpen = False) Begin
87505>>>            Function_Return False
87506>>>        End
87506>>>>
87506>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87507>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87508>>>        Field_Map hTable sOldFieldName to iField
87510>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87511>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87512>>>
87512>>>        Get AutoConnectionIDLogin to bOK
87513>>>        Get OpenTableExclusive hTable to bOK
87514>>>        If (bOK = False) Begin
87516>>>            Function_Return False
87517>>>        End
87517>>>>
87517>>>
87517>>>        Move False to Err
87518>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87519>>>        Set Private.phCurrentTable to hTable
87520>>>        Set Private.piCurrentField to iField
87521>>>
87521>>>        If (iField > 0) Begin
87523>>>            Structure_Start hTable
87524>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
87527>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87528>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87530>>>        End
87530>>>>
87530>>>        Else Begin
87531>>>            Move 0 to LastErr
87532>>>            Move False to Err
87533>>>        End
87533>>>>
87533>>>
87533>>>        Set Action_Text of ghoStatusPanel to ""
87534>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87535>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87536>>>
87536>>>        Function_Return (Err = False)
87537>>>    End_Function
87538>>>
87538>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87540>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87540>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87541>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
87541>>>        Boolean bRenameField
87541>>>
87541>>>        Open hTable
87543>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87544>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87545>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87546>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
87549>>>        Move (iSize max iNumberOfFieldsTo) to iSize
87550>>>        Decrement iSize
87551>>>        for iCount from 0 to iSize
87557>>>>
87557>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87559>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87560>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87561>>>
87561>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
87563>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
87565>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
87566>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
87567>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
87569>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
87570>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
87571>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
87572>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
87573>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
87574>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
87575>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
87576>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
87577>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
87578>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
87579>>>                        Increment iItem
87580>>>                    End
87580>>>>
87580>>>                End
87580>>>>
87580>>>            End
87580>>>>
87580>>>        Loop
87581>>>>
87581>>>
87581>>>        Move False to Err
87582>>>        Move 0 to LastErr
87583>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87584>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87585>>>        Function_Return aAPIColumnsToInsert
87586>>>    End_Function
87587>>>
87587>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
87589>>>        Integer iSize iCount
87589>>>        Boolean bOK
87589>>>        tAPIColumn[] aColumnsTo
87589>>>        tAPIColumn[] aColumnsTo
87590>>>        tAPIColumnCompare[] aAPIColumnCompare
87590>>>        tAPIColumnCompare[] aAPIColumnCompare
87591>>>
87591>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
87592>>>        If (iSize = 0) Begin
87594>>>            Function_Return True
87595>>>        End
87595>>>>
87595>>>
87595>>>        Move False to Err
87596>>>        Decrement iSize
87597>>>        for iCount from 0 to iSize
87603>>>>
87603>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
87604>>>        Loop
87605>>>>
87605>>>
87605>>>        Function_Return bOK
87606>>>    End_Function
87607>>>
87607>>>    // Returns a struct array with fields that has the same names but different field numbers.
87607>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87609>>>        tAPIColumnCompare[] aAPIColumnsToMove
87609>>>        tAPIColumnCompare[] aAPIColumnsToMove
87610>>>        Integer iSize iCount iItem iShouldMove
87610>>>
87610>>>        Move 0 to iItem
87611>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87612>>>        Decrement iSize
87613>>>        for iCount from 0 to iSize
87619>>>>
87619>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87621>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
87622>>>                If (iShouldMove <> -1) Begin
87624>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
87625>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
87626>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
87627>>>                    Increment iItem
87628>>>                End
87628>>>>
87628>>>            End
87628>>>>
87628>>>        Loop
87629>>>>
87629>>>
87629>>>        Move False to Err
87630>>>        Move 0 to LastErr
87631>>>        Function_Return aAPIColumnsToMove
87632>>>    End_Function
87633>>>
87633>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
87635>>>        Integer iSize iCount
87635>>>        Boolean bOK
87635>>>        tAPIColumnCompare[] aAPIColumnCompare
87635>>>        tAPIColumnCompare[] aAPIColumnCompare
87636>>>
87636>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
87637>>>        If (iSize = 0) Begin
87639>>>            Function_Return True
87640>>>        End
87640>>>>
87640>>>
87640>>>        Move False to Err
87641>>>        Decrement iSize
87642>>>        for iCount from 0 to iSize
87648>>>>
87648>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87649>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87650>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
87652>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
87653>>>                Get UtilColumnsStructFill hTable to aColumnsTo
87654>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87655>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
87656>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
87658>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
87659>>>                    Decrement iSize
87660>>>                    Move 0 to iCount
87661>>>                End
87661>>>>
87661>>>            End
87661>>>>
87661>>>        Loop
87662>>>>
87662>>>
87662>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87663>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87664>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
87666>>>            Move 0 to LastErr
87667>>>        End
87667>>>>
87667>>>        Function_Return bOK
87668>>>    End_Function
87669>>>
87669>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
87669>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
87669>>>    // - The "FROM" field name is <> "TO" field name
87669>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
87669>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
87669>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
87671>>>        Boolean bShouldRename
87671>>>        String sFieldNameFrom sFieldNameTo
87671>>>
87671>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
87672>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
87673>>>        If (sFieldNameFrom = sFieldNameTo) Begin
87675>>>            Function_Return False
87676>>>        End
87676>>>>
87676>>>
87676>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
87677>>>//        If (bShouldRename = False) Begin
87677>>>//            Function_Return False
87677>>>//        End
87677>>>//
87677>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
87677>>>//            Function_Return True
87677>>>//        End
87677>>>
87677>>>        Function_Return bShouldRename
87678>>>    End_Function
87679>>>
87679>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
87679>>>    // Else it returns the column/field number of the field that exists in another position.
87679>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
87681>>>        Integer iCount iSize iRetval
87681>>>        String sFieldNameFrom
87681>>>
87681>>>        Move -1 to iRetval
87682>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
87684>>>            Function_Return iRetval
87685>>>        End
87685>>>>
87685>>>
87685>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
87686>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87687>>>        Decrement iSize
87688>>>        for iCount from 0 to iSize
87694>>>>
87694>>>            // We're only interested in fields other than the passed field/column number:
87694>>>            If (iCount <> iColumn) Begin
87696>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
87698>>>                    Move (iCount + 1) to iRetval
87699>>>                End
87699>>>>
87699>>>            End
87699>>>>
87699>>>        Loop
87700>>>>
87700>>>
87700>>>        Move 0 to LastErr
87701>>>        Function_Return iRetval
87702>>>    End_Function
87703>>>
87703>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87705>>>        tAPIColumnCompare[] aAPIColumnsToRename
87705>>>        tAPIColumnCompare[] aAPIColumnsToRename
87706>>>        Integer iSize iCount iItem iFieldTo iShouldMove
87706>>>        Boolean bRenameField
87706>>>
87706>>>        Open hTable
87708>>>        Move 0 to iItem
87709>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87710>>>        Decrement iSize
87711>>>        for iCount from 0 to iSize
87717>>>>
87717>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87719>>>                // Check if the field exists in another position (other field number)
87719>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
87720>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
87721>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
87723>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
87724>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
87725>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
87726>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
87727>>>                    Increment iItem
87728>>>                End
87728>>>>
87728>>>            End
87728>>>>
87728>>>        Loop
87729>>>>
87729>>>
87729>>>        Move False to Err
87730>>>        Move 0 to LastErr
87731>>>        Function_Return aAPIColumnsToRename
87732>>>    End_Function
87733>>>
87733>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
87735>>>        Integer iSize iCount
87735>>>        Boolean bOK
87735>>>        tAPIColumn[] aColumnsTo
87735>>>        tAPIColumn[] aColumnsTo
87736>>>        tAPIColumnCompare[] aAPIColumnCompare
87736>>>        tAPIColumnCompare[] aAPIColumnCompare
87737>>>
87737>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
87738>>>        If (iSize = 0) Begin
87740>>>            Function_Return True
87741>>>        End
87741>>>>
87741>>>
87741>>>        Move False to Err
87742>>>        Decrement iSize
87743>>>        For iCount from 0 to iSize
87749>>>>
87749>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87750>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
87751>>>        Loop
87752>>>>
87752>>>
87752>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87753>>>        Function_Return bOK
87754>>>    End_Function
87755>>>
87755>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
87757>>>        Boolean bDateType
87757>>>
87757>>>        If (bIsSQLTableTo = True) Begin
87759>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
87760>>>        End
87760>>>>
87760>>>        Else Begin
87761>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
87762>>>        End
87762>>>>
87762>>>
87762>>>        Function_Return bDateType
87763>>>    End_Function
87764>>>
87764>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
87766>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
87766>>>        Integer iCount2 iColumn2
87766>>>        Handle hFile
87766>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
87766>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
87766>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
87766>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
87766>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
87771>>>        tColumnType ColumnType
87771>>>        tColumnType ColumnType
87771>>>
87771>>>        Move False to Err
87772>>>        Close hTable
87773>>>        Get OpenTableExclusive hTable to bIsOpen
87774>>>        If (bIsOpen = False) Begin
87776>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
87777>>>>
87777>>>            Function_Return False
87778>>>        End 
87778>>>>
87778>>>        
87778>>>        Get piDbType to iDbType
87779>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87782>>>        Move bIsSQLTableFrom to bIsSQLDriver
87783>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
87784>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
87787>>>
87787>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87788>>>
87788>>>        // Before we start to change the table we need to do three things;
87788>>>        // 1) Insert any new fields
87788>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
87789>>>        If (SizeOfArray(aApiInsertColumns)) Begin
87791>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
87792>>>            If (bOK = False) Begin
87794>>>                Function_Return False
87795>>>            End
87795>>>>
87795>>>            // Update info with changes made.
87795>>>            Get UtilColumnsStructFill hTable to aColumnsTo
87796>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87797>>>        End
87797>>>>
87797>>>
87797>>>        // 2) Move fields with same names
87797>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
87798>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
87800>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
87801>>>            If (bOK = False) Begin
87803>>>                Function_Return False
87804>>>            End
87804>>>>
87804>>>            Get UtilColumnsStructFill hTable to aColumnsTo
87805>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87806>>>        End
87806>>>>
87806>>>        
87806>>>        // 3) Rename fields
87806>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
87807>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
87809>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
87810>>>            If (bOK = False) Begin
87812>>>                Function_Return False
87813>>>            End
87813>>>>
87813>>>            Get UtilColumnsStructFill hTable to aColumnsTo
87814>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87815>>>        End
87815>>>>
87815>>>
87815>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
87815>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
87815>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
87815>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
87815>>>//            If (bOK = False) Begin
87815>>>//                Function_Return False
87815>>>//            End
87815>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
87815>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87815>>>//        End
87815>>>
87815>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
87815>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
87817>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
87818>>>            If (bIsSame = True) Begin
87820>>>                Function_Return True
87821>>>            End
87821>>>>
87821>>>        End
87821>>>>
87821>>>
87821>>>        // We can now continue to make standard field changes:
87821>>>        Get OpenTableExclusive hTable to bIsOpen
87822>>>        Set Private.phCurrentTable to hTable
87823>>>        Move hTable to hFile
87824>>>        Structure_Start hFile sDriverIDTo
87825>>>
87825>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
87826>>>            Decrement iColumns
87827>>>            for iCount from 0 to iColumns
87833>>>>
87833>>>                Send DoAdvance of ghoProgressBar
87834>>>
87834>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
87835>>>                Set Private.piCurrentField                  to iColumn
87836>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
87837>>>                If (bIsSame = False) Begin
87839>>>
87839>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
87840>>>                    If (bFieldExistsFrom = True) Begin
87842>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
87843>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
87844>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
87845>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
87846>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
87847>>>
87847>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
87848>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
87849>>>                        If (iTypeFrom < -1490) Begin
87851>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
87852>>>                        End
87852>>>>
87852>>>
87852>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
87852>>>                        // data types between Embedded and SQL, else we can't compare the data types.
87852>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87854>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
87855>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87857>>>                                Move DF_DATE to iTypeFrom
87858>>>                            End
87858>>>>
87858>>>                        End
87858>>>>
87858>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87861>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
87862>>>                        End
87862>>>>
87862>>>
87862>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
87863>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
87864>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
87865>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
87866>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
87867>>>
87867>>>                        Move False to bSkipTypeChange
87868>>>                        If (bCompareDate_DateTime = False) Begin
87870>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
87871>>>                        End
87871>>>>
87871>>>
87871>>>                        If (bFieldExistsTo = False) Begin
87873>>>                            Move 0 to iColumn
87874>>>                            Create_Field hFile At iColumn
87875>>>                            Set Private.piCurrentField to iColumn
87876>>>                        End
87876>>>>
87876>>>
87876>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
87878>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
87881>>>                        End
87881>>>>
87881>>>
87881>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
87883>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
87886>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
87887>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87889>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87890>>>                            End
87890>>>>
87890>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
87893>>>                        End
87893>>>>
87893>>>
87893>>>                        If (bSkipTypeChange = False) Begin
87895>>>                            If (iTypeFrom <> iTypeTo) Begin
87897>>>                                If (bIsSQLTableTo = True) Begin
87899>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
87902>>>                                End
87902>>>>
87902>>>                                Else Begin                                                   
87903>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87905>>>                                        Move DF_DATE to iDataFlexType  // Date
87906>>>                                    End
87906>>>>
87906>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
87909>>>                                End
87909>>>>
87909>>>                            End
87909>>>>
87909>>>                        End
87909>>>>
87909>>>
87909>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
87910>>>                        // We can't set the length or precision for Date type columns (they are fixed).
87910>>>                        If (bIsDateType = False) Begin
87912>>>                            If (iLengthFrom <> iLengthTo) Begin
87914>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
87917>>>                            End
87917>>>>
87917>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
87919>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
87922>>>                            End
87922>>>>
87922>>>                        End
87922>>>>
87922>>>
87922>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
87924>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
87924>>>                            If (bRecnumTable = True) Begin
87926>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
87929>>>                            End
87929>>>>
87929>>>
87929>>>                            // We might need to create an index here.
87929>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
87929>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
87929>>>                            // index update checking logic.
87929>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
87932>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
87934>>>                                Create_Index hFile at iIndex
87935>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
87938>>>                            End
87938>>>>
87938>>>
87938>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
87941>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
87944>>>                                // Note: The order here is crucial!
87944>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
87947>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
87950>>>                        End
87950>>>>
87950>>>                    End
87950>>>>
87950>>>                    Else Begin
87951>>>                        Delete_Field hFile iColumn
87952>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
87953>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
87954>>>                        Decrement iCount2
87955>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
87955>>>                        // starting with the array number we just deleted the field for.
87955>>>                        for iColumn2 from iCount to iCount2
87961>>>>
87961>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
87962>>>                        Loop
87963>>>>
87963>>>                        Decrement iCount
87964>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87965>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
87966>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
87968>>>                            Move iColumns to iCount 
87969>>>                        End
87969>>>>
87969>>>                    End
87969>>>>
87969>>>                End
87969>>>>
87969>>>            Loop
87970>>>>
87970>>>
87970>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87971>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87973>>>
87973>>>        Set Action_Text of ghoStatusPanel to ""
87974>>>        Function_Return (Err = False)
87975>>>    End_Function
87976>>>
87976>>>    // * Dummy function for the Studio's Code Explorer *
87976>>>    Function API_INDEX_FUNCTIONS Returns Boolean
87978>>>        Function_Return False
87979>>>    End_Function
87980>>>
87980>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
87980>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
87980>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
87980>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
87982>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
87982>>>        String sDriverID
87982>>>        Boolean bOK bExists bIsSQLTable
87982>>>
87982>>>        Get AutoConnectionIDLogin to bOK
87983>>>        Get OpenTableExclusive hTable to bOK
87984>>>        If (bOK = False) Begin
87986>>>            Function_Return False
87987>>>        End
87987>>>>
87987>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87990>>>
87990>>>            Get _UtilTableIsSql hTable to bIsSQLTable
87991>>>            If (bIsSQLTable = True) Begin
87993>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
87996>>>            End
87996>>>>
87996>>>
87996>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
87999>>>        Move (iIndexSegments > 0) to bExists
88000>>>        If (bExists = True) Begin
88002>>>            Function_Return True
88003>>>        End
88003>>>>
88003>>>
88003>>>        Move -1 to iSegment1
88004>>>        Move -1 to iSegment2
88005>>>        Move -1 to iSegment3
88006>>>        Move -1 to iSegment4
88007>>>        Move -1 to iSegment5
88008>>>        Move -1 to iSegment6
88009>>>        Move -1 to iSegment7
88010>>>        Move -1 to iSegment8
88011>>>        Move -1 to iSegment9
88012>>>        Move -1 to iSegment10
88013>>>
88013>>>        If (num_arguments > 3) Begin
88015>>>            Move iSgmnt1 to iSegment1
88016>>>        End
88016>>>>
88016>>>        If (num_arguments > 4) Begin
88018>>>            Move iSgmnt2 to iSegment2
88019>>>        End
88019>>>>
88019>>>        If (num_arguments > 5) Begin
88021>>>            Move iSgmnt3 to iSegment3
88022>>>        End
88022>>>>
88022>>>        If (num_arguments > 6) Begin
88024>>>            Move iSgmnt4 to iSegment4
88025>>>        End
88025>>>>
88025>>>        If (num_arguments > 7) Begin
88027>>>            Move iSgmnt5 to iSegment5
88028>>>        End
88028>>>>
88028>>>        If (num_arguments > 8) Begin
88030>>>            Move iSgmnt6 to iSegment6
88031>>>        End
88031>>>>
88031>>>        If (num_arguments > 9) Begin
88033>>>            Move iSgmnt7 to iSegment7
88034>>>        End
88034>>>>
88034>>>        If (num_arguments > 10) Begin
88036>>>            Move iSgmnt8 to iSegment8
88037>>>        End
88037>>>>
88037>>>        If (num_arguments > 11) Begin
88039>>>            Move iSgmnt9 to iSegment9
88040>>>        End
88040>>>>
88040>>>        If (num_arguments > 12) Begin
88042>>>            Move iSgmnt10 to iSegment10
88043>>>        End
88043>>>>
88043>>>
88043>>>        Move False to Err
88044>>>        Move hTable to iTableNo
88045>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88046>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88047>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88048>>>
88048>>>        // We start by deleting the index, if it exists.
88048>>>        If (bExists = True) Begin
88050>>>            Structure_Start hTable sDriverID
88051>>>                Delete_Index iTableNo iIndex
88052>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88053>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88055>>>        End
88055>>>>
88055>>>
88055>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88056>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88057>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88058>>>        Set Action_Text of ghoStatusPanel to ""
88059>>>        Move False to Err
88060>>>        Move 0 to LastErr
88061>>>
88061>>>        // Need to re-open if index deleted.
88061>>>        Move iTableNo to hTable
88062>>>        Get OpenTableExclusive hTable to bOK
88063>>>        If (bOK = False) Begin
88065>>>            Function_Return False
88066>>>        End
88066>>>>
88066>>>
88066>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88067>>>        Structure_Start hTable sDriverID
88068>>>            Create_Index hTable At iIndex
88069>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88072>>>
88072>>>            If (iSgmnt1 <> -1) Begin
88074>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88077>>>            End
88077>>>>
88077>>>            If (iSegment2 <> -1) Begin
88079>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88082>>>            End
88082>>>>
88082>>>            If (iSegment3 <> -1) Begin
88084>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88087>>>            End
88087>>>>
88087>>>            If (iSegment4 <> -1) Begin
88089>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88092>>>            End
88092>>>>
88092>>>            If (iSegment5 <> -1) Begin
88094>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88097>>>            End
88097>>>>
88097>>>            If (iSegment6 <> -1) Begin
88099>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88102>>>            End
88102>>>>
88102>>>            If (iSegment7 <> -1) Begin
88104>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88107>>>            End
88107>>>>
88107>>>            If (iSegment8 <> -1) Begin
88109>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88112>>>            End
88112>>>>
88112>>>            If (iSegment9 <> -1) Begin
88114>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88117>>>            End
88117>>>>
88117>>>            If (iSegment10 <> -1) Begin
88119>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
88122>>>            End
88122>>>>
88122>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88123>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88125>>>
88125>>>        Set Action_Text of ghoStatusPanel to ""
88126>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88127>>>
88127>>>        Function_Return (Err = False)
88128>>>    End_Function
88129>>>
88129>>>    // Example:
88129>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
88129>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
88129>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
88131>>>        Integer iTableNo iNumSgmnt iNumSgmnts
88131>>>        String sDriverID
88131>>>        Boolean bOK bIsSQLTable
88131>>>
88131>>>        Get AutoConnectionIDLogin to bOK
88132>>>
88132>>>        Move False to Err
88133>>>        Move hTable to iTableNo
88134>>>        Get OpenTableExclusive hTable to bOK
88135>>>        If (bOK = False) Begin
88137>>>            Function_Return False
88138>>>        End
88138>>>>
88138>>>
88138>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88141>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88142>>>            If (bIsSQLTable = True) Begin
88144>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88147>>>            End
88147>>>>
88147>>>
88147>>>        // We start by deleting the index
88147>>>        Structure_Start hTable sDriverID
88148>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88149>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88150>>>            Delete_Index iTableNo iIndex
88151>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88152>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88153>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88155>>>
88155>>>        Move False to Err
88156>>>        Move iTableNo to hTable
88157>>>        Get OpenTableExclusive hTable to bOK
88158>>>        If (bOK = False) Begin
88160>>>            Function_Return False
88161>>>        End
88161>>>>
88161>>>
88161>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88162>>>        Structure_Start hTable sDriverID
88163>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
88164>>>
88164>>>            Create_Index hTable at iIndex
88165>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
88168>>>
88168>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
88174>>>>
88174>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
88177>>>            Loop
88178>>>>
88178>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88180>>>
88180>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88181>>>
88181>>>        Function_Return (Err = False)
88182>>>    End_Function
88183>>>
88183>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
88185>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
88185>>>        String sDriverID sSQLIndexName
88185>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
88185>>>
88185>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
88186>>>        If (iSegmentsFrom = 0) Begin
88188>>>            Function_Return False
88189>>>        End
88189>>>>
88189>>>
88189>>>        Get AutoConnectionIDLogin to bOK
88190>>>        Move False to Err
88191>>>        Get OpenTableExclusive hTable to bIsOpen
88192>>>        If (bIsOpen = False) Begin
88194>>>            Function_Return False
88195>>>        End
88195>>>>
88195>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88198>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88199>>>            If (bIsSQLTable = True) Begin
88201>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88204>>>            End
88204>>>>
88204>>>
88204>>>        Move 0     to iSegmentsTo
88205>>>        Move 0     to iSQLIndexType
88206>>>        Move ""    to sSQLIndexName
88207>>>        Move False to bIsSQLTemporaryIndex
88208>>>        Move False to bIsSQLPrimaryKey
88209>>>        Move False to bIsSQLClustered
88210>>>
88210>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
88211>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
88214>>>        Move (iSegmentsTo > 0) to bExists
88215>>>        If (bExists = True) Begin
88217>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
88219>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
88222>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
88225>>>                        Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
88226>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
88229>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
88232>>>            End
88232>>>>
88232>>>        End
88232>>>>
88232>>>
88232>>>        Move hTable to iTableNo
88233>>>        Move False to Err
88234>>>        Move 0 to LastErr
88235>>>
88235>>>        Structure_Start hTable sDriverID
88236>>>            If (bExists = True) Begin
88238>>>                Delete_Index iTableNo APIIndex.iIndexNumber
88239>>>            End
88239>>>>
88239>>>
88239>>>            Create_Index hTable At APIIndex.iIndexNumber
88240>>>
88240>>>                If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
88242>>>                    Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
88245>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
88248>>>                    Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
88251>>>                    Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
88254>>>                End
88254>>>>
88254>>>
88254>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
88257>>>
88257>>>            for iCount from 0 to (iSegmentsFrom -1)
88263>>>>
88263>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
88264>>>                If (iFieldFrom <> -1 ) Begin
88266>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
88269>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
88272>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
88275>>>                End
88275>>>>
88275>>>            Loop
88276>>>>
88276>>>
88276>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88277>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88279>>>
88279>>>        Set Action_Text of ghoStatusPanel to ""
88280>>>
88280>>>        Function_Return (Err = False)
88281>>>    End_Function
88282>>>
88282>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
88282>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
88282>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
88284>>>        Integer iLastIndex iCount iTableNo iSegments
88284>>>        String sSQLIndexNameCompare sTmpIndexName
88284>>>        Boolean bIsOpen bExists bIsSQLDriver 
88284>>>
88284>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88285>>>        
88285>>>        If (bIsSQLDriver = False) Begin
88287>>>            Function_Return False
88288>>>        End
88288>>>>
88288>>>
88288>>>        Move False to Err
88289>>>        Move hTable to iTableNo
88290>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
88293>>>        for iCount from 0 to iLastIndex
88299>>>>
88299>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
88302>>>            Move (iSegments > 0) to bExists
88303>>>            If (bExists = True) Begin
88305>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
88308>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
88310>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
88311>>>                    Structure_Start iTableNo sDriverID
88312>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
88315>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88317>>>                    Open hTable
88319>>>                End
88319>>>>
88319>>>            End
88319>>>>
88319>>>        Loop
88320>>>>
88320>>>
88320>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88323>>>        If (bIsOpen = False) Begin
88325>>>            Get OpenTableExclusive hTable to bIsOpen
88326>>>        End
88326>>>>
88326>>>        If (bIsOpen = False) Begin
88328>>>            Function_Return False
88329>>>        End
88329>>>>
88329>>>
88329>>>        Function_Return (Err = False)
88330>>>    End_Function
88331>>>
88331>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
88331>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
88331>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
88333>>>        Integer iSize iCount
88333>>>        Integer iRetVal
88333>>>
88333>>>        Move 0 to iRetVal
88334>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
88337>>>        If (iRetVal = 0) Begin
88339>>>            Function_Return 0
88340>>>        End
88340>>>>
88340>>>        Move (SizeOfArray(APIIndexTo)) to iSize
88341>>>        Decrement iSize
88342>>>        for iCount from 0 to iSize
88348>>>>
88348>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
88350>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
88352>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
88353>>>                End
88353>>>>
88353>>>            End
88353>>>>
88353>>>        Loop
88354>>>>
88354>>>
88354>>>        Function_Return iRetVal
88355>>>    End_Function
88356>>>
88356>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88358>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88358>>>        Boolean bIsSQLTable
88358>>>        
88358>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88359>>>            If (bIsSQLTable = True) Begin
88361>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88364>>>            End
88364>>>>
88364>>>
88364>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88367>>>        If (iSegment = iNumSegments) Begin
88369>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88369>>>        End
88369>>>>
88369>>>
88369>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88372>>>            for iCurSegment from iSegment to (iNumSegments - 1)
88378>>>>
88378>>>                //*** Move index segment attributes
88378>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88381>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88384>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88387>>>
88387>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
88390>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
88393>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
88396>>>            Loop
88397>>>>
88397>>>
88397>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88400>>>        End
88400>>>>
88400>>>
88400>>>        Function_Return (Err = False)
88401>>>    End_Function
88402>>>
88402>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
88404>>>        Integer iCount iSize iIndex
88404>>>        String sDriverID
88404>>>        Boolean bOK bIsSQLTable bIsOpen
88404>>>
88404>>>        Move (SizeOfArray(APIIndex)) to iSize
88405>>>        If (iSize = 0) Begin
88407>>>            Function_Return True
88408>>>        End
88408>>>>
88408>>>
88408>>>        Get AutoConnectionIDLogin to bOK
88409>>>        Move False to Err
88410>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88413>>>        If (bIsOpen = False) Begin
88415>>>            Get OpenTableExclusive hTable to bIsOpen
88416>>>            If (bIsOpen = False) Begin
88418>>>                Function_Return False
88419>>>            End
88419>>>>
88419>>>        End
88419>>>>
88419>>>
88419>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88422>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88423>>>            If (bIsSQLTable = True) Begin
88425>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88428>>>            End
88428>>>>
88428>>>
88428>>>        Move False to Err
88429>>>        Move 0 to LastErr
88430>>>        Decrement iSize
88431>>>
88431>>>        Structure_Start hTable sDriverID
88432>>>            for iCount from 0 to iSize
88438>>>>
88438>>>//                Move False to bIsSQLPrimaryKey
88438>>>//                #IF (!@ > 180)   // DF 18.1 and up
88438>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88438>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
88438>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88438>>>//                #ENDIF
88438>>>                // We can't delete if this is a primary key index:
88438>>>//                If (bIsSQLPrimaryKey = False) Begin
88438>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
88439>>>                    Delete_Index hTable iIndex
88440>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88440>>>//                End
88440>>>            Loop
88441>>>>
88441>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88442>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88444>>>//        Move False to Err
88444>>>        Move 0 to LastErr
88445>>>
88445>>>        Set Action_Text of ghoStatusPanel to ""
88446>>>        Function_Return (Err = False)
88447>>>    End_Function
88448>>>
88448>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
88450>>>        Boolean bOK
88450>>>
88450>>>        Get AutoConnectionIDLogin to bOK
88451>>>        Move False to Err
88452>>>        Get OpenTableExclusive hTable to bOK
88453>>>        If (bOK = False) Begin
88455>>>            Function_Return False
88456>>>        End
88456>>>>
88456>>>        Structure_Start hTable
88457>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
88460>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88461>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88463>>>
88463>>>        Set Action_Text of ghoStatusPanel to ""
88464>>>        Function_Return (Err = False)
88465>>>    End_Function
88466>>>
88466>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
88468>>>        Integer iCase
88468>>>        Boolean bOK
88468>>>
88468>>>        If (bUppercase = True) Begin
88470>>>            Move DF_CASE_IGNORED to iCase
88471>>>        End
88471>>>>
88471>>>        Else Begin
88472>>>            Move DF_CASE_USED to iCase
88473>>>        End
88473>>>>
88473>>>
88473>>>        Get AutoConnectionIDLogin to bOK
88474>>>        Move False to Err
88475>>>        Get OpenTableExclusive hTable to bOK
88476>>>        If (bOK = False) Begin
88478>>>            Function_Return False
88479>>>        End
88479>>>>
88479>>>        Structure_Start hTable
88480>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
88483>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88484>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88486>>>
88486>>>        Set Action_Text of ghoStatusPanel to ""
88487>>>        Function_Return (Err = False)
88488>>>    End_Function
88489>>>
88489>>>    // To delete an index
88489>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
88491>>>        Integer iTableNo iNumSegments
88491>>>        String sDriverID
88491>>>        Boolean bOK bIsSQLTable
88491>>>
88491>>>        Get AutoConnectionIDLogin to bOK
88492>>>        Move False to Err
88493>>>        Move hTable to iTableNo
88494>>>        Get OpenTableExclusive hTable to bOK
88495>>>        If (bOK = False) Begin
88497>>>            Function_Return False
88498>>>        End
88498>>>>
88498>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88501>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88502>>>            If (bIsSQLTable = True) Begin
88504>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88507>>>            End
88507>>>>
88507>>>
88507>>>        // Check to see if the index exists or not...
88507>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88510>>>        If (iNumSegments = 0) Begin
88512>>>            Function_Return True // Then nothing to do.
88513>>>        End
88513>>>>
88513>>>
88513>>>        Structure_Start hTable sDriverID
88514>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88515>>>            Delete_Index iTableNo iIndex
88516>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88517>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88518>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88520>>>
88520>>>        Set Action_Text of ghoStatusPanel to ""
88521>>>        Function_Return (Err = False)
88522>>>    End_Function
88523>>>
88523>>>    // Delete an Index Segment
88523>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88525>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88525>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88525>>>        Integer iIndexType
88525>>>        String sDriverID
88525>>>
88525>>>        Get AutoConnectionIDLogin to bOK
88526>>>        Move False to Err
88527>>>
88527>>>        Get OpenTableExclusive hTable to bOK
88528>>>        If (bOK = False) Begin
88530>>>            Function_Return False
88531>>>        End
88531>>>>
88531>>>
88531>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88532>>>            If (bIsSQLTable = True) Begin
88534>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88537>>>            End
88537>>>>
88537>>>
88537>>>        // Check to see if the index exists or not...
88537>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88540>>>        If (iNumSegments = 0) Begin
88542>>>            Function_Return False
88543>>>        End
88543>>>>
88543>>>
88543>>>        Move False to bIndexTemporary
88544>>>        Get psDriverID to sDriverID
88545>>>        Get IsSQLDriver sDriverID to bSQLDriver
88546>>>        If (bSQLDriver) Begin
88548>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88551>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88554>>>                Move True to bIndexTemporary
88555>>>        End
88555>>>>
88555>>>
88555>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88555>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88557>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88560>>>            If (iSegment = iNumSegments) Begin
88562>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88565>>>            End
88565>>>>
88565>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88568>>>                For iCurSegment from iSegment to (iNumSegments - 1)
88574>>>>
88574>>>                    //*** Move index segment attributes
88574>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88577>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88580>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88583>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88586>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88589>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88592>>>                Loop
88593>>>>
88593>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88596>>>            End
88596>>>>
88596>>>        End
88596>>>>
88596>>>
88596>>>        Else Begin
88597>>>           Structure_Start hTable
88598>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88601>>>               If (iSegment = iNumSegments) Begin
88603>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88606>>>               End
88606>>>>
88606>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88609>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
88615>>>>
88615>>>                       //*** Move index segment attributes
88615>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88618>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88621>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88624>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88627>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88630>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88633>>>                   Loop
88634>>>>
88634>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88637>>>               End
88637>>>>
88637>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88638>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88640>>>            Set Action_Text of ghoStatusPanel to ""
88641>>>        End
88641>>>>
88641>>>
88641>>>        Function_Return (Err = False)
88642>>>    End_Function
88643>>>
88643>>>    // Add/Insert an Index Segment
88643>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
88645>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88645>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
88645>>>        Integer iIndexType
88645>>>        String sDriverId
88645>>>
88645>>>        Get AutoConnectionIDLogin to bOK
88646>>>        Move False to Err
88647>>>
88647>>>        Get OpenTableExclusive hTable to bOK
88648>>>        If (bOK = False) Begin
88650>>>            Function_Return False
88651>>>        End
88651>>>>
88651>>>
88651>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88652>>>            If (bIsSQLTable = True) Begin
88654>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88657>>>            End
88657>>>>
88657>>>
88657>>>        Move False to bIndexTemporary
88658>>>        // Check to see if the index exists or not...
88658>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88661>>>        If (iNumSegments = 0) Begin
88663>>>            Function_Return False
88664>>>        End
88664>>>>
88664>>>
88664>>>        Get psDriverID to sDriverID
88665>>>        Get IsSQLDriver sDriverID to bSQLDriver
88666>>>        If (bSQLDriver) Begin
88668>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88671>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88674>>>                Move True to bIndexTemporary
88675>>>        End
88675>>>>
88675>>>
88675>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88675>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88677>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88680>>>
88680>>>           If (iSegment > iNumSegments) Begin
88682>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88685>>>               Move (iNumSegments + 1) to iCurSegment
88686>>>           End
88686>>>>
88686>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
88689>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88692>>>               Move iNumSegments to iCurSegment
88693>>>
88693>>>               While (iCurSegment > iSegment)
88697>>>                   //*** Move index segment attributes
88697>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
88700>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
88703>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
88706>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
88709>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
88712>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
88715>>>                   Decrement iCurSegment
88716>>>               Loop
88717>>>>
88717>>>
88717>>>               //*** Now set new segment attributes
88717>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
88720>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
88723>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
88726>>>           End
88726>>>>
88726>>>        End
88726>>>>
88726>>>
88726>>>        Else Begin
88727>>>        Structure_Start hTable
88728>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88731>>>
88731>>>            If (iSegment > iNumSegments) Begin
88733>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88736>>>                Move (iNumSegments + 1) to iCurSegment
88737>>>            End
88737>>>>
88737>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
88740>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88743>>>                Move iNumSegments to iCurSegment
88744>>>
88744>>>                While (iCurSegment > iSegment)
88748>>>                    //*** Move index segment attributes
88748>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
88751>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
88754>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
88757>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88760>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88763>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88766>>>                    Decrement iCurSegment
88767>>>                Loop
88768>>>>
88768>>>
88768>>>                //*** Now set new segment attributes
88768>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
88771>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
88774>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
88777>>>            End
88777>>>>
88777>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88778>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88780>>>            Set Action_Text of ghoStatusPanel to ""
88781>>>        End
88781>>>>
88781>>>
88781>>>        Function_Return (Err = False)
88782>>>    End_Function
88783>>>
88783>>>    // * Dummy function for the Studio's Code Explorer *
88783>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
88785>>>        Function_Return False
88786>>>    End_Function  
88787>>>    
88787>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
88787>>>    // for an SQL conversion.
88787>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
88789>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
88789>>>        
88789>>>        Move True to bConvertTo30FormatbOK
88790>>>        Move True to bRepairAndReindexOK
88791>>>        Move True to bFixBogusDatesOK
88792>>>        Move True to bMoveMiscFilesToBackupOK
88793>>>        
88793>>>        If (bMoveMiscFilesToBackup = True) Begin   
88795>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
88796>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
88797>>>        End                                                                                
88797>>>>
88797>>>        If (bFixALLBogusFilelistEntries = True) Begin
88799>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
88800>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
88801>>>        End
88801>>>>
88801>>>        If (bConvertTo30Format = True) Begin
88803>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
88804>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
88805>>>        End                                                 
88805>>>>
88805>>>        If (bRepairAndReindex = True) Begin
88807>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
88808>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
88809>>>        End  
88809>>>>
88809>>>        If (bFixBogusDates = True) Begin
88811>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
88812>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
88813>>>        End                                    
88813>>>>
88813>>>        
88813>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
88814>>>    End_Function
88815>>>
88815>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
88817>>>        Boolean bOK bFlexErrs bTemp
88817>>>        Handle hTable
88817>>>        String sTableName
88817>>>        Integer iCount iSize
88817>>>        
88817>>>        Move True to bOK
88818>>>        Move 0 to hTable    
88819>>>
88819>>>        Get UtilFilelistNoOfTables to iSize
88820>>>        Set pbVisible    of ghoProgressBarOverall to True
88821>>>        Set piPosition   of ghoProgressBarOverall to 0
88822>>>        Set piMaximum    of ghoProgressBarOverall to iSize
88823>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
88824>>>
88824>>>        Repeat
88824>>>>
88824>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
88825>>>            Set piPosition of ghoProgressBarOverall to iCount  
88826>>>            Increment iCount
88827>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
88830>>>            If (hTable > 0) Begin
88832>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
88835>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
88836>>>                If (bFlexErrs = False) Begin
88838>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
88839>>>                    If (bTemp = False) Begin
88841>>>                        Move False to bOK
88842>>>                    End
88842>>>>
88842>>>                End
88842>>>>
88842>>>            End
88842>>>>
88842>>>        Until (hTable = 0)
88844>>>        
88844>>>        Set Action_Text of ghoStatusPanel to ""
88845>>>        Function_Return bOK
88846>>>    End_Function
88847>>>    
88847>>>    // Converts an embedded table from 2.3 -> 3.0.
88847>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
88847>>>    // It will return a TRUE if successful or the table is an SQL table.
88847>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
88849>>>        Boolean bOK bIsEmbedded bIsAlias
88849>>>        String sRevision
88849>>>        
88849>>>        Get AutoConnectionIDLogin to bOK
88850>>>        If (bOK = False) Begin
88852>>>            Function_Return True
88853>>>        End
88853>>>>
88853>>>        Get OpenTableExclusive hTable to bOK
88854>>>        If (bOK = False) Begin
88856>>>            Function_Return True
88857>>>        End
88857>>>>
88857>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
88858>>>        If (bIsEmbedded = False) Begin
88860>>>            Function_Return True
88861>>>        End                             
88861>>>>
88861>>>        Get UtilTableIsAlias hTable to bIsAlias
88862>>>        If (bIsAlias = True) Begin
88864>>>            Function_Return True
88865>>>        End                     
88865>>>>
88865>>>        
88865>>>        Move False to Err
88866>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
88869>>>        If (sRevision contains "2.3") Begin
88871>>>            Move False to Err
88872>>>            Set Private.phCurrentTable to hTable
88873>>>            Structure_Start hTable    
88874>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
88877>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
88878>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
88880>>>            Set Action_Text of ghoStatusPanel to ""
88881>>>        End
88881>>>>
88881>>>        
88881>>>        Function_Return (Err = False)
88882>>>    End_Function
88883>>>
88883>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
88885>>>        Boolean bIgnore bExists bOK bResponse
88885>>>        Handle hTable   
88885>>>        String sTableName
88885>>>        
88885>>>        Move False to Err 
88886>>>        Move True to bOK
88887>>>        Move 0 to hTable
88888>>>        Repeat
88888>>>>
88888>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
88891>>>            If (hTable > 0) Begin
88893>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
88896>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
88897>>>                If (bIgnore = False) Begin
88899>>>                    Get _UtilTableExists hTable to bExists
88900>>>                    If (bExists = False) Begin
88902>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
88903>>>                        If (bResponse = False) Begin
88905>>>                            Move False to bOK
88906>>>                        End
88906>>>>
88906>>>                        
88906>>>                    End
88906>>>>
88906>>>                End
88906>>>>
88906>>>            End
88906>>>>
88906>>>        Until (hTable = 0)                     
88908>>>        
88908>>>        Set Action_Text of ghoStatusPanel to "" 
88909>>>        Function_Return bOK
88910>>>    End_Function
88911>>>    
88911>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
88911>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
88911>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
88911>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
88911>>>    //
88911>>>    // The root of the problem is the following:
88911>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
88911>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
88911>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
88911>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
88911>>>    // an SQL error will be thrown;
88911>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
88911>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
88913>>>        Boolean bOK bIsAlias bIsSQL
88913>>>        Integer iCount iSize iDateSize
88913>>>        Handle hTable
88913>>>        String sLogicalName
88913>>>        Integer[] aTablesToCheck aDateFields
88915>>>
88915>>>        Get _AllTablesDateCorrections to aTablesToCheck
88916>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
88917>>>        Set pbVisible    of ghoProgressBarOverall to True
88918>>>        Set piPosition   of ghoProgressBarOverall to 0
88919>>>        Set piMaximum    of ghoProgressBarOverall to iSize
88920>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
88921>>>
88921>>>        Move True to bOK
88922>>>        Decrement iSize
88923>>>        for iCount from 0 to iSize
88929>>>>
88929>>>            Move aTablesToCheck[iCount] to hTable
88930>>>            Set piPosition of ghoProgressBarOverall to iCount
88931>>>            Get UtilTableIsAlias hTable to bIsAlias
88932>>>            Get _UtilTableIsSql   hTable to bIsSQL
88933>>>
88933>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
88936>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
88937>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
88938>>>
88938>>>            If (bIsAlias = False and bIsSQL = False) Begin
88940>>>                Get UtilCheckForDateFields hTable to aDateFields
88941>>>                Move (SizeOfArray(aDateFields)) to iDateSize
88942>>>                If (iDateSize > 0) Begin
88944>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
88945>>>                    Close hTable
88946>>>                End
88946>>>>
88946>>>            End
88946>>>>
88946>>>        Loop
88947>>>>
88947>>>
88947>>>        Close DF_ALL
88948>>>        Function_Return bOK
88949>>>    End_Function
88950>>>
88950>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
88950>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
88952>>>        Integer[] aDateFields aDateFieldsEmpty
88954>>>        Integer iSize iCount iType
88954>>>        Boolean bOpen bOK
88954>>>        
88954>>>        Get _UtilTableExists hTable to bOK
88955>>>        If (bOK = False) Begin
88957>>>            Set Private.phCurrentTable to hTable
88958>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
88959>>>>
88959>>>            Function_Return aDateFieldsEmpty
88960>>>        End
88960>>>>
88960>>>        Set Private.phCurrentTable to hTable
88961>>>        Set Private.piCurrentField to 0
88962>>>
88962>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88962>>>        Open hTable
88964>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
88967>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
88967>>>        If (bOpen = False) Begin
88969>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
88969>>>            Function_Return aDateFieldsEmpty
88970>>>        End
88970>>>>
88970>>>
88970>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
88973>>>        For iCount from 1 to iSize
88979>>>>
88979>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
88982>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
88984>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
88985>>>            End
88985>>>>
88985>>>        Loop
88986>>>>
88986>>>
88986>>>        Function_Return aDateFields
88987>>>    End_Function
88988>>>
88988>>>    // Loops through all records for the passed hTable, and checks that all Date values
88988>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
88988>>>    // and the record is saved
88988>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
88988>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
88988>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
88990>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
88990>>>        String sDriverID sDateMin
88990>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
88990>>>        Date dDate dDateMin
88990>>>        Integer[] iaChangeField
88991>>>
88991>>>        Get _UtilTableExists hTable to bOK
88992>>>        // I believe we should just skip files not found and not report an error.
88992>>>        // This is because a filelist may have entries but no files/tables on disk, but
88992>>>        // this may be adjusted by other calls to DUF in a later update package. 
88992>>>        // Especially considering that this call is probably done at the very
88992>>>        // beginning of a DUF update.
88992>>>        If (bOK = False) Begin
88994>>>//            Set Private.phCurrentTable to hTable
88994>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
88994>>>//            Function_Return False
88994>>>            Function_Return True
88995>>>        End
88995>>>>
88995>>>
88995>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
88995>>>        // date format to "USA" = "MM/DD/YYYY"
88995>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
88998>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
89001>>>
89001>>>//        Send SetAllIndexesToBatch hTable True
89001>>>        Open hTable
89003>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89006>>>        If (bOpened = False) Begin
89008>>>            Function_Return False
89009>>>        End
89009>>>>
89009>>>        
89009>>>        Set Private.phCurrentTable to hTable
89010>>>        Move 0 to iRecord
89011>>>        Move (SizeOfArray(aDateFields)) to iSize
89012>>>        Decrement iSize
89013>>>
89013>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89016>>>        Get DriverIndex sDriverID to iDriverIndex
89017>>>        If (iDriverIndex <> 0) Begin
89019>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
89022>>>            If (sDateMin = "") Begin
89024>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
89025>>>            End
89025>>>>
89025>>>            Else Begin
89026>>>                If (IsDate(sDateMin)) Begin
89028>>>                    Move sDateMin to dDateMin
89029>>>                End
89029>>>>
89029>>>                Else Begin
89030>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
89031>>>                End
89031>>>>
89031>>>            End
89031>>>>
89031>>>        End
89031>>>>
89031>>>        Else Begin
89032>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
89033>>>        End
89033>>>>
89033>>>
89033>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
89036>>>        Set piPosition   of ghoProgressBar to 0
89037>>>        Set piAdvanceBy  of ghoProgressBar to 100
89038>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
89039>>>        Move False to Err
89040>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89041>>>
89041>>>        Clear hTable
89042>>>        Repeat
89042>>>>
89042>>>            Vfind hTable 0 GT
89044>>>            Move Found to bFound
89045>>>            If (bFound = True) Begin
89047>>>                Move False to bSaveChanges
89048>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
89049>>>                Move (SizeOfArray(aDateFields)) to iSize
89050>>>                Decrement iSize
89051>>>                For iCount from 0 to iSize
89057>>>>
89057>>>                    Move aDateFields[iCount] to iField
89058>>>                    Get_Field_Value hTable iField to dDate
89061>>>                    If (bFixZeroDates = True) Begin
89063>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
89064>>>                    End
89064>>>>
89064>>>                    Else Begin
89065>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
89066>>>                    End
89066>>>>
89066>>>                    If (bChange = True) Begin
89068>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
89069>>>                    End
89069>>>>
89069>>>                Loop
89070>>>>
89070>>>
89070>>>                // Only change Date fields that needs to be changed.
89070>>>                If (SizeOfArray(iaChangeField)) Begin
89072>>>                    Reread hTable
89076>>>                        Move (SizeOfArray(iaChangeField)) to iSize
89077>>>                        Decrement iSize
89078>>>                        For iCount from 0 to iSize
89084>>>>
89084>>>                            Move iaChangeField[iCount] to iField
89085>>>                            Set Private.piCurrentField to iField
89086>>>                            Set_Field_Value hTable iField to dDateMin
89089>>>                        Loop
89090>>>>
89090>>>                        Move False to Err
89091>>>                        SaveRecord hTable
89092>>>                    Unlock
89093>>>>
89093>>>                End
89093>>>>
89093>>>
89093>>>                Increment iRecord
89094>>>                // Increment the StatusPanel counter and check the
89094>>>                // cancel status every 100 records rather than every
89094>>>                // record, it's way faster.
89094>>>                If (Mod(iRecord, 100) = 0) Begin
89096>>>                    Send DoAdvance of ghoProgressBar
89097>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
89098>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89099>>>                End
89099>>>>
89099>>>            End
89099>>>>
89099>>>        Until (bFound = False)
89101>>>
89101>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
89104>>>        If (bResetIndexesToOnLine = True) Begin
89106>>>            Send SetAllIndexesToBatch hTable False
89107>>>        End
89107>>>>
89107>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89108>>>
89108>>>        Function_Return (Err = False)
89109>>>    End_Function
89110>>>
89110>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89110>>>    // Note that it first removes any driver prefixes in the rootname.
89110>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
89112>>>        Boolean bIsSame
89112>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89112>>>
89112>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
89113>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
89114>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
89115>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
89116>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
89117>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
89118>>>
89118>>>        If (bCompareFilelistUppercase = True) Begin
89120>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
89121>>>        End
89121>>>>
89121>>>        Else Begin
89122>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
89123>>>        End
89123>>>>
89123>>>        If (bIsSame = False) Begin
89125>>>            Function_Return False
89126>>>        End
89126>>>>
89126>>>
89126>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
89127>>>        If (bIsSame = False) Begin
89129>>>            Function_Return False
89130>>>        End
89130>>>>
89130>>>
89130>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
89131>>>        If (bIsSame = False) Begin
89133>>>            Function_Return False
89134>>>        End
89134>>>>
89134>>>
89134>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
89135>>>        If (bIsSame = False) Begin
89137>>>            Function_Return False
89138>>>        End
89138>>>>
89138>>>
89138>>>        Function_Return bIsSame
89139>>>    End_Function
89140>>>
89140>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89142>>>        Handle hTableFrom hTableTo
89142>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89142>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
89142>>>        String sRootName sDriverIDFrom sDriverIDTo
89142>>>        tAPIColumnCompare[]   aAPIColumnCompare
89142>>>        tAPIColumnCompare[]   aAPIColumnCompare
89143>>>        tAPIIndexCompare[]    aAPIIndexCompare
89143>>>        tAPIIndexCompare[]    aAPIIndexCompare
89144>>>        tAPIRelationCompare[] aAPIRelationCompare
89144>>>        tAPIRelationCompare[] aAPIRelationCompare
89145>>>
89145>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
89146>>>        If (bIsSame = True) Begin
89148>>>            Function_Return True
89149>>>        End
89149>>>>
89149>>>
89149>>>        Move False to bFilelistError
89150>>>        Move True to bIsSame
89151>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
89152>>>        Get pbCompareIndexAscending to bCompareIndexAscending
89153>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
89154>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89155>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89156>>>
89156>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
89157>>>        Get _TableNameOnly sRootName             to sRootName
89158>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
89159>>>
89159>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
89159>>>        // bCodeGenerateMode = True = Code Generation mode.
89159>>>        If (bCodeGenerateMode = True) Begin
89161>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89161>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89163>>>                Function_Return False
89164>>>            End
89164>>>>
89164>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89165>>>            If (bIsSame = False) Begin
89167>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
89168>>>                Move True to bFilelistError
89169>>>                Function_Return False
89170>>>            End
89170>>>>
89170>>>        End
89170>>>>
89170>>>
89170>>>        If (bCodeGenerateMode = False) Begin
89172>>>            // Then we want to create this table
89172>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89174>>>                Function_Return False
89175>>>            End
89175>>>>
89175>>>
89175>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89176>>>            If (bIsSame = False) Begin
89178>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
89179>>>>
89179>>>                Move True to bFilelistError
89180>>>                Function_Return False
89181>>>            End
89181>>>>
89181>>>        End
89181>>>>
89181>>>
89181>>>        // Check columns:
89181>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89182>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
89183>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
89184>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89185>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
89186>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
89187>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
89188>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
89189>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
89190>>>        If (bIsSame = False) Begin
89192>>>            Function_Return False
89193>>>        End
89193>>>>
89193>>>
89193>>>        // ...then check indexes:
89193>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
89194>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
89195>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
89196>>>        If (bIsSame = False) Begin
89198>>>            Function_Return False
89199>>>        End
89199>>>>
89199>>>
89199>>>        // ...and finally relationships:
89199>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
89200>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
89201>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
89202>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
89203>>>
89203>>>        Function_Return (bIsSame = True)
89204>>>    End_Function
89205>>>
89205>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
89205>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89207>>>        Handle hTable
89207>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89207>>>        String sRootName sDriverIDFrom sDriverIDTo
89207>>>
89207>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
89209>>>            Move True to bFilelistError
89210>>>            Function_Return False
89211>>>        End
89211>>>>
89211>>>
89211>>>        Move APITableCompare.hTable to hTable
89212>>>        Move True  to bIsSame
89213>>>        Move False to bFilelistError
89214>>>
89214>>>        If (APITableCompare.bExistsFrom = True) Begin
89216>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
89217>>>        End
89217>>>>
89217>>>        Else Begin
89218>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
89219>>>        End
89219>>>>
89219>>>        Get _TableNameOnly sRootName                                   to sRootName
89220>>>
89220>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
89221>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
89222>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
89223>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
89224>>>
89224>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
89224>>>        // bCodeGenerateMode = True = Code Generation mode.
89224>>>        If (bCodeGenerateMode = True) Begin
89226>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89226>>>            If (APITableCompare.bExistsTo = False) Begin
89228>>>                Function_Return False
89229>>>            End
89229>>>>
89229>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
89230>>>            If (bIsSame = False) Begin
89232>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
89233>>>                Move True to bFilelistError
89234>>>                Function_Return False
89235>>>            End
89235>>>>
89235>>>        End
89235>>>>
89235>>>
89235>>>        If (bCodeGenerateMode = False) Begin
89237>>>            If (APITableCompare.bExistsTo = False) Begin
89239>>>                // Then we might want to create this table
89239>>>                Function_Return False
89240>>>            End
89240>>>>
89240>>>
89240>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
89241>>>            If (bIsSame = False) Begin
89243>>>                Function_Return False
89244>>>            End
89244>>>>
89244>>>
89244>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
89245>>>            If (bIsSame = False) Begin
89247>>>                Function_Return False
89248>>>            End
89248>>>>
89248>>>
89248>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
89249>>>            If (bIsSame = False) Begin
89251>>>                Function_Return False
89252>>>            End
89252>>>>
89252>>>
89252>>>            // Check table names et al.
89252>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
89253>>>            If (bIsSame = False) Begin
89255>>>                Function_Return False
89256>>>            End
89256>>>>
89256>>>        End
89256>>>>
89256>>>
89256>>>        // Check Columns:
89256>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
89257>>>        If (bIsSame = False) Begin
89259>>>            Function_Return False
89260>>>        End
89260>>>>
89260>>>
89260>>>        // ...then check Indexes:
89260>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
89261>>>        If (bIsSame = False) Begin
89263>>>            Function_Return False
89264>>>        End
89264>>>>
89264>>>
89264>>>        // ...and finally Relationships:
89264>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
89265>>>
89265>>>        Function_Return (bIsSame = True)
89266>>>    End_Function
89267>>>
89267>>>    // To fill a complete Table array structure (tAPITable[]) with data.
89267>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
89267>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
89267>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
89267>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
89269>>>        tAPITableNameInfo ApiTableNameInfo
89269>>>        tAPITableNameInfo ApiTableNameInfo
89269>>>        tAPITable[]     aApiTables aApiTablesEmpty
89269>>>        tAPITable[]     aApiTables aApiTablesEmpty
89271>>>        tAPIColumn[]    aApiColumns
89271>>>        tAPIColumn[]    aApiColumns
89272>>>        tAPIIndex[]     aApiIndexes
89272>>>        tAPIIndex[]     aApiIndexes
89273>>>        tAPIRelation[]  aApiRelations
89273>>>        tAPIRelation[]  aApiRelations
89274>>>        Handle hTable
89274>>>        Integer iCount
89274>>>        Boolean bUserCancel bOK
89274>>>        String sLogicalName sMessageText
89274>>>
89274>>>        Get AutoConnectionIDLogin to bOK
89275>>>        Move 0 to hTable
89276>>>        If (bFromTables = True) Begin
89278>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
89279>>>            If (bCompareUtil = True) Begin
89281>>>                Move (sMessageText * "(1 of 3)") to sMessageText
89282>>>            End
89282>>>>
89282>>>        End
89282>>>>
89282>>>        Else Begin
89283>>>            Move "Reading 'TO' Table Structure:" to sMessageText
89284>>>            If (bCompareUtil = True) Begin
89286>>>                Move (sMessageText * "(2 of 3)") to sMessageText
89287>>>            End
89287>>>>
89287>>>        End
89287>>>>
89287>>>        Set Message_Text of ghoStatusPanel to sMessageText
89288>>>
89288>>>        Get UtilFilelistNoOfTables to iCount
89289>>>        Set piMaximum of ghoProgressBar to iCount
89290>>>        Move 0 to iCount
89291>>>
89291>>>        Repeat
89291>>>>
89291>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89294>>>            If (hTable > 0 and hTable <> 50) Begin
89296>>>
89296>>>                Open hTable
89298>>>                // ToDo: Needs to be revised
89298>>>                // For some reason tables may be reported as "unopened", while in
89298>>>                // fact the open was successful (!)
89298>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89298>>>//                If (bIsOpen = False) Begin
89298>>>//                    Move True to aApiTablesEmpty[0].bError
89298>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
89298>>>//                    Function_Return aApiTablesEmpty
89298>>>//                End
89298>>>
89298>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89301>>>                Set piPosition of ghoProgressBar to iCount
89302>>>                Send DoAdvance of ghoProgressBarOverall
89303>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
89304>>>
89304>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
89305>>>//                Close hTable DF_PERMANENT
89305>>>                Increment iCount
89306>>>            End
89306>>>>
89306>>>
89306>>>            If (bStatusPanel = True) Begin
89308>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
89309>>>                If (bUserCancel = True) Begin
89311>>>                    Move True to aApiTablesEmpty[0].bCancel
89312>>>                    Function_Return aApiTablesEmpty
89313>>>                End
89313>>>>
89313>>>            End
89313>>>>
89313>>>
89313>>>        Until (hTable = 0)
89315>>>
89315>>>        Function_Return aApiTables
89316>>>    End_Function
89317>>>
89317>>>    // Returns a 'single' table APITable struct.
89317>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
89319>>>        tAPITableNameInfo ApiTableNameInfo
89319>>>        tAPITableNameInfo ApiTableNameInfo
89319>>>        tAPITable         ApiTable ApiTableEmpty
89319>>>        tAPITable         ApiTable ApiTableEmpty
89319>>>        tAPIColumn[]     aApiColumns
89319>>>        tAPIColumn[]     aApiColumns
89320>>>        tAPIIndex[]      aApiIndexes
89320>>>        tAPIIndex[]      aApiIndexes
89321>>>        tAPIRelation[]   aApiRelations
89321>>>        tAPIRelation[]   aApiRelations
89322>>>        Boolean bIsOpen
89322>>>
89322>>>        Open hTable
89324>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89327>>>        If (bIsOpen = False) Begin
89329>>>            Move True to ApiTableEmpty.bError
89330>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89331>>>            Function_Return ApiTableEmpty
89332>>>        End
89332>>>>
89332>>>
89332>>>        // Fill Table Name Info
89332>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
89333>>>
89333>>>        // Fill columns
89333>>>        Get UtilColumnsStructFill hTable to aApiColumns
89334>>>        If (SizeOfArray(aApiColumns)) Begin
89336>>>            If (aApiColumns[0].bCancel = True) Begin
89338>>>                Move True to ApiTableEmpty.bError
89339>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89340>>>                Function_Return ApiTableEmpty
89341>>>            End
89341>>>>
89341>>>        End
89341>>>>
89341>>>
89341>>>        // Fill indexes
89341>>>        Get UtilIndexesStructFill hTable to aApiIndexes
89342>>>        If (SizeOfArray(aApiIndexes)) Begin
89344>>>            If (aApiIndexes[0].bCancel = True) Begin
89346>>>                Move True to ApiTableEmpty.bError
89347>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89348>>>                Function_Return ApiTableEmpty
89349>>>            End
89349>>>>
89349>>>        End
89349>>>>
89349>>>
89349>>>        // Fill relationships
89349>>>        Get UtilRelationsStructFill hTable to aApiRelations
89350>>>        If (SizeOfArray(aApiRelations)) Begin
89352>>>            If (aApiRelations[0].bCancel = True) Begin
89354>>>                Move True to ApiTableEmpty.bError
89355>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89356>>>                Function_Return ApiTableEmpty
89357>>>            End
89357>>>>
89357>>>        End
89357>>>>
89357>>>
89357>>>        Move hTable             to ApiTable.hTable
89358>>>        Move bFromTables        to ApiTable.bFromTable
89359>>>        Move (not(bFromTables)) to ApiTable.bToTable
89360>>>
89360>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
89361>>>        Move aApiColumns        to ApiTable.aApiColumns
89362>>>        Move aApiIndexes        to ApiTable.aApiIndexes
89363>>>        Move aApiRelations      to ApiTable.aApiRelations
89364>>>
89364>>>        Function_Return ApiTable
89365>>>    End_Function
89366>>>
89366>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
89368>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89368>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89368>>>        Boolean bIsOpen
89368>>>
89368>>>        Open hTable
89370>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89373>>>        If (bIsOpen = False) Begin
89375>>>            Move True   to APITableNameInfoEmpty.bError
89376>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
89377>>>            Function_Return APITableNameInfoEmpty
89378>>>        End
89378>>>>
89378>>>
89378>>>        Move hTable                                  to APITableNameInfo.iTableNumber
89379>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
89382>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
89385>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
89388>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
89391>>>
89391>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
89392>>>        Get _UtilTableIsSql                    hTable to APITableNameInfo.bIsSQL
89393>>>
89393>>>        Function_Return APITableNameInfo
89394>>>    End_Function
89395>>>
89395>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
89397>>>        Integer iSize iCount iItem
89397>>>        tAPITableNameInfo ApiTableNameInfo
89397>>>        tAPITableNameInfo ApiTableNameInfo
89397>>>
89397>>>        Move -1 to iItem
89398>>>        Move (SizeOfArray(aTableStructure)) to iSize
89399>>>        Decrement iSize
89400>>>        for iCount from 0 to iSize
89406>>>>
89406>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89407>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
89409>>>                Move iCount to iItem
89410>>>                Move iSize  to iCount // We're done.
89411>>>            End
89411>>>>
89411>>>        Loop
89412>>>>
89412>>>
89412>>>        Function_Return iItem
89413>>>    End_Function
89414>>>
89414>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
89416>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
89419>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
89422>>>
89422>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
89425>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
89428>>>
89428>>>        Function_Return (EQ)
89429>>>    End_Function
89430>>>
89430>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
89432>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
89432>>>        Handle hTable
89432>>>        tAPITable[] aAPITableFromAndTo
89432>>>        tAPITable[] aAPITableFromAndTo
89433>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89433>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89433>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89433>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89433>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89433>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89434>>>        tAPIColumnCompare[]   aAPIColumnCompare
89434>>>        tAPIColumnCompare[]   aAPIColumnCompare
89435>>>        tAPIIndexCompare[]    aAPIIndexCompare
89435>>>        tAPIIndexCompare[]    aAPIIndexCompare
89436>>>        tAPIRelationCompare[] aAPIRelationCompare
89436>>>        tAPIRelationCompare[] aAPIRelationCompare
89437>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89437>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89437>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89437>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89440>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89440>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89443>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89443>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89446>>>
89446>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
89447>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
89448>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
89450>>>            Function_Return aAPITableCompare
89451>>>        End
89451>>>>
89451>>>
89451>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
89452>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
89453>>>
89453>>>        Move 0 to iItem
89454>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
89455>>>        Decrement iSize
89456>>>        for iCount from 0 to iSize
89462>>>>
89462>>>
89462>>>            Move iCount to iItemFrom
89463>>>            Move iCount to iItemTo
89464>>>            Move APITableEmpty to APITableFrom
89465>>>            Move APITableEmpty to APITableTo
89466>>>
89466>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
89468>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89469>>>            End
89469>>>>
89469>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
89471>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
89472>>>            End
89472>>>>
89472>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
89474>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89475>>>                Move (iCount + 1) to iItemTo
89476>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
89477>>>            End
89477>>>>
89477>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
89479>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
89480>>>                If (iItemTo <> -1) Begin
89482>>>                    Move aAPITableTo[iItemTo] to APITableTo
89483>>>                End
89483>>>>
89483>>>                Else Begin
89484>>>                    Move APITableEmpty to APITableTo
89485>>>                End
89485>>>>
89485>>>            End
89485>>>>
89485>>>
89485>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
89486>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
89487>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
89488>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
89489>>>
89489>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
89490>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
89491>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
89492>>>            Move APITableTo.aApiRelations   to aApiRelationTo
89493>>>
89493>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
89494>>>
89494>>>            If (hTable > 0) Begin
89496>>>
89496>>>                // Table info:
89496>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
89497>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
89498>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
89499>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
89500>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
89501>>>
89501>>>                // Column info:
89501>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
89502>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
89503>>>
89503>>>                // Index info:
89503>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
89504>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
89505>>>
89505>>>                // Relation info:
89505>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
89506>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
89507>>>
89507>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
89508>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
89509>>>                Move False                                                              to aAPITableCompare[iItem].bError
89510>>>                If (iItemTo > iItemFrom) Begin
89512>>>                    Increment iCount
89513>>>                End
89513>>>>
89513>>>                Increment iItem
89514>>>            End
89514>>>>
89514>>>
89514>>>        Loop
89515>>>>
89515>>>
89515>>>        Function_Return aAPITableCompare
89516>>>    End_Function
89517>>>
89517>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
89519>>>        Integer iSize iCount iItem
89519>>>        tAPITableNameInfo ApiTableNameInfo
89519>>>        tAPITableNameInfo ApiTableNameInfo
89519>>>
89519>>>        Move -1 to iItem
89520>>>        Move (SizeOfArray(aTableStructure)) to iSize
89521>>>        Decrement iSize
89522>>>        For iCount from 0 to iSize
89528>>>>
89528>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89529>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
89531>>>                Move iCount to iItem
89532>>>                Move iSize  to iCount // We're done.
89533>>>            End
89533>>>>
89533>>>        Loop
89534>>>>
89534>>>
89534>>>        Function_Return iItem
89535>>>    End_Function
89536>>>
89536>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
89538>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89538>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89538>>>
89538>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
89540>>>            Function_Return APITableNameInfoCompare
89541>>>        End
89541>>>>
89541>>>
89541>>>        // FROM database info:
89541>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
89543>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
89544>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
89545>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
89546>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
89547>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
89548>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
89549>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
89550>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
89551>>>        End
89551>>>>
89551>>>
89551>>>        // TO database info:
89551>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
89553>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
89554>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
89555>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
89556>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
89557>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
89558>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
89559>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
89560>>>            Move True                               to APITableNameInfoCompare.bExistsTo
89561>>>        End
89561>>>>
89561>>>
89561>>>        Function_Return APITableNameInfoCompare
89562>>>    End_Function
89563>>>
89563>>>    // Note:
89563>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
89563>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
89563>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
89563>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
89563>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
89563>>>    Function UtilTableHandleToString Handle hTable Returns String
89565>>>        String sTableName
89565>>>        Boolean bOpen bExists bOK
89565>>>
89565>>>        Get _UtilTableNumberIsInUse hTable to bExists
89566>>>        If (bExists = False) Begin
89568>>>            Function_Return ""
89569>>>        End
89569>>>>
89569>>>
89569>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89570>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89573>>>        If (bOpen = False) Begin
89575>>>            Get AutoConnectionIDLogin to bOK
89576>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89577>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
89578>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89579>>>            Open hTable
89581>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89582>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
89583>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89584>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
89587>>>        End
89587>>>>
89587>>>        If (bOpen = True) Begin
89589>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89590>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
89593>>>            // If blank it is an embedded table:
89593>>>            If (sTableName = "") Begin
89595>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89598>>>                Move 0 to LastErr
89599>>>                Move False to Err
89600>>>            End
89600>>>>
89600>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89601>>>        End
89601>>>>
89601>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89602>>>        Move 0 to LastErr
89603>>>
89603>>>        Function_Return sTableName
89604>>>    End_Function
89605>>>
89605>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
89605>>>    // Returns 0 if unsuccessful.
89605>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
89605>>>    Function UtilTableNameToHandle String sTableName Returns Integer
89607>>>        String sValue sPrefixTableName sDriverID
89607>>>        Handle hTable hRetval
89607>>>
89607>>>        Get psDriverID to sDriverID
89608>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
89610>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
89611>>>        End
89611>>>>
89611>>>        Move 0 to hTable
89612>>>        Move 0 to hRetval
89613>>>        Repeat
89613>>>>
89613>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89616>>>            If (hTable <> 0) Begin
89618>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
89621>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
89623>>>                    Move hTable to hRetval
89624>>>                    Move 0 to hTable
89625>>>                End
89625>>>>
89625>>>            End
89625>>>>
89625>>>        Until (hTable = 0)
89627>>>
89627>>>        Function_Return hRetval
89628>>>    End_Function
89629>>>
89629>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
89629>>>    // _after_ all tables have successfully been converted to SQL (.int files)
89629>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
89631>>>        Boolean bOK bExists
89631>>>        String sDataPath sBackupFolder
89631>>>
89631>>>        Close DF_ALL DF_PERMANENT
89632>>>        Send DoAdvance of ghoProgressBar
89633>>>
89633>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
89634>>>        Move CS_DUFBackupDataFolder to sBackupFolder
89635>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
89636>>>        Get vFolderFormat sDataPath to sDataPath
89637>>>
89637>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
89638>>>        If (bExists = False) Begin
89640>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
89641>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
89642>>>            If (bExists = False) Begin
89644>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
89645>>>>
89645>>>                Function_Return False
89646>>>            End
89646>>>>
89646>>>        End
89646>>>>
89646>>>
89646>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
89647>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
89648>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
89649>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
89650>>>        // We need to wait for Windows before we can copy files back
89650>>>        Sleep 2  
89651>>>        
89651>>>        //...except for these files that needs to be copied back to the Data folder:
89651>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
89652>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
89653>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
89654>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
89655>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
89656>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
89657>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
89657>>>        
89657>>>
89657>>>        Set Message_Text of ghoStatusPanel to ""
89658>>>        Function_Return True
89659>>>    End_Function
89660>>>    
89660>>>    Function UtilTableRepairAndReindexALL Returns Boolean
89662>>>        Boolean bOK bRetval
89662>>>        Handle hTable
89662>>>        Integer iSize iCount
89662>>>        
89662>>>        Move True to bOK
89663>>>        Get UtilFilelistNoOfTables to iSize
89664>>>        Set pbVisible    of ghoProgressBarOverall to True
89665>>>        Set piPosition   of ghoProgressBarOverall to 0
89666>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89667>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89668>>>
89668>>>        Repeat
89668>>>>
89668>>>            Set piPosition of ghoProgressBarOverall to iCount
89669>>>            Increment iCount
89670>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89673>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
89675>>>                Get UtilTableRepairAndReindex hTable to bRetval
89676>>>                If (bRetval = False) Begin
89678>>>                    Move False to bOK
89679>>>                End
89679>>>>
89679>>>            End
89679>>>>
89679>>>        Until (hTable = 0)
89681>>>                
89681>>>        Function_Return bOK
89682>>>    End_Function           
89683>>>    
89683>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
89683>>>    // After the header has been repaired - also makes a re-index.  
89683>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
89683>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
89685>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
89685>>>        Integer iRetval
89685>>>        String sRootName sFileName sDataPath
89685>>>        
89685>>>        Move False to Err
89686>>>        Move 0 to LastErr 
89687>>>        Move True to bOK
89688>>>        
89688>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
89689>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
89691>>>            Function_Return True
89692>>>        End
89692>>>>
89692>>>        Get UtilTableIsAlias hTable to bIsAlias 
89693>>>        If (bIsAlias = True) Begin
89695>>>            Function_Return True
89696>>>        End
89696>>>>
89696>>>        
89696>>>        // Check for bad file and remove if exists
89696>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89699>>>        Set private.phCurrentTable to hTable  
89700>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
89701>>>        
89701>>>        // This is important! Else it can happen that the table can't be opened,
89701>>>        // with a "4077 - File in use" error.
89701>>>        Close DF_ALL DF_PERMANENT    
89702>>>        Open hTable
89704>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89707>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89708>>>        If (bIsOpen = False) Begin
89710>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
89711>>>>
89711>>>            Function_Return False        
89712>>>        End
89712>>>>
89712>>>
89712>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
89713>>>        If (bBadExists = True) Begin
89715>>>            Get_File_Path (sRootName + ".BAD") to sFileName
89716>>>            Get vDeleteFile sFileName to iRetval
89717>>>        End
89717>>>>
89717>>>        
89717>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
89718>>>        
89718>>>        Move False to Err
89719>>>        // **** Repair and reindex the table. ****
89719>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
89720>>>
89720>>>        // Check for bad file: if it exists, something went wrong
89720>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
89721>>>        Get vFolderFormat sDataPath to sDataPath
89722>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
89723>>>        If (bBadExists = True) Begin
89725>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
89726>>>>
89726>>>            Move False to bOK
89727>>>        End
89727>>>>
89727>>>        Close hTable
89728>>>
89728>>>        Function_Return bOK
89729>>>    End_Function
89730>>>
89730>>>    // Repair and reindex the named DataFlex data-table.
89730>>>    // No checks are done if the passed table name is an embedded or SQL,
89730>>>    // so use with care (make sure you only pass embedded table names).
89730>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
89732>>>        String sMode
89732>>>        Integer iVoid
89732>>>
89732>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
89733>>>        Move "0" to sMode   // 0=Reindex after repair!    
89734>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
89735>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
89740>>>        Set Message_Text of ghoStatusPanel to ""
89741>>>        Function_Return (iVoid = 0)
89742>>>    End_Function
89743>>>
89743>>>    // Returns _two_ arrays.
89743>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
89743>>>    // Also returns all files that are Alias files in a second array.
89743>>>    // IMPORTANT: All master & alias files _must_ have been included into
89743>>>    //            the DoSetAllMasterAndAlias message.
89743>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
89745>>>        Integer[] iaFileIsAlias
89746>>>        Integer hTable iFileAlias iSize
89746>>>        Boolean bOpen
89746>>>
89746>>>        Move 0 to hTable
89747>>>        Repeat
89747>>>>
89747>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89750>>>            If (hTable <> 0) Begin
89752>>>                Open hTable
89754>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
89757>>>                If (bOpen = True) Begin
89759>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
89762>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
89764>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
89765>>>                        Move hTable to iaFileIsMaster[iSize]
89766>>>                    End
89766>>>>
89766>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
89769>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
89770>>>                        Move hTable to iaFileIsAlias[iSize]
89771>>>                    End
89771>>>>
89771>>>                End
89771>>>>
89771>>>            End
89771>>>>
89771>>>        Until (hTable = 0)
89773>>>
89773>>>        Function_Return iaFileIsAlias
89774>>>    End_Function  
89775>>>    
89775>>>    // Is a repair of the data-header necessary? (Embedded tables only)
89775>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
89777>>>        String sMode
89777>>>        Integer iRepairNeeded bIsOpen
89777>>>
89777>>>        Move "0" to sMode
89778>>>        Set private.phCurrentTable to hTable 
89779>>>        Close hTable
89780>>>        Open hTable
89782>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89785>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
89790>>>
89790>>>        Function_Return iRepairNeeded
89791>>>    End_Function
89792>>>
89792>>>    // Helper function
89792>>>    // Takes two params:
89792>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
89792>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
89792>>>    // Returns:
89792>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
89792>>>    //  DF_FILE_IS_MASTER if master
89792>>>    //  DF_FILE_IS_ALIAS if alias
89792>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
89794>>>        Integer i iSize
89794>>>
89794>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
89795>>>        Decrement iSize
89796>>>        for i from 0 to iSize
89802>>>>
89802>>>            If (hTable = iaFileIsMaster[i]) Begin
89804>>>                Function_Return DF_FILE_IS_MASTER
89805>>>            End
89805>>>>
89805>>>        Loop
89806>>>>
89806>>>
89806>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
89807>>>        Decrement iSize
89808>>>        for i from 0 to iSize
89814>>>>
89814>>>            If (hTable = iaFileIsAlias[i]) Begin
89816>>>                Function_Return DF_FILE_IS_ALIAS
89817>>>            End
89817>>>>
89817>>>        Loop
89818>>>>
89818>>>
89818>>>        Function_Return DF_FILE_ALIAS_DEFAULT
89819>>>    End_Function
89820>>>
89820>>>    // Determine the available indexes of a table.
89820>>>    //
89820>>>    // Arguments:
89820>>>    //   Handle hTable - The number of the table
89820>>>    //
89820>>>    // Returns:
89820>>>    //   String - A string to be used with the sort command
89820>>>    //   to re-index all indexes of a table.
89820>>>    Function UtilTableIndexString Handle hTable Returns String
89822>>>        String  sSortString
89822>>>        Integer iLastIndex iNumSegments iCount
89822>>>
89822>>>        Move "" to sSortString
89823>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
89826>>>
89826>>>        for iCount from 1 to iLastIndex
89832>>>>
89832>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
89835>>>            If iNumSegments Begin
89837>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
89840>>>                Move (Append(sSortString, iCount)) to sSortString
89841>>>            End
89841>>>>
89841>>>        Loop
89842>>>>
89842>>>
89842>>>        Function_Return sSortString
89843>>>    End_Function
89844>>>
89844>>>    
89844>>>    // * Dummy function for the Studio's Code Explorer *
89844>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
89846>>>        Function_Return False
89847>>>    End_Function
89848>>>
89848>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
89848>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
89850>>>        Boolean bIsSame
89850>>>        Integer iCount iColumns iColumn
89850>>>
89850>>>        Move True to bIsSame
89851>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
89852>>>        Set piMaximum of ghoProgressBar  to iColumns
89853>>>        Decrement iColumns
89854>>>
89854>>>        for iCount from 0 to iColumns
89860>>>>
89860>>>            Set piPosition of ghoProgressBar to iCount
89861>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
89862>>>            If (bIsSame = False) Begin
89864>>>                Function_Return False
89865>>>            End
89865>>>>
89865>>>        Loop
89866>>>>
89866>>>
89866>>>        Function_Return (bIsSame = True)
89867>>>    End_Function
89868>>>
89868>>>    // Compares a single column (For 'FROM' & 'TO' tables)
89868>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
89870>>>        Integer iFromType iToType iDbType
89870>>>        tColumnType ColumnType
89870>>>        tColumnType ColumnType
89870>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
89870>>>
89870>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
89872>>>            Function_Return False
89873>>>        End
89873>>>>
89873>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
89875>>>            Function_Return False
89876>>>        End
89876>>>>
89876>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
89878>>>            Function_Return False
89879>>>        End                                                                
89879>>>>
89879>>>
89879>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
89881>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
89883>>>                Function_Return False
89884>>>            End
89884>>>>
89884>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
89886>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
89888>>>                    End
89888>>>>
89888>>>                Else Begin
89889>>>                    Function_Return False
89890>>>                End
89890>>>>
89890>>>            End
89890>>>>
89890>>>        End
89890>>>>
89890>>>
89890>>>        Get piDbType                       to iDbType
89891>>>        Move APIColumnCompare.iTypeFrom    to iFromType
89892>>>        Move APIColumnCompare.iTypeTo      to iToType
89893>>>
89893>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
89893>>>        // data types between Embedded and SQL.
89893>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
89895>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
89896>>>        End
89896>>>>
89896>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
89898>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
89899>>>        End
89899>>>>
89899>>>
89899>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
89900>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
89901>>>
89901>>>        // Make Date and DateTime comparison?
89901>>>        If (bCompareDate_DataTime = True) Begin
89903>>>            If (iFromType <> iToType) Begin
89905>>>                Function_Return False
89906>>>            End
89906>>>>
89906>>>        End
89906>>>>
89906>>>
89906>>>        // This is when not checking for Date/DateTime differences but all other other field types...
89906>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
89908>>>            If (iFromType <> iToType) Begin
89910>>>                Function_Return False
89911>>>            End
89911>>>>
89911>>>        End
89911>>>>
89911>>>
89911>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
89911>>>        If (bIsDateTypeFrom = False) Begin
89913>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
89915>>>                Function_Return False
89916>>>            End
89916>>>>
89916>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
89918>>>                Function_Return False
89919>>>            End
89919>>>>
89919>>>        End
89919>>>>
89919>>>
89919>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
89921>>>            Function_Return False
89922>>>        End
89922>>>>
89922>>>
89922>>>        Function_Return True
89923>>>    End_Function
89924>>>
89924>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
89926>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
89926>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
89926>>>        tAPIColumn[] APIColumns APIColumnsEmpty
89926>>>        tAPIColumn[] APIColumns APIColumnsEmpty
89928>>>        String sDriverID sRootName sLogicalName
89928>>>
89928>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89929>>>        Get piDbType to iDbType
89930>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89933>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89936>>>
89936>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89939>>>        If (bIsOpen = False) Begin
89941>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89942>>>            Open hTable
89944>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89945>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89948>>>            If (bIsOpen = False) Begin
89950>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89951>>>                Move True to APIColumnsEmpty[0].bError
89952>>>                Function_Return APIColumnsEmpty
89953>>>            End
89953>>>>
89953>>>        End
89953>>>>
89953>>>
89953>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89956>>>        Get IsSQLDriver    sDriverID to bSqlDriver
89957>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
89958>>>
89958>>>        Get _UtilTableIsSqlByRootName sRootName to bIsSqlTable
89959>>>        If (bIsSqlTable = True) Begin
89961>>>            Get _UtilTableExists hTable to bExists
89962>>>            If (bExists = False) Begin
89964>>>                Move True to APIColumnsEmpty[0].bError
89965>>>                Function_Return APIColumnsEmpty
89966>>>            End
89966>>>>
89966>>>        End
89966>>>>
89966>>>
89966>>>        Move 0 to iCount
89967>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
89970>>>        Set piMaximum of ghoProgressBar to iNumColumns
89971>>>
89971>>>        for iColumn from 1 to iNumColumns
89977>>>>
89977>>>            Move 0 to iOptions
89978>>>            Move False to bIdentityKey
89979>>>            Move False to Err
89980>>>            Move 0     to LastErr
89981>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
89982>>>            Set piPosition of ghoProgressBar to iColumn
89983>>>            If (bDawSqlDriver = True) Begin
89985>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89986>>>                If (bIsSqlTable = True) Begin
89988>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
89991>>>                    Move iType                                                to APIColumns[iCount].iType
89992>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
89995>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
89998>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
90001>>>                End
90001>>>>
90001>>>                Else Begin
90002>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
90005>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90006>>>                End
90006>>>>
90006>>>
90006>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90006>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
90009>>>                Move (iCheckFieldNumber >= 0) to bExists
90010>>>                If (bExists = False) Begin
90012>>>                    Move 0 to APIColumns[iCount].iType
90013>>>                End
90013>>>>
90013>>>                If (bExists = True) Begin
90015>>>                        Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90018>>>                End
90018>>>>
90018>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90019>>>                If (bIdentityKey = True) Begin
90021>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
90022>>>                End
90022>>>>
90022>>>            End
90022>>>>
90022>>>            Else Begin
90023>>>                Move False to Err
90024>>>                Move 0     to LastErr
90025>>>                If (bIsSqlTable = True) Begin
90027>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
90030>>>                End
90030>>>>
90030>>>                Else Begin
90031>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
90034>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90035>>>                End
90035>>>>
90035>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90035>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
90036>>>                If (bExists = False) Begin
90038>>>                    Move 0 to APIColumns[iCount].iType
90039>>>                End
90039>>>>
90039>>>            End
90039>>>>
90039>>>
90039>>>            If (bExists = True) Begin
90041>>>                Move iColumn to APIColumns[iCount].iFieldNumber
90042>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
90045>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
90045>>>//                If (bIsSqlTable = True) Begin
90045>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
90045>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90045>>>//                End
90045>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
90048>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90051>>>
90051>>>                // If the length was zero we might have an Overlap(!) field.
90051>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
90051>>>                If (APIColumns[iCount].iLength = 0) Begin
90053>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
90056>>>                    If (iType = DF_OVERLAP) Begin
90058>>>                        Move 0 to APIColumns[iCount].iFieldNumber
90059>>>                        Move 0 to APIColumns[iCount].iLength
90060>>>                        Move 0 to APIColumns[iCount].iOptions
90061>>>                        Move 0 to APIColumns[iCount].iPrecision
90062>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
90063>>>                        Move "" to APIColumns[iCount].sFieldName
90064>>>                        Decrement iCount
90065>>>                    End
90065>>>>
90065>>>                End
90065>>>>
90065>>>            End
90065>>>>
90065>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90066>>>            If (bUserCancel = True) Begin
90068>>>                Move True to APIColumnsEmpty[0].bCancel
90069>>>                Function_Return APIColumnsEmpty
90070>>>            End
90070>>>>
90070>>>            Increment iCount
90071>>>        Loop
90072>>>>
90072>>>
90072>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90073>>>        Function_Return APIColumns
90074>>>    End_Function
90075>>>
90075>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90075>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90075>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90075>>>    // have "holes" in the series of index numbers.
90075>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
90077>>>        tAPIColumnCompare[] aAPIColumnCompare
90077>>>        tAPIColumnCompare[] aAPIColumnCompare
90078>>>        tAPIColumnCompare   APIColumnCompare
90078>>>        tAPIColumnCompare   APIColumnCompare
90078>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90078>>>
90078>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
90079>>>        Decrement iSizeFrom
90080>>>        for iCount from 0 to iSizeFrom
90086>>>>
90086>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
90087>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
90088>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
90089>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
90090>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
90091>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
90092>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
90093>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
90094>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
90095>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
90096>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
90097>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
90098>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
90099>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
90100>>>        Loop
90101>>>>
90101>>>
90101>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
90102>>>        Decrement iSizeTo
90103>>>        for iCount from 0 to iSizeTo
90109>>>>
90109>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
90110>>>            // Search if the field number already exists in the array; else add it.
90110>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
90111>>>            If (iItem = -1) Begin
90113>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
90114>>>            End
90114>>>>
90114>>>
90114>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
90115>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
90116>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
90117>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
90118>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
90119>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
90120>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
90121>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
90122>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
90123>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
90124>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
90125>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
90126>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
90127>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
90128>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
90129>>>        Loop
90130>>>>
90130>>>
90130>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
90131>>>
90131>>>        Function_Return aAPIColumnCompare
90132>>>    End_Function
90133>>>
90133>>>    // Checks if a field name exists in a table definition
90133>>>    // Returns True if it does
90133>>>    // Sample:
90133>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90133>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90135>>>        Integer iNumColumns iColumn
90135>>>        String sColumn
90135>>>        Boolean bExists bOK bOpen
90135>>>
90135>>>        Get AutoConnectionIDLogin to bOK
90136>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90137>>>        Open hTable
90139>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90140>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90143>>>        If (bOpen = False) Begin
90145>>>            Function_Return False
90146>>>        End
90146>>>>
90146>>>
90146>>>        Move False to bExists
90147>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90150>>>        for iColumn from 1 to iNumColumns
90156>>>>
90156>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90159>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90161>>>                Move iNumColumns to iColumn
90162>>>                Move True to bExists
90163>>>            End
90163>>>>
90163>>>        Loop
90164>>>>
90164>>>        Close hTable
90165>>>
90165>>>        Function_Return bExists
90166>>>    End_Function
90167>>>
90167>>>    // Returns the field/column number for the passed FieldName as an integer.
90167>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
90169>>>        Integer iNumColumns iColumn iRetval
90169>>>        String sColumn
90169>>>        Boolean bOK bOpen
90169>>>
90169>>>        Get AutoConnectionIDLogin to bOK
90170>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90171>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90172>>>        Open hTable
90174>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90175>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90178>>>        If (bOpen = False) Begin
90180>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90181>>>            Function_Return False
90182>>>        End
90182>>>>
90182>>>
90182>>>        Move 0 to iColumn
90183>>>        Move 0 to iRetval
90184>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90187>>>        for iColumn from 1 to iNumColumns
90193>>>>
90193>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90196>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90198>>>                Move iColumn to iRetval
90199>>>                Move iNumColumns to iColumn
90200>>>            End
90200>>>>
90200>>>        Loop
90201>>>>
90201>>>        Close hTable
90202>>>
90202>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90203>>>        Function_Return iRetval
90204>>>    End_Function
90205>>>
90205>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
90205>>>    // The reciprocal function is UtilColumnTypeToInteger.
90205>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
90207>>>        tColumnType RetvalType
90207>>>        tColumnType RetvalType
90207>>>
90207>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
90208>>>        Function_Return RetvalType.iSQLType
90209>>>    End_Function
90210>>>
90210>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
90210>>>    // The reciprocal function is UtilColumnTypeToString.
90210>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
90212>>>        tColumnType RetvalType
90212>>>        tColumnType RetvalType
90212>>>
90212>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90213>>>        Function_Return RetvalType.sSQLType
90214>>>    End_Function
90215>>>
90215>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
90217>>>        tColumnType RetvalType
90217>>>        tColumnType RetvalType
90217>>>
90217>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90218>>>        Function_Return RetvalType.sPrecision
90219>>>    End_Function
90220>>>
90220>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
90222>>>        tColumnType RetvalType
90222>>>        tColumnType RetvalType
90222>>>
90222>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90223>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
90223>>>        // if the column type length is _not_ fixed.
90223>>>        Function_Return (RetvalType.bCanEditSize = False)
90224>>>    End_Function
90225>>>
90225>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
90227>>>        tColumnType RetvalType
90227>>>        tColumnType RetvalType
90227>>>        String sValue
90227>>>        Integer iRetval iPos
90227>>>
90227>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90228>>>        Move RetvalType.sPrecision to sValue
90229>>>        Move (Pos(".", sValue)) to iPos
90230>>>        If (iPos <> 0) Begin
90232>>>            Move (Left(sValue, (iPos -1))) to iRetval
90233>>>        End
90233>>>>
90233>>>        Else Begin
90234>>>            Move sValue to iRetval
90235>>>        End
90235>>>>
90235>>>        Function_Return iRetval
90236>>>    End_Function
90237>>>
90237>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
90239>>>        tColumnType RetvalType
90239>>>        tColumnType RetvalType
90239>>>        String sValue
90239>>>        Integer iRetval iPos
90239>>>
90239>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90240>>>        Move RetvalType.sPrecision to sValue
90241>>>        Move (Pos(".", sValue)) to iPos
90242>>>        If (iPos = 0) Begin
90244>>>            Function_Return 0
90245>>>        End
90245>>>>
90245>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
90246>>>
90246>>>        Function_Return iRetval
90247>>>    End_Function
90248>>>
90248>>>    // * Dummy function for the Studio's Code Explorer *
90248>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
90250>>>        Function_Return False
90251>>>    End_Function
90252>>>
90252>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
90252>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90254>>>        Boolean bIsSame
90254>>>        Integer iCount iSize
90254>>>
90254>>>        Move True to bIsSame
90255>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
90256>>>        Decrement iSize
90257>>>        For iCount from 0 to iSize
90263>>>>
90263>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90264>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90265>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90266>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90267>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90268>>>            If (bIsSame = False) Begin
90270>>>                Function_Return False
90271>>>            End
90271>>>>
90271>>>        Loop
90272>>>>
90272>>>
90272>>>        Function_Return bIsSame
90273>>>    End_Function
90274>>>
90274>>>    // Compares a single index for a 'FROM' and a 'TO' table.
90274>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90276>>>        Boolean bIsSame
90276>>>        Integer iSegment
90276>>>
90276>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
90277>>>        If (bIsSame = False) Begin
90279>>>            Function_Return False
90280>>>        End
90280>>>>
90280>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
90281>>>        If (bIsSame = False) Begin
90283>>>            Function_Return False
90284>>>        End
90284>>>>
90284>>>
90284>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
90286>>>            // * We should probably not compare SQL index names?
90286>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
90286>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
90286>>>            //     Function_Return False
90286>>>            // End
90286>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
90287>>>            If (bIsSame = False) Begin
90289>>>                Function_Return False
90290>>>            End
90290>>>>
90290>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
90291>>>            If (bIsSame = False) Begin
90293>>>                Function_Return False
90294>>>            End
90294>>>>
90294>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
90295>>>            If (bIsSame = False) Begin
90297>>>                Function_Return False
90298>>>            End
90298>>>>
90298>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
90299>>>            If (bIsSame = False) Begin
90301>>>                Function_Return False
90302>>>            End
90302>>>>
90302>>>        End
90302>>>>
90302>>>
90302>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
90303>>>        Move (iSegment = -1) to bIsSame
90304>>>
90304>>>        Function_Return (bIsSame = True)
90305>>>    End_Function
90306>>>
90306>>>    // Compares each segment for the passed index.
90306>>>    // Returns -1 if same; else returns the index segment that differs.
90306>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90308>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
90308>>>        Boolean bIsSame
90308>>>
90308>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90309>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90310>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
90311>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
90312>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
90313>>>
90313>>>        Decrement iNumSegments
90314>>>        for iSegment from 0 to iNumSegments
90320>>>>
90320>>>            Move False to bIsSame
90321>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
90323>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90324>>>            End
90324>>>>
90324>>>            If (bIsSame = False) Begin
90326>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90327>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90328>>>                Function_Return iSegment
90329>>>            End
90329>>>>
90329>>>        Loop
90330>>>>
90330>>>
90330>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90331>>>        Function_Return -1 // This means bIsSame = True
90332>>>    End_Function
90333>>>
90333>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90335>>>        Boolean bIsSame
90335>>>
90335>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
90336>>>        If (bIsSame = False) Begin
90338>>>            Function_Return False
90339>>>        End
90339>>>>
90339>>>        If (bCompareIndexUppercase = True) Begin
90341>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
90342>>>            If (bIsSame = False) Begin
90344>>>                Function_Return False
90345>>>            End
90345>>>>
90345>>>        End
90345>>>>
90345>>>        If (bCompareIndexAscending = True) Begin
90347>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
90348>>>            If (bIsSame = False) Begin
90350>>>                Function_Return False
90351>>>            End
90351>>>>
90351>>>        End
90351>>>>
90351>>>
90351>>>        Function_Return True
90352>>>    End_Function
90353>>>
90353>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90355>>>        Boolean bIsSame bOK
90355>>>        Integer iSize iSizeTo iCount
90355>>>        tAPIIndexCompare[] aAPIIndexCompare
90355>>>        tAPIIndexCompare[] aAPIIndexCompare
90356>>>
90356>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
90357>>>        If (iSize = 0) Begin
90359>>>            Function_Return True
90360>>>        End
90360>>>>
90360>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
90361>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
90362>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
90363>>>
90363>>>        for iCount from 0 to (iSize - 1)
90369>>>>
90369>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90370>>>            If (bIsSame = False) Begin
90372>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
90373>>>            End
90373>>>>
90373>>>        Loop
90374>>>>
90374>>>
90374>>>        // We probably should delete other indexes if they exists.
90374>>>        for iCount from (iSize +1) to iSizeTo
90380>>>>
90380>>>            Get ApiIndexRemove hTable iCount to bOK
90381>>>        Loop
90382>>>>
90382>>>
90382>>>        Function_Return bOK
90383>>>    End_Function
90384>>>
90384>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
90386>>>        tAPIIndex[] APIIndexes
90386>>>        tAPIIndex[] APIIndexes
90387>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
90387>>>        String sDriverID
90387>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
90387>>>
90387>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90388>>>        Get psDriverID to sDriverID
90389>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90390>>>        Get _UtilTableIsSql hTable to bIsSQLTable
90391>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90394>>>        If (bIsOpen = False) Begin
90396>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90397>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90398>>>            Open hTable
90400>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90401>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90402>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90405>>>            If (bIsOpen = False) Begin
90407>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90408>>>                Move True to APIIndexes[0].bError
90409>>>                Function_Return APIIndexes
90410>>>            End
90410>>>>
90410>>>        End
90410>>>>
90410>>>
90410>>>        Move 0 to iCount
90411>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
90414>>>        for iIndex from 1 to iIndexes
90420>>>>
90420>>>            // This is a test that the index exists as there might be "holes" aka the index
90420>>>            // numbers doesn't not need to be consequitive:
90420>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90423>>>            If (iNumSegments > 0) Begin
90425>>>
90425>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
90426>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
90429>>>                If (bIsSQLTable = True) Begin
90431>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
90434>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
90437>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
90440>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
90443>>>                End
90443>>>>
90443>>>
90443>>>                Move 0 to iSegmentCount
90444>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90447>>>                For iSegment from 1 to iNumSegments
90453>>>>
90453>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
90456>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
90457>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
90460>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
90463>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
90466>>>                    Increment iSegmentCount
90467>>>                Loop
90468>>>>
90468>>>                Increment iCount
90469>>>            End
90469>>>>
90469>>>        Loop
90470>>>>
90470>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90471>>>
90471>>>        Function_Return APIIndexes
90472>>>    End_Function
90473>>>
90473>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90473>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90473>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90473>>>    // have "holes" in the series of index numbers.
90473>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
90475>>>        tAPIIndexCompare[] aAPIIndexCompare
90475>>>        tAPIIndexCompare[] aAPIIndexCompare
90476>>>        tAPIIndexCompare   APIIndexCompare
90476>>>        tAPIIndexCompare   APIIndexCompare
90476>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90476>>>
90476>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
90477>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
90478>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90480>>>            Function_Return aAPIIndexCompare
90481>>>        End
90481>>>>
90481>>>
90481>>>        Decrement iSizeFrom
90482>>>        for iCount from 0 to iSizeFrom
90488>>>>
90488>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
90489>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
90490>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
90491>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
90492>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
90493>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
90494>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
90495>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
90496>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
90497>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
90498>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
90499>>>        Loop
90500>>>>
90500>>>
90500>>>        Decrement iSizeTo
90501>>>        for iCount from 0 to iSizeTo
90507>>>>
90507>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
90508>>>            // Search if the Index number already exists in the array; else add it.
90508>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
90509>>>            If (iItem = -1) Begin
90511>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
90512>>>            End
90512>>>>
90512>>>
90512>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
90513>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
90514>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
90515>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
90516>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
90517>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
90518>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
90519>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
90520>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
90521>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
90522>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
90523>>>        Loop
90524>>>>
90524>>>
90524>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
90525>>>
90525>>>        Function_Return aAPIIndexCompare
90526>>>    End_Function
90527>>>
90527>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
90527>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
90529>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
90529>>>        String sDriverID
90529>>>
90529>>>        Get psDriverID to sDriverID
90530>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90531>>>        Get IsSQLDriver sDriverID to bIsSqlTable
90532>>>        If (bIsSqlTable = True) Begin
90534>>>            Get _UtilTableIsSql hTable to bIsSqlTable
90535>>>        End
90535>>>>
90535>>>
90535>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
90536>>>        If (bIsSame = False) Begin
90538>>>            Function_Return False
90539>>>        End
90539>>>>
90539>>>
90539>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
90541>>>            // Don't think we should do this. Or should we?
90541>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
90541>>>
90541>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
90542>>>            If (bIsSame = False) Begin
90544>>>                Function_Return False
90545>>>            End
90545>>>>
90545>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
90546>>>            If (bIsSame = False) Begin
90548>>>                Function_Return False
90549>>>            End
90549>>>>
90549>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
90550>>>            If (bIsSame = False) Begin
90552>>>                Function_Return False
90553>>>            End
90553>>>>
90553>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
90554>>>            If (bIsSame = False) Begin
90556>>>                Function_Return False
90557>>>            End
90557>>>>
90557>>>        End
90557>>>>
90557>>>
90557>>>        Function_Return bIsSame
90558>>>    End_Function
90559>>>
90559>>>    // DF_INDEX_SQL_TYPE values
90559>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
90559>>>    // returns a string with the name.
90559>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
90561>>>        String sRetval
90561>>>            Case Begin
90561>>>                Case (iIndexType = DF_INDEX_CLIENT)
90563>>>                    Move "DF_INDEX_CLIENT" to sRetval
90564>>>                    Case Break
90565>>>                Case (iIndexType = DF_INDEX_SERVER)
90568>>>                    Move "DF_INDEX_SERVER" to sRetval
90569>>>                    Case Break
90570>>>                Case (iIndexType = DF_INDEX_SERVER_ONLY)
90573>>>                    Move "DF_INDEX_SERVER_ONLY" to sRetval
90574>>>                    Case Break
90575>>>                Case (iIndexType = DF_INDEX_TEMPORARY)
90578>>>                    Move "DF_INDEX_TEMPORARY" to sRetval
90579>>>                    Case Break
90580>>>                Case Else
90580>>>                    Move "UNKNOWN INDEX TYPE" to sRetval
90581>>>            Case End
90581>>>        Function_Return sRetval
90582>>>    End_Function
90583>>>
90583>>>    // * Dummy function for the Studio's Code Explorer *
90583>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
90585>>>        Function_Return False
90586>>>    End_Function
90587>>>
90587>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
90587>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
90589>>>        Boolean bIsSame
90589>>>        Integer iSize iCount
90589>>>
90589>>>        Move True to bIsSame
90590>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
90591>>>        Decrement iSize
90592>>>        For iCount from 0 to iSize
90598>>>>
90598>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
90599>>>            If (bIsSame = False) Begin
90601>>>                Function_Return False
90602>>>            End
90602>>>>
90602>>>        Loop
90603>>>>
90603>>>
90603>>>        Function_Return bIsSame
90604>>>    End_Function
90605>>>
90605>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
90605>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
90607>>>        Boolean bIsSame
90607>>>
90607>>>        Move True to bIsSame
90608>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
90610>>>            Function_Return False
90611>>>        End
90611>>>>
90611>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
90613>>>            Function_Return False
90614>>>        End
90614>>>>
90614>>>
90614>>>        // We could also compare field names, but I don't think that is necessary...
90614>>>
90614>>>        Function_Return bIsSame
90615>>>    End_Function
90616>>>
90616>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
90616>>>    // already exists.
90616>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
90618>>>        Boolean bOK
90618>>>        Integer iSizeTo iSize iCount iColumn
90618>>>        String sDriverID
90618>>>
90618>>>        Move True to bOK
90619>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
90620>>>        If (iSizeTo > 0) Begin
90622>>>            Get AutoConnectionIDLogin to bOK
90623>>>            Move False to Err
90624>>>            Open hTable Mode DF_EXCLUSIVE
90626>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90629>>>            Decrement iSizeTo
90630>>>
90630>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
90630>>>            // for the "TO" database. But start by deleting all current "TO" relations:
90630>>>            Structure_Start hTable sDriverID
90631>>>                for iCount from 0 to iSizeTo
90637>>>>
90637>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
90638>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
90641>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
90644>>>                Loop
90645>>>>
90645>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
90646>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90648>>>            Set Action_Text of ghoStatusPanel to ""
90649>>>        End
90649>>>>
90649>>>
90649>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
90650>>>        Decrement iSize
90651>>>        for iCount from 0 to iSize
90657>>>>
90657>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
90658>>>        Loop
90659>>>>
90659>>>
90659>>>        Function_Return bOK
90660>>>    End_Function
90661>>>
90661>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
90663>>>        tAPIRelation[] APIRelations
90663>>>        tAPIRelation[] APIRelations
90664>>>        Integer iColumn iColumnTo iNumColumns iCount
90664>>>        Handle hParent
90664>>>        Boolean bIsOpen
90664>>>
90664>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90665>>>        Move 0 to iCount
90666>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90669>>>        If (bIsOpen = False) Begin
90671>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90672>>>            Open hTable
90674>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90675>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90678>>>            If (bIsOpen = False) Begin
90680>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90681>>>                Move True to APIRelations[0].bError
90682>>>                Function_Return APIRelations
90683>>>            End
90683>>>>
90683>>>        End
90683>>>>
90683>>>
90683>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90686>>>        For iColumn from 1 to iNumColumns
90692>>>>
90692>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
90695>>>            If (hParent <> 0) Begin
90697>>>                Open hParent
90699>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
90700>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
90703>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
90704>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
90707>>>
90707>>>                Move hParent                                            to APIRelations[iCount].hTableTo
90708>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
90711>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
90714>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
90715>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
90718>>>                Move False                                              to APIRelations[iCount].bShouldChange
90719>>>                Move False                                              to APIRelations[iCount].bCancel
90720>>>                Move False                                              to APIRelations[iCount].bError
90721>>>                Close hParent
90722>>>                Increment iCount
90723>>>            End
90723>>>>
90723>>>        Loop
90724>>>>
90724>>>
90724>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90725>>>        Function_Return APIRelations
90726>>>    End_Function
90727>>>
90727>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90727>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
90727>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
90729>>>        tAPIRelation[] aAPIRelationFromAndTo
90729>>>        tAPIRelation[] aAPIRelationFromAndTo
90730>>>        tAPIRelationCompare[] aAPIRelationCompare
90730>>>        tAPIRelationCompare[] aAPIRelationCompare
90731>>>        tAPIRelationCompare   APIRelationCompare
90731>>>        tAPIRelationCompare   APIRelationCompare
90731>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90731>>>
90731>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
90732>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
90733>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90735>>>            Function_Return aAPIRelationCompare
90736>>>        End
90736>>>>
90736>>>
90736>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
90737>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(__UtilRelationArrayCompare))) to aAPIRelationFromAndTo
90738>>>
90738>>>        Decrement iSizeFrom
90739>>>        for iCount from 0 to iSizeFrom
90745>>>>
90745>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
90746>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
90747>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
90748>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
90749>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
90750>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
90751>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
90752>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
90753>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
90754>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
90755>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
90756>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
90757>>>        Loop
90758>>>>
90758>>>
90758>>>        Decrement iSizeTo
90759>>>        for iCount from 0 to iSizeTo
90765>>>>
90765>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
90766>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
90767>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
90768>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
90769>>>
90769>>>            // Search if the relation already exists in the array; else add it.
90769>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to iItem
90770>>>            If (iItem = -1) Begin
90772>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
90773>>>            End
90773>>>>
90773>>>
90773>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
90774>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
90775>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
90776>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
90777>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
90778>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
90779>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
90780>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
90781>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
90782>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
90783>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
90784>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
90785>>>        Loop
90786>>>>
90786>>>
90786>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to aAPIRelationCompare
90787>>>
90787>>>        Function_Return aAPIRelationCompare
90788>>>    End_Function
90789>>>
90789>>>    // * Dummy function for the Studio's Code Explorer *
90789>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
90791>>>        Function_Return False
90792>>>    End_Function
90793>>>
90793>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
90793>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
90793>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
90793>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
90795>>>        Boolean bFound
90795>>>
90795>>>        Move False to Err
90796>>>        Open CodeMast
90798>>>        Open CodeType
90800>>>
90800>>>        If (bCodeType = True) Begin
90802>>>            Set Private.phCurrentTable to CODETYPE.File_Number
90803>>>            Clear CodeType
90804>>>            Move sTypeValue to CODETYPE.Type
90805>>>            Find eq CODETYPE by 1
90806>>>>
90806>>>            Move Found to bFound
90807>>>            If (bFound = True) Begin
90809>>>                Reread CodeType
90813>>>            End
90813>>>>
90813>>>            Else Begin
90814>>>                Clear CodeType
90815>>>            End
90815>>>>
90815>>>
90815>>>            Move sTypeValue to CODETYPE.Type
90816>>>            Move sValue2    to CODETYPE.Description
90817>>>            Move sValue3    to CODETYPE.Comment
90818>>>            SaveRecord CODETYPE
90819>>>
90819>>>            If (bFound = True) Begin
90821>>>                Unlock
90822>>>>
90822>>>            End
90822>>>>
90822>>>        End
90822>>>>
90822>>>
90822>>>        If (bCodeType = False) Begin
90824>>>            Set Private.phCurrentTable to CODEMAST.File_Number
90825>>>            Clear CODEMAST
90826>>>            Move sTypeValue to CODEMAST.Type
90827>>>            Move sValue2    to CODEMAST.Code
90828>>>            Find eq CODEMAST by 1
90829>>>>
90829>>>            Move Found to bFound
90830>>>            If (bFound = True) Begin
90832>>>                Reread CODEMAST
90836>>>            End
90836>>>>
90836>>>            Else Begin
90837>>>                Clear CODEMAST
90838>>>            End
90838>>>>
90838>>>
90838>>>            Move sTypeValue to CODEMAST.Type
90839>>>            Move sValue2    to CODEMAST.Code
90840>>>            Move sValue3    to CODEMAST.Description
90841>>>            SaveRecord CODEMAST
90842>>>
90842>>>            If (bFound = True) Begin
90844>>>                Unlock
90845>>>>
90845>>>            End
90845>>>>
90845>>>        End
90845>>>>
90845>>>
90845>>>        Close CodeMast
90846>>>        Close CodeType
90847>>>
90847>>>        Function_Return (Err = False)
90848>>>    End_Function
90849>>>
90849>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
90849>>>    // CodeType and then spins through all CodeMast records to change all related records.
90849>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
90851>>>        Boolean bFound
90851>>>
90851>>>        Move False to Err
90852>>>        Open CodeMast
90854>>>        Open CodeType
90856>>>
90856>>>        Clear CodeType
90857>>>        Move sFromValue to CODETYPE.Type
90858>>>        Find eq CODETYPE.Type
90859>>>>
90859>>>        If (Found = True) Begin
90861>>>            Reread CODETYPE
90865>>>                Move sToValue to CODETYPE.Type
90866>>>                SaveRecord CODETYPE
90867>>>            Unlock
90868>>>>
90868>>>        End
90868>>>>
90868>>>
90868>>>        Clear CODEMAST
90869>>>        Find gt CODEMAST by Recnum
90870>>>>
90870>>>        While (Found = True)
90874>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
90875>>>            If (bFound = True) Begin
90877>>>                Reread CODEMAST
90881>>>                    Move sToValue to CODEMAST.Type
90882>>>                    SaveRecord CODEMAST
90883>>>                Unlock
90884>>>>
90884>>>            End
90884>>>>
90884>>>            Find gt CODEMAST by Recnum
90885>>>>
90885>>>        Loop
90886>>>>
90886>>>
90886>>>        Close CodeMast
90887>>>        Close CodeType
90888>>>
90888>>>        Function_Return (Err = False)
90889>>>    End_Function
90890>>>
90890>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
90890>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
90892>>>        Boolean bFound
90892>>>
90892>>>        Move False to Err
90893>>>        Open CodeMast
90895>>>
90895>>>        Clear CODEMAST
90896>>>        Move sTypeValue to CODEMAST.Type
90897>>>        Move sValue2    to CODEMAST.Code
90898>>>        Find eq CODEMAST.Code
90899>>>>
90899>>>        Move Found to bFound
90900>>>        If (bFound = True) Begin
90902>>>            Delete CODEMAST
90903>>>        End
90903>>>>
90903>>>
90903>>>        Close CodeMast
90904>>>
90904>>>        Function_Return (Err = False)
90905>>>    End_Function
90906>>>
90906>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
90908>>>        Boolean bRecnum bToAnsi
90908>>>        Integer iCh
90908>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
90908>>>
90908>>>        If (Trim(sDataPath) = "") Begin
90910>>>            Function_Return False
90911>>>        End
90911>>>>
90911>>>
90911>>>        Move False to Err
90912>>>        Get psDriverID     to sDriverID
90913>>>        Get psConnectionID to sConnectionID
90914>>>        Get psSchema       to sSchemaName
90915>>>        Get True           to bRecnum
90916>>>        Get pbToANSI       to bToAnsi
90917>>>        Move CS_ANSI_Txt to sANSI_OEM
90918>>>        If (bToAnsi = False) Begin
90920>>>            Move CS_OEM_Txt to sANSI_OEM
90921>>>        End
90921>>>>
90921>>>
90921>>>        Get vFolderFormat sDataPath to sDataPath
90922>>>        Move "CodeMast.int"         to sFileName
90923>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
90924>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
90927>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
90930>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
90933>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
90936>>>            Writeln channel iCh ("")
90939>>>            Writeln channel iCh ("RECNUM_TABLE YES")
90942>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
90945>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
90948>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
90951>>>            Writeln channel iCh ("")
90954>>>            Writeln channel iCh ("INDEX_NUMBER 1")
90957>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
90960>>>            Writeln channel iCh ("")
90963>>>        Send Seq_Close_Channel iCh
90964>>>
90964>>>        Get vFolderFormat sDataPath to sDataPath
90965>>>        Move "CodeType.int"         to sFileName
90966>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
90967>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
90970>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
90973>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
90976>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
90979>>>            Writeln channel iCh ("")
90982>>>            Writeln channel iCh ("RECNUM_TABLE YES")
90985>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
90988>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
90991>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
90994>>>            Writeln channel iCh ("")
90997>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91000>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91003>>>            Writeln channel iCh ("")
91006>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91009>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91012>>>            Writeln channel iCh ("")
91015>>>        Send Seq_Close_Channel iCh
91016>>>
91016>>>        Function_Return (Err = False)
91017>>>    End_Function
91018>>>
91018>>>    // * Dummy function for the Studio's Code Explorer *
91018>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
91020>>>        Function_Return False
91021>>>    End_Function
91022>>>
91022>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
91022>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
91022>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
91024>>>        Boolean bOK bExists
91024>>>        String sDataPath sBackupFolder
91024>>>
91024>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
91025>>>        Move CS_DUFBackupDataFolder to sBackupFolder
91026>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91027>>>        Get vFolderFormat sDataPath to sDataPath
91028>>>
91028>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91029>>>        If (bExists = False) Begin
91031>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
91032>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91033>>>            If (bExists = False) Begin
91035>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
91036>>>>
91036>>>                Function_Return False
91037>>>            End
91037>>>>
91037>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
91038>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
91039>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
91040>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
91041>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
91042>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
91043>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
91044>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
91045>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
91046>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
91047>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
91048>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
91049>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
91050>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
91051>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
91052>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
91053>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
91054>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
91055>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
91056>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
91057>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
91058>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
91059>>>        End
91059>>>>
91059>>>
91059>>>        Set Message_Text of ghoStatusPanel to ""
91060>>>        Function_Return True
91061>>>    End_Function
91062>>>    
91062>>>    // Check if the file exists in the Data folder,
91062>>>    // else creates it from memory as it has been compiled into the program as a resource:
91062>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
91064>>>        String sPath
91064>>>        Boolean bExists
91064>>>
91064>>>        Get psDataPathFirstPart to sPath
91065>>>        Move (sPath + sFileName) to sFileName
91066>>>        Get vFilePathExists sFileName to bExists
91067>>>
91067>>>        If (bExists = False) Begin
91069>>>            // Read from memory & create file on disk.
91069>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
91070>>>            Get vFilePathExists sFileName to bExists
91071>>>        End
91071>>>>
91071>>>        Function_Return bExists
91072>>>    End_Function
91073>>>
91073>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
91075>>>        tColumnType RetvalType
91075>>>        tColumnType RetvalType
91075>>>        Integer iRetval
91075>>>
91075>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91076>>>        Move RetvalType.iDataFlexType to iRetval
91077>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
91079>>>            If (iLength <= 255) Begin
91081>>>                Move DF_ASCII to iRetval
91082>>>            End
91082>>>>
91082>>>        End
91082>>>>
91082>>>        Function_Return iRetval
91083>>>    End_Function
91084>>>
91084>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
91086>>>        String sRetval
91086>>>
91086>>>        Case Begin
91086>>>            Case (iDataType = DF_ASCII)
91088>>>                Move "DF_ASCII" to sRetval
91089>>>                Case Break
91090>>>            Case (iDataType = DF_BCD)
91093>>>                Move "DF_BCD" to sRetval
91094>>>                Case Break
91095>>>            Case (iDataType = DF_BINARY)
91098>>>                Move "DF_BINARY" to sRetval
91099>>>                Case Break
91100>>>            Case (iDataType = DF_DATE)
91103>>>                Move "DF_DATE" to sRetval
91104>>>                Case Break
91105>>>            Case (iDataType = DF_DATETIME)
91108>>>                Move "DF_DATETIME" to sRetval
91109>>>                Case Break
91110>>>            Case (iDataType = DF_TEXT)
91113>>>                Move "DF_TEXT" to sRetval
91114>>>                Case Break
91115>>>            Case Else
91115>>>                Move "" to sRetval
91116>>>        Case End
91116>>>
91116>>>        Function_Return sRetval
91117>>>    End_Function
91118>>>
91118>>>    // The default value used for a datatype as specified in the driver int file.
91118>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
91120>>>        String sRetval sServer
91120>>>        tColumnType RetvalType
91120>>>        tColumnType RetvalType
91120>>>        Integer iDriver iDataFlexType
91120>>>        Handle hDatabase
91120>>>
91120>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91121>>>        Move RetvalType.iDataFlexType to iDataFlexType
91122>>>        Get DriverIndex sDriverID to iDriver
91123>>>        Get psServer to sServer
91124>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91125>>>        If (hDatabase = 0) Begin
91127>>>            Function_Return ""
91128>>>        End
91128>>>>
91128>>>
91128>>>        Case Begin
91128>>>            Case (iDataFlexType = DF_ASCII)
91130>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
91133>>>                Case Break
91134>>>            Case (iDataFlexType = DF_BCD)
91137>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
91140>>>                Case Break
91141>>>            Case (iDataFlexType = DF_BINARY)
91144>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
91147>>>                Case Break
91148>>>            Case (iDataFlexType = DF_DATE)
91151>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
91154>>>                Case Break
91155>>>            Case (iDataFlexType = DF_DATETIME)
91158>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
91161>>>                Case Break
91162>>>            Case (iDataFlexType = DF_TEXT)
91165>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
91168>>>                Case Break
91169>>>            Case Else
91169>>>                Move "" to sRetval
91170>>>        Case End
91170>>>
91170>>>        Function_Return sRetval
91171>>>    End_Function
91172>>>
91172>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
91174>>>        String sDriverID sServer
91174>>>        tColumnType RetvalType
91174>>>        tColumnType RetvalType
91174>>>        Integer iDbType iDriver
91174>>>        Handle hDatabase
91174>>>
91174>>>        Get psDriverID to sDriverID
91175>>>        Get piDbType   to iDbType
91176>>>        Get DriverIndex sDriverID to iDriver
91177>>>        Get psServer to sServer
91178>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91179>>>        If (hDatabase = 0) Begin
91181>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
91182>>>>
91182>>>            Procedure_Return
91183>>>        End
91183>>>>
91183>>>
91183>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
91186>>>
91186>>>    End_Procedure
91187>>>
91187>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
91189>>>        String sDriverID sServer
91189>>>        tColumnType RetvalType
91189>>>        tColumnType RetvalType
91189>>>        Integer iDbType iDriver
91189>>>        Handle hDatabase
91189>>>
91189>>>        Get psDriverID to sDriverID
91190>>>        Get piDbType   to iDbType
91191>>>        Get DriverIndex sDriverID to iDriver
91192>>>        Get psServer to sServer
91193>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91194>>>        If (hDatabase = 0) Begin
91196>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
91197>>>>
91197>>>            Procedure_Return
91198>>>        End
91198>>>>
91198>>>
91198>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
91201>>>
91201>>>    End_Procedure
91202>>>
91202>>>    // Returns a struct array with the default column types for the SQL back-end and how they
91202>>>    // are mapped to the standard DataFlex data types.
91202>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
91202>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
91204>>>        tColumnType[] ColumnTypeArray EmptyArray
91204>>>        tColumnType[] ColumnTypeArray EmptyArray
91206>>>        String sDataType
91206>>>        Integer iDataType iDriverID iCount
91206>>>        Boolean bSQLDriver
91206>>>
91206>>>        Move 0 to iCount
91207>>>        Get DriverIndex sDriverID to iDriverID
91208>>>        Get IsSQLDriver sDriverID to bSQLDriver
91209>>>        If (bSQLDriver = False) Begin
91211>>>            Function_Return EmptyArray
91212>>>        End
91212>>>>
91212>>>
91212>>>        // DF_ASCII
91212>>>        If (sDriverID = ODBC_DRV_ID) Begin
91214>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
91217>>>        End
91217>>>>
91217>>>        Else Begin
91218>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
91221>>>        End
91221>>>>
91221>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91222>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
91223>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
91224>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91225>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91226>>>        Increment iCount
91227>>>
91227>>>        // DF_BINARY
91227>>>        If (sDriverID = ODBC_DRV_ID) Begin
91229>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
91232>>>        End
91232>>>>
91232>>>        Else Begin
91233>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
91236>>>        End
91236>>>>
91236>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91237>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
91238>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
91239>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91240>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91241>>>        Increment iCount
91242>>>
91242>>>        // DF_DATE
91242>>>        If (sDriverID = ODBC_DRV_ID) Begin
91244>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
91247>>>        End
91247>>>>
91247>>>        Else Begin
91248>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
91251>>>        End
91251>>>>
91251>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91252>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
91253>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
91254>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91255>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91256>>>        Increment iCount
91257>>>
91257>>>        // DF_DATETIME
91257>>>        If (sDriverID = ODBC_DRV_ID) Begin
91259>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
91262>>>        End
91262>>>>
91262>>>        Else Begin
91263>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
91266>>>        End
91266>>>>
91266>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91267>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
91268>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
91269>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91270>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91271>>>        Increment iCount
91272>>>
91272>>>        // DF_NUMERIC
91272>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
91272>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
91272>>>        // we make them here all "Numeric"...
91272>>>        Case Begin
91272>>>            Case (sDriverID = MSSQLDRV_ID)
91274>>>                Move SQL_NUMERIC to iDataType
91275>>>                Move "numeric"   to sDataType
91276>>>                Case Break
91277>>>            Case (sDriverID = DB2_DRV_ID)
91280>>>                Move SQL_NUMERIC to iDataType
91281>>>                Move "NUMERIC"   to sDataType
91282>>>                Case Break
91283>>>            Case Else
91283>>>                Move DF_BCD      to iDataType
91284>>>                Move "Numeric"   to sDataType
91285>>>        Case End
91285>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
91286>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
91287>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91288>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91289>>>        Increment iCount
91290>>>
91290>>>        // DF_TEXT
91290>>>        If (sDriverID = ODBC_DRV_ID) Begin
91292>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
91295>>>        End
91295>>>>
91295>>>        Else Begin
91296>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
91299>>>        End
91299>>>>
91299>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91300>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
91301>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
91302>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91303>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91304>>>
91304>>>        Function_Return ColumnTypeArray
91305>>>    End_Function
91306>>>
91306>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
91308>>>        tColumnType[] ColumnTypeArray
91308>>>        tColumnType[] ColumnTypeArray
91309>>>        tColumnType   ColumnType
91309>>>        tColumnType   ColumnType
91309>>>        Integer iCount iSize
91309>>>
91309>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
91310>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
91311>>>        Decrement iSize
91312>>>
91312>>>        for iCount from 0 to iSize
91318>>>>
91318>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
91320>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
91321>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
91322>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
91323>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
91324>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
91325>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
91326>>>                Move iSize to iCount
91327>>>            End
91327>>>>
91327>>>        Loop
91328>>>>
91328>>>
91328>>>        Function_Return ColumnType
91329>>>    End_Function
91330>>>
91330>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
91330>>>    // An Alias file/table is a filelist number that share the same Physical filename
91330>>>    // but the Logical name is different.
91330>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
91330>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
91332>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
91332>>>        Handle hInTable hMasterTable 
91332>>>        Boolean bIsAlias
91332>>>        
91332>>>        Move hTable to hInTable
91333>>>        Move False to bIsAlias
91334>>>        Move 0 to hMasterTable
91335>>>        
91335>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91338>>>        // Remove any prefix with a driver name.
91338>>>        Get _TableNameOnly sRootName to sRootName     
91339>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91342>>>        Get _TableNameOnly sLogicalName to sLogicalName     
91343>>>        
91343>>>        // If the table has the same root and logical name it can't be an alias,
91343>>>        // so we can safely return a "False".
91343>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
91345>>>            Function_Return False
91346>>>        End
91346>>>>
91346>>>        
91346>>>        // Now we need to find a master table with the same root name (sRootName above),
91346>>>        // as the passed hTable root name.
91346>>>        // A master table always has the same root and logical name.
91346>>>        Move 0 to hTable
91347>>>        Repeat
91347>>>>
91347>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91350>>>            If (hTable > 0 and hTable <> 50) Begin
91352>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
91355>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
91356>>>                // If we found another table with the same root and logical name
91356>>>                // we have found a master table.
91356>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
91358>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
91361>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
91362>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
91364>>>                        Move hTable to hMasterTable   
91365>>>                        Move 0 to hTable // To end the loop.
91366>>>                    End
91366>>>>
91366>>>                End
91366>>>>
91366>>>            End
91366>>>>
91366>>>        Until (hTable = 0)
91368>>>        
91368>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
91370>>>            Move True to bIsAlias
91371>>>        End
91371>>>>
91371>>>        
91371>>>        Function_Return bIsAlias
91372>>>    End_Function
91373>>>
91373>>>    // To Open a table with any driver.
91373>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
91373>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
91373>>>    //
91373>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
91373>>>    // The found flag is still used to indicate if the open was successful or not. The function
91373>>>    // returns a True if successful (table could be opened).
91373>>>    //
91373>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
91373>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
91373>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
91373>>>    // set properly we can open the table.
91373>>>    //
91373>>>    // DAW Driver Syntax:
91373>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
91373>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
91373>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
91373>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
91373>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
91373>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
91373>>>    //
91373>>>    // DAW Driver Sample:
91373>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
91373>>>    //
91373>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
91375>>>        String sTableNameOrg
91375>>>        Boolean bOpen bOK
91375>>>        tSQLConnection SQLConnection
91375>>>        tSQLConnection SQLConnection
91375>>>        
91375>>>        Move False to bOpen
91376>>>        Move sTableName to sTableNameOrg
91377>>>        If (hTable > 0) Begin
91379>>>            Send Ignore_Error of Error_Object_Id 20529
91380>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91381>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91382>>>            Send Ignore_Error of Error_Object_Id 10
91383>>>            Open hTable Mode iMode
91385>>>            Send Trap_Error of Error_Object_Id 20529
91386>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91387>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91388>>>            Send Trap_Error of Error_Object_Id 10
91389>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91392>>>            If (bOpen = True) Begin
91394>>>                Function_Return True
91395>>>            End
91395>>>>
91395>>>        End
91395>>>>
91395>>>
91395>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
91396>>>        If (hTable > 0) Begin
91398>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91401>>>        End
91401>>>>
91401>>>
91401>>>        Function_Return bOpen
91402>>>    End_Function
91403>>>
91403>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
91405>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
91405>>>        Boolean bOpen bOK
91405>>>        tSQLConnection SQLConnection
91405>>>        tSQLConnection SQLConnection
91405>>>
91405>>>        If (hTable < 1) Begin
91407>>>            Function_Return False
91408>>>        End
91408>>>>
91408>>>
91408>>>        Move sTableName to sTableNameOrg
91409>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91410>>>        Move SQLConnection.sDriverID to sDriverID
91411>>>        Move SQLConnection.sConnectionString to sConnection
91412>>>        Move SQLConnection.sSchema to sSchema
91413>>>        If (sSchema = "") Begin
91415>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
91416>>>        End
91416>>>>
91416>>>
91416>>>        // We need to remove the ".int" part of the table name because
91416>>>        // the table name after the "#" in the connection syntax below wants the
91416>>>        // "bare" table name without any extension.
91416>>>        If (sDriverID <> DATAFLEX_ID) Begin
91418>>>            If (Lowercase(sTableName) contains ".int") Begin
91420>>>                Get ParseFileExtension sTableName to sExt
91421>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
91422>>>            End
91422>>>>
91422>>>            Else Begin
91423>>>                Move sTableName to sTableNameShort
91424>>>                Move (Append(sTableName, ".int")) to sTableName
91425>>>            End
91425>>>>
91425>>>            Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
91426>>>            Move sConnection to sTableName
91427>>>        End
91427>>>>
91427>>>
91427>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91428>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91429>>>        If (hTable = 0) Begin
91431>>>            Get NextFreeFilelistSlot to hTable
91432>>>        End
91432>>>>
91432>>>
91432>>>        Case Begin
91432>>>            Case (sDriverID = MSSQLDRV_ID)
91434>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91434>>>                If (iMode <> DF_EXCLUSIVE) Begin
91436>>>                    Close hTable
91437>>>                    Open sTableName as hTable
91439>>>                End
91439>>>>
91439>>>                Else Begin
91440>>>                    Get OpenTableExclusive hTable to bOK
91441>>>                    If (bOK = False) Begin
91443>>>                        Function_Return False
91444>>>                    End
91444>>>>
91444>>>                End
91444>>>>
91444>>>                Case Break
91445>>>
91445>>>            Case (sDriverID = DB2_DRV_ID)
91448>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91448>>>                If (iMode <> DF_EXCLUSIVE) Begin
91450>>>                    Close hTable
91451>>>                    Open sTableName as hTable
91453>>>                End
91453>>>>
91453>>>                Else Begin
91454>>>                    Get OpenTableExclusive hTable to bOK
91455>>>                    If (bOK = False) Begin
91457>>>                        Function_Return False
91458>>>                    End
91458>>>>
91458>>>                End
91458>>>>
91458>>>                Case Break
91459>>>
91459>>>            Case (sDriverID = ODBC_DRV_ID)
91462>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91462>>>                If (iMode = DF_SHARE) Begin
91464>>>                    Close hTable
91465>>>                    Open sTableName as hTable
91467>>>                End
91467>>>>
91467>>>                Else Begin
91468>>>                    Get OpenTableExclusive hTable to bOK
91469>>>                    If (bOK = False) Begin
91471>>>                        Function_Return False
91472>>>                    End
91472>>>>
91472>>>                End
91472>>>>
91472>>>                Case Break
91473>>>
91473>>>            Case (sDriverID = DATAFLEX_ID)
91476>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
91478>>>                    Close hTable
91479>>>                    Open sTableName as hTable
91481>>>                End
91481>>>>
91481>>>                Else If (iMode = DF_EXCLUSIVE) Begin
91484>>>                    Get OpenTableExclusive hTable to bOK
91485>>>                    If (bOK = False) Begin
91487>>>                        Function_Return False
91488>>>                    End
91488>>>>
91488>>>                End
91488>>>>
91488>>>                Else Begin
91489>>>                    Open hTable
91491>>>                End
91491>>>>
91491>>>                Case Break
91492>>>
91492>>>            Case Else
91492>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
91493>>>>
91493>>>        Case End
91493>>>
91493>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91494>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91495>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
91497>>>            Move False to Found
91498>>>        End
91498>>>>
91498>>>        // If open failed, the Err is set to true,
91498>>>        // but we don't want that because it could end our loop.
91498>>>        Move False to Err
91499>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91502>>>
91502>>>        Function_Return bOpen
91503>>>    End_Function
91504>>>
91504>>>    // Pass a table's logical name
91504>>>    // Returns True if the table exists in filelist.cfg.
91504>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
91506>>>        Handle hTable
91506>>>        Boolean bFound
91506>>>        String sCompareTable
91506>>>
91506>>>        Move False to bFound
91507>>>        Move 0 to hTable
91508>>>        Repeat
91508>>>>
91508>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91511>>>            If (hTable > 0) Begin
91513>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
91516>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
91518>>>                    Move True to bFound
91519>>>                End
91519>>>>
91519>>>            End
91519>>>>
91519>>>            If (bFound = True) ;                Break
91522>>>        Until (hTable = 0)
91524>>>
91524>>>        Function_Return (bFound = True)
91525>>>    End_Function
91526>>>
91526>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
91526>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
91528>>>        Boolean bOK bExists
91528>>>        String sDriverID
91528>>>
91528>>>        Get _UtilTableExists hTable to bExists
91529>>>        If (bExists = False) Begin
91531>>>            Function_Return DATAFLEX_ID
91532>>>        End
91532>>>>
91532>>>        Get OpenTableExclusive hTable to bOK
91533>>>        If (bOK = False) Begin
91535>>>            Function_Return DATAFLEX_ID
91536>>>        End
91536>>>>
91536>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91539>>>        Function_Return sDriverID
91540>>>    End_Function
91541>>>
91541>>>    // Number of tables in Filelist.cfg. Returns integger
91541>>>    Function UtilFilelistNoOfTables Returns Integer
91543>>>        Handle hTable
91543>>>        Integer iRetval
91543>>>
91543>>>        Move 0 to hTable
91544>>>        Move 0 to iRetval
91545>>>
91545>>>        Repeat
91545>>>>
91545>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91548>>>            If (hTable > 0) Begin
91550>>>                Increment iRetval
91551>>>            End
91551>>>>
91551>>>        Until (hTable = 0)
91553>>>
91553>>>        Function_Return iRetval
91554>>>    End_Function
91555>>>
91555>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
91555>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
91557>>>        Handle hTable
91557>>>        String sRoot sDriverID
91557>>>        Boolean bIsSQLTable
91557>>>        Integer iPos
91557>>>
91557>>>        Move 0 to hTable
91558>>>        Move "" to sDriverID
91559>>>        Move False to bIsSQLTable
91560>>>
91560>>>        Repeat
91560>>>>
91560>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91563>>>            If (hTable > 0) Begin
91565>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
91568>>>                If (sRoot contains ":") Begin
91570>>>                    Move (Pos(":", sRoot)) to iPos
91571>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
91572>>>                End
91572>>>>
91572>>>                Get IsSQLDriver sDriverID to bIsSQLTable
91573>>>            End
91573>>>>
91573>>>
91573>>>        Until (hTable = 0 or bIsSQLTable = True)
91575>>>
91575>>>        Function_Return sDriverID
91576>>>    End_Function
91577>>>
91577>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
91579>>>        String sRootName
91579>>>        Boolean bIsSQL
91579>>>        Handle hTable
91579>>>
91579>>>        Move False to bIsSQL
91580>>>        Move 0 to hTable
91581>>>        Repeat
91581>>>>
91581>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91584>>>            If (hTable > 0) Begin
91586>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91589>>>                Get _UtilTableIsSqlByRootName sRootName to bIsSQL
91590>>>                If (bIsSQL = True) Begin
91592>>>                    Move 0 to hTable
91593>>>                End
91593>>>>
91593>>>            End
91593>>>>
91593>>>        Until (hTable = 0)
91595>>>
91595>>>        Function_Return (bIsSQL = False)
91596>>>    End_Function
91597>>>
91597>>>    // * Dummy function for the Studio's Code Explorer *
91597>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
91599>>>        Function_Return False
91600>>>    End_Function
91601>>>
91601>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
91603>>>        String  sRetval
91603>>>        String[] sOverlapFieldsArray
91604>>>        Integer iType iColumn iColumns
91604>>>        Boolean bOpen bOverlap
91604>>>
91604>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91607>>>        If (bOpen = False) Begin
91609>>>            Open hTable
91611>>>        End
91611>>>>
91611>>>
91611>>>        Move "" to sRetval
91612>>>
91612>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
91615>>>
91615>>>        for iColumn from 0 to iColumns
91621>>>>
91621>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
91624>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
91626>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
91629>>>                If (bOverlap) Begin
91631>>>                    If (sRetval <> "") Begin
91633>>>                        Append sRetval ","
91634>>>                    End
91634>>>>
91634>>>                    Append sRetval iColumn
91635>>>                End
91635>>>>
91635>>>            End
91635>>>>
91635>>>        Loop
91636>>>>
91636>>>
91636>>>        If (bOpen = False) Begin
91638>>>            Close hTable
91639>>>        End
91639>>>>
91639>>>
91639>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
91640>>>
91640>>>        Function_Return sOverlapFieldsArray
91641>>>    End_Function
91642>>>
91642>>>    Function UtilEnumerateODBCDrivers Returns String
91644>>>        Handle hoRegistry hoODBCDriverNames
91644>>>        Boolean bExists bKeyOpened
91644>>>        String sKey
91644>>>        String[] sDrivers
91645>>>        Integer iDriverNames iDriverName
91645>>>
91645>>>        Get Create (RefClass (cRegistry)) to hoRegistry
91646>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
91647>>>        Set pfAccessRights of hoRegistry to Key_Read
91648>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
91649>>>        Get KeyExists of hoRegistry sKey to bExists
91650>>>        If (bExists) Begin
91652>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
91653>>>            If (bKeyOpened) Begin
91655>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
91656>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
91657>>>                If (iDriverNames > 0) Begin
91659>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
91660>>>                    Decrement iDriverNames
91661>>>                    for iDriverName from 0 to iDriverNames
91667>>>>
91667>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
91668>>>                    Loop
91669>>>>
91669>>>                End
91669>>>>
91669>>>                Send CloseKey of hoRegistry
91670>>>            End
91670>>>>
91670>>>        End
91670>>>>
91670>>>        Send Destroy of hoRegistry
91671>>>
91671>>>        Function_Return sDrivers
91672>>>    End_Function
91673>>>
91673>>>    Procedure IncreaseSortBufferSize
91675>>>        String sNull
91675>>>        Integer iSortBufferSize
91675>>>        Boolean bBufferSet
91675>>>
91675>>>        Move "" to sNull
91676>>>        Move (1024 * 128) to iSortBufferSize
91677>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
91682>>>
91682>>>    End_Procedure
91683>>>
91683>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
91685>>>        Integer iLastIndex iIndex iNumSegments
91685>>>        Boolean bOK
91685>>>        String sDriverID
91685>>>
91685>>>        If (hTable > 0) Begin
91687>>>            Get UtilDriverFromTableNumber hTable to sDriverID
91688>>>            Close hTable
91689>>>            Get OpenTableExclusive hTable to bOK
91690>>>            If (bOK = False) Begin
91692>>>                Procedure_Return
91693>>>            End
91693>>>>
91693>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
91696>>>            Structure_Start hTable sDriverID
91697>>>                for iIndex from 1 to iLastIndex
91703>>>>
91703>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91706>>>                    If (iNumSegments > 0) Begin
91708>>>                        If (bSetToBatch = True) Begin
91710>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
91713>>>                        End
91713>>>>
91713>>>                        Else Begin
91714>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
91717>>>                        End
91717>>>>
91717>>>                    End
91717>>>>
91717>>>                Loop
91718>>>>
91718>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91720>>>        End
91720>>>>
91720>>>    End_Procedure
91721>>>
91721>>>    Function NextFreeFilelistSlot Returns Handle
91723>>>        Handle hTable
91723>>>
91723>>>        Move 0 to hTable
91724>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
91727>>>
91727>>>        Function_Return hTable
91728>>>    End_Function
91729>>>
91729>>>    // For debugging purposes. To print Sql statements as they are build...
91729>>>    Procedure DebugPrint String sStmt String sFileName
91731>>>        Integer iCh
91731>>>        Get Seq_Append_Output_Channel sFileName to iCh
91732>>>            Write channel iCh sStmt
91734>>>        Send Seq_Close_Channel iCh
91735>>>    End_Procedure
91736>>>
91736>>>    // Returns the integer number for the passed Driver ID that is
91736>>>    // needed by some database API calls.
91736>>>    Function DriverIndex String sDriverID Returns Integer
91738>>>        String  sCurrentDriver
91738>>>        Integer iNumberOfDrivers iDriver iCount
91738>>>
91738>>>        Move 0 to iDriver
91739>>>
91739>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
91742>>>        for iCount from 1 to iNumberOfDrivers
91748>>>>
91748>>>
91748>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
91751>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
91753>>>                Move iCount to iDriver
91754>>>            End
91754>>>>
91754>>>        Loop
91755>>>>
91755>>>
91755>>>        // In case it was not found, it wasn't loaded so we do that now.
91755>>>        If (iDriver = 0) Begin
91757>>>            Move False to Err
91758>>>            Load_Driver sDriverID
91759>>>            If (Err = False) Begin
91761>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
91764>>>            End
91764>>>>
91764>>>        End
91764>>>>
91764>>>
91764>>>        Function_Return iDriver
91765>>>    End_Function
91766>>>
91766>>>
91766>>>    Function SqlServerClientVersionName for cMSSQLHandler Integer iClientVersion  Returns String
91768>>>        String  sSqlServerClientVersionName
91768>>>        
91768>>>        Case Begin
91768>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
91770>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
91771>>>                Case Break
91772>>>                
91772>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
91775>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
91776>>>                Case Break
91777>>>            
91777>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
91780>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
91781>>>                Case Break
91782>>>            
91782>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
91785>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
91786>>>                Case Break
91787>>>            
91787>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
91790>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
91791>>>                Case Break
91792>>>            
91792>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
91795>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
91796>>>                Case Break
91797>>>            
91797>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
91800>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
91801>>>                Case Break
91802>>>            
91802>>>            Case Else
91802>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
91803>>>        Case End
91803>>>        
91803>>>        Function_Return sSqlServerClientVersionName
91804>>>    End_Function
91805>>>
91805>>>    Function SqlServerClientDriverName for cMSSQLHandler Integer iClientVersion  Returns String
91807>>>        String  sSqlServerClientDriverName
91807>>>        
91807>>>        Case Begin
91807>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
91809>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
91810>>>                Case Break
91811>>>                
91811>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
91814>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
91815>>>                Case Break
91816>>>            
91816>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
91819>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
91820>>>                Case Break
91821>>>            
91821>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
91824>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
91825>>>                Case Break
91826>>>            
91826>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
91829>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
91830>>>                Case Break
91831>>>            
91831>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
91834>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
91835>>>                Case Break
91836>>>            
91836>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
91839>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
91840>>>                Case Break
91841>>>            
91841>>>            Case Else
91841>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
91842>>>        Case End
91842>>>        
91842>>>        Function_Return sSqlServerClientDriverName
91843>>>    End_Function
91844>>>    
91844>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
91846>>>        String sDriverID sVersion sClient sClientLowest sRetval
91846>>>        Integer iNumberOfDrivers iDriver iClient
91846>>>        Handle hoCLIHandler hoMSSQLHandler   
91846>>>        Boolean bOK
91846>>>        
91846>>>        Move "" to sRetval
91847>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
91848>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
91849>>>        Load_Driver MSSQLDRV_ID
91850>>>
91850>>>        // Loop through all loaded drivers.
91850>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
91853>>>        For iDriver from 1 to iNumberOfDrivers
91859>>>>
91859>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
91862>>>            If (sDriverID = MSSQLDRV_ID) Begin
91864>>>                Set psDriverID of hoCLIHandler to sDriverID
91865>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
91868>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
91869>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
91870>>>                Get CKRevision of hoCLIHandler to sVersion
91871>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
91872>>>                If (sClient <> "" and sRetval <> "") Begin
91874>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
91875>>>                End                                
91875>>>>
91875>>>                Else Begin
91876>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
91877>>>                End
91877>>>>
91877>>>            End
91877>>>>
91877>>>        Loop
91878>>>>
91878>>>        Send Destroy of hoCLIHandler  
91879>>>        Send Destroy of hoMSSQLHandler  
91880>>>        If (bShowErrorDialog = True) Begin
91882>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
91883>>>            If (bOK = False or (iClient < iClientVersion)) Begin
91885>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
91886>>>                If (bExitProgram = True) Begin
91888>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
91889>>>                End
91889>>>>
91889>>>                Send Stop_Box sRetval  
91890>>>                If (bExitProgram = True) Begin
91892>>>                    Send Exit_Application
91893>>>                End
91893>>>>
91893>>>            End
91893>>>>
91893>>>        End
91893>>>>
91893>>>        
91893>>>        Function_Return sRetval
91894>>>    End_Function  
91895>>>    
91895>>>    // Returns True if first "." separated string is greater than the second.
91895>>>    // It checks from left to right, one part of the string at a time.
91895>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
91895>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
91897>>>        String[] asVersion asSQLVersion          
91899>>>        Integer iSize iCount iVersion iSQLVersion
91899>>>        
91899>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
91900>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
91901>>>        Move (SizeOfArray(asVersion)) to iSize
91902>>>        // Make sure the two arrays are of the same size:
91902>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
91904>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
91905>>>        End
91905>>>>
91905>>>        Decrement iSize
91906>>>        for iCount from 0 to iSize
91912>>>>
91912>>>            Move asVersion[iCount]    to iVersion
91913>>>            Move asSQLVersion[iCount] to iSQLVersion
91914>>>            CompilerWarnings Off
91914>>>            If (iVersion > iSQLVersion) Break
91917>>>            CompilerWarnings On
91917>>>        Loop
91918>>>>
91918>>>        
91918>>>        Function_Return (iVersion > iSQLVersion)
91919>>>    End_Function
91920>>>
91920>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
91920>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
91920>>>    //       so in that case we "cheat" and report those tables were opened OK.
91920>>>    Function OpenTableExclusive Handle hTable Returns Boolean
91922>>>        Integer iMode iErrorObject
91922>>>        Boolean bOpened
91922>>>        String sTableName 
91922>>>        Handle hoCurrentErrorHandler
91922>>>
91922>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91923>>>        // Can't open a table properly if run through the Debugger/Studio,
91923>>>        // so we generate an error here:
91923>>>        If (IsDebuggerPresent()) Begin
91925>>>            Move Error_Object_Id to hoCurrentErrorHandler
91926>>>            Get piOrgErrorHandlerID to iErrorObject
91927>>>            If (iErrorObject <> 0) Begin
91929>>>                Move iErrorObject to Error_Object_Id
91930>>>            End
91930>>>>
91930>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
91931>>>>
91931>>>            Move hoCurrentErrorHandler to Error_Object_Id
91932>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91933>>>            Function_Return False
91934>>>        End
91934>>>>
91934>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91937>>>        If (bOpened) Begin
91939>>>//            If (IsDebuggerPresent()) Begin
91939>>>//                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91939>>>//                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
91939>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
91939>>>//                    Function_Return True
91939>>>//                End
91939>>>//            End
91939>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
91942>>>            If (iMode=DF_EXCLUSIVE) Begin
91944>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
91945>>>                Function_Return True
91946>>>            End
91946>>>>
91946>>>            Close hTable
91947>>>        End
91947>>>>
91947>>>        Else Begin
91948>>>            Open hTable
91950>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
91953>>>            If (bOpened and IsDebuggerPresent()) Begin
91955>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91958>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
91960>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
91961>>>                    Function_Return True
91962>>>                End
91962>>>>
91962>>>            End
91962>>>>
91962>>>
91962>>>        End
91962>>>>
91962>>>
91962>>>        Close hTable
91963>>>        Open hTable Mode DF_EXCLUSIVE
91965>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91968>>>
91968>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91969>>>        Function_Return bOpened
91970>>>    End_Function
91971>>>
91971>>>    Function AutoConnectionIDLogin Returns Boolean
91973>>>        String sConnectionID sConnectionString sDriverID
91973>>>        Boolean bExists bOK bSQLDriver
91973>>>        Handle hoCLI hoDriver
91973>>>        Integer iRetval
91973>>>        tSQLConnection SQLConnection
91973>>>        tSQLConnection SQLConnection
91973>>>
91973>>>        Get psDriverID to sDriverID
91974>>>        Get IsSQLDriver sDriverID to bSQLDriver
91975>>>        If (bSQLDriver = False) Begin
91977>>>            Function_Return True
91978>>>        End
91978>>>>
91978>>>
91978>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91979>>>        Move SQLConnection.sDriverID                  to sDriverID
91980>>>        Move SQLConnection.sConnectionString          to sConnectionString
91981>>>        Move SQLConnection.sConnectionID to sConnectionID
91982>>>
91982>>>        Get IsConnectionID sConnectionID sDriverID to bExists
91983>>>        If (bExists = False) Begin
91985>>>            // We always start by deleting the current connection - if any - because the
91985>>>            // login details my have changed.
91985>>>            Get phoCLIHandler to hoCLI
91986>>>            Set psDriverID    of hoCLI to sDriverID
91987>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
91988>>>            Get AutoSetConnectionID sConnectionID to bOk
91989>>>            If (bOk = False) Begin
91991>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
91992>>>>
91992>>>                Function_Return False
91993>>>            End
91993>>>>
91993>>>            Move bOK to bExists
91994>>>        End
91994>>>>
91994>>>
91994>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
91995>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
91996>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
91997>>>        Send Destroy of hoDriver
91998>>>
91998>>>        Function_Return (bExists = True)
91999>>>    End_Function
92000>>>
92000>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92000>>>    // Returns: False if nobody else is running
92000>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92000>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92000>>>    //      tables are not locked as DataFlex tables are.
92000>>>    Function IsDatabaseInUse Returns Boolean
92002>>>        Handle  hTable
92002>>>        String  sRootName
92002>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
92002>>>        Integer iCount iTables
92002>>>
92002>>>        Move 0 to iTables
92003>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
92004>>>        Get AutoConnectionIDLogin to bOK
92005>>>        Get UtilFilelistNoOfTables to iTables
92006>>>        Set piPosition   of ghoProgressBar to 0
92007>>>        Set piAdvanceBy  of ghoProgressBar to 1
92008>>>        Set piMaximum    of ghoProgressBar to iTables
92009>>>        Move 0 to hTable
92010>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92013>>>        Move False to bErr
92014>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92015>>>
92015>>>        Repeat
92015>>>>
92015>>>            Set piPosition of ghoProgressBar to iCount
92016>>>            Increment iCount
92017>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92020>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
92021>>>
92021>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
92021>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQLTable
92022>>>            Move False to bOpen
92023>>>            Get _UtilTableExists hTable to bExists
92024>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
92024>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
92026>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92027>>>                Open hTable
92029>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
92032>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92033>>>                If (bOpen = True) Begin
92035>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
92035>>>                    Get UtilTableIsAlias hTable to bAlias
92036>>>                    If (bAlias = False) Begin
92038>>>                        Close hTable
92039>>>                        Get OpenTableExclusive hTable to bOpen
92040>>>                        If (bOpen = False) Begin
92042>>>                            Move True to bErr
92043>>>                        End
92043>>>>
92043>>>                    End
92043>>>>
92043>>>                End
92043>>>>
92043>>>                Close hTable
92044>>>            End
92044>>>>
92044>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92047>>>            If (bErr = True ) ;                Break
92050>>>        Until (not(hTable))
92052>>>
92052>>>        Set Action_Text of ghoStatusPanel to ""
92053>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92054>>>        Move False to Err
92055>>>
92055>>>        Function_Return bErr
92056>>>    End_Function
92057>>>
92057>>>End_Class
92058>// Needs to be after the cSQLConnectionHandler Object
92058>Object oDbUpdateFunctionLibrary is a cDbUpdateFunctionLibrary
92060>End_Object
92061>
92061>Use cSQLConnectionHandler.pkg
92061>Object oSQLConnectionHandler is a cSQLConnectionHandler
92063>    // If a file was passed on the command line - which can be done from the Studio -
92063>    // we change the ini-file path here. (The file name is always the same)
92063>    Procedure End_Construct_Object
92066>        String sPath
92066>        Boolean bExists
92066>        Get psCommandLineIniFilePath of ghoApplication to sPath
92067>        If (sPath <> "") Begin
92069>            Set psIniFilePath to sPath
92070>        End
92070>        Else Begin
92071>            Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
92072>            Set psIniFilePath to sPath
92073>            Get vFolderFormat sPath to sPath
92074>            Get vFilePathExists (sPath + CS_SQLIniFileName) to bExists
92075>            Set pbIniFileExists of ghoApplication to bExists
92076>        End
92076>        Forward Send End_Construct_Object
92078>    End_Procedure
92079>End_Object
92080>
92080>Object oToolTipController is a cToolTipController
92082>    Move Self to ghoToolTipController
92083>    Set pbBalloonStyle to False
92084>    Set piIcon to TTI_INFO
92085>    Set psTitle to "Information"
92086>    Set piMaxWidth to 400
92087>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
92088>End_Object
92089>
92089>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 23.0\Pkg\oEditContextMenu.pkg)
92089>>>Use cCJStandardMenuItemClasses.pkg
92089>>>
92089>>>Object oEditContextMenu is a cCJContextMenu
92091>>>    
92091>>>    Move Self to Default_Form_Floating_Menu_ID
92092>>>    
92092>>>    Object oUndoMenuItem is a cCJUndoMenuItem
92094>>>    End_Object
92095>>>    
92095>>>    Object oCutMenuItem is a cCJCutMenuItem
92097>>>        Set pbControlBeginGroup to True
92098>>>    End_Object
92099>>>    
92099>>>    Object oCopyMenuItem is a cCJCopyMenuItem
92101>>>    End_Object
92102>>>
92102>>>    Object oPasteMenuItem is a cCJPasteMenuItem
92104>>>    End_Object
92105>>>
92105>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
92107>>>    End_Object
92108>>>
92108>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
92110>>>        Set pbControlBeginGroup to True
92111>>>    End_Object
92112>>>
92112>>>End_Object
92113>>>
92113>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 23.0\Pkg\oDEOEditContextMenu17.pkg)
92113>>>Use Windows.pkg
92113>>>Use cCJStandardMenuItemClasses.pkg
92113>>>Use cCJDeoMenuItemClasses.pkg
92113>>>
92113>>>
92113>>>Object oDEOEditContextMenu17 is a cCJContextMenu
92115>>>    
92115>>>    Move Self to Default_dbFloating_Menu_ID
92116>>>    
92116>>>    Object oUndoMenuItem is a cCJUndoMenuItem
92118>>>    End_Object
92119>>>    
92119>>>    Object oCutMenuItem is a cCJCutMenuItem
92121>>>        Set pbControlBeginGroup to True
92122>>>    End_Object
92123>>>    
92123>>>    Object oCopyMenuItem is a cCJCopyMenuItem
92125>>>    End_Object
92126>>>
92126>>>    Object oPasteMenuItem is a cCJPasteMenuItem
92128>>>    End_Object
92129>>>
92129>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
92131>>>    End_Object
92132>>>
92132>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
92134>>>        Set pbControlBeginGroup to True
92135>>>    End_Object
92136>>>
92136>>>    Object oPromptMenuItem is a cCJPromptMenuItem
92138>>>        Set pbControlBeginGroup to True
92139>>>    End_Object
92140>>>
92140>>>    Object oFindNextMenu is a cCJFindNextMenuItem
92142>>>        Set pbControlBeginGroup to True
92143>>>    End_Object
92144>>>
92144>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
92146>>>    End_Object
92147>>>
92147>>>    Object oClearMenuItem is a cCJClearMenuItem
92149>>>        Set pbControlBeginGroup to True
92150>>>    End_Object
92151>>>
92151>>>    Object oClearAllMenu is a cCJClearAllMenuItem
92153>>>    End_Object
92154>>>
92154>>>    Object oSaveMenu is a cCJSaveMenuItem
92156>>>    End_Object
92157>>>    
92157>>>    Object oDeleteMenu is a cCJDeleteMenuItem
92159>>>    End_Object
92160>>>
92160>>>    Object oRememberitem is a cCJRememberFieldMenuItem
92162>>>        Set pbControlBeginGroup to True
92163>>>    End_Object
92164>>>
92164>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
92166>>>    End_Object
92167>>>
92167>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
92169>>>    End_Object
92170>>>
92170>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
92172>>>    End_Object
92173>>>
92173>>>End_Object
92174>
92174>Object oMain is a Panel
92176>    Set Label to (psProduct(ghoApplication))
92177>    Set Location to 30 17
92178>    Set Size to 190 450
92179>    Set Icon to "SQLConnections1.ico"
92180>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
92181>
92181>    Object oCommandBarSystem is a cCJCommandBarSystem
92183>        Set pbTimerUpdate to True
92184>        Set pbShowTextBelowIcons to True
92185>            Set pbAutoResizeIcons to True
92186>            Set pbLargeIcons to True
92187>
92187>        Procedure OnCreateCommandBars
92190>            Handle hoOptions
92190>            Integer iSize
92190>
92190>            Send DoChangeToolTipFormat
92191>
92191>            Get OptionsObject to hoOptions
92192>            Move 32 to iSize
92193>            Send ComSetIconSize of hoOptions False iSize iSize  // Set icon size for Toolbar buttons.
92194>            Forward Send OnCreateCommandBars
92196>        End_Procedure
92197>
92197>        Procedure DoChangeToolTipFormat
92200>            Variant vToolTip
92200>            Handle  hoObject
92200>            Integer eTheme iToolTipStyle
92200>            Boolean bIsBalloonStyleSupported
92200>
92200>            Get ComToolTipContext to vTooltip
92201>            Get Create (RefClass(cCJToolTipContext)) to hoObject
92202>            Set pvComObject of hoObject to vTooltip
92203>            Move xtpToolTipStandard to iToolTipStyle
92204>            If (iToolTipStyle = -1) Begin
92206>                Get peVisualTheme to eTheme
92207>                Set ComStyle of hoObject to eTheme
92208>            End
92208>            Else Begin
92209>                // Baloon tooltip style requires IE 5.0 or later, so check if installed.
92209>                // The ComShowTitleAndDescription also requires IE 5.0.
92209>                Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
92210>                If (bIsBalloonStyleSupported = False) Begin
92212>                    // If not supported we cannot show baloon tooltip; use standard style instead.
92212>                    If (iToolTipStyle = xtpToolTipBalloon) Begin
92214>                        Move xtpToolTipStandard to iToolTipStyle
92215>                    End
92215>                End
92215>                Set ComStyle of hoObject to iToolTipStyle
92216>                If (bIsBalloonStyleSupported = True) Begin
92218>                    Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
92219>                End
92219>            End
92219>            Set  ComShowOfficeBorder        of hoObject to True
92220>            Set  ComShowShadow              of hoObject to True
92221>            // Set the max width for a tooltip. 250 just seems to be a good
92221>            // compromise. After 250 pixels the text will wrap to the next line automatically.
92221>            Set  ComMaxTipWidth             of hoObject to 250 // In pixels
92222>            Send Destroy of hoObject
92223>            If (phoStatusBar(ghoCommandBars)) Begin
92225>                Send DoChangeToolTipFormat of (phoStatusBar(Self))
92226>            End
92226>
92226>        End_Procedure
92227>
92227>        Object oOpen_Toolbar is a cCJToolbar     
92229>
92229>            Object oOpen_MenuItem is a cCJMenuItem
92231>                Set psTooltip to "&Open"
92232>                Set psDescription to "Open connection ini-file (Ctrl+O)"
92233>                Set psImage to "ActionOpen1.ico"
92234>                Set pbActiveUpdate to True
92235>                Procedure OnExecute Variant vCommandBarControl
92238>                    Forward Send OnExecute vCommandBarControl
92240>                    Send ActivateOpenDialog of (phoMainView(ghoApplication))
92241>                End_Procedure
92242>            End_Object
92243>
92243>            Object oRefreshMenuItem is a cCJMenuItem
92245>                Set psTooltip to "&Refresh"
92246>                Set psDescription to "Refresh grid - re-read values from ini-file (Alt+R)"
92247>                Set psImage to "ActionRefresh1.ico"
92248>                Set pbActiveUpdate to True
92249>               
92249>                Procedure OnExecute Variant vCommandBarControl
92252>                    Forward Send OnExecute vCommandBarControl
92254>                    Send RefreshIniFile of (phoMainView(ghoApplication))
92255>                End_Procedure
92256>
92256>                Function IsEnabled Returns Boolean
92259>                    Boolean bSave
92259>                    Get Should_Save of (oSQLConnections_grd(phoMainView(ghoApplication))) to bSave
92260>                    Function_Return (bSave = True)
92261>                End_Function
92262>                
92262>            End_Object
92263>
92263>        End_Object
92264>
92264>        Object oEdit_Toolbar is a cCJToolbar     
92266>        
92266>            Object oAddMenuItem is a cCJMenuItem
92268>                Set psTooltip to "&Add"
92269>                Set psDescription to "Add new connection (Alt+A)"
92270>                Set psImage to "ActionAdd1.ico"
92271>                Set pbActiveUpdate to True
92272>                Procedure OnExecute Variant vCommandBarControl
92275>                    Forward Send OnExecute vCommandBarControl
92277>                    Send AddItem of (phoMainView(ghoApplication))
92278>                End_Procedure
92279>            End_Object
92280>
92280>            Object oEditMenuItem is a cCJMenuItem
92282>                Set psTooltip to "&Edit"
92283>                Set psDescription to "Edit selected connection (Alt+E)"
92284>                Set psImage to "ActionEdit1.ico"
92285>                Set pbActiveUpdate to True
92286>
92286>                Procedure OnExecute Variant vCommandBarControl
92289>                    Forward Send OnExecute vCommandBarControl
92291>                    Send EditItem of (phoMainView(ghoApplication))
92292>                End_Procedure
92293>
92293>                Function IsEnabled Returns Boolean
92296>                    Handle ho              
92296>                    Boolean bRecord
92296>                    Move (oSQLConnections_grd(phoMainView(ghoApplication))) to ho
92297>                    Send ChangeHeaderText of ho
92298>                    Get HasRecord of ho to bRecord
92299>                    Function_Return (bRecord = True)
92300>                End_Function
92301>
92301>            End_Object
92302>
92302>            Object oSaveMenuItem is a cCJMenuItem
92304>                Set psTooltip to "Save"
92305>                Set psDescription to "Save changes (Ctrl+S)"
92306>                Set psImage to "ActionSave1.ico"
92307>                Set pbActiveUpdate to True
92308>                Set peControlType to xtpControlSplitButtonPopup
92309>
92309>                Procedure OnExecute Variant vCommandBarControl
92312>                    Forward Send OnExecute vCommandBarControl
92314>                    Send SaveIniFile of (phoMainView(ghoApplication))
92315>                End_Procedure
92316>
92316>                Function IsEnabled Returns Boolean
92319>                    Boolean bSave
92319>                    Get Should_Save of (oSQLConnections_grd(phoMainView(ghoApplication))) to bSave
92320>                    Function_Return (bSave = True)
92321>                End_Function
92322>
92322>                Object oSaveAsMenuItem is a cCJMenuItem
92324>                    Set psTooltip to "Save As"
92325>                    Set psDescription to "Save configuration file as..."  
92326>                    Set psImage to "ActionSaveAs1.ico"
92327>                    
92327>                    Procedure OnExecute Variant vCommandBarControl  
92330>                        String sPath sIniFileName sFileName
92330>
92330>                        Forward Send OnExecute vCommandBarControl
92332>                        
92332>                        Get psIniFilePath of ghoSQLConnectionHandler to sPath
92333>                        Get psIniFileName of ghoSQLConnectionHandler to sIniFileName
92334>                        Get vSelectSaveFile ".int" "Please enter a file name to save to" sPath sIniFileName to sFileName
92335>                        If (sFileName <> "") Begin
92337>                            Get ParseFolderName sFileName to sPath
92338>                            Get ParseFileName   sFileName to sIniFileName
92339>                            Set psIniFilePath of ghoSQLConnectionHandler to sPath
92340>                            Set psIniFileName of ghoSQLConnectionHandler to sIniFileName
92341>                            Send SaveIniFile  of (phoMainView(ghoApplication))
92342>                        End
92342>                    End_Procedure
92343>
92343>                End_Object   
92344>                
92344>            End_Object
92345>
92345>            Object oClearMenuItem is a cCJMenuItem 
92347>                Set psTooltip to "Clear All"
92348>                Set psDescription to "Clear ini-file (Ctrl+F5)"
92349>                Set psImage to "ActionClear1.ico"
92350>                Set pbActiveUpdate to True
92351>                
92351>                Procedure OnExecute Variant vCommandBarControl
92354>                    Forward Send OnExecute vCommandBarControl   
92356>                    Send ClearIniFile of (phoMainView(ghoApplication))
92357>                End_Procedure   
92358>                
92358>                Function IsEnabled Returns Boolean
92361>                    Handle ho              
92361>                    Boolean bRecord
92361>                    Move (oSQLConnections_grd(phoMainView(ghoApplication))) to ho
92362>                    Send ChangeHeaderText of ho
92363>                    Get HasRecord of ho to bRecord
92364>                    Function_Return (bRecord = True)
92365>                End_Function
92366>
92366>            End_Object
92367>    
92367>            Object oDeleteMenuItem is a cCJMenuItem
92369>                Set psTooltip to "Delete"
92370>                Set psDescription to "Delete selected connection (Alt+D)"
92371>                Set psImage to "ActionDelete1.ico"
92372>                Set pbActiveUpdate to True
92373>
92373>                Procedure OnExecute Variant vCommandBarControl
92376>                    Forward Send OnExecute vCommandBarControl
92378>                    Send DeleteItem of (phoMainView(ghoApplication))
92379>                End_Procedure   
92380>                
92380>                Function IsEnabled Returns Boolean
92383>                    Handle ho              
92383>                    Boolean bRecord
92383>                    Move (oSQLConnections_grd(phoMainView(ghoApplication))) to ho
92384>                    Send ChangeHeaderText of ho
92385>                    Get HasRecord of ho to bRecord
92386>                    Function_Return (bRecord = True)
92387>                End_Function
92388>
92388>            End_Object
92389>
92389>        End_Object      
92390>        
92390>        Object oExit_Toolbar is a cCJToolbar
92392>            Set peStretched to stStretchShared
92393>
92393>            Object oAddToStudioMenuItem is a cCJMenuItem
92395>                Set psTooltip to "Add to Studio"
92396>                Set psDescription to "Add program to the Studio's toolbar menu"
92397>                Set psImage to "ActionAddStudio1.ico"
92398>                
92398>                Procedure OnExecute Variant vCommandBarControl
92401>                    Forward Send OnExecute vCommandBarControl
92403>                    Send Popup of (oAddToStudio_dg(Client_Id(phoMainPanel(ghoApplication))))
92404>                End_Procedure
92405>            
92405>            End_Object
92406>
92406>            Object oAbout_MenuItem is a cCJMenuItem
92408>                Set psTooltip to C_$About
92409>                Set psDescription to "Info about the program..."
92410>                Set psImage to "ActionAbout1.ico"
92411>        
92411>                Procedure OnExecute Variant vCommandBarControl
92414>                    Send ChangeStatusRowText of (phoMainView(ghoApplication)) ""
92415>                    Send Activate_About of (Client_Id(phoMainPanel(ghoApplication)))
92416>                End_Procedure
92417>        
92417>            End_Object     
92418>            
92418>            Object oHelpMenuItem is a cCJHelpMenuItem
92420>                Set peControlType to xtpControlSplitButtonPopup
92421>                Set psToolTip to C_$Help
92422>                Set psDescription to "Local HTML Help"
92423>                Set psImage to "ActionHelp1.ico"
92424>
92424>                Procedure OnExecute Variant vCommandBarControl
92427>                    Send ShowProgramHelp
92428>                End_Procedure
92429>
92429>                Object oHelpMenuItemLocal is a cCJMenuItem
92431>                    Set psToolTip to C_$Help
92432>                    Set psCaption to "Local HTML Help"
92433>                    Set psDescription to "Local HTML Help"
92434>                    Set psImage to "ActionHelp1.ico"
92435>                    Procedure OnExecute Variant vCommandBarControl
92438>                        Send ShowProgramHelp
92439>                    End_Procedure
92440>                End_Object
92441>
92441>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
92443>                    Set psToolTip to C_$Help
92444>                    Set psCaption to "Online HTML Help"
92445>                    Set psDescription to "Online HTML Help"
92446>                    Set psImage to "ActionHelpInternet1.ico"
92447>                    Procedure OnExecute Variant vCommandBarControl
92450>                        Runprogram Shell Background "https://www.rdctools.com/HTMLHelpDUF/DUFSQLConnectionsTool.html"
92451>                    End_Procedure
92452>                End_Object
92453>
92453>                Object oCheckforUpdatesMenuItem is a cCJMenuItem
92455>                    Set psToolTip to "Updates"
92456>                    Set psCaption to "Check for Updates..."
92457>                    Set psDescription to "Check for Updates..."
92458>                    Set psImage to "InternetUpdate1.ico"
92459>                    Set pbControlBeginGroup to True
92460>                    
92460>                    Procedure OnExecute Variant vCommandBarControl
92463>                        String sPath sUpdateProgram sParam
92463>                        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
92464>                        Get vFolderFormat sPath to sPath
92465>                        Move "updater.exe" to sUpdateProgram
92466>                        Move "/checknow"   to sParam
92467>                        Runprogram Shell Wait ('"' + sPath + sUpdateProgram + '"') sParam
92468>                    End_Procedure
92469>                
92469>                End_Object
92470>                
92470>            End_Object
92471>
92471>            Object oExit_MenuItem is a cCJExitMenuItem
92473>                Set psToolTip to "Exit"
92474>                Set psDescription to "Exit application (Alt+F4)"   
92475>                Set psImage to "ActionExit1.ico"
92476>            End_Object
92477>
92477>        End_Object
92478>        
92478>        Object oStatusBar is a cCJStatusBar
92480>
92480>            Object oStatusPane1 is a cCJStatusBarPane
92482>                Set pbStyleStretch to True
92483>            End_Object
92484>
92484>            Object oStatusPane2 is a cCJStatusBarPane
92486>                Set phoViewPane to Self
92487>                Set pbStyleStretch to True
92488>                Set piTextColor to clRed
92489>            End_Object
92490>
92490>        End_Object
92491>
92491>    End_Object
92492>
92492>    Object oClientArea is a ClientArea
92494>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout20\StdAbout.pkg)
92494>>>//************************************************************************
92494>>>// Confidential Trade Secret.
92494>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
92494>>>// as an unpublished work.  All rights reserved.
92494>>>// DataFlex is a registered trademark of Data Access Corporation.
92494>>>//
92494>>>//************************************************************************
92494>>>//************************************************************************
92494>>>//
92494>>>// $File name  : StdAbout.pkg
92494>>>// $File title : Standard about object package for VDF
92494>>>// Notice      :
92494>>>// $Author(s)  : John Tuohy
92494>>>//
92494>>>// $Rev History
92494>>>//
92494>>>// JT 06/27/97   File created
92494>>>//************************************************************************
92494>>>
92494>>>// This provides a quick and simple way to create an about package for a program.
92494>>>// You need to create a message inside you client area called Activate_About.
92494>>>// Within this message you should send the message DoAbout passing needed
92494>>>// string information.
92494>>>//
92494>>>//       Procedure Activate_About
92494>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
92494>>>//       End_Procedure
92494>>>//    where: sTitle =     Name of application. If none provided, uses caption
92494>>>//                        bar title
92494>>>//           sVersion   = Version Line. If none provided, will be blank
92494>>>//           sCopyRight = Copyright Line. If none provided, will be blank
92494>>>//           sAuthor    = Author name, blank if none provided
92494>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
92494>>>//                        is used.
92494>>>// It is expected that you will place this in your own object package. For
92494>>>// example an order about package may look like this:
92494>>>//
92494>>>//   // OrderAbout.pkg
92494>>>//   Use StdAbout.pkg
92494>>>//   Procedure Activate_About
92494>>>//      String sTitle sCopyright sVersion sAuthor
92494>>>//      Move "My Order Entry System" to sTitle
92494>>>//      Move "Version 2.1" to sVersion
92494>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
92494>>>//      Move "John Smith"  to sAuthor
92494>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
92494>>>//   end_procedure
92494>>>//   // end of file.
92494>>>
92494>>>Use DfAbout.pkg
92494>>>
92494>>>// *************************************************************************
92494>>>//  Public message. This is the default message. It is expected that you will
92494>>>//   create your own message to override this
92494>>>// *************************************************************************
92494>>>
92494>>>Procedure Activate_About
92497>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
92498>>>End_Procedure
92499>>>
92499>>>// *************************************************************************
92499>>>//  Public message. It is expected that you will send this message (most
92499>>>//  likely from Activate_About. This creates an about object, activates it
92499>>>//  and destroys it when done. It is not exepected that you will augment this.
92499>>>// *************************************************************************
92499>>>// Sample usage:
92499>>>//   The first two params will automatically be filled from the application settings if not provided.
92499>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
92499>>>
92499>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
92502>>>    Integer hoObj hoMain iArgs
92502>>>    String sValue
92502>>>
92502>>>    // Create object
92502>>>    Object About is an AboutDialog
92504>>>    // Uncomment these two lines if you would like to have a resizable About object.
92504>>>    //            Set Border_Style to Border_Thick
92504>>>    //            Set peAnchors to anAll
92504>>>
92504>>>    // Add checking for the number of arguments passed to avoid runtime errors
92504>>>    // if one of them is not passed. This makes the interface
92504>>>    // more flexible.
92504>>>        Move num_arguments to iArgs
92505>>>
92505>>>        // If no title is passed use the label of the main panel (if a main panel exists).
92505>>>        If (iArgs > 0 and sTitle = "") Begin
92507>>>            Get Main_Window of Desktop to hoMain
92508>>>            If hoMain Begin
92510>>>                Get Label of hoMain to sValue
92511>>>            End
92511>>>>
92511>>>        End
92511>>>>
92511>>>        Else If (iArgs > 0 and sTitle <> "") Begin
92514>>>            Move sTitle to sValue
92515>>>        End
92515>>>>
92515>>>        Else If (iArgs = 0) Begin
92518>>>            Get Main_Window of Desktop to hoMain
92519>>>            If hoMain Begin
92521>>>                Get Label of hoMain to sValue
92522>>>            End
92522>>>>
92522>>>        End
92522>>>>
92522>>>
92522>>>        If (sValue <> "") Begin
92524>>>            Send Add_LineLn sValue
92525>>>        End
92525>>>>
92525>>>        Move "" to sValue
92526>>>
92526>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
92526>>>        // For this to work the Project Properties Version must have been set in the Studio.
92526>>>        If (iArgs < 2) Begin
92528>>>            Move "" to sValue
92529>>>        End
92529>>>>
92529>>>        Else Begin
92530>>>            Move sVersion to sValue
92531>>>        End
92531>>>>
92531>>>        Set Version to sValue
92532>>>
92532>>>        If (iArgs > 2 and sCopyRight <> "") Begin
92534>>>            Send Add_LineLn sCopyRight
92535>>>        End
92535>>>>
92535>>>
92535>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
92535>>>        // else we do.
92535>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
92537>>>            Send Add_Line sAuthor
92538>>>        End
92538>>>>
92538>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
92541>>>            Send Add_LineLn sAuthor
92542>>>        End
92542>>>>
92542>>>
92542>>>        // Square bitmaps of 80x80 works best
92542>>>        If (iArgs > 4 and sBitmap <> "") Begin
92544>>>            Set Logo to sBitMap
92545>>>        End
92545>>>>
92545>>>
92545>>>        // Here starts handling of the five optional params:
92545>>>        If (iArgs = 6 and sParam6  <> "") Begin
92547>>>            Send Add_Line sParam6
92548>>>        End
92548>>>>
92548>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
92551>>>            Send Add_LineLn sParam6
92552>>>        End
92552>>>>
92552>>>
92552>>>        If (iArgs = 7 and sParam7  <> "") Begin
92554>>>            Send Add_Line sParam7
92555>>>        End
92555>>>>
92555>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
92558>>>            Send Add_LineLn sParam7
92559>>>        End
92559>>>>
92559>>>
92559>>>        If (iArgs = 8 and sParam8  <> "") Begin
92561>>>            Send Add_Line sParam8
92562>>>        End
92562>>>>
92562>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
92565>>>            Send Add_LineLn sParam8
92566>>>        End
92566>>>>
92566>>>
92566>>>        If (iArgs = 9 and sParam9  <> "") Begin
92568>>>            Send Add_Line sParam9
92569>>>        End
92569>>>>
92569>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
92572>>>            Send Add_LineLn sParam9
92573>>>        End
92573>>>>
92573>>>
92573>>>        If (iArgs = 10 and sParam10 <> "") Begin
92575>>>            Send Add_Line sParam10
92576>>>        End
92576>>>>
92576>>>
92576>>>        Move Self to hoObj
92577>>>    End_Object
92578>>>
92578>>>    Send Popup   of hoObj // Popup the about object
92579>>>    Send Destroy of hoObj // When done, it will be destroyed
92580>>>End_Procedure
92581>        Use ManageSQLConnections.vw
Including file: ManageSQLConnections.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ManageSQLConnections.vw)
92581>>>Use DFClient.pkg
92581>>>Use cCJCommandBarSystem.pkg
92581>>>Use cCJGrid.pkg
92581>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJGridColumnRowIndicator.pkg)
92581>>>>>Use cCJGridColumn.pkg
92581>>>>>
92581>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
92582>>>>>    
92582>>>>>    Procedure Construct_Object
92584>>>>>        Forward Send Construct_Object
92586>>>>>        
92586>>>>>        Property Integer piImage 0
92587>>>>>        
92587>>>>>        Set psCaption to ""
92588>>>>>        Set piWidth to 20
92589>>>>>        Set pbResizable to False
92590>>>>>        Set pbEditable to False
92591>>>>>        Set pbFocusable to False
92592>>>>>        Set pbAllowDrag to False
92593>>>>>        Set psToolTip to "Row Indicator"
92594>>>>>    End_Procedure
92595>>>>>    
92595>>>>>    Procedure OnCreateColumn
92597>>>>>        Integer iImage
92597>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
92599>>>>>        Set piImage to iImage
92600>>>>>    End_Procedure
92601>>>>>    
92601>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
92603>>>>>        Integer iImage iFocusedRow
92603>>>>>        Handle hoDataSource
92603>>>>>        
92603>>>>>        Get phoDataSource to hoDataSource
92604>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
92605>>>>>        Move -1 to iImage
92606>>>>>        If (iRow = iFocusedRow) Begin
92608>>>>>            Get piImage to iImage
92609>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
92610>>>>>        End
92610>>>>>>
92610>>>>>    End_Procedure
92611>>>>>    
92611>>>>>End_Class
92612>>>Use cCJGridColumn.pkg
92612>>>Use cSQLConnectionButton.pkg
Including file: cSQLConnectionButton.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionButton.pkg)
92612>>>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCButtonDPI.pkg)
92612>>>>>>>//****************************************************************************
92612>>>>>>>// $Module type: Package
92612>>>>>>>// $Module name: cRDCButtonDPI.pkg
92612>>>>>>>//
92612>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
92612>>>>>>>// Copyright (c) 2013 RDC Tools International
92612>>>>>>>// E-mail      : support@rdctools.com
92612>>>>>>>// Web-site    : http://www.rdctools.com
92612>>>>>>>//
92612>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
92612>>>>>>>//
92612>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
92612>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
92612>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
92612>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
92612>>>>>>>// in the help folder for more details.
92612>>>>>>>//
92612>>>>>>>//****************************************************************************
92612>>>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCButton.pkg)
92612>>>>>>>>>//****************************************************************************
92612>>>>>>>>>// $Module type: Package
92612>>>>>>>>>// $Module name: cRDCButton.pkg
92612>>>>>>>>>//
92612>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
92612>>>>>>>>>// Copyright (c) 2013 RDC Tools International
92612>>>>>>>>>// E-mail      : support@rdctools.com
92612>>>>>>>>>// Web-site    : http://www.rdctools.com
92612>>>>>>>>>//
92612>>>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
92612>>>>>>>>>//
92612>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
92612>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
92612>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
92612>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
92612>>>>>>>>>// in the help folder for more details.
92612>>>>>>>>>//
92612>>>>>>>>>//****************************************************************************
92612>>>>>>>>>Use Windows.pkg
92612>>>>>>>>>Use Enclient.pkg
92612>>>>>>>>>Use errornum.inc
92612>>>>>>>>>
92612>>>>>>>>>Class cButtonIdleHandler is a cIdleHandler
92613>>>>>>>>>    Procedure Construct_Object
92615>>>>>>>>>        Forward Send Construct_Object
92617>>>>>>>>>
92617>>>>>>>>>    End_Procedure
92618>>>>>>>>>
92618>>>>>>>>>    Procedure OnIdle
92620>>>>>>>>>        Delegate Send DoUpdate
92622>>>>>>>>>    End_Procedure
92623>>>>>>>>>
92623>>>>>>>>>End_Class
92624>>>>>>>>>
92624>>>>>>>>>Class cRDCButton is a Button
92625>>>>>>>>>
92625>>>>>>>>>    Procedure Construct_Object
92627>>>>>>>>>        Forward Send Construct_Object
92629>>>>>>>>>
92629>>>>>>>>>        Property Boolean pbAutoEnable True
92630>>>>>>>>>
92630>>>>>>>>>        Property Boolean pbEnabled True
92631>>>>>>>>>
92631>>>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
92632>>>>>>>>>
92632>>>>>>>>>        On_Key kCancel Send CancelIfPopupObject
92633>>>>>>>>>    End_Procedure
92634>>>>>>>>>
92634>>>>>>>>>    Procedure CancelIfPopupObject
92636>>>>>>>>>        Boolean bIsInPopupObject
92636>>>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
92638>>>>>>>>>        If (bIsInPopupObject = True) Begin
92640>>>>>>>>>            Send Close_Panel
92641>>>>>>>>>        End
92641>>>>>>>>>>
92641>>>>>>>>>    End_Procedure
92642>>>>>>>>>
92642>>>>>>>>>    Procedure End_Construct_Object
92644>>>>>>>>>        String sTooltip sStatus_Help
92644>>>>>>>>>
92644>>>>>>>>>        Forward Send End_Construct_Object
92646>>>>>>>>>
92646>>>>>>>>>        Get psToolTip   to sTooltip
92647>>>>>>>>>        Get Status_Help to sStatus_Help
92648>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
92650>>>>>>>>>            Set psToolTip to sStatus_Help
92651>>>>>>>>>        End
92651>>>>>>>>>>
92651>>>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
92653>>>>>>>>>            Set Status_Help to sToolTip
92654>>>>>>>>>        End
92654>>>>>>>>>>
92654>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
92655>>>>>>>>>    End_Procedure
92656>>>>>>>>>
92656>>>>>>>>>    Procedure DoUpdate
92658>>>>>>>>>        If (pbAutoEnable(Self) = False) Begin
92660>>>>>>>>>            Procedure_Return
92661>>>>>>>>>        End
92661>>>>>>>>>>
92661>>>>>>>>>        Set Enabled_State to (IsEnabled(Self))
92662>>>>>>>>>    End_Procedure
92663>>>>>>>>>
92663>>>>>>>>>    Function IsEnabled Returns Boolean
92665>>>>>>>>>        Boolean bEnabled
92665>>>>>>>>>        Get pbEnabled to bEnabled
92666>>>>>>>>>        Function_Return bEnabled
92667>>>>>>>>>    End_Function
92668>>>>>>>>>
92668>>>>>>>>>    // Enable the idle handler timer when the button is activated
92668>>>>>>>>>    Procedure Activating
92670>>>>>>>>>        Forward Send Activating
92672>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
92673>>>>>>>>>    End_Procedure
92674>>>>>>>>>
92674>>>>>>>>>    // Disable the idle handler when the button is deactivated
92674>>>>>>>>>    Procedure Deactivating
92676>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
92677>>>>>>>>>        Forward Send Deactivating
92679>>>>>>>>>    End_Procedure
92680>>>>>>>>>
92680>>>>>>>>>End_Class
92681>>>>>>>
92681>>>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
92681>>>>>>>Class cRDCButtonDPI is a cRDCButton
92682>>>>>>>    Procedure Construct_Object
92684>>>>>>>        Integer iIconSize
92684>>>>>>>        Forward Send Construct_Object
92686>>>>>>>        Set piImageMarginLeft to 10
92687>>>>>>>    End_Procedure
92688>>>>>>>
92688>>>>>>>    // Returns: DPI setting as an integer.
92688>>>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
92688>>>>>>>    //                      iDPI=120 is "Medium setting" 125%
92688>>>>>>>    //                      iDPI= 144 is "Large setting" 150%
92688>>>>>>>    Function GetCurrentDPI Returns Integer
92690>>>>>>>        Handle hDC
92690>>>>>>>        Integer iPixelsX
92690>>>>>>>        Move (GetDC(0)) to hDC
92691>>>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
92692>>>>>>>        Move (ReleaseDC(0, hDC)) to hDC
92693>>>>>>>        Function_Return iPixelsX
92694>>>>>>>    End_Function
92695>>>>>>>
92695>>>>>>>    Function GetCorrectIconSize Returns Integer
92697>>>>>>>        Integer iPixelsX iIndex iSize
92697>>>>>>>        Integer[] iaSizes
92698>>>>>>>
92698>>>>>>>        Move 16 to iaSizes[0]
92699>>>>>>>        Move 24 to iaSizes[1]
92700>>>>>>>        Move 32 to iaSizes[2]
92701>>>>>>>        Move 48 to iaSizes[3]
92702>>>>>>>        Move 64 to iaSizes[4]
92703>>>>>>>
92703>>>>>>>        Get piImageSize to iSize  // the "100%" size
92704>>>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
92705>>>>>>>        Move (0 max iIndex) to iIndex
92706>>>>>>>        Get GetCurrentDPI to iPixelsX
92707>>>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
92707>>>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
92707>>>>>>>        // will increment iIndex as many times as we need here.
92707>>>>>>>        Case Begin
92707>>>>>>>            Case (iPixelsX > 144)
92709>>>>>>>                Increment iIndex
92710>>>>>>>            Case (iPixelsX = 144)
92713>>>>>>>                Increment iIndex
92714>>>>>>>            Case (iPixelsX = 120)
92717>>>>>>>                Increment iIndex
92718>>>>>>>        Case End
92718>>>>>>>        Move (iIndex min 4) to iIndex
92719>>>>>>>        Function_Return iaSizes[iIndex]
92720>>>>>>>    End_Function
92721>>>>>>>
92721>>>>>>>    Procedure Set psToolTip String sToolTip
92723>>>>>>>        String sStatusHelp
92723>>>>>>>
92723>>>>>>>        Get Status_Help to sStatusHelp
92724>>>>>>>        If (sStatusHelp = "") Begin
92726>>>>>>>            Set Status_Help to sToolTip
92727>>>>>>>        End
92727>>>>>>>>
92727>>>>>>>
92727>>>>>>>        Forward Set psToolTip to sToolTip
92729>>>>>>>    End_Procedure
92730>>>>>>>
92730>>>>>>>End_Class
92731>>>>>
92731>>>>>// New button class so we constantly can display the ini-filename in the status_help area:
92731>>>>>Class cSQLConnectionButton is a cRDCButtonDPI
92732>>>>>    Procedure Construct_Object
92734>>>>>        Forward Send Construct_Object
92736>>>>>    End_Procedure
92737>>>>>
92737>>>>>    Procedure End_Construct_Object
92739>>>>>        String sLabel sImage
92739>>>>>        Forward Send End_Construct_Object
92741>>>>>        Get psImage to sImage
92742>>>>>        If (sImage = "") Begin
92744>>>>>            Get Label to sLabel
92745>>>>>            Move (Replace("&", sLabel, "")) to sLabel
92746>>>>>            Move (Replace("...", sLabel, "")) to sLabel
92747>>>>>            Set psImage to ("Action" + sLabel + "1.ico")
92748>>>>>        End
92748>>>>>>
92748>>>>>    End_Procedure
92749>>>>>
92749>>>>>    Function Status_Help String Item# Returns String
92751>>>>>        String sRetval
92751>>>>>        Get IniFileName to sRetval
92752>>>>>        Function_Return sRetval
92753>>>>>    End_Function
92754>>>>>
92754>>>>>End_Class
92755>>>
92755>>>Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
92755>>>>>Use Windows.pkg
92755>>>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJGridPromptList.pkg)
92755>>>>>>>Use Windows.pkg
92755>>>>>>>Use cCJGrid.pkg
92755>>>>>>>Use umPromptRelational.pkg
92755>>>>>>>
92755>>>>>>>Class cCJGridPromptList is a cCJGrid
92756>>>>>>>    
92756>>>>>>>    Procedure Construct_Object
92758>>>>>>>        Forward Send Construct_Object
92760>>>>>>>        
92760>>>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
92761>>>>>>>        Property Boolean Private_pbAutoOrdering True
92762>>>>>>>        Property Boolean pbAutoSearch True  // pops up search window
92763>>>>>>>        Property Integer peUpdateMode umPromptValue
92764>>>>>>>        Property Integer piUpdateColumn 0
92765>>>>>>>        Property Integer piInitialColumn -1
92766>>>>>>>        Property String  psSeedValue ''
92767>>>>>>>        Property Handle phmPromptUpdateCallback 0
92768>>>>>>>        Property Integer phoInvokingObject
92769>>>>>>>        
92769>>>>>>>        Property Boolean pbStoredAutoSeed
92770>>>>>>>        Property Boolean pbStoredAutoOrdering
92771>>>>>>>        Property Boolean pbStoredAutoSearch
92772>>>>>>>        Property Integer peStoredUpdateMode
92773>>>>>>>        Property Integer piStoredUpdateColumn
92774>>>>>>>        Property Integer piStoredInitialColumn
92775>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
92776>>>>>>>        Property Boolean pbStoredSelectionEnable
92777>>>>>>>        Property Boolean pbStoredMultipleSelection
92778>>>>>>>        
92778>>>>>>>        // internally set by list
92778>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
92778>>>>>>>        Property Boolean pbCanceled
92779>>>>>>>        Property Integer[] pSelectedRows
92780>>>>>>>        
92780>>>>>>>        Property Boolean pbNeedsNewOrdering
92781>>>>>>>        Property Boolean pbRequestSearch
92782>>>>>>>        Property tGridKeyPair[] pSearchKeys
92783>>>>>>>        
92783>>>>>>>        // these properties makes a prompt list a prompt list
92783>>>>>>>        // and should not be changed.
92783>>>>>>>        Set pbEditOnKeyNavigation to False
92784>>>>>>>        Set pbEditOnClick to False
92785>>>>>>>        Set pbReadOnly to True
92786>>>>>>>        Set pbFocusSubItems to True
92787>>>>>>>        
92787>>>>>>>        // these could maybe be changed
92787>>>>>>>        Set pbShadeSortColumn to True
92788>>>>>>>        Set pbHeaderReorders to True
92789>>>>>>>        Set pbHeaderTogglesDirection to True
92790>>>>>>>        Set pbHeaderSelectsColumn to True
92791>>>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
92792>>>>>>>        Set piFocusCellBackColor to clNone
92793>>>>>>>        Set piFocusCellForeColor to clNone
92794>>>>>>>        Set piFocusCellRectangleColor to clBlack
92795>>>>>>>        Set pbUseFocusCellRectangle to False
92796>>>>>>>        Set pbSelectionEnable to True
92797>>>>>>>        
92797>>>>>>>        On_Key kEnter Send Ok
92798>>>>>>>        On_Key kCancel Send Cancel
92799>>>>>>>        
92799>>>>>>>    End_Procedure
92800>>>>>>>    
92800>>>>>>>    // reorder list automatically on column change
92800>>>>>>>    // this also set pbFocusSubItems which is required to make the two states work
92800>>>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
92802>>>>>>>        Set Private_pbAutoOrdering to bAutoOrder
92803>>>>>>>        Set pbFocusSubItems to bAutoOrder
92804>>>>>>>    End_Procedure
92805>>>>>>>    
92805>>>>>>>    Function pbAutoOrdering Returns Boolean
92807>>>>>>>        Boolean bAutoOrder
92807>>>>>>>        Get Private_pbAutoOrdering to bAutoOrder
92808>>>>>>>        Function_Return bAutoOrder
92809>>>>>>>    End_Function
92810>>>>>>>    
92810>>>>>>>    // augmented to handle auto-ordering and invoking the search popup list
92810>>>>>>>    Procedure OnIdle
92812>>>>>>>        Boolean bNeedsReorder bSearch bOldToggle
92812>>>>>>>        Handle hoCol
92812>>>>>>>        Integer iKy1 iKy2 iCol
92812>>>>>>>        
92812>>>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
92813>>>>>>>        If bNeedsReorder Begin
92815>>>>>>>            Get SelectedColumn to iCol
92816>>>>>>>            If (iCol<>-1) Begin
92818>>>>>>>                
92818>>>>>>>                Get pbHeaderTogglesDirection to bOldToggle
92819>>>>>>>                Set pbHeaderTogglesDirection to False
92820>>>>>>>                Send HeaderReorder iCol
92821>>>>>>>                Set pbHeaderTogglesDirection to bOldToggle
92822>>>>>>>                
92822>>>>>>>                Set pbNeedsNewOrdering to False
92823>>>>>>>            End
92823>>>>>>>>
92823>>>>>>>        End
92823>>>>>>>>
92823>>>>>>>        
92823>>>>>>>        Get pbRequestSearch to bSearch
92824>>>>>>>        If bSearch Begin
92826>>>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
92827>>>>>>>        End
92827>>>>>>>>
92827>>>>>>>        
92827>>>>>>>        Forward Send OnIdle
92829>>>>>>>    End_Procedure
92830>>>>>>>    
92830>>>>>>>    Procedure OnStoreDefaults
92832>>>>>>>        Integer iVal
92832>>>>>>>        Boolean bVal
92832>>>>>>>        
92832>>>>>>>        Get pbAutoSeed to bVal
92833>>>>>>>        Set pbStoredAutoSeed to bVal
92834>>>>>>>        
92834>>>>>>>        Get pbAutoOrdering to bVal
92835>>>>>>>        Set pbStoredAutoOrdering to bVal
92836>>>>>>>        
92836>>>>>>>        Get pbAutoSearch to bVal
92837>>>>>>>        Set pbStoredAutoSearch to bVal
92838>>>>>>>        
92838>>>>>>>        Get peUpdateMode to iVal
92839>>>>>>>        Set peStoredUpdateMode to iVal
92840>>>>>>>        
92840>>>>>>>        Get piUpdateColumn to iVal
92841>>>>>>>        Set piStoredUpdateColumn to iVal
92842>>>>>>>        
92842>>>>>>>        Get piInitialColumn to iVal
92843>>>>>>>        Set piStoredInitialColumn to iVal
92844>>>>>>>        
92844>>>>>>>        Get phmPromptUpdateCallback to iVal
92845>>>>>>>        Set phmStoredPromptUpdateCallback to iVal
92846>>>>>>>        
92846>>>>>>>        Get pbSelectionEnable to bVal
92847>>>>>>>        Set pbStoredSelectionEnable to bVal
92848>>>>>>>        
92848>>>>>>>        Get pbMultipleSelection to bVal
92849>>>>>>>        Set pbStoredMultipleSelection to bVal
92850>>>>>>>        
92850>>>>>>>    End_Procedure
92851>>>>>>>    
92851>>>>>>>    Procedure OnRestoreDefaults
92853>>>>>>>        Integer iVal
92853>>>>>>>        Boolean bVal
92853>>>>>>>        
92853>>>>>>>        Get pbStoredAutoSeed to bVal
92854>>>>>>>        Set pbAutoSeed to bVal
92855>>>>>>>        
92855>>>>>>>        Get pbStoredAutoOrdering to bVal
92856>>>>>>>        Set pbAutoOrdering to bVal
92857>>>>>>>        
92857>>>>>>>        Get pbStoredAutoSearch to bVal
92858>>>>>>>        Set pbAutoSearch to bVal
92859>>>>>>>        
92859>>>>>>>        Get peStoredUpdateMode to iVal
92860>>>>>>>        Set peUpdateMode to iVal
92861>>>>>>>        
92861>>>>>>>        Get piStoredInitialColumn to iVal
92862>>>>>>>        Set piInitialColumn to iVal
92863>>>>>>>        
92863>>>>>>>        Get phmStoredPromptUpdateCallback to iVal
92864>>>>>>>        Set phmPromptUpdateCallback to iVal
92865>>>>>>>        
92865>>>>>>>        Get pbStoredSelectionEnable to bVal
92866>>>>>>>        Set pbSelectionEnable to bVal
92867>>>>>>>        
92867>>>>>>>        Get pbStoredMultipleSelection to bVal
92868>>>>>>>        Set pbMultipleSelection to bVal
92869>>>>>>>        
92869>>>>>>>    End_Procedure
92870>>>>>>>    
92870>>>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
92870>>>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
92870>>>>>>>    // Suitable for augmentation
92870>>>>>>>    Procedure OnSeedData
92872>>>>>>>        Integer iUpdateColumn iSortColumn
92872>>>>>>>        Boolean bSeed bAuto
92872>>>>>>>        String sValue
92872>>>>>>>        Handle hoCol
92872>>>>>>>        
92872>>>>>>>        Get piUpdateColumn to iUpdateColumn
92873>>>>>>>        Get psSeedValue to sValue
92874>>>>>>>        Get pbAutoSeed to bSeed
92875>>>>>>>        Get piSortColumn to iSortColumn
92876>>>>>>>        Get pbAutoOrdering to bAuto
92877>>>>>>>        // if not yet sorted and this is auto ordering we will
92877>>>>>>>        // sort the data for the search column. We do this to make the
92877>>>>>>>        // column search GE logic work properly.
92877>>>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
92879>>>>>>>            Get ColumnObject iUpdateColumn to hoCol
92880>>>>>>>            Send SortGridByColumn hoCol False
92881>>>>>>>        End
92881>>>>>>>>
92881>>>>>>>        
92881>>>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
92883>>>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
92884>>>>>>>        End
92884>>>>>>>>
92884>>>>>>>        Else Begin
92885>>>>>>>            Send MovetoFirstRow
92886>>>>>>>        End
92886>>>>>>>>
92886>>>>>>>        
92886>>>>>>>    End_Procedure
92887>>>>>>>    
92887>>>>>>>    Procedure OnMoveValueOutByValue
92889>>>>>>>        String sValue
92889>>>>>>>        Handle hoInvokingObject hoCol  hoDataSource
92889>>>>>>>        Integer iRow iCol
92889>>>>>>>        Integer[] SelRowsIndexes
92890>>>>>>>        
92890>>>>>>>        Get phoInvokingObject to hoInvokingObject
92891>>>>>>>        Get pSelectedRows to SelRowsIndexes
92892>>>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
92894>>>>>>>            Get piUpdateColumn to iCol
92895>>>>>>>            Get ColumnObject iCol to hoCol
92896>>>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
92897>>>>>>>            Set Value of hoInvokingObject to sValue
92898>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
92899>>>>>>>        End
92899>>>>>>>>
92899>>>>>>>    End_Procedure
92900>>>>>>>    
92900>>>>>>>    Procedure OnMoveValueOutByCustom
92902>>>>>>>    End_Procedure
92903>>>>>>>    
92903>>>>>>>    // augment to popup a search window when allowed
92903>>>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
92905>>>>>>>        Boolean bSubFocus bAutoSearch bChar
92905>>>>>>>        Integer iVal
92905>>>>>>>        
92905>>>>>>>        Get pbFocusSubItems to bSubFocus
92906>>>>>>>        Get pbAutoSearch to bAutoSearch
92907>>>>>>>        Forward Send OnComKeyDown llKeyCode llShift
92909>>>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
92911>>>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
92913>>>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
92914>>>>>>>                Move (iVal<>0) to bChar
92915>>>>>>>            End
92915>>>>>>>>
92915>>>>>>>            If bChar Begin
92917>>>>>>>                // this can get called multiple times before a search dialog pops up
92917>>>>>>>                Send AddToSearchKeys llKeyCode llShift
92918>>>>>>>            End
92918>>>>>>>>
92918>>>>>>>        End
92918>>>>>>>>
92918>>>>>>>    End_Procedure
92919>>>>>>>    
92919>>>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
92921>>>>>>>        Boolean bAutoSearch
92921>>>>>>>        Integer iKeyCode iShiftCode
92921>>>>>>>        Get pbAutoSearch to bAutoSearch
92922>>>>>>>        If bAutoSearch Begin
92924>>>>>>>            // this can get called multiple times before a search dialog pops up
92924>>>>>>>            Get piLastKey to iKeyCode
92925>>>>>>>            Get piLastKey2 to iShiftCode
92926>>>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
92927>>>>>>>        End
92927>>>>>>>>
92927>>>>>>>        Move True to llCancel
92928>>>>>>>    End_Procedure
92929>>>>>>>    
92929>>>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
92931>>>>>>>        Send ClearSearchRequest // kill any deferred search popup
92932>>>>>>>        Forward Send OnComRowDblClick llRow llItem
92934>>>>>>>    End_Procedure
92935>>>>>>>    
92935>>>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
92937>>>>>>>        Send Ok
92938>>>>>>>    End_Procedure
92939>>>>>>>    
92939>>>>>>>    
92939>>>>>>>    // we don't want a menu for prompt lists
92939>>>>>>>    Function CreateContextMenu Returns Handle
92941>>>>>>>        Function_Return 0
92942>>>>>>>    End_Function
92943>>>>>>>    
92943>>>>>>>    // if we use auto-ordering, change the order when the column changes
92943>>>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
92945>>>>>>>        Boolean bAutoOrder
92945>>>>>>>        Forward Send ColumnChanged iOld iNew
92947>>>>>>>        Get pbAutoOrdering to bAutoOrder
92948>>>>>>>        If bAutoOrder Begin
92950>>>>>>>            // will be reordered in idle event
92950>>>>>>>            Set pbNeedsNewOrdering to True
92951>>>>>>>        End
92951>>>>>>>>
92951>>>>>>>    End_Procedure
92952>>>>>>>    
92952>>>>>>>    
92952>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
92954>>>>>>>        Integer eMode
92954>>>>>>>        Integer[] SelRowsIndexes
92955>>>>>>>        Set pbCanceled to True // assume cancel unless changed
92956>>>>>>>        Set pSelectedRows to SelRowsIndexes // empty
92957>>>>>>>        Get peUpdateMode to eMode
92958>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
92960>>>>>>>            Send OnStoreDefaults
92961>>>>>>>        End
92961>>>>>>>>
92961>>>>>>>        Send InitializePromptList
92962>>>>>>>        Forward Send Add_Focus hoParent
92964>>>>>>>        Send LoadData
92965>>>>>>>        Set psSeedValue to ""
92966>>>>>>>    End_Procedure
92967>>>>>>>    
92967>>>>>>>    // called before the list is activated.
92967>>>>>>>    Procedure InitializePromptList
92969>>>>>>>        Integer hoInvokingObject
92969>>>>>>>        Boolean bAutoColumn bAutoSeed
92969>>>>>>>        Integer i iOldMode eUpdateMode
92969>>>>>>>        String sValue
92969>>>>>>>        
92969>>>>>>>        Get peUpdateMode to eUpdateMode
92970>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
92972>>>>>>>            Get Focus of Desktop to hoInvokingObject
92973>>>>>>>            If (hoInvokingObject<=Desktop) Begin
92975>>>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
92976>>>>>>>>
92976>>>>>>>                Procedure_Return
92977>>>>>>>            End
92977>>>>>>>>
92977>>>>>>>            
92977>>>>>>>            Set phoInvokingObject to hoInvokingObject
92978>>>>>>>            
92978>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
92979>>>>>>>            Get peUpdateMode to eUpdateMode
92980>>>>>>>        End
92980>>>>>>>>
92980>>>>>>>        
92980>>>>>>>        Send ClearSearchRequest // clear the search keys
92981>>>>>>>        Set pbNeedsNewOrdering to False
92982>>>>>>>        
92982>>>>>>>        Get pbAutoSeed to bAutoSeed
92983>>>>>>>        
92983>>>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
92985>>>>>>>            Get Value of hoInvokingObject to sValue
92986>>>>>>>            Set psSeedValue to sValue
92987>>>>>>>        End
92987>>>>>>>>
92987>>>>>>>        
92987>>>>>>>    End_Procedure
92988>>>>>>>    
92988>>>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
92988>>>>>>>    Procedure LoadData
92990>>>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
92990>>>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
92990>>>>>>>        Integer eUpdateMode
92990>>>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
92990>>>>>>>        
92990>>>>>>>        Get phoDataSource to hoDataSource
92991>>>>>>>        Get peUpdateMode to eUpdateMode
92992>>>>>>>        Get phoInvokingObject to hoInvokingObject
92993>>>>>>>        Get pbAutoSeed to bAutoSeed
92994>>>>>>>        Get piInitialColumn to iInitialColumn
92995>>>>>>>        Get piUpdateColumn to iUpdateColumn
92996>>>>>>>        Get RowCount of hoDataSource to iRows
92997>>>>>>>        
92997>>>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
92997>>>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
92997>>>>>>>        If (iInitialColumn=-1) Begin
92999>>>>>>>            Move iUpdateColumn to iInitialColumn
93000>>>>>>>        End
93000>>>>>>>>
93000>>>>>>>        If (iInitialColumn>=0) Begin
93002>>>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
93003>>>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
93004>>>>>>>        End
93004>>>>>>>>
93004>>>>>>>        Send OnSeedData // find a good starting place for the row
93005>>>>>>>        Get pbFocusSubItems to bSubFocus
93006>>>>>>>        If bSubFocus Begin
93008>>>>>>>            // if column focus, which is normal, go to initialcolumn
93008>>>>>>>            If hoInitialColumn Begin
93010>>>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
93011>>>>>>>            End
93011>>>>>>>>
93011>>>>>>>            Else Begin
93012>>>>>>>                Send MoveToFirstEnterableColumn
93013>>>>>>>            End
93013>>>>>>>>
93013>>>>>>>        End
93013>>>>>>>>
93013>>>>>>>        
93013>>>>>>>    End_Procedure
93014>>>>>>>    
93014>>>>>>>    // This is only called in a successful close
93014>>>>>>>    Procedure ClosePromptList
93016>>>>>>>        Handle hoDataSource hoInvokingObject
93016>>>>>>>        Handle hmCallBack
93016>>>>>>>        Integer iRow eUpdateMode
93016>>>>>>>        Integer[] SelRowsIndexes
93017>>>>>>>        
93017>>>>>>>        Get phoDataSource to hoDataSource
93018>>>>>>>        Get phoInvokingObject to hoInvokingObject
93019>>>>>>>        
93019>>>>>>>        If (pbMultipleSelection(Self)) Begin
93021>>>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
93022>>>>>>>        End
93022>>>>>>>>
93022>>>>>>>        Else Begin
93023>>>>>>>            Get SelectedRow of hoDataSource to iRow
93024>>>>>>>            If (iRow<>-1) Begin
93026>>>>>>>                Move iRow to SelRowsIndexes[0]
93027>>>>>>>            End
93027>>>>>>>>
93027>>>>>>>        End
93027>>>>>>>>
93027>>>>>>>        
93027>>>>>>>        Set pbCanceled to False
93028>>>>>>>        Set pSelectedRows to SelRowsIndexes
93029>>>>>>>        
93029>>>>>>>        Get peUpdateMode to eUpdateMode
93030>>>>>>>        // if non-invoking there is by definition, no move value out
93030>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
93032>>>>>>>            
93032>>>>>>>            If (eUpdateMode=umPromptValue) Begin
93034>>>>>>>                Send OnMoveValueOutByValue
93035>>>>>>>            End
93035>>>>>>>>
93035>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
93038>>>>>>>                Send OnMoveValueOutByCustom
93039>>>>>>>            End
93039>>>>>>>>
93039>>>>>>>            Get phmPromptUpdateCallback to hmCallBack
93040>>>>>>>            If hmCallBack Begin
93042>>>>>>>                Send hmCallBack of hoInvokingObject Self
93043>>>>>>>            End
93043>>>>>>>>
93043>>>>>>>        End
93043>>>>>>>>
93043>>>>>>>        
93043>>>>>>>        Send Close_Panel
93044>>>>>>>    End_Procedure
93045>>>>>>>    
93045>>>>>>>    // augment to send OnRestoreDefaults.
93045>>>>>>>    Procedure Release_Focus
93047>>>>>>>        Integer eUpdateMode
93047>>>>>>>        Get peUpdateMode to eUpdateMode
93048>>>>>>>        Forward Send Release_Focus
93050>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
93052>>>>>>>            Send OnRestoreDefaults
93053>>>>>>>        End
93053>>>>>>>>
93053>>>>>>>    End_Procedure
93054>>>>>>>    
93054>>>>>>>    Function SelectedRowIds Returns RowID[]
93056>>>>>>>        RowID[] SelectedRowids
93057>>>>>>>        Integer[] SelectedRows
93058>>>>>>>        Integer i iRows
93058>>>>>>>        Handle hoDataSource
93058>>>>>>>        Get phoDataSource to hoDataSource
93059>>>>>>>        Get pSelectedRows to SelectedRows
93060>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
93061>>>>>>>        For i from 0 to (iRows-1)
93067>>>>>>>>
93067>>>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
93068>>>>>>>        Loop
93069>>>>>>>>
93069>>>>>>>        Function_Return SelectedRowids
93070>>>>>>>    End_Function
93071>>>>>>>    
93071>>>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
93073>>>>>>>        String[] SelectedValues
93074>>>>>>>        Integer[] SelectedRows
93075>>>>>>>        Integer i iRows
93075>>>>>>>        Handle hoCol
93075>>>>>>>        Get ColumnObject iCol to hoCol
93076>>>>>>>        Get pSelectedRows to SelectedRows
93077>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
93078>>>>>>>        For i from 0 to (iRows-1)
93084>>>>>>>>
93084>>>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
93085>>>>>>>        Loop
93086>>>>>>>>
93086>>>>>>>        Function_Return SelectedValues
93087>>>>>>>    End_Function
93088>>>>>>>    
93088>>>>>>>    Procedure Ok Returns Integer
93090>>>>>>>        Send ClosePromptList
93091>>>>>>>    End_Procedure
93092>>>>>>>    
93092>>>>>>>    Procedure Cancel Returns Integer
93094>>>>>>>        Send Close_Panel
93095>>>>>>>    End_Procedure
93096>>>>>>>    
93096>>>>>>>    Procedure Search
93098>>>>>>>        Send Activate // give focus back to list so focus things are correct
93099>>>>>>>        Send Request_Search 0 0
93100>>>>>>>    End_Procedure
93101>>>>>>>    
93101>>>>>>>    // do a search using the current keys in the search key buffer for the sort column.
93101>>>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
93101>>>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
93101>>>>>>>    Procedure Request_SearchEx
93103>>>>>>>        tGridKeyPair[] Keys
93103>>>>>>>        tGridKeyPair[] Keys
93104>>>>>>>        Integer iCol
93104>>>>>>>        Handle hoCol hoSearchDialog
93104>>>>>>>        Boolean bOk
93104>>>>>>>        String sValue
93104>>>>>>>        
93104>>>>>>>        Get piSortColumn to iCol
93105>>>>>>>        If (iCol<>-1) Begin
93107>>>>>>>            Get ColumnObject iCol to hoCol
93108>>>>>>>            Get pSearchKeys to Keys
93109>>>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
93110>>>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
93111>>>>>>>            If bOk Begin
93113>>>>>>>                Send RequestFindColumnValue iCol sValue True 0
93114>>>>>>>            End
93114>>>>>>>>
93114>>>>>>>            Send Destroy of hoSearchDialog
93115>>>>>>>        End
93115>>>>>>>>
93115>>>>>>>        Send ClearSearchRequest // clear the search keys
93116>>>>>>>    End_Procedure
93117>>>>>>>    
93117>>>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
93117>>>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
93119>>>>>>>        tGridKeyPair[] Keys
93119>>>>>>>        tGridKeyPair[] Keys
93120>>>>>>>        tGridKeyPair KeyPair
93120>>>>>>>        tGridKeyPair KeyPair
93120>>>>>>>        Set pbRequestSearch to True
93121>>>>>>>        Move iKeyCode to KeyPair.KeyCode
93122>>>>>>>        Move iShiftCode to KeyPair.ShiftCode
93123>>>>>>>        Get pSearchKeys to Keys
93124>>>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
93125>>>>>>>        Set pSearchKeys to Keys
93126>>>>>>>    End_Procedure
93127>>>>>>>    
93127>>>>>>>    Procedure ClearSearchRequest
93129>>>>>>>        tGridKeyPair[] SearchKeys
93129>>>>>>>        tGridKeyPair[] SearchKeys
93130>>>>>>>        Set pSearchKeys to SearchKeys
93131>>>>>>>        Set pbRequestSearch to False
93132>>>>>>>    End_Procedure
93133>>>>>>>    
93133>>>>>>>End_Class
93134>>>>>>>
93134>>>>>Use cDbUpdateFunctionLibrary.pkg
93134>>>>>Use MSSqldrv.pkg
93134>>>>>Use db2_drv.pkg
93134>>>>>Use odbc_drv.pkg
93134>>>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout20\cRDCModalPanel.pkg)
93134>>>>>>>//****************************************************************************
93134>>>>>>>// $Module type: Class
93134>>>>>>>// $Module name: cRDCModalPanel
93134>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
93134>>>>>>>// Created     : 2014-03-17 @ 12:33
93134>>>>>>>//
93134>>>>>>>// Description :
93134>>>>>>>//
93134>>>>>>>// $Rev History:
93134>>>>>>>//    2014-03-17  Module header created
93134>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
93134>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
93134>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
93134>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
93134>>>>>>>// in the help folder for more details.
93134>>>>>>>//
93134>>>>>>>//****************************************************************************
93134>>>>>>>Use Windows.pkg
93134>>>>>>>Use cCJCommandBarSystem.pkg   
93134>>>>>>>Use cCJSkinFramework.pkg
93134>>>>>>>
93134>>>>>>>Class cRDCModalPanel is a ModalPanel
93135>>>>>>>
93135>>>>>>>    Procedure Construct_Object
93137>>>>>>>        Forward Send Construct_Object
93139>>>>>>>
93139>>>>>>>        Set Maximize_Icon to True
93140>>>>>>>        Set Minimize_Icon to False
93141>>>>>>>        Set Border_Style to Border_Thick
93142>>>>>>>        Set Locate_Mode to Center_On_Parent
93143>>>>>>>
93143>>>>>>>        Property String Private_Icon
93144>>>>>>>        Property Handle phoDialogCommandbar
93145>>>>>>>    End_Procedure
93146>>>>>>>
93146>>>>>>>    Procedure Set Icon String sIcon
93148>>>>>>>        Forward Set Icon to sIcon
93150>>>>>>>        Set Private_Icon to sIcon
93151>>>>>>>    End_Procedure
93152>>>>>>>
93152>>>>>>>    Function Icon Returns String
93154>>>>>>>        String sIcon
93154>>>>>>>        Get Private_Icon to sIcon
93155>>>>>>>        Function_Return sIcon
93156>>>>>>>    End_Function
93157>>>>>>>
93157>>>>>>>    Procedure Page Integer iPageObject
93159>>>>>>>        String sIcon
93159>>>>>>>        Integer hWnd
93159>>>>>>>        
93159>>>>>>>        Forward Send Page iPageObject
93161>>>>>>>        Get Private_Icon to sIcon
93162>>>>>>>        If (sIcon <> "") Begin
93164>>>>>>>            Set Icon to sIcon
93165>>>>>>>        End
93165>>>>>>>>
93165>>>>>>>
93165>>>>>>>        Get Window_Handle to hWnd
93166>>>>>>>
93166>>>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
93168>>>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
93169>>>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
93170>>>>>>>        End
93170>>>>>>>>
93170>>>>>>>    End_Procedure
93171>>>>>>>
93171>>>>>>>    // Put a status bar at the bottom of the panel, which makes
93171>>>>>>>    // status_help work and puts a gripper in the lower right corner.
93171>>>>>>>    Procedure End_Construct_Object
93173>>>>>>>        Integer iStyle iSize iOffset
93173>>>>>>>
93173>>>>>>>        Forward Send End_Construct_Object
93175>>>>>>>
93175>>>>>>>        Get Border_Style to iStyle
93176>>>>>>>        Move 8 to iOffset
93177>>>>>>>        If (iStyle = Border_Thick) Begin
93179>>>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
93181>>>>>>>                Object oStatusBar is a cCJStatusBar
93183>>>>>>>                    Set phoDialogCommandbar to Self
93184>>>>>>>                    Object oStatusIdle is a cCJStatusBarPane
93186>>>>>>>                        Set piId to sbpIDIdlePane
93187>>>>>>>                        Set pbStyleStretch to True
93188>>>>>>>                    End_Object
93189>>>>>>>                End_Object
93190>>>>>>>            End_Object
93191>>>>>>>            Get Size to iSize
93192>>>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
93193>>>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
93194>>>>>>>        End
93194>>>>>>>>
93194>>>>>>>
93194>>>>>>>    End_Procedure
93195>>>>>>>
93195>>>>>>>    Procedure Popup
93197>>>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
93198>>>>>>>        Forward Send Popup
93200>>>>>>>    End_Procedure
93201>>>>>>>
93201>>>>>>>End_Class
93202>>>>>
93202>>>>>Object oDatabaseSelection_sl is a cRDCModalPanel
93204>>>>>    Set Label to "SQL Database Selection"
93205>>>>>    Set Size to 119 183
93206>>>>>    Set piMinSize to 89 170
93207>>>>>    Set Location to 2 2
93208>>>>>    Set Border_Style to Border_Thick
93209>>>>>    Set Icon to "DatabaseLookup1.ico"
93210>>>>>
93210>>>>>    Property String[] psTheData
93212>>>>>
93212>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
93214>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
93216>>>>>        End_Object
93217>>>>>    End
93217>>>>>>
93217>>>>>
93217>>>>>    Object oSelList is a cCJGridPromptList
93219>>>>>        Set Size to 89 167
93220>>>>>        Set Location to 6 6
93221>>>>>        Set peAnchors to anAll
93222>>>>>        Set pbAllowColumnRemove to False
93223>>>>>        Set pbUseAlternateRowBackgroundColor to True
93224>>>>>        Set pbGrayIfDisable to False
93225>>>>>        Set pbHeaderReorders to False
93226>>>>>        Set pbHeaderSelectsColumn to False
93227>>>>>        Set pbHeaderTogglesDirection to False
93228>>>>>        Set pbShadeSortColumn to False
93229>>>>>        Set piFocusCellBackColor to clDkGray
93230>>>>>
93230>>>>>        Object oName is a cCJGridColumn
93232>>>>>            Set piWidth to 334
93233>>>>>            Set psCaption to "Database Name"
93234>>>>>        End_Object
93235>>>>>
93235>>>>>        Procedure Activating
93238>>>>>            tDataSourceRow[] MyData
93238>>>>>            tDataSourceRow[] MyData
93239>>>>>            Handle hoDataSource
93239>>>>>            String[] sTheData
93240>>>>>            Integer iCount iSize
93240>>>>>
93240>>>>>            Send Cursor_Wait of Cursor_Control
93241>>>>>            Forward Send Activating
93243>>>>>
93243>>>>>            Get psTheData to sTheData
93244>>>>>            Move (SizeOfArray(sTheData)) to iSize
93245>>>>>            Decrement iSize
93246>>>>>            For iCount from 0 to iSize
93252>>>>>>
93252>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
93253>>>>>            Loop
93254>>>>>>
93254>>>>>
93254>>>>>            Get phoDataSource to hoDataSource
93255>>>>>            Send InitializeData of hoDataSource MyData
93256>>>>>            Send Cursor_Ready of Cursor_Control
93257>>>>>        End_Procedure
93258>>>>>
93258>>>>>    End_Object
93259>>>>>
93259>>>>>    Object oOK_Btn is a Button
93261>>>>>        Set Size to 14 50
93262>>>>>        Set Label    to "&OK"
93263>>>>>        Set Location to 98 68
93264>>>>>        Set peAnchors To anBottomRight
93265>>>>>
93265>>>>>        Procedure OnClick
93268>>>>>            Send Ok of oSelList
93269>>>>>        End_Procedure
93270>>>>>
93270>>>>>    End_Object
93271>>>>>
93271>>>>>    Object oCancel_Btn is a Button
93273>>>>>        Set Size to 14 50
93274>>>>>        Set Label    to "&Cancel"
93275>>>>>        Set Location to 98 123
93276>>>>>        Set peAnchors to anBottomRight
93277>>>>>
93277>>>>>        Procedure OnClick
93280>>>>>            Send Close_Panel
93281>>>>>        End_Procedure
93282>>>>>
93282>>>>>    End_Object
93283>>>>>
93283>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
93284>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
93285>>>>>End_Object
93286>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
93286>>>>>Use Windows.pkg
93286>>>>>Use cCJGridPromptList.pkg
93286>>>>>Use MSSqldrv.pkg
93286>>>>>Use db2_drv.pkg
93286>>>>>Use odbc_drv.pkg    
93286>>>>>Use cRDCModalPanel.pkg
93286>>>>>Use cDbUpdateFunctionLibrary.pkg
93286>>>>>
93286>>>>>Object oServerSelection_sl is a cRDCModalPanel
93288>>>>>    Set Size to 105 225
93289>>>>>    Set Label to "Database Server/DSN Selection"
93290>>>>>    Set piMinSize to 89 211
93291>>>>>    Set Location to 2 2
93292>>>>>    Set Icon to "ServerLookup1.ico"
93293>>>>>
93293>>>>>    Property String[] psTheData
93295>>>>>
93295>>>>>    Object oSelList is a cCJGridPromptList
93297>>>>>        Set Size to 72 215
93298>>>>>        Set Location to 6 6
93299>>>>>        Set peAnchors to anAll
93300>>>>>        Set pbAllowColumnRemove to False
93301>>>>>        Set pbUseAlternateRowBackgroundColor to True
93302>>>>>        Set pbGrayIfDisable to False
93303>>>>>        Set pbHeaderReorders to False
93304>>>>>        Set pbHeaderSelectsColumn to False
93305>>>>>        Set pbHeaderTogglesDirection to False
93306>>>>>        Set pbShadeSortColumn to False
93307>>>>>        Set piFocusCellBackColor to clDkGray
93308>>>>>
93308>>>>>        Object oName is a cCJGridColumn
93310>>>>>            Set piWidth to 358
93311>>>>>            Set psCaption to "Name"
93312>>>>>        End_Object
93313>>>>>
93313>>>>>        Procedure Activating
93316>>>>>            tDataSourceRow[] MyData
93316>>>>>            tDataSourceRow[] MyData
93317>>>>>            Handle hoDataSource
93317>>>>>            String[] sTheData
93318>>>>>            Integer iCount iSize
93318>>>>>
93318>>>>>            Send Cursor_Wait of Cursor_Control
93319>>>>>            Get psTheData to sTheData
93320>>>>>            Move (SizeOfArray(sTheData)) to iSize
93321>>>>>            Decrement iSize
93322>>>>>            For iCount from 0 to iSize
93328>>>>>>
93328>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
93329>>>>>            Loop
93330>>>>>>
93330>>>>>
93330>>>>>            Forward Send Activating
93332>>>>>
93332>>>>>            Get phoDataSource to hoDataSource
93333>>>>>            Send InitializeData of hoDataSource MyData
93334>>>>>            Send Cursor_Ready of Cursor_Control
93335>>>>>        End_Procedure
93336>>>>>
93336>>>>>    End_Object
93337>>>>>
93337>>>>>    Object oOK_Btn is a Button
93339>>>>>        Set Size to 14 50
93340>>>>>        Set Label    to "&OK"
93341>>>>>        Set Location to 85 116
93342>>>>>        Set peAnchors To anBottomRight
93343>>>>>
93343>>>>>        Procedure OnClick
93346>>>>>            Send Ok of oSelList
93347>>>>>        End_Procedure
93348>>>>>
93348>>>>>    End_Object
93349>>>>>
93349>>>>>    Object oCancel_Btn is a Button
93351>>>>>        Set Size to 14 50
93352>>>>>        Set Label    to "&Cancel"
93353>>>>>        Set Location to 85 171
93354>>>>>        Set peAnchors to anBottomRight
93355>>>>>
93355>>>>>        Procedure OnClick
93358>>>>>            Send Close_Panel
93359>>>>>        End_Procedure
93360>>>>>
93360>>>>>    End_Object
93361>>>>>
93361>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
93362>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
93363>>>>>End_Object
93364>>>Use ManageSQLConnections.dg
Including file: ManageSQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ManageSQLConnections.dg)
93364>>>>>Use Windows.pkg
93364>>>>>Use Cursor.pkg
93364>>>>>Use cCJCommandBarSystem.pkg
93364>>>>>Use cRDCButtonDPI.pkg
93364>>>>>Use cSQLCheckBox.pkg
Including file: cSQLCheckBox.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLCheckBox.pkg)
93364>>>>>>>Use Windows.pkg
93364>>>>>>>
93364>>>>>>>// Used by the "Page" message below to show
93364>>>>>>>// a rectangle around ComboForm and Checkbox objects.
93364>>>>>>>    Define WM_CHANGEUISTATE for |CI$0127
93364>>>>>>>    Define WM_UPDATEUISTATE for |CI$0128
93364>>>>>>>    Define WM_QUERYUISTATE  for |CI$0129
93364>>>>>>>    Define UIS_SET          for 1
93364>>>>>>>    Define UIS_CLEAR        for 2
93364>>>>>>>    Define UIS_INITIALIZE   for 3
93364>>>>>>>    Define UISF_HIDEFOCUS   for |CI$1
93364>>>>>>>    Define UISF_HIDEACCEL   for |CI$2
93364>>>>>>>    Define UISF_ACTIVE      for |CI$4
93364>>>>>>>
93364>>>>>>>// Note: Can't use cRDCCheckbox as then the OnChange event isn't called (Don't know why)
93364>>>>>>>Class cSQLCheckBox is a CheckBox
93365>>>>>>>    Procedure Construct_Object
93367>>>>>>>        Forward Send Construct_Object
93369>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
93369>>>>>>>        Property Integer piItem
93370>>>>>>>    End_Procedure
93371>>>>>>>
93371>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
93373>>>>>>>    End_Procedure
93374>>>>>>>
93374>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
93376>>>>>>>        Integer iItem
93376>>>>>>>        Get piItem to iItem
93377>>>>>>>        Set Checked_State to (sConnectionData[iItem] = "1")
93378>>>>>>>    End_Procedure
93379>>>>>>>
93379>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
93381>>>>>>>        Boolean bState
93381>>>>>>>        Integer iItem
93381>>>>>>>        Get piItem to iItem
93382>>>>>>>        Get Checked_State to bState
93383>>>>>>>        Move bState to sConnectionData[iItem]
93384>>>>>>>    End_Procedure
93385>>>>>>>
93385>>>>>>>    Procedure Set psToolTip String sToolTip
93387>>>>>>>        String sStatusHelp
93387>>>>>>>
93387>>>>>>>        Get Status_Help to sStatusHelp
93388>>>>>>>        If (sStatusHelp = "") Begin
93390>>>>>>>            Set Status_Help to sToolTip
93391>>>>>>>        End
93391>>>>>>>>
93391>>>>>>>
93391>>>>>>>        Forward Set psToolTip to sToolTip
93393>>>>>>>    End_Procedure
93394>>>>>>>
93394>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
93394>>>>>>>    // The bug being that the focus rectangle doesn't show.
93394>>>>>>>    Procedure Page Integer iPageObject
93396>>>>>>>        Handle hWnd
93396>>>>>>>        Integer iRet iState
93396>>>>>>>
93396>>>>>>>        Forward Send Page iPageObject
93398>>>>>>>
93398>>>>>>>        If (iPageObject) Begin
93400>>>>>>>            Get Window_Handle to hWnd
93401>>>>>>>            If (hWnd) Begin
93403>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
93404>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
93406>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
93407>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
93408>>>>>>>                End
93408>>>>>>>>
93408>>>>>>>            End
93408>>>>>>>>
93408>>>>>>>        End
93408>>>>>>>>
93408>>>>>>>    End_Procedure
93409>>>>>>>
93409>>>>>>>End_Class
93410>>>>>Use cSQLComboForm.pkg
Including file: cSQLComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLComboForm.pkg)
93410>>>>>>>Use Windows.pkg
93410>>>>>>>Use cRDCComboForm.pkg
Including file: cRDCComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCComboForm.pkg)
93410>>>>>>>>>//****************************************************************************
93410>>>>>>>>>// $Module type: Package
93410>>>>>>>>>// $Module name: cRDCComboform.pkg
93410>>>>>>>>>//
93410>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
93410>>>>>>>>>// Copyright (c) 2014 RDC Tools International
93410>>>>>>>>>// E-mail      : support@rdctools.com
93410>>>>>>>>>// Web-site    : http://www.rdctools.com
93410>>>>>>>>>//
93410>>>>>>>>>// Created     : 2014-03-17 @ 12:35 (Military date format - Year-Month-Day)
93410>>>>>>>>>//
93410>>>>>>>>>// Portions by : Raveen Sundram, Excellent Software Ltd
93410>>>>>>>>>//               The auto-size combo width logic was developed by Raveen.
93410>>>>>>>>>//
93410>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
93410>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
93410>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
93410>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
93410>>>>>>>>>// in the help folder for more details.
93410>>>>>>>>>//
93410>>>>>>>>>//****************************************************************************
93410>>>>>>>>>Use Windows.pkg
93410>>>>>>>>>
93410>>>>>>>>>// Used by the "Page" message below to show
93410>>>>>>>>>// a focus rectangle around ComboForm and Checkbox objects.
93410>>>>>>>>>
93410>>>>>>>>>Class cComboFormIdleHandler is a cIdleHandler
93411>>>>>>>>>    Procedure Construct_Object
93413>>>>>>>>>        Forward Send Construct_Object
93415>>>>>>>>>
93415>>>>>>>>>        Set Label_Row_Offset to 0
93416>>>>>>>>>        Set Label_Col_Offset to 2
93417>>>>>>>>>        Set Label_Justification_Mode to jMode_Right
93418>>>>>>>>>        Set Combo_Sort_State to False
93419>>>>>>>>>        Set Entry_State to False
93420>>>>>>>>>
93420>>>>>>>>>    End_Procedure
93421>>>>>>>>>
93421>>>>>>>>>    Procedure OnIdle
93423>>>>>>>>>        Delegate Send DoUpdate
93425>>>>>>>>>    End_Procedure
93426>>>>>>>>>
93426>>>>>>>>>End_Class
93427>>>>>>>>>
93427>>>>>>>>>Class cRDCComboForm is a ComboForm
93428>>>>>>>>>    Procedure Construct_Object
93430>>>>>>>>>        Forward Send Construct_Object
93432>>>>>>>>>
93432>>>>>>>>>        Property Boolean pbAutoListWidth True
93433>>>>>>>>>
93433>>>>>>>>>        Property Boolean pbAutoShadowLabelObject True
93434>>>>>>>>>
93434>>>>>>>>>        Property Boolean pbAutoEnable False
93435>>>>>>>>>        Set Label_Col_Offset to 2
93436>>>>>>>>>        Property Boolean pbEnabled True
93437>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
93438>>>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cComboFormIdleHandler)))
93439>>>>>>>>>
93439>>>>>>>>>    End_Procedure
93440>>>>>>>>>
93440>>>>>>>>>    Procedure End_Construct_Object
93442>>>>>>>>>        Boolean bAutoShadowLabelObject
93442>>>>>>>>>        String sTooltip sStatus_Help
93442>>>>>>>>>
93442>>>>>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
93443>>>>>>>>>        If (bAutoShadowLabelObject = True) Begin
93445>>>>>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
93446>>>>>>>>>        End
93446>>>>>>>>>>
93446>>>>>>>>>
93446>>>>>>>>>        Forward Send End_Construct_Object
93448>>>>>>>>>
93448>>>>>>>>>        Get psToolTip   to sTooltip
93449>>>>>>>>>        Get Status_Help to sStatus_Help
93450>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
93452>>>>>>>>>            Set psToolTip to sStatus_Help
93453>>>>>>>>>        End
93453>>>>>>>>>>
93453>>>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
93456>>>>>>>>>            Set Status_Help to sTooltip
93457>>>>>>>>>        End
93457>>>>>>>>>>
93457>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
93458>>>>>>>>>
93458>>>>>>>>>    End_Procedure
93459>>>>>>>>>
93459>>>>>>>>>    Procedure DoUpdate
93461>>>>>>>>>        If (pbAutoEnable(Self) = False) Begin
93463>>>>>>>>>            Procedure_Return
93464>>>>>>>>>        End
93464>>>>>>>>>>
93464>>>>>>>>>        Set Enabled_State to (IsEnabled(Self))
93465>>>>>>>>>    End_Procedure
93466>>>>>>>>>
93466>>>>>>>>>    Function IsEnabled Returns Boolean
93468>>>>>>>>>        Boolean bEnabled
93468>>>>>>>>>        Get pbEnabled to bEnabled
93469>>>>>>>>>        Function_Return bEnabled
93470>>>>>>>>>    End_Function
93471>>>>>>>>>
93471>>>>>>>>>    // Enable the idle handler timer when the object is activated
93471>>>>>>>>>    Procedure Activating
93473>>>>>>>>>        Forward Send Activating
93475>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
93476>>>>>>>>>    End_Procedure
93477>>>>>>>>>
93477>>>>>>>>>    // Disable the idle handler when the object is deactivated
93477>>>>>>>>>    Procedure Deactivating
93479>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
93480>>>>>>>>>        Forward Send Deactivating
93482>>>>>>>>>    End_Procedure
93483>>>>>>>>>
93483>>>>>>>>>    // To "un-select" the text in the comboform on startup
93483>>>>>>>>>    Procedure DoApplyAnchors Integer Arg1 Integer Arg2
93485>>>>>>>>>        Integer iStart iEnd
93485>>>>>>>>>
93485>>>>>>>>>        If (Focus(Desktop)=Self) Begin
93487>>>>>>>>>            Get SelStart to iStart
93488>>>>>>>>>            Get SelEnd   to iEnd
93489>>>>>>>>>        End
93489>>>>>>>>>>
93489>>>>>>>>>        Forward Send DoApplyAnchors Arg1 Arg2
93491>>>>>>>>>        Send SetSel iStart iEnd
93492>>>>>>>>>    End_Procedure
93493>>>>>>>>>
93493>>>>>>>>>    // Message that will drop down the list without the user clicking it,
93493>>>>>>>>>    // so you can send "DropDownList" to the combo to show the list.
93493>>>>>>>>>    Procedure DropDownList
93495>>>>>>>>>        Send Windows_Message CB_SHOWDROPDOWN 1 0
93496>>>>>>>>>    End_Procedure
93497>>>>>>>>>
93497>>>>>>>>>    Procedure SizeComboWidth
93499>>>>>>>>>        Integer iCount iItem iTextExt iRows iWd iNewWd iVertAdj
93499>>>>>>>>>        String sVal
93499>>>>>>>>>
93499>>>>>>>>>        // Initialise Width
93499>>>>>>>>>        Set ListWidth to 0
93500>>>>>>>>>        Send DoSetListWidth
93501>>>>>>>>>
93501>>>>>>>>>        Get ListRowCount     to iRows
93502>>>>>>>>>        Get Combo_Item_Count to iCount
93503>>>>>>>>>
93503>>>>>>>>>        // Vertical scroll-bar adjustment is needed
93503>>>>>>>>>        Move (iRows > 0 and iCount > iRows) to iVertAdj
93504>>>>>>>>>        If (iVertAdj) Begin
93506>>>>>>>>>            Move (GetSystemMetrics(SM_CXVSCROLL)+GetSystemMetrics(SM_CXEDGE)) to iVertAdj
93507>>>>>>>>>        End
93507>>>>>>>>>>
93507>>>>>>>>>        Else Begin
93508>>>>>>>>>            Move (GetSystemMetrics(SM_CXEDGE)) to iVertAdj
93509>>>>>>>>>        End
93509>>>>>>>>>>
93509>>>>>>>>>
93509>>>>>>>>>        // Calculate New Width
93509>>>>>>>>>        Decrement iCount
93510>>>>>>>>>        For iItem from 0 to iCount
93516>>>>>>>>>>
93516>>>>>>>>>            Get Combo_Value iItem to sVal
93517>>>>>>>>>            If (sVal <> "") Begin
93519>>>>>>>>>                Get Text_Extent sVal to iTextExt
93520>>>>>>>>>                Move (Low(iTextExt) + iVertAdj) to iWd
93521>>>>>>>>>                If (iWd > iNewWd) Begin
93523>>>>>>>>>                    Move (iWd + GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CXEDGE)) to iNewWd
93524>>>>>>>>>                End
93524>>>>>>>>>>
93524>>>>>>>>>            End
93524>>>>>>>>>>
93524>>>>>>>>>        Loop
93525>>>>>>>>>>
93525>>>>>>>>>
93525>>>>>>>>>        // Set New Width
93525>>>>>>>>>        Set ListWidth to iNewWd
93526>>>>>>>>>        Send DoSetListWidth
93527>>>>>>>>>    End_Procedure
93528>>>>>>>>>
93528>>>>>>>>>    Procedure Combo_Add_Item String sValue
93530>>>>>>>>>        Forward Send Combo_Add_Item sValue
93532>>>>>>>>>        If (pbAutoListWidth(Self)) Begin
93534>>>>>>>>>            Send SizeComboWidth
93535>>>>>>>>>        End
93535>>>>>>>>>>
93535>>>>>>>>>    End_Procedure
93536>>>>>>>>>
93536>>>>>>>>>    Procedure Combo_Fill_List
93538>>>>>>>>>        Forward Send Combo_Fill_List
93540>>>>>>>>>        If (pbAutoListWidth(Self)) Begin
93542>>>>>>>>>            Send SizeComboWidth
93543>>>>>>>>>        End
93543>>>>>>>>>>
93543>>>>>>>>>    End_Procedure
93544>>>>>>>>>
93544>>>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
93544>>>>>>>>>    // The bug being that the focus rectangle doesn't show.
93544>>>>>>>>>    Procedure Page Integer iPageObject
93546>>>>>>>>>        Handle hWnd
93546>>>>>>>>>        Integer iRet iState
93546>>>>>>>>>
93546>>>>>>>>>        Forward Send Page iPageObject
93548>>>>>>>>>
93548>>>>>>>>>        If (iPageObject) Begin
93550>>>>>>>>>            Get Window_Handle to hWnd
93551>>>>>>>>>            If (hWnd) Begin
93553>>>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
93554>>>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
93556>>>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
93557>>>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
93558>>>>>>>>>                End
93558>>>>>>>>>>
93558>>>>>>>>>            End
93558>>>>>>>>>>
93558>>>>>>>>>        End
93558>>>>>>>>>>
93558>>>>>>>>>
93558>>>>>>>>>        // To "un-select" the text in the comboform
93558>>>>>>>>>        If (iPageObject = 1 and Focus(Desktop) <> Self) Begin
93560>>>>>>>>>            Send SetSel 0 0
93561>>>>>>>>>        End
93561>>>>>>>>>>
93561>>>>>>>>>    End_Procedure
93562>>>>>>>>>
93562>>>>>>>>>End_Class
93563>>>>>>>
93563>>>>>>>// Used by the "Page" message below to show
93563>>>>>>>// a rectangle around ComboForm and Checkbox objects.
93563>>>>>>>//#IFNDEF WM_CHANGEUISTATE
93563>>>>>>>//    Define WM_CHANGEUISTATE for |CI$0127
93563>>>>>>>//    Define WM_UPDATEUISTATE for |CI$0128
93563>>>>>>>//    Define WM_QUERYUISTATE  for |CI$0129
93563>>>>>>>//    Define UIS_SET          for 1
93563>>>>>>>//    Define UIS_CLEAR        for 2
93563>>>>>>>//    Define UIS_INITIALIZE   for 3
93563>>>>>>>//    Define UISF_HIDEFOCUS   for |CI$1
93563>>>>>>>//    Define UISF_HIDEACCEL   for |CI$2
93563>>>>>>>//    Define UISF_ACTIVE      for |CI$4
93563>>>>>>>//#ENDIF
93563>>>>>>>
93563>>>>>>>Class cSQLComboForm is a cRDCComboForm
93564>>>>>>>    Procedure Construct_Object
93566>>>>>>>        Forward Send Construct_Object
93568>>>>>>>
93568>>>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
93568>>>>>>>//        Property Boolean pbAutoShadowLabelObject True
93568>>>>>>>
93568>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
93568>>>>>>>        Property Integer piItem
93569>>>>>>>
93569>>>>>>>//        Set Label_Col_Offset to 2
93569>>>>>>>//        Set Label_Justification_Mode to JMode_Right
93569>>>>>>>    End_Procedure
93570>>>>>>>
93570>>>>>>>    Procedure End_Construct_Object
93572>>>>>>>//        Boolean bAutoShadowLabelObject
93572>>>>>>>//        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
93572>>>>>>>//        If (bAutoShadowLabelObject = True) Begin
93572>>>>>>>//            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
93572>>>>>>>//        End
93572>>>>>>>        Forward Send End_Construct_Object
93574>>>>>>>    End_Procedure
93575>>>>>>>
93575>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
93577>>>>>>>    End_Procedure
93578>>>>>>>
93578>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
93580>>>>>>>        Integer iItem
93580>>>>>>>        Get piItem to iItem
93581>>>>>>>        Set Value to sConnectionData[iItem]
93582>>>>>>>    End_Procedure
93583>>>>>>>
93583>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
93585>>>>>>>        String sValue
93585>>>>>>>        Integer iItem
93585>>>>>>>        Get piItem to iItem
93586>>>>>>>        Get Value to sValue
93587>>>>>>>        Move sValue to sConnectionData[iItem]
93588>>>>>>>    End_Procedure
93589>>>>>>>
93589>>>>>>>//    Procedure Set psToolTip String sToolTip
93589>>>>>>>//        String sStatusHelp
93589>>>>>>>//
93589>>>>>>>//        Get Status_Help to sStatusHelp
93589>>>>>>>//        If (sStatusHelp = "") Begin
93589>>>>>>>//            Set Status_Help to sToolTip
93589>>>>>>>//        End
93589>>>>>>>//
93589>>>>>>>//        Forward Set psToolTip to sToolTip
93589>>>>>>>//    End_Procedure
93589>>>>>>>//
93589>>>>>>>//    // Fix for a bug when using manifest files & running Vista and above.
93589>>>>>>>//    // The bug being that the focus rectangle doesn't show.
93589>>>>>>>//    Procedure Page Integer iPageObject
93589>>>>>>>//        Handle hWnd
93589>>>>>>>//        Integer iRet iState
93589>>>>>>>//
93589>>>>>>>//        Forward Send Page iPageObject
93589>>>>>>>//
93589>>>>>>>//        If (iPageObject) Begin
93589>>>>>>>//            Get Window_Handle to hWnd
93589>>>>>>>//            If (hWnd) Begin
93589>>>>>>>//                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
93589>>>>>>>//                If (iRet iand UISF_HIDEFOCUS) Begin
93589>>>>>>>//                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
93589>>>>>>>//                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
93589>>>>>>>//                End
93589>>>>>>>//            End
93589>>>>>>>//        End
93589>>>>>>>//    End_Procedure
93589>>>>>>>
93589>>>>>>>End_Class
93590>>>>>Use cSQLForm.pkg
Including file: cSQLForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLForm.pkg)
93590>>>>>>>Use Windows.pkg
93590>>>>>>>
93590>>>>>>>Class cSQLForm is a Form
93591>>>>>>>    Procedure Construct_Object
93593>>>>>>>        Forward Send Construct_Object
93595>>>>>>>
93595>>>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
93595>>>>>>>        Property Boolean pbAutoShadowLabelObject True
93596>>>>>>>
93596>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
93596>>>>>>>        Property Integer piItem
93597>>>>>>>
93597>>>>>>>        Set Label_Justification_Mode to JMode_Right
93598>>>>>>>        Set Label_Col_Offset to 2
93599>>>>>>>    End_Procedure
93600>>>>>>>
93600>>>>>>>    Procedure End_Construct_Object
93602>>>>>>>        Boolean bAutoShadowLabelObject
93602>>>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
93603>>>>>>>        If (bAutoShadowLabelObject = True) Begin
93605>>>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
93606>>>>>>>        End
93606>>>>>>>>
93606>>>>>>>        Forward Send End_Construct_Object
93608>>>>>>>    End_Procedure
93609>>>>>>>
93609>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
93611>>>>>>>    End_Procedure
93612>>>>>>>
93612>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
93614>>>>>>>        Integer iItem
93614>>>>>>>        Get piItem to iItem
93615>>>>>>>        Set Value to sConnectionData[iItem]
93616>>>>>>>    End_Procedure
93617>>>>>>>
93617>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
93619>>>>>>>        String sValue
93619>>>>>>>        Integer iItem
93619>>>>>>>        Get piItem to iItem
93620>>>>>>>        Get Value to sValue
93621>>>>>>>        Move sValue to sConnectionData[iItem]
93622>>>>>>>    End_Procedure
93623>>>>>>>
93623>>>>>>>    Procedure Set psToolTip String sToolTip
93625>>>>>>>        String sStatusHelp
93625>>>>>>>
93625>>>>>>>        Get Status_Help to sStatusHelp
93626>>>>>>>        If (sStatusHelp = "") Begin
93628>>>>>>>            Set Status_Help to sToolTip
93629>>>>>>>        End
93629>>>>>>>>
93629>>>>>>>
93629>>>>>>>        Forward Set psToolTip to sToolTip
93631>>>>>>>    End_Procedure
93632>>>>>>>
93632>>>>>>>End_Class
93633>>>>>Use cSQLConnectionHandler.pkg
93633>>>>>Use cDbUpdateFunctionLibrary.pkg
93633>>>>>Use cDbUpdateDatabaseDriver.pkg
93633>>>>>Use DatabaseSelection.dg
93633>>>>>Use ServerSelection.dg
93633>>>>>Use TableSpaceSelection.dg
Including file: TableSpaceSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\TableSpaceSelection.dg)
93633>>>>>>>Use Windows.pkg
93633>>>>>>>Use cCJGridPromptList.pkg     
93633>>>>>>>Use cRDCModalPanel.pkg
93633>>>>>>>Use cDbUpdateFunctionLibrary.pkg
93633>>>>>>>
93633>>>>>>>Object oTableSpaceSelection_sl is a cRDCModalPanel
93635>>>>>>>    Set Size to 118 177
93636>>>>>>>    Set Label to "SQL Tablespace Selection"
93637>>>>>>>    Set piMinSize to 89 177
93638>>>>>>>    Set Location to 2 2
93639>>>>>>>    Set Icon to "DatabaseLookup1.ico"
93640>>>>>>>
93640>>>>>>>    Property String[] psTheData
93642>>>>>>>
93642>>>>>>>//    If (ghoDbUpdateFunctionLibrary = 0) Begin
93642>>>>>>>//        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
93642>>>>>>>//        End_Object
93642>>>>>>>//    End
93642>>>>>>>
93642>>>>>>>    Object oSelList is a cCJGridPromptList
93644>>>>>>>        Set Size to 89 167
93645>>>>>>>        Set Location to 6 6
93646>>>>>>>        Set peAnchors to anAll
93647>>>>>>>        Set pbAllowColumnRemove to False
93648>>>>>>>        Set pbUseAlternateRowBackgroundColor to True
93649>>>>>>>        Set pbGrayIfDisable to False
93650>>>>>>>        Set pbHeaderReorders to False
93651>>>>>>>        Set pbHeaderSelectsColumn to False
93652>>>>>>>        Set pbHeaderTogglesDirection to False
93653>>>>>>>        Set pbShadeSortColumn to False
93654>>>>>>>        Set piFocusCellBackColor to clDkGray
93655>>>>>>>
93655>>>>>>>        Object oName is a cCJGridColumn
93657>>>>>>>            Set piWidth to 334
93658>>>>>>>            Set psCaption to "Table Space Name"
93659>>>>>>>        End_Object
93660>>>>>>>
93660>>>>>>>        Procedure Activating
93663>>>>>>>            tDataSourceRow[] MyData
93663>>>>>>>            tDataSourceRow[] MyData
93664>>>>>>>            Handle hoDataSource
93664>>>>>>>            String[] sTheData
93665>>>>>>>            Integer iCount iSize
93665>>>>>>>
93665>>>>>>>            Send Cursor_Wait of Cursor_Control
93666>>>>>>>            Forward Send Activating
93668>>>>>>>
93668>>>>>>>            Get psTheData to sTheData
93669>>>>>>>            Move (SizeOfArray(sTheData)) to iSize
93670>>>>>>>            Decrement iSize
93671>>>>>>>            For iCount from 0 to iSize
93677>>>>>>>>
93677>>>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
93678>>>>>>>            Loop
93679>>>>>>>>
93679>>>>>>>
93679>>>>>>>            Get phoDataSource to hoDataSource
93680>>>>>>>            Send InitializeData of hoDataSource MyData
93681>>>>>>>            Send Cursor_Ready of Cursor_Control
93682>>>>>>>        End_Procedure
93683>>>>>>>
93683>>>>>>>    End_Object
93684>>>>>>>
93684>>>>>>>    Object oOK_Btn is a Button
93686>>>>>>>        Set Size to 14 50
93687>>>>>>>        Set Label    to "&OK"
93688>>>>>>>        Set Location to 98 68
93689>>>>>>>        Set peAnchors To anBottomRight
93690>>>>>>>
93690>>>>>>>        Procedure OnClick
93693>>>>>>>            Send Ok of oSelList
93694>>>>>>>        End_Procedure
93695>>>>>>>
93695>>>>>>>    End_Object
93696>>>>>>>
93696>>>>>>>    Object oCancel_Btn is a Button
93698>>>>>>>        Set Size to 14 50
93699>>>>>>>        Set Label    to "&Cancel"
93700>>>>>>>        Set Location to 98 123
93701>>>>>>>        Set peAnchors to anBottomRight
93702>>>>>>>
93702>>>>>>>        Procedure OnClick
93705>>>>>>>            Send Close_Panel
93706>>>>>>>        End_Procedure
93707>>>>>>>
93707>>>>>>>    End_Object
93708>>>>>>>
93708>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
93709>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
93710>>>>>>>End_Object
93711>>>>>Use SchemasSelection.dg
Including file: SchemasSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SchemasSelection.dg)
93711>>>>>>>Use Windows.pkg
93711>>>>>>>Use cCJGridPromptList.pkg  
93711>>>>>>>Use cRDCModalPanel.pkg
93711>>>>>>>Use cDbUpdateFunctionLibrary.pkg
93711>>>>>>>
93711>>>>>>>Object oSchemasSelection_sl is a cRDCModalPanel
93713>>>>>>>    Set Size to 118 177
93714>>>>>>>    Set Label to "SQL Schemas Selection"
93715>>>>>>>    Set piMinSize to 89 177
93716>>>>>>>    Set Location to 2 2
93717>>>>>>>    Set Icon to "DatabaseLookup1.ico"
93718>>>>>>>
93718>>>>>>>    Property String[] psTheData
93720>>>>>>>
93720>>>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
93722>>>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
93724>>>>>>>        End_Object
93725>>>>>>>    End
93725>>>>>>>>
93725>>>>>>>
93725>>>>>>>    Object oSelList is a cCJGridPromptList
93727>>>>>>>        Set Size to 89 167
93728>>>>>>>        Set Location to 6 6
93729>>>>>>>        Set peAnchors to anAll
93730>>>>>>>        Set pbAllowColumnRemove to False
93731>>>>>>>        Set pbUseAlternateRowBackgroundColor to True
93732>>>>>>>        Set pbGrayIfDisable to False
93733>>>>>>>        Set pbHeaderReorders to False
93734>>>>>>>        Set pbHeaderSelectsColumn to False
93735>>>>>>>        Set pbHeaderTogglesDirection to False
93736>>>>>>>        Set pbShadeSortColumn to False
93737>>>>>>>        Set piFocusCellBackColor to clDkGray
93738>>>>>>>
93738>>>>>>>        Object oName is a cCJGridColumn
93740>>>>>>>            Set piWidth to 334
93741>>>>>>>            Set psCaption to "Schema Name"
93742>>>>>>>        End_Object
93743>>>>>>>
93743>>>>>>>        Procedure Activating
93746>>>>>>>            tDataSourceRow[] MyData
93746>>>>>>>            tDataSourceRow[] MyData
93747>>>>>>>            Handle hoDataSource
93747>>>>>>>            String[] sTheData
93748>>>>>>>            Integer iCount iSize
93748>>>>>>>
93748>>>>>>>            Send Cursor_Wait of Cursor_Control
93749>>>>>>>            Forward Send Activating
93751>>>>>>>
93751>>>>>>>            Get psTheData to sTheData
93752>>>>>>>
93752>>>>>>>            Move (SizeOfArray(sTheData)) to iSize
93753>>>>>>>            Decrement iSize
93754>>>>>>>            For iCount from 0 to iSize
93760>>>>>>>>
93760>>>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
93761>>>>>>>            Loop
93762>>>>>>>>
93762>>>>>>>
93762>>>>>>>            Get phoDataSource to hoDataSource
93763>>>>>>>            Send InitializeData of hoDataSource MyData
93764>>>>>>>            Send Cursor_Ready of Cursor_Control
93765>>>>>>>        End_Procedure
93766>>>>>>>
93766>>>>>>>    End_Object
93767>>>>>>>
93767>>>>>>>    Object oOK_Btn is a Button
93769>>>>>>>        Set Size to 14 50
93770>>>>>>>        Set Label    to "&OK"
93771>>>>>>>        Set Location to 98 68
93772>>>>>>>        Set peAnchors To anBottomRight
93773>>>>>>>
93773>>>>>>>        Procedure OnClick
93776>>>>>>>            Send Ok of oSelList
93777>>>>>>>        End_Procedure
93778>>>>>>>
93778>>>>>>>    End_Object
93779>>>>>>>
93779>>>>>>>    Object oCancel_Btn is a Button
93781>>>>>>>        Set Size to 14 50
93782>>>>>>>        Set Label    to "&Cancel"
93783>>>>>>>        Set Location to 98 123
93784>>>>>>>        Set peAnchors to anBottomRight
93785>>>>>>>
93785>>>>>>>        Procedure OnClick
93788>>>>>>>            Send Close_Panel
93789>>>>>>>        End_Procedure
93790>>>>>>>
93790>>>>>>>    End_Object
93791>>>>>>>
93791>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
93792>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
93793>>>>>>>End_Object
93794>>>>>Use cRDCHeaderGroup.pkg  
Including file: cRDCHeaderGroup.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCHeaderGroup.pkg)
93794>>>>>>>//****************************************************************************
93794>>>>>>>// $Module type: Package
93794>>>>>>>// $Module name: cRDCHeaderGroup.pkg
93794>>>>>>>//
93794>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
93794>>>>>>>// Copyright (c) 2017 RDC Tools International
93794>>>>>>>// E-mail      : support@rdctools.com
93794>>>>>>>// Web-site    : http://www.rdctools.com
93794>>>>>>>//
93794>>>>>>>// Created     : 2017-01-05 @ 19:04 (Military date format - Year-Month-Day)
93794>>>>>>>//
93794>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
93794>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
93794>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
93794>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
93794>>>>>>>// in the help folder for more details.
93794>>>>>>>//
93794>>>>>>>//****************************************************************************
93794>>>>>>>Use Windows.pkg
93794>>>>>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCommandLinkButton.pkg)
93794>>>>>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
93794>>>>>>>>>// older versions you will just get a regular great big button.
93794>>>>>>>>>
93794>>>>>>>>>Use Windows.pkg
93794>>>>>>>>>Use CharTranslate.pkg
93794>>>>>>>>>
93794>>>>>>>>>Class cCommandLinkButton is a Button
93795>>>>>>>>>    
93795>>>>>>>>>    Procedure Construct_Object
93797>>>>>>>>>        Forward Send Construct_Object
93799>>>>>>>>>        Property String psPrivateNote
93800>>>>>>>>>    End_Procedure
93801>>>>>>>>>    
93801>>>>>>>>>    Procedure Set psNote String sNote
93803>>>>>>>>>        Boolean bSupported
93803>>>>>>>>>        Set psPrivateNote to sNote
93804>>>>>>>>>        Get IsExControlSupported to bSupported
93805>>>>>>>>>        If bSupported Begin
93807>>>>>>>>>            Send SetWinNote
93808>>>>>>>>>        End
93808>>>>>>>>>>
93808>>>>>>>>>    End_Procedure
93809>>>>>>>>>    
93809>>>>>>>>>    Procedure SetWinNote
93811>>>>>>>>>        WString wNote
93811>>>>>>>>>        Handle hWnd
93811>>>>>>>>>        Integer i
93811>>>>>>>>>        Pointer pVar
93811>>>>>>>>>        Get Form_Window_Handle 0 to hWnd
93812>>>>>>>>>        If hWnd Begin
93814>>>>>>>>>            Get psNote to wNote
93815>>>>>>>>>            Move (SendMessage(hwnd, BCM_SETNOTE, 0, AddressOf(wNote))) to i
93816>>>>>>>>>        End
93816>>>>>>>>>>
93816>>>>>>>>>    End_Procedure
93817>>>>>>>>>    
93817>>>>>>>>>    
93817>>>>>>>>>    Function psNote Returns String
93819>>>>>>>>>        Function_Return (psPrivateNote(Self))
93820>>>>>>>>>    End_Function
93821>>>>>>>>>    
93821>>>>>>>>>    
93821>>>>>>>>>    Procedure Page Integer iState
93823>>>>>>>>>        Integer i hWnd
93823>>>>>>>>>        Boolean bSupported
93823>>>>>>>>>        Get IsExControlSupported to bSupported
93824>>>>>>>>>        If (iState=1 and bSupported) Begin
93826>>>>>>>>>            Get form_style i to i
93827>>>>>>>>>            Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
93828>>>>>>>>>            Forward Send Page iState
93830>>>>>>>>>            Send SetWinNote
93831>>>>>>>>>        End
93831>>>>>>>>>>
93831>>>>>>>>>        Else Begin
93832>>>>>>>>>            Forward Send Page iState
93834>>>>>>>>>        End
93834>>>>>>>>>>
93834>>>>>>>>>    End_Procedure
93835>>>>>>>>>    
93835>>>>>>>>>End_Class
93836>>>>>>>
93836>>>>>>>Define clGreenGrey      for (RGB(64, 84, 93))
93836>>>>>>>Define clGreenGreyLight for (RGB(7, 117, 104))
93836>>>>>>>
93836>>>>>>>Class cRDCHeaderGroupImage is a cCommandLinkButton
93837>>>>>>>    Procedure Construct_Object
93839>>>>>>>        Forward Send Construct_Object
93841>>>>>>>
93841>>>>>>>        Set Size to 18 19
93842>>>>>>>        Set Focus_Mode to NonFocusable
93843>>>>>>>        Set peImageAlign to Button_ImageList_Align_Top
93844>>>>>>>        Set pbAutoResizeIcons to True
93845>>>>>>>    End_Procedure
93846>>>>>>>
93846>>>>>>>    Procedure OnClick
93848>>>>>>>        Broadcast Send Prompt of (Parent(Self))
93850>>>>>>>    End_Procedure
93851>>>>>>>
93851>>>>>>>    Procedure Set Bitmap String sBitmapName
93853>>>>>>>        Forward Set psImage to sBitmapName
93855>>>>>>>    End_Procedure
93856>>>>>>>
93856>>>>>>>    Procedure End_Construct_Object
93858>>>>>>>        Set pbShield to False
93859>>>>>>>        Forward Send End_Construct_Object
93861>>>>>>>    End_Procedure
93862>>>>>>>
93862>>>>>>>End_Class
93863>>>>>>>
93863>>>>>>>// Intermediate class - don't use.
93863>>>>>>>Class _cRDCHeaderGroup is a Container3d
93864>>>>>>>
93864>>>>>>>    Procedure Construct_Object
93866>>>>>>>        Forward Send Construct_Object
93868>>>>>>>
93868>>>>>>>        Property String private.psImage
93869>>>>>>>        Property String private.psLabel
93870>>>>>>>
93870>>>>>>>    End_Procedure
93871>>>>>>>
93871>>>>>>>    Procedure Set psImage String sImage
93873>>>>>>>        Set private.psImage to sImage
93874>>>>>>>    End_Procedure
93875>>>>>>>
93875>>>>>>>    Function psImage Returns String
93877>>>>>>>        Function_Return (private.psImage(Self))
93878>>>>>>>    End_Function
93879>>>>>>>
93879>>>>>>>    Procedure Set psLabel String sLabel
93881>>>>>>>        Set private.psLabel to sLabel
93882>>>>>>>    End_Procedure
93883>>>>>>>
93883>>>>>>>    Function psLabel Returns String
93885>>>>>>>        Function_Return (private.psLabel(Self))
93886>>>>>>>    End_Function
93887>>>>>>>
93887>>>>>>>    // Don't display but allow to use old "Label" syntax to set the value of the oInfo_tb object (header text)
93887>>>>>>>    Procedure Set Label String sLabel
93889>>>>>>>        Set psLabel to sLabel
93890>>>>>>>    End_Procedure
93891>>>>>>>
93891>>>>>>>    Function Label Returns String
93893>>>>>>>        Function_Return (private.psLabel(Self))
93894>>>>>>>    End_Function
93895>>>>>>>
93895>>>>>>>End_Class
93896>>>>>>>
93896>>>>>>>Register_Procedure NavigatePrevious
93896>>>>>>>Register_Procedure NavigateNext
93896>>>>>>>
93896>>>>>>>Class cRDCHeaderGroup is a _cRDCHeaderGroup
93897>>>>>>>
93897>>>>>>>    Procedure Construct_Object
93899>>>>>>>        Forward Send Construct_Object
93901>>>>>>>
93901>>>>>>>        Set peAnchors to anTopLeftRight
93902>>>>>>>        Set pbAcceptDropFiles to True
93903>>>>>>>        Set Border_Style to Border_Normal
93904>>>>>>>
93904>>>>>>>        Property Integer private.piColorOrg
93905>>>>>>>        Property Boolean private.pbIsHeaderGroup True // Don't touch!
93906>>>>>>>        Property String private.psToolTip ""
93907>>>>>>>
93907>>>>>>>        Property Integer piImageColOffset 4
93908>>>>>>>        Property Integer piImageRowOffset -1
93909>>>>>>>        Property String psNote ""
93910>>>>>>>        Property Boolean pbLargeImageSize True
93911>>>>>>>        Property Integer private.piLargeImageSize 24
93912>>>>>>>        Property Integer private.piSmallImageSize 16
93913>>>>>>>        Property Boolean pbUseHotspotColor False
93914>>>>>>>        Property Integer piHeaderHotspotColor clAqua
93915>>>>>>>        Property String private.psLabel ""
93916>>>>>>>        Property Integer piLabelColor clGreenGrey
93917>>>>>>>        Property Boolean pbLabelFontItalics False
93918>>>>>>>        Property Integer piLabelLargeFontHeight 12
93919>>>>>>>        Property Integer piLabelSmallFontHeight 10
93920>>>>>>>        Property Boolean pbUseLargeFontHeight False
93921>>>>>>>
93921>>>>>>>        Property Integer piLabelFontPointWeight fw_Bold
93922>>>>>>>        Property Integer piLabelColOffset 28
93923>>>>>>>        Property Integer piLabelRowOffset 4
93924>>>>>>>        Property Boolean pbCreateTooltipItem True
93925>>>>>>>
93925>>>>>>>        Set pbAcceptDropFiles to True
93926>>>>>>>
93926>>>>>>>        Send Define_ToolTip_Support_Mixin
93927>>>>>>>
93927>>>>>>>        // For the Studio to render the header image
93927>>>>>>>        Set Bitmap to "Default32x32.bmp"
93928>>>>>>>        // This doesn't work... I wonder if there's a way to "trick" the Studio
93928>>>>>>>        // to render some text in the header when in design mode?
93928>>>>>>>        Set Label to "HEADER TEXT"
93929>>>>>>>
93929>>>>>>>        On_Key kLeftArrow  Send NavigatePrevious
93930>>>>>>>        On_Key kUpArrow    Send NavigatePrevious
93931>>>>>>>        On_Key kRightArrow Send NavigateNext
93932>>>>>>>        On_Key kDownArrow  Send NavigateNext
93933>>>>>>>        On_Key kSwitch     Send Switch_Next_Area
93934>>>>>>>    End_Procedure
93935>>>>>>>
93935>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
93936>>>>>>>
93936>>>>>>>    Procedure Set psImage String sImage
93938>>>>>>>        Set Bitmap to ""
93939>>>>>>>        Forward Set psImage to sImage
93941>>>>>>>    End_Procedure
93942>>>>>>>
93942>>>>>>>    Function psImage Returns String
93944>>>>>>>        Function_Return (psImage(Self))
93945>>>>>>>    End_Function
93946>>>>>>>
93946>>>>>>>    Procedure Set Label String sLabel
93948>>>>>>>        Forward Set psLabel to sLabel
93950>>>>>>>    End_Procedure
93951>>>>>>>
93951>>>>>>>    Procedure Set psToolTip String sToolTip
93953>>>>>>>        Set private.psToolTip to sToolTip
93954>>>>>>>    End_Procedure
93955>>>>>>>
93955>>>>>>>    Function psToolTip Returns String
93957>>>>>>>        Function_Return (private.psToolTip(Self))
93958>>>>>>>    End_Function
93959>>>>>>>
93959>>>>>>>    Procedure End_Construct_Object
93961>>>>>>>        String sNote sLabel
93961>>>>>>>        Boolean bUseLargeFontHeight bLargeImageSize bCreateTooltipItem
93961>>>>>>>        Integer iFontHeight iImageSize iLabelRowOffset iLabelColOffset iSize iTextOffset
93961>>>>>>>
93961>>>>>>>        Forward Send End_Construct_Object
93963>>>>>>>
93963>>>>>>>        Get piLabelColOffset to iLabelColOffset
93964>>>>>>>        Get pbUseLargeFontHeight to bUseLargeFontHeight
93965>>>>>>>        If (bUseLargeFontHeight = True) Begin
93967>>>>>>>            Get piLabelLargeFontHeight to iFontHeight
93968>>>>>>>            Move 8 to iLabelRowOffset
93969>>>>>>>        End
93969>>>>>>>>
93969>>>>>>>        Else Begin
93970>>>>>>>            Get piLabelSmallFontHeight to iFontHeight
93971>>>>>>>            Move 6 to iLabelRowOffset
93972>>>>>>>        End
93972>>>>>>>>
93972>>>>>>>
93972>>>>>>>        Get pbLargeImageSize to bLargeImageSize
93973>>>>>>>        If (bLargeImageSize = True) Begin
93975>>>>>>>            Get private.piLargeImageSize to iImageSize
93976>>>>>>>        End
93976>>>>>>>>
93976>>>>>>>        Else Begin
93977>>>>>>>            Get private.piSmallImageSize to iImageSize
93978>>>>>>>            Move (iLabelColOffset - 6) to iLabelColOffset
93979>>>>>>>        End
93979>>>>>>>>
93979>>>>>>>
93979>>>>>>>        Object oHeaderGroupImage is a cRDCHeaderGroupImage
93981>>>>>>>            Set piImageSize to iImageSize
93982>>>>>>>            Set Location to (piImageRowOffset(Self)) (piImageColOffset(Self))
93983>>>>>>>            Set psImage to (private.psImage(Self))
93984>>>>>>>            Set peImageAlign to Button_ImageList_Align_Center
93985>>>>>>>            Set psToolTip to (private.psToolTip(Self))
93986>>>>>>>        End_Object
93987>>>>>>>
93987>>>>>>>        Object oHeaderGroupInfo_tb is a TextBox
93989>>>>>>>            Set Size to 12 100
93990>>>>>>>            Set Location to (piLabelRowOffset(Self)) iLabelColOffset
93991>>>>>>>            Set FontWeight to (piLabelFontPointWeight(Self))
93992>>>>>>>            Set FontItalics to (pbLabelFontItalics(Self))
93993>>>>>>>            Set FontPointHeight to iFontHeight
93994>>>>>>>            Set Label to (private.psLabel(Self))
93995>>>>>>>            Set TextColor to (piLabelColor(Self))
93996>>>>>>>            Set psToolTip to (private.psToolTip(Self))
93997>>>>>>>            Get Size to iSize
93998>>>>>>>        End_Object
93999>>>>>>>
93999>>>>>>>        // ToDo: The positioning logic for placing the info image to the right of the header text is flawed.
93999>>>>>>>        // How can it be improved?
93999>>>>>>>        Get pbCreateTooltipItem to bCreateTooltipItem
94000>>>>>>>        If (bCreateTooltipItem = True and private.psToolTip(Self) <> "") Begin
94002>>>>>>>            Get private.psLabel to sLabel
94003>>>>>>>            Get Text_Extent sLabel to iTextOffset
94004>>>>>>>            Move (Low(iTextOffset) -0)  to iTextOffset
94005>>>>>>>            Object oHeaderGroupTooltip_tb is a TextBox
94007>>>>>>>                Set Size to 10 10
94008>>>>>>>                If (bUseLargeFontHeight = True) Begin
94010>>>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset //(Low(iSize) + (iTextOffset))
94010>>>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + (iLabelColOffset * 2) + 10)
94011>>>>>>>                End
94011>>>>>>>>
94011>>>>>>>                Else Begin
94012>>>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset
94012>>>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + iLabelColOffset + 25)
94013>>>>>>>                End
94013>>>>>>>>
94013>>>>>>>                Set psToolTip to (private.psToolTip(Self))
94014>>>>>>>                Set Bitmap to "ActionAbout.bmp"
94015>>>>>>>            End_Object
94016>>>>>>>        End
94016>>>>>>>>
94016>>>>>>>
94016>>>>>>>        Get psNote to sNote
94017>>>>>>>        If (Trim(sNote) <> "") Begin
94019>>>>>>>            Object oHeaderGroupNote_tb is a TextBox
94021>>>>>>>                Set Size to 12 100
94022>>>>>>>                Set Location to (Hi(iSize) + iLabelRowOffset) (iLabelColOffset + 8)
94023>>>>>>>                Set Label to ("-" * String(sNote))
94024>>>>>>>                Set TextColor to (piLabelColor(Self))
94025>>>>>>>                Set FontPointHeight to 9
94026>>>>>>>                Set psToolTip to (private.psToolTip(Self))
94027>>>>>>>            End_Object
94028>>>>>>>        End
94028>>>>>>>>
94028>>>>>>>
94028>>>>>>>    End_Procedure
94029>>>>>>>
94029>>>>>>>    Function Popup_State Returns Boolean
94031>>>>>>>        Boolean bIsPopup
94031>>>>>>>        Get Popup_State of (Parent(Self)) to bIsPopup
94032>>>>>>>        Function_Return bIsPopup
94033>>>>>>>    End_Function
94034>>>>>>>
94034>>>>>>>    Procedure OnEnterArea Handle hoFrom
94036>>>>>>>        Integer iColor
94036>>>>>>>        Forward Send OnEnterArea hoFrom
94038>>>>>>>        // Not ideal, but works most of the time.
94038>>>>>>>        //       When navigating to i.e a popup we don't want
94038>>>>>>>        //       the coloring to appear. Else there will be 2
94038>>>>>>>        //       cRDCHeaderGroup's with the highlight color...
94038>>>>>>>        // Is there a better way?
94038>>>>>>>        If (hoFrom <> Desktop and hoFrom < Parent(Self)) Begin
94040>>>>>>>            Procedure_Return
94041>>>>>>>        End
94041>>>>>>>>
94041>>>>>>>        If (pbUseHotspotColor(Self) = True) Begin
94043>>>>>>>            Get Color to iColor
94044>>>>>>>            Set private.piColorOrg to iColor
94045>>>>>>>            Get piHeaderHotspotColor to iColor
94046>>>>>>>            Set Color to iColor
94047>>>>>>>            Broadcast Recursive Set Color to iColor
94049>>>>>>>        End
94049>>>>>>>>
94049>>>>>>>    End_Procedure
94050>>>>>>>
94050>>>>>>>    Procedure OnExitArea Handle hoFrom
94052>>>>>>>        Integer iColor
94052>>>>>>>        Forward Send OnExitArea hoFrom
94054>>>>>>>        If (pbUseHotspotColor(Self) = True) Begin
94056>>>>>>>            Get private.piColorOrg to iColor
94057>>>>>>>            Set Color to iColor
94058>>>>>>>            Broadcast Recursive Set Color to iColor
94060>>>>>>>        End
94060>>>>>>>>
94060>>>>>>>    End_Procedure
94061>>>>>>>
94061>>>>>>>    // Public access message to change the group header text color at runtime.
94061>>>>>>>    Procedure Set Label_Color Integer iColor
94063>>>>>>>        Set TextColor of (oHeaderGroupInfo_tb(Self)) to iColor
94064>>>>>>>    End_Procedure
94065>>>>>>>
94065>>>>>>>    Procedure NavigatePrevious
94067>>>>>>>        Integer iMulti ivoid iLastErr
94067>>>>>>>        Handle hWnd
94067>>>>>>>        Boolean bErr
94067>>>>>>>
94067>>>>>>>        Move Err to bErr
94068>>>>>>>        Move LastErr to iLastErr
94069>>>>>>>
94069>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
94070>>>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
94071>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
94072>>>>>>>        If (Err) Begin
94074>>>>>>>            Move bErr to Err
94075>>>>>>>            Move iLastErr to LastErr
94076>>>>>>>            Procedure_Return
94077>>>>>>>        End
94077>>>>>>>>
94077>>>>>>>
94077>>>>>>>        Move bErr to Err
94078>>>>>>>        Move iLastErr to LastErr
94079>>>>>>>        If (iMulti = Multi_Select) Begin
94081>>>>>>>            Send Previous
94082>>>>>>>        End
94082>>>>>>>>
94082>>>>>>>        Else Begin
94083>>>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
94084>>>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
94085>>>>>>>        End
94085>>>>>>>>
94085>>>>>>>    End_Procedure
94086>>>>>>>
94086>>>>>>>    Procedure NavigateNext
94088>>>>>>>        Integer iMulti iVoid iLastErr
94088>>>>>>>        Handle hWnd
94088>>>>>>>        Boolean bErr
94088>>>>>>>
94088>>>>>>>        Move Err to bErr
94089>>>>>>>        Move LastErr to iLastErr
94090>>>>>>>
94090>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
94091>>>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
94092>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
94093>>>>>>>        If (Err) Begin
94095>>>>>>>            Move bErr to Err
94096>>>>>>>            Move iLastErr to LastErr
94097>>>>>>>            Procedure_Return
94098>>>>>>>        End
94098>>>>>>>>
94098>>>>>>>
94098>>>>>>>        Move bErr to Err
94099>>>>>>>        Move iLastErr to LastErr
94100>>>>>>>        If (iMulti = Multi_Select) Begin
94102>>>>>>>            Send Next
94103>>>>>>>        End
94103>>>>>>>>
94103>>>>>>>        Else Begin
94104>>>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
94105>>>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
94106>>>>>>>        End
94106>>>>>>>>
94106>>>>>>>
94106>>>>>>>    End_Procedure
94107>>>>>>>
94107>>>>>>>    Procedure Enable_Window Integer iState
94109>>>>>>>        Handle hWnd
94109>>>>>>>        Get Window_Handle to hWnd
94110>>>>>>>        If hWnd Begin
94112>>>>>>>            Move (EnableWindow(hWnd, iState)) to hWnd
94113>>>>>>>        End
94113>>>>>>>>
94113>>>>>>>    End_Procedure
94114>>>>>>>
94114>>>>>>>    Procedure Page_Object Integer iState
94116>>>>>>>        Handle hWnd
94116>>>>>>>        Get Window_Handle to hWnd
94117>>>>>>>        Forward Send Page_Object iState
94119>>>>>>>        If (hWnd = 0 and iState) Begin
94121>>>>>>>            Send Shadow_Display
94122>>>>>>>        End
94122>>>>>>>>
94122>>>>>>>    End_Procedure
94123>>>>>>>
94123>>>>>>>    Procedure Shadow_Display
94125>>>>>>>        Send Enable_Window (not(Object_Shadow_State(Self)))
94126>>>>>>>    End_Procedure
94127>>>>>>>
94127>>>>>>>    Function Explicit_Shadow_State Returns Boolean
94129>>>>>>>        Function_Return (Private.Explicit_Shadow_State(Self))
94130>>>>>>>    End_Function
94131>>>>>>>
94131>>>>>>>    // For some reason we need to augment this event to allow
94131>>>>>>>    // files to be dropped on a cRDCHeaderGroup object; else nothing will
94131>>>>>>>    // happen.
94131>>>>>>>    Procedure OnFileDropped String sFilename Boolean bLast
94133>>>>>>>        Delegate Send OnFileDropped sFilename bLast
94135>>>>>>>    End_Procedure
94136>>>>>>>
94136>>>>>>>End_Class
94137>>>>>>>
94137>>>>>>>// We don't want the broadcast of setting color to set the background
94137>>>>>>>// color for forms that are within a cRDCHeaderGroup object.
94137>>>>>>>// If the Form is not within a cRDCHeaderGroup the Form class should
94137>>>>>>>// behave as it always has. But if you don't like this; just comment
94137>>>>>>>// it out.
94137>>>>>>>//Procedure Set Color for Form Integer eColor
94137>>>>>>>//    Boolean bIsHeaderGroup bErr bEnabled_State
94137>>>>>>>//    Integer iLastErr
94137>>>>>>>//
94137>>>>>>>//    Move Err to bErr
94137>>>>>>>//    Move LastErr to iLastErr
94137>>>>>>>//
94137>>>>>>>//    Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
94137>>>>>>>//    Delegate Get private.pbIsHeaderGroup to bIsHeaderGroup
94137>>>>>>>//    Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
94137>>>>>>>//    Move bErr to Err
94137>>>>>>>//    Move iLastErr to LastErr
94137>>>>>>>//    If (bIsHeaderGroup = False) Begin
94137>>>>>>>//        Forward Set Color to eColor
94137>>>>>>>//    End
94137>>>>>>>//End_Procedure
94137>>>>>Use DriverSettings.dg
Including file: DriverSettings.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DriverSettings.dg)
94137>>>>>>>Use cApplication.pkg
94137>>>>>>>Use Dfline.pkg
94137>>>>>>>Use cRichEdit.pkg
94137>>>>>>>Use cScrollingContainer.pkg
Including file: cScrollingContainer.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cScrollingContainer.pkg)
94137>>>>>>>>>// Provides support for scrolling containers.
94137>>>>>>>>>// Scrolling containers is provided by creating two objects,
94137>>>>>>>>>// a host (cScrollingContainer) and a scrolling clientarea (cScrollingClientArea)
94137>>>>>>>>>// The host has no public interface, you just drop the object. It should have only one child object
94137>>>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
94137>>>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
94137>>>>>>>>>
94137>>>>>>>>>Use Windows.pkg
94137>>>>>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cScrollingContainerMixin.pkg)
94137>>>>>>>>>>>// Mixin classes for scrolling container support:
94137>>>>>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
94137>>>>>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
94137>>>>>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
94137>>>>>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
94137>>>>>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
94137>>>>>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
94137>>>>>>>>>>>
94137>>>>>>>>>>>Use Windows.pkg
94137>>>>>>>>>>>Use Winuser.pkg
94137>>>>>>>>>>>Use tWinStructs.pkg
94137>>>>>>>>>>>
94137>>>>>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
94137>>>>>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
94137>>>>>>>>>>>// support for the scrolling client area mixin object.
94137>>>>>>>>>>>
94137>>>>>>>>>>>Class cScrollingClientAreaMixin is a Mixin
94138>>>>>>>>>>>    
94138>>>>>>>>>>>    Procedure Define_cScrollingClientAreaMixin
94140>>>>>>>>>>>        
94140>>>>>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
94141>>>>>>>>>>>        Set Border_Style to Border_None
94142>>>>>>>>>>>        
94142>>>>>>>>>>>        Property Boolean pbAutoScroll True
94143>>>>>>>>>>>        Property Boolean pbAutoScrollFocus True
94144>>>>>>>>>>>        Property Integer piAutoScrollMarginX 5
94145>>>>>>>>>>>        Property Integer piAutoScrollMarginY 5
94146>>>>>>>>>>>        Property Integer piAutoScrollMinX 0
94147>>>>>>>>>>>        Property Integer piAutoScrollMinY 0
94148>>>>>>>>>>>        Property Boolean pbShowDisabledScrollBar False
94149>>>>>>>>>>>        
94149>>>>>>>>>>>        
94149>>>>>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
94150>>>>>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
94151>>>>>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
94152>>>>>>>>>>>        // keeps track of scrolling
94152>>>>>>>>>>>        Property Integer piCurrentVertScrolled 0
94153>>>>>>>>>>>        Property Integer piCurrentHorzScrolled 0
94154>>>>>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
94155>>>>>>>>>>>        Delegate Set phoScrollingClientArea to Self
94157>>>>>>>>>>>        
94157>>>>>>>>>>>        // set this true to make this a tabbed workspace view (design time)
94157>>>>>>>>>>>        Property Boolean pbTabWorkspaceView False
94158>>>>>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
94158>>>>>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
94159>>>>>>>>>>>    End_Procedure
94160>>>>>>>>>>>    
94160>>>>>>>>>>>    // low level event sent from windows.
94160>>>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
94162>>>>>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
94162>>>>>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
94163>>>>>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
94164>>>>>>>>>>>        If (wParam<0) Begin
94166>>>>>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
94167>>>>>>>>>>>        End
94167>>>>>>>>>>>>
94167>>>>>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
94168>>>>>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
94169>>>>>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
94169>>>>>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
94170>>>>>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
94171>>>>>>>>>>>        // If we have enough Clicks send OnMouseWheel
94171>>>>>>>>>>>        If (iClicks<>0) Begin
94173>>>>>>>>>>>            Send OnMouseWheel iClicks iKeys
94174>>>>>>>>>>>        End
94174>>>>>>>>>>>>
94174>>>>>>>>>>>        // tell windows that we've handled the event.
94174>>>>>>>>>>>        Set Windows_Override_State to True
94175>>>>>>>>>>>    End_Procedure
94176>>>>>>>>>>>    
94176>>>>>>>>>>>    
94176>>>>>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
94176>>>>>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
94178>>>>>>>>>>>        Integer iLineScrollUnit
94178>>>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
94179>>>>>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
94180>>>>>>>>>>>    End_Procedure
94181>>>>>>>>>>>    
94181>>>>>>>>>>>    // should be sent by WM_VSCROLL
94181>>>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
94183>>>>>>>>>>>        Boolean bOk
94183>>>>>>>>>>>        tWinScrollInfo ScrollInfo
94183>>>>>>>>>>>        tWinScrollInfo ScrollInfo
94183>>>>>>>>>>>        Integer iLineScrollUnit
94183>>>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
94184>>>>>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
94185>>>>>>>>>>>        If bOk Begin
94187>>>>>>>>>>>            
94187>>>>>>>>>>>            Case Begin
94187>>>>>>>>>>>                Case (iType=SB_PAGEDOWN)
94189>>>>>>>>>>>                    Send VScroll ScrollInfo.nPage
94190>>>>>>>>>>>                    Case Break
94191>>>>>>>>>>>                
94191>>>>>>>>>>>                Case (iType=SB_PAGEUP)
94194>>>>>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
94195>>>>>>>>>>>                    Case Break
94196>>>>>>>>>>>                
94196>>>>>>>>>>>                Case (iType=SB_LINEDOWN)
94199>>>>>>>>>>>                    Send VScroll iLineScrollUnit
94200>>>>>>>>>>>                    Case Break
94201>>>>>>>>>>>                
94201>>>>>>>>>>>                Case (iType=SB_LINEUP)
94204>>>>>>>>>>>                    Send VScroll (-iLineScrollUnit)
94205>>>>>>>>>>>                    Case Break
94206>>>>>>>>>>>                
94206>>>>>>>>>>>                Case (iType=SB_BOTTOM)
94209>>>>>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
94210>>>>>>>>>>>                    Case Break
94211>>>>>>>>>>>                
94211>>>>>>>>>>>                Case (iType=SB_Top)
94214>>>>>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
94215>>>>>>>>>>>                    Case Break
94216>>>>>>>>>>>                
94216>>>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
94219>>>>>>>>>>>                    Case Break
94220>>>>>>>>>>>                
94220>>>>>>>>>>>                Case (iType=SB_THUMBTRACK)
94223>>>>>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
94224>>>>>>>>>>>                    Case Break
94225>>>>>>>>>>>            Case End
94225>>>>>>>>>>>        End
94225>>>>>>>>>>>>
94225>>>>>>>>>>>    End_Procedure
94226>>>>>>>>>>>    
94226>>>>>>>>>>>    // should be sent by WM_HSCROLL
94226>>>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
94228>>>>>>>>>>>        Boolean bOk
94228>>>>>>>>>>>        tWinScrollInfo ScrollInfo
94228>>>>>>>>>>>        tWinScrollInfo ScrollInfo
94228>>>>>>>>>>>        Integer iLineScrollUnit
94228>>>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
94229>>>>>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
94230>>>>>>>>>>>        If bOk Begin
94232>>>>>>>>>>>            
94232>>>>>>>>>>>            Case Begin
94232>>>>>>>>>>>                Case (iType=SB_PAGEDOWN)
94234>>>>>>>>>>>                    Send hScroll ScrollInfo.nPage
94235>>>>>>>>>>>                    Case Break
94236>>>>>>>>>>>                
94236>>>>>>>>>>>                Case (iType=SB_PAGEUP)
94239>>>>>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
94240>>>>>>>>>>>                    Case Break
94241>>>>>>>>>>>                
94241>>>>>>>>>>>                Case (iType=SB_LINEDOWN)
94244>>>>>>>>>>>                    Send hScroll iLineScrollUnit
94245>>>>>>>>>>>                    Case Break
94246>>>>>>>>>>>                
94246>>>>>>>>>>>                Case (iType=SB_LINEUP)
94249>>>>>>>>>>>                    Send hScroll (-iLineScrollUnit)
94250>>>>>>>>>>>                    Case Break
94251>>>>>>>>>>>                
94251>>>>>>>>>>>                Case (iType=SB_BOTTOM)
94254>>>>>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
94255>>>>>>>>>>>                    Case Break
94256>>>>>>>>>>>                
94256>>>>>>>>>>>                Case (iType=SB_Top)
94259>>>>>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
94260>>>>>>>>>>>                    Case Break
94261>>>>>>>>>>>                
94261>>>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
94264>>>>>>>>>>>                    Case Break
94265>>>>>>>>>>>                
94265>>>>>>>>>>>                Case (iType=SB_THUMBTRACK)
94268>>>>>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
94269>>>>>>>>>>>                    Case Break
94270>>>>>>>>>>>            Case End
94270>>>>>>>>>>>        End
94270>>>>>>>>>>>>
94270>>>>>>>>>>>    End_Procedure
94271>>>>>>>>>>>    
94271>>>>>>>>>>>    
94271>>>>>>>>>>>    // this calls SetScrollInfo with proper info
94271>>>>>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
94273>>>>>>>>>>>        tWinScrollInfo ScrollInfo
94273>>>>>>>>>>>        tWinScrollInfo ScrollInfo
94273>>>>>>>>>>>        Integer iVoid
94273>>>>>>>>>>>        Handle hWnd
94273>>>>>>>>>>>        Boolean bShow
94273>>>>>>>>>>>        
94273>>>>>>>>>>>        Delegate Get Window_Handle to hWnd
94275>>>>>>>>>>>        If (hWnd <> 0) Begin
94277>>>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
94278>>>>>>>>>>>            
94278>>>>>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
94279>>>>>>>>>>>            Get pbShowDisabledScrollBar to bShow
94280>>>>>>>>>>>            If bShow Begin
94282>>>>>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
94283>>>>>>>>>>>            End
94283>>>>>>>>>>>>
94283>>>>>>>>>>>            Move iRangeMin to ScrollInfo.nMin
94284>>>>>>>>>>>            Move iRangeMax to ScrollInfo.nMax
94285>>>>>>>>>>>            Move iPageSize to ScrollInfo.nPage
94286>>>>>>>>>>>            Move 0 to ScrollInfo.nPos
94287>>>>>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
94288>>>>>>>>>>>            
94288>>>>>>>>>>>        End
94288>>>>>>>>>>>>
94288>>>>>>>>>>>    End_Procedure
94289>>>>>>>>>>>    
94289>>>>>>>>>>>    // this wraps GetScrollInfo
94289>>>>>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
94291>>>>>>>>>>>        Boolean bOk
94291>>>>>>>>>>>        Handle hWnd
94291>>>>>>>>>>>        
94291>>>>>>>>>>>        Delegate Get Window_Handle to hWnd
94293>>>>>>>>>>>        If (hWnd <> 0) Begin
94295>>>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
94296>>>>>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
94297>>>>>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
94298>>>>>>>>>>>        End
94298>>>>>>>>>>>>
94298>>>>>>>>>>>        Function_Return bOk
94299>>>>>>>>>>>    End_Function
94300>>>>>>>>>>>    
94300>>>>>>>>>>>    // this wraps SetScrollPos
94300>>>>>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
94302>>>>>>>>>>>        Integer iVoid
94302>>>>>>>>>>>        Handle hWnd
94302>>>>>>>>>>>        
94302>>>>>>>>>>>        Delegate Get Window_Handle to hWnd
94304>>>>>>>>>>>        If (hWnd <> 0) Begin
94306>>>>>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
94307>>>>>>>>>>>        End
94307>>>>>>>>>>>>
94307>>>>>>>>>>>    End_Procedure
94308>>>>>>>>>>>    
94308>>>>>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
94308>>>>>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
94308>>>>>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
94310>>>>>>>>>>>        Send ScrollClientArea
94311>>>>>>>>>>>    End_Procedure
94312>>>>>>>>>>>    
94312>>>>>>>>>>>    // augment to handle the scrolling area initialization.
94312>>>>>>>>>>>    Procedure Add_Focus Handle hoParent
94314>>>>>>>>>>>        Forward Send Add_Focus hoParent
94316>>>>>>>>>>>        // at this the scrolling container and client area should both be paged.
94316>>>>>>>>>>>        // child objects ae also paged with initial anchors applied
94316>>>>>>>>>>>        Send CalculateAutoScrollMinimums
94317>>>>>>>>>>>    End_Procedure
94318>>>>>>>>>>>    
94318>>>>>>>>>>>    Procedure Page Integer iPage
94320>>>>>>>>>>>        Forward Send Page iPage
94322>>>>>>>>>>>        If iPage Begin
94324>>>>>>>>>>>            // at this the scrolling container and client area should both be paged
94324>>>>>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
94324>>>>>>>>>>>            // the child items are paged (else they may get anchored oddly)
94324>>>>>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
94324>>>>>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
94324>>>>>>>>>>>            // before they were really needed. This should be more accurate
94324>>>>>>>>>>>            Send SetScrollBarInfo True 0 0 0
94325>>>>>>>>>>>            Send SetScrollBarInfo False 0 0 0
94326>>>>>>>>>>>        End
94326>>>>>>>>>>>>
94326>>>>>>>>>>>    End_Procedure
94327>>>>>>>>>>>    
94327>>>>>>>>>>>    // determine scrolling minimums and set the client area as required.
94327>>>>>>>>>>>    
94327>>>>>>>>>>>    Procedure CalculateAutoScrollMinimums
94329>>>>>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
94329>>>>>>>>>>>        Integer iAutoMinX iAutoMinY
94329>>>>>>>>>>>        Boolean bAutoScroll
94329>>>>>>>>>>>        Handle hoNext hoFirst
94329>>>>>>>>>>>        
94329>>>>>>>>>>>        Get pbAutoScroll to bAutoScroll
94330>>>>>>>>>>>        Get piAutoScrollMinX to iAutoMinX
94331>>>>>>>>>>>        Get piAutoScrollMinY to iAutoMinY
94332>>>>>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
94333>>>>>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
94334>>>>>>>>>>>        Move (Low(iSiz)) to iAutoMinX
94335>>>>>>>>>>>        Set piMinimumHeight to iAutoMinY
94336>>>>>>>>>>>        Set piMinimumWidth to iAutoMinX
94337>>>>>>>>>>>        
94337>>>>>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
94339>>>>>>>>>>>            
94339>>>>>>>>>>>            Get Next_Level to hoFirst
94340>>>>>>>>>>>            Move hoFirst to hoNext
94341>>>>>>>>>>>            If (hoFirst) Begin
94343>>>>>>>>>>>                Repeat
94343>>>>>>>>>>>>
94343>>>>>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
94344>>>>>>>>>>>                    Get GuiLocation of hoNext to iLoc
94345>>>>>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
94346>>>>>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
94347>>>>>>>>>>>                    Get Next_Focus of hoNext to hoNext
94348>>>>>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
94350>>>>>>>>>>>                
94350>>>>>>>>>>>                If (iAutoMinY=0) Begin
94352>>>>>>>>>>>                    Get piAutoScrollMarginY to iMargin
94353>>>>>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
94354>>>>>>>>>>>                End
94354>>>>>>>>>>>>
94354>>>>>>>>>>>                
94354>>>>>>>>>>>                If (iAutoMinX=0) Begin
94356>>>>>>>>>>>                    Get piAutoScrollMarginX to iMargin
94357>>>>>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
94358>>>>>>>>>>>                    
94358>>>>>>>>>>>                End
94358>>>>>>>>>>>>
94358>>>>>>>>>>>            End
94358>>>>>>>>>>>>
94358>>>>>>>>>>>        End
94358>>>>>>>>>>>>
94358>>>>>>>>>>>        
94358>>>>>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
94358>>>>>>>>>>>        Broadcast Set pbAnchorCreated to False
94360>>>>>>>>>>>        Send ScrollClientArea
94361>>>>>>>>>>>        // after the scroll set up, reinitialize all anchors.
94361>>>>>>>>>>>        Broadcast Send DoCreateAnchors
94363>>>>>>>>>>>    End_Procedure
94364>>>>>>>>>>>    
94364>>>>>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
94364>>>>>>>>>>>    // work of scrolling.
94364>>>>>>>>>>>    
94364>>>>>>>>>>>    Procedure ScrollClientArea
94366>>>>>>>>>>>        Integer iSiz
94366>>>>>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
94366>>>>>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
94366>>>>>>>>>>>        Integer iSzY iSzX iLocX iLocY
94366>>>>>>>>>>>        
94366>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
94368>>>>>>>>>>>        Move (Hi(iSiz)) to iHeight
94369>>>>>>>>>>>        Move (Low(iSiz)) to iWidth
94370>>>>>>>>>>>        
94370>>>>>>>>>>>        // Vertical scrolling
94370>>>>>>>>>>>        
94370>>>>>>>>>>>        Get piMinimumHeight to iOrig
94371>>>>>>>>>>>        Get piMinimumWidth to iWOrig
94372>>>>>>>>>>>        
94372>>>>>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
94374>>>>>>>>>>>            
94374>>>>>>>>>>>            If (iOrig<>0) Begin
94376>>>>>>>>>>>                Get piCurrentVertScrolled to iHCur
94377>>>>>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
94377>>>>>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
94379>>>>>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
94380>>>>>>>>>>>                    Set piCurrentVertScrolled to iHCur
94381>>>>>>>>>>>                End
94381>>>>>>>>>>>>
94381>>>>>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
94383>>>>>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
94384>>>>>>>>>>>                    Send SetScrollBarPosInfo True iHCur
94385>>>>>>>>>>>                End
94385>>>>>>>>>>>>
94385>>>>>>>>>>>                Else Begin
94386>>>>>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
94387>>>>>>>>>>>                End
94387>>>>>>>>>>>>
94387>>>>>>>>>>>            End
94387>>>>>>>>>>>>
94387>>>>>>>>>>>            
94387>>>>>>>>>>>            // Horiz scrolling
94387>>>>>>>>>>>            
94387>>>>>>>>>>>            Get piCurrentHorzScrolled to iWCur
94388>>>>>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
94388>>>>>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
94390>>>>>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
94391>>>>>>>>>>>                Set piCurrentHorzScrolled to iWCur
94392>>>>>>>>>>>            End
94392>>>>>>>>>>>>
94392>>>>>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
94394>>>>>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
94395>>>>>>>>>>>                Send SetScrollBarPosInfo False iWCur
94396>>>>>>>>>>>            End
94396>>>>>>>>>>>>
94396>>>>>>>>>>>            Else Begin
94397>>>>>>>>>>>                Send SetScrollBarInfo False 0 0 0
94398>>>>>>>>>>>            End
94398>>>>>>>>>>>>
94398>>>>>>>>>>>        End
94398>>>>>>>>>>>>
94398>>>>>>>>>>>        
94398>>>>>>>>>>>        // this could change depending on scrollbars appearing or not
94398>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
94400>>>>>>>>>>>        
94400>>>>>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
94400>>>>>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
94400>>>>>>>>>>>        // This is required to make anchors work sensibly
94400>>>>>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
94401>>>>>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
94402>>>>>>>>>>>        Move (-iHCur) to iLocY
94403>>>>>>>>>>>        Move (-iWCur) to iLocX
94404>>>>>>>>>>>        
94404>>>>>>>>>>>        // Allow chance to make modifications
94404>>>>>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
94405>>>>>>>>>>>        
94405>>>>>>>>>>>        Set GuiSize to iSzY iSzX
94406>>>>>>>>>>>        // if we've scrolled, we need to reposition the container
94406>>>>>>>>>>>        Set GuiLocation to iLocY iLocX
94407>>>>>>>>>>>    End_Procedure
94408>>>>>>>>>>>    
94408>>>>>>>>>>>    // note that scrolling never changes the size of the scrolling client.
94408>>>>>>>>>>>    // this way, it does not interfere with anchors.
94408>>>>>>>>>>>    
94408>>>>>>>>>>>    Procedure VScroll Integer iDelta
94410>>>>>>>>>>>        Integer iHeight iCur iOrig iSiz
94410>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
94412>>>>>>>>>>>        Move (hi(iSiz)) to iHeight
94413>>>>>>>>>>>        Get piCurrentVertScrolled to iCur
94414>>>>>>>>>>>        Get piMinimumHeight to iOrig
94415>>>>>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
94417>>>>>>>>>>>            Procedure_Return
94418>>>>>>>>>>>        End
94418>>>>>>>>>>>>
94418>>>>>>>>>>>        // make sure delta is within range
94418>>>>>>>>>>>        If (iDelta+iCur<0) Begin
94420>>>>>>>>>>>            Move (-iCur) to iDelta
94421>>>>>>>>>>>        End
94421>>>>>>>>>>>>
94421>>>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
94424>>>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
94425>>>>>>>>>>>        End
94425>>>>>>>>>>>>
94425>>>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
94428>>>>>>>>>>>        
94428>>>>>>>>>>>        Move (iCur + iDelta) to iCur
94429>>>>>>>>>>>        Set piCurrentVertScrolled to iCur
94430>>>>>>>>>>>        Send SetScrollBarPosInfo True iCur
94431>>>>>>>>>>>        Get GuiLocation to iSiz
94432>>>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
94433>>>>>>>>>>>        Send ScrollClientArea
94434>>>>>>>>>>>    End_Procedure
94435>>>>>>>>>>>    
94435>>>>>>>>>>>    
94435>>>>>>>>>>>    Procedure HScroll Integer iDelta
94437>>>>>>>>>>>        Integer iHeight iCur iOrig iSiz
94437>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
94439>>>>>>>>>>>        Move (low(iSiz)) to iHeight
94440>>>>>>>>>>>        Get piCurrentHorzScrolled to iCur
94441>>>>>>>>>>>        Get piMinimumWidth to iOrig
94442>>>>>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
94444>>>>>>>>>>>            Procedure_Return
94445>>>>>>>>>>>        End
94445>>>>>>>>>>>>
94445>>>>>>>>>>>        If (iDelta+iCur<0) Begin
94447>>>>>>>>>>>            Move (-iCur) to iDelta
94448>>>>>>>>>>>        End
94448>>>>>>>>>>>>
94448>>>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
94451>>>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
94452>>>>>>>>>>>        End
94452>>>>>>>>>>>>
94452>>>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
94455>>>>>>>>>>>        
94455>>>>>>>>>>>        Move (iCur + iDelta) to iCur
94456>>>>>>>>>>>        Set piCurrentHorzScrolled to iCur
94457>>>>>>>>>>>        Send SetScrollBarPosInfo False iCur
94458>>>>>>>>>>>        Get GuiLocation to iSiz
94459>>>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
94460>>>>>>>>>>>        Send ScrollClientArea
94461>>>>>>>>>>>    End_Procedure
94462>>>>>>>>>>>    
94462>>>>>>>>>>>    // make sure client is a 0,0
94462>>>>>>>>>>>    Procedure ScrollHome
94464>>>>>>>>>>>        Send SetVScrollbox SB_TOP 0
94465>>>>>>>>>>>        Send SetHScrollbox SB_TOP 0
94466>>>>>>>>>>>    End_Procedure
94467>>>>>>>>>>>    
94467>>>>>>>>>>>    // get relative GUI location of this object to the parent one passed.
94467>>>>>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
94469>>>>>>>>>>>        Integer ivoid
94469>>>>>>>>>>>        tWinRect Rect0 Rect1
94469>>>>>>>>>>>        tWinRect Rect0 Rect1
94469>>>>>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
94470>>>>>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
94471>>>>>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
94472>>>>>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
94473>>>>>>>>>>>    End_Procedure
94474>>>>>>>>>>>    
94474>>>>>>>>>>>    // This scrolls this object into visual range.
94474>>>>>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
94476>>>>>>>>>>>        Handle hoScrollingContainer
94476>>>>>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
94476>>>>>>>>>>>        Integer iViewHeight iViewWidth
94476>>>>>>>>>>>        Integer iRelLocHeight iRelLocWidth
94476>>>>>>>>>>>        Integer iSize iControlHeight iControlWidth
94476>>>>>>>>>>>        Integer iScroll
94476>>>>>>>>>>>        Integer iMarginX iMarginY
94476>>>>>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
94476>>>>>>>>>>>        
94476>>>>>>>>>>>        Get piAutoScrollMarginX to iMarginX
94477>>>>>>>>>>>        Get piAutoScrollMarginY to iMarginY
94478>>>>>>>>>>>        
94478>>>>>>>>>>>        // the scrolling container
94478>>>>>>>>>>>        Move Self to hoScrollingContainer
94479>>>>>>>>>>>        // the amount the SC is currently scrolled
94479>>>>>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
94480>>>>>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
94481>>>>>>>>>>>        
94481>>>>>>>>>>>        // size of view's client area (this is the viewport area)
94481>>>>>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
94482>>>>>>>>>>>        Move (hi(iSize)) to iViewHeight
94483>>>>>>>>>>>        Move (low(iSize)) to iViewWidth
94484>>>>>>>>>>>        
94484>>>>>>>>>>>        // get this object's location relative to the scrolling container
94484>>>>>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
94485>>>>>>>>>>>        
94485>>>>>>>>>>>        // we expect that the client size is the window size but just in case
94485>>>>>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
94486>>>>>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
94487>>>>>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
94488>>>>>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
94489>>>>>>>>>>>        
94489>>>>>>>>>>>        // the outer size of the control object
94489>>>>>>>>>>>        Get GUIWindowSize of hoControl to iSize
94490>>>>>>>>>>>        Move (hi(iSize)) to iControlHeight
94491>>>>>>>>>>>        Move (low(iSize)) to iControlWidth
94492>>>>>>>>>>>        
94492>>>>>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
94492>>>>>>>>>>>        
94492>>>>>>>>>>>        // Vertical Scroll
94492>>>>>>>>>>>        
94492>>>>>>>>>>>        // Vertical Scroll down
94492>>>>>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
94492>>>>>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
94494>>>>>>>>>>>            
94494>>>>>>>>>>>            // set scroll amount so that the bottom of the control is visible
94494>>>>>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
94495>>>>>>>>>>>            
94495>>>>>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
94495>>>>>>>>>>>            // top of the object appears at the bottom
94495>>>>>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
94497>>>>>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
94498>>>>>>>>>>>            End
94498>>>>>>>>>>>>
94498>>>>>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
94498>>>>>>>>>>>            If (iScroll>0) Begin
94500>>>>>>>>>>>                Send VScroll of hoScrollingContainer iScroll
94501>>>>>>>>>>>            End
94501>>>>>>>>>>>>
94501>>>>>>>>>>>        End
94501>>>>>>>>>>>>
94501>>>>>>>>>>>        // else vertical scroll up
94501>>>>>>>>>>>        // We scroll if the top of the object is not visible.
94501>>>>>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
94504>>>>>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
94504>>>>>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
94505>>>>>>>>>>>            If (iScroll<0) Begin
94507>>>>>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
94508>>>>>>>>>>>            End
94508>>>>>>>>>>>>
94508>>>>>>>>>>>        End
94508>>>>>>>>>>>>
94508>>>>>>>>>>>        
94508>>>>>>>>>>>        // Horizonal Scroll
94508>>>>>>>>>>>        
94508>>>>>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
94508>>>>>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
94510>>>>>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
94511>>>>>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
94513>>>>>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
94514>>>>>>>>>>>            End
94514>>>>>>>>>>>>
94514>>>>>>>>>>>            If (iScroll>0) Begin
94516>>>>>>>>>>>                Send HScroll of hoScrollingContainer iScroll
94517>>>>>>>>>>>            End
94517>>>>>>>>>>>>
94517>>>>>>>>>>>        End
94517>>>>>>>>>>>>
94517>>>>>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
94519>>>>>>>>>>>            // if this can fit by moving all the way to left, do so.
94519>>>>>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
94521>>>>>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
94522>>>>>>>>>>>            End
94522>>>>>>>>>>>>
94522>>>>>>>>>>>            Else Begin
94523>>>>>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
94524>>>>>>>>>>>            End
94524>>>>>>>>>>>>
94524>>>>>>>>>>>            If (iScroll<0) Begin
94526>>>>>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
94527>>>>>>>>>>>            End
94527>>>>>>>>>>>>
94527>>>>>>>>>>>        End
94527>>>>>>>>>>>>
94527>>>>>>>>>>>        
94527>>>>>>>>>>>        
94527>>>>>>>>>>>    End_Procedure
94528>>>>>>>>>>>    
94528>>>>>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
94528>>>>>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
94530>>>>>>>>>>>        Boolean bScrollOnFocus
94530>>>>>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
94531>>>>>>>>>>>        If bScrollOnFocus Begin
94533>>>>>>>>>>>            Send ScrollObjectInRange hoControl
94534>>>>>>>>>>>        End
94534>>>>>>>>>>>>
94534>>>>>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
94536>>>>>>>>>>>    End_Procedure
94537>>>>>>>>>>>    
94537>>>>>>>>>>>    
94537>>>>>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
94539>>>>>>>>>>>        Boolean bCenter
94539>>>>>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
94540>>>>>>>>>>>        Function_Return bCenter
94541>>>>>>>>>>>    End_Function
94542>>>>>>>>>>>    
94542>>>>>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
94544>>>>>>>>>>>        Boolean bTabWorkspaceView
94544>>>>>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
94545>>>>>>>>>>>        If bTabWorkspaceView Begin
94547>>>>>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
94548>>>>>>>>>>>        End
94548>>>>>>>>>>>>
94548>>>>>>>>>>>    End_Procedure
94549>>>>>>>>>>>    
94549>>>>>>>>>>>    Function ParentView Returns Handle
94551>>>>>>>>>>>        Function_Return (Parent(Parent(Self)))
94552>>>>>>>>>>>    End_Function
94553>>>>>>>>>>>    
94553>>>>>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
94555>>>>>>>>>>>        Integer iSize iMax iDiff
94555>>>>>>>>>>>        Handle hoView
94555>>>>>>>>>>>        Boolean bCenter bModal
94555>>>>>>>>>>>        Get ParentView to hoView
94556>>>>>>>>>>>        Get Block_Mouse_State of hoView to bModal
94557>>>>>>>>>>>        If not bModal Begin
94559>>>>>>>>>>>            Get CenterTabWorkspaceView to bCenter
94560>>>>>>>>>>>            Get GuiSize of hoView to iSize
94561>>>>>>>>>>>            Get piMaxSize of hoView to iMax
94562>>>>>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
94563>>>>>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
94565>>>>>>>>>>>                If bCenter Begin
94567>>>>>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
94568>>>>>>>>>>>                End
94568>>>>>>>>>>>>
94568>>>>>>>>>>>                Move (Low(iMax)) to iWidth
94569>>>>>>>>>>>            End
94569>>>>>>>>>>>>
94569>>>>>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
94571>>>>>>>>>>>                If bCenter Begin
94573>>>>>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
94574>>>>>>>>>>>                    Move (iLocy min 25) to  iLocY
94575>>>>>>>>>>>                End
94575>>>>>>>>>>>>
94575>>>>>>>>>>>                Move (Hi(imax)) to iHeight
94576>>>>>>>>>>>            End
94576>>>>>>>>>>>>
94576>>>>>>>>>>>        End
94576>>>>>>>>>>>>
94576>>>>>>>>>>>    End_Procedure
94577>>>>>>>>>>>    
94577>>>>>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
94577>>>>>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
94577>>>>>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
94577>>>>>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
94577>>>>>>>>>>>    // This should almost always yield the right answer.
94577>>>>>>>>>>>    // This is called by the scrolling container's end_constructor
94577>>>>>>>>>>>    Procedure AutoSetTabWorkspaceView
94579>>>>>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
94579>>>>>>>>>>>        Handle hoParent
94579>>>>>>>>>>>        Integer iSize
94579>>>>>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
94580>>>>>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
94582>>>>>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
94583>>>>>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
94583>>>>>>>>>>>            // change this after the commandbar is paged.
94583>>>>>>>>>>>            If (bTabView) Begin
94585>>>>>>>>>>>                Get ParentView to hoParent
94586>>>>>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
94587>>>>>>>>>>>                If (bIsView) Begin
94589>>>>>>>>>>>                    // set this as a tab workspace view
94589>>>>>>>>>>>                    Set pbTabWorkspaceView to True
94590>>>>>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
94590>>>>>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
94590>>>>>>>>>>>                    Set pbAutoScroll to True
94591>>>>>>>>>>>                    
94591>>>>>>>>>>>                End
94591>>>>>>>>>>>>
94591>>>>>>>>>>>            End
94591>>>>>>>>>>>>
94591>>>>>>>>>>>        End
94591>>>>>>>>>>>>
94591>>>>>>>>>>>    End_Procedure
94592>>>>>>>>>>>    
94592>>>>>>>>>>>End_Class
94593>>>>>>>>>>>
94593>>>>>>>>>>>// Container scrolling class support. Nothing in here is public
94593>>>>>>>>>>>Class cScrollingContainerMixin is a Mixin
94594>>>>>>>>>>>    
94594>>>>>>>>>>>    Procedure Define_cScrollingContainerMixin
94596>>>>>>>>>>>        Forward Set Border_Style to Border_None
94598>>>>>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
94599>>>>>>>>>>>        Forward Set peAnchors to anAll
94601>>>>>>>>>>>        
94601>>>>>>>>>>>        // forcing scrollbars right away seems to make painting better
94601>>>>>>>>>>>        Set Window_Style WS_HSCROLL to True
94602>>>>>>>>>>>        Set Window_Style WS_VSCROLL to True
94603>>>>>>>>>>>        
94603>>>>>>>>>>>        Property Handle phoScrollingClientArea 0
94604>>>>>>>>>>>    End_Procedure
94605>>>>>>>>>>>    
94605>>>>>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
94605>>>>>>>>>>>    Procedure Set peAnchors Integer eAnchors
94607>>>>>>>>>>>    End_Procedure
94608>>>>>>>>>>>    
94608>>>>>>>>>>>    // if a border style is set, it will not work. We won't let that happen
94608>>>>>>>>>>>    Procedure Set Border_Style Integer eStyle
94610>>>>>>>>>>>    End_Procedure
94611>>>>>>>>>>>    
94611>>>>>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
94611>>>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
94613>>>>>>>>>>>        Handle hoClient
94613>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
94614>>>>>>>>>>>        If hoClient Begin
94616>>>>>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
94617>>>>>>>>>>>        End
94617>>>>>>>>>>>>
94617>>>>>>>>>>>    End_Procedure
94618>>>>>>>>>>>    
94618>>>>>>>>>>>    // should be sent by WM_VSCROLL
94618>>>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
94620>>>>>>>>>>>        Handle hoClient
94620>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
94621>>>>>>>>>>>        If hoClient Begin
94623>>>>>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
94624>>>>>>>>>>>        End
94624>>>>>>>>>>>>
94624>>>>>>>>>>>    End_Procedure
94625>>>>>>>>>>>    
94625>>>>>>>>>>>    // should be sent by WM_HSCROLL
94625>>>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
94627>>>>>>>>>>>        Handle hoClient
94627>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
94628>>>>>>>>>>>        If hoClient Begin
94630>>>>>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
94631>>>>>>>>>>>        End
94631>>>>>>>>>>>>
94631>>>>>>>>>>>    End_Procedure
94632>>>>>>>>>>>    
94632>>>>>>>>>>>    // augmented to adjust its size to the size of the parent client area.
94632>>>>>>>>>>>    // After this is set, anchors will handle any further resizing.
94632>>>>>>>>>>>    Procedure Page Integer iState
94634>>>>>>>>>>>        Integer iSiz iHeight iWidth
94634>>>>>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
94634>>>>>>>>>>>        Boolean bGroup
94634>>>>>>>>>>>        Handle hoClient
94634>>>>>>>>>>>        If (iState =1) Begin
94636>>>>>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
94638>>>>>>>>>>>            // We have special code to support groups because they
94638>>>>>>>>>>>            // draw a border inside of the client rectangle
94638>>>>>>>>>>>            If bGroup Begin
94640>>>>>>>>>>>                Get Physical_FontSize to iFontSize
94641>>>>>>>>>>>                Move (Hi(iFontSize)) to iTop
94642>>>>>>>>>>>                Move 2 to iLeft
94643>>>>>>>>>>>                Move 2 to iRight
94644>>>>>>>>>>>                Move 2 to iBottom
94645>>>>>>>>>>>            End
94645>>>>>>>>>>>>
94645>>>>>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
94645>>>>>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
94645>>>>>>>>>>>            // makes anchors work properly with unpaged tab-pages
94645>>>>>>>>>>>            Delegate Get GetContainerClientSize to iSiz
94647>>>>>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
94648>>>>>>>>>>>            Set GuiLocation to iTop iLeft
94649>>>>>>>>>>>            Send Adjust_Logicals
94650>>>>>>>>>>>        End
94650>>>>>>>>>>>>
94650>>>>>>>>>>>        Forward Send Page iState
94652>>>>>>>>>>>    End_Procedure
94653>>>>>>>>>>>    
94653>>>>>>>>>>>    Procedure End_Construct_Object
94655>>>>>>>>>>>        Handle hoClient
94655>>>>>>>>>>>        Forward Send End_Construct_Object
94657>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
94658>>>>>>>>>>>        If (hoClient) Begin
94660>>>>>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
94661>>>>>>>>>>>        End
94661>>>>>>>>>>>>
94661>>>>>>>>>>>    End_Procedure
94662>>>>>>>>>>>    
94662>>>>>>>>>>>End_Class
94663>>>>>>>>>
94663>>>>>>>>>Class cScrollingClientArea is a Container3d
94664>>>>>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
94665>>>>>>>>>    Procedure Construct_Object
94667>>>>>>>>>        Forward Send Construct_Object
94669>>>>>>>>>        Send Define_cScrollingClientAreaMixin
94670>>>>>>>>>    End_Procedure
94671>>>>>>>>>End_Class
94672>>>>>>>>>
94672>>>>>>>>>
94672>>>>>>>>>
94672>>>>>>>>>Class cScrollingContainer is a Container3d
94673>>>>>>>>>    Import_Class_Protocol cScrollingContainerMixin
94674>>>>>>>>>    Procedure Construct_Object
94676>>>>>>>>>        Forward Send Construct_Object
94678>>>>>>>>>        Send Define_cScrollingContainerMixin
94679>>>>>>>>>    End_Procedure
94680>>>>>>>>>End_Class
94681>>>>>>>Use cRDCModalPanel.pkg
94681>>>>>>>Use cRDCForm.pkg
Including file: cRDCForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCForm.pkg)
94681>>>>>>>>>//****************************************************************************
94681>>>>>>>>>// $Module type: Class
94681>>>>>>>>>// $Module name: cForm
94681>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
94681>>>>>>>>>// Created     : 2014-03-17 @ 12:34
94681>>>>>>>>>//
94681>>>>>>>>>// Description :
94681>>>>>>>>>//
94681>>>>>>>>>// $Rev History:
94681>>>>>>>>>//    2014-03-17  Module header created
94681>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
94681>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
94681>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
94681>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
94681>>>>>>>>>// in the help folder for more details.
94681>>>>>>>>>//
94681>>>>>>>>>//****************************************************************************
94681>>>>>>>>>Use Windows.pkg
94681>>>>>>>>>
94681>>>>>>>>>Class cFormIdleHandler is a cIdleHandler
94682>>>>>>>>>    Procedure Construct_Object
94684>>>>>>>>>        Forward Send Construct_Object
94686>>>>>>>>>
94686>>>>>>>>>    End_Procedure
94687>>>>>>>>>
94687>>>>>>>>>    Procedure OnIdle
94689>>>>>>>>>        Delegate Send DoUpdate
94691>>>>>>>>>    End_Procedure
94692>>>>>>>>>
94692>>>>>>>>>End_Class
94693>>>>>>>>>
94693>>>>>>>>>Class cRDCForm is a Form
94694>>>>>>>>>
94694>>>>>>>>>    Procedure Construct_Object
94696>>>>>>>>>        Forward Send Construct_Object
94698>>>>>>>>>
94698>>>>>>>>>        Property Boolean pbAutoEnable False
94699>>>>>>>>>
94699>>>>>>>>>        Property Boolean pbEnabled True
94700>>>>>>>>>
94700>>>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cFormIdleHandler)))
94701>>>>>>>>>
94701>>>>>>>>>        Set Label_Justification_mode to JMode_Right
94702>>>>>>>>>        Set Label_Col_Offset to 2
94703>>>>>>>>>        Set Label_Row_Offset to 0
94704>>>>>>>>>    End_Procedure
94705>>>>>>>>>
94705>>>>>>>>>    Procedure End_Construct_Object
94707>>>>>>>>>        String sTooltip sStatus_Help
94707>>>>>>>>>
94707>>>>>>>>>        Forward Send End_Construct_Object
94709>>>>>>>>>
94709>>>>>>>>>        Get psToolTip   to sTooltip
94710>>>>>>>>>        Get Status_Help to sStatus_Help
94711>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
94713>>>>>>>>>            Set psToolTip to sStatus_Help
94714>>>>>>>>>        End
94714>>>>>>>>>>
94714>>>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
94717>>>>>>>>>            Set Status_Help to sTooltip
94718>>>>>>>>>        End
94718>>>>>>>>>>
94718>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
94719>>>>>>>>>    End_Procedure
94720>>>>>>>>>
94720>>>>>>>>>    Procedure DoUpdate
94722>>>>>>>>>        If (pbAutoEnable(Self) = False) Begin
94724>>>>>>>>>            Procedure_Return
94725>>>>>>>>>        End
94725>>>>>>>>>>
94725>>>>>>>>>        Set Enabled_State to (IsEnabled(Self))
94726>>>>>>>>>    End_Procedure
94727>>>>>>>>>
94727>>>>>>>>>    Function IsEnabled Returns Boolean
94729>>>>>>>>>        Boolean bEnabled
94729>>>>>>>>>        Get pbEnabled to bEnabled
94730>>>>>>>>>        Function_Return bEnabled
94731>>>>>>>>>    End_Function
94732>>>>>>>>>
94732>>>>>>>>>    // Enable the idle handler timer when the object is activated
94732>>>>>>>>>    Procedure Activating
94734>>>>>>>>>        Forward Send Activating
94736>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
94737>>>>>>>>>    End_Procedure
94738>>>>>>>>>
94738>>>>>>>>>    // Disable the idle handler when the object is deactivated
94738>>>>>>>>>    Procedure Deactivating  
94740>>>>>>>>>        // When exiting the program it can happen that the idle handler
94740>>>>>>>>>        // already has been destroyed.      
94740>>>>>>>>>        If (Object_id(phoIdleHandler(Self)) <> 0) Begin
94742>>>>>>>>>            Set pbEnabled of (phoIdleHandler(Self)) to False
94743>>>>>>>>>        End
94743>>>>>>>>>>
94743>>>>>>>>>        Forward Send Deactivating
94745>>>>>>>>>    End_Procedure 
94746>>>>>>>>>    
94746>>>>>>>>>    // Toggles the password state, as it doesn't work changing the
94746>>>>>>>>>    // password_state at runtine because it is a design time property.
94746>>>>>>>>>    Procedure TogglePasswordState
94748>>>>>>>>>        Boolean bState    
94748>>>>>>>>>        Handle hoFocus hoParent
94748>>>>>>>>>        Integer iRetval
94748>>>>>>>>>        Get Password_State to bState
94749>>>>>>>>>        Set Password_State to (not(bState))
94750>>>>>>>>>        Get Focus of Desktop to hoFocus
94751>>>>>>>>>        Move (Parent(Self)) to hoParent
94752>>>>>>>>>        Send Page_Object False
94753>>>>>>>>>        Send Page_Object True   
94754>>>>>>>>>        Get msg_Add_Focus hoParent to iRetval
94755>>>>>>>>>        Set Focus_Mode of hoFocus to Focusable
94756>>>>>>>>>//        Send Page_Delete
94756>>>>>>>>>//        Send Page 1
94756>>>>>>>>>    End_Procedure
94757>>>>>>>>>
94757>>>>>>>>>End_Class
94758>>>>>>>Use cRDCComboForm.pkg
94758>>>>>>>Use cRDCButton.pkg
94758>>>>>>>Use cRDCHeaderGroup.pkg
94758>>>>>>>Use cDbDriverSettingsForm.pkg
Including file: cDbDriverSettingsForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbDriverSettingsForm.pkg)
94758>>>>>>>>>//****************************************************************************
94758>>>>>>>>>// $Module type: Class
94758>>>>>>>>>// $Module name: cDbDriverSettingsForm
94758>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International
94758>>>>>>>>>// Created     : 2014-03-17 @ 12:34
94758>>>>>>>>>//
94758>>>>>>>>>// Description :
94758>>>>>>>>>//
94758>>>>>>>>>// $Rev History:
94758>>>>>>>>>//    2014-03-17  Module header created
94758>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
94758>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
94758>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
94758>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
94758>>>>>>>>>// in the help folder for more details.
94758>>>>>>>>>//
94758>>>>>>>>>//****************************************************************************
94758>>>>>>>>>Use Windows.pkg
94758>>>>>>>>>Use seq_chnl.pkg
94758>>>>>>>>>
94758>>>>>>>>>Class cDbDriverSettingsForm is a Form
94759>>>>>>>>>
94759>>>>>>>>>    Procedure Construct_Object
94761>>>>>>>>>        Forward Send Construct_Object
94763>>>>>>>>>
94763>>>>>>>>>        Property Boolean private.pbDriverLoadingError False
94764>>>>>>>>>        
94764>>>>>>>>>        Set Label_Col_Offset to 2
94765>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
94766>>>>>>>>>        Set Size to 11 125 
94767>>>>>>>>>        // We use these settings and not enabled_state to be able
94767>>>>>>>>>        // to show tooltips.
94767>>>>>>>>>        Set Color to clBtnFace
94768>>>>>>>>>        Set Focus_Mode to NonFocusable
94769>>>>>>>>>        Set peAnchors to anTopLeftRight
94770>>>>>>>>>
94770>>>>>>>>>        Property String psDriverIniFile ""
94771>>>>>>>>>    End_Procedure
94772>>>>>>>>>
94772>>>>>>>>>    Procedure Set psToolTip String sText
94774>>>>>>>>>        If (Trim(sText) = "") Begin
94776>>>>>>>>>            Move "No info available" to sText
94777>>>>>>>>>        End
94777>>>>>>>>>>
94777>>>>>>>>>        Forward Set psToolTip to sText
94779>>>>>>>>>    End_Procedure
94780>>>>>>>>>
94780>>>>>>>>>    Function psToolTip Returns String
94782>>>>>>>>>        String sTooltip sSearchValue
94782>>>>>>>>>
94782>>>>>>>>>        Get Label to sSearchValue
94783>>>>>>>>>        Get ExtractIniFileComment sSearchValue to sTooltip
94784>>>>>>>>>
94784>>>>>>>>>        Function_Return sTooltip
94785>>>>>>>>>    End_Function
94786>>>>>>>>>
94786>>>>>>>>>    Procedure SetValue String sDriver String sLabel Integer iAttribute
94788>>>>>>>>>        Integer iDriver
94788>>>>>>>>>        String sValue
94788>>>>>>>>>
94788>>>>>>>>>        // Sadly driver API attributes are only supported by the CLI-drivers,
94788>>>>>>>>>        // and the Pervasive driver is not amongst them. So do nothing if Pervasive.
94788>>>>>>>>>        If (sDriver <> DFBTRDRV_ID and sDriver <> DATAFLEX_ID) Begin
94790>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
94791>>>>>>>>>            Get DriverIndex of ghoSQLConnectionHandler sDriver to iDriver
94792>>>>>>>>>            Set private.pbDriverLoadingError to (iDriver = -1)
94793>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
94794>>>>>>>>>            If (iDriver <= 0) Begin
94796>>>>>>>>>                Procedure_Return
94797>>>>>>>>>            End
94797>>>>>>>>>>
94797>>>>>>>>>            // Set indicator to false prior asking for the driver attribute.
94797>>>>>>>>>            // This way we can decide to show the object or not, based on success/failure.
94797>>>>>>>>>            Move False to Err
94798>>>>>>>>>            Get_Attribute iAttribute of iDriver to sValue
94801>>>>>>>>>            If (sValue = "0") Begin
94803>>>>>>>>>                Move "0 (False)" to sValue
94804>>>>>>>>>            End
94804>>>>>>>>>>
94804>>>>>>>>>            If (sValue = "1") Begin
94806>>>>>>>>>                Move "1 (True)"  to sValue
94807>>>>>>>>>            End
94807>>>>>>>>>>
94807>>>>>>>>>            Set Value to sValue
94808>>>>>>>>>
94808>>>>>>>>>            Move (Replace("DF_DRIVER_", Uppercase(sLabel), "")) to sLabel
94809>>>>>>>>>            // Its a bit annoying reading all caps, so "proper" case
94809>>>>>>>>>            // all labels (DF_DRIVER_XXX values).
94809>>>>>>>>>            Get Propercase sLabel to sLabel
94810>>>>>>>>>            Set Label to sLabel
94811>>>>>>>>>
94811>>>>>>>>>            Get ExtractIniFileComment sLabel to sValue
94812>>>>>>>>>            Set Status_Help to sValue
94813>>>>>>>>>            Set psToolTip to sValue
94814>>>>>>>>>        End
94814>>>>>>>>>>
94814>>>>>>>>>    End_Procedure
94815>>>>>>>>>
94815>>>>>>>>>    // Pass a driver ini filename with path & a comment value to search for.
94815>>>>>>>>>    // Returns: The comments in the file as a string.
94815>>>>>>>>>    Function ExtractIniFileComment String sSearchValue Returns String
94817>>>>>>>>>        String sIniFile sValue sRetval sComment sCommentMarker
94817>>>>>>>>>        Boolean bCommentRow bStart
94817>>>>>>>>>        Integer iCh
94817>>>>>>>>>
94817>>>>>>>>>        Get psDriverIniFile to sIniFile
94818>>>>>>>>>        Move ";" to sCommentMarker
94819>>>>>>>>>        Get Seq_Open_Input_Channel sIniFile to iCh
94820>>>>>>>>>        While (SeqEof = False)
94824>>>>>>>>>            Readln channel iCh sValue
94826>>>>>>>>>            Move (Trim(sValue)) to sValue
94827>>>>>>>>>
94827>>>>>>>>>            // Check for a ";" at pos 1 & if the line contains the passed search value (driver attribute).
94827>>>>>>>>>            Move (Left(sValue, 1)) to sComment
94828>>>>>>>>>            If (bStart = False) Begin
94830>>>>>>>>>                Move (sComment = sCommentMarker and Lowercase(sValue) contains Lowercase(sSearchValue)) to bStart
94831>>>>>>>>>            End
94831>>>>>>>>>>
94831>>>>>>>>>            If (bStart = True) Begin
94833>>>>>>>>>                // Have we read past end of the comment for the driver attribute? If so, quit.
94833>>>>>>>>>                If (sComment <> sCommentMarker) Begin
94835>>>>>>>>>                    Move True to SeqEof
94836>>>>>>>>>                End
94836>>>>>>>>>>
94836>>>>>>>>>                Else Begin
94837>>>>>>>>>                    Move (sComment = sCommentMarker) to bCommentRow
94838>>>>>>>>>                    If (bCommentRow = True) Begin
94840>>>>>>>>>                        Move (Replace(sCommentMarker, sValue, "")) to sValue
94841>>>>>>>>>
94841>>>>>>>>>                        // Replace all double spaces with a single space character.
94841>>>>>>>>>                        Move (Replaces("  ", sValue, " ")) to sValue
94842>>>>>>>>>
94842>>>>>>>>>                        If (sRetval = "") Begin
94844>>>>>>>>>                            Move sValue to sRetval
94845>>>>>>>>>                        End
94845>>>>>>>>>>
94845>>>>>>>>>                        Else Begin
94846>>>>>>>>>                            Move (sRetval + " " + sValue) to sRetval
94847>>>>>>>>>                        End
94847>>>>>>>>>>
94847>>>>>>>>>                    End
94847>>>>>>>>>>
94847>>>>>>>>>                End
94847>>>>>>>>>>
94847>>>>>>>>>            End
94847>>>>>>>>>>
94847>>>>>>>>>        Loop
94848>>>>>>>>>>
94848>>>>>>>>>        Send Seq_Close_Channel iCh
94849>>>>>>>>>
94849>>>>>>>>>CompilerWarnings Off
94849>>>>>>>>>        // Replaces all double spaces with a single space character.
94849>>>>>>>>>        // The Replaces function doesn't quite work for this.
94849>>>>>>>>>        Repeat
94849>>>>>>>>>>
94849>>>>>>>>>            Replace "  " in sRetval with " "
94853>>>>>>>>>        Until (FindErr)
94855>>>>>>>>>        
94855>>>>>>>>>        Function_Return sRetval
94856>>>>>>>>>    End_Function
94857>>>>>>>>>CompilerWarnings On
94857>>>>>>>>>
94857>>>>>>>>>    Function Propercase String sText Returns String 
94859>>>>>>>>>        String[] sDelimiters
94860>>>>>>>>>        Integer iPos
94860>>>>>>>>>        
94860>>>>>>>>>        //Lowercase everything and we'll handle uppercase by exception
94860>>>>>>>>>        Move (Lowercase(sText)) to sText
94861>>>>>>>>>        
94861>>>>>>>>>        Move " " to sDelimiters[SizeOfArray(sDelimiters)]
94862>>>>>>>>>        Move "-" to sDelimiters[SizeOfArray(sDelimiters)]
94863>>>>>>>>>        Move "_" to sDelimiters[SizeOfArray(sDelimiters)]
94864>>>>>>>>>        
94864>>>>>>>>>        For iPos from 1 to (Length(sText)) // 1 based loop to match MID and OVERSTRIKE
94870>>>>>>>>>>
94870>>>>>>>>>            //If the previous character is a space, uppercase the current one (alway upper the first char)
94870>>>>>>>>>            If ((iPos = 1) or (SearchArray( Mid(sText, 1, (iPos - 1)), sDelimiters) <> -1)) ;                Move (Overstrike( Uppercase(Mid(sText, 1, iPos)), sText, iPos )) to sText
94873>>>>>>>>>        Loop
94874>>>>>>>>>>
94874>>>>>>>>>        
94874>>>>>>>>>        Function_Return sText
94875>>>>>>>>>    End_Function
94876>>>>>>>>>
94876>>>>>>>>>End_Class
94877>>>>>>>Use cDbUpdateFunctionLibrary.pkg
94877>>>>>>>
94877>>>>>>>Register_Procedure psOrgToolTip String sTooltip
94877>>>>>>>
94877>>>>>>>Object oDriverSettings_dg is a cRDCModalPanel
94879>>>>>>>    Set Size to 291 345
94880>>>>>>>    Set Label to "Driver Configuration File Info"
94881>>>>>>>    Set Location to 2 2
94882>>>>>>>    Set Maximize_Icon to False
94883>>>>>>>    Set Locate_Mode to CENTER_ON_PARENT
94884>>>>>>>    Set Icon to "DriverSettings1.ico"
94885>>>>>>>    
94885>>>>>>>    Property String psDriverID MSSQLDRV_ID
94887>>>>>>>    Property Boolean pbDriverLoadingError False
94889>>>>>>>    
94889>>>>>>>    Object oCancel_Btn is a cRDCButton
94891>>>>>>>        Set Label    to "&Close"
94892>>>>>>>        Set Location to 269 287
94893>>>>>>>        Set peAnchors to anBottomRight
94894>>>>>>>
94894>>>>>>>        Procedure OnClick
94897>>>>>>>            Send Close_Panel
94898>>>>>>>        End_Procedure
94899>>>>>>>
94899>>>>>>>    End_Object
94900>>>>>>>
94900>>>>>>>    Object oDriver_cf is a cRDCComboForm
94902>>>>>>>        Set Label to "Database Driver"
94903>>>>>>>        Set Size to 13 80
94904>>>>>>>        Set Location to 8 90
94905>>>>>>>        Set Form_Border to 0
94906>>>>>>>        Set Label_Col_Offset to 2
94907>>>>>>>        Set Label_Justification_Mode to JMode_Right
94908>>>>>>>        Set Status_Help to "Database driver."
94909>>>>>>>        Set Enabled_State to False
94910>>>>>>>        Set Skip_State to True
94911>>>>>>>
94911>>>>>>>        Procedure Combo_Fill_List
94914>>>>>>>            Send Combo_Add_Item DATAFLEX_ID
94915>>>>>>>            Send Combo_Add_Item DFBTRDRV_ID
94916>>>>>>>            Send Combo_Add_Item ODBC_DRV_ID
94917>>>>>>>            Send Combo_Add_Item MSSQLDRV_ID
94918>>>>>>>            Send Combo_Add_Item DB2_DRV_ID
94919>>>>>>>        End_Procedure
94920>>>>>>>
94920>>>>>>>    End_Object
94921>>>>>>>
94921>>>>>>>    Object oDriverFileName_cf is a cRDCForm
94923>>>>>>>        Set Label to "Database Driver File"
94924>>>>>>>        Set Size to 12 193
94925>>>>>>>        Set Location to 24 90
94926>>>>>>>        Set Label_Col_Offset to 2
94927>>>>>>>        Set Label_Justification_Mode to JMode_Right
94928>>>>>>>        Set Status_Help to "Database driver to be used when creating new tables."
94929>>>>>>>        Set Color to clBtnFace
94930>>>>>>>        Set Focus_Mode to NonFocusable
94931>>>>>>>        Set peAnchors to anTopLeftRight
94932>>>>>>>
94932>>>>>>>        Procedure OnChange
94935>>>>>>>            String sDriverID sValue sDriverIntFileName sTooltip sPath
94935>>>>>>>
94935>>>>>>>            Forward Send OnChange
94937>>>>>>>            Get Value to sValue
94938>>>>>>>            Set Status_Help to sValue
94939>>>>>>>
94939>>>>>>>            Get psDriverID to sDriverID
94940>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
94942>>>>>>>                Get DatabaseDriverIniFilePath sDriverID to sPath
94943>>>>>>>                If (sPath <> "") Begin
94945>>>>>>>                    Move (sPath + sDriverID + ".int") to sDriverIntFileName
94946>>>>>>>                End
94946>>>>>>>>
94946>>>>>>>            End
94946>>>>>>>>
94946>>>>>>>            Else Begin
94947>>>>>>>                Move sDriverID to sDriverIntFileName
94948>>>>>>>            End
94948>>>>>>>>
94948>>>>>>>
94948>>>>>>>            Set Value of oDriverIniFile_fm to sDriverIntFileName
94949>>>>>>>            Get psOrgToolTip of oDriverIniFile_fm to sTooltip
94950>>>>>>>            Set Status_Help of oDriverIniFile_fm to (sTooltip * sDriverIntFileName)
94951>>>>>>>
94951>>>>>>>            // In case driver attribute objects already exists; destroy them
94951>>>>>>>            Broadcast Send Destroy    of oScrollingClientArea
94953>>>>>>>            // Then recreate them to show driver attributes
94953>>>>>>>            Send DoReadDriverSettings of oScrollingClientArea sDriverID
94954>>>>>>>        End_Procedure  
94955>>>>>>>        
94955>>>>>>>    End_Object
94956>>>>>>>
94956>>>>>>>    Object oDriverInfo_btn is a cRDCButton
94958>>>>>>>        Set Size to 13 50
94959>>>>>>>        Set Location to 24 287
94960>>>>>>>        Set Label to "Version Info"
94961>>>>>>>        Set Status_Help to "Shows a dialog with driver properties and SQL client software version(s), license info and more."
94962>>>>>>>        Set peAnchors to anTopRight
94963>>>>>>>
94963>>>>>>>        Procedure OnClick
94966>>>>>>>            Object oSysInfoDialog is a SysInfoDialog
94968>>>>>>>            End_Object
94969>>>>>>>
94969>>>>>>>            Send Popup of oSysInfoDialog
94970>>>>>>>        End_Procedure
94971>>>>>>>    End_Object
94972>>>>>>>
94972>>>>>>>    Object oDriverIniFile_fm is a cRDCForm
94974>>>>>>>        Set Size to 13 193
94975>>>>>>>        Set Location to 39 90
94976>>>>>>>        Set Label_Col_Offset to 2
94977>>>>>>>        Set Label_Justification_Mode to JMode_Right
94978>>>>>>>        Set Label to "Driver Configuration File"
94979>>>>>>>        Set peAnchors to anTopLeftRight
94980>>>>>>>        Set Color to clBtnFace
94981>>>>>>>        Set Focus_Mode to NonFocusable
94982>>>>>>>        Property String psOrgToolTip "The file is the first found in the DF_OPEN_PATH path string."
94984>>>>>>>        Set Status_Help to (psOrgToolTip(Self))
94985>>>>>>>    End_Object
94986>>>>>>>
94986>>>>>>>    Object oOpenDriverFile_Btn is a cRDCButton
94988>>>>>>>        Set Size to 13 50
94989>>>>>>>        Set Label to "Edit File"
94990>>>>>>>        Set Location to 39 287
94991>>>>>>>        Set Status_Help to "Opens the driver configuration file that contains configuration settings that are used when tables are restructured, in Notepad."
94992>>>>>>>        Set psImage to "ActionEdit1.ico"
94993>>>>>>>        Set peAnchors to anTopRight
94994>>>>>>>        Set pbAutoEnable to True
94995>>>>>>>
94995>>>>>>>        Procedure OnClick
94998>>>>>>>            String sFileName
94998>>>>>>>            Get Value of oDriverIniFile_fm to sFileName
94999>>>>>>>            If (sFileName <> DATAFLEX_ID) Begin
95001>>>>>>>                Runprogram Background "Notepad.exe" sFileName
95002>>>>>>>            End
95002>>>>>>>>
95002>>>>>>>            Else Begin
95003>>>>>>>                Send Info_Box "Sorry, there exist no driver ini file for the DataFlex database driver, so nothing to show here."
95004>>>>>>>            End
95004>>>>>>>>
95004>>>>>>>        End_Procedure   
95005>>>>>>>        
95005>>>>>>>        Function IsEnabled Returns Boolean
95008>>>>>>>            String sFileName
95008>>>>>>>            Get Value of oDriverFileName_cf to sFileName
95009>>>>>>>            Function_Return (sFileName <> "")
95010>>>>>>>        End_Function
95011>>>>>>>
95011>>>>>>>    End_Object
95012>>>>>>>
95012>>>>>>>    Object oDumpDriverData_Btn is a cRDCButton
95014>>>>>>>        Set Size to 13 50
95015>>>>>>>        Set Label to "Dump"
95016>>>>>>>        Set Location to 54 233
95017>>>>>>>        Set peAnchors to anTopRight
95018>>>>>>>        Set psToolTip to "Dumps the current status of the Connectivity Kit driver to an ASCII disk file."
95019>>>>>>>        Set psImage to "ActionExport1.ico"
95020>>>>>>>        Set pbAutoEnable to True
95021>>>>>>>        
95021>>>>>>>        Procedure OnClick
95024>>>>>>>            Handle hoCLI
95024>>>>>>>            String sDriver sPath sFileName
95024>>>>>>>            Integer iRetval
95024>>>>>>>
95024>>>>>>>            Get psDriverID to sDriver
95025>>>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLI
95026>>>>>>>            Set psDriverID of hoCLI  to sDriver
95027>>>>>>>            If (sDriver = DATAFLEX_ID or sDriver = DFBTRDRV_ID) Begin
95029>>>>>>>                Send Destroy of hoCLI
95030>>>>>>>                Send Info_Box "Sorry, no attributes can be shown for the selected database driver."
95031>>>>>>>                Procedure_Return
95032>>>>>>>            End
95032>>>>>>>>
95032>>>>>>>
95032>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
95033>>>>>>>            Get vFolderFormat sPath to sPath
95034>>>>>>>            Move (sDriver + "dump.txt") to sFileName
95035>>>>>>>            Send DumpStatus of hoCLI (sPath + sFileName)
95036>>>>>>>            Send Destroy of hoCLI
95037>>>>>>>
95037>>>>>>>            Send vShellExecute "open" sFileName "" sPath
95038>>>>>>>            Sleep 1
95039>>>>>>>            Get vDeleteFile (sPath + sFileName) to iRetval
95040>>>>>>>        End_Procedure
95041>>>>>>>
95041>>>>>>>        Function IsEnabled Returns Boolean
95044>>>>>>>            String sFileName
95044>>>>>>>            Boolean bDriverLoadingError 
95044>>>>>>>            Get pbDriverLoadingError to bDriverLoadingError
95045>>>>>>>            Get Value of oDriverFileName_cf to sFileName
95046>>>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
95047>>>>>>>        End_Function
95048>>>>>>>
95048>>>>>>>    End_Object
95049>>>>>>>
95049>>>>>>>    Object oReset_Btn is a cRDCButton
95051>>>>>>>        Set Size to 13 50
95052>>>>>>>        Set Label to "Refresh"
95053>>>>>>>        Set Status_Help to "If you edit the driver configuration file, the display of attributes above needs to be refreshed. Click here to refresh."
95054>>>>>>>        Set Location to 54 287
95055>>>>>>>        Set psImage to "ActionRefresh1.ico"
95056>>>>>>>        Set peAnchors to anTopRight
95057>>>>>>>        Set pbAutoEnable to True
95058>>>>>>>
95058>>>>>>>        Procedure OnClick
95061>>>>>>>            String sDriver
95061>>>>>>>            Get psDriverID to sDriver
95062>>>>>>>            Unload_Driver sDriver
95063>>>>>>>            Load_Driver sDriver
95064>>>>>>>            Send Info_Box "This dialog needs to be re-opened to display the refreshed values. Dialog will now close and you need to re-open it manually."
95065>>>>>>>            Send Close_Panel
95066>>>>>>>        End_Procedure
95067>>>>>>>
95067>>>>>>>        Function IsEnabled Returns Boolean
95070>>>>>>>            String sFileName
95070>>>>>>>            Boolean bDriverLoadingError 
95070>>>>>>>            Get pbDriverLoadingError to bDriverLoadingError
95071>>>>>>>            Get Value of oDriverFileName_cf to sFileName
95072>>>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
95073>>>>>>>        End_Function
95074>>>>>>>
95074>>>>>>>    End_Object
95075>>>>>>>
95075>>>>>>>    Object oDriverSetings_grp is a cRDCHeaderGroup
95077>>>>>>>        Set Size to 125 328
95078>>>>>>>        Set Location to 74 9
95079>>>>>>>        Set psImage to "DriverSettings1.ico"
95080>>>>>>>        Set Label to "Driver Configuration File Settings"   
95081>>>>>>>        Set psNote to "Hover the mouse over an attribute field to read information about it."
95082>>>>>>>        Set peAnchors to anAll
95083>>>>>>>
95083>>>>>>>        Object oInvisible_Container is a Container3d
95085>>>>>>>            Set Size to 100 327
95086>>>>>>>            Set Location to 24 0
95087>>>>>>>            Set Border_Style to Border_None
95088>>>>>>>            Set peAnchors to anAll
95089>>>>>>>    
95089>>>>>>>            Object oScrollingContainer is a cScrollingContainer
95091>>>>>>>               
95091>>>>>>>                Object oScrollingClientArea is a cScrollingClientArea
95093>>>>>>>
95093>>>>>>>                    // Just fill the array with all available driver attributes from Cli.pkg,
95093>>>>>>>                    // and one object will automatically be created for each attribute
95093>>>>>>>                    // for the current driver by the DoReadDriverSettings procedure.
95093>>>>>>>                    Function GeneralDriverAttributes Returns String[]
95096>>>>>>>                        String[] sAttributesArray
95097>>>>>>>    
95097>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_ASCII             |CI1101" to sAttributesArray[SizeOfArray(sAttributesArray)]
95098>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_ASCII            |CI1102" to sAttributesArray[SizeOfArray(sAttributesArray)]
95099>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_NUMERIC           |CI1103" to sAttributesArray[SizeOfArray(sAttributesArray)]
95100>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_NUMERIC          |CI1104" to sAttributesArray[SizeOfArray(sAttributesArray)]
95101>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATE              |CI1105" to sAttributesArray[SizeOfArray(sAttributesArray)]
95102>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATE             |CI1106" to sAttributesArray[SizeOfArray(sAttributesArray)]
95103>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_TEXT              |CI1107" to sAttributesArray[SizeOfArray(sAttributesArray)]
95104>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_TEXT             |CI1108" to sAttributesArray[SizeOfArray(sAttributesArray)]
95105>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_BINARY            |CI1109" to sAttributesArray[SizeOfArray(sAttributesArray)]
95106>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_BINARY           |CI1110" to sAttributesArray[SizeOfArray(sAttributesArray)]
95107>>>>>>>                        Move "DF_DRIVER_DUMMY_ZERO_DATE_VALUE             |CI1111" to sAttributesArray[SizeOfArray(sAttributesArray)]
95108>>>>>>>                        Move "DF_DRIVER_MAX_ACTIVE_STATEMENTS             |CI1112" to sAttributesArray[SizeOfArray(sAttributesArray)]
95109>>>>>>>                        Move "DF_DRIVER_CACHE_PATH                        |CI1113" to sAttributesArray[SizeOfArray(sAttributesArray)]
95110>>>>>>>                        Move "DF_DRIVER_DRIVER_DECIMAL_SEPARATOR          |CI1114" to sAttributesArray[SizeOfArray(sAttributesArray)]
95111>>>>>>>                        Move "DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT    |CI1115" to sAttributesArray[SizeOfArray(sAttributesArray)]
95112>>>>>>>                        Move "DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR        |CI1116" to sAttributesArray[SizeOfArray(sAttributesArray)]
95113>>>>>>>                        Move "DF_DRIVER_APPLICATION_CHARACTER_FORMAT      |CI1117" to sAttributesArray[SizeOfArray(sAttributesArray)]
95114>>>>>>>                        Move "DF_DRIVER_DRIVER_DATE_FORMAT                |CI1118" to sAttributesArray[SizeOfArray(sAttributesArray)]
95115>>>>>>>                        Move "DF_DRIVER_LAST_ERROR_TEXT                   |CI1119" to sAttributesArray[SizeOfArray(sAttributesArray)]
95116>>>>>>>                        Move "DF_DRIVER_DRIVER_DATE_SEPARATOR             |CI1120" to sAttributesArray[SizeOfArray(sAttributesArray)]
95117>>>>>>>    
95117>>>>>>>                        // Exception to the rule!
95117>>>>>>>                        // Someone - in its infinite wisdome - decided that the keyword in the ini file should be "DFConnectionId",
95117>>>>>>>                        // and not "Connection_ID" that is the API attribute name. This brakes the cDriverSettingsForm tooltip logic.
95117>>>>>>>                        // We fix it by changing the attribute constant string here (removed the _ (underscore) before the "ID" part.
95117>>>>>>>                        Move "DF_DRIVER_CONNECTIONID                      |CI1121" to sAttributesArray[SizeOfArray(sAttributesArray)]
95118>>>>>>>                        Move "DF_DRIVER_IGNORE_UCASE_SUPPORT              |CI1122" to sAttributesArray[SizeOfArray(sAttributesArray)]
95119>>>>>>>                        Move "DF_DRIVER_CONNECTION_ID_STRING              |CI1123" to sAttributesArray[SizeOfArray(sAttributesArray)]
95120>>>>>>>    
95120>>>>>>>                        Move "DF_DRIVER_IGNORE_WARNINGS                   |CI1124" to sAttributesArray[SizeOfArray(sAttributesArray)]
95121>>>>>>>                        Move "DF_DRIVER_USE_DF_LOCKERROR                  |CI1126" to sAttributesArray[SizeOfArray(sAttributesArray)]
95122>>>>>>>                        Move "DF_DRIVER_FIND_CACHE_TIMEOUT                |CI1128" to sAttributesArray[SizeOfArray(sAttributesArray)]
95123>>>>>>>                        Move "DF_DRIVER_JIT_TRESHOLD                      |CI1130" to sAttributesArray[SizeOfArray(sAttributesArray)]
95124>>>>>>>                        Move "DF_DRIVER_TRUNCATE_BINARY_ZEROES            |CI1132" to sAttributesArray[SizeOfArray(sAttributesArray)]
95125>>>>>>>                        Move "DF_DRIVER_ERROR_DEBUG_MODE                  |CI1134" to sAttributesArray[SizeOfArray(sAttributesArray)]
95126>>>>>>>                        Move "DF_DRIVER_USE_CACHE                         |CI1136" to sAttributesArray[SizeOfArray(sAttributesArray)]
95127>>>>>>>                        Move "DF_DRIVER_REPORT_CACHE_ERRORS               |CI1138" to sAttributesArray[SizeOfArray(sAttributesArray)]
95128>>>>>>>                        Move "DF_DRIVER_USE_CACHE_EXPIRATION              |CI1140" to sAttributesArray[SizeOfArray(sAttributesArray)]
95129>>>>>>>                        Move "DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE       |CI1142" to sAttributesArray[SizeOfArray(sAttributesArray)]
95130>>>>>>>                        Move "DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING    |CI1144" to sAttributesArray[SizeOfArray(sAttributesArray)]
95131>>>>>>>                        Move "DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS       |CI1146" to sAttributesArray[SizeOfArray(sAttributesArray)]
95132>>>>>>>                        Move "DF_DRIVER_SILENT_LOGIN                      |CI1148" to sAttributesArray[SizeOfArray(sAttributesArray)]
95133>>>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_TO_RECNUM             |CI1150" to sAttributesArray[SizeOfArray(sAttributesArray)]
95134>>>>>>>                        Move "DF_DRIVER_CONNECTION_ID_OPTIONS             |CI1152" to sAttributesArray[SizeOfArray(sAttributesArray)]
95135>>>>>>>                        Move "DF_DRIVER_NUMBER_CONNECTION_IDS             |CI1154" to sAttributesArray[SizeOfArray(sAttributesArray)]
95136>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATETIME          |CI1155" to sAttributesArray[SizeOfArray(sAttributesArray)]
95137>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATETIME         |CI1156" to sAttributesArray[SizeOfArray(sAttributesArray)]
95138>>>>>>>                        Move "DF_DRIVER_MATCH_CLIENT_SERVER_VERSION       |CI1158" to sAttributesArray[SizeOfArray(sAttributesArray)]
95139>>>>>>>                        Move "DF_DRIVER_SQLSERVER_CLIENT_VERSION          |CI1160" to sAttributesArray[SizeOfArray(sAttributesArray)]
95140>>>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE            |CI1168" to sAttributesArray[SizeOfArray(sAttributesArray)]
95141>>>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_SQLTYPE             |CI1169" to sAttributesArray[SizeOfArray(sAttributesArray)]
95142>>>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE        |CI1170" to sAttributesArray[SizeOfArray(sAttributesArray)]
95143>>>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE         |CI1171" to sAttributesArray[SizeOfArray(sAttributesArray)]
95144>>>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE           |CI1172" to sAttributesArray[SizeOfArray(sAttributesArray)]
95145>>>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_SQLTYPE            |CI1173" to sAttributesArray[SizeOfArray(sAttributesArray)]
95146>>>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE            |CI1174" to sAttributesArray[SizeOfArray(sAttributesArray)]
95147>>>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE             |CI1175" to sAttributesArray[SizeOfArray(sAttributesArray)]
95148>>>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE          |CI1176" to sAttributesArray[SizeOfArray(sAttributesArray)]
95149>>>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE           |CI1177" to sAttributesArray[SizeOfArray(sAttributesArray)]
95150>>>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA |CI1178" to sAttributesArray[SizeOfArray(sAttributesArray)]
95151>>>>>>>                        Move "DF_DRIVER_LOGIN_ON_OPEN                     |CI1180" to sAttributesArray[SizeOfArray(sAttributesArray)]
95152>>>>>>>                        Move "DF_DRIVER_MINIMUM_CLIENT_VERSION            |CI1182" to sAttributesArray[SizeOfArray(sAttributesArray)]
95153>>>>>>>    
95153>>>>>>>                        // Sort items alphabetically
95153>>>>>>>                        Move (SortArray(sAttributesArray)) to sAttributesArray
95154>>>>>>>                        Function_Return sAttributesArray
95155>>>>>>>                    End_Function
95156>>>>>>>    
95156>>>>>>>                    Function SplitValue String sValue Integer ByRef iAttribute Returns String
95159>>>>>>>                        String sAttribute sTmp
95159>>>>>>>                        Integer iPos
95159>>>>>>>    
95159>>>>>>>                        Move (Pos("|", sValue)) to iPos
95160>>>>>>>                        Move (Left(sValue, (iPos -1))) to sAttribute
95161>>>>>>>                        Move (Mid(sValue, Length(sValue), iPos)) to sTmp
95162>>>>>>>                        Move (Trim(sAttribute)) to sAttribute
95163>>>>>>>                        Move (Eval(sTmp)) to iAttribute
95164>>>>>>>    
95164>>>>>>>                        Function_Return sAttribute
95165>>>>>>>                    End_Function
95166>>>>>>>    
95166>>>>>>>                    // Note: Creates dynamic objects.
95166>>>>>>>                    // They are not being destroyed by this method.
95166>>>>>>>                    // It is the reponsibility of the calling method to do that,
95166>>>>>>>                    // prior calling this method.
95166>>>>>>>                    Procedure DoReadDriverSettings String sDriver
95169>>>>>>>                        Integer iLocW iLocH iHfactor iFirstLineOffset iCount iItems iAttribute
95169>>>>>>>                        Handle ho hoParent
95169>>>>>>>                        String[] sAttributesArray
95170>>>>>>>                        String sValue sAttribute sDriverIniFile 
95170>>>>>>>                        Boolean bDriverLoadingError
95170>>>>>>>    
95170>>>>>>>                        Move (Self) to hoParent
95171>>>>>>>                        Move 13  to iHfactor // Height offset between form
95172>>>>>>>                        Move 120 to iLocW
95173>>>>>>>                        Move 10  to iLocH                            
95174>>>>>>>                        Move  0  to iFirstLineOffset // Offset from the top for the very first object.
95175>>>>>>>    
95175>>>>>>>                        Get Value of oDriverIniFile_fm to sDriverIniFile
95176>>>>>>>                        If (Trim(sDriverIniFile) = "") Begin
95178>>>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
95179>>>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
95180>>>>>>>                            Set Location of ho to iLocH (iLocW + 30)
95181>>>>>>>                            Set Label of ho to "No Driver Configuration File found!"
95182>>>>>>>                            Set Value of ho to "No attributes to display..."   
95183>>>>>>>                            Procedure_Return
95184>>>>>>>                        End
95184>>>>>>>>
95184>>>>>>>                            
95184>>>>>>>                        // Driver attributes aren't supported by the Pervasive driver,
95184>>>>>>>                        // so notify and quite.
95184>>>>>>>                        If (sDriver = DFBTRDRV_ID or sDriver = DATAFLEX_ID) Begin
95186>>>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
95187>>>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
95188>>>>>>>                            Set Location of ho to iLocH (iLocW + 30)
95189>>>>>>>                            Set Label of ho to "Query of driver attributes unsupported!"
95190>>>>>>>                            Set Value of ho to "Sorry, no attributes to display"
95191>>>>>>>                            Procedure_Return
95192>>>>>>>                        End
95192>>>>>>>>
95192>>>>>>>    
95192>>>>>>>                        Get GeneralDriverAttributes to sAttributesArray
95193>>>>>>>                        Move (SizeOfArray(sAttributesArray)) to iItems
95194>>>>>>>                        Decrement iItems
95195>>>>>>>                        Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE 
95196>>>>>>>                        Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE  // Invalid driver value
95197>>>>>>>    
95197>>>>>>>                        For iCount from 0 to iItems
95203>>>>>>>>
95203>>>>>>>                            Move sAttributesArray[iCount] to sValue
95204>>>>>>>                            Get SplitValue sValue (&iAttribute) to sAttribute
95205>>>>>>>    
95205>>>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho 
95206>>>>>>>                            Set psDriverIniFile of ho to sDriverIniFile
95207>>>>>>>                            Send SetValue of ho sDriver sAttribute iAttribute
95208>>>>>>>                            Get private.pbDriverLoadingError of ho to bDriverLoadingError
95209>>>>>>>                            If (bDriverLoadingError = True) Begin
95211>>>>>>>                                Set Label of ho to "Driver could not be loaded!"   
95212>>>>>>>                                If (Trim(sDriverIniFile) = "") Begin
95214>>>>>>>                                    Set Value of ho to "Driver .dll file not found!"
95215>>>>>>>                                End
95215>>>>>>>>
95215>>>>>>>                                Else Begin
95216>>>>>>>                                    Set Value of ho to "No attributes to display..."   
95217>>>>>>>                                End
95217>>>>>>>>
95217>>>>>>>                                Set psToolTip of ho to "Check that the database engine for the selected driver is installed and is running correctly!"  
95218>>>>>>>                                Delegate Set pbDriverLoadingError to True
95220>>>>>>>                                Move iItems to iCount // We're out of here.   
95221>>>>>>>                                Move False to Err
95222>>>>>>>                            End
95222>>>>>>>>
95222>>>>>>>                            If (Err = True) Begin
95224>>>>>>>                                Send Destroy of ho
95225>>>>>>>                            End
95225>>>>>>>>
95225>>>>>>>                            Else Begin
95226>>>>>>>                                If (iCount = 0) Begin
95228>>>>>>>                                    Move (iFirstLineOffset + iLocH) to iLocH
95229>>>>>>>                                End
95229>>>>>>>>
95229>>>>>>>                                Set Location of ho to iLocH (iLocW + 30)
95230>>>>>>>                                Move (iLocH + iHfactor) to iLocH
95231>>>>>>>                            End
95231>>>>>>>>
95231>>>>>>>                        Loop
95232>>>>>>>>
95232>>>>>>>    
95232>>>>>>>                        Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE
95233>>>>>>>                        Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
95234>>>>>>>                    End_Procedure
95235>>>>>>>    
95235>>>>>>>                End_Object
95236>>>>>>>
95236>>>>>>>            End_Object
95237>>>>>>>    
95237>>>>>>>        End_Object
95238>>>>>>>
95238>>>>>>>    End_Object
95239>>>>>>>
95239>>>>>>>    Object oInfo_edt is a cRichEdit
95241>>>>>>>        Set Size to 49 328
95242>>>>>>>        Set Location to 213 9
95243>>>>>>>        Set Label to "General Connectivity Kit Information:"
95244>>>>>>>        Set Value to "It is possible to configure the behavior of a Connectivity Kit through configuration files. Configuration files can be located anywhere in DFPATH. In general, one configuration file per install is enough. There are situations where there is a need to have different configurations for different deploy environments on one machine/network. In that case the configuration file should be placed in the deployment environment rather than in the overall DataFlex environment."
95245>>>>>>>        Set Skip_State to True
95246>>>>>>>        Set Read_Only_State to True
95247>>>>>>>        Set pbItalics to True
95248>>>>>>>        Set peAnchors to anBottomLeftRight
95249>>>>>>>
95249>>>>>>>        Procedure DoIndent
95252>>>>>>>            Integer iTwipsPerInch iCurrentIndent
95252>>>>>>>        
95252>>>>>>>            // number of twips per inch
95252>>>>>>>            Move 1440 to iTwipsPerInch
95253>>>>>>>        
95253>>>>>>>            Set piSpacingBefore to (1440 * 0.05)
95254>>>>>>>            // indent 0.1 inches from current indentation
95254>>>>>>>            Get piParagraphIndent to iCurrentIndent
95255>>>>>>>            Set piParagraphIndent to (iCurrentIndent + (iTwipsPerInch * 0.1))
95256>>>>>>>        End_Procedure
95257>>>>>>>        Send DoIndent
95258>>>>>>>
95258>>>>>>>    End_Object
95259>>>>>>>
95259>>>>>>>    Procedure Activating
95262>>>>>>>        Forward Send Activating
95264>>>>>>>        Send Cursor_Ready of Cursor_Control
95265>>>>>>>    End_Procedure
95266>>>>>>>
95266>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
95267>>>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
95268>>>>>>>End_Object
95269>>>>>>>
95269>>>>>>>// General purpose access method for the dialog above:
95269>>>>>>>Procedure PopupDriverSettings String sDriverID 
95272>>>>>>>    Handle ho
95272>>>>>>>    String sDriverFile sPath
95272>>>>>>>
95272>>>>>>>    Send Cursor_Wait of Cursor_Control
95273>>>>>>>    Move (oDriverSettings_dg(Self)) to ho
95274>>>>>>>    Set psDriverID of ho to sDriverID
95275>>>>>>>    Set pbDriverLoadingError of ho to False
95276>>>>>>>
95276>>>>>>>    Set Value of (oDriver_cf(ho)) to sDriverID
95277>>>>>>>    Get DatabaseDriverPath sDriverID to sPath
95278>>>>>>>    If (sPath <> "") Begin
95280>>>>>>>        Move (sDriverID + ".dll")  to sDriverFile
95281>>>>>>>    End
95281>>>>>>>>
95281>>>>>>>    Set Value of (oDriverFileName_cf(ho)) to (sPath + sDriverFile)
95282>>>>>>>    Send Cursor_Ready of Cursor_Control
95283>>>>>>>
95283>>>>>>>    Send Popup of ho
95284>>>>>>>End_Procedure
95285>>>>>>>
95285>>>>>>>Function DatabaseDriverPath String sDriverID Returns String
95288>>>>>>>    String sPath sDriverFileName
95288>>>>>>>
95288>>>>>>>    Move "" to sPath
95289>>>>>>>    If (sDriverID = DATAFLEX_ID) Begin
95291>>>>>>>        Function_Return sPath
95292>>>>>>>    End                   
95292>>>>>>>>
95292>>>>>>>    
95292>>>>>>>    Move (sDriverID + ".dll") to sDriverFileName
95293>>>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
95294>>>>>>>    
95294>>>>>>>    Function_Return sPath
95295>>>>>>>End_Function      
95296>>>>>>>
95296>>>>>>>Function DatabaseDriverIniFilePath String sDriverID Returns String
95299>>>>>>>    String sPath sDriverFileName
95299>>>>>>>
95299>>>>>>>    Move "" to sPath
95300>>>>>>>    If (sDriverID = DATAFLEX_ID) Begin
95302>>>>>>>        Function_Return sPath
95303>>>>>>>    End                   
95303>>>>>>>>
95303>>>>>>>    
95303>>>>>>>    Move (sDriverID + ".int") to sDriverFileName
95304>>>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
95305>>>>>>>    
95305>>>>>>>    Function_Return sPath
95306>>>>>>>End_Function      
95307>>>>>Use CreateDatabase.dg
Including file: CreateDatabase.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CreateDatabase.dg)
95307>>>>>>>Use Windows.pkg
95307>>>>>>>Use cRDCModalPanel.pkg
95307>>>>>>>Use cRDCForm.pkg 
95307>>>>>>>Use cRDCComboForm.pkg
95307>>>>>>>Use cRDCSuggestionIniForm.pkg
Including file: cRDCSuggestionIniForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCSuggestionIniForm.pkg)
95307>>>>>>>>>//****************************************************************************
95307>>>>>>>>>// $Module type: Class
95307>>>>>>>>>// $Module name: cRDCSuggestionIniForm
95307>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
95307>>>>>>>>>// Web-site    : http://www.rdctools.com
95307>>>>>>>>>// Created     : 2018-09-05 @ 09:50 (Military date format: YY-MM-DD)
95307>>>>>>>>>//
95307>>>>>>>>>// Description : The class consists of a variant of DataAccess Worldwide's cSuggestionFormList
95307>>>>>>>>>//               It has the added ability to save/retrieve values to the workspace .ws file.
95307>>>>>>>>>//
95307>>>>>>>>>// $Rev History:
95307>>>>>>>>>//    2018-09-05  Module header created
95307>>>>>>>>>//
95307>>>>>>>>>//****************************************************************************
95307>>>>>>>>>Use Windows.pkg
95307>>>>>>>>>Use Windows.pkg
95307>>>>>>>>>Use WinSuggestion.pkg
95307>>>>>>>>>Use cIniFile.pkg
95307>>>>>>>>>Use cRDCForm.pkg
95307>>>>>>>>>Use vWin32fh.pkg
95307>>>>>>>>>
95307>>>>>>>>>Define CS_cRDCSuggestionFormList       for "Suggestion Form List"  // [Section Name]
95307>>>>>>>>>Define CS_cRDCSuggestionSaveItem       for "Saved Item"            // Key=Value
95307>>>>>>>>>Define CS_cRDCSuggestionFormTooltip    for "This is a suggestion form - start typing what you're looking for. Previously entered values are saved automatically."
95307>>>>>>>>>
95307>>>>>>>>>Class cRDCSuggestionIniForm is a cRDCForm
95308>>>>>>>>>
95308>>>>>>>>>    Procedure Define_cRDCSuggestionControl_mixin
95310>>>>>>>>>
95310>>>>>>>>>        Property Integer piTimeOutTicks 0
95311>>>>>>>>>
95311>>>>>>>>>        On_Key kEnter            Send SelectSuggestion
95312>>>>>>>>>        On_Key Key_Escape        Send DeActivateSuggestionList
95313>>>>>>>>>        On_Key Key_Up_Arrow      Send Up
95314>>>>>>>>>        On_Key Key_Down_Arrow    Send Down
95315>>>>>>>>>
95315>>>>>>>>>        // Added 'Home' & 'End' navigation keys for the drop-down list and the form object (and Ctrl+Home & Ctrl+End).
95315>>>>>>>>>        On_Key Key_Home          Send Home
95316>>>>>>>>>        On_Key Key_Ctrl+Key_Home Send Home
95317>>>>>>>>>    On_Key Key_End           Send End
95318>>>>>>>>>On_Key Key_Ctrl+Key_End  Send End // Need this as well; else the Ctrl+Home/End keys generates a runtime error (always has).
95319>>>>>>>>>
95319>>>>>>>>>// Just can't seem to get the popup of the suggestion list with F4 to work.
95319>>>>>>>>>On_Key kPrompt           Send Prompt
95320>>>>>>>>>End_Procedure
95321>>>>>>>>>
95321>>>>>>>>>Import_Class_Protocol cSuggestionControl_mixin
95322>>>>>>>>>Import_Class_Protocol cSuggestion_mixin
95323>>>>>>>>>
95323>>>>>>>>>Procedure Construct_Object
95325>>>>>>>>>    Forward Send Construct_Object
95327>>>>>>>>>    Send Define_cRDCSuggestionControl_mixin
95328>>>>>>>>>    Send Define_cSuggestion_mixin
95329>>>>>>>>>
95329>>>>>>>>>    Set peSuggestionMode to smCustom
95330>>>>>>>>>    Set pbFullText to True
95331>>>>>>>>>    Set piStartAtChar to 1
95332>>>>>>>>>
95332>>>>>>>>>    Property String[] psSavedFormValues
95333>>>>>>>>>    Property String psIniFileSection
95334>>>>>>>>>    Property Integer piSuggestionListMaxItems 99 // Max no of values saved/read to ini file
95335>>>>>>>>>    Property Boolean pbUseWorkspaceIniFile True
95336>>>>>>>>>    Property Boolean pbAutoCheckValueExistsAsFile True
95337>>>>>>>>>    Property Boolean pbAskToRemoveMissingFile True
95338>>>>>>>>>    // Note: pbUseWorkspaceIniFile has presedence over the psIniFileName setting.
95338>>>>>>>>>    //       That means that if pbUseWorkspaceIniFile=True, psIniFilename will be set to the
95338>>>>>>>>>    //       worspace .ws file on program startup.
95338>>>>>>>>>    Property String psIniFileName "RDCSuggestionForm.ini"
95339>>>>>>>>>End_Procedure
95340>>>>>>>>>
95340>>>>>>>>>Procedure ShowSuggestions
95342>>>>>>>>>    tSuggestion[] aResults
95342>>>>>>>>>    tSuggestion[] aResults
95343>>>>>>>>>    Integer i iLines
95343>>>>>>>>>    String sSearch
95343>>>>>>>>>
95343>>>>>>>>>    Get pSearchResults to aResults
95344>>>>>>>>>    Get Value to sSearch
95345>>>>>>>>>
95345>>>>>>>>>    If (ghoSuggestionList <> 0) Begin
95347>>>>>>>>>        Send Delete_Data of ghoSuggestionList
95348>>>>>>>>>        Move (SizeOfArray(aResults)) to iLines
95349>>>>>>>>>        For i from 0 to (iLines-1)
95355>>>>>>>>>>
95355>>>>>>>>>            Send ShowSuggestion aResults[i] sSearch
95356>>>>>>>>>            If ((iLines-1)<>i) Begin
95358>>>>>>>>>                Send AppendTextLn of ghoSuggestionList ""
95359>>>>>>>>>            End
95359>>>>>>>>>>
95359>>>>>>>>>        Loop
95360>>>>>>>>>>
95360>>>>>>>>>        Send AdjustSuggestionListSize iLines
95361>>>>>>>>>    End
95361>>>>>>>>>>
95361>>>>>>>>>
95361>>>>>>>>>    Set Cursor of Cursor_Control to IDC_ARROW
95362>>>>>>>>>    Send Activate of (Self)
95363>>>>>>>>>    Send Release_Mouse_Capture
95364>>>>>>>>>End_Procedure
95365>>>>>>>>>
95365>>>>>>>>>Procedure Home
95367>>>>>>>>>    If (Focus(Desktop) = Self and ghoSuggestionList) Begin
95369>>>>>>>>>        Send ScrollHome
95370>>>>>>>>>    End
95370>>>>>>>>>>
95370>>>>>>>>>    Else Begin
95371>>>>>>>>>        Send Key VK_HOME
95372>>>>>>>>>    End
95372>>>>>>>>>>
95372>>>>>>>>>End_Procedure
95373>>>>>>>>>
95373>>>>>>>>>Procedure ScrollHome
95375>>>>>>>>>    Send SelectRow of ghoSuggestionList 0
95376>>>>>>>>>End_Procedure
95377>>>>>>>>>
95377>>>>>>>>>Procedure End
95379>>>>>>>>>If (Focus(Desktop) = Self and ghoSuggestionList) Begin
95381>>>>>>>>>    Send ScrollEnd
95382>>>>>>>>>End
95382>>>>>>>>>>
95382>>>>>>>>>Else Begin
95383>>>>>>>>>    Send Key VK_END
95384>>>>>>>>>End
95384>>>>>>>>>>
95384>>>>>>>>>End_Procedure
95385>>>>>>>>>
95385>>>>>>>>>Procedure ScrollEnd
95387>>>>>>>>>    Integer iLine iLines
95387>>>>>>>>>    Get Line_Count of ghoSuggestionList  to iLines
95388>>>>>>>>>    Get SelectedRow of ghoSuggestionList to iLine
95389>>>>>>>>>    // there can be an extra line at the end
95389>>>>>>>>>    If (iLine < iLines - 1) Begin
95391>>>>>>>>>        Send SelectRow of ghoSuggestionList (iLines - 1)
95392>>>>>>>>>    End
95392>>>>>>>>>>
95392>>>>>>>>>End_Procedure
95393>>>>>>>>>
95393>>>>>>>>>Procedure Activating
95395>>>>>>>>>    String[] sSavedFormValues
95396>>>>>>>>>    If (pbUseWorkspaceIniFile(Self) = True) Begin
95398>>>>>>>>>        Get ReadWorkspaceIniFile to sSavedFormValues
95399>>>>>>>>>        Set psSavedFormValues    to sSavedFormValues
95400>>>>>>>>>    End
95400>>>>>>>>>>
95400>>>>>>>>>End_Procedure
95401>>>>>>>>>
95401>>>>>>>>>Procedure Set psToolTip String sToolTip
95403>>>>>>>>>    String sStatusHelp
95403>>>>>>>>>
95403>>>>>>>>>    Get Status_Help to sStatusHelp
95404>>>>>>>>>    If (sStatusHelp = "") Begin
95406>>>>>>>>>        Set Status_Help to sToolTip
95407>>>>>>>>>    End
95407>>>>>>>>>>
95407>>>>>>>>>
95407>>>>>>>>>    Move (sToolTip + String(Character(10)) + String(CS_cRDCSuggestionFormTooltip)) to sToolTip
95408>>>>>>>>>    Forward Set psToolTip to sToolTip
95410>>>>>>>>>End_Procedure
95411>>>>>>>>>
95411>>>>>>>>>Function ReadWorkspaceIniFile Returns String[]
95413>>>>>>>>>    String sWorkspaceFile sObjectName sValue
95413>>>>>>>>>    String[] sSavedFormValues
95414>>>>>>>>>    Handle hoIniFile
95414>>>>>>>>>    Integer iItem iCount iSize
95414>>>>>>>>>    Boolean bExists
95414>>>>>>>>>
95414>>>>>>>>>    If (pbUseWorkspaceIniFile(Self) = False) Begin
95416>>>>>>>>>        Function_Return sSavedFormValues
95417>>>>>>>>>    End
95417>>>>>>>>>>
95417>>>>>>>>>
95417>>>>>>>>>    Move 0 to iItem
95418>>>>>>>>>    Get Object_Label to sObjectName
95419>>>>>>>>>    Move (psWorkspaceWSFile(phoWorkspace(ghoApplication))) to sWorkspaceFile
95420>>>>>>>>>    Set psIniFileName to sWorkspaceFile
95421>>>>>>>>>    Get Create (RefClass(cIniFile)) to hoIniFile
95422>>>>>>>>>    Set psFileName of hoIniFile to sWorkspaceFile
95423>>>>>>>>>    Get piSuggestionListMaxItems to iSize
95424>>>>>>>>>
95424>>>>>>>>>    For iCount from 0 to iSize
95430>>>>>>>>>>
95430>>>>>>>>>        Get KeyExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) to bExists
95431>>>>>>>>>        // We need to loop through all possible values because the list of items may not start at zero.
95431>>>>>>>>>        Get ReadString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) "" to sValue
95432>>>>>>>>>        If (Trim(sValue) <> "") Begin
95434>>>>>>>>>            Move sValue to sSavedFormValues[iItem]
95435>>>>>>>>>            Increment iItem
95436>>>>>>>>>        End
95436>>>>>>>>>>
95436>>>>>>>>>    Loop
95437>>>>>>>>>>
95437>>>>>>>>>
95437>>>>>>>>>    Send Destroy of hoIniFile
95438>>>>>>>>>    Function_Return sSavedFormValues
95439>>>>>>>>>End_Function
95440>>>>>>>>>
95440>>>>>>>>>Procedure WriteWorkspaceIniFile
95442>>>>>>>>>    String sWorkspaceFile sObjectName sValue
95442>>>>>>>>>    String[] sSavedFormValues
95443>>>>>>>>>    Handle hoIniFile
95443>>>>>>>>>    Integer iSize iCount
95443>>>>>>>>>    Boolean bExists
95443>>>>>>>>>
95443>>>>>>>>>    If (pbUseWorkspaceIniFile(Self) = False) Begin
95445>>>>>>>>>        Procedure_Return
95446>>>>>>>>>    End
95446>>>>>>>>>>
95446>>>>>>>>>
95446>>>>>>>>>    Get Object_Label  to sObjectName
95447>>>>>>>>>    Get psIniFileName to sWorkspaceFile
95448>>>>>>>>>    Get Create (RefClass(cIniFile)) to hoIniFile
95449>>>>>>>>>    Set psFileName    of hoIniFile to sWorkspaceFile
95450>>>>>>>>>    Get SectionExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) to bExists
95451>>>>>>>>>    If (bExists = True) Begin
95453>>>>>>>>>        Send DeleteSection of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName))
95454>>>>>>>>>    End
95454>>>>>>>>>>
95454>>>>>>>>>
95454>>>>>>>>>    Get psSavedFormValues to sSavedFormValues
95455>>>>>>>>>    Move (SizeOfArray(sSavedFormValues)) to iSize
95456>>>>>>>>>    Decrement iSize
95457>>>>>>>>>
95457>>>>>>>>>    For iCount from 0 to iSize
95463>>>>>>>>>>
95463>>>>>>>>>        Move sSavedFormValues[iCount] to sValue
95464>>>>>>>>>        Move (Trim(sValue)) to sValue
95465>>>>>>>>>        Get vFilePathExists sValue to bExists
95466>>>>>>>>>        If (bExists = True) Begin
95468>>>>>>>>>            Send WriteString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) sSavedFormValues[iCount]
95469>>>>>>>>>        End
95469>>>>>>>>>>
95469>>>>>>>>>    Loop
95470>>>>>>>>>>
95470>>>>>>>>>
95470>>>>>>>>>    Send Destroy of hoIniFile
95471>>>>>>>>>End_Procedure
95472>>>>>>>>>
95472>>>>>>>>>Procedure Prompt
95474>>>>>>>>>    If (ghoSuggestionTimer=0) Begin
95476>>>>>>>>>        Send CreateSuggestionTimer
95477>>>>>>>>>    End
95477>>>>>>>>>>
95477>>>>>>>>>    Send ActivateSuggestionList
95478>>>>>>>>>    Send FindSuggestions
95479>>>>>>>>>    Set Visible_State of ghoSuggestionList to True
95480>>>>>>>>>End_Procedure
95481>>>>>>>>>
95481>>>>>>>>>Procedure OnExitObject
95483>>>>>>>>>    String sValue
95483>>>>>>>>>    Boolean bExists
95483>>>>>>>>>    String[] sSavedFormValues
95484>>>>>>>>>    Integer iSize iIndex
95484>>>>>>>>>
95484>>>>>>>>>    Forward Send OnExitObject
95486>>>>>>>>>
95486>>>>>>>>>    If (pbUseWorkspaceIniFile(Self) = False) Begin
95488>>>>>>>>>        Procedure_Return
95489>>>>>>>>>    End
95489>>>>>>>>>>
95489>>>>>>>>>
95489>>>>>>>>>    Get Value to sValue
95490>>>>>>>>>    Move (Trim(sValue)) to sValue
95491>>>>>>>>>    Get psSavedFormValues to sSavedFormValues
95492>>>>>>>>>    Move (SearchArray(sValue, sSavedFormValues)) to iIndex
95493>>>>>>>>>    // Does it exist in the array already?
95493>>>>>>>>>    If (iIndex <> -1) Begin
95495>>>>>>>>>        Procedure_Return
95496>>>>>>>>>    End
95496>>>>>>>>>>
95496>>>>>>>>>    Get vFilePathExists sValue to bExists
95497>>>>>>>>>    If (bExists = False) Begin
95499>>>>>>>>>        Procedure_Return
95500>>>>>>>>>    End
95500>>>>>>>>>>
95500>>>>>>>>>    Move (SizeOfArray(sSavedFormValues)) to iSize
95501>>>>>>>>>    Move sValue to sSavedFormValues[iSize]
95502>>>>>>>>>    Set psSavedFormValues to sSavedFormValues
95503>>>>>>>>>    Send WriteWorkspaceIniFile
95504>>>>>>>>>End_Procedure
95505>>>>>>>>>
95505>>>>>>>>>// Custom code to find all matches for the search
95505>>>>>>>>>Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
95507>>>>>>>>>    String[] sSavedFormValues
95508>>>>>>>>>    Integer i iLen iSize iCount
95508>>>>>>>>>
95508>>>>>>>>>    Move (Lowercase(sSearch)) to sSearch
95509>>>>>>>>>    Move (Length(sSearch)) to iLen
95510>>>>>>>>>    Get psSavedFormValues to sSavedFormValues
95511>>>>>>>>>    Move (SizeOfArray(sSavedFormValues)) to iSize
95512>>>>>>>>>    Decrement iSize
95513>>>>>>>>>    For i from 0 to iSize
95519>>>>>>>>>>
95519>>>>>>>>>        If (Lowercase(sSavedFormValues[i]) contains sSearch) Begin
95521>>>>>>>>>            Move sSavedFormValues[i] to aSuggestions[iCount].sRowId
95522>>>>>>>>>            Move sSavedFormValues[i] to aSuggestions[iCount].aValues[0]
95523>>>>>>>>>            Increment iCount
95524>>>>>>>>>        End
95524>>>>>>>>>>
95524>>>>>>>>>    Loop
95525>>>>>>>>>>
95525>>>>>>>>>End_Procedure
95526>>>>>>>>>
95526>>>>>>>>>Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
95528>>>>>>>>>    Boolean bExists bAutoCheckValueExistsAsFile bAskToRemoveMissingFile
95528>>>>>>>>>    Integer iRetval iIndex
95528>>>>>>>>>    String[] sSavedFormValues
95529>>>>>>>>>    String sValue
95529>>>>>>>>>
95529>>>>>>>>>    //        Send Release_Mouse_Capture
95529>>>>>>>>>    Move Suggestion.sRowId to sValue
95530>>>>>>>>>    Move (Trim(sValue)) to sValue
95531>>>>>>>>>    Get pbAutoCheckValueExistsAsFile to bAutoCheckValueExistsAsFile
95532>>>>>>>>>
95532>>>>>>>>>    If (bAutoCheckValueExistsAsFile = True) Begin
95534>>>>>>>>>        Get pbAskToRemoveMissingFile to bAskToRemoveMissingFile
95535>>>>>>>>>        Get vFilePathExists sValue to bExists
95536>>>>>>>>>        If (bExists = False) Begin
95538>>>>>>>>>            If (bAskToRemoveMissingFile = True) Begin
95540>>>>>>>>>                Get YesNo_Box ("The file" * String(sValue) + "\nDoesn't exist. Do you want to remove it from the suggestion list?") to iRetval
95541>>>>>>>>>            End
95541>>>>>>>>>>
95541>>>>>>>>>            // This will happen if bAskToRemoveMissingFile = False, and bAutoCheckValueExistsAsFile = True.
95541>>>>>>>>>            // Then the missing file will just be removed from the saved list.
95541>>>>>>>>>            Else Begin
95542>>>>>>>>>                Move MBR_Yes to iRetval
95543>>>>>>>>>            End
95543>>>>>>>>>>
95543>>>>>>>>>
95543>>>>>>>>>            If (iRetval = MBR_Yes) Begin
95545>>>>>>>>>                Get psSavedFormValues to sSavedFormValues
95546>>>>>>>>>                Move (SearchArray(sValue, sSavedFormValues)) to iIndex
95547>>>>>>>>>                If (iIndex <> -1) Begin
95549>>>>>>>>>                    Move (RemoveFromArray(sSavedFormValues, iIndex)) to sSavedFormValues
95550>>>>>>>>>                    Set psSavedFormValues to sSavedFormValues
95551>>>>>>>>>                    Send WriteWorkspaceIniFile
95552>>>>>>>>>                    Set Value to ""
95553>>>>>>>>>                    Procedure_Return
95554>>>>>>>>>                End
95554>>>>>>>>>>
95554>>>>>>>>>            End
95554>>>>>>>>>>
95554>>>>>>>>>        End
95554>>>>>>>>>>
95554>>>>>>>>>    End
95554>>>>>>>>>>
95554>>>>>>>>>
95554>>>>>>>>>    Set Value to Suggestion.sRowId
95555>>>>>>>>>    Set Item_Changed_State to False
95556>>>>>>>>>End_Procedure
95557>>>>>>>>>
95557>>>>>>>>>//    { MethodType=Event  NoDoc=True }
95557>>>>>>>>>//    Procedure Mouse_Click Integer i1 Integer i2
95557>>>>>>>>>//        Send Release_Mouse_Capture
95557>>>>>>>>>//        Forward Send Mouse_click i1 i2
95557>>>>>>>>>//    End_Procedure
95557>>>>>>>>>
95557>>>>>>>>>End_Class
95558>>>>>>>>>
95558>>>>>>>>>//    Procedure Mouse_Up for cRDCSuggestionList Integer iWindowNumber Integer iPosition
95558>>>>>>>>>//        Handle hoObj
95558>>>>>>>>>//        Send Release_Mouse_Capture
95558>>>>>>>>>//        Get phoOwner to hoObj
95558>>>>>>>>>//        Send Activate of hoObj // move focus to owner, which will close the list
95558>>>>>>>>>//        Send SelectSuggestion of hoObj
95558>>>>>>>>>//    End_Procedure // Mouse_Up
95558>>>>>>>>>
95558>>>>>>>>>//    Function OnWindowsHook for cRDCSuggestionHookMouse Integer i1 Integer i2 Integer i3 Returns Integer
95558>>>>>>>>>//        tWinMouseHookStruct MouseHook
95558>>>>>>>>>//        Integer ivoid hObj
95558>>>>>>>>>//        Handle hoOwner hoParent
95558>>>>>>>>>//        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;
95558>>>>>>>>>//                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
95558>>>>>>>>>//            Send Release_Mouse_Capture
95558>>>>>>>>>//            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
95558>>>>>>>>>//            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
95558>>>>>>>>>//            If (hObj = Cursor_Control) Begin
95558>>>>>>>>>//                Move (Focus(Desktop)) to hObj
95558>>>>>>>>>//            End
95558>>>>>>>>>//            Get Parent to hoParent
95558>>>>>>>>>//            Get phoOwner of hoParent to hoOwner
95558>>>>>>>>>//            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
95558>>>>>>>>>//                Send DisableWindowsHook
95558>>>>>>>>>//                Send DeActivateSuggestionList of hoOwner
95558>>>>>>>>>//            End
95558>>>>>>>>>//        End
95558>>>>>>>>>//    End_Function
95558>>>>>>>>>
95558>>>>>>>Use cDbUpdateFunctionLibrary.pkg
95558>>>>>>>Use cRDCHeaderGroup.pkg
95558>>>>>>>Use cCommandLinkButton.pkg
95558>>>>>>>
95558>>>>>>>Object oCreateDatabase_dg is a cRDCModalPanel
95560>>>>>>>    Set Size to 151 312
95561>>>>>>>    Set Label to "Create New Database"
95562>>>>>>>    Set piMinSize to 53 211
95563>>>>>>>    Set Location to 2 2
95564>>>>>>>    Set Icon to "ActionCreateDatabase1.ico"
95565>>>>>>>    
95565>>>>>>>    Property String psDriverID                   
95567>>>>>>>    Property String psCollation 
95569>>>>>>>    Property String psDatabaseName 
95571>>>>>>>
95571>>>>>>>//    Object oCollate_cf is a cRDCComboForm
95571>>>>>>>//        Set Size to 13 216
95571>>>>>>>//        Set Location to 42 63
95571>>>>>>>//        Set Label to "Use Collation:"  
95571>>>>>>>//        Set psToolTip to "Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
95571>>>>>>>//        // This must be set to False; else the filling takes for ever.
95571>>>>>>>//        Set pbAutoListWidth to False
95571>>>>>>>//        
95571>>>>>>>//        Procedure Combo_Fill_List
95571>>>>>>>//            String[] asCollations   
95571>>>>>>>//            Integer iCount iSize      
95571>>>>>>>//            String sDriverID sCollation
95571>>>>>>>//            
95571>>>>>>>//            Get psDriverID to sDriverID      
95571>>>>>>>//            
95571>>>>>>>//            // The _SqlEnumerateDatabaseCollations function is *at current* for MSSQLDRV_ID only.
95571>>>>>>>//            If (sDriverID = MSSQLDRV_ID) Begin
95571>>>>>>>//                Send Cursor_Wait of Cursor_Control
95571>>>>>>>//                Get _SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
95571>>>>>>>//                Move (SizeOfArray(asCollations)) to iSize
95571>>>>>>>//                Decrement iSize
95571>>>>>>>//                For iCount from 0 to iSize
95571>>>>>>>//                    Send Combo_Add_Item asCollations[iCount]
95571>>>>>>>//                Loop
95571>>>>>>>//                
95571>>>>>>>//                Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
95571>>>>>>>//                Set Value to sCollation
95571>>>>>>>//                Send Cursor_Ready of Cursor_Control
95571>>>>>>>//            End
95571>>>>>>>//        End_Procedure
95571>>>>>>>//    
95571>>>>>>>//        Procedure OnChange
95571>>>>>>>//            String sValue
95571>>>>>>>//            Get Value to sValue
95571>>>>>>>//            Set psCollation to sValue
95571>>>>>>>//        End_Procedure
95571>>>>>>>//     
95571>>>>>>>//    End_Object
95571>>>>>>>
95571>>>>>>>    Object oInfo_tb is a TextBox
95573>>>>>>>        Set Auto_Size_State to False
95574>>>>>>>        Set Size to 8 50
95575>>>>>>>        Set Location to 133 120
95576>>>>>>>        Set TextColor to clGreen
95577>>>>>>>        Set Justification_Mode to JMode_Right
95578>>>>>>>        Set peAnchors to anBottomRight
95579>>>>>>>    End_Object
95580>>>>>>>
95580>>>>>>>    Object oMain_RDCHeaderGroup is a cRDCHeaderGroup
95582>>>>>>>        Set Size to 108 293
95583>>>>>>>        Set Location to 8 10
95584>>>>>>>        Set psImage to "ActionCreateDatabase1.ico"
95585>>>>>>>        Set Label to "Create Database"
95586>>>>>>>        Set psNote to "Enter collation and database name"
95587>>>>>>>        Set peAnchors to anTopBottom
95588>>>>>>>
95588>>>>>>>        Object oDriver_fm is a cRDCForm
95590>>>>>>>            Set Size to 13 100
95591>>>>>>>            Set Location to 34 63
95592>>>>>>>            Set Label to "Driver"
95593>>>>>>>            Set Enabled_State to False  
95594>>>>>>>        End_Object  
95595>>>>>>>        
95595>>>>>>>        Object oServerCurrentCollating_fm is a cRDCForm
95597>>>>>>>            Set Size to 13 216
95598>>>>>>>            Set Location to 49 63
95599>>>>>>>            Set Label to "Default Collation"
95600>>>>>>>            Set psToolTip to "The SQL server's default collation. It will be used when creating a new database, if nothing else is specified."
95601>>>>>>>            Set Enabled_State to False  
95602>>>>>>>            
95602>>>>>>>            Procedure InitializeCollation 
95605>>>>>>>                String sCollation
95605>>>>>>>                
95605>>>>>>>                Move False to Err
95606>>>>>>>                Send Ignore_All of Error_Object_Id
95607>>>>>>>                // Fetch the SQL server's default collation:
95607>>>>>>>                // It will be used when creating a new database, if nothing else is specified.
95607>>>>>>>                Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary "master" False to sCollation
95608>>>>>>>                Send Trap_All of Error_Object_Id
95609>>>>>>>                If (Err = True) Begin
95611>>>>>>>                    Move "" to sCollation
95612>>>>>>>                End
95612>>>>>>>>
95612>>>>>>>                Set Value to sCollation
95613>>>>>>>            End_Procedure     
95614>>>>>>>    
95614>>>>>>>        End_Object  
95615>>>>>>>        
95615>>>>>>>        Object oCollate_fm is a cRDCSuggestionIniForm 
95617>>>>>>>            Set Size to 13 216
95618>>>>>>>            Set Location to 65 63
95619>>>>>>>            Set Label to "Collation"
95620>>>>>>>            Set psToolTip to "Suggestion list. Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
95621>>>>>>>            Set pbAskToRemoveMissingFile to False
95622>>>>>>>            Set pbAutoCheckValueExistsAsFile to False
95623>>>>>>>            Set pbUseWorkspaceIniFile to True
95624>>>>>>>            Set piStartAtChar to 3
95625>>>>>>>            Set Prompt_Button_Mode to PB_PromptOn
95626>>>>>>>            
95626>>>>>>>            Function ReadWorkspaceIniFile Returns String[]
95629>>>>>>>                String[] asCollations   
95630>>>>>>>                Integer iCount iSize      
95630>>>>>>>                String sDriverID sCollation
95630>>>>>>>                
95630>>>>>>>                Get psDriverID to sDriverID      
95631>>>>>>>                // The _SqlEnumerateDatabaseCollations function is at current for MSSQLDRV_ID only.
95631>>>>>>>                If (sDriverID <> MSSQLDRV_ID) Begin
95633>>>>>>>                    Function_Return asCollations
95634>>>>>>>                End                 
95634>>>>>>>>
95634>>>>>>>                
95634>>>>>>>                Send Cursor_Wait of Cursor_Control
95635>>>>>>>                Get _SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
95636>>>>>>>                Set psSavedFormValues to asCollations
95637>>>>>>>                    
95637>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
95639>>>>>>>                    Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
95640>>>>>>>                    Set Value to sCollation
95641>>>>>>>                End
95641>>>>>>>>
95641>>>>>>>                Send Cursor_Ready of Cursor_Control
95642>>>>>>>                Function_Return asCollations
95643>>>>>>>            End_Function
95644>>>>>>>    
95644>>>>>>>            Procedure OnChange
95647>>>>>>>                String sValue
95647>>>>>>>                Get Value to sValue
95648>>>>>>>                Set psCollation to sValue
95649>>>>>>>            End_Procedure
95650>>>>>>>         
95650>>>>>>>            Procedure WriteWorkspaceIniFile
95653>>>>>>>            End_Procedure             
95654>>>>>>>            
95654>>>>>>>//            Procedure Prompt      
95654>>>>>>>//                If (ghoSuggestionTimer=0) Begin
95654>>>>>>>//                    Send CreateSuggestionTimer
95654>>>>>>>//                End
95654>>>>>>>//                Send ActivateSuggestionList
95654>>>>>>>//                Send FindSuggestions
95654>>>>>>>//                Set Visible_State of ghoSuggestionList to True
95654>>>>>>>//            End_Procedure 
95654>>>>>>>            
95654>>>>>>>            Procedure OnEnterObject
95657>>>>>>>                Set pbUseWorkspaceIniFile to True
95658>>>>>>>                Forward Send OnEnterObject
95660>>>>>>>            End_Procedure
95661>>>>>>>
95661>>>>>>>            Procedure OnExitObject
95664>>>>>>>                Set pbUseWorkspaceIniFile to False
95665>>>>>>>                Forward Send OnExitObject
95667>>>>>>>            End_Procedure
95668>>>>>>>        
95668>>>>>>>            On_Key kCancel Send KeyAction of oCancel_Btn   
95669>>>>>>>//            On_Key kPrompt Send Prompt
95669>>>>>>>        End_Object   
95670>>>>>>>        
95670>>>>>>>        Object oDatabaseName_fm is a cRDCForm
95672>>>>>>>            Set Size to 13 216
95673>>>>>>>            Set Location to 81 63
95674>>>>>>>            Set Label_Col_Offset to 2
95675>>>>>>>            Set Label_Justification_Mode to JMode_Right
95676>>>>>>>            Set Label to "Database Name"
95677>>>>>>>            Set psToolTip to "Specify the name of the database to be created."
95678>>>>>>>        End_Object
95679>>>>>>>    
95679>>>>>>>    End_Object
95680>>>>>>>
95680>>>>>>>    Object oOK_Btn is a Button
95682>>>>>>>        Set Label    to "&OK"
95683>>>>>>>        Set Location to 130 198
95684>>>>>>>        Set peAnchors to anBottomRight   
95685>>>>>>>        
95685>>>>>>>        Property String psWorkingText "Working..."
95687>>>>>>>        Property String psIdleText    ""
95689>>>>>>>
95689>>>>>>>        Procedure OnClick
95692>>>>>>>            String sDatabase sDriverID sCollation
95692>>>>>>>            Boolean bOK bExists
95692>>>>>>>        
95692>>>>>>>            Get Value of oDatabaseName_fm to sDatabase    
95693>>>>>>>            Get psDriverID to sDriverID
95694>>>>>>>            Set psDatabaseName to ""
95695>>>>>>>
95695>>>>>>>            If (sDatabase <> "" and sDriverID <> "") Begin    
95697>>>>>>>                Set Value of oInfo_tb to (psWorkingText(Self))
95698>>>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
95700>>>>>>>                    Get psCollation to sCollation
95701>>>>>>>                    Set psCollation of ghoDbUpdateFunctionLibrary to sCollation
95702>>>>>>>                End
95702>>>>>>>>
95702>>>>>>>
95702>>>>>>>                Get SqlUtilCheckIfDatabaseExists of ghoDbUpdateFunctionLibrary sDatabase to bExists
95703>>>>>>>                If (bExists = True) Begin
95705>>>>>>>                    Set Value of oInfo_tb to ""
95706>>>>>>>                    Send Info_Box "The database already exists. No changes made."
95707>>>>>>>                    Procedure_Return
95708>>>>>>>                End
95708>>>>>>>>
95708>>>>>>>                Send Cursor_Wait of Cursor_Control     
95709>>>>>>>                Get SqlDatabaseCreate of ghoDbUpdateFunctionLibrary sDriverID sDatabase False False to bOK
95710>>>>>>>                Send Cursor_Ready of Cursor_Control
95711>>>>>>>                Set Value of oInfo_tb to (psIdleText(Self))
95712>>>>>>>                If (bOK = False) Begin
95714>>>>>>>                    Send Info_Box ("Something went wrong and the database could NOT be created. Please check your database manager.")
95715>>>>>>>                    Procedure_Return
95716>>>>>>>                End 
95716>>>>>>>>
95716>>>>>>>                Set psDatabaseName to sDatabase
95717>>>>>>>                Send Close_Panel
95718>>>>>>>            End                                 
95718>>>>>>>>
95718>>>>>>>            Else If (sDatabase = "") Begin
95721>>>>>>>                Send Info_Box ("Please enter a database name and try again.")
95722>>>>>>>            End
95722>>>>>>>>
95722>>>>>>>        End_Procedure
95723>>>>>>>
95723>>>>>>>    End_Object
95724>>>>>>>
95724>>>>>>>    Object oCancel_Btn is a Button
95726>>>>>>>        Set Label    to "&Cancel"
95727>>>>>>>        Set Location to 130 253
95728>>>>>>>        Set peAnchors to anBottomRight
95729>>>>>>>
95729>>>>>>>        Procedure OnClick
95732>>>>>>>            Send Close_Panel
95733>>>>>>>        End_Procedure
95734>>>>>>>
95734>>>>>>>    End_Object
95735>>>>>>>
95735>>>>>>>    Object oHelp_btn is a Button
95737>>>>>>>        Set Location to 130 75
95738>>>>>>>        Set Label to "Help"
95739>>>>>>>        Set psImage to "ActionHelpInternet1.ico"
95740>>>>>>>        Set psToolTip to "Show a Full List of Collations Supported in SQL Server 2017"
95741>>>>>>>        Set peAnchors to anBottomLeft
95742>>>>>>>    
95742>>>>>>>        Procedure OnClick
95745>>>>>>>            Runprogram Shell Background "https://database.guide/full-list-of-collations-supported-in-sql-server-2017/"
95746>>>>>>>        End_Procedure
95747>>>>>>>    
95747>>>>>>>    End_Object
95748>>>>>>>    
95748>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
95749>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
95750>>>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
95751>>>>>>>End_Object
95752>>>>>>>
95752>>>>>>>Function Create_DataBase_Dialog String sDriverID Returns String
95755>>>>>>>    String sDatabaseName         
95755>>>>>>>    Handle ho
95755>>>>>>>    
95755>>>>>>>    Move (oCreateDatabase_dg(Self)) to ho
95756>>>>>>>    Set psDriverID of ho to sDriverID
95757>>>>>>>    Set Value of (oDriver_fm(ho)) to sDriverID
95758>>>>>>>    Set Value of (oDatabaseName_fm(ho)) to ""
95759>>>>>>>    Send InitializeCollation of (oServerCurrentCollating_fm(ho))
95760>>>>>>>    Send Popup of ho
95761>>>>>>>    
95761>>>>>>>    Get psDatabaseName of ho to sDatabaseName
95762>>>>>>>    Function_Return sDatabaseName
95763>>>>>>>End_Function                         
95764>>>>>
95764>>>>>Define CS_LoadingServers        for "Enumerating servers..."
95764>>>>>Define CS_LoadingDatabases      for "Enumerating databases..."
95764>>>>>Define CS_LoadingTableSpaces    for "Enumerating table spaces..."
95764>>>>>Define CS_LoadingSchemas        for "Enumerating schemas..."
95764>>>>>Define CS_LoginAttempt          for "Connecting..."
95764>>>>>Define CS_LoginSuccessful       for "Login successful!"
95764>>>>>Define CS_LoginFailed           for "Login failed!"
95764>>>>>Define CS_DF_File_Schema        for "Schema"
95764>>>>>Define CS_DF_File_Owner         for "Owner"
95764>>>>>
95764>>>>>Object oSQLMaintainConnections_dg is a ModalPanel
95766>>>>>    Set Label to "Edit SQL Connection"
95767>>>>>    Set Size to 315 324 //309 324
95768>>>>>    Set Location to 4 6
95769>>>>>    Set piMaxSize to (Hi(Size(Self))) (Low(Size(Self)) + 300)
95770>>>>>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
95771>>>>>    Set Locate_Mode to CENTER_ON_PARENT
95772>>>>>    Set Border_Style to Border_Thick
95773>>>>>    
95773>>>>>    Property Boolean pbReadOnly  False
95775>>>>>    Property Boolean pbNew       False // First time for a workspace, which means the .ini-file is empty.
95777>>>>>    Property Integer piCurrentRow -1   // The current row of the grid that was passed to this dialog.
95779>>>>>    Property Boolean pbChanged   False // If any change was made to the data.
95781>>>>>    Property Handle phoDialogCommandbar
95783>>>>>    Property tSQLConnection pSQLConnectionData
95785>>>>>    Property tDataSourceRow[] pTheData
95787>>>>>    Property Boolean pbDFConnId  False // Is set to True if this is a DAW "DFConnId.ini" file; in which case we warn to not encrypt/decrypt password. (different algorithms and don't touch password)
95789>>>>>    Property String psUncryptedPw      // Used if  pbDFConnId = True to temporary save the un-encrypted password.
95791>>>>>
95791>>>>>    Object oSettings_grp is a cRDCHeaderGroup
95793>>>>>        Set Size to 202 303
95794>>>>>        Set Location to 77 11 //71 11
95795>>>>>        Set psImage to "Settings1.ico"
95796>>>>>        Set psLabel to "SQL Connection Settings"
95797>>>>>        Set peAnchors to anTopLeftRight
95798>>>>>        Set psToolTip to "Setup the SQL connection."
95799>>>>>
95799>>>>>        Object oConnectionID_fm is a cSQLForm
95801>>>>>            Set Size to 13 115
95802>>>>>            Set Location to 22 82
95803>>>>>            Set Label to "Connection ID"
95804>>>>>            Set psToolTip to "The DFConnectionID keyword to set a default connection id for the driver. This is the connection ID that appear in database table .int files with the format; 'SERVER_NAME DFCONNID=MyConnID'"
95805>>>>>            Set piItem to 2
95806>>>>>            Set peAnchors to anTopLeftRight
95807>>>>>        End_Object
95808>>>>>
95808>>>>>        Object oEnabled_cb is a cSQLCheckBox
95810>>>>>            Set Size to 10 36
95811>>>>>            Set Location to 25 210
95812>>>>>            Set Label to "Enabled"
95813>>>>>            Set psToolTip to "Check to indicate that this is the enabled connection. Note: There can only be one enabled connection at a time."
95814>>>>>            Set piItem to 1
95815>>>>>            Set peAnchors to anTopRight
95816>>>>>
95816>>>>>            Procedure OnChange
95819>>>>>                Boolean bChecked bNew
95819>>>>>                tSQLConnection SQLConnection
95819>>>>>                tSQLConnection SQLConnection
95819>>>>>
95819>>>>>                Get pbNew to bNew
95820>>>>>                Get Checked_State to bChecked
95821>>>>>                If (bNew = False and bChecked = True) Begin
95823>>>>>                    Get pSQLConnectionData to SQLConnection
95824>>>>>                    Move True to SQLConnection.bEnabled
95825>>>>>                End
95825>>>>>>
95825>>>>>
95825>>>>>            End_Procedure
95826>>>>>
95826>>>>>        End_Object
95827>>>>>
95827>>>>>        Object oODBC_rgp is a RadioGroup
95829>>>>>            Set Location to 38 24
95830>>>>>            Set Size to 32 173
95831>>>>>//            Set psToolTip to "Only available if the ODBC_DRV has been selected. Depending on the radio button that is selected the 'Server/DSN' selection list shows different values."
95831>>>>>            Set peAnchors to anTopLeftRight
95832>>>>>            Set Label to "ODBC Source Type"
95833>>>>>
95833>>>>>            Object oRadio0 is a Radio
95835>>>>>                Set Label to "User data"
95836>>>>>                Set Size to 10 44
95837>>>>>                Set Location to 12 5
95838>>>>>            End_Object
95839>>>>>
95839>>>>>            Object oRadio1 is a Radio
95841>>>>>                Set Label to "System data"
95842>>>>>                Set Size to 10 52
95843>>>>>                Set Location to 12 52
95844>>>>>            End_Object
95845>>>>>
95845>>>>>            Object oRadio2 is a Radio
95847>>>>>                Set Label to "Both"
95848>>>>>                Set Size to 10 26
95849>>>>>                Set Location to 13 109
95850>>>>>            End_Object
95851>>>>>
95851>>>>>            Object oRadio3 is a Radio
95853>>>>>                Set Label to "File"
95854>>>>>                Set Size to 10 25
95855>>>>>                Set Location to 13 141
95856>>>>>            End_Object
95857>>>>>
95857>>>>>            Procedure Notify_Select_State Integer iToItem Integer iFromItem
95860>>>>>                Forward Send Notify_Select_State iToItem iFromItem 
95862>>>>>                If (oFileDSN_btn(Self) <> 0) Begin
95864>>>>>                    Set Enabled_State of oFileDSN_btn to (iToItem = 3)
95865>>>>>                End
95865>>>>>>
95865>>>>>            End_Procedure
95866>>>>>
95866>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
95869>>>>>                Set Enabled_State to (sDriverID = ODBC_DRV_ID)
95870>>>>>                Set Enabled_State of oODBC_rgp to (sDriverID = ODBC_DRV_ID)
95871>>>>>            End_Procedure
95872>>>>>
95872>>>>>            Set Current_Radio to 2
95873>>>>>        End_Object
95874>>>>>
95874>>>>>        Object oFileDSN_btn is a cRDCButton
95876>>>>>            Set Size to 13 78
95877>>>>>            Set Location to 42 210
95878>>>>>            Set Label to "Select File DSN..."
95879>>>>>            Set pbAutoEnable to True
95880>>>>>            Set peAnchors to anTopRight
95881>>>>>
95881>>>>>            Procedure OnClick
95884>>>>>                String sFileName
95884>>>>>                Get vSelect_File ("Data Sources (*.dsn)|*.dsn|All Files (*.*)|*.*") "Select a file data source" "" to sFileName
95885>>>>>                If (sFileName <> "") Begin
95887>>>>>                    Set Value of oServer_fm to sFileName
95888>>>>>                End
95888>>>>>>
95888>>>>>            End_Procedure     
95889>>>>>            
95889>>>>>            Function IsEnabled Returns Boolean
95892>>>>>                String sDriverID
95892>>>>>                Integer iRadio
95892>>>>>                Get Value of oDriverID_cf to sDriverID
95893>>>>>                Get Current_Radio of oODBC_rgp to iRadio
95894>>>>>                Function_Return (sDriverID = ODBC_DRV_ID and iRadio = 3)
95895>>>>>            End_Function
95896>>>>>
95896>>>>>        End_Object
95897>>>>>
95897>>>>>        Object oODBCAdmin_btn is a cRDCButton
95899>>>>>            Set Size to 13 78
95900>>>>>            Set Location to 57 210
95901>>>>>            Set Label to "ODBC Admin" 
95902>>>>>            Set psImage to "ODBCAD32.ico"
95903>>>>>            Set pbAutoEnable to True
95904>>>>>            Set peAnchors to anTopRight
95905>>>>>            
95905>>>>>            Procedure OnClick
95908>>>>>                Handle hWnd
95908>>>>>                Get Window_Handle to hWnd
95909>>>>>                If (hWnd <> 0) Begin
95911>>>>>                    Call_Driver 0 ODBC_DRV_ID Function ODBC_MANAGE_DATA_SOURCES Callback 0 Passing CLI$StrDummy CLI$StrDummy !1 Result CLI$IntDummy
95916>>>>>                End
95916>>>>>>
95916>>>>>                Else Begin
95917>>>>>                    Send Stop_Box "Could not get a Windows handle.."
95918>>>>>                End
95918>>>>>>
95918>>>>>            End_Procedure
95919>>>>>
95919>>>>>            Function IsEnabled Returns Boolean
95922>>>>>                String sDriverID
95922>>>>>                Get Value of oDriverID_cf to sDriverID
95923>>>>>                Function_Return (sDriverID = ODBC_DRV_ID)
95924>>>>>            End_Function
95925>>>>>
95925>>>>>        End_Object
95926>>>>>
95926>>>>>        Object oServer_fm is a cSQLForm
95928>>>>>            Set Size to 13 114
95929>>>>>            Set Location to 74 82
95930>>>>>            Set Label to "Server"
95931>>>>>            Set psToolTip to "Server/DSN: Depending on the selected database type the label can either display as 'Server' or 'DSN'. Either enter the name - if you know it - or by using the selection list (F4). Tip: If you are using Microsoft SQL Server and you are testing on the same machine as the MS SQL Server instance is running and you are using SQLEXPRESS you can enter e.g. '.\SQLEXPRESS'. That will mean use the SQLEXPRESS instance of Microsoft SQL Server running on this machine. If you press [F4] and the selection list comes up empty for Microsoft SQL Server it probably is because the service hasn't been started. Type 'Services' in Windows menu system to start Windows Services app. Type 'SQL' to jump to the SQL Server services. Check that the 'SQL Server Browser' service is started and set to 'Automatic'."
95932>>>>>            Set piItem to 5
95933>>>>>            Set peAnchors to anTopLeftRight
95934>>>>>
95934>>>>>            Property Handle phoPromptObject (oServerSelection_sl(Self))
95936>>>>>
95936>>>>>            Procedure Prompt
95939>>>>>                String sDriverID sValue
95939>>>>>                String[] sTheData
95940>>>>>                Integer iDbType iODBCType iRadio iPos
95940>>>>>                Handle ho
95940>>>>>
95940>>>>>                Get Prompt_Object to ho
95941>>>>>                If (ho = 0) Begin
95943>>>>>                    Procedure_Return
95944>>>>>                End
95944>>>>>>
95944>>>>>
95944>>>>>                Set Label of oShowInfo_tb to CS_LoadingServers
95945>>>>>                Send Cursor_Wait of Cursor_Control
95946>>>>>                Get SelectedDbType of oDbType_cf to iDbType
95947>>>>>                Get Value of oDriverID_cf to sDriverID
95948>>>>>                Move (Trim(sDriverID)) to sDriverID
95949>>>>>                Get Current_Radio of oODBC_rgp to iRadio
95950>>>>>                If (iRadio = 0) Begin
95952>>>>>                    Move SQL_FETCH_USER   to iODBCType
95953>>>>>                End
95953>>>>>>
95953>>>>>                If (iRadio = 1) Begin
95955>>>>>                    Move SQL_FETCH_SYSTEM to iODBCType
95956>>>>>                End
95956>>>>>>
95956>>>>>                If (iRadio = 2) Begin
95958>>>>>                    Move SQL_FETCH_ALL    to iODBCType
95959>>>>>                End
95959>>>>>>
95959>>>>>
95959>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
95960>>>>>                Load_Driver sDriverID
95961>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
95962>>>>>                If (LastErr = DFERR_CANT_LOAD_DLL) Begin
95964>>>>>                    Send Cursor_Ready of Cursor_Control
95965>>>>>                    Send Info_Box ("Can't display any items because the database driver could not be loaded. (" + sDriverID + ")")
95966>>>>>                    Procedure_Return
95967>>>>>                End
95967>>>>>>
95967>>>>>
95967>>>>>                Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID iODBCType to sTheData
95968>>>>>                Set psTheData  of ho to sTheData
95969>>>>>                Set Label of oShowInfo_tb to ""
95970>>>>>
95970>>>>>                Forward Send Prompt
95972>>>>>
95972>>>>>                // The selection list will show the ODBC DataSource name + a comma (,) + a description.
95972>>>>>                // We need to remove those parts from the comma and to the end of string.
95972>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
95974>>>>>                    Get Value to sValue
95975>>>>>                    Move (Pos(",", sValue)) to iPos
95976>>>>>                    Move (Left(sValue, (iPos - 1))) to sValue
95977>>>>>                    Set Value to sValue
95978>>>>>                End
95978>>>>>>
95978>>>>>            End_Procedure
95979>>>>>
95979>>>>>            Procedure OnChange
95982>>>>>                tSQLIntTableInfo[] sReturnStructArray
95982>>>>>                tSQLIntTableInfo[] sReturnStructArray
95983>>>>>                String sServer sDatabaseName sVal sDriverID
95983>>>>>                Integer iSize iCount iPos 
95983>>>>>                Boolean bFileDSN
95983>>>>>                
95983>>>>>                Move False to bFileDSN
95984>>>>>                Get Value of oDriverID_cf to sDriverID
95985>>>>>                If (sDriverID = "") Begin
95987>>>>>                    Procedure_Return
95988>>>>>                End
95988>>>>>>
95988>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
95990>>>>>                    Move "" to sDatabaseName
95991>>>>>                    Get Value to sServer 
95992>>>>>                    Move (Pos(",", sServer)) to iPos
95993>>>>>                    If (iPos <> 0) Begin
95995>>>>>                        Move (Left(sServer, (iPos -1))) to sServer
95996>>>>>                    End
95996>>>>>>
95996>>>>>                    If (sServer <> "") Begin
95998>>>>>                        Set psServer of ghoDbUpdateFunctionLibrary to sServer
95999>>>>>                    End
95999>>>>>>
95999>>>>>                    Get _SqlDatabasesArrayODBC of ghoDbUpdateFunctionLibrary to sReturnStructArray
96000>>>>>                    If (SizeOfArray(sReturnStructArray)) Begin
96002>>>>>                        If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
96004>>>>>                            // If a FILEDSN: (can only be one database name)
96004>>>>>                            Move sReturnStructArray[0].sDatabaseName to sDatabaseName
96005>>>>>                            Move True to bFileDSN
96006>>>>>                        End
96006>>>>>>
96006>>>>>                        Else Begin
96007>>>>>                            // Else the DSN's were read from the registry.
96007>>>>>                            Move (SizeOfArray(sReturnStructArray)) to iSize
96008>>>>>                            Decrement iSize
96009>>>>>                            For iCount from 0 to iSize
96015>>>>>>
96015>>>>>                                Move (sReturnStructArray[iCount].sServerName) to sVal
96016>>>>>                                If (Uppercase(sServer) = Uppercase(sVal)) Begin
96018>>>>>                                    Move sReturnStructArray[iCount].sDatabaseName to sDatabaseName
96019>>>>>                                    Move iSize to iCount // We're done.
96020>>>>>                                End
96020>>>>>>
96020>>>>>                            Loop
96021>>>>>>
96021>>>>>                        End
96021>>>>>>
96021>>>>>                    End
96021>>>>>>
96021>>>>>                    Set Value of oDatabase_fm to sDatabaseName
96022>>>>>                    If (bFileDSN = True) Begin
96024>>>>>                        Set Current_Radio of oODBC_rgp to 3
96025>>>>>                    End    
96025>>>>>>
96025>>>>>                    Else Begin
96026>>>>>                        Set Current_Radio of oODBC_rgp to 2
96027>>>>>                    End
96027>>>>>>
96027>>>>>                End
96027>>>>>>
96027>>>>>
96027>>>>>            End_Procedure
96028>>>>>
96028>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96031>>>>>                String sLabel
96031>>>>>                Handle ho
96031>>>>>
96031>>>>>                Get phoPromptObject to ho
96032>>>>>                Set Prompt_Button_Mode to PB_PromptOn
96033>>>>>                Case Begin
96033>>>>>                    Case (iDbType = EN_dbTypeDB2)
96035>>>>>                        Move "DSN" to sLabel
96036>>>>>                        Case Break
96037>>>>>                    Case (iDbType = EN_dbTypeMSSQL)
96040>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
96042>>>>>                            Move "ODBC Data Source" to sLabel
96043>>>>>                        End
96043>>>>>>
96043>>>>>                        Else Begin
96044>>>>>                            Move "Server" to sLabel
96045>>>>>                        End
96045>>>>>>
96045>>>>>                        Case Break
96046>>>>>                    Case (iDbType = EN_dbTypeMySQL)
96049>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
96051>>>>>                            Move "ODBC Data Source" to sLabel
96052>>>>>                        End
96052>>>>>>
96052>>>>>                        Else Begin
96053>>>>>                            Move "DSN" to sLabel
96054>>>>>                        End
96054>>>>>>
96054>>>>>                        Case Break
96055>>>>>                    Case (iDbType = EN_dbTypeOracle)
96058>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
96060>>>>>                            Move "ODBC Data Source" to sLabel
96061>>>>>                        End
96061>>>>>>
96061>>>>>                        Else Begin
96062>>>>>                            Move "Server" to sLabel
96063>>>>>                        End
96063>>>>>>
96063>>>>>                        Case Break
96064>>>>>                    Case (iDbType = EN_dbTypePostgre)
96067>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
96069>>>>>                            Move "ODBC Data Source" to sLabel
96070>>>>>                        End
96070>>>>>>
96070>>>>>                        Else Begin
96071>>>>>                            Move "Server" to sLabel
96072>>>>>                        End
96072>>>>>>
96072>>>>>                        Case Break
96073>>>>>                    Case Else
96073>>>>>                Case End
96073>>>>>
96073>>>>>                Set Prompt_Object to ho
96074>>>>>                Set Label to sLabel
96075>>>>>            End_Procedure
96076>>>>>
96076>>>>>        End_Object
96077>>>>>
96077>>>>>        Object oSilentLogin_fm is a cSQLCheckBox
96079>>>>>            Set Size to 10 48
96080>>>>>            Set Location to 76 210
96081>>>>>            Set Label to "Silent Login"
96082>>>>>            Set psToolTip to "Silent login to database is to not show error if login was unsuccessive."
96083>>>>>            Set peAnchors to anTopRight
96084>>>>>            Set piItem to 15
96085>>>>>        End_Object
96086>>>>>
96086>>>>>        Object oTrusted_cb is a cSQLCheckbox
96088>>>>>            Set Size to 12 85
96089>>>>>            Set Location to 91 82
96090>>>>>            Set Label to "Use Trusted Connection"
96091>>>>>            Set psToolTip to "(Windows Authentication) When selected, SQL Server uses integrated login (Windows login information) security to establish connections using this data source, regardless of the current login security mode at the server."
96092>>>>>            Set piItem to 8
96093>>>>>
96093>>>>>            Procedure OnChange
96096>>>>>                Boolean bChecked
96096>>>>>                Get Checked_State to bChecked
96097>>>>>                Set Enabled_State of oUserID_fm   to (bChecked = False)
96098>>>>>                Set Enabled_State of oPassword_fm to (bChecked = False)
96099>>>>>                Set Enabled_State of oViewPassword_btn to (bChecked = False)
96100>>>>>            End_Procedure
96101>>>>>
96101>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96104>>>>>                Boolean bChecked
96104>>>>>
96104>>>>>                Get Checked_State to bChecked
96105>>>>>                If (iDbType <> EN_dbTypeMSSQL) Begin
96107>>>>>                    Set Enabled_State to (iDbType = EN_dbTypeMSSQL)
96108>>>>>                    If (bChecked = True) Begin
96110>>>>>                        Set Checked_State to False
96111>>>>>                    End
96111>>>>>>
96111>>>>>                End
96111>>>>>>
96111>>>>>                Else Begin
96112>>>>>                    Set Enabled_State to True
96113>>>>>                End
96113>>>>>>
96113>>>>>
96113>>>>>                Send OnChange
96114>>>>>            End_Procedure
96115>>>>>
96115>>>>>        End_Object
96116>>>>>
96116>>>>>        Object oUserID_fm is a cSQLForm
96118>>>>>            Set Size to 13 114
96119>>>>>            Set Location to 103 82
96120>>>>>            Set Label to "User ID"
96121>>>>>            Set psToolTip to "Enter the user name to use for authentication when you log on to the database."
96122>>>>>            Set piItem to 9
96123>>>>>            Set peAnchors to anTopLeftRight
96124>>>>>        End_Object
96125>>>>>
96125>>>>>        Object oPassword_fm is a cSQLForm
96127>>>>>            Set Size to 13 61
96128>>>>>            Set Location to 103 210
96129>>>>>            Set Label to "Password"
96130>>>>>            Set psToolTip to "Enter the password for your user name. The password will automatically be encrypted & decrypted when writing/reading from the ini file. Of Special Note: If the cConnection class is used with DataFlex 19 or later and such an .ini file is edited with this program you will get a question if you would like the program to 'touch' the password or not. If you answer No, the ini-file will keep working with the DataFlex tools. You should probably never try to change the password with this program for a DFConnid.ini file as the two programs uses different encryption/decryption algorithms."
96131>>>>>            Set piItem to 10
96132>>>>>            Set Password_State to True
96133>>>>>            Set peAnchors to anTopRight
96134>>>>>            Set Label_Col_Offset to 0
96135>>>>>            Set Label_Justification_Mode to JMode_Top
96136>>>>>        End_Object
96137>>>>>
96137>>>>>        Object oShowInfo_tb is a TextBox
96139>>>>>            Set Auto_Size_State to False
96140>>>>>            Set Size to 10 114
96141>>>>>            Set Location to 119 82
96142>>>>>            Set TextColor to clGreen
96143>>>>>            Set Justification_Mode to JMode_Center
96144>>>>>            Set peAnchors to anTopRight
96145>>>>>        End_Object
96146>>>>>
96146>>>>>        Object oViewPassword_btn is a cRDCButton
96148>>>>>            Set Size to 13 15
96149>>>>>            Set Location to 103 273
96150>>>>>            Set psToolTip to "View/hide password"
96151>>>>>            Set psImage to "ViewPassword1.ico"
96152>>>>>            Set piImageMarginLeft to 2
96153>>>>>            Set peAnchors to anTopRight
96154>>>>>
96154>>>>>            Procedure OnClick
96157>>>>>                Handle ho
96157>>>>>                Boolean bState
96157>>>>>
96157>>>>>                Move (oPassword_fm(Self)) to ho
96158>>>>>                Get Password_State of ho 0 to bState
96159>>>>>                Send Deactivate of ho
96160>>>>>                Set Password_State of ho to (not(bState))
96161>>>>>                // Finally we need to re-add the object to the focus tree or it will be invisible.
96161>>>>>                Send Activate of ho (Parent(Self))
96162>>>>>            End_Procedure
96163>>>>>
96163>>>>>        End_Object
96164>>>>>
96164>>>>>        Object oCheckLogin_btn is a cRDCButton
96166>>>>>            Set Size to 13 78
96167>>>>>            Set Location to 119 210
96168>>>>>            Set Label to "Check &Login"
96169>>>>>            Set psImage to "ActionLogin1.ico"
96170>>>>>            Set psToolTip to "You should always use this button when adding a new SQL Connection to ensure that the entered credentials are correct. (Ctrl+L)"
96171>>>>>            Set piImageMarginLeft to 3
96172>>>>>            Set peAnchors to anTopRight
96173>>>>>
96173>>>>>            Procedure OnClick
96176>>>>>                String sConnectionString sDriverID sError
96176>>>>>                Boolean bLoginSuccessful 
96176>>>>>                Integer iDriverID
96176>>>>>                Handle hoErrorObj
96176>>>>>
96176>>>>>                Send Cursor_Wait of Cursor_Control // Note: The Cursor_Wait changes the Err flag!
96177>>>>>                Move Error_Object_Id to hoErrorObj
96178>>>>>                Move Self to Error_Object_Id
96179>>>>>                Move False to Err
96180>>>>>
96180>>>>>                Set Value of oLoginInfo_tb to CS_LoginAttempt
96181>>>>>                Send PumpMsgQueue
96182>>>>>                
96182>>>>>                Get Value of oDriverID_cf to sDriverID
96183>>>>>                Move "" to sError
96184>>>>>                Get LoginString (&sError) to sConnectionString
96185>>>>>                If (sError <> "") Begin
96187>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
96188>>>>>                    Send Info_Box sError
96189>>>>>                    Procedure_Return
96190>>>>>                End
96190>>>>>>
96190>>>>>                
96190>>>>>                Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriverID
96191>>>>>                If (iDriverID = 0) Begin
96193>>>>>                    Set TextColor of oLoginInfo_tb to clRed
96194>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
96195>>>>>                    Send Info_Box ("The driver" * sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
96196>>>>>                    Procedure_Return
96197>>>>>                End
96197>>>>>>
96197>>>>>
96197>>>>>                Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
96200>>>>>
96200>>>>>                Move False to Err
96201>>>>>                Send CreateConnParamsFromConnectionString of ghoSQLConnectionHandler sDriverID sConnectionString
96202>>>>>
96202>>>>>                Move (Err = False) to bLoginSuccessful
96203>>>>>                If bLoginSuccessful Begin
96205>>>>>                    Set TextColor of oLoginInfo_tb to clGreen
96206>>>>>                    Set Value of oLoginInfo_tb to CS_LoginSuccessful 
96207>>>>>                    Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
96208>>>>>                    Set psConnectionString of ghoDbUpdateFunctionLibrary to sConnectionString
96209>>>>>                End
96209>>>>>>
96209>>>>>                Else Begin
96210>>>>>                    Set TextColor of oLoginInfo_tb to clRed
96211>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
96212>>>>>                End
96212>>>>>>
96212>>>>>
96212>>>>>                Move hoErrorObj to Error_Object_Id
96213>>>>>                Send Cursor_Ready of Cursor_Control
96214>>>>>            End_Procedure
96215>>>>>
96215>>>>>            // This method is here simply to intercept any error that may occur while logging in
96215>>>>>            // it does not have to do anything with the error, but it suppresses the normal error display
96215>>>>>            Procedure Error_Report Integer iErrNum Integer iErrLine String sErrMsg
96218>>>>>                If (LastErr = 25000) Begin
96220>>>>>                    If (Trim(sErrMsg) <> "") Begin
96222>>>>>                        Send Info_Box sErrMsg
96223>>>>>                    End
96223>>>>>>
96223>>>>>                End  
96223>>>>>>
96223>>>>>            End_Procedure   
96224>>>>>            
96224>>>>>        End_Object
96225>>>>>
96225>>>>>        Object oIndexTableSpace_fm is a cSQLForm
96227>>>>>            Set Size to 13 114
96228>>>>>            Set Location to 133 82
96229>>>>>            Set Label to "Index Table Space"
96230>>>>>            Set piItem to 14
96231>>>>>            Set psToolTip to "To set the name of the table space where indexes will be stored. Only applicable for IBM DB2, Oracle and PostgreSQL databases."
96232>>>>>            Set Prompt_Button_Mode to PB_PromptOn
96233>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
96234>>>>>            Set peAnchors to anTopLeftRight
96235>>>>>
96235>>>>>            Procedure Prompt
96238>>>>>                String[] sTheData
96239>>>>>                Handle ho
96239>>>>>                tSQLConnection SQLConnection
96239>>>>>                tSQLConnection SQLConnection
96239>>>>>
96239>>>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
96240>>>>>                Get ReadCurrentSQLSettings to SQLConnection
96241>>>>>
96241>>>>>                Get _SqlUtilEnumerateTablespaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
96242>>>>>
96242>>>>>                Get Prompt_Object to ho
96243>>>>>                Set psTheData     of ho to sTheData
96244>>>>>                Set Label of oShowInfo_tb to ""
96245>>>>>
96245>>>>>                Forward Send Prompt
96247>>>>>            End_Procedure
96248>>>>>
96248>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96251>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
96252>>>>>            End_Procedure
96253>>>>>
96253>>>>>        End_Object
96254>>>>>
96254>>>>>        Object oLoginInfo_tb is a TextBox
96256>>>>>            Set Auto_Size_State to False
96257>>>>>            Set Size to 9 78
96258>>>>>            Set Location to 135 210
96259>>>>>            Set TextColor to clGreen
96260>>>>>            Set peAnchors to anTopRight
96261>>>>>            Set Justification_Mode to JMode_Left
96262>>>>>        End_Object
96263>>>>>
96263>>>>>        Object oBaseTableSpace_fm is a cSQLForm
96265>>>>>            Set Size to 13 114
96266>>>>>            Set Location to 148 82
96267>>>>>            Set Label to "Table Space"
96268>>>>>            Set piItem to 12
96269>>>>>            Set psToolTip to "Sets the name of the table space where the data will be stored. Applicable for IBM DB2, Oracle and PostgreSQL databases. Table spaces allow you to assign a physical location to logical objects (tables). They can be used to improve performance or to increase the page size, thus increasing the maximum size of a record that can be stored in the table space. You can specify what table space must be used to store table, index or long data. The index and long data table space will only be set when the table tables pace is also set."
96270>>>>>            Set Prompt_Button_Mode to PB_PromptOn
96271>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
96272>>>>>            Set peAnchors to anTopLeftRight
96273>>>>>
96273>>>>>            Procedure Prompt
96276>>>>>                String[] sTheData
96277>>>>>                Handle ho
96277>>>>>                tSQLConnection SQLConnection
96277>>>>>                tSQLConnection SQLConnection
96277>>>>>
96277>>>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
96278>>>>>                Get ReadCurrentSQLSettings to SQLConnection
96279>>>>>                Get _SqlUtilEnumerateTablespaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
96280>>>>>
96280>>>>>                Get Prompt_Object to ho
96281>>>>>                Set psTheData  of ho to sTheData
96282>>>>>                Set Label of oShowInfo_tb to ""
96283>>>>>
96283>>>>>                Forward Send Prompt
96285>>>>>            End_Procedure
96286>>>>>
96286>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96289>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
96290>>>>>            End_Procedure
96291>>>>>
96291>>>>>        End_Object
96292>>>>>
96292>>>>>        Object oLongTableSpace_fm is a cSQLForm
96294>>>>>            Set Size to 13 114
96295>>>>>            Set Location to 163 82
96296>>>>>            Set Label to "Long Table Space"
96297>>>>>            Set piItem to 13
96298>>>>>            Set psToolTip to "Only applicable for IBM DB2 databases. If you are unsure on what to enter your best bet is to use the same value as for the 'Table Space' above."
96299>>>>>            Set Prompt_Button_Mode to PB_PromptOn
96300>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
96301>>>>>            Set peAnchors to anTopLeftRight
96302>>>>>
96302>>>>>            Procedure Prompt
96305>>>>>                String[] sTheData
96306>>>>>                Handle ho
96306>>>>>                tSQLConnection SQLConnection
96306>>>>>                tSQLConnection SQLConnection
96306>>>>>
96306>>>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
96307>>>>>                Get ReadCurrentSQLSettings to SQLConnection
96308>>>>>
96308>>>>>                Get _SqlUtilEnumerateTablespaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
96309>>>>>
96309>>>>>                Get Prompt_Object to ho
96310>>>>>                Set psTheData     of ho to sTheData
96311>>>>>                Set Label of oShowInfo_tb to ""
96312>>>>>
96312>>>>>                Forward Send Prompt
96314>>>>>            End_Procedure
96315>>>>>
96315>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96318>>>>>                Set Enabled_State to (iDbType = EN_dbTypeDB2)
96319>>>>>            End_Procedure
96320>>>>>
96320>>>>>        End_Object
96321>>>>>
96321>>>>>        Object oSchema_fm is a cSQLForm
96323>>>>>            Set Size to 13 78
96324>>>>>            Set Location to 163 210
96325>>>>>            Set Label to "Schema"
96326>>>>>            Set psToolTip to "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult your database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
96327>>>>>            Set piItem to 11
96328>>>>>            Set Enabled_State to False
96329>>>>>
96329>>>>>            Property String psSchemaToolTip "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult a database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
96331>>>>>            Property String psOwnerTooltip  "The owner name to use within the database where the tables must be placed. If you want to specify an owner of the table that will be converted you can do so, not specifying an owner will result in the default owner being used. The suggested owner name to use is 'dbo'"
96333>>>>>
96333>>>>>            Set peAnchors to anTopRight
96334>>>>>            Set Label_Justification_Mode to JMode_Top
96335>>>>>            Set Label_Col_Offset to 0
96336>>>>>
96336>>>>>            Procedure Prompt
96339>>>>>                String[] sTheData
96340>>>>>                Handle ho
96340>>>>>                tSQLConnection SQLConnection
96340>>>>>                tSQLConnection SQLConnection
96340>>>>>
96340>>>>>                Set Label of oShowInfo_tb to CS_LoadingSchemas
96341>>>>>                Get ReadCurrentSQLSettings to SQLConnection
96342>>>>>
96342>>>>>                Get SqlUtilEnumerateSchemas of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
96343>>>>>
96343>>>>>                Get Prompt_Object to ho
96344>>>>>                Set psTheData     of ho to sTheData
96345>>>>>                Set Label of oShowInfo_tb to ""
96346>>>>>
96346>>>>>                Forward Send Prompt
96348>>>>>            End_Procedure
96349>>>>>
96349>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96352>>>>>                String sValue
96352>>>>>
96352>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeMSSQL or iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
96353>>>>>                If (iDbType = EN_dbTypeMSSQL) Begin
96355>>>>>                    Set Label to CS_DF_File_Owner
96356>>>>>                    Set Prompt_Button_Mode to PB_PromptOff
96357>>>>>                    Set Prompt_Object to 0
96358>>>>>                    Set psToolTip to (psOwnerTooltip(Self))
96359>>>>>                    Get Value to sValue
96360>>>>>                    If (Trim(sValue) = "") Begin
96362>>>>>                        Set Value to "dbo"
96363>>>>>                    End
96363>>>>>>
96363>>>>>                End
96363>>>>>>
96363>>>>>                Else Begin
96364>>>>>                    Set Label to CS_DF_File_Schema
96365>>>>>                    Set Prompt_Button_Mode to PB_PromptOn
96366>>>>>                    Set Prompt_Object to (oSchemasSelection_sl(Self))
96367>>>>>                    Set psToolTip to (psSchemaToolTip(Self))
96368>>>>>                    If (Trim(sValue) = "dbo") Begin
96370>>>>>                        Set Value to ""
96371>>>>>                    End
96371>>>>>>
96371>>>>>                End
96371>>>>>>
96371>>>>>                If (Enabled_State(Self) = False) Begin
96373>>>>>                    Set Value to ""
96374>>>>>                End
96374>>>>>>
96374>>>>>            End_Procedure
96375>>>>>
96375>>>>>        End_Object
96376>>>>>
96376>>>>>        Object oDatabase_fm is a cSQLForm
96378>>>>>            Set Size to 13 114
96379>>>>>            Set Location to 178 82
96380>>>>>            Set Label to "Database"
96381>>>>>            Set peAnchors to anTopLeftRight
96382>>>>>            Set psToolTip to "Name of the SQL database. Note: If you are setting up your first connection for a workspace and your SQL database doesn't exist yet, leave the default 'Master' as it is always available. The 'SqlDatabaseCreate' function will take care of the rest when creating your new SQL database."
96383>>>>>            Set piItem to 6
96384>>>>>            Set Prompt_Button_Mode to PB_PromptOn
96385>>>>>
96385>>>>>            Procedure Prompt
96388>>>>>                String[] sTheData
96389>>>>>                Handle ho
96389>>>>>                tSQLConnection SQLConnection
96389>>>>>                tSQLConnection SQLConnection
96389>>>>>
96389>>>>>                Set Label of oShowInfo_tb to CS_LoadingDatabases
96390>>>>>                Get ReadCurrentSQLSettings to SQLConnection
96391>>>>>
96391>>>>>                Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID to sTheData
96392>>>>>
96392>>>>>                Get Prompt_Object to ho
96393>>>>>                Set psTheData     of ho to sTheData
96394>>>>>                Set Label of oShowInfo_tb to ""
96395>>>>>
96395>>>>>                Forward Send Prompt
96397>>>>>            End_Procedure
96398>>>>>
96398>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96401>>>>>                Boolean bAdd
96401>>>>>                String sValue
96401>>>>>
96401>>>>>                If (sDriverID <> "") Begin
96403>>>>>                    Set Enabled_State to (sDriverID = MSSQLDRV_ID or (sDriverID = ODBC_DRV_ID and iDbType <> EN_DbTypeOracle))
96404>>>>>                    If (Enabled_State(Self) = True) Begin
96406>>>>>                        Move (piCurrentRow(Self) = -1) to bAdd
96407>>>>>                        Get Value to sValue
96408>>>>>                        If (bAdd = True and sValue = "" and iDbType = EN_dbTypeMSSQL) Begin
96410>>>>>                            Set Value to "master"
96411>>>>>                        End
96411>>>>>>
96411>>>>>                        Else Begin
96412>>>>>                            Set Prompt_Button_Mode to PB_PromptOn
96413>>>>>                            Set Prompt_Object to (oDatabaseSelection_sl(Self))
96414>>>>>                            If (Value(Self) = "master") Begin
96416>>>>>                                Set Value to ""
96417>>>>>                            End
96417>>>>>>
96417>>>>>                        End
96417>>>>>>
96417>>>>>                    End
96417>>>>>>
96417>>>>>                    If (Enabled_State(Self) = False) Begin
96419>>>>>                        Set Value to ""
96420>>>>>                    End
96420>>>>>>
96420>>>>>                End
96420>>>>>>
96420>>>>>            End_Procedure
96421>>>>>
96421>>>>>        End_Object
96422>>>>>
96422>>>>>        Object oCreateDatabase_btn is a cRDCButton
96424>>>>>            Set Size to 13 78
96425>>>>>            Set Location to 178 210
96426>>>>>            Set Label to "Create Database..."
96427>>>>>            Set psImage to "ActionCreateDatabase1.ico"
96428>>>>>            Set pbAutoEnable to True
96429>>>>>            Set peAnchors to anTopRight
96430>>>>>        
96430>>>>>            Procedure OnClick                                                              
96433>>>>>                String sConnectionString sError sDriverID sLoginText sDatabaseName
96433>>>>>                
96433>>>>>                Get LoginString (&sError) to sConnectionString
96434>>>>>                If (sError <> "") Begin
96436>>>>>                    Send Info_Box sError
96437>>>>>                    Procedure_Return
96438>>>>>                End                         
96438>>>>>>
96438>>>>>                
96438>>>>>                Get Value of oDriverID_cf to sDriverID
96439>>>>>                Get Create_DataBase_Dialog of (Client_Id(phoMainPanel(ghoApplication))) sDriverID to sDatabaseName
96440>>>>>                If (sDatabaseName <> "") Begin
96442>>>>>                    Set Value of oDatabase_fm to sDatabaseName
96443>>>>>                End
96443>>>>>>
96443>>>>>            End_Procedure                
96444>>>>>            
96444>>>>>            Function IsEnabled Returns Boolean
96447>>>>>                Integer iDbType    
96447>>>>>                Boolean bReadOnly
96447>>>>>                Get SelectedDbType of oDbType_cf to iDbType
96448>>>>>                Get pbReadOnly to bReadOnly
96449>>>>>                Function_Return (bReadOnly = False and (iDbType = EN_DbTypeMSSQL or iDbType = EN_DbTypeDB2 or iDbType = EN_DbTypeMySQL or iDbType = EN_DbTypePostgre))
96450>>>>>            End_Function
96451>>>>>        
96451>>>>>        End_Object
96452>>>>>
96452>>>>>        Procedure DbTypeUpdate Integer iDbType String sDriverID
96455>>>>>            String sDbType
96455>>>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sDbType
96456>>>>>            Set Label to (sDbType * "Connection Details")
96457>>>>>        End_Procedure
96458>>>>>
96458>>>>>    End_Object
96459>>>>>
96459>>>>>    Object oOK_Btn is a cRDCButton
96461>>>>>        Set Label    to C_$OK
96462>>>>>        Set Location to 287 208 //281 208
96463>>>>>        Set peAnchors to anBottomRight
96464>>>>>
96464>>>>>        Procedure OnClick
96467>>>>>            String sLoginText
96467>>>>>            String[] sConnectionData
96468>>>>>            tSQLConnection SQLIniFileConnection
96468>>>>>            tSQLConnection SQLIniFileConnection
96468>>>>>            Boolean bNew bOK bShouldSave
96468>>>>>            Integer iRetval
96468>>>>>
96468>>>>>            Delegate Get Should_Save to bShouldSave
96470>>>>>            If (bShouldSave = False) Begin
96472>>>>>                Set pbChanged to False
96473>>>>>                Send Close_Panel
96474>>>>>                Procedure_Return
96475>>>>>            End
96475>>>>>>
96475>>>>>
96475>>>>>            Broadcast Recursive Send WriteConnectionData of (Parent(Self)) (&sConnectionData)
96477>>>>>
96477>>>>>            Get pbNew to bNew
96478>>>>>            Get MoveStringArrayToSQLConnection sConnectionData to SQLIniFileConnection
96479>>>>>            Case Begin
96479>>>>>                Case (SQLIniFileConnection.sDriverID = DB2_DRV_ID or SQLIniFileConnection.sDriverID = ODBC_DRV_ID)
96481>>>>>                    If (SQLIniFileConnection.sDriverID = DB2_DRV_ID) Begin
96483>>>>>                        Move "" to SQLIniFileConnection.sDatabase
96484>>>>>                    End
96484>>>>>>
96484>>>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
96486>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
96488>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "") to bOK
96489>>>>>                        End
96489>>>>>>
96489>>>>>                        Else Begin
96490>>>>>                            Move (SQLIniFileConnection.sServer <> "") to bOK
96491>>>>>                        End
96491>>>>>>
96491>>>>>                    End
96491>>>>>>
96491>>>>>                    Else Begin
96492>>>>>                        // It should probably be allowed to use an UID but no password...
96492>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
96494>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
96495>>>>>                        End
96495>>>>>>
96495>>>>>                        Else Begin
96496>>>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
96497>>>>>                        End
96497>>>>>>
96497>>>>>                    End
96497>>>>>>
96497>>>>>                    Case Break
96498>>>>>                Case (SQLIniFileConnection.sDriverID = MSSQLDRV_ID)
96501>>>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
96503>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
96505>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
96506>>>>>                        End
96506>>>>>>
96506>>>>>                        Else Begin
96507>>>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
96508>>>>>                        End
96508>>>>>>
96508>>>>>                    End
96508>>>>>>
96508>>>>>                    Else Begin
96509>>>>>                        // It should probably be allowed to use an UID but no password...
96509>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
96511>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
96512>>>>>                        End
96512>>>>>>
96512>>>>>                        Else Begin
96513>>>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
96514>>>>>                        End
96514>>>>>>
96514>>>>>                    End
96514>>>>>>
96514>>>>>                    Case Break
96515>>>>>            Case End
96515>>>>>
96515>>>>>            If (bOK = False) Begin
96517>>>>>                Send Info_Box "Please fill in all connection data."
96518>>>>>                Procedure_Return
96519>>>>>            End
96519>>>>>>
96519>>>>>
96519>>>>>            Move MBR_Yes to iRetval
96520>>>>>            Get Label of oLoginInfo_tb to sLoginText
96521>>>>>            If (sLoginText = CS_LoginFailed) Begin
96523>>>>>                Get YesNo_Box "The login failed. Are you sure you want to use these connection settings?" to iRetval
96524>>>>>            End
96524>>>>>>
96524>>>>>            Else If (sLoginText = "") Begin
96527>>>>>                Get YesNo_Box "The login has not been tested. Are you sure you want to use these connection settings?" to iRetval
96528>>>>>            End
96528>>>>>>
96528>>>>>            If (iRetval <> MBR_Yes) Begin
96530>>>>>                Procedure_Return
96531>>>>>            End
96531>>>>>>
96531>>>>>
96531>>>>>            Set pSQLConnectionData to SQLIniFileConnection
96532>>>>>            Set pbChanged to True
96533>>>>>            Send Close_Panel
96534>>>>>        End_Procedure
96535>>>>>
96535>>>>>    End_Object
96536>>>>>
96536>>>>>    Object oCancel_Btn is a cRDCButton
96538>>>>>        Set Label    to C_$Cancel
96539>>>>>        Set Location to 287 264 //281 264
96540>>>>>        Set peAnchors to anBottomRight
96541>>>>>
96541>>>>>        Procedure OnClick
96544>>>>>            Set pbChanged to False
96545>>>>>            Send Close_Panel
96546>>>>>        End_Procedure
96547>>>>>
96547>>>>>    End_Object
96548>>>>>
96548>>>>>    Object oHelp_Btn is a cRDCButton
96550>>>>>        Set Label to C_$Help
96551>>>>>        Set Location to 287 11 //281 11
96552>>>>>        Set peAnchors to anBottomLeft
96553>>>>>        Set psImage to "ActionHelp1.ico"
96554>>>>>
96554>>>>>        Procedure OnClick
96557>>>>>            Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
96558>>>>>        End_Procedure
96559>>>>>    End_Object
96560>>>>>
96560>>>>>    Object oConnectionType_grp is a cRDCHeaderGroup
96562>>>>>        Set Size to 60 303
96563>>>>>        Set Location to 8 11 //2 11
96564>>>>>        Set psImage to "SQLSettings1.ico"
96565>>>>>        Set psLabel to "Database Type Settings"
96566>>>>>
96566>>>>>        Object oDbType_cf is a cSQLComboForm
96568>>>>>            Set Size to 13 115
96569>>>>>            Set Location to 22 82
96570>>>>>            Set Label to "Database Type"
96571>>>>>            Set Entry_State to False
96572>>>>>            Set Combo_Sort_State to False
96573>>>>>            Set psToolTip to "Select a database type, then select a driver to use for the database"
96574>>>>>            Set piItem to 3
96575>>>>>            
96575>>>>>            Procedure Combo_Fill_List
96578>>>>>                Send Combo_Add_Item CS_dbTypeMSSQL
96579>>>>>                Send Combo_Add_Item CS_dbTypeMySQL
96580>>>>>                Send Combo_Add_Item CS_dbTypeOracle
96581>>>>>                Send Combo_Add_Item CS_dbTypeDB2
96582>>>>>                Send Combo_Add_Item CS_dbTypePostgre
96583>>>>>            End_Procedure
96584>>>>>
96584>>>>>            Procedure OnChange
96587>>>>>                Integer iDbType
96587>>>>>                String sDriverID
96587>>>>>    
96587>>>>>                Get SelectedDbType to iDbType
96588>>>>>                Send Refill_Comboform of oDriverID_cf iDbType
96589>>>>>                Get Value of oDriverID_cf to sDriverID
96590>>>>>                If (sDriverID = "") Begin
96592>>>>>                    Move MSSQLDRV_ID to sDriverID
96593>>>>>                End
96593>>>>>>
96593>>>>>                Send DbTypeUpdate of oSettings_grp iDbType sDriverID
96594>>>>>            End_Procedure
96595>>>>>    
96595>>>>>            Function SelectedDbType Returns Integer
96598>>>>>                Integer iRetval
96598>>>>>                String sDbType
96598>>>>>    
96598>>>>>                Get Value to sDbType
96599>>>>>                Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sDbType to iRetval
96600>>>>>    
96600>>>>>                Function_Return iRetval
96601>>>>>            End_Function
96602>>>>>
96602>>>>>        End_Object
96603>>>>>
96603>>>>>// This used to work, but it seems that the Ssms.exe is no longer part of Windows "global pathing (in DOS)".
96603>>>>>//        Object oStartSQLManager_btn is a cRDCButton
96603>>>>>//            Set Size to 13 78
96603>>>>>//            Set Location to 22 210
96603>>>>>//            Set Label to "SQL Manager"
96603>>>>>//            Set pbAutoEnable to True  
96603>>>>>//            Set psImage to "SSMS1.ico" 
96603>>>>>//            Set psToolTip to "Start Microsoft SQL Server Management Studio"
96603>>>>>//            Set peAnchors to anTopRight
96603>>>>>//        
96603>>>>>//            Procedure OnClick
96603>>>>>//                Runprogram Shell Background "Ssms.exe"    
96603>>>>>//            End_Procedure  
96603>>>>>//            
96603>>>>>//            Function IsEnabled Returns Boolean
96603>>>>>//                String sDbType
96603>>>>>//                Get Value of oDbType_cf to sDbType
96603>>>>>//                Function_Return (sDbType = CS_dbTypeMSSQL)
96603>>>>>//            End_Function
96603>>>>>//        
96603>>>>>//        End_Object
96603>>>>>
96603>>>>>        Object oDriverID_cf is a cSQLComboForm
96605>>>>>            Set Size to 13 115
96606>>>>>            Set Location to 37 82
96607>>>>>            Set Label to "Driver ID"
96608>>>>>            Set Entry_State to False
96609>>>>>            Set Combo_Sort_State to False
96610>>>>>            Set psToolTip to "Depending on the database type selected the comboform list will vary."
96611>>>>>            Set piItem to 4
96612>>>>>
96612>>>>>            Procedure Refill_Comboform Integer iDbType
96615>>>>>                String sValue
96615>>>>>
96615>>>>>                Send Combo_Delete_Data
96616>>>>>                Send Combo_Add_Item MSSQLDRV_ID
96617>>>>>                Send Combo_Add_Item DB2_DRV_ID
96618>>>>>                Send Combo_Add_Item ODBC_DRV_ID
96619>>>>>                Send Combo_Add_Item DATAFLEX_ID
96620>>>>>
96620>>>>>                Case Begin
96620>>>>>                    Case (iDbType = EN_dbTypeMSSQL)
96622>>>>>                        Move MSSQLDRV_ID to sValue
96623>>>>>                        Case Break
96624>>>>>                    Case (iDbType = EN_dbTypeMySQL)
96627>>>>>                        Move ODBC_DRV_ID to sValue
96628>>>>>                        Case Break
96629>>>>>                    Case (iDbType = EN_dbTypeOracle)
96632>>>>>                        Move ODBC_DRV_ID to sValue
96633>>>>>                        Case Break
96634>>>>>                    Case (iDbType = EN_dbTypeDB2)
96637>>>>>                        Move DB2_DRV_ID to sValue
96638>>>>>                        Case Break
96639>>>>>                    Case (iDbType = EN_dbTypePostgre)
96642>>>>>                        Move ODBC_DRV_ID to sValue
96643>>>>>                        Case Break
96644>>>>>                    Case Else
96644>>>>>                        Move DATAFLEX_ID to sValue
96645>>>>>                Case End
96645>>>>>                Set Value to sValue
96646>>>>>            End_Procedure
96647>>>>>
96647>>>>>            Procedure OnChange
96650>>>>>                String sDriverID
96650>>>>>                Integer iDbType
96650>>>>>
96650>>>>>                Get Value to sDriverID
96651>>>>>                If (sDriverID = "") Begin
96653>>>>>//                    Move MSSQLDRV_ID to sDriverID 
96653>>>>>                    Procedure_Return
96654>>>>>                End
96654>>>>>>
96654>>>>>                Get SelectedDbType of oDbType_cf to iDbType
96655>>>>>                Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
96657>>>>>            End_Procedure
96658>>>>>
96658>>>>>        End_Object
96659>>>>>
96659>>>>>        Object oShowDriverSettings_btn is a cRDCButton
96661>>>>>            Set Size to 13 78
96662>>>>>            Set Location to 37 210
96663>>>>>            Set Label to "Driver Settings"
96664>>>>>            Set Status_Help to "Shows settings for the selected driver."
96665>>>>>            Set psImage to "DriverSettings1.ico"
96666>>>>>            Set peAnchors to anTopRight
96667>>>>>
96667>>>>>            Procedure OnClick
96670>>>>>                String sDriver sPath 
96670>>>>>                
96670>>>>>                Get Value of oDriverID_cf to sDriver
96671>>>>>                Send PopupDriverSettings sDriver 
96672>>>>>            End_Procedure
96673>>>>>    
96673>>>>>        End_Object
96674>>>>>
96674>>>>>    End_Object
96675>>>>>
96675>>>>>    Function ReadCurrentSQLSettings Returns tSQLConnection
96678>>>>>        tSQLConnection SQLConnection
96678>>>>>        tSQLConnection SQLConnection
96678>>>>>
96678>>>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
96679>>>>>        Get SelectedDbType of oDbType_cf to SQLConnection.iDbType
96680>>>>>
96680>>>>>        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
96681>>>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
96682>>>>>        Get Value of oServer_fm          to SQLConnection.sServer
96683>>>>>        Get Value of oUserID_fm          to SQLConnection.sUserID
96684>>>>>        Get Value of oPassword_fm        to SQLConnection.sPassword     
96685>>>>>        Move False to Err
96686>>>>>        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) ;            SQLConnection.sDriverID SQLConnection.sServer "" SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
96687>>>>>        Set pSQLConnection of ghoSQLConnectionHandler to SQLConnection
96688>>>>>        Move Err to SQLConnection.bError
96689>>>>>        
96689>>>>>        Function_Return SQLConnection
96690>>>>>    End_Function
96691>>>>>
96691>>>>>    Function LoginString String ByRef sError Returns String
96694>>>>>        String sDriverID sServer sDatabase
96694>>>>>        tSQLConnection SQLConnection
96694>>>>>        tSQLConnection SQLConnection
96694>>>>>        
96694>>>>>        Get Value of oDriverID_cf to sDriverID
96695>>>>>        If (sDriverID = "") Begin
96697>>>>>            Move "Please select a driver first, then try again." to sError
96698>>>>>            Function_Return ""
96699>>>>>        End
96699>>>>>>
96699>>>>>
96699>>>>>        Get Value of oServer_fm   to sServer
96700>>>>>        If (sServer = "") Begin
96702>>>>>            Move "Please select a server first, then try again." to sError
96703>>>>>            Function_Return ""
96704>>>>>        End
96704>>>>>>
96704>>>>>
96704>>>>>        Get Value of oDatabase_fm to sDatabase
96705>>>>>        If (sDatabase = "" and sDriverID = MSSQLDRV_ID) Begin
96707>>>>>            Move "master" to sDatabase
96708>>>>>        End
96708>>>>>>
96708>>>>>
96708>>>>>        Get ReadCurrentSQLSettings to SQLConnection
96709>>>>>        If (SQLConnection.bError = True) Begin
96711>>>>>            Move "Login Error" to sError
96712>>>>>        End
96712>>>>>>
96712>>>>>
96712>>>>>        Function_Return SQLConnection.sConnectionString
96713>>>>>    End_Function
96714>>>>>
96714>>>>>    // Returns True if anything has changed.
96714>>>>>    Function Should_Save Returns Boolean
96717>>>>>        String[] sConnectionData sConnectionData2
96719>>>>>        tSQLConnection SQLConnectionData
96719>>>>>        tSQLConnection SQLConnectionData
96719>>>>>        Boolean bState
96719>>>>>
96719>>>>>        Broadcast Recursive Send WriteConnectionData (&sConnectionData)
96721>>>>>        Get pSQLConnectionData to SQLConnectionData
96722>>>>>        Get MoveSQLConnectionToStringArray SQLConnectionData to sConnectionData2
96723>>>>>        // We don't have a form here for the sConnectionString, so we "blank it out"
96723>>>>>        // to be able to compare properly.
96723>>>>>        Move "" to sConnectionData2[7]
96724>>>>>
96724>>>>>            Move (IsSameArray(sConnectionData, sConnectionData2)) to bState
96725>>>>>        Function_Return (bState = False)
96726>>>>>    End_Function
96727>>>>>
96727>>>>>    Function IsConnectionIDDuplicate tSQLConnection SQLConnection Returns Boolean
96730>>>>>        Integer iCount iSize iItems iCurrentRow
96730>>>>>        String sValue sConnectionID
96730>>>>>        Boolean bExists
96730>>>>>        tDataSourceRow[] TheData
96730>>>>>        tDataSourceRow[] TheData
96731>>>>>        tDataSourceRow TheRow
96731>>>>>        tDataSourceRow TheRow
96731>>>>>
96731>>>>>        Move 0 to iItems
96732>>>>>        Get piCurrentRow to iCurrentRow
96733>>>>>        Move SQLConnection.sConnectionID to sConnectionID
96734>>>>>        Get MoveSQLConnectionToGridRow SQLConnection to TheRow
96735>>>>>        Get pTheData to TheData
96736>>>>>        Move (SizeOfArray(TheData)) to iSize
96737>>>>>        If (iCurrentRow <> -1) Begin
96739>>>>>            // This is the sConnectionID:
96739>>>>>            Move TheRow.sValue[2] to TheData[iCurrentRow].sValue[2]
96740>>>>>        End
96740>>>>>>
96740>>>>>        Else Begin
96741>>>>>            Move TheRow to TheData[iSize]
96742>>>>>        End
96742>>>>>>
96742>>>>>        Move (SizeOfArray(TheData)) to iSize
96743>>>>>        Decrement iSize
96744>>>>>        For iCount from 0 to iSize
96750>>>>>>
96750>>>>>            Move TheData[iCount].sValue[2] to sValue
96751>>>>>            Move (sValue = sConnectionID) to bExists
96752>>>>>            If (bExists) Begin
96754>>>>>                Increment iItems
96755>>>>>            End
96755>>>>>>
96755>>>>>        Loop
96756>>>>>>
96756>>>>>
96756>>>>>        Function_Return (iItems > 1)
96757>>>>>    End_Function
96758>>>>>
96758>>>>>    // Transfers data between a tSQLConnection struct and a grid data row.
96758>>>>>    Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
96761>>>>>        tDataSourceRow TheRow
96761>>>>>        tDataSourceRow TheRow
96761>>>>>        Integer iDbType
96761>>>>>        String sValue
96761>>>>>
96761>>>>>        Move 0                                  to TheRow.sValue[0]
96762>>>>>        Move SQLConnection.bEnabled             to TheRow.sValue[1]
96763>>>>>        Move SQLConnection.sConnectionID        to TheRow.sValue[2]
96764>>>>>        Move SQLConnection.sDriverID            to TheRow.sValue[3]
96765>>>>>
96765>>>>>        // We only show three asterisks ("***") instead of the password in the grid.
96765>>>>>        Move (Replace(SQLConnection.sPassword, SQLConnection.sConnectionString, "***")) to sValue
96766>>>>>        Move sValue                             to TheRow.sValue[4]
96767>>>>>
96767>>>>>        Move SQLConnection.iDbType to iDbType
96768>>>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
96769>>>>>        Move sValue                             to TheRow.sValue[5]
96770>>>>>        Move SQLConnection.sServer              to TheRow.sValue[6]
96771>>>>>        Move SQLConnection.sDatabase            to TheRow.sValue[7]
96772>>>>>
96772>>>>>        // Hidden columns (to make Should_Save function work)
96772>>>>>        Move SQLConnection.sConnectionString    to TheRow.sValue[8] // "Untouched" connection string.
96773>>>>>        Move SQLConnection.bTrusted             to TheRow.sValue[9]
96774>>>>>        Move SQLConnection.sUserID              to TheRow.sValue[10]
96775>>>>>        Move SQLConnection.sPassword            to TheRow.sValue[11]
96776>>>>>        Move SQLConnection.sSchema              to TheRow.sValue[12]
96777>>>>>        Move SQLConnection.sBaseTableSpace      to TheRow.sValue[13]
96778>>>>>        Move SQLConnection.sLongTableSpace      to TheRow.sValue[14]
96779>>>>>        Move SQLConnection.sIndexTableSpace     to TheRow.sValue[15]
96780>>>>>        Move SQLConnection.bSilentLogin         to TheRow.sValue[16]
96781>>>>>//        Move SQLConnection.bDisabled            to TheRow.sValue[17]
96781>>>>>//        Move SQLConnection.iDriverIndex         to TheRow.sValue[18]
96781>>>>>
96781>>>>>        Function_Return TheRow
96782>>>>>    End_Function
96783>>>>>
96783>>>>>    Function MoveSQLConnectionToStringArray tSQLConnection SQLConnection Returns String[]
96786>>>>>        String[] sConnectionData
96787>>>>>        Integer iRetval
96787>>>>>
96787>>>>>        Move SQLConnection.bEnabled          to sConnectionData[1]
96788>>>>>        Move SQLConnection.sConnectionID     to sConnectionData[2]
96789>>>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary SQLConnection.iDbType to sConnectionData[3]
96790>>>>>        Move SQLConnection.sDriverID         to sConnectionData[4]
96791>>>>>        Move SQLConnection.sServer           to sConnectionData[5]
96792>>>>>        Move SQLConnection.sDatabase         to sConnectionData[6]
96793>>>>>        Move SQLConnection.sConnectionString to sConnectionData[7]
96794>>>>>        Move SQLConnection.bTrusted          to sConnectionData[8]
96795>>>>>        Move SQLConnection.sUserID           to sConnectionData[9]
96796>>>>>
96796>>>>>        If (SQLConnection.sPassword <> "") Begin
96798>>>>>            Move MBR_Yes to iRetval
96799>>>>>            If (pbDFConnId(Self) = True) Begin
96801>>>>>                Get YesNo_Box "You are working with a DAW 'DFConnId.ini' file. Although this program can both read/write to such a file, the password encryption/decryption algorithms are (obviously) different. Thus the password will not be touched. Continue?" to iRetval
96802>>>>>                If (iRetval = MBR_Yes) Begin
96804>>>>>                    Set psUncryptedPw to SQLConnection.sPassword
96805>>>>>                    Move "" to SQLConnection.sPassword 
96806>>>>>//                    Set Enabled_State of oCheckLogin_btn to False
96806>>>>>                End
96806>>>>>>
96806>>>>>                Else Begin
96807>>>>>                    Send Stop_UI
96808>>>>>                End
96808>>>>>>
96808>>>>>            End
96808>>>>>>
96808>>>>>            Else Begin
96809>>>>>                Move SQLConnection.sPassword to sConnectionData[10]
96810>>>>>            End
96810>>>>>>
96810>>>>>        End
96810>>>>>>
96810>>>>>
96810>>>>>        Move SQLConnection.sSchema           to sConnectionData[11]
96811>>>>>        Move SQLConnection.sBaseTableSpace   to sConnectionData[12]
96812>>>>>        Move SQLConnection.sLongTableSpace   to sConnectionData[13]
96813>>>>>        Move SQLConnection.sIndexTableSpace  to sConnectionData[14]
96814>>>>>        Move SQLConnection.bSilentLogin      to sConnectionData[15]
96815>>>>>
96815>>>>>        Function_Return sConnectionData
96816>>>>>    End_Function
96817>>>>>
96817>>>>>    Function MoveStringArrayToSQLConnection String[] sConnectionData Returns tSQLConnection
96820>>>>>        tSQLConnection SQLConnection
96820>>>>>        tSQLConnection SQLConnection
96820>>>>>
96820>>>>>        Move sConnectionData[1]  to SQLConnection.bEnabled
96821>>>>>        Move sConnectionData[2]  to SQLConnection.sConnectionID
96822>>>>>        Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sConnectionData[3] to SQLConnection.iDbType
96823>>>>>        Move sConnectionData[4]  to SQLConnection.sDriverID
96824>>>>>        Move sConnectionData[5]  to SQLConnection.sServer
96825>>>>>        Move sConnectionData[6]  to SQLConnection.sDatabase
96826>>>>>
96826>>>>>        Move sConnectionData[8]  to SQLConnection.bTrusted
96827>>>>>        Move sConnectionData[9]  to SQLConnection.sUserID
96828>>>>>
96828>>>>>        If (sConnectionData[10] <> "" and pbDFConnId(Self) = False) Begin
96830>>>>>            Move sConnectionData[10] to SQLConnection.sPassword
96831>>>>>        End
96831>>>>>>
96831>>>>>        // In case of we're dealing with a DfConnID.ini file (DF 19+) we don't want to change the password
96831>>>>>        // as DAW's 'Managed Connections' program has a different password encryption/decryption algorithm.
96831>>>>>        If (pbDFConnId(Self) = True) Begin
96833>>>>>            Get psUncryptedPw to SQLConnection.sPassword
96834>>>>>        End
96834>>>>>>
96834>>>>>
96834>>>>>        Move sConnectionData[11] to SQLConnection.sSchema
96835>>>>>        Move sConnectionData[12] to SQLConnection.sBaseTableSpace
96836>>>>>        Move sConnectionData[13] to SQLConnection.sLongTableSpace
96837>>>>>        Move sConnectionData[14] to SQLConnection.sIndexTableSpace
96838>>>>>        Move sConnectionData[15] to SQLConnection.bSilentLogin
96839>>>>>
96839>>>>>        // Connection string:
96839>>>>>        Get ConstructConnectionString of ghoSQLConnectionHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase ;                                                                 SQLConnection.bTrusted  SQLConnection.sUserID SQLConnection.sPassword ;                                      to SQLConnection.sConnectionString
96840>>>>>
96840>>>>>        Function_Return SQLConnection
96841>>>>>    End_Function
96842>>>>>
96842>>>>>    Procedure Popup
96845>>>>>        tSQLConnection SQLIniFileConnection
96845>>>>>        tSQLConnection SQLIniFileConnection
96845>>>>>        String[] sConnectionData
96846>>>>>        String sDriverID
96846>>>>>        Integer iDbType
96846>>>>>        Boolean bAdd
96846>>>>>
96846>>>>>        Move (piCurrentRow(Self) = -1) to bAdd
96847>>>>>        Get pSQLConnectionData to SQLIniFileConnection             
96848>>>>>        // we need these as the oConnectionType_grp has been moved to be the last object(s) in the dialog.
96848>>>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
96849>>>>>        Set Value of oDriverID_cf to ""
96850>>>>>        If (SQLIniFileConnection.bEnabled = False and bAdd = True) Begin
96852>>>>>            Move True to SQLIniFileConnection.bEnabled
96853>>>>>        End
96853>>>>>>
96853>>>>>        Get MoveSQLConnectionToStringArray SQLIniFileConnection to sConnectionData
96854>>>>>
96854>>>>>        Set Value of oDriverID_cf to SQLIniFileConnection.sDriverID
96855>>>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
96856>>>>>        Broadcast Recursive Send ReadConnectionData sConnectionData
96858>>>>>
96858>>>>>        // We need this message to "auto-default" certain fields.
96858>>>>>        If (bAdd = True) Begin
96860>>>>>            Get SelectedDbType of oDbType_cf to iDbType
96861>>>>>            Get Value of oDriverID_cf to sDriverID
96862>>>>>            If (sDriverID = "") Begin
96864>>>>>                Move MSSQLDRV_ID to sDriverID
96865>>>>>            End
96865>>>>>>
96865>>>>>            Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
96867>>>>>        End
96867>>>>>>
96867>>>>>
96867>>>>>        Set Password_State of oPassword_fm to True
96868>>>>>        Set Value of oLoginInfo_tb to ""
96869>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
96870>>>>>
96870>>>>>        Forward Send Popup
96872>>>>>    End_Procedure
96873>>>>>
96873>>>>>    Procedure Page Integer iPageObject
96876>>>>>        Boolean bNew bReadOnly
96876>>>>>        String sText
96876>>>>>        Handle hWnd
96876>>>>>
96876>>>>>        Send Cursor_Ready of Cursor_Control
96877>>>>>        Forward Send Page iPageObject
96879>>>>>
96879>>>>>        Set Icon to "SQLConnections1.ico"
96880>>>>>
96880>>>>>        Get pbNew to bNew
96881>>>>>        If (bNew = True) Begin
96883>>>>>            Move ("The" * CS_SQLIniFileName * "file doesn't exist yet for this workspace and needs to be created. Here's what you need to do:\n\n") to sText
96884>>>>>            Move (sText * "1. Enter a Connection ID (the same that is being used by your workspace .int files) and other data that is used to login to the database.\n") to sText
96885>>>>>            Move (sText * "2. Press the 'Test Login' button to ensure entered details are correct.\n") to sText
96886>>>>>            Move (sText * "3. Press the 'OK' button and then save your changes.\n") to sText
96887>>>>>            Send Info_Box sText
96888>>>>>        End
96888>>>>>>
96888>>>>>
96888>>>>>        If (ghoSkinFramework <> 0 and hWnd <> 0) Begin
96890>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
96891>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
96892>>>>>        End
96892>>>>>>
96892>>>>>
96892>>>>>        Get pbReadOnly to bReadOnly
96893>>>>>        If (bReadOnly = True) Begin
96895>>>>>            Broadcast Recursive Set Enabled_State    to (not(bReadOnly))
96897>>>>>            Set Enabled_State of oConnectionType_grp to True
96898>>>>>            Set Enabled_State of oSettings_grp       to True
96899>>>>>            Set Enabled_State of oPassword_fm        to True
96900>>>>>            Set Enabled_State of oViewPassword_btn   to True
96901>>>>>            Set Enabled_State of oCheckLogin_btn     to True
96902>>>>>            Set Enabled_State of oCancel_Btn         to True
96903>>>>>            Set Enabled_State of oHelp_Btn           to True
96904>>>>>            Set Enabled_State of oShowDriverSettings_btn to True
96905>>>>>            Set Enabled_State of oCreateDatabase_btn to False
96906>>>>>            Send Activate of oCancel_Btn
96907>>>>>        End
96907>>>>>>
96907>>>>>    End_Procedure
96908>>>>>
96908>>>>>    Function IniFileName Returns String
96911>>>>>        String sRetval
96911>>>>>        Function_Return sRetval
96912>>>>>    End_Function
96913>>>>>
96913>>>>>    // Put a status bar at the bottom of the panel, which makes
96913>>>>>    // status_help work and puts a gripper in the lower right corner.
96913>>>>>    Procedure End_Construct_Object
96916>>>>>        Integer iStyle iSize iOffset
96916>>>>>
96916>>>>>        Forward Send End_Construct_Object
96918>>>>>
96918>>>>>        Get Border_Style to iStyle
96919>>>>>        Move 8 to iOffset
96920>>>>>        If (iStyle = Border_Thick) Begin
96922>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
96924>>>>>                Object oStatusBar is a cCJStatusBar
96926>>>>>                    Set phoDialogCommandbar to Self
96927>>>>>                    Object oStatusIdle is a cCJStatusBarPane
96929>>>>>                        Set piId to sbpIDIdlePane
96930>>>>>                        Set pbStyleStretch to True
96931>>>>>                    End_Object
96932>>>>>                End_Object
96933>>>>>            End_Object
96934>>>>>
96934>>>>>            Get Size to iSize
96935>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
96936>>>>>        End
96936>>>>>>
96936>>>>>    End_Procedure
96937>>>>>
96937>>>>>    Procedure ShowProgramHelp
96940>>>>>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
96941>>>>>    End_Procedure
96942>>>>>
96942>>>>>    On_Key Key_F1         Send ShowProgramHelp
96943>>>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oCheckLogin_btn
96944>>>>>    On_Key kCancel        Send KeyAction of oCancel_Btn
96945>>>>>End_Object
96946>>>>>
96946>>>>>// General purpose access message                                                                                                           // If ini-file= "DFConnId.ini" (DAW file)
96946>>>>>Procedure Activate_SQLMaintainConnections_dg Boolean bNew Integer iCurrentRow tSQLConnection ByRef SQLConnectionData Boolean ByRef bChanged Boolean bDFConnId tDataSourceRow[] TheData
96949>>>>>    Handle ho
96949>>>>>    String sPath sSQLConnectionsFileName
96949>>>>>    Boolean bExists
96949>>>>>    
96949>>>>>    Send Cursor_Wait of Cursor_Control
96950>>>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
96951>>>>>    Set pbReadOnly              of ho to False
96952>>>>>    Set pbNew                   of ho to bNew
96953>>>>>    Set piCurrentRow            of ho to iCurrentRow
96954>>>>>    Set pbDFConnId              of ho to bDFConnId
96955>>>>>    Set pSQLConnectionData      of ho to SQLConnectionData
96956>>>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
96957>>>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
96958>>>>>    File_Exist (sPath + sSQLConnectionsFileName) bExists
96959>>>>>    If (bExists = True) Begin
96961>>>>>     Set Label  of ho to ("Connection Properties" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
96962>>>>>    End
96962>>>>>>
96962>>>>>    
96962>>>>>    Set pTheData                of ho to TheData
96963>>>>>
96963>>>>>    Send Popup                  of ho
96964>>>>>
96964>>>>>    Get pSQLConnectionData      of ho to SQLConnectionData
96965>>>>>    Get pbChanged               of ho to bChanged
96966>>>>>End_Procedure
96967>>>>>
96967>>>>>// Read-only access message
96967>>>>>Procedure Activate_ReadOnlySQLMaintainConnections_dg tSQLConnection SQLConnectionData
96970>>>>>    Handle ho
96970>>>>>    String sPath sSQLConnectionsFileName
96970>>>>>
96970>>>>>    Send Cursor_Wait of Cursor_Control
96971>>>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
96972>>>>>    Set pbReadOnly              of ho to True
96973>>>>>
96973>>>>>    Set pSQLConnectionData      of ho to SQLConnectionData
96974>>>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
96975>>>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
96976>>>>>    Set Label  of ho to ("Connection Properties (Read-Only)" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
96977>>>>>
96977>>>>>    Send Popup of ho
96978>>>>>End_Procedure
96979>>>>>
96979>>>
96979>>>Activate_View Activate_oSQLMaintainConnection for oSQLMaintainConnection
96989>>>>
96989>>>Object oSQLMaintainConnection is a dbView
96991>>>    Set Size to 135 538
96992>>>    Set Location to 2 2
96993>>>    Set Maximize_Icon to True
96994>>>    Set Minimize_Icon to False
96995>>>    Set Border_Style to Border_Thick
96996>>>    Set View_Mode to Viewmode_Zoom
96997>>>    Set pbAutoActivate to True
96998>>>    Set pbAcceptDropFiles to True
96999>>>
96999>>>    Set phoMainView of ghoApplication to Self
97000>>>    
97000>>>    Property Boolean pbEnabled False
97002>>>    Property Boolean pbNew False
97004>>>    Property tDataSourceRow[] pTheData
97006>>>
97006>>>    Function IniFileName Returns String
97009>>>        String sRetval
97009>>>        Get InfileName of oSQLConnections_grd to sRetval
97010>>>        Function_Return sRetval
97011>>>    End_Function
97012>>>
97012>>>    Object oGridInfo_tb is a TextBox
97014>>>        Set Auto_Size_State to False
97015>>>        Set Size to 9 368
97016>>>        Set Location to 10 34
97017>>>        Set Label to "Note: You can drag and drop a connection file on to the grid."
97018>>>        Set FontItalics to True
97019>>>        Set peAnchors to anTopLeftRight
97020>>>        Set Justification_Mode to JMode_Left
97021>>>    End_Object
97022>>>
97022>>>    Object oSQLConnections_grd is a cCJGrid
97024>>>        Set Size to 98 503
97025>>>        Set Location to 25 19
97026>>>        Set peAnchors to anAll
97027>>>        Set pbShowRowFocus to True
97028>>>        Set pbUseAlternateRowBackgroundColor to True
97029>>>        Set pbSelectionEnable to True
97030>>>        Set pbRestoreLayout to True
97031>>>        Set psLayoutSection to "oSQLConnections_grd"
97032>>>        Set piLayoutBuild to 13
97033>>>        Set pbShowFooter to True
97034>>>        Set pbAllowAppendRow to False
97035>>>        Set pbAllowEdit to False
97036>>>        Set pbAllowInsertRow to False
97037>>>        Set pbAutoAppend to False
97038>>>        Set pbAutoSave to False
97039>>>        Set pbEditOnTyping to False
97040>>>                Set peVisualTheme to xtpGridThemeExplorer
97041>>>        
97041>>>        Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
97043>>>            Set piWidth to 18
97044>>>        End_Object
97045>>>
97045>>>        Object oActive_Col is a cCJGridColumn
97047>>>            Set piWidth to 81
97048>>>            Set psCaption to "Enabled"
97049>>>            Set pbCheckbox to True
97050>>>            Set psToolTip to "Only one connection can be the active one at any time. Press the 'Edit' button or double-click on a row to edit."
97051>>>        End_Object
97052>>>
97052>>>        Object oConnectionID_Col is a cCJGridColumn
97054>>>            Set piWidth to 90
97055>>>            Set psCaption to "ID"
97056>>>        End_Object
97057>>>
97057>>>        Object oDbType_Col is a cCJGridColumn
97059>>>            Set piWidth to 150
97060>>>            Set psCaption to "Database Type"
97061>>>        End_Object
97062>>>
97062>>>        Object oServer_Col is a cCJGridColumn
97064>>>            Set piWidth to 138
97065>>>            Set psCaption to "Server"
97066>>>        End_Object
97067>>>
97067>>>        Object oDatabase_Col is a cCJGridColumn
97069>>>            Set piWidth to 92
97070>>>            Set psCaption to "Database"
97071>>>        End_Object
97072>>>
97072>>>        Object oDriver_Col is a cCJGridColumn
97074>>>            Set piWidth to 101
97075>>>            Set psCaption to "Driver ID"
97076>>>        End_Object
97077>>>
97077>>>        Object oConnectionString_Col is a cCJGridColumn
97079>>>            Set piWidth to 372
97080>>>            Set psCaption to "Connection String"
97081>>>            Set psTooltip to "The full connection string as read from the connections ini-file. Press the 'Edit' button or double-click on a row to edit."
97082>>>        End_Object
97083>>>
97083>>>        // The following columns are all hidden. The only reason they are here is to make the grid data exactly the same
97083>>>        // as the tSQLConnection data.
97083>>>        // See the "Should_Save" function
97083>>>        //
97083>>>        // "Untouched" connection string column. Needed when passing data between grid and popup dialog as we mask pw in connection string.
97083>>>        Object oConnectionStringFull_Col is a cCJGridColumn
97085>>>            Set piWidth to 50
97086>>>            Set psCaption to "Connection String (Untouched)"
97087>>>            Set pbVisible to False   
97088>>>            Set pbShowInFieldChooser to False
97089>>>        End_Object
97090>>>
97090>>>        Object oTrusted_Col is a cCJGridColumn
97092>>>            Set piWidth to 50
97093>>>            Set psCaption to "Trusted"
97094>>>            Set pbCheckbox to True
97095>>>            Set pbVisible to False
97096>>>        End_Object
97097>>>
97097>>>        Object oUserID_Col is a cCJGridColumn
97099>>>            Set piWidth to 50
97100>>>            Set psCaption to "UserID"
97101>>>            Set pbVisible to False
97102>>>        End_Object
97103>>>
97103>>>        Object oPassword_Col is a cCJGridColumn
97105>>>            Set piWidth to 50
97106>>>            Set psCaption to "Password"
97107>>>            Set pbVisible to False
97108>>>            Set pbShowInFieldChooser to False
97109>>>        End_Object
97110>>>
97110>>>        Object oSchema_Col is a cCJGridColumn
97112>>>            Set piWidth to 50
97113>>>            Set psCaption to "Schema"
97114>>>            Set pbVisible to False
97115>>>        End_Object
97116>>>
97116>>>        Object oBaseTableSpace_Col is a cCJGridColumn
97118>>>            Set piWidth to 50
97119>>>            Set psCaption to "Base Table Space"
97120>>>            Set pbVisible to False
97121>>>        End_Object
97122>>>
97122>>>        Object oLongTableSpace_Col is a cCJGridColumn
97124>>>            Set piWidth to 50
97125>>>            Set psCaption to "Long Table Space"
97126>>>            Set pbVisible to False
97127>>>        End_Object
97128>>>
97128>>>        Object oIndexTableSpace_Col is a cCJGridColumn
97130>>>            Set piWidth to 50
97131>>>            Set psCaption to "Index Table Space"
97132>>>            Set pbVisible to False
97133>>>        End_Object
97134>>>
97134>>>        Object oSilentLogin_Col is a cCJGridColumn
97136>>>            Set piWidth to 50
97137>>>            Set psCaption to "Silent Login"
97138>>>            Set pbCheckbox to True
97139>>>            Set pbVisible to False
97140>>>        End_Object
97141>>>
97141>>>//        Object oDisabled_Col is a cCJGridColumn
97141>>>//            Set piWidth to 50
97141>>>//            Set psCaption to "Disabled"
97141>>>//            Set pbVisible to False
97141>>>//        End_Object
97141>>>
97141>>>        Object oCJContextMenu is a cCJContextMenu
97143>>>            Set pbShowPopupBarToolTips of ghoCommandBars to True
97144>>>
97144>>>            Object oAddMenuItem is a cCJMenuItem
97146>>>                Set psCaption to "Add"
97147>>>                Set psTooltip to "Add new connection"
97148>>>                Set psImage to "ActionAdd1.ico"
97149>>>                Set psShortcut to "Ctrl+A"
97150>>>                Procedure OnExecute Variant vCommandBarControl
97153>>>                    Forward Send OnExecute vCommandBarControl
97155>>>                    Send AddItem
97156>>>                End_Procedure
97157>>>            End_Object
97158>>>
97158>>>            Object oEditMenuItem is a cCJMenuItem
97160>>>                Set psCaption to "Edit"
97161>>>                Set psTooltip to "Edit existing connection"
97162>>>                Set psImage to "ActionEdit1.ico"
97163>>>                Set psShortcut to "Ctrl+E"
97164>>>                Procedure OnExecute Variant vCommandBarControl
97167>>>                    Forward Send OnExecute vCommandBarControl
97169>>>                    Send EditItem
97170>>>                End_Procedure
97171>>>            End_Object
97172>>>
97172>>>            Object oDeleteMenuItem is a cCJMenuItem
97174>>>                Set psCaption to "Delete"
97175>>>                Set psTooltip to "Delete current connection"
97176>>>                Set psImage to "ActionDelete1.ico"
97177>>>                Set psShortcut to "Del"
97178>>>                Procedure OnExecute Variant vCommandBarControl
97181>>>                    Forward Send OnExecute vCommandBarControl
97183>>>                    Send DeleteItem 
97184>>>                End_Procedure
97185>>>            End_Object
97186>>>
97186>>>            Object oSaveMenuItem is a cCJMenuItem
97188>>>                Set pbControlBeginGroup to True
97189>>>                Set psCaption to "Save"
97190>>>                Set psTooltip to "Save changes"
97191>>>                Set psImage to "ActionSave1.ico" 
97192>>>                Set psShortcut to "Ctrl+S"
97193>>>                
97193>>>                Procedure OnExecute Variant vCommandBarControl
97196>>>                    Forward Send OnExecute vCommandBarControl
97198>>>                    Send SaveIniFile 
97199>>>                End_Procedure
97200>>>
97200>>>                Function IsEnabled Returns Boolean
97203>>>                    Boolean bState
97203>>>                    Get Should_Save to bState
97204>>>                    Function_Return (bState = True)
97205>>>                End_Function
97206>>>            End_Object
97207>>>
97207>>>            Object oSaveAsMenuItem is a cCJMenuItem
97209>>>                Set psCaption to "Save As"
97210>>>                Set psTooltip to "Save SQL Configuration File As"  
97211>>>                Set psImage to "ActionSaveAs1.ico"
97212>>>                
97212>>>                Procedure OnExecute Variant vCommandBarControl  
97215>>>                    String sPath sIniFileName sFileName
97215>>>
97215>>>                    Forward Send OnExecute vCommandBarControl
97217>>>                    
97217>>>                    Get psIniFilePath of ghoSQLConnectionHandler to sPath
97218>>>                    Get psIniFileName of ghoSQLConnectionHandler to sIniFileName
97219>>>                    Get vSelectSaveFile ".int" "Please enter a file name to save to" sPath sIniFileName to sFileName
97220>>>                    If (sFileName <> "") Begin
97222>>>                        Get ParseFolderName sFileName to sPath
97223>>>                        Get ParseFileName   sFileName to sIniFileName
97224>>>                        Set psIniFilePath of ghoSQLConnectionHandler to sPath
97225>>>                        Set psIniFileName of ghoSQLConnectionHandler to sIniFileName
97226>>>                        Send SaveIniFile  of (phoMainView(ghoApplication))
97227>>>                    End
97227>>>>
97227>>>                End_Procedure
97228>>>
97228>>>            End_Object   
97229>>>
97229>>>            Object oOpenMenuItem is a cCJMenuItem
97231>>>                Set pbControlBeginGroup to True
97232>>>                Set psCaption to "Open"
97233>>>                Set psTooltip to "Open SQL Connection ini-file"
97234>>>                Set psImage to "ActionOpen1.ico"
97235>>>                Set psShortcut to "Ctrl+O"
97236>>>                Procedure OnExecute Variant vCommandBarControl
97239>>>                    Forward Send OnExecute vCommandBarControl
97241>>>                    Send ActivateOpenDialog
97242>>>                End_Procedure
97243>>>            End_Object
97244>>>
97244>>>            Object oRefreshMenuItem is a cCJMenuItem
97246>>>                Set psCaption to "Refresh"
97247>>>                Set psTooltip to "Refresh grid (re-read values from ini-file)"
97248>>>                Set psImage to "ActionRefresh1.ico"
97249>>>                Set psShortcut to "Ctrl+R"
97250>>>
97250>>>                Procedure OnExecute Variant vCommandBarControl
97253>>>                    Forward Send OnExecute vCommandBarControl
97255>>>                    Send RefreshIniFile
97256>>>                End_Procedure
97257>>>
97257>>>                Function IsEnabled Returns Boolean
97260>>>                    Boolean bSave
97260>>>                    Get Should_Save to bSave
97261>>>                    Function_Return (bSave = True)
97262>>>                End_Function
97263>>>                
97263>>>            End_Object
97264>>>
97264>>>            Set phoContextMenu to Self
97265>>>        End_Object
97266>>>
97266>>>        Function Should_Save Returns Boolean
97269>>>            tDataSourceRow[] TheData1 TheData2
97269>>>            tDataSourceRow[] TheData1 TheData2
97271>>>            Handle hoDataSource
97271>>>            Boolean bShouldSave
97271>>>
97271>>>            Move True to bShouldSave
97272>>>            Get pTheData to TheData1
97273>>>            Get phoDataSource to hoDataSource
97274>>>            Get DataSource    of hoDataSource to TheData2
97275>>>                Move (not(IsSameArray(TheData1, TheData2))) to bShouldSave
97276>>>
97276>>>            Function_Return bShouldSave
97277>>>        End_Function
97278>>>
97278>>>        Function HasRecord Returns Boolean
97281>>>            tDataSourceRow[] TheData
97281>>>            tDataSourceRow[] TheData
97282>>>            Handle hoDataSource
97282>>>            Integer iSize
97282>>>
97282>>>            Get phoDataSource to hoDataSource
97283>>>            Get DataSource    of hoDataSource to TheData
97284>>>            Move (SizeOfArray(TheData)) to iSize
97285>>>
97285>>>            Function_Return (iSize > 0)
97286>>>        End_Function
97287>>>
97287>>>        Procedure ChangeHeaderText
97290>>>            Handle[] hoPanels
97291>>>            String sFileName
97291>>>
97291>>>            Send ChangeStatusRowText ""
97292>>>            Get IniFileName to sFileName
97293>>>            // Not sure why, but if the oStatusPane1 was set to "Set piID to sbpIDIdlePane",
97293>>>            // it wasn't always updated when this message was send. So instead change the
97293>>>            // text explicitly:
97293>>>            Get PaneObjects of (phoStatusBar(ghoCommandBars)) to hoPanels
97294>>>            Set psText of hoPanels[0] to sFileName
97295>>>        End_Procedure
97296>>>        
97296>>>        Function InFileName Returns String
97299>>>            String sFileName sPath
97299>>>            Handle ho
97299>>>            Boolean bChangesExist
97299>>>
97299>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97300>>>            Get psIniFilePath of ho to sPath
97301>>>            Get psIniFileName of ho to sFileName
97302>>>            If (sFileName = "") Begin
97304>>>                Move "" to sPath
97305>>>            End                 
97305>>>>
97305>>>            Else Begin
97306>>>                Get Should_Save to bChangesExist
97307>>>                If (bChangesExist = True) Begin
97309>>>                    Move (sFileName + "*") to sFileName
97310>>>                End
97310>>>>
97310>>>            End
97310>>>>
97310>>>            Function_Return (sPath + sFileName)
97311>>>        End_Function
97312>>>
97312>>>        Procedure LoadData
97315>>>            Handle hoDataSource ho
97315>>>            tDataSourceRow[] TheData
97315>>>            tDataSourceRow[] TheData
97316>>>            tDataSourceRow TheRow
97316>>>            tDataSourceRow TheRow
97316>>>            Integer iCount iSize
97316>>>            tSQLConnection[] SQLConnectionsArray
97316>>>            tSQLConnection[] SQLConnectionsArray
97317>>>
97317>>>            Send ChangeHeaderText
97318>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97319>>>
97319>>>            Get phoDataSource to hoDataSource
97320>>>            Send Reset of hoDataSource
97321>>>
97321>>>            Get ReadIniFile to SQLConnectionsArray
97322>>>            Move (SizeOfArray(SQLConnectionsArray)) to iSize
97323>>>            Decrement iSize
97324>>>
97324>>>            // Load data to the grid datasource array
97324>>>            For iCount from 0 to iSize
97330>>>>
97330>>>                Get MoveSQLConnectionToGridRow SQLConnectionsArray[iCount] to TheRow
97331>>>                Move TheRow to TheData[iCount]
97332>>>            Loop
97333>>>>
97333>>>
97333>>>            Set pTheData to TheData
97334>>>
97334>>>            // Initialize Grid with new data
97334>>>            Send InitializeData TheData
97335>>>
97335>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize +1))
97336>>>            Send MovetoFirstRow
97337>>>        End_Procedure    
97338>>>        
97338>>>        Procedure ClearData    
97341>>>            Handle hoDataSource
97341>>>            tDataSourceRow[] TheData
97341>>>            tDataSourceRow[] TheData
97342>>>
97342>>>            Send ChangeHeaderText
97343>>>            Set pTheData to TheData
97344>>>            Get phoDataSource to hoDataSource 
97345>>>            Send InitializeData TheData
97346>>>        End_Procedure
97347>>>
97347>>>        // Transfers data between a tSQLConnection struct and a grid data row.
97347>>>        Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
97350>>>            tDataSourceRow TheRow
97350>>>            tDataSourceRow TheRow
97350>>>            Integer iDbType
97350>>>            String sValue
97350>>>
97350>>>            Move SQLConnection.bEnabled             to TheRow.sValue[piColumnId(oActive_Col(Self))]
97351>>>            Move SQLConnection.sConnectionID        to TheRow.sValue[piColumnId(oConnectionID_Col(Self))]
97352>>>            Move SQLConnection.sDriverID            to TheRow.sValue[piColumnId(oDriver_Col(Self))]
97353>>>
97353>>>            // We only show three asterisks ("***") instead of the password in the grid.
97353>>>            Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97354>>>            Move sValue                             to TheRow.sValue[piColumnId(oConnectionString_Col(Self))]
97355>>>
97355>>>            Move SQLConnection.iDbType to iDbType
97356>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
97357>>>            Move sValue                             to TheRow.sValue[piColumnId(oDbType_Col(Self))]
97358>>>            Move SQLConnection.sServer              to TheRow.sValue[piColumnId(oServer_Col(Self))]
97359>>>            Move SQLConnection.sDatabase            to TheRow.sValue[piColumnId(oDatabase_Col(Self))]
97360>>>
97360>>>            // Hidden columns (to make Should_Save function work)
97360>>>            Move SQLConnection.sConnectionString    to TheRow.sValue[piColumnId(oConnectionStringFull_Col(Self))] // "Untouched" connection string.
97361>>>            Move SQLConnection.bTrusted             to TheRow.sValue[piColumnId(oTrusted_Col(Self))]
97362>>>            Move SQLConnection.sUserID              to TheRow.sValue[piColumnId(oUserID_Col(Self))]
97363>>>            Move SQLConnection.sPassword            to TheRow.sValue[piColumnId(oPassword_Col(Self))]
97364>>>            Move SQLConnection.sSchema              to TheRow.sValue[piColumnId(oSchema_Col(Self))]
97365>>>            Move SQLConnection.sBaseTableSpace      to TheRow.sValue[piColumnId(oBaseTableSpace_Col(Self))]
97366>>>            Move SQLConnection.sLongTableSpace      to TheRow.sValue[piColumnId(oLongTableSpace_Col(Self))]
97367>>>            Move SQLConnection.sIndexTableSpace     to TheRow.sValue[piColumnId(oIndexTableSpace_Col(Self))]
97368>>>            Move SQLConnection.bSilentLogin         to TheRow.sValue[piColumnId(oSilentLogin_Col(Self))]
97369>>>//            Move SQLConnection.bDisabled            to TheRow.sValue[piColumnId(oDisabled_Col(Self))]
97369>>>
97369>>>            Function_Return TheRow
97370>>>        End_Function
97371>>>
97371>>>        // Transfers data between a grid data row and a tSQLConnection struct.
97371>>>        Function MoveGridRowToSQLConnection tDataSourceRow TheRow Returns tSQLConnection
97374>>>            tSQLConnection SQLConnection
97374>>>            tSQLConnection SQLConnection
97374>>>            String sValue
97374>>>
97374>>>            Move TheRow.sValue[piColumnId(oActive_Col(Self))]               to SQLConnection.bEnabled
97375>>>            Move TheRow.sValue[piColumnId(oConnectionID_Col(Self))]         to SQLConnection.sConnectionID
97376>>>
97376>>>            Move TheRow.sValue[piColumnId(oDbType_Col(Self))]               to sValue
97377>>>            Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sValue to SQLConnection.iDbType
97378>>>            Move TheRow.sValue[piColumnId(oServer_Col(Self))]               to SQLConnection.sServer
97379>>>            Move TheRow.sValue[piColumnId(oDatabase_Col(Self))]             to SQLConnection.sDatabase
97380>>>            Move TheRow.sValue[piColumnId(oDriver_Col(Self))]               to SQLConnection.sDriverID
97381>>>
97381>>>            // Hidden columns (to make Should_Save function work)
97381>>>            Move TheRow.sValue[piColumnId(oConnectionStringFull_Col(Self))] to SQLConnection.sConnectionString
97382>>>            Move TheRow.sValue[piColumnId(oTrusted_Col(Self))]              to SQLConnection.bTrusted
97383>>>            Move TheRow.sValue[piColumnId(oUserID_Col(Self))]               to SQLConnection.sUserID
97384>>>            Move TheRow.sValue[piColumnId(oPassword_Col(Self))]             to SQLConnection.sPassword
97385>>>            Move TheRow.sValue[piColumnId(oSchema_Col(Self))]               to SQLConnection.sSchema
97386>>>            Move TheRow.sValue[piColumnId(oBaseTableSpace_Col(Self))]       to SQLConnection.sBaseTableSpace
97387>>>            Move TheRow.sValue[piColumnId(oLongTableSpace_Col(Self))]       to SQLConnection.sLongTableSpace
97388>>>            Move TheRow.sValue[piColumnId(oIndexTableSpace_Col(Self))]      to SQLConnection.sIndexTableSpace
97389>>>            Move TheRow.sValue[piColumnId(oSilentLogin_Col(Self))]          to SQLConnection.bSilentLogin
97390>>>//            Move TheRow.sValue[piColumnId(oDisabled_Col(Self))]             to SQLConnection.bDisabled
97390>>>
97390>>>            Function_Return SQLConnection
97391>>>        End_Function
97392>>>
97392>>>        // Called when the grid object is created:
97392>>>        Procedure Activating
97395>>>            Forward Send Activating
97397>>>            Send LoadData
97398>>>        End_Procedure
97399>>>
97399>>>        Function CurrentRow Returns Integer
97402>>>            Handle hoDataSource
97402>>>            Integer iRow
97402>>>
97402>>>            Get phoDataSource to hoDataSource
97403>>>            Get SelectedRow   of hoDataSource to iRow
97404>>>            Function_Return iRow
97405>>>        End_Function
97406>>>
97406>>>        Function CurrentRowData Returns tDataSourceRow
97409>>>            tDataSourceRow[] TheData
97409>>>            tDataSourceRow[] TheData
97410>>>            tDataSourceRow TheRow
97410>>>            tDataSourceRow TheRow
97410>>>            Handle ho hoDataSource
97410>>>            Integer iRow
97410>>>
97410>>>            Get phoDataSource  to hoDataSource
97411>>>            Get DataSource     of hoDataSource to TheData
97412>>>            Get SelectedRow    of hoDataSource to iRow
97413>>>            Move TheData[iRow] to TheRow
97414>>>
97414>>>            Function_Return TheRow
97415>>>        End_Function
97416>>>
97416>>>        Procedure OnRowChanged Integer iOldRow Integer iNewSelectedRow
97419>>>            Integer iRow
97419>>>            Handle hoDataSource
97419>>>            tDataSourceRow[] RowData
97419>>>            tDataSourceRow[] RowData
97420>>>
97420>>>            Forward Send OnRowChanged iOldRow iNewSelectedRow
97422>>>            Send ChangeHeaderText
97423>>>
97423>>>            Get phoDataSource to hoDataSource
97424>>>
97424>>>            Get SelectedRow of hoDataSource to iRow
97425>>>            If (iRow <> -1) Begin
97427>>>                Get DataSource of hoDataSource to RowData
97428>>>                Set pbEnabled to RowData[iRow].sValue[piColumnid(oActive_Col(Self))]
97429>>>            End
97429>>>>
97429>>>        End_Procedure
97430>>>
97430>>>        Procedure OnComRowDblClick Variant llRow Variant llItem
97433>>>            Forward Send OnComRowDblClick llRow llItem
97435>>>            Delegate Send EditItem 
97437>>>        End_Procedure
97438>>>
97438>>>        Procedure OnEnterKey
97441>>>            Forward Send OnEnterKey
97443>>>            Delegate Send EditItem 
97445>>>        End_Procedure
97446>>>
97446>>>        Procedure AddConnection tDataSourceRow TheRow
97449>>>            Integer iSize iCount
97449>>>            Handle hoDataSource
97449>>>            tDataSourceRow[] TheData
97449>>>            tDataSourceRow[] TheData
97450>>>            Boolean bEnabled
97450>>>
97450>>>            Get phoDataSource to hoDataSource
97451>>>            Get DataSource    of hoDataSource to TheData
97452>>>
97452>>>            Move (SizeOfArray(TheData)) to iSize
97453>>>            Move (TheRow.sValue[piColumnid(oActive_Col(Self))]) to bEnabled
97454>>>            If (bEnabled = True) Begin
97456>>>                // Then bEnabled state have changed; deactivate all current rows.
97456>>>                For iCount from 0 to (iSize -1)
97462>>>>
97462>>>                    Move False to TheData[iCount].sValue[piColumnId(oActive_Col(Self))]
97463>>>                Loop
97464>>>>
97464>>>            End
97464>>>>
97464>>>
97464>>>            Move TheRow to TheData[iSize]
97465>>>
97465>>>            // Initialize Grid with new data
97465>>>            Send InitializeData TheData True
97466>>>            Move (SizeOfArray(TheData)) to iSize
97467>>>            Send MoveToLastRow
97468>>>
97468>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
97469>>>        End_Procedure
97470>>>
97470>>>        Procedure UpdateConnection tDataSourceRow TheRow
97473>>>            Integer iRow iSize iCount
97473>>>            Handle hoDataSource
97473>>>            tDataSourceRow[] TheData
97473>>>            tDataSourceRow[] TheData
97474>>>            Boolean bEnabled
97474>>>
97474>>>            Get phoDataSource to hoDataSource
97475>>>            Get SelectedRow of hoDataSource to iRow
97476>>>            If (iRow <> -1) Begin
97478>>>                Get DataSource of hoDataSource to TheData
97479>>>
97479>>>                // If bEnabled state has changed; deactivate all rows.
97479>>>                Move (TheRow.sValue[piColumnId(oActive_Col(Self))]) to bEnabled
97480>>>                If (bEnabled = True) Begin
97482>>>                    Move (SizeOfArray(TheData)) to iSize
97483>>>                    Decrement iSize
97484>>>                    For iCount from 0 to iSize
97490>>>>
97490>>>                        Move False to TheData[iCount].sValue[piColumnId(oActive_Col(Self))]
97491>>>                    Loop
97492>>>>
97492>>>                End
97492>>>>
97492>>>
97492>>>                Move TheRow to TheData[iRow]
97493>>>            End
97493>>>>
97493>>>
97493>>>            // Initialize Grid with new data
97493>>>            Send ReInitializeData TheData True
97494>>>            Move (SizeOfArray(TheData)) to iSize
97495>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
97496>>>        End_Procedure
97497>>>
97497>>>        Procedure RemoveCurrentConnection
97500>>>            Integer iSize iRow iItem
97500>>>            Handle hoDataSource
97500>>>            tDataSourceRow[] TheData
97500>>>            tDataSourceRow[] TheData
97501>>>
97501>>>            Move 0 to iItem
97502>>>            Get phoDataSource to hoDataSource
97503>>>            Get DataSource of hoDataSource to TheData
97504>>>
97504>>>            Get SelectedRow of hoDataSource to iRow
97505>>>            If (iRow = -1) Begin
97507>>>                Procedure_Return
97508>>>            End
97508>>>>
97508>>>
97508>>>            Move False to Err
97509>>>            Send Request_Delete
97510>>>
97510>>>            Get DataSource of hoDataSource to TheData
97511>>>            Move (SizeOfArray(TheData)) to iSize
97512>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
97513>>>        End_Procedure
97514>>>
97514>>>        Function IsOneItemActive Returns Boolean
97517>>>            Handle hoDataSource ho
97517>>>            tDataSourceRow[] TheData
97517>>>            tDataSourceRow[] TheData
97518>>>            Integer iSize iCount
97518>>>            Boolean bRetval bExists
97518>>>            String sSection
97518>>>
97518>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97519>>>            Get psIniSectionName of ho to sSection
97520>>>            Get SectionExists    of ho sSection to bExists
97521>>>
97521>>>            Get phoDataSource to hoDataSource
97522>>>            Get DataSource of hoDataSource to TheData
97523>>>
97523>>>            Move (SizeOfArray(TheData)) to iSize
97524>>>            If (iSize = 0) Begin
97526>>>                Function_Return True
97527>>>            End
97527>>>>
97527>>>
97527>>>            Decrement iSize
97528>>>            For iCount from 0 to iSize
97534>>>>
97534>>>                If (TheData[iCount].sValue[piColumnId(oActive_Col(Self))] = True) Begin
97536>>>                    Move True to bRetval
97537>>>                End
97537>>>>
97537>>>            Loop
97538>>>>
97538>>>
97538>>>            Function_Return bRetval
97539>>>        End_Function
97540>>>
97540>>>        Function ReadIniFile Returns tSQLConnection[]
97543>>>            tSQLConnection[] SQLConnectionsArray
97543>>>            tSQLConnection[] SQLConnectionsArray
97544>>>            Handle ho
97544>>>
97544>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97545>>>            Get SQLIniFileReadConnections of ho to SQLConnectionsArray
97546>>>
97546>>>            Function_Return SQLConnectionsArray
97547>>>        End_Function
97548>>>
97548>>>        Procedure WriteIniFile
97551>>>            Integer iCount iSize iRetval
97551>>>            Handle hoDataSource ho
97551>>>            tDataSourceRow[] TheData
97551>>>            tDataSourceRow[] TheData
97552>>>            tDataSourceRow TheRow
97552>>>            tDataSourceRow TheRow
97552>>>            tSQLConnection[] SQLConnectionArray
97552>>>            tSQLConnection[] SQLConnectionArray
97553>>>            tSQLConnection SQLConnection
97553>>>            tSQLConnection SQLConnection
97553>>>            Boolean bIsOneActive bOK
97553>>>            String sPath sIniFileName
97553>>>            
97553>>>            Get psIniFileName of ghoSQLConnectionHandler to sIniFileName
97554>>>            If (sIniFileName = "") Begin
97556>>>                Get vSelectSaveFile ("SQLConnections ini-files (*.ini)|" + CS_SQLIniFileName + "|All Ini Files (*.ini)|*.ini|All Files (*.*)|*.*") "Select a connection ini-file" "" to sIniFileName
97557>>>                If (sIniFileName <> "") Begin
97559>>>                    Get ParseFolderName sIniFileName to sPath
97560>>>                    Set psIniFilePath of ghoSQLConnectionHandler to sPath
97561>>>                    Get ParseFileName sIniFileName to sIniFileName
97562>>>                    Set psIniFileName of ghoSQLConnectionHandler to sIniFileName
97563>>>                End  
97563>>>>
97563>>>                Else Begin
97564>>>                    Procedure_Return
97565>>>                End
97565>>>>
97565>>>            End
97565>>>>
97565>>>            
97565>>>            // 2018-07-14 I don't think this is necessary. In fact it can be quite practical in
97565>>>            // testing to disable all connections, or if e.g. customer's connections has been tested,
97565>>>            // that no longer are available locally.
97565>>>            Get IsOneItemActive to bIsOneActive
97566>>>//            If (bIsOneActive = False) Begin
97566>>>//                Send Info_Box "Sorry, you need to set one connection as active before changes can be saved."
97566>>>//                Procedure_Return
97566>>>//            End
97566>>>            If (bIsOneActive = False) Begin
97568>>>                Get YesNo_Box "Warning, no connection has been set to 'Enabled'. That means that the Database Framework will not read any information from here when initialized.\n\nAre you sure you want to continue to save without any connection Enabled?" to iRetval
97569>>>                If (iRetval = MBR_No) Begin
97571>>>                    Procedure_Return
97572>>>                End
97572>>>>
97572>>>            End
97572>>>>
97572>>>
97572>>>            Move 0 to iCount
97573>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97574>>>            Get phoDataSource to hoDataSource
97575>>>            Get DataSource of hoDataSource to TheData
97576>>>            Move (SizeOfArray(TheData)) to iSize
97577>>>            Decrement iSize
97578>>>
97578>>>            // Load data from the grid datasource array to SQLConnection array
97578>>>            For iCount from 0 to iSize
97584>>>>
97584>>>                Move TheData[iCount] to TheRow
97585>>>                Get MoveGridRowToSQLConnection TheRow to SQLConnection
97586>>>                Move SQLConnection to SQLConnectionArray[iCount]
97587>>>            Loop
97588>>>>
97588>>>
97588>>>            Get SQLIniFileWriteConnections of ho SQLConnectionArray to bOK
97589>>>            If (bOK = False) Begin
97591>>>                Send ChangeStatusRowText "Sorry, an error occured while saving the file and changes were not saved."
97592>>>                Procedure_Return
97593>>>            End
97593>>>>
97593>>>
97593>>>            // Update the view property with the newly saved values. (Used to check if anything has changed)
97593>>>            Set pTheData to TheData
97594>>>            Send ChangeHeaderText
97595>>>            Send ChangeStatusRowText "Ready! File saved."
97596>>>        End_Procedure
97597>>>
97597>>>        Procedure OnHeaderClick Integer iCol
97600>>>            String sPath sFileName
97600>>>            Handle ho
97600>>>
97600>>>            Forward Send OnHeaderClick iCol
97602>>>
97602>>>            Get vSelect_File ("SQLConnections ini-files (*.ini)|" + CS_SQLIniFileName + "|All Ini Files (*.ini)|*.ini|All Files (*.*)|*.*") "Select a connection ini-file" "" to sFileName
97603>>>            If (sFileName <> "") Begin
97605>>>                Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97606>>>                Get ParseFolderName sFileName to sPath
97607>>>                Set psIniFilePath of ho to sPath
97608>>>                Get ParseFileName sFileName to sFileName
97609>>>                Set psIniFileName of ho to sFilename
97610>>>                Set pbDFConnId of ho to (sFileName <> CS_SQLIniFileName)
97611>>>                Send LoadData of oSQLConnections_grd
97612>>>            End
97612>>>>
97612>>>        End_Procedure
97613>>>
97613>>>        Procedure OnCreateGridControl 
97616>>>            Handle hoObject  
97616>>>            Integer iToolTipStyle      
97616>>>            Boolean bIsBalloonStyleSupported
97616>>>            
97616>>>            Forward Send OnCreateGridControl
97618>>>    
97618>>>            Get phoToolTipContext to hoObject
97619>>>            If (hoObject <> 0) Begin
97621>>>                Move xtpToolTipStandard to iToolTipStyle    
97622>>>                // Baloon tooltip style requires IE 5.0 or later, so check if installed.
97622>>>                // The ComShowTitleAndDescription also requires IE 5.0.
97622>>>                Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
97623>>>                If (bIsBalloonStyleSupported = True) Begin
97625>>>                    Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
97626>>>                End                                                   
97626>>>>
97626>>>                Set ComStyle             of hoObject to iToolTipStyle
97627>>>                Set ComShowOfficeBorder  of hoObject to True
97628>>>                Set ComShowShadow        of hoObject to True
97629>>>                // Set the max width for a tooltip. 250 just seems to be a good
97629>>>                // compromise. After 250 pixels the text will wrap to the next line automatically.
97629>>>                Set ComMaxTipWidth       of hoObject to 250 // In pixels
97630>>>            End 
97630>>>>
97630>>>        End_Procedure
97631>>>
97631>>>        // These overrides the grid standar behaviour
97631>>>        On_Key kSave_Record Send SaveIniFile
97632>>>        On_Key Key_F5       Send RefreshIniFile
97633>>>    End_Object
97634>>>
97634>>>    // Public access methods: (used by menu/toolbar system)
97634>>>    Procedure ActivateOpenDialog
97637>>>        Send OnHeaderClick of oSQLConnections_grd 1
97638>>>    End_Procedure
97639>>>
97639>>>    Procedure RefreshIniFile
97642>>>        Boolean bChanged
97642>>>        Handle ho
97642>>>        Integer iRetval
97642>>>
97642>>>        Move (oSQLConnections_grd(Self)) to ho
97643>>>        Get Should_Save of ho to bChanged
97644>>>        If (bChanged = True) Begin
97646>>>            Get YesNo_Box "Changes exists! Press 'Yes' to refresh (changes will be lost)." "Refresh Question" to iRetval
97647>>>            If (iRetval <> MBR_Yes) Begin
97649>>>                Procedure_Return
97650>>>            End
97650>>>>
97650>>>        End
97650>>>>
97650>>>        Send ChangeStatusRowText ""
97651>>>        Send LoadData of oSQLConnections_grd
97652>>>    End_Procedure
97653>>>
97653>>>    Procedure AddItem
97656>>>        Boolean bChanged bDFConnId
97656>>>        tSQLConnection SQLConnection
97656>>>        tSQLConnection SQLConnection
97656>>>        tDataSourceRow[] TheData
97656>>>        tDataSourceRow[] TheData
97657>>>        tDataSourceRow   TheRow
97657>>>        tDataSourceRow   TheRow
97657>>>        Handle hoDataSource
97657>>>
97657>>>        Send ChangeStatusRowText ""
97658>>>        Get IsDFConnId to bDFConnId
97659>>>        Move EN_DbTypeMSSQL to SQLConnection.iDbType
97660>>>        Move MSSQLDRV_ID    to SQLConnection.sDriverID
97661>>>        Get phoDataSource of oSQLConnections_grd to hoDataSource
97662>>>        Get DataSource of hoDataSource to TheData
97663>>>        Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) -1 (&SQLConnection) (&bChanged) bDFConnId TheData
97664>>>        If (bChanged = True) Begin
97666>>>            Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
97667>>>            Send AddConnection of oSQLConnections_grd TheRow
97668>>>        End
97668>>>>
97668>>>    End_Procedure
97669>>>
97669>>>    Procedure EditItem
97672>>>        Boolean bEnabled bChanged bDFConnId
97672>>>        tSQLConnection SQLConnection
97672>>>        tSQLConnection SQLConnection
97672>>>        tDataSourceRow TheRow
97672>>>        tDataSourceRow TheRow
97672>>>        tDataSourceRow[] TheData
97672>>>        tDataSourceRow[] TheData
97673>>>        Handle hoDataSource
97673>>>        Integer iCurrentRow
97673>>>
97673>>>        Get CurrentRowData of oSQLConnections_grd to TheRow
97674>>>        Get MoveGridRowToSQLConnection of oSQLConnections_grd TheRow to SQLConnection
97675>>>        Send ChangeStatusRowText ""
97676>>>        Get pbEnabled to bEnabled
97677>>>        Get IsDFConnId to bDFConnId
97678>>>
97678>>>        Get phoDataSource of oSQLConnections_grd to hoDataSource
97679>>>        Get DataSource of hoDataSource to TheData
97680>>>        Get CurrentRow of oSQLConnections_grd to iCurrentRow
97681>>>
97681>>>        Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) iCurrentRow (&SQLConnection) (&bChanged) bDFConnId TheData
97682>>>        If (bChanged = True) Begin
97684>>>            Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
97685>>>            Send UpdateConnection of oSQLConnections_grd TheRow
97686>>>        End
97686>>>>
97686>>>    End_Procedure
97687>>>
97687>>>    Procedure SaveIniFile
97690>>>        Send ChangeStatusRowText ""
97691>>>        Send WriteIniFile of oSQLConnections_grd
97692>>>    End_Procedure
97693>>>
97693>>>    Procedure ClearIniFile
97696>>>        Handle ho
97696>>>        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97697>>>        Set psIniFilePath of ho to ""
97698>>>        Set psIniFileName of ho to ""
97699>>>        Set pbDFConnId of ho to False
97700>>>        Send ClearData of (oSQLConnections_grd(phoMainView(ghoApplication))) 
97701>>>    End_Procedure   
97702>>>                
97702>>>    Procedure DeleteItem
97705>>>        Send ChangeStatusRowText ""
97706>>>        Send RemoveCurrentConnection of oSQLConnections_grd
97707>>>    End_Procedure
97708>>>
97708>>>    Procedure ExitApplication
97711>>>        Send Exit_Application of ghoApplication
97712>>>    End_Procedure
97713>>>    
97713>>>    // Other messages used by the view:
97713>>>    Function IsDFConnId Returns Boolean
97716>>>        Boolean bDFConnId
97716>>>        Handle ho
97716>>>        String sFileName
97716>>>
97716>>>        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97717>>>        Get psIniFileName of ho to sFileName
97718>>>        Move (Uppercase(sFileName) = Uppercase(CS_SQLDF19IniFileName)) to bDFConnId
97719>>>        Set pbDFConnId of ho to bDFConnId
97720>>>
97720>>>        Function_Return bDFConnId
97721>>>    End_Function
97722>>>
97722>>>    Procedure OnFileDropped String sFilename Boolean bLast
97725>>>        Boolean bHasChange
97725>>>        Handle ho hoGrid
97725>>>        Integer iRetval
97725>>>        String sPath
97725>>>
97725>>>        Forward Send OnFileDropped sFilename bLast
97727>>>
97727>>>        If (bLast = True) Begin
97729>>>            Move (oSQLConnections_grd(Self)) to hoGrid
97730>>>            Get ParseFolderName sFilename to sPath
97731>>>            Get ParseFileName   sFilename to sFilename
97732>>>            If (Uppercase(sFilename) <> Uppercase(CS_SQLIniFileName) and Uppercase(sFilename) <> Uppercase(CS_SQLDF19IniFileName)) Begin
97734>>>                Send Info_Box ("Sorry, only" * CS_SQLIniFileName * "files can be dropped!")
97735>>>                Procedure_Return
97736>>>            End
97736>>>>
97736>>>            Get Should_Save of hoGrid to bHasChange
97737>>>            If (bHasChange = True) Begin
97739>>>                Get YesNo_Box "Changes exist! Do you still want to load the new file?" to iRetval
97740>>>                If (iRetval <> MBR_Yes) Begin
97742>>>                    Procedure_Return
97743>>>                End
97743>>>>
97743>>>            End
97743>>>>
97743>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
97744>>>            Set psIniFilePath of ho to sPath
97745>>>            Set psIniFileName of ho to sFilename
97746>>>            Send LoadData of oSQLConnections_grd
97747>>>        End
97747>>>>
97747>>>    End_Procedure
97748>>>
97748>>>    // This is only being called when there is no SQLConnections.ini file;
97748>>>    // thus a new active/enabled DFConnection ID needs to be established.
97748>>>    Procedure ConnectionDoesNotExist
97751>>>        tSQLConnection SQLConnection
97751>>>        tSQLConnection SQLConnection
97751>>>        Boolean bChanged bDFConnId bEnabled
97751>>>        Handle ho
97751>>>        tDataSourceRow TheRow
97751>>>        tDataSourceRow TheRow
97751>>>        Handle hoDataSource
97751>>>        tDataSourceRow[] TheData
97751>>>        tDataSourceRow[] TheData
97752>>>
97752>>>        Get IsDFConnId to bDFConnId
97753>>>
97753>>>        Move (oSQLMaintainConnections_dg(Self)) to ho
97754>>>        Move True to bEnabled
97755>>>        Set pbNew to True
97756>>>        Set pbNew of ho to True
97757>>>
97757>>>        Get phoDataSource of oSQLConnections_grd to hoDataSource
97758>>>        Get DataSource of hoDataSource to TheData
97759>>>
97759>>>        Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) -1 (&SQLConnection) (&bChanged) bDFConnId TheData
97760>>>        If (bChanged = True) Begin
97762>>>            // We also need to tell the main connection object that we now have
97762>>>            // created a connection.
97762>>>            Set pSQLConnection            of ghoSQLConnectionHandler to SQLConnection
97763>>>            // And add the data to the grid.
97763>>>            Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
97764>>>            Send AddConnection of oSQLConnections_grd TheRow
97765>>>            // Not new anymore.
97765>>>            Set pbNew to False
97766>>>            Set pbNew of ho to False
97767>>>        End
97767>>>>
97767>>>    End_Procedure
97768>>>
97768>>>    Procedure ChangeStatusRowText String sText
97771>>>        Handle[] hoPanels
97772>>>        Get PaneObjects of (phoStatusBar(ghoCommandBars)) to hoPanels
97773>>>        Set psText of hoPanels[1] to sText
97774>>>    End_Procedure
97775>>>
97775>>>    // On idle handling:
97775>>>    Object oIdle is a cIdleHandler
97777>>>        Procedure OnIdle
97780>>>          Delegate Send OnIdle
97782>>>        End_Procedure
97783>>>    End_Object
97784>>>
97784>>>    Procedure OnIdle
97787>>>        Handle ho
97787>>>
97787>>>        Move (oSQLConnections_grd(Self)) to ho
97788>>>        Send ChangeHeaderText of ho
97789>>>    End_Procedure
97790>>>
97790>>>    Procedure Activating
97793>>>        Handle ho
97793>>>
97793>>>        Set Maximize_Icon to True
97794>>>        Set Minimize_Icon to False
97795>>>        Set Border_Style to Border_Thick
97796>>>        Set View_Mode to Viewmode_Zoom
97797>>>
97797>>>        // Note: The following line is essential for the resizing logic
97797>>>        // to work when starting the program.
97797>>>        Move (Client_Id(ghoCommandBars)) to ho
97798>>>        Set Border_Style of ho to Border_ClientEdge
97799>>>
97799>>>        Set pbEnabled of oIdle to True
97800>>>    End_Procedure
97801>>>
97801>>>    Procedure Deactivating
97804>>>        Set pbEnabled of oIdle to False
97805>>>        Forward Send Deactivating
97807>>>    End_Procedure
97808>>>
97808>>>    Function Verify_Exit_Application Returns Integer
97811>>>        Integer iRetval
97811>>>        Boolean bChanged
97811>>>
97811>>>        Get Should_Save of oSQLConnections_grd to bChanged
97812>>>        If (bChanged = False) Begin
97814>>>            Function_Return False
97815>>>        End
97815>>>>
97815>>>        Else Begin
97816>>>            Get YesNoCancel_Box "Changes exists. Save changes first?" to iRetval
97817>>>            If (iRetval = MBR_Cancel) Begin
97819>>>                Function_Return True
97820>>>            End
97820>>>>
97820>>>            If (iRetval = MBR_Yes) Begin
97822>>>                Send SaveIniFile //KeyAction of oSave_btn
97823>>>                Send Exit_Application
97824>>>            End
97824>>>>
97824>>>            If (iRetval = MBR_No) Begin
97826>>>                Function_Return False
97827>>>            End
97827>>>>
97827>>>        End
97827>>>>
97827>>>        Function_Return True
97828>>>    End_Function
97829>>>
97829>>>    On_Key kDelete_Character Send DeleteItem 
97830>>>    On_Key Key_Ctrl+Key_D    Send DeleteItem 
97831>>>    On_Key Key_Alt+Key_D     Send DeleteItem 
97832>>>    On_Key Key_Ctrl+Key_E    Send EditItem   
97833>>>    On_Key Key_Alt+Key_E     Send EditItem   
97834>>>    On_Key Key_Ctrl+Key_A    Send AddItem    
97835>>>    On_Key Key_Alt+Key_A     Send AddItem    
97836>>>    On_Key Key_F5            Send RefreshIniFile 
97837>>>    On_Key Key_Ctrl+Key_R    Send RefreshIniFile 
97838>>>    On_Key Key_Alt+Key_R     Send RefreshIniFile 
97839>>>    On_Key Key_Ctrl+Key_F5   Send ClearIniFile
97840>>>    On_Key kSave_Record      Send SaveIniFile    
97841>>>    On_Key Key_Ctrl+Key_S    Send SaveIniFile    
97842>>>    On_Key Key_F2            Send SaveIniFile    
97843>>>    On_Key Key_Ctrl+Key_X    Send ExitApplication
97844>>>    On_Key Key_Ctrl+Key_O    Send ActivateOpenDialog
97845>>>    On_Key Key_Alt+Key_O     Send ActivateOpenDialog
97846>>>    On_Key kCancel           Send None
97847>>>    On_Key Key_Ctrl+Key_F4   Send None
97848>>>End_Object
97849>        Use ManageSQLConnections.dg
97849>        Use AddToStudio.dg
Including file: AddToStudio.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\AddToStudio.dg)
97849>>>Use Windows.pkg
97849>>>Use Dfspnfrm.pkg
97849>>>Use cRegistry.pkg
97849>>>Use vWin32fh.pkg
97849>>>
97849>>>Enum_List
97849>>>    Define cx_RegKeyAlreadyExist
97849>>>    Define cx_RegKeyCreated
97849>>>    Define cx_RegkeyFailed
97849>>>    Define cx_RegKeyVDFKeyDoesNotExist
97849>>>    Define CX_InstalledOkVdfUnder16
97849>>>End_Enum_List
97849>>>
97849>>>// Note: The "Visual" part will automatically be removed if
97849>>>// the current DataFlex version is above 17.
97849>>>Define CS_StudioPath        for "Software\Data Access Worldwide\Visual DataFlex Tools\"
97849>>>Define CS_StudioTools       for "\Studio\Tools"
97849>>>Define CS_RegApplication    for "<application>"
97849>>>Define CS_RegWorkspace      for "<workspace>"
97849>>>Define CS_CommandLine       for "CommandLine"
97849>>>Define CS_Name              for "Name"
97849>>>Define CS_Separator         for "Separator"
97849>>>Define CS_Command           for "Command"
97849>>>
97849>>>Object oAddToStudio_dg is a ModalPanel
97851>>>    Set Size to 79 330
97852>>>    Set Label to "Add Program To DataFlex Studio's Tools Menu"
97853>>>    Set piMinSize to 79 211
97854>>>    Set Location to 5 4
97855>>>    Set Locate_Mode to Center_On_Parent
97856>>>
97856>>>    Property String psTag CS_RegApplication
97858>>>
97858>>>    Object oStudioIntegration_grp is a Group
97860>>>        Set Size to 45 299
97861>>>        Set Location to 8 15
97862>>>        Set Label to "DataFlex Studio Integration"
97863>>>
97863>>>        Object oStudioMajorVersion_sf is a SpinForm
97865>>>            Set Size to 12 27
97866>>>            Set Location to 18 168
97867>>>            Set Maximum_Position to 30
97868>>>            Set Minimum_Position to 14
97869>>>            Set Label_Col_Offset to 2
97870>>>            Set Label_Justification_Mode to JMode_Right
97871>>>            Set Label to "Add to Studio's Tools Menu:     Major Version"
97872>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
97873>>>            Set Value to FMAC_VERSION
97874>>>            Set peAnchors to anNone
97875>>>        End_Object
97876>>>
97876>>>        Object oStudioMinorVersion_sf is a SpinForm
97878>>>            Set Size to 12 27
97879>>>            Set Location to 18 254
97880>>>            Set Label_Col_Offset to 2
97881>>>            Set Label to "Minor Version"
97882>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
97883>>>            Set Maximum_Position to 9
97884>>>            Set Minimum_Position to 0
97885>>>            Set Value to FMAC_REVISION
97886>>>            Set Label_Justification_Mode to JMode_Right
97887>>>            Set peAnchors to anNone
97888>>>        End_Object
97889>>>
97889>>>    End_Object
97890>>>
97890>>>    Object oOK_btn is a Button
97892>>>        Set Location to 59 207
97893>>>        Set Label to "Add Now"
97894>>>        Set Status_Help to "Add to DataFlex Studio's Tools menu. The Studio version can be selected with the two spinforms. The program gets added to the Studios Tools menu."
97895>>>        Set peAnchors to anTopRight
97896>>>
97896>>>        Procedure OnClick
97899>>>            Integer iRetval iMajorVersion iMinorVersion
97899>>>            String sText sStudioVersion
97899>>>            Get Value of oStudioMajorVersion_sf to iMajorVersion
97900>>>            Get Value of oStudioMinorVersion_sf to iMinorVersion
97901>>>            Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
97902>>>            Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
97903>>>            Case Begin
97903>>>                Case (iRetval = cx_RegKeyAlreadyExist)
97905>>>                    Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
97906>>>                    Break
97907>>>                Case (iRetval = cx_RegKeyCreated)
97910>>>                    Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
97911>>>                    Break
97912>>>                Case (iRetval = cx_RegkeyFailed)
97915>>>                    Move "Failed. Could not create the registry key for adding the program to the DataFlex Studio's Tools menu." to sText
97916>>>                    Break
97917>>>                Case (iRetval = cx_RegKeyVDFKeyDoesNotExist)
97920>>>                    Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
97921>>>                    Break
97922>>>                Case (iRetval = CX_InstalledOkVdfUnder16)
97925>>>                    Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed for an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
97926>>>                    Break
97927>>>            Case End
97927>>>
97927>>>            Send Info_Box sText
97928>>>        End_Procedure
97929>>>    End_Object
97930>>>
97930>>>    Object oCancel_Btn is a Button
97932>>>        Set Label to C_$Close
97933>>>        Set Location to 59 264
97934>>>        Set peAnchors to anBottomRight
97935>>>
97935>>>        Procedure OnClick
97938>>>            Send Close_Panel
97939>>>        End_Procedure
97940>>>
97940>>>    End_Object
97941>>>
97941>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
97944>>>        Boolean bOk bExists bOpen
97944>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath
97944>>>        Handle hoReg hoArray
97944>>>        Integer i iItems iCreated iRetval
97944>>>
97944>>>        Move False to bOk
97945>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
97946>>>        If (sStudioVersion > "17.1") Begin
97948>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
97949>>>        End
97949>>>>
97949>>>
97949>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
97950>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
97951>>>        Get vFolderFormat sProgramPath to sProgramPath
97952>>>        Get psProduct     of (phoWorkspace(ghoApplication)) to sProduct
97953>>>        Get Module_Name to sProgram
97954>>>        Get Create (RefClass(cRegistry)) to hoReg
97955>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
97956>>>
97956>>>        // First check if the VDF version is installed
97956>>>        Get KeyExists of hoReg sStudioPath to bExists
97957>>>        If (bExists = False) Begin
97959>>>            Send Destroy of hoReg
97960>>>            Function_Return cx_RegKeyVDFKeyDoesNotExist
97961>>>        End
97961>>>>
97961>>>
97961>>>        // Then check if any tools have been installed in the Tools Menu.
97961>>>        // If no tools created yet, create the Tools registry key.
97961>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
97962>>>        Get KeyExists of hoReg sStudioPath to bExists
97963>>>        If (bExists = False) Begin
97965>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
97966>>>            Get CreateKey of hoReg sStudioPath to iCreated
97967>>>            If (iCreated <> 0) Begin
97969>>>                Move cx_RegkeyFailed to iRetval
97970>>>            End
97970>>>>
97970>>>            Else Begin
97971>>>                Move True to bExists
97972>>>            End
97972>>>>
97972>>>        End
97972>>>>
97972>>>
97972>>>        If (bExists = True) Begin
97974>>>            Get OpenKey of hoReg sStudioPath to bOk
97975>>>            If (bOk = True) Begin
97977>>>                Get Create (RefClass(Array)) to hoArray
97978>>>                Get GetSubkeys of hoReg hoArray to iItems
97979>>>                Decrement iItems
97980>>>                Move False to bExists
97981>>>                Set pfAccessRights of hoReg to KEY_READ
97982>>>                // Check if the key already exists:
97982>>>                For i from 0 to iItems
97988>>>>
97988>>>                    Get Value of hoArray i to sKey
97989>>>                    Move (sStudioPath + "\" + sKey) to sKey
97990>>>                    Get OpenKey of hoReg sKey to bOpen
97991>>>                    If (bOpen = True) Begin
97993>>>                        Get ReadString of hoReg CS_Name to sValue
97994>>>                        If (sValue = sProduct) Begin
97996>>>                            Move True to bExists
97997>>>                        End
97997>>>>
97997>>>                    End
97997>>>>
97997>>>                Loop
97998>>>>
97998>>>                Send Destroy of hoArray
97999>>>                If (bExists = False) Begin
98001>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
98002>>>                    // We need to create the next key number:
98002>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
98002>>>                    Increment iItems
98003>>>                    Increment iItems
98004>>>                    Get CreateKey of hoReg (sStudioPath + "\" + String(iItems)) to iCreated
98005>>>                    If (iCreated = 0) Begin
98007>>>                        Send WriteString of hoReg CS_Name sProduct
98008>>>                        // From DataFlex 16 and up the params for the Studio's Tools menu changed slightly:
98008>>>                        If (sStudioVersion >= "16.0") Begin
98010>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
98011>>>                            Send WriteString of hoReg CS_CommandLine (psTag(Self))
98012>>>                        End
98012>>>>
98012>>>                        Else Begin
98013>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * psTag(Self))
98014>>>                            Move CX_InstalledOkVdfUnder16 to iRetval
98015>>>                        End
98015>>>>
98015>>>                        Send WriteDword  of hoReg CS_Separator 1
98016>>>                        Move cx_RegKeyCreated to iRetval
98017>>>                    End
98017>>>>
98017>>>                    Else Begin
98018>>>                        Move cx_RegkeyFailed to iRetval
98019>>>                    End
98019>>>>
98019>>>                End
98019>>>>
98019>>>                Else Begin
98020>>>                    Move cx_RegKeyAlreadyExist to iRetval
98021>>>                End
98021>>>>
98021>>>                Send CloseKey of hoReg
98022>>>            End
98022>>>>
98022>>>        End
98022>>>>
98022>>>
98022>>>        Send Destroy of hoReg
98023>>>        Function_Return iRetval
98024>>>    End_Function
98025>>>
98025>>>    Procedure Page Integer iPageObject
98028>>>        Forward Send Page iPageObject
98030>>>        Set Icon to "ActionAddStudio1.ico"
98031>>>    End_Procedure
98032>>>
98032>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
98033>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
98034>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
98035>>>End_Object
98036>        Use CreateDatabase.dg
98036>
98036>        Procedure Activate_About
98039>            Send DoAbout "" "" ("Copyright 2016-2023" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "SQLConnections.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
98040>        End_Procedure
98041>
98041>    End_Object
98042>
98042>    Procedure ShowProgramHelp
98045>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
98046>    End_Procedure
98047>
98047>    On_Key Key_F1 Send ShowProgramHelp
98048>End_Object
98049>
98049>// Check if a SQLConnections.ini file exists;
98049>// else the user needs to setup a Connection ID and login info & save the new connection file.
98049>Procedure CheckIfConnectionExists
98051>    Boolean bIniFileExists
98051>    Get pbIniFileExists of ghoApplication to bIniFileExists
98052>    If (bIniFileExists = False) Begin
98054>        Send ConnectionDoesNotExist of (oSQLMaintainConnection(Client_Id(phoMainPanel(ghoApplication))))
98055>    End
98055>End_Procedure
98056>Send CheckIfConnectionExists
98057>
98057>Start_UI
98058>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 52231
Total Resources: 6
Total Commands : 98057
Total Windows  : 0
Total Pages    : 0
Static Data    : 771633
Message area   : 632790
Total Blocks   : 35297
