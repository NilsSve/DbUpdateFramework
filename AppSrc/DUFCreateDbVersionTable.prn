Compiling Program: C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\DUFCreateDbVersionTable.src
Memory Available: 2147483646
1>    CompilerLevelWarning All On
1>Use DfAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files\DataFlex 20.1\Pkg\dfallent.pkd)
73081>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJStandardCommandBarSystem.pkg)
73081>>>// these are all the packages used in a standard MDI menubar/toolbar system
73081>>>
73081>>>Use cCJCommandBarSystem.pkg
73081>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJStandardMenuItemClasses.pkg)
73081>>>>>Use Dfpanel.pkg
73081>>>>>Use cCJCommandBarSystem.pkg
73081>>>>>Use LanguageText.pkg
73081>>>>>
73081>>>>>
73081>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73082>>>>>    
73082>>>>>    Procedure Construct_Object
73084>>>>>        Forward Send Construct_Object
73086>>>>>        Set psCaption   to C_$CaptionUndo
73087>>>>>        Set psToolTip to C_$ToolTipUndo
73088>>>>>        Set psDescription to C_$DescUndo
73089>>>>>        Set psImage to "ActionUndo.ico"
73090>>>>>        Set pbActiveUpdate to True
73091>>>>>        Set psCategory to C_$CategoryEdit
73092>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73093>>>>>    End_Procedure
73094>>>>>    
73094>>>>>    Procedure OnExecute Variant vCommandBarControl
73096>>>>>        Send Undo of (focus(Self))
73097>>>>>    End_Procedure
73098>>>>>    
73098>>>>>    Function IsEnabled Returns Boolean
73100>>>>>        Boolean bEnabled
73100>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73101>>>>>        Function_Return bEnabled
73102>>>>>    End_Function
73103>>>>>    
73103>>>>>End_Class
73104>>>>>
73104>>>>>
73104>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73105>>>>>    
73105>>>>>    Procedure Construct_Object
73107>>>>>        Forward Send Construct_Object
73109>>>>>        Set psCaption   to C_$CaptionDelete
73110>>>>>        Set psToolTip to C_$ToolTipDelete
73111>>>>>        Set psDescription to C_$DescDelete
73112>>>>>        Set psImage to "actionDelete.ico"
73113>>>>>        Set psShortcut to C_$Key_Delete
73114>>>>>        Set pbActiveUpdate to True
73115>>>>>        Set psCategory to C_$CategoryEdit
73116>>>>>    End_Procedure
73117>>>>>    
73117>>>>>    
73117>>>>>    Procedure OnExecute Variant vCommandBarControl
73119>>>>>        Send Delete of (focus(Self))
73120>>>>>    End_Procedure
73121>>>>>    
73121>>>>>    Function IsEnabled Returns Boolean
73123>>>>>        Boolean bEnabled
73123>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73124>>>>>        Function_Return bEnabled
73125>>>>>    End_Function
73126>>>>>    
73126>>>>>End_Class
73127>>>>>
73127>>>>>
73127>>>>>Class cCJCutMenuItem is a cCJMenuItem
73128>>>>>    
73128>>>>>    Procedure Construct_Object
73130>>>>>        Forward Send Construct_Object
73132>>>>>        Set psCaption   to C_$CaptionCut
73133>>>>>        Set psToolTip to C_$TooltipCut
73134>>>>>        Set psDescription to C_$DescCut
73135>>>>>        Set psImage to "actionCut.ico"
73136>>>>>        Set psShortcut to C_$Key_Ctrl_X
73137>>>>>        Set pbActiveUpdate to True
73138>>>>>        Set psCategory to C_$CategoryEdit
73139>>>>>    End_Procedure
73140>>>>>    
73140>>>>>    
73140>>>>>    Procedure OnExecute Variant vCommandBarControl
73142>>>>>        Send Cut of (focus(Self))
73143>>>>>    End_Procedure
73144>>>>>    
73144>>>>>    Function IsEnabled Returns Boolean
73146>>>>>        Boolean bEnabled
73146>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73147>>>>>        Function_Return bEnabled
73148>>>>>    End_Function
73149>>>>>    
73149>>>>>End_Class
73150>>>>>
73150>>>>>
73150>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73151>>>>>    
73151>>>>>    Procedure Construct_Object
73153>>>>>        Forward Send Construct_Object
73155>>>>>        Set psCaption   to C_$CaptionCopy
73156>>>>>        Set psToolTip to C_$ToolTipCopy
73157>>>>>        Set psDescription to C_$DescCopy
73158>>>>>        Set psImage to "actionCopy.ico"
73159>>>>>        Set psShortcut to C_$Key_Ctrl_C
73160>>>>>        Set pbActiveUpdate to True
73161>>>>>        Set psCategory to C_$CategoryEdit
73162>>>>>    End_Procedure
73163>>>>>    
73163>>>>>    
73163>>>>>    Procedure OnExecute Variant vCommandBarControl
73165>>>>>        Send Copy of (focus(Self))
73166>>>>>    End_Procedure
73167>>>>>    
73167>>>>>    Function IsEnabled Returns Boolean
73169>>>>>        Boolean bEnabled
73169>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73170>>>>>        Function_Return bEnabled
73171>>>>>    End_Function
73172>>>>>    
73172>>>>>End_Class
73173>>>>>
73173>>>>>
73173>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73174>>>>>    
73174>>>>>    Procedure Construct_Object
73176>>>>>        Forward Send Construct_Object
73178>>>>>        Set psCaption   to C_$CaptionPaste
73179>>>>>        Set psToolTip to C_$ToolTipPaste
73180>>>>>        Set psDescription to C_$DescPaste
73181>>>>>        Set psImage to "actionPaste.ico"
73182>>>>>        Set pbActiveUpdate to True
73183>>>>>        Set psShortcut to C_$Key_Ctrl_V
73184>>>>>        Set psCategory to C_$CategoryEdit
73185>>>>>    End_Procedure
73186>>>>>    
73186>>>>>    
73186>>>>>    Procedure OnExecute Variant vCommandBarControl
73188>>>>>        Send Paste of (focus(Self))
73189>>>>>    End_Procedure
73190>>>>>    
73190>>>>>    Function IsEnabled Returns Boolean
73192>>>>>        Boolean bEnabled
73192>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73193>>>>>        Function_Return bEnabled
73194>>>>>    End_Function
73195>>>>>    
73195>>>>>End_Class
73196>>>>>
73196>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73197>>>>>    
73197>>>>>    Procedure Construct_Object
73199>>>>>        Forward Send Construct_Object
73201>>>>>        Set psCaption   to C_$CaptionSelectAll
73202>>>>>        Set psToolTip to C_$ToolTipSelectAll
73203>>>>>        Set psDescription to C_$DescSelectAll
73204>>>>>        Set pbActiveUpdate to True
73205>>>>>        Set psShortcut to C_$Key_Ctrl_A
73206>>>>>        Set psCategory to C_$CategoryEdit
73207>>>>>    End_Procedure
73208>>>>>    
73208>>>>>    
73208>>>>>    Procedure OnExecute Variant vCommandBarControl
73210>>>>>        Send Select_All of (focus(Self))
73211>>>>>    End_Procedure
73212>>>>>    
73212>>>>>    Function IsEnabled Returns Boolean
73214>>>>>        Boolean bEnabled
73214>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73215>>>>>        Function_Return bEnabled
73216>>>>>    End_Function
73217>>>>>    
73217>>>>>End_Class
73218>>>>>
73218>>>>>
73218>>>>>Class cCJExitMenuItem is a cCJMenuItem
73219>>>>>    
73219>>>>>    Procedure Construct_Object
73221>>>>>        Forward Send Construct_Object
73223>>>>>        Set psCaption to C_$CaptionExit
73224>>>>>        Set psToolTip to C_$ToolTipExit
73225>>>>>        Set psDescription to C_$ToolTipExit
73226>>>>>        Set psShortcut to C_$Key_Alt_F4
73227>>>>>        Set psCategory to C_$CategoryFile
73228>>>>>    End_Procedure
73229>>>>>    
73229>>>>>    Procedure OnExecute Variant vCommandBarControl
73231>>>>>        Send Exit_Application of Desktop
73232>>>>>    End_Procedure
73233>>>>>    
73233>>>>>End_Class
73234>>>>>
73234>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73235>>>>>    
73235>>>>>    Procedure Construct_Object
73237>>>>>        Forward Send Construct_Object
73239>>>>>        Set psCaption to C_$CaptionHelp
73240>>>>>        Set psDescription to C_$ToolTipHelp
73241>>>>>        Set psToolTip to C_$DescHelp
73242>>>>>        Set psImage to "ActionHelp.ico"
73243>>>>>        Set psShortcut to "F1"
73244>>>>>        Set psCategory to C_$CategoryHelp
73245>>>>>    End_Procedure
73246>>>>>    
73246>>>>>    Procedure OnExecute Variant vCommandBarControl
73248>>>>>        Send Help of (Focus(Self))
73249>>>>>    End_Procedure
73250>>>>>    
73250>>>>>End_Class
73251>>>>>
73251>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73252>>>>>    
73252>>>>>    Procedure Construct_Object
73254>>>>>        Forward Send Construct_Object
73256>>>>>        Set psCaption to C_$CaptionAddStatusbar
73257>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73258>>>>>        Set psDescription to  C_$DescAddStatusbar
73259>>>>>        Set psCategory to C_$CategoryWindow
73260>>>>>    End_Procedure
73261>>>>>    
73261>>>>>    Procedure OnExecute Variant vCommandBarControl
73263>>>>>        Handle hoCommandBars hoClientArea
73263>>>>>        Get CommandBarSystemObject to hoCommandBars
73264>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73265>>>>>        If hoClientArea Begin
73267>>>>>            // the clientarea's parent panel has message
73267>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73268>>>>>        End
73268>>>>>>
73268>>>>>    End_Procedure
73269>>>>>    
73269>>>>>    Function IsChecked Returns Boolean
73271>>>>>        Boolean bOn
73271>>>>>        Handle hoCommandBars hoClientArea
73271>>>>>        Get CommandBarSystemObject to hoCommandBars
73272>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73273>>>>>        If hoClientArea Begin
73275>>>>>            // the clientarea's parent panel has message
73275>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73276>>>>>        End
73276>>>>>>
73276>>>>>        Function_Return bOn
73277>>>>>    End_Function
73278>>>>>End_Class
73279>>>>>
73279>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73280>>>>>    
73280>>>>>    Procedure Construct_Object
73282>>>>>        Forward Send Construct_Object
73284>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73285>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73286>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73287>>>>>        Set psCategory to C_$CategoryWindow
73288>>>>>    End_Procedure
73289>>>>>    
73289>>>>>    Procedure OnExecute Variant vCommandBarControl
73291>>>>>        Handle hoCommandBars hoClientArea
73291>>>>>        Get CommandBarSystemObject to hoCommandBars
73292>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73293>>>>>        If hoClientArea Begin
73295>>>>>            // the clientarea's parent panel has message
73295>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73296>>>>>        End
73296>>>>>>
73296>>>>>    End_Procedure
73297>>>>>    
73297>>>>>    Function IsChecked Returns Boolean
73299>>>>>        Boolean bOn
73299>>>>>        Handle hoCommandBars hoClientArea
73299>>>>>        Get CommandBarSystemObject to hoCommandBars
73300>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73301>>>>>        If hoClientArea Begin
73303>>>>>            // the clientarea's parent panel has message
73303>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73304>>>>>        End
73304>>>>>>
73304>>>>>        Function_Return bOn
73305>>>>>    End_Function
73306>>>>>End_Class
73307>>>>>
73307>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73308>>>>>    
73308>>>>>    Procedure Construct_Object
73310>>>>>        Forward Send Construct_Object
73312>>>>>        Set psCaption to C_$CaptionRestoreMenus
73313>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73314>>>>>        Set psDescription to C_$DescRestoreMenus
73315>>>>>        Set psCategory to C_$CategoryWindow
73316>>>>>    End_Procedure
73317>>>>>    
73317>>>>>    Procedure OnExecute Variant vCommandBarControl
73319>>>>>        Handle hoCommandBars
73319>>>>>        Get CommandBarSystemObject to hoCommandBars
73320>>>>>        Send RestoreLayout of hoCommandBars
73321>>>>>    End_Procedure
73322>>>>>    
73322>>>>>End_Class
73323>>>>>
73323>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73324>>>>>    
73324>>>>>    Procedure Construct_Object
73326>>>>>        Forward Send Construct_Object
73328>>>>>        Set psCaption to C_$CaptionCascade
73329>>>>>        Set psToolTip to C_$ToolTipCascade
73330>>>>>        Set psDescription to  C_$DescCascade
73331>>>>>        Set psImage to "ActionCascade.ico"
73332>>>>>        Set psCategory to C_$CategoryWindow
73333>>>>>    End_Procedure
73334>>>>>    
73334>>>>>    Procedure OnExecute Variant vCommandBarControl
73336>>>>>        Handle hoCommandBars hoClientArea
73336>>>>>        Get CommandBarSystemObject to hoCommandBars
73337>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73338>>>>>        If hoClientArea Begin
73340>>>>>            Send Cascade_Windows of hoClientArea
73341>>>>>        End
73341>>>>>>
73341>>>>>    End_Procedure
73342>>>>>End_Class
73343>>>>>
73343>>>>>Class cCJTileHorizontally is a cCJMenuItem
73344>>>>>    
73344>>>>>    Procedure Construct_Object
73346>>>>>        Forward Send Construct_Object
73348>>>>>        Set psCaption to C_$CaptionTileHorizontally
73349>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73350>>>>>        Set psDescription to  C_$DescTileHorizontally
73351>>>>>        Set psImage to "ActionTileHorizontally.ico"
73352>>>>>        Set psCategory to C_$CategoryWindow
73353>>>>>    End_Procedure
73354>>>>>    
73354>>>>>    Procedure OnExecute Variant vCommandBarControl
73356>>>>>        Handle hoCommandBars hoClientArea
73356>>>>>        Get CommandBarSystemObject to hoCommandBars
73357>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73358>>>>>        If hoClientArea Begin
73360>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73361>>>>>        End
73361>>>>>>
73361>>>>>    End_Procedure
73362>>>>>End_Class
73363>>>>>
73363>>>>>Class cCJTileVertically is a cCJMenuItem
73364>>>>>    
73364>>>>>    Procedure Construct_Object
73366>>>>>        Forward Send Construct_Object
73368>>>>>        Set psCaption to C_$CaptionTileVertically
73369>>>>>        Set psToolTip to C_$ToolTipTileVertically
73370>>>>>        Set psDescription to  C_$DescTileVertically
73371>>>>>        Set psImage to "ActionTileVertically.ico"
73372>>>>>        Set psCategory to C_$CategoryWindow
73373>>>>>    End_Procedure
73374>>>>>    
73374>>>>>    Procedure OnExecute Variant vCommandBarControl
73376>>>>>        Handle hoCommandBars hoClientArea
73376>>>>>        Get CommandBarSystemObject to hoCommandBars
73377>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73378>>>>>        If hoClientArea Begin
73380>>>>>            Send Tile_Windows_Vertical of hoClientArea
73381>>>>>        End
73381>>>>>>
73381>>>>>    End_Procedure
73382>>>>>End_Class
73383>>>>>
73383>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73384>>>>>    
73384>>>>>    Procedure Construct_Object
73386>>>>>        Forward Send Construct_Object
73388>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73389>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73390>>>>>        Set psDescription to  C_$DescMinimizeWindows
73391>>>>>        Set psCategory to C_$CategoryWindow
73392>>>>>    End_Procedure
73393>>>>>    
73393>>>>>    Procedure OnExecute Variant vCommandBarControl
73395>>>>>        Handle hoCommandBars hoClientArea
73395>>>>>        Get CommandBarSystemObject to hoCommandBars
73396>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73397>>>>>        If hoClientArea Begin
73399>>>>>            // the clientarea's parent panel has message
73399>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73400>>>>>        End
73400>>>>>>
73400>>>>>    End_Procedure
73401>>>>>End_Class
73402>>>>>
73402>>>>>
73402>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73403>>>>>    
73403>>>>>    Procedure Construct_Object
73405>>>>>        Forward Send Construct_Object
73407>>>>>        Set psCaption to C_$CaptionRestoreWindows
73408>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73409>>>>>        Set psDescription to  C_$DescRestoreWindows
73410>>>>>        Set psCategory to C_$CategoryWindow
73411>>>>>    End_Procedure
73412>>>>>    
73412>>>>>    Procedure OnExecute Variant vCommandBarControl
73414>>>>>        Handle hoCommandBars hoClientArea
73414>>>>>        Get CommandBarSystemObject to hoCommandBars
73415>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73416>>>>>        If hoClientArea Begin
73418>>>>>            // the clientarea's parent panel has message
73418>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73419>>>>>        End
73419>>>>>>
73419>>>>>    End_Procedure
73420>>>>>End_Class
73421>>>>>
73421>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73422>>>>>    
73422>>>>>    Procedure Construct_Object
73424>>>>>        Forward Send Construct_Object
73426>>>>>        Set psCaption to C_$CaptionArrangeIcons
73427>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73428>>>>>        Set psDescription to  C_$DescArrangeIcons
73429>>>>>        Set psCategory to C_$CategoryWindow
73430>>>>>    End_Procedure
73431>>>>>    
73431>>>>>    Procedure OnExecute Variant vCommandBarControl
73433>>>>>        Handle hoCommandBars hoClientArea
73433>>>>>        Get CommandBarSystemObject to hoCommandBars
73434>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73435>>>>>        If hoClientArea Begin
73437>>>>>            Send Arrange_Icons of hoClientArea
73438>>>>>        End
73438>>>>>>
73438>>>>>    End_Procedure
73439>>>>>    
73439>>>>>End_Class
73440>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJAboutMenuItem.pkg)
73440>>>>>Use cCJCommandBarSystem.pkg
73440>>>>>Use LanguageText.pkg
73440>>>>>
73440>>>>>// It is expected that if you use this class that you provide an about object that is
73440>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73440>>>>>// because you may wish to create your own custom about package.
73440>>>>>
73440>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73441>>>>>
73441>>>>>    Procedure Construct_Object
73443>>>>>        Forward Send Construct_Object
73445>>>>>        Set psCaption to C_$CaptionAbout
73446>>>>>        Set psDescription to C_$ToolTipAbout
73447>>>>>        Set psToolTip to C_$DescAbout
73448>>>>>        Set psImage to "ActionAbout.ico"
73449>>>>>        Set psCategory to C_$CategoryHelp
73450>>>>>    End_Procedure
73451>>>>>    
73451>>>>>    Procedure OnExecute Variant vCommandBarControl
73453>>>>>        Handle hoCommandBars hoClientArea
73453>>>>>        Get CommandBarSystemObject to hoCommandBars
73454>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73455>>>>>        If hoClientArea Begin
73457>>>>>            Send Activate_About of hoClientArea
73458>>>>>        End
73458>>>>>>
73458>>>>>    End_Procedure
73459>>>>>
73459>>>>>End_Class
73460>>>>>
73460>>>>>
73460>>>Use cCJDeoMenuItemClasses.pkg
73460>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJMDIWindowsMenuItem.pkg)
73460>>>>>Use cCJCommandBarSystem.pkg
73460>>>>>
73460>>>>>Register_Function Client_ID Returns Integer
73460>>>>>
73460>>>>>// only used by cCJMDIWIndowsMenuItem
73460>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73461>>>>>    
73461>>>>>    Procedure Construct_Object
73463>>>>>        Forward Send Construct_Object
73465>>>>>        Property Handle phWindow 0 // object id of view
73466>>>>>        Set pbControlFlagNoMovable to True
73467>>>>>        Set pbActiveUpdate to True
73468>>>>>    End_Procedure
73469>>>>>    
73469>>>>>    Procedure OnExecute Variant vCommandBarControl
73471>>>>>        Handle hWindow
73471>>>>>        Get phWindow to hWindow
73472>>>>>        Send Activate_View of hWindow
73473>>>>>    End_Procedure
73474>>>>>    
73474>>>>>End_Class
73475>>>>>
73475>>>>>
73475>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73476>>>>>    
73476>>>>>    Procedure Construct_Object
73478>>>>>        Forward Send Construct_Object
73480>>>>>        Property Handle[] phArrayOfWindows
73481>>>>>        Set peControlType to xtpControlPopup
73482>>>>>        Set psCategory to C_$CategoryWindow
73483>>>>>    End_Procedure
73484>>>>>    
73484>>>>>    // This adds MDI windows to the existing menu items.
73484>>>>>    // This removes any existing windows menus and always adds a new set to the end
73484>>>>>    
73484>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73486>>>>>        Handle  hClientArea hView
73486>>>>>        String  sLabel
73486>>>>>        Integer i iWindows
73486>>>>>        Handle[] hArrayOfWindows
73487>>>>>        Variant vItem
73487>>>>>        
73487>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73487>>>>>        // also assume that destroying an action removes all menu instances of that action
73487>>>>>        Get phArrayOfWindows to hArrayOfWindows
73488>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73489>>>>>        For i from 0 to (iWindows-1)
73495>>>>>>
73495>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73496>>>>>        Loop
73497>>>>>>
73497>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73498>>>>>        
73498>>>>>        // Add all views to this menu. Create the action and add the item
73498>>>>>        Move 0 to i
73499>>>>>        Get Client_Id to hClientArea // object id of client area
73500>>>>>        If (hClientArea > 0) Begin
73502>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73503>>>>>            While (hView <> 0)
73507>>>>>                If (Active_State(hView)) Begin
73509>>>>>                    // create the action
73509>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73510>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73511>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73512>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73513>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73515>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73516>>>>>                    End
73516>>>>>>
73516>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73517>>>>>                    If (i=0) Begin
73519>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73520>>>>>                    End
73520>>>>>>
73520>>>>>                    // Create a menu item for this action
73520>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73521>>>>>                    Increment i
73522>>>>>                End
73522>>>>>>
73522>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73523>>>>>            Loop
73524>>>>>>
73524>>>>>        End
73524>>>>>>
73524>>>>>        
73524>>>>>        Set phArrayOfWindows to hArrayOfWindows
73525>>>>>        
73525>>>>>    End_Procedure
73526>>>>>    
73526>>>>>End_Class
73527>Use Dfspnfrm.pkg
73527>Use Dfcursor.pkg
73527>Use Dfline.pkg
73527>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\Libraries\vwin32fh\vWin32fh.pkg)
73527>>>// This code is part of VDF GUIdance
73527>>>// Visit us @ http://www.vdf-guidance.com
73527>>>// e-Mail us @ info@vdf-guidance.com
73527>>>// VDF GUIdance is a mutual project of
73527>>>// Frank Vandervelpen - Vandervelpen Systems and
73527>>>// Wil van Antwerpen  - Antwise Solutions
73527>>>// All software source code should be used <<AS IS>> without any warranty.
73527>>>//
73527>>>//
73527>>>// *** Windows 32bit file handling wrapper class ***
73527>>>//
73527>>>
73527>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
73527>>>//                   This may be painfull for some of you, but it was really needed as it was
73527>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
73527>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
73527>>>//
73527>>>// The used naming-convention is:
73527>>>//     - a prefix of "vWin32_" for every external function declaration
73527>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
73527>>>//
73527>>>// By using this we are guarding ourselves for conflicts with variable declarations
73527>>>// of DataAccess in the future.
73527>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
73527>>>//
73527>>>// mm-dd-yyyy Author Description
73527>>>//
73527>>>//                   vSHGetFolderPath added to retrieve the new shell folders
73527>>>//                   vGetWindowsDirectory
73527>>>//
73527>>>//                   vGetTempFileName
73527>>>//                   vGetTempPath
73527>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
73527>>>//                   This is an absolute need for WebApp. We expect you to handle the
73527>>>//                   error in your application anyways. Changed this for:
73527>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
73527>>>// 03-02-2002 **WvA: vRemoveDirectory added
73527>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
73527>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
73527>>>//                   It is renamed too avoid this.
73527>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
73527>>>//                   function vSelectedFileName is now just SelectedFileName
73527>>>//                   Removed the local keyword in the variable declarations
73527>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
73527>>>//                   created file-open dialog
73527>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
73527>>>//                   in that it didn't exactly return the correct filename of the file created.
73527>>>//                   This has now been taken care of.
73527>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
73527>>>//                   These declarations are now included from the vWin32fh header file.
73527>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
73527>>>//                   Before today one could always undo the operation, as of now you cannot as
73527>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
73527>>>//                   Since i don't really expect someone to use that feature it has been removed.
73527>>>//                   One can however restore to the old way of handling by simply calling the
73527>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
73527>>>//                   filehandling operations
73527>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
73527>>>//                   as well as the StringFromRightOfChar function.
73527>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
73527>>>//                   DISABLED now as testing shows that it does not work as advertised...
73527>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
73527>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
73527>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
73527>>>//                   extended characters are treated ok too.
73527>>>//                   Reported by Flemming from
73527>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
73527>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
73527>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
73527>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
73527>>>//                   Added vSelectSavefile function to create a file save dialog
73527>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
73527>>>//                   Added vParentPath function to retrieve the parent "node" of a path
73527>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
73527>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
73527>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
73527>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
73527>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
73527>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
73527>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
73527>>>
73527>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
73527>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\Libraries\vwin32fh\cvFileDialogs.pkg)
73527>>>>>//***************************************************************************
73527>>>>>//*
73527>>>>>//* Class:        cvSaveAsDialog
73527>>>>>//* Package Name: cvFileDialogs.pkg
73527>>>>>//*
73527>>>>>//***************************************************************************
73527>>>>>
73527>>>>>Use File_dlg.pkg
73527>>>>>
73527>>>>>// *WvA: 13-01-1999 Created
73527>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
73527>>>>>// This function opens the Windows standard file open dialog and returns the selected
73527>>>>>// file_name.
73527>>>>>Class cvSelectFile_Dialog is an OpenDialog
73528>>>>>
73528>>>>>    Procedure Construct_Object Integer iImage_Id
73530>>>>>        Forward Send Construct_Object iImage_Id
73532>>>>>        Set HideReadOnly_State to True
73533>>>>>    End_Procedure
73534>>>>>
73534>>>>>    Function SelectedFileName Returns String
73536>>>>>        String sFileName
73536>>>>>        Move "" to sFileName
73537>>>>>        If (Show_Dialog(Self)) Begin
73539>>>>>            Move (RTrim(File_Name(Self))) to sFileName
73540>>>>>        End
73540>>>>>>
73540>>>>>        Function_Return sFileName
73541>>>>>    End_Function
73542>>>>>End_Class
73543>>>>>
73543>>>>>// *WvA: 13-01-1999 Created
73543>>>>>// This function opens the Windows standard file open dialog and returns the selected
73543>>>>>// file_name. Returns '' if the user didn't make a selection.
73543>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
73543>>>>>//                   file-open dialog
73543>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
73545>>>>>    String sSelectedFile
73545>>>>>    Integer hoOpenFileDialog
73545>>>>>
73545>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
73547>>>>>
73547>>>>>        Set Dialog_Caption    to sCaptionText
73548>>>>>        Set Filter_String     to sSupportedFileTypes
73549>>>>>        Set Initial_Folder    to sInitialFolder
73550>>>>>
73550>>>>>        Move Self       to hoOpenFileDialog
73551>>>>>    End_Object
73552>>>>>
73552>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
73553>>>>>    Send Destroy_Object to hoOpenFileDialog
73554>>>>>    Function_Return sSelectedFile
73555>>>>>End_Function
73556>>>>>
73556>>>>>Class cvSaveAsDialog is a SaveAsDialog
73557>>>>>
73557>>>>>    Procedure Construct_Object
73559>>>>>        Forward Send Construct_Object
73561>>>>>        Set HideReadOnly_State to True
73562>>>>>    End_Procedure
73563>>>>>
73563>>>>>    Function SelectedFileName Returns String
73565>>>>>        String sFileName
73565>>>>>        Move "" to sFileName
73566>>>>>        If (Show_Dialog(Self)) Begin
73568>>>>>            Move (RTrim(File_Name(Self))) to sFileName
73569>>>>>        End
73569>>>>>>
73569>>>>>        Function_Return sFileName
73570>>>>>    End_Function
73571>>>>>
73571>>>>>End_Class
73572>>>>>
73572>>>>>// Added optional default filename as suggested by Nils
73572>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
73574>>>>>    String sSelectedFile
73574>>>>>    Integer hoDialog
73574>>>>>
73574>>>>>    Move "" to sSelectedFile
73575>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
73576>>>>>    If (hoDialog) Begin
73578>>>>>    //Set NoChangeDir_State Of hoDialog To True
73578>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
73579>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
73580>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
73581>>>>>        If (Num_Arguments = 4) Begin
73583>>>>>            Set File_Title        of hoDialog to sDefaultFileName
73584>>>>>        End
73584>>>>>>
73584>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
73585>>>>>        Send Destroy of hoDialog
73586>>>>>    End
73586>>>>>>
73586>>>>>    Function_Return sSelectedFile
73587>>>>>End_Function
73588>>>Use Seq_chnl.pkg
73588>>>
73588>>>Use windows.pkg
73588>>>Use Dll.pkg
73588>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF20\DbUpdateFramework2.0\Libraries\vwin32fh\vwin32fh.h)
73588>>>>>//TH-Header
73588>>>>>//*****************************************************************************************
73588>>>>>// Copyright (c)  2004 KURANT Project
73588>>>>>// All rights reserved.
73588>>>>>//
73588>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
73588>>>>>// $ProjectName : Windows 32 bits file handling
73588>>>>>// $Authors     : Wil van Antwerpen
73588>>>>>// $Created     : 19.02.2004  19:25
73588>>>>>// $Type        : BSD (as in do with it whatever you like)
73588>>>>>//
73588>>>>>// Contents:
73588>>>>>//  This file contains the Windows API external function call definitions and
73588>>>>>//  constants as they are used in the vWin32fh package.
73588>>>>>//*****************************************************************************************
73588>>>>>//TH-RevisionStart
73588>>>>>//TH-RevisionEnd
73588>>>>>
73588>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
73588>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
73588>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
73588>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
73588>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
73588>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
73588>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
73588>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
73588>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
73588>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
73588>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
73588>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
73588>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
73588>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
73588>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
73588>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
73588>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
73588>>>>>
73588>>>>>
73588>>>>>Define vMax_Path     For |CI260
73588>>>>>Define vMinChar      For |CI$80
73588>>>>>Define vMaxChar      For |CI$7F
73588>>>>>Define vMinShort     For |CI$8000
73588>>>>>Define vMaxShort     For |CI$7FFF
73588>>>>>Define vMinLong      For |CI$80000000
73588>>>>>Define vMaxLong      For |CI$7FFFFFFF
73588>>>>>Define vMaxByte      For |CI$FF
73588>>>>>Define vMaxWord      For |CI$FFFF
73588>>>>>Define vMaxDword     For |CI$FFFFFFFF
73588>>>>>
73588>>>>>
73588>>>>>
73588>>>>>// For FindFirstFile
73588>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
73588>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
73588>>>>>Define vERROR_NO_MORE_FILES    For |CI18
73588>>>>>
73588>>>>>// The defines below can be used to find out what kind of error has occurred if
73588>>>>>// the API-call ShellExecute is used.
73588>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
73588>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
73588>>>>>Define vERROR_BAD_FORMAT       For |CI0011
73588>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
73588>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
73588>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
73588>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
73588>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
73588>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
73588>>>>>Define vSE_ERR_FNF             For |CI0002
73588>>>>>Define vSE_ERR_NOASSOC         For |CI0031
73588>>>>>Define vSE_ERR_OOM             For |CI0008
73588>>>>>Define vSE_ERR_PNF             For |CI0003
73588>>>>>Define vSE_ERR_SHARE           For |CI0026
73588>>>>>
73588>>>>>
73588>>>>>// C-Structure
73588>>>>>//typedef struct _browseinfo {
73588>>>>>//    HWND hwndOwner;
73588>>>>>//    LPCITEMIDLIST pidlRoot;
73588>>>>>//    LPSTR pszDisplayName;
73588>>>>>//    LPCSTR lpszTitle;
73588>>>>>//    UINT ulFlags;
73588>>>>>//    BFFCALLBACK lpfn;
73588>>>>>//    LPARAM lParam;
73588>>>>>//    int iImage;
73588>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
73588>>>>>
73588>>>>>//declare C structure struct_browseinfo
73588>>>>>//as documented in MSDN under Windows Shell API
73588>>>>>Struct tvBrowseInfo
73588>>>>>  Handle    hWndOwner
73588>>>>>  Pointer   pIDLRoot
73588>>>>>  Pointer   pszDisplayName
73588>>>>>  Pointer   lpszTitle
73588>>>>>  dWord     ulFlags
73588>>>>>  Pointer   lpfnCallback
73588>>>>>  dWord     lParam
73588>>>>>  DWord     iImage
73588>>>>>End_Struct // tvBrowseInfo
73588>>>>>
73588>>>>>// Browsing for directory.
73588>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
73588>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
73588>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
73588>>>>>                                            // The callback function can set the status text by
73588>>>>>                                            // sending messages to the dialog box.
73588>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
73588>>>>>
73588>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
73588>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
73588>>>>>
73588>>>>>// message from browser
73588>>>>>//Define BFFM_INITIALIZED        1
73588>>>>>//Define BFFM_SELCHANGED         2
73588>>>>>
73588>>>>>// messages to browser
73588>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
73588>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
73588>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
73588>>>>>
73588>>>>>
73588>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
73589>>>>>
73589>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
73590>>>>>
73590>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
73591>>>>>
73591>>>>>
73591>>>>>
73591>>>>>
73591>>>>>Struct tvSecurity_attributes
73591>>>>>  DWord   nLength
73591>>>>>  Pointer lpDescriptor
73591>>>>>  Integer bInheritHandle
73591>>>>>End_Struct // tvSecurity_attributes
73591>>>>>
73591>>>>>//nLength:
73591>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
73591>>>>>// SECURITY_ATTRIBUTES structure.
73591>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
73591>>>>>// value of the nLength member. However, an application should still set it properly.
73591>>>>>// That ensures current, future, and cross-platform compatibility.
73591>>>>>//
73591>>>>>//lpSecurityDescriptor:
73591>>>>>// Points to a security descriptor for the object that controls the sharing of it.
73591>>>>>// If NULL is specified for this member, the object may be assigned the default security
73591>>>>>// descriptor of the calling process.
73591>>>>>//
73591>>>>>//bInheritHandle:
73591>>>>>// Specifies whether the returned handle is inherited when a new process is created.
73591>>>>>// If this member is TRUE, the new process inherits the handle.
73591>>>>>
73591>>>>>
73591>>>>>// BOOL CreateDirectory(
73591>>>>>//    LPCTSTR lpPathName,
73591>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
73591>>>>>//   );
73591>>>>>//
73591>>>>>// lpPathName
73591>>>>>//  Points to a null-terminated string that specifies the path of the directory
73591>>>>>//  to be created.
73591>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
73591>>>>>//  This limit is related to how the CreateDirectory function parses paths.
73591>>>>>// lpSecurityAttributes
73591>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
73591>>>>>//  determines whether the returned handle can be inherited by child processes.
73591>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
73591>>>>>// Returns:
73591>>>>>//  If the function succeeds, the return value is nonzero.
73591>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
73591>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
73592>>>>>
73592>>>>>
73592>>>>>// lpPathName
73592>>>>>//  Points to a null-terminated string that specifies the path of the directory
73592>>>>>//  to be removed.
73592>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
73592>>>>>// Returns:
73592>>>>>//  If the function succeeds, the return value is nonzero.
73592>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
73592>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
73593>>>>>
73593>>>>>
73593>>>>>
73593>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
73593>>>>>// executable file or a document file.
73593>>>>>//
73593>>>>>// Operation can be one of the following:
73593>>>>>//    "OPEN"  The function opens the file specified by lpFile.
73593>>>>>//            The file can be an executable file or a document file.
73593>>>>>//            The file can be a folder to open.
73593>>>>>//    "PRINT" The function prints the file specified by lpFile.
73593>>>>>//            The file should be a document file. If the file is an executable file,
73593>>>>>//            the function opens the file, as if "open" had been specified.
73593>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
73593>>>>>//
73593>>>>>// Return Values:
73593>>>>>//
73593>>>>>// If the function succeeds, the return value is the instance handle of the application that
73593>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
73593>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
73593>>>>>//
73593>>>>>// The following table lists these error values:
73593>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
73593>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
73593>>>>>// Public Const ERROR_BAD_FORMAT = 11&
73593>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
73593>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
73593>>>>>// Public Const SE_ERR_DDEBUSY = 30
73593>>>>>// Public Const SE_ERR_DDEFAIL = 29
73593>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
73593>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
73593>>>>>// Public Const SE_ERR_FNF = 2
73593>>>>>// Public Const SE_ERR_NOASSOC = 31
73593>>>>>// Public Const SE_ERR_OOM = 8
73593>>>>>// Public Const SE_ERR_PNF = 3
73593>>>>>// Public Const SE_ERR_SHARE = 26
73593>>>>>
73593>>>>>
73593>>>>>
73593>>>>>// Code to open the program that is associated with the selected file.
73593>>>>>//
73593>>>>>// External function call used in Procedure DoStartDocument
73593>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
73594>>>>>
73594>>>>>
73594>>>>>
73594>>>>>
73594>>>>>Define vFO_MOVE                For |CI$0001
73594>>>>>Define vFO_COPY                For |CI$0002
73594>>>>>Define vFO_DELETE              For |CI$0003
73594>>>>>Define vFO_RENAME              For |CI$0004
73594>>>>>
73594>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
73594>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
73594>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
73594>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
73594>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
73594>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
73594>>>>>                                          // Must be freed using SHFreeNameMappings
73594>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
73594>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
73594>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
73594>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
73594>>>>>
73594>>>>>Struct tvShFileOpStruct
73594>>>>>  Handle  hWnd
73594>>>>>  Integer wFunc
73594>>>>>  Pointer pFrom
73594>>>>>  Pointer pTo
73594>>>>>  Short   fFlags
73594>>>>>  Short   fAnyOperationsAborted
73594>>>>>  Pointer hNameMappings
73594>>>>>  Pointer lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
73594>>>>>End_Struct // tvShFileOpStruct
73594>>>>>
73594>>>>>// hwnd
73594>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
73594>>>>>
73594>>>>>// wFunc
73594>>>>>//   Operation to perform. This member can be one of the following values:
73594>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
73594>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
73594>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
73594>>>>>//     FO_RENAME   Renames the files specified by pFrom.
73594>>>>>
73594>>>>>// pFrom
73594>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
73594>>>>>//   be null-separated. The list of names must be double null-terminated.
73594>>>>>
73594>>>>>// pTo
73594>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
73594>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
73594>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
73594>>>>>//   double null-terminated.
73594>>>>>
73594>>>>>// fAnyOperationsAborted
73594>>>>>//   Value that receives TRUE if the user aborted any file operations before they
73594>>>>>//   were completed or FALSE otherwise.
73594>>>>>
73594>>>>>
73594>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
73594>>>>>// This can be a file or a folder.
73594>>>>>// With thanks to Andrew S Kaplan
73594>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
73595>>>>>
73595>>>>>
73595>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
73595>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
73596>>>>>
73596>>>>>
73596>>>>>
73596>>>>>// Courtesy Of Vincent Oorsprong
73596>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
73596>>>>>//   Pointer lpPathName ;
73596>>>>>//   Pointer lpPrefixString ;
73596>>>>>//   Integer uUnique ;
73596>>>>>//   Pointer lpTempFileName ;
73596>>>>>//   Returns Integer
73596>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
73596>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
73597>>>>>
73597>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
73598>>>>>
73598>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
73599>>>>>
73599>>>>>// from:
73599>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
73599>>>>>//
73599>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
73599>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
73599>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
73599>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
73599>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
73599>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
73599>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
73599>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
73599>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
73599>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
73599>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
73599>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
73599>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
73599>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
73599>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
73599>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
73599>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
73599>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
73599>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
73599>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
73599>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
73599>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
73599>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
73599>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
73599>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
73599>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
73599>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
73599>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
73599>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
73599>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
73599>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
73599>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
73599>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
73599>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
73599>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
73599>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
73599>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
73599>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
73599>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
73599>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
73599>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
73599>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
73599>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
73599>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
73599>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
73599>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
73599>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
73599>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
73599>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
73599>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
73599>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
73599>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
73599>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
73599>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
73599>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
73599>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
73599>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
73599>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
73599>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
73599>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
73599>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
73599>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
73599>>>>>
73599>>>>>
73599>>>>>//HRESULT SHGetFolderPath(
73599>>>>>//    HWND hwndOwner,
73599>>>>>//    int nFolder,
73599>>>>>//    HANDLE hToken,
73599>>>>>//    DWORD dwFlags,
73599>>>>>//    LPTSTR pszPath
73599>>>>>//);
73599>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
73599>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
73599>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
73599>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
73599>>>>>// If that fails, it will try to simulate the appropriate behavior.
73599>>>>>//
73599>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
73600>>>>>
73600>>>>>
73600>>>>>
73600>>>>>Struct tvWin32FindData
73600>>>>> Dword            dwFileAttributes
73600>>>>> Dword            ftCreationLowDateTime
73600>>>>> Dword            ftCreationHighDateTime
73600>>>>> dword            ftLastAccessLowDateTime
73600>>>>> Dword            ftLastAccessHighDateTime
73600>>>>> Dword            ftLastWriteLowDateTime
73600>>>>> Dword            ftLastWriteHighDateTime
73600>>>>> Dword            nFileSizeHigh
73600>>>>> Dword            nFileSizeLow
73600>>>>> Dword            dwReserved0
73600>>>>> Dword            dwReserved1
73600>>>>> UChar[vMax_Path] cFileName
73600>>>>> UChar[14]        cAlternateFileName
73600>>>>>End_Struct
73600>>>>>
73600>>>>>// Courtesy Of Vincent Oorsprong
73600>>>>>// lpFileName      : address of name of file to search for
73600>>>>>// lpFindFileData  : address of returned information
73600>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
73601>>>>>
73601>>>>>// Courtesy Of Vincent Oorsprong
73601>>>>>// hFindFile       : handle of search
73601>>>>>// lpFindFileData  : address of structure for data on found file
73601>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
73602>>>>>
73602>>>>>//
73602>>>>>// Unicode equivalents
73602>>>>>//
73602>>>>>// lpFileName      : address of name of file to search for
73602>>>>>// lpFindFileData  : address of returned information
73602>>>>>External_function vWin32W_FindFirstFile "FindFirstFileW"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
73603>>>>>
73603>>>>>// hFindFile       : handle of search
73603>>>>>// lpFindFileData  : address of structure for data on found file
73603>>>>>External_function vWin32W_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
73604>>>>>
73604>>>>>
73604>>>>>// Courtesy Of Vincent Oorsprong
73604>>>>>//  hFindFile      : file search handle
73604>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
73605>>>>>
73605>>>>>
73605>>>>>
73605>>>>>Struct tvFileTime
73605>>>>>  DWord dwLowDateTime
73605>>>>>  DWord dwHighDateTime
73605>>>>>End_Struct
73605>>>>>
73605>>>>>
73605>>>>>Struct tvSystemTime
73605>>>>>  UShort wYear
73605>>>>>  UShort wMonth
73605>>>>>  UShort wDayOfWeek
73605>>>>>  UShort wDay
73605>>>>>  UShort wHour
73605>>>>>  UShort wMinute
73605>>>>>  UShort wSecond
73605>>>>>  UShort wMilliSeconds
73605>>>>>End_Struct
73605>>>>>
73605>>>>>
73605>>>>>// Courtesy Of Vincent Oorsprong
73605>>>>>//  lpFileTime     : pointer to file time to convert
73605>>>>>//  lpSystemTime   : pointer to structure to receive system time
73605>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
73606>>>>>
73606>>>>>// Courtesy Of Vincent Oorsprong
73606>>>>>// This function formats the time in a picture-string passed
73606>>>>>//
73606>>>>>// Picture      Meaning
73606>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
73606>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
73606>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
73606>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
73606>>>>>//    m         Minutes with no leading zero for single-digit minutes
73606>>>>>//    mm        Minutes with leading zero for single-digit minutes
73606>>>>>//    s         Seconds with no leading zero for single-digit seconds
73606>>>>>//    ss        Seconds with leading zero for single-digit seconds
73606>>>>>//    t         One character time marker string, such as A or P
73606>>>>>//    tt        Multicharacter time marker string, such as AM or PM
73606>>>>>//
73606>>>>>// For example, to get the time string  "11:29:40 PM"
73606>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
73606>>>>>
73606>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
73607>>>>>
73607>>>>>
73607>>>>>// Courtesy Of Vincent Oorsprong
73607>>>>>// This function formats the date in a picture-string passed
73607>>>>>//
73607>>>>>// Picture      Meaning
73607>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
73607>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
73607>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
73607>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
73607>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
73607>>>>>//              value associated with the specified locale.
73607>>>>>//    M         Month as digits with no leading zero for single-digit months.
73607>>>>>//    MM        Month as digits with leading zero for single-digit months.
73607>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
73607>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
73607>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
73607>>>>>//              associated with the specified locale.
73607>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
73607>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
73607>>>>>//    yyyy      Year represented hy full four digits.
73607>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
73607>>>>>//              with the specified locale. This element is ignored if the date to be formatted
73607>>>>>//              does not have an associated era or period string.
73607>>>>>// For example, to get the date string  "Wed, Aug 31 94"
73607>>>>>// use the following picture string:    "ddd","MMM dd yy"
73607>>>>>
73607>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
73608>>>>>
73608>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
73608>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
73608>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
73608>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
73608>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
73608>>>>>
73608>>>>>//  Date Flags for GetDateFormatW.
73608>>>>>//
73608>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
73608>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
73608>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
73608>>>>>
73608>>>>>
73608>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
73609>>>>>
73609>>>>>
73609>>>>>// **WvA: 20-02-2004
73609>>>>>// While i was testing the format capabilities i stumbled over a very
73609>>>>>// weird problem where it looks like that the integer value gets somehow translated
73609>>>>>// incorrectly into an unsigned integer.
73609>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
73609>>>>>// It does smell a bit fishy though
73609>>>>>// Tested it with the same results on both VDF7 and VDF9.1
73609>>>>>
73609>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
73609>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
73609>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
73609>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
73609>>>>>
73609>>>>>// Possible errors that can be returned by the shellformat function
73609>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
73609>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
73609>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
73609>>>>>
73609>>>>>
73609>>>>> // Courtesy Of Steve Walter,
73609>>>>> // USA Software, Inc
73609>>>>> // Format a disk
73609>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
73609>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
73610>>>>>
73610>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
73610>>>>>
73610>>>>>// SHCreateDirectoryEx
73610>>>>>
73610>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
73610>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
73610>>>>>//
73610>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
73610>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
73610>>>>>//    the files are visible. If they are not visible, expect one of the following:
73610>>>>>//
73610>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
73610>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
73610>>>>>//        ERROR_CANCELLED.
73610>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
73610>>>>>
73610>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
73610>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
73610>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
73610>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
73610>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
73610>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
73610>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
73610>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
73610>>>>>
73610>>>>>//        int SHCreateDirectoryEx(
73610>>>>>//            HWND hwnd,
73610>>>>>//            LPCTSTR pszPath,
73610>>>>>//            const SECURITY_ATTRIBUTES *psa
73610>>>>>//        );
73610>>>>>
73610>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
73611>>>>>
73611>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryA" SHLWAPI.DLL Pointer lpszPath Returns Integer
73612>>>
73612>>>
73612>>>//
73612>>>// Gets the string from the right of the last sStopChar in sFrom
73612>>>// If sStopChar has no occurences in the string an empty string is
73612>>>// returned.
73612>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
73614>>>    String  sRetVal
73614>>>    String  sChar
73614>>>    Integer iLength
73614>>>    Integer iPos
73614>>>    Boolean bStopChar
73614>>>    Move "" to sRetval
73615>>>    Move (Length(sFrom)) to iLength
73616>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
73618>>>        Move iLength   to iPos
73619>>>        Move (False)   to bStopChar
73620>>>        While Not bStopChar
73624>>>            Move (Mid(sFrom,1,iPos)) to sChar
73625>>>            Decrement iPos
73626>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
73628>>>                Move (True) to bStopChar
73629>>>            End
73629>>>>
73629>>>            Else Begin
73630>>>                Move (sChar+sRetVal) to sRetVal
73631>>>            End
73631>>>>
73631>>>        Loop
73632>>>>
73632>>>    End
73632>>>>
73632>>>    Function_Return sRetVal
73633>>>End_Function
73634>>>
73634>>>// Pre:  sFileName contains the complete path of the file.
73634>>>// Post: returns the complete path of the file.
73634>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
73634>>>Function ParseFolderName Global String sFileName Returns String
73636>>>    String sFile
73636>>>    String sFolderName
73636>>>    String sDirSep // this is "\" for windows, or "/" for unix
73636>>>
73636>>>    Move "" to sFolderName
73637>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
73638>>>    If sDirSep In sFileName Begin
73640>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
73641>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
73642>>>    End
73642>>>>
73642>>>    Else If ":" In sFileName Begin
73645>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
73646>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
73647>>>    End
73647>>>>
73647>>>    Function_Return sFolderName
73648>>>End_Function
73649>>>
73649>>>// Pre:  sFileName contains the complete path of the file.
73649>>>// post: The returned filename has it's path removed, but will have a extension
73649>>>Function ParseFileName Global String sFileName Returns String
73651>>>    String sFolderName
73651>>>    String sDirSep // this is "\" for windows, or "/" for unix
73651>>>
73651>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
73652>>>    Get ParseFolderName sFileName to sFolderName
73653>>>    If (sFolderName <> "") Begin
73655>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
73656>>>    End
73656>>>>
73656>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
73657>>>    Function_Return sFilename
73658>>>End_Function
73659>>>
73659>>>// Pre:  sFileName may contain the complete path of the file.
73659>>>//       or contain multiple dots in the filename, so temp.gif.bak will
73659>>>//       return "bak" as the extension and not "gif"
73659>>>// Post: returns the extension only, this extension can be a valid unixlike extension
73659>>>//       such as "html" or "java"
73659>>>Function ParseFileExtension Global String sFileName Returns String
73661>>>    String  sFileExtension
73661>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
73662>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
73663>>>    Function_Return sFileExtension
73664>>>End_Function
73665>>>
73665>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
73665>>>
73665>>>Function DDE_Error_To_String Integer iErrorID Returns String
73667>>>    String sMessage
73667>>>    Case Begin
73667>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
73669>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
73670>>>            Case Break
73671>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
73674>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
73675>>>            Case Break
73676>>>        Case (iErrorID = vERROR_BAD_FORMAT)
73679>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
73680>>>            Case Break
73681>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
73684>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
73685>>>            Case Break
73686>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
73689>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
73690>>>            Case Break
73691>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
73694>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
73695>>>            Case Break
73696>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
73699>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
73700>>>            Case Break
73701>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
73704>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
73705>>>            Case Break
73706>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
73709>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
73710>>>            Case Break
73711>>>        Case (iErrorID = vSE_ERR_NOASSOC)
73714>>>            Move CS_DDE_ERR_NOASSOC to sMessage
73715>>>            Case Break
73716>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
73719>>>            Move CS_DDE_ERR_OOM to sMessage
73720>>>            Case Break
73721>>>        Case (iErrorID = vSE_ERR_PNF)
73724>>>            Move CS_DDE_ERR_PNF to sMessage
73725>>>            Case Break
73726>>>        Case (iErrorID = vSE_ERR_SHARE)
73729>>>            Move CS_DDE_ERR_SHARE to sMessage
73730>>>            Case Break
73731>>>        Case Else
73731>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
73732>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
73733>>>            Case Break
73734>>>    Case End
73734>>>    Function_Return sMessage
73735>>>End_Function
73736>>>
73736>>>Procedure vDDE_Error_Handler Integer iErrorID
73738>>>    String sMessage
73738>>>    Get DDE_Error_To_String iErrorID to sMessage
73739>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
73740>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
73741>>>End_Procedure
73742>>>
73742>>>// Does the directory exist? - No = false, Yes = True
73742>>>// This also works with UNC path encoding and wildcards
73742>>>Function vFolderExists Global String sFolderName Returns Boolean
73744>>>    Boolean bFolderExists
73744>>>    Boolean bStop
73744>>>    String  sFolder sTmp
73744>>>    Integer iCh
73744>>>
73744>>>    // 2013-09-29 NGS Check for empty folder name and convert to ANSI
73744>>>    Move (Utf8ToAnsi(Trim(sFolderName))) to sFolderName
73745>>>    If (sFolderName = "") Begin
73747>>>        Function_Return False
73748>>>    End
73748>>>>
73748>>>
73748>>>    Move True  to bFolderExists
73749>>>    Move False to bStop
73750>>>    Move "dir:" to sFolder
73751>>>    Append sFolder sFolderName
73752>>>    Get Seq_New_Channel to iCh  // get free channel for input
73753>>>    Direct_Input channel iCh sFolder
73755>>>    Repeat
73755>>>>
73755>>>        Readln channel iCh sTmp
73757>>>        Move (SeqEof) to bStop
73758>>>        If (Trim(sTmp)="") Begin
73760>>>            Move False to bFolderExists
73761>>>        End
73761>>>>
73761>>>        Else Begin
73762>>>            Move True to bFolderExists
73763>>>            Move True to bStop
73764>>>        End
73764>>>>
73764>>>    Until (bStop)
73766>>>    Close_Input channel iCh
73768>>>    Send Seq_Release_Channel iCh
73769>>>    Function_Return bFolderExists
73770>>>End_Function
73771>>>
73771>>>// returns folder name if a folder was selected, otherwise returns ""
73771>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
73773>>>    String sFolder sTitle sPath
73773>>>    Pointer lpItemIdList
73773>>>    Integer iFolderSelected iRetval
73773>>>    tvBrowseInfo BrowseInfo
73773>>>    tvBrowseInfo BrowseInfo
73773>>>
73773>>>    Move "" to sPath
73774>>>    If (sDialogTitle<>"") Begin
73776>>>        Move sDialogTitle to sTitle
73777>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
73777>>>        // disables showing some commonly used ascii characters like ascii 137 ()
73777>>>        // These chars are correctly shown if no toansi is used.
73777>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
73777>>>        // selected it will always be valid.
73777>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
73778>>>    End
73778>>>>
73778>>>
73778>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
73779>>>
73779>>>    // Torben Lund added line below. Move handle of focus object to structure before
73779>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
73779>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
73780>>>
73780>>>    // null 128 chars into var (make space)
73780>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
73781>>>
73781>>>    // select folder
73781>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
73782>>>    // get selected folder name
73782>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
73783>>>
73783>>>    // release memory resources that are used by the ItemIdList
73783>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
73784>>>
73784>>>    If (iFolderSelected<>0) Begin
73786>>>        Move (CString(sFolder)) to sPath
73787>>>    End
73787>>>>
73787>>>    Function_Return  sPath
73788>>>End_Function
73789>>>
73789>>>// returns 0 if the folder is created.
73789>>>//         1 if the API-call returned an error.
73789>>>Function vCreateDirectory Global String sNewFolder Returns Integer
73791>>>    String  sFolder
73791>>>    Integer iRetval bFolderCreated
73791>>>    tvSecurity_attributes SA
73791>>>    tvSecurity_attributes SA
73791>>>
73791>>>    Move False to bFolderCreated
73792>>>
73792>>>    // null MAX_PATH chars into var (make space)
73792>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
73793>>>
73793>>>    If (sNewFolder <> "") Begin
73795>>>
73795>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
73796>>>        Move  0  to SA.lpDescriptor
73797>>>        Move  1  to SA.bInheritHandle
73798>>>
73798>>>        //
73798>>>        Move (sNewFolder+"") to sFolder
73799>>>        Move (vWin32_CreateDirectory(AddressOf(sFolder), AddressOf(SA))) to bFolderCreated
73800>>>    End
73800>>>>
73800>>>
73800>>>    If (bFolderCreated=false) Begin
73802>>>        Move 1 to iRetVal
73803>>>    End
73803>>>>
73803>>>    Function_Return iRetVal
73804>>>End_Function
73805>>>
73805>>>// **WvA: 03-02-2002 Function created.
73805>>>// With this function one can remove a directory.
73805>>>// returns 0 if the folder is removed.
73805>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
73805>>>//         2 if the folder did not exist
73805>>>//         3 if the sFolder parameter passed is equal to ""
73805>>>Function vRemoveDirectory Global String sFolder Returns Integer
73807>>>    Boolean bRemoved
73807>>>    String  sPath
73807>>>    Integer iRetval
73807>>>
73807>>>    Move 0     to iRetVal
73808>>>    Move False to bRemoved
73809>>>    Move (Trim(sFolder)) to sFolder
73810>>>    If (sFolder="") Begin
73812>>>        Move 3 to iRetVal
73813>>>    End
73813>>>>
73813>>>    If (vFolderExists(sFolder)=False) Begin
73815>>>        Move 2 to iRetVal
73816>>>    End
73816>>>>
73816>>>    If (iRetVal=0) Begin
73818>>>    // null MAX_PATH chars into var (make space)
73818>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
73819>>>        //
73819>>>        Move (Insert(sFolder,sPath,1)) to sPath
73820>>>        Move (vWin32_RemoveDirectory(AddressOf(sPath))) to bRemoved
73821>>>    End
73821>>>>
73821>>>
73821>>>    If (iRetVal=0 And bRemoved=False) Begin
73823>>>        Move 1 to iRetVal
73824>>>    End
73824>>>>
73824>>>    Function_Return iRetVal
73825>>>End_Function
73826>>>
73826>>>// This function informs the user that he entered a yet unknown folder and
73826>>>// asks if he/she wants to create the folder (Yes/No)
73826>>>// Choice: "Yes" - this creates the folder
73826>>>//                 if successful, the function returns false
73826>>>//                 else it will be true.
73826>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
73826>>>//                 For example: to stop a save
73826>>>// Precondition: A foldername must be entered. We do not check for empty paths
73826>>>// This function returns a non-zero value if the folder isn't created afterwards
73826>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
73828>>>    Integer bIsNotValid
73828>>>    Integer iUsers_Choice
73828>>>    String  sMessage
73828>>>
73828>>>    If (vFolderExists(sFolderName) Eq 0) Begin
73830>>>        Move "The folder '" to sMessage
73831>>>        Append sMessage sFolderName
73832>>>        Append sMessage "' does not yet exist,\n"
73833>>>        Append sMessage "Do you want to create it now?"
73834>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
73835>>>        Case Begin
73835>>>            Case (iUsers_Choice = MBR_Yes)
73837>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
73838>>>                If bIsNotValid Begin
73840>>>                    Move "An error occurred while trying to create folder '" to sMessage
73841>>>                    Append sMessage sFolderName "'.\n\n"
73843>>>                    Send Info_Box sMessage "Info"
73844>>>                End
73844>>>>
73844>>>                Case Break
73845>>>            Case (iUsers_Choice = MBR_No)
73848>>>                Move dfTrue to bIsNotValid // Cancel the save
73849>>>                Case Break
73850>>>        Case End
73850>>>    End
73850>>>>
73850>>>    Function_Return bIsNotValid
73851>>>End_Function
73852>>>
73852>>>// This will perform an operation on a file (e.g. open) with the application
73852>>>// registered in the Windows Registry to open that type of file (via its extension)
73852>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
73852>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
73854>>>    Handle  hInstance hWnd
73854>>>    // remove any leading/trailing spaces in the string
73854>>>    Move (Trim(sDocument)) to sDocument
73855>>>    Move (Trim(sPath))     to sPath
73856>>>    // Make the strings readable for windows API, by converting them to null-terminated
73856>>>    Append sOperation   (Character(0))
73857>>>    Append sDocument    (Character(0))
73858>>>    Append sParameters  (Character(0))
73859>>>    Append sPath        (Character(0))
73860>>>
73860>>>    Get Window_Handle to hWnd
73861>>>    Move (vWin32_ShellExecute (hWnd, AddressOf(sOperation), AddressOf(sDocument), AddressOf(sParameters), AddressOf(sPath), 1)) to hInstance
73862>>>    If (hInstance <= 32) Begin
73864>>>        Send vDDE_Error_Handler hInstance
73865>>>    End
73865>>>>
73865>>>End_Procedure
73866>>>
73866>>>Class cShellFileOperations is a Array
73867>>>
73867>>>    Procedure Construct_Object
73869>>>        Forward Send Construct_Object
73871>>>        Property Integer piDeleteFlags        0
73872>>>        Property Integer piCopyFlags          0
73873>>>        Property Integer piMoveFlags          0
73874>>>        Property Integer piRenameFlags        0
73875>>>
73875>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
73876>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
73877>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
73878>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
73879>>>    End_Procedure
73880>>>
73880>>>    // This function uses the shell API to perform a file operation on the
73880>>>    // files supplied.
73880>>>    //
73880>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
73882>>>        Integer  iRetVal
73882>>>        Integer  iUserAbort
73882>>>        tvShFileOpStruct FOS
73882>>>        tvShFileOpStruct FOS
73882>>>
73882>>>        Move (Utf8ToAnsi(sSource)+Character(0)+Character(0))      to sSource
73883>>>        Move (Utf8ToAnsi(sDestination)+Character(0)+Character(0)) to sDestination
73884>>>        If (eOperation <> vFO_DELETE) Begin
73886>>>            Move (AddressOf(sDestination)) to FOS.pTo
73887>>>        End
73887>>>>
73887>>>
73887>>>        Move eOperation           to FOS.wFunc
73888>>>        Move (AddressOf(sSource)) to FOS.pFrom
73889>>>        Move iFlags               to FOS.fFlags
73890>>>
73890>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
73891>>>        Move FOS.fAnyOperationsAborted to iUserAbort
73892>>>        If (iUserAbort <> 0) Begin
73894>>>            Move 80 to iRetVal  // file Operation Aborted by USER
73895>>>        End
73895>>>>
73895>>>        Function_Return (iRetVal)
73896>>>    End_Function
73897>>>
73897>>>    Function sfoDeleteFile String sFileName Returns Integer
73899>>>        Integer  iRetVal
73899>>>        Integer  iFlags
73899>>>
73899>>>        Get piDeleteFlags to iFlags
73900>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
73901>>>        Function_Return iRetVal
73902>>>    End_Function
73903>>>
73903>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
73905>>>        Integer  iRetVal
73905>>>        Integer  iFlags
73905>>>
73905>>>        Get piCopyFlags to iFlags
73906>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
73907>>>        Function_Return iRetVal
73908>>>    End_Function
73909>>>
73909>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
73911>>>        Integer  iRetVal
73911>>>        Integer  iFlags
73911>>>
73911>>>        Get piMoveFlags to iFlags
73912>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
73913>>>        Function_Return iRetVal
73914>>>    End_Function
73915>>>
73915>>>    // Rename a file or folder
73915>>>    // Returns a nonzero value if the operation failed.
73915>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
73917>>>        Integer  iRetVal
73917>>>        Integer  iFlags
73917>>>
73917>>>        Get piRenameFlags to iFlags
73918>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
73919>>>        Function_Return iRetVal
73920>>>    End_Function
73921>>>
73921>>>    // Courtesy Of Steve Walter
73921>>>    // Requires Windows 2000 and up according to msdn but it was
73921>>>    //  in fact available before that as an unpublished API call
73921>>>    //  a little google search shows that this was already available
73921>>>    //  in windows 95 and NT
73921>>>    //
73921>>>    // The format is controlled by the dialog interface.
73921>>>    // That is, the user must click the OK button To actually Begin the format
73921>>>    // the format cannot be started programmatically.
73921>>>    // An alternative to this functionality would be to use a controlpanel
73921>>>    //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
73921>>>    //
73921>>>    // hWnd = The windows handle of the object from which the format Function
73921>>>    //        is called.
73921>>>    // To Get this,
73921>>>    //          use:  Get Window_Handle Of <object>
73921>>>    //          For instance, in this app, we're going to use the Report_Panel:
73921>>>    //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
73921>>>    //
73921>>>    // sDrive = The drive letter. At this moment only A and B are valid
73921>>>    //
73921>>>    // iOptions = Format options.
73921>>>    //  SHFMT_OPT_DEFAULT = Quick format
73921>>>    //  SHFMT_OPT_FULL    = Full Format
73921>>>    //  SHFMT_OPT_SYSONLY = System only
73921>>>    //  3                 = Full format with system. (unsupported)
73921>>>    //
73921>>>    // Return Values:
73921>>>    //  SHFMT_ERROR    = Error on format or no drive specified.
73921>>>    //  SHFMT_CANCEL   = Format cancelled by user.
73921>>>    //  SHFMT_NOFORMAT = Drive is not formatable.
73921>>>    //
73921>>>    //
73921>>>    // *** ATTENTION: This function has been disabled as it doesn't
73921>>>    //                seem to work, i must have made a silly mistake
73921>>>    //                somewhere.
73921>>>    //
73921>>>    Function sfoFormatDisk String sDrive Integer iOptions Returns DWord
73923>>>        Handle   hWnd
73923>>>        Integer  iObj
73923>>>        DWord    dwReturnVal
73923>>>        Integer iDrive
73923>>>
73923>>>        Function_Return 1 // STOP HERE
73924>>>
73924>>>        Move (Trim(sDrive)) to sDrive
73925>>>        If ( sDrive <> '' ) Begin
73927>>>            If ( sDrive Contains ':' ) Begin
73929>>>                Move (Replace(':',sDrive,'')) to sDrive
73930>>>            End
73930>>>>
73930>>>            If (Not( 'AB' Contains sDrive )) Begin
73932>>>                Function_Return (SHFMT_NOFORMAT)
73933>>>            End
73933>>>>
73933>>>            If ( sDrive = 'A' ) Begin
73935>>>                Move 0 to iDrive
73936>>>            End
73936>>>>
73936>>>            Else If ( sDrive = 'B' ) Begin
73939>>>                Move 1 to iDrive
73940>>>            End
73940>>>>
73940>>>            // Window_Handle Of Desktop equals to 0
73940>>>
73940>>>            Get focus of desktop to iObj
73941>>>            If (iObj>desktop) Begin
73943>>>                Get Container_Handle of iObj to hWnd
73944>>>            End
73944>>>>
73944>>>            While (hWnd=0 And iObj<>Desktop)
73948>>>                Get Parent of iObj to iObj
73949>>>                Get Container_Handle of iObj to hWnd
73950>>>            Loop
73951>>>>
73951>>>
73951>>>            //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
73951>>>            Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) to dwReturnVal
73952>>>        End
73952>>>>
73952>>>        Else Begin
73953>>>            Move (SHFMT_ERROR) to dwReturnVal
73954>>>        End
73954>>>>
73954>>>        Function_Return dwReturnVal
73955>>>    End_Function
73956>>>
73956>>>    //Example:
73956>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
73956>>>    //                                          mode.
73956>>>
73956>>>End_Class
73957>>>
73957>>>Object oShellFileOperations is a cShellFileOperations
73959>>>End_Object
73960>>>
73960>>>// Restore to the old way of working with the shell file operations.
73960>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
73960>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
73960>>>Procedure vWin32fhCompatibilityMode
73962>>>    Integer hoSFO
73962>>>    Integer iFlags
73962>>>
73962>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
73963>>>    Move (oShellFileOperations(Self)) to hoSFO
73964>>>
73964>>>    Set piDeleteFlags of hoSFO to iFlags
73965>>>    Set piCopyFlags   of hoSFO to iFlags
73966>>>    Set piMoveFlags   of hoSFO to iFlags
73967>>>    Set piRenameFlags of hoSFO to iFlags
73968>>>End_Procedure
73969>>>
73969>>>// Delete a file or folder
73969>>>// Returns a nonzero value if the operation failed.
73969>>>Function vDeleteFile Global String sFileName Returns Integer
73971>>>    Integer  iRetVal
73971>>>
73971>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
73972>>>    Function_Return iRetVal
73973>>>End_Function
73974>>>
73974>>>// Copy a file or folder
73974>>>// Returns a nonzero value if the operation failed.
73974>>>Function vCopyFile Global String sSource String sDestination Returns Integer
73976>>>    Integer  iRetVal
73976>>>
73976>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
73977>>>    Function_Return iRetVal
73978>>>End_Function
73979>>>
73979>>>// Move a file or folder
73979>>>// Returns a nonzero value if the operation failed.
73979>>>Function vMoveFile Global String sSource String sDestination Returns Integer
73981>>>    Integer  iRetVal
73981>>>
73981>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
73982>>>    Function_Return iRetVal
73983>>>End_Function
73984>>>
73984>>>// Rename a file or folder
73984>>>// Returns a nonzero value if the operation failed.
73984>>>Function vRenameFile Global String sSource String sDestination Returns Integer
73986>>>    Integer  iRetVal
73986>>>
73986>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
73987>>>    Function_Return iRetVal
73988>>>End_Function
73989>>>
73989>>>Function vGetWindowsDirectory Returns String
73991>>>    String  sDirectory
73991>>>    Integer iVoid
73991>>>
73991>>>    Move (ZeroString(vMAX_PATH)) to sDirectory
73992>>>    Move (vWin32_GetWindowsDirectory(AddressOf(sDirectory), vMAX_PATH)) to iVoid
73993>>>    Function_Return (CString(sDirectory))
73994>>>End_Function
73995>>>
73995>>>Function vGetTempPath Returns String
73997>>>    Integer iRetval
73997>>>    String  sTempPath
73997>>>
73997>>>    Move (ZeroString(vMAX_PATH)) to sTempPath
73998>>>    Move (vWin32_GetTempPath (vMAX_PATH, AddressOf(sTempPath))) to iRetVal
73999>>>    Function_Return (Cstring(sTempPath))
74000>>>End_Function
74001>>>
74001>>>// Courtesy of Marco Kuipers
74001>>>Function vMakeTempFile Returns String
74003>>>    Integer iRetval
74003>>>    String  sTempPath
74003>>>    String  sTempFileName
74003>>>    String  sPrefixString
74003>>>
74003>>>    Get vGetTempPath to sTempPath
74004>>>    If (sTempPath = "") Begin
74006>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
74007>>>        If (sTempPath<>"") Begin
74009>>>            Move (sTempPath+"\Temp\") to sTempPath
74010>>>        End
74010>>>>
74010>>>    End
74010>>>>
74010>>>
74010>>>    If (sTempPath = "") Begin
74012>>>    // second fallback we really do not want to get here as to be fair using current folder as temp
74012>>>    // makes little sense. Leaving this in as it was old behavior.
74012>>>        Get_Current_Directory to sTempPath
74013>>>    End
74013>>>>
74013>>>
74013>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
74014>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
74016>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
74017>>>>
74017>>>    End
74017>>>>
74017>>>
74017>>>    Move (ZeroString(vMax_Path)) to sTempFileName
74018>>>    Move ("tmp"+Character(0)) to sPrefixString // **WvA: 28-04-2005 Added a null
74019>>>    Move (vWin32_GetTempFileName (AddressOf(sTempPath), AddressOf(sPrefixString), 0, AddressOf(sTempFileName))) to iRetval
74020>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
74022>>>    //Get ShowLastError to iRetval
74022>>>        Move "" to sTempFileName
74023>>>    End
74023>>>>
74023>>>
74023>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
74024>>>End_Function
74025>>>
74025>>>// This function creates a uniquely named temporary file in folder sPath
74025>>>// The file created will have a prefix based on the first 3 characters in sPrefix
74025>>>// Note that you will have to cleanup the tempfile yourself as the function
74025>>>// does not take care of that.
74025>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
74027>>>    Integer iRetVal
74027>>>    String sTempFileName
74027>>>
74027>>>    Move (Utf8ToAnsi(sPath)+Character(0))   to sPath
74028>>>    Move (Utf8ToAnsi(sPrefix)+Character(0)) to sPrefix
74029>>>    Move (Pad("", vMAX_PATH)) to sTempFileName
74030>>>
74030>>>    Move (vWin32_GetTempFileName(AddressOf(sPath), AddressOf(sPrefix), 0, AddressOf(sTempFileName))) to iRetVal
74031>>>    Move (Trim(Cstring(sTempFileName))) to sTempFileName
74032>>>    Function_Return sTempFileName
74033>>>End_Function
74034>>>
74034>>>//
74034>>>// Get a specific shell folder for example to get the desktop folder
74034>>>// simply call this function and pass it vCSIDL_DESKTOP
74034>>>//
74034>>>Function vSHGetFolderPath Integer eFolder Returns String
74036>>>    String  sFolder
74036>>>    Integer iVoid
74036>>>    Handle  hWnd
74036>>>
74036>>>    Move (Window_Handle(focus(desktop))) to hWnd
74037>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
74038>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(sFolder))) to iVoid
74039>>>    Function_Return (CString(sFolder))
74040>>>End_Function
74041>>>
74041>>>// Courtesy Of Vincent Oorsprong
74041>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
74043>>>    String  sFormattedTime sFormattedDate
74043>>>    String  sFileDateTime
74043>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
74043>>>    tvFileTime   FileTime
74043>>>    tvFileTime   FileTime
74043>>>    tvSystemTime SystemTime
74043>>>    tvSystemTime SystemTime
74043>>>
74043>>>    Move "" to sFileDateTime
74044>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
74045>>>    Move dwHighDateTime to FileTime.dwHighDateTime
74046>>>
74046>>>    Move 0 to SystemTime.wYear
74047>>>
74047>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
74048>>>    If (iSuccess = 1) Begin
74050>>>        Move (ZeroString(255))        to sFormattedTime
74051>>>        Move (Length(sFormattedTime)) to iLenCcTime
74052>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedTime), iLenCcTime)) to iDataLength
74053>>>        Move (ZeroString(255))        to sFormattedDate
74054>>>        Move (Length(sFormattedDate)) to iLenCcDate
74055>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedDate), iLenCcDate)) to iDataLength
74056>>>        Move (Cstring (sFormattedDate)  * Cstring (sFormattedTime)) to sFileDateTime
74057>>>    End
74057>>>>
74057>>>    Function_Return sFileDateTime
74058>>>End_Function
74059>>>
74059>>>// **WvA:
74059>>>// A windows replacement for the standard function FileExists.
74059>>>// This version will also return (true) for a file when it is open by an application.
74059>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
74059>>>// Example: Get vFilePathExists "C:\config.sy?"
74059>>>// This will return true if you have a file matching these conditions. (aka config.sys)
74059>>>Function vFilePathExists Global String sFilePathMask Returns Integer
74061>>>    String  sDirSep
74061>>>    Handle  hFindFile
74061>>>    Integer iVoid
74061>>>    tvWin32FindData FindData
74061>>>    tvWin32FindData FindData
74061>>>
74061>>>    Move vINVALID_HANDLE_VALUE to hFindFile
74062>>>    Move (Utf8ToANSI(Trim(sFilePathMask))) to sFilePathMask
74063>>>    If (Length(sFilePathMask)>0) Begin
74065>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
74065>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74066>>>        While (Right(sFilePathMask, 1) = sDirSep)
74070>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
74071>>>        Loop
74072>>>>
74072>>>
74072>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
74073>>>        Move (vWin32_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
74074>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
74075>>>    End
74075>>>>
74075>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
74076>>>End_Function
74077>>>
74077>>>//
74077>>>// WideChar version of the function, do not use, it's an experiment
74077>>>//
74077>>>Function vWFilePathExists Global String sFilePathMask Returns Integer
74079>>>    Handle  hFindFile
74079>>>    Integer iVoid
74079>>>    tvWin32FindData FindData
74079>>>    tvWin32FindData FindData
74079>>>
74079>>>    Move vINVALID_HANDLE_VALUE to hFindFile
74080>>>
74080>>>    If (Length(sFilePathMask)>0) Begin
74082>>>
74082>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
74083>>>        Move (vWin32W_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
74084>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
74085>>>    End
74085>>>>
74085>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
74086>>>End_Function
74087>>>
74087>>>// **WvA
74087>>>// Formats a foldername by first trimming it and after that by sticking a
74087>>>// directory separator (/\) to the end if it doesn't have one there already.
74087>>>// The folder may contain a drive letter or UNC encoding.
74087>>>Function vFolderFormat Global String sFolderName Returns String
74089>>>    String sDirSep
74089>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
74090>>>    Move (Trim(sFolderName)) to sFolderName
74091>>>    If (Right(sFolderName,1)<>sDirSep) Begin
74093>>>        Move (sFolderName+sDirSep) to sFolderName
74094>>>    End
74094>>>>
74094>>>    Function_Return sFolderName
74095>>>End_Function
74096>>>
74096>>>//
74096>>>// Returns the amount of files in the folder (if it exists)
74096>>>// Returns -1 if folder doesn't exist.
74096>>>// The files "." and ".." are not counted.
74096>>>//
74096>>>Function vFolderFileCount Global String sFolderName Returns Integer
74098>>>    Boolean bFound
74098>>>    Handle  hFindFile
74098>>>    Integer iCount  iVoid
74098>>>    Integer iSuccess
74098>>>    String  sFileName
74098>>>    tvWin32FindData FindData
74098>>>    tvWin32FindData FindData
74098>>>
74098>>>    Move -1 to iCount
74099>>>    Get vFolderFormat sFolderName to sFolderName
74100>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
74101>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
74102>>>    Move (vWin32_FindFirstFile (AddressOf(sFolderName), AddressOf(FindData))) to hFindFile
74103>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
74104>>>    If (bFound) Begin
74106>>>        Move 0 to iCount
74107>>>    End
74107>>>>
74107>>>    While (bFound)
74111>>>        Increment iCount
74112>>>        Move (UCharArrayToString(FindData.cFileName)) to sFileName
74113>>>        If (sFileName="." or sFileName="..") Begin
74115>>>            Decrement iCount
74116>>>        End
74116>>>>
74116>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
74117>>>        Move (iSuccess<>0) to bFound
74118>>>    Loop
74119>>>>
74119>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
74120>>>    Function_Return iCount
74121>>>End_Function
74122>>>
74122>>>//
74122>>>// Gets the parent path of the currently supplied path
74122>>>// Returns "" when we are at the root folder.
74122>>>//
74122>>>Function vParentPath Global String sPath Returns String
74124>>>    String sStrip sDirSep
74124>>>
74124>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74125>>>    Move (Trim(sPath)) to sPath
74126>>>    If (Right(sPath,1) = sDirSep) Begin
74128>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
74129>>>    End
74129>>>>
74129>>>    If (Pos(sDirSep, sPath)) Begin
74131>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
74132>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
74133>>>    End
74133>>>>
74133>>>    Else Begin
74134>>>        Move "" to sPath
74135>>>    End
74135>>>>
74135>>>    Function_Return sPath
74136>>>End_Function
74137>>>
74137>>>// Create the folder, including intermediate directories.
74137>>>// Don't panic if the folder already exists.
74137>>>// Michael Mullan June 2009.
74137>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
74139>>>    String  sFolder
74139>>>    Integer iRetval iFolderCreated
74139>>>    tvSecurity_attributes SA
74139>>>    tvSecurity_attributes SA
74139>>>
74139>>>    Move 0 to iFolderCreated
74140>>>
74140>>>    // null MAX_PATH chars into var (make space)
74140>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
74141>>>    If (sNewFolder <> "") Begin
74143>>>
74143>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
74144>>>        Move  0  to SA.lpDescriptor
74145>>>        Move  1  to SA.bInheritHandle
74146>>>
74146>>>        //
74146>>>        Move (sNewFolder+"") to sFolder
74147>>>        Move (vWin32_SHCreateDirectoryEx(0,AddressOf(sFolder), AddressOf(SA))) to iFolderCreated
74148>>>    End
74148>>>>
74148>>>
74148>>>    If (iFolderCreated <> 0) Begin
74150>>>        Move 1 to iRetVal
74151>>>        Case Begin
74151>>>            Case (iFolderCreated = 161)
74153>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
74154>>>>
74154>>>                Case Break
74155>>>            Case (iFolderCreated = 206)
74158>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
74159>>>>
74159>>>                Case Break
74160>>>            Case (iFolderCreated = 3)
74163>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
74164>>>>
74164>>>                Case Break
74165>>>            Case (iFolderCreated = 80)
74168>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
74169>>>                Case Break
74170>>>            Case (iFolderCreated = 183)
74173>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
74174>>>                Case Break
74175>>>            Case (iFolderCreated = 1223)
74178>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
74179>>>>
74179>>>                Case Break
74180>>>            Case Else
74180>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
74181>>>>
74181>>>        Case End
74181>>>    End
74181>>>>
74181>>>    Function_Return iRetVal
74182>>>End_Function
74183>>>
74183>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
74185>>>    DWord   dwFileSizeHigh dwFileSizeLow
74185>>>    Integer iFileSize iVoid
74185>>>    Handle  hFindFile
74185>>>    tvWin32FindData FindData
74185>>>    tvWin32FindData FindData
74185>>>
74185>>>    Move (sFileName+"") to sFileName
74186>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
74187>>>    Move (vWin32_FindFirstFile (AddressOf(sFileName), AddressOf(FindData))) to hFindFile
74188>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
74190>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
74191>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
74192>>>    End
74192>>>>
74192>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
74193>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
74194>>>
74194>>>    Function_Return iFileSize
74195>>>End_Function
74196>>>
74196>>>//
74196>>>// Based on code in Peter Crook's Browse folder workspace
74196>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
74196>>>//
74196>>>//=============================================================================
74196>>>// Verifies that a path is a valid directory.
74196>>>//
74196>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
74196>>>//
74196>>>// Parameters:
74196>>>//      sPath - Address of the path to verify.
74196>>>//=============================================================================
74196>>>Function vPathIsDirectory Global String sPath Returns Boolean
74198>>>    Integer iResult
74198>>>    Boolean bRetVal
74198>>>
74198>>>    Move false to bRetVal
74199>>>    Move (Utf8ToAnsi(sPath) - Character (0)) to sPath
74200>>>    Move (vWin32_PathIsDirectory (AddressOf (sPath))) to iResult
74201>>>    If (iResult<>0) Begin
74203>>>        Move True to bRetVal
74204>>>    End
74204>>>>
74204>>>
74204>>>    Function_Return bRetVal
74205>>>End_Function
74206>>>
74206>Use Windows.pkg
74206>
74206>Object oHtmlHelp is a cHtmlHelp
74208>End_Object
74209>
74209>Object oApplication is a cApplication
74211>    Set peHelpType to htHtmlHelp
74212>    Set psCompany to "RDC Tools International"
74213>    Set psProduct to "The Database Update Framework - Create DbVersion Table"
74214>    Set psHelpFile to "Developer5.chm"
74215>    Set psAutoOpenWorkspace to ""
74216>
74216>    Property String psFilelistName
74218>    Property String psOpenPath
74220>
74220>    Procedure OnCreate
74223>        Handle ho hoIni
74223>        String sSWSFile sWSFile sOpenPath sPath sFilelistname
74223>        Integer eOpened iPos
74223>        Boolean bExists
74223>
74223>        Get phoCommandLine to ho
74224>        Get Argument of ho 1 to sSWSFile
74225>
74225>        // Was the program started with a parameter on the command line from e.g. the Studio?
74225>        If (sSWSFile <> "") Begin
74227>            Get Create (RefClass(cIniFile)) to hoIni
74228>            Set psFileName of hoIni to sSWSFile
74229>            Get ParseFolderName sSWSFile to sPath
74230>
74230>            // Read .ws file path from the .sws file:
74230>            Get ReadString of hoIni "WorkspacePaths" "ConfigFile" "" to sWSFile
74231>            Move (Pos(".\", sWSFile)) to iPos
74232>            If (iPos <> 0) Begin
74234>                Move (Replace(".\", sWSFile, "")) to sWSFile
74235>            End
74235>            Send Destroy of hoIni
74236>            Move (sPath + sWSFile) to sWSFile
74237>            Get vFilePathExists sWSFile to bExists
74238>            If (bExists = True) Begin
74240>                Get OpenWorkspaceFile of (phoWorkspace(Self)) sWSFile to eOpened
74241>                If (eOpened = wsWorkspaceOpened) Begin
74243>                    Set psFilelistName to (psFileList(phoWorkspace(Self)))
74244>                    Procedure_Return // Workspace opened; We're done!
74245>                End
74245>            End
74245>        End
74245>
74245>        Get_Attribute DF_OPEN_PATH to sOpenPath
74248>        Set psOpenPath to sOpenPath
74249>
74249>        // Check if there is a config.ws file in the Programs folder:
74249>        Get OpenWorkspaceFile of (phoWorkspace(Self)) "config.ws" to eOpened
74250>        If (eOpened = wsWorkspaceOpened) Begin
74252>            Get psFileList of (phoWorkspace(Self)) to sFileListName
74253>            Set psFilelistName to sFileListName
74254>            Procedure_Return         // Workspace opened; We're done!
74255>        End
74255>
74255>        // If no config.ws was not found; let user select a .ws file
74255>        Get GetApplicationPath to sPath
74256>        Get vSelect_File "Workspace Files (*.ws)|*.ws|All Files (*.*)|*.*" "Please select a Workspace file (*.ws)" sPath to sWsFile
74257>        Get vFilePathExists sWsFile to bExists
74258>        If (bExists = False) Begin
74260>            Send Stop_Box "No Workspace file selected. Cannot continue!"
74261>            Send Exit_Application
74262>        End
74262>        Get OpenWorkspaceFile of (phoWorkspace(Self)) sWsFile to eOpened
74263>        If (eOpened = wsWorkspaceOpened) Begin
74265>            Get psFileList of (phoWorkspace(Self)) to sFileListName
74266>            Set psFilelistName to sFileListName
74267>            Procedure_Return
74268>        End
74268>        Else Begin
74269>            Send Stop_Box "Could not open the Workspace. Cannot continue!"
74270>            Send Exit_Application
74271>        End
74271>
74271>    End_Procedure
74272>
74272>End_Object
74273>
74273>//Use cCJSkinFramework.pkg
74273>//Object oCJSkinFramework is a cCJSkinFramework
74273>//    Set psSkinFile to "Mac_OSX_Leopard.cjstyles"
74273>//    Set psSkinIni to "NormalLeopard.ini"
74273>//End_Object
74273>
74273>Use cToolTipController.pkg
74273>Object oToolTipController is a cToolTipController
74275>    Move Self to ghoToolTipController
74276>    Set pbBalloonStyle to False
74277>    Set piIcon to TTI_INFO
74278>    Set psTitle to "Information"
74279>    Set piMaxWidth to 400
74280>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
74281>End_Object
74282>
74282>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cDbUpdateFunctionLibrary.pkg)
74282>>>//****************************************************************************
74282>>>// $Module type: Class
74282>>>// $Module name: cDbUpdateFunctionLibrary
74282>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
74282>>>// Web-site    : http://www.rdctools.com
74282>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
74282>>>//
74282>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
74282>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
74282>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
74282>>>//               with the help of Sql-scripts.
74282>>>//
74282>>>// $Rev History:
74282>>>//    2014-09-05  Module header created
74282>>>//
74282>>>//****************************************************************************
74282>>>Use cApplication.pkg
74282>>>Use seq_chnl.pkg
74282>>>Use GlobalFunctionsProcedures.pkg
74282>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
74282>>>Use Dfcursor.pkg
74282>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\DUFStatusPanel.pkg)
74282>>>>>// StatPnl.pkg - creates the standard status_panel object.
74282>>>>>//
74282>>>>>//
74282>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
74282>>>>>// invoke the standard status panel. The standard has always been that the package name
74282>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
74282>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
74282>>>>>// prior revisions has been replace with status panel that is part of the application.
74282>>>>>// This should work much better and faster than the old sentinel based solution.
74282>>>>>// While the way this operates has changed, the interface has not and therefore this should work
74282>>>>>// with most applications.
74282>>>>>//
74282>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
74282>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
74282>>>>>// a cleaner more robust interface.
74282>>>>>//
74282>>>>>//
74282>>>>>// Compatibility Note:
74282>>>>>//
74282>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
74282>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
74282>>>>>//
74282>>>>>// If for some reason you application will not work using this as a replacement for the old status
74282>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
74282>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
74282>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
74282>>>>>//
74282>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
74282>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
74282>>>>>//
74282>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
74282>>>>>// can still access the new object via the ghoStatusPanel handle.
74282>>>>>//
74282>>>>>//
74282>>>>>// Creating your own Status Panel objects
74282>>>>>//
74282>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
74282>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
74282>>>>>// with a different file and object name and direct your status panel request to the new object.
74282>>>>>//
74282>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
74282>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
74282>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
74282>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
74282>>>>>// e.g.
74282>>>>>//       Procedure UpdateStatusBar
74282>>>>>//           Send DoAdvance of oProgressBar
74282>>>>>//           Send ProcessEvents
74282>>>>>//       End_Procedure
74282>>>>>//
74282>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
74282>>>>>// messages this will be done for you.
74282>>>>>//
74282>>>>>// the standard Interface for status panels are:
74282>>>>>//
74282>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
74282>>>>>// Send Start_StatusPanel      - start the status panel
74282>>>>>// Send Stop_StatusPanel       - stop the status panel
74282>>>>>// Send Update_StatusPanel     - update the status panel's action area
74282>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
74282>>>>>//
74282>>>>>// Get/Set Caption_Text - updates the caption bar
74282>>>>>// Get/Set Title_Text   - updates the title area
74282>>>>>// Get/Set Message_Text - updates the Message area
74282>>>>>// Get/Set Action_Text  - updates the action area
74282>>>>>// Get/Set Button_Text  - updates the button area
74282>>>>>//
74282>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
74282>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
74282>>>>>//
74282>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
74282>>>>>Use cProcessStatusPanel.pkg
74282>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJSkinFramework.pkg)
74282>>>>>>>Use windows.pkg
74282>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJComSkinFramework.pkg)
74282>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v20.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v20.0.0.ocx
74282>>>>>>>>>Use FlexCom20.pkg
74282>>>>>>>>>
74282>>>>>>>>>// Changes to Imported package
74282>>>>>>>>>//     OLEXTPxx to XTPxx
74282>>>>>>>>>//     OLExtpxx to xtpxx
74282>>>>>>>>>//     OLESkinFramework to SkinFramework
74282>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
74282>>>>>>>>>//     cCom classes to cCJ
74282>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
74282>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
74282>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
74282>>>>>>>>>//     Use statements as noted below (classes moved to these files)
74282>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
74282>>>>>>>>>
74282>>>>>>>>>// These have been extracted from this class and moved into seperate packages
74282>>>>>>>>>// because other Codejock classes use these.
74282>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
74282>>>>>>>>>
74282>>>>>>>>>
74282>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
74282>>>>>>>>>    Define xtpSkinApplyMetrics for 1
74282>>>>>>>>>    Define xtpSkinApplyFrame for 2
74282>>>>>>>>>    Define xtpSkinApplyColors for 4
74282>>>>>>>>>    Define xtpSkinApplyMenus for 8
74282>>>>>>>>>
74282>>>>>>>>>// CLSID: {C0DE2000-28D7-4F2C-87A7-7266367B4655}
74282>>>>>>>>>// Dispatch interface for SkinFramework Control
74282>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
74283>>>>>>>>>
74283>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
74285>>>>>>>>>        SkinFrameworkApplyOptions retVal
74285>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
74286>>>>>>>>>        Function_Return retVal
74287>>>>>>>>>    End_Function
74288>>>>>>>>>
74288>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
74290>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
74291>>>>>>>>>    End_Procedure
74292>>>>>>>>>
74292>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
74294>>>>>>>>>        Boolean retVal
74294>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
74295>>>>>>>>>        Function_Return retVal
74296>>>>>>>>>    End_Function
74297>>>>>>>>>
74297>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
74299>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
74300>>>>>>>>>    End_Procedure
74301>>>>>>>>>
74301>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
74303>>>>>>>>>        Boolean retVal
74303>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
74304>>>>>>>>>        Function_Return retVal
74305>>>>>>>>>    End_Function
74306>>>>>>>>>
74306>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
74308>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
74309>>>>>>>>>    End_Procedure
74310>>>>>>>>>
74310>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
74312>>>>>>>>>        Handle hDispatchDriver
74312>>>>>>>>>        Boolean retVal
74312>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74313>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74314>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74315>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74316>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
74317>>>>>>>>>        Function_Return retVal
74318>>>>>>>>>    End_Function
74319>>>>>>>>>
74319>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
74321>>>>>>>>>        Handle hDispatchDriver
74321>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74322>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74323>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74324>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
74325>>>>>>>>>    End_Procedure
74326>>>>>>>>>
74326>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
74328>>>>>>>>>        Handle hDispatchDriver
74328>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74329>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74330>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74331>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
74332>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
74333>>>>>>>>>    End_Procedure
74334>>>>>>>>>
74334>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
74336>>>>>>>>>        Handle hDispatchDriver
74336>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74337>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74338>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74339>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
74340>>>>>>>>>    End_Procedure
74341>>>>>>>>>
74341>>>>>>>>>    Procedure ComRemoveAllWindows
74343>>>>>>>>>        Handle hDispatchDriver
74343>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74344>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
74345>>>>>>>>>    End_Procedure
74346>>>>>>>>>
74346>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
74348>>>>>>>>>        Handle hDispatchDriver
74348>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74349>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74350>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
74351>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
74352>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
74353>>>>>>>>>    End_Procedure
74354>>>>>>>>>
74354>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
74356>>>>>>>>>        Handle hDispatchDriver
74356>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74357>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74358>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
74359>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
74360>>>>>>>>>    End_Procedure
74361>>>>>>>>>
74361>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
74363>>>>>>>>>        Handle hDispatchDriver
74363>>>>>>>>>        Variant retVal
74363>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74364>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74365>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
74366>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
74367>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
74368>>>>>>>>>        Function_Return retVal
74369>>>>>>>>>    End_Function
74370>>>>>>>>>
74370>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
74372>>>>>>>>>        Handle hDispatchDriver
74372>>>>>>>>>        Variant retVal
74372>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74373>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74374>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
74375>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
74376>>>>>>>>>        Function_Return retVal
74377>>>>>>>>>    End_Function
74378>>>>>>>>>
74378>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74380>>>>>>>>>        Handle hDispatchDriver
74380>>>>>>>>>        OLE_COLOR retVal
74380>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74381>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74382>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74383>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
74384>>>>>>>>>        Function_Return retVal
74385>>>>>>>>>    End_Function
74386>>>>>>>>>
74386>>>>>>>>>    Procedure ComExcludeModule String llModuleName
74388>>>>>>>>>        Handle hDispatchDriver
74388>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74389>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74390>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
74391>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
74392>>>>>>>>>    End_Procedure
74393>>>>>>>>>
74393>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
74395>>>>>>>>>        Handle hDispatchDriver
74395>>>>>>>>>        Variant retVal
74395>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74396>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74397>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74398>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74399>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
74400>>>>>>>>>        Function_Return retVal
74401>>>>>>>>>    End_Function
74402>>>>>>>>>
74402>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
74404>>>>>>>>>        Handle hDispatchDriver
74404>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74405>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74406>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74407>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
74408>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
74409>>>>>>>>>    End_Procedure
74410>>>>>>>>>
74410>>>>>>>>>    Procedure ComAboutBox
74412>>>>>>>>>        Handle hDispatchDriver
74412>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74413>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
74414>>>>>>>>>    End_Procedure
74415>>>>>>>>>End_Class
74416>>>>>>>>>
74416>>>>>>>>>// CLSID: {C0DE2000-4463-4030-B324-AC6A8075FEC8}
74416>>>>>>>>>// Event interface for SkinFramework Control
74416>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
74417>>>>>>>>>
74417>>>>>>>>>    Procedure RegisterComEvents
74419>>>>>>>>>    End_Procedure
74420>>>>>>>>>End_Class
74421>>>>>>>>>
74421>>>>>>>>>// CoClass
74421>>>>>>>>>// ProgID: Codejock.SkinFramework.20.0.0
74421>>>>>>>>>// CLSID: {C0DE2000-2217-42EE-B1B0-82C890431F17}
74421>>>>>>>>>// SkinFramework Control
74421>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
74422>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
74423>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
74424>>>>>>>>>
74424>>>>>>>>>    Procedure Construct_Object
74426>>>>>>>>>        Forward Send Construct_Object
74428>>>>>>>>>        Set psProgID to "{C0DE2000-2217-42EE-B1B0-82C890431F17}"
74429>>>>>>>>>        Set psEventId to "{C0DE2000-4463-4030-B324-AC6A8075FEC8}"
74430>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2021 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v20.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
74431>>>>>>>>>        Set peAutoCreate to acAutoCreate
74432>>>>>>>>>    End_Procedure
74433>>>>>>>>>End_Class
74434>>>>>>>>>
74434>>>>>>>>>// CLSID: {C0DE2000-CA9A-4AA9-8601-0AB7F551AA3D}
74434>>>>>>>>>// SkinFramework Global Settings
74434>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
74435>>>>>>>>>
74435>>>>>>>>>    Function ComLicense Returns String
74437>>>>>>>>>        String retVal
74437>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
74438>>>>>>>>>        Function_Return retVal
74439>>>>>>>>>    End_Function
74440>>>>>>>>>
74440>>>>>>>>>    Procedure Set ComLicense String value
74442>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
74443>>>>>>>>>    End_Procedure
74444>>>>>>>>>
74444>>>>>>>>>    Function ComTitle Returns String
74446>>>>>>>>>        String retVal
74446>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
74447>>>>>>>>>        Function_Return retVal
74448>>>>>>>>>    End_Function
74449>>>>>>>>>
74449>>>>>>>>>    Procedure Set ComTitle String value
74451>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
74452>>>>>>>>>    End_Procedure
74453>>>>>>>>>
74453>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74453>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
74455>>>>>>>>>        Boolean retVal
74455>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
74456>>>>>>>>>        Function_Return retVal
74457>>>>>>>>>    End_Function
74458>>>>>>>>>
74458>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74458>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
74460>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
74461>>>>>>>>>    End_Procedure
74462>>>>>>>>>
74462>>>>>>>>>    Function ComVersion Returns String
74464>>>>>>>>>        Handle hDispatchDriver
74464>>>>>>>>>        String retVal
74464>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74465>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
74466>>>>>>>>>        Function_Return retVal
74467>>>>>>>>>    End_Function
74468>>>>>>>>>
74468>>>>>>>>>    Function ComUnicode Returns Boolean
74470>>>>>>>>>        Handle hDispatchDriver
74470>>>>>>>>>        Boolean retVal
74470>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74471>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
74472>>>>>>>>>        Function_Return retVal
74473>>>>>>>>>    End_Function
74474>>>>>>>>>
74474>>>>>>>>>    Function ComOcxPath Returns String
74476>>>>>>>>>        Handle hDispatchDriver
74476>>>>>>>>>        String retVal
74476>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74477>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
74478>>>>>>>>>        Function_Return retVal
74479>>>>>>>>>    End_Function
74480>>>>>>>>>End_Class
74481>>>>>>>>>
74481>>>>>>>>>// CoClass
74481>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.20.0.0
74481>>>>>>>>>// CLSID: {C0DE2000-F744-4373-B38D-29CE83EF0EE5}
74481>>>>>>>>>// SkinFramework Global Settings
74481>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
74482>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
74483>>>>>>>>>
74483>>>>>>>>>    Procedure Construct_Object
74485>>>>>>>>>        Forward Send Construct_Object
74487>>>>>>>>>        Set psProgID to "{C0DE2000-F744-4373-B38D-29CE83EF0EE5}"
74488>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
74489>>>>>>>>>    End_Procedure
74490>>>>>>>>>End_Class
74491>>>>>>>>>
74491>>>>>>>>>// CLSID: {C0DE2000-1038-498E-A936-361F08B4C4AA}
74491>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
74492>>>>>>>>>
74492>>>>>>>>>    Function ComColorScheme Returns String
74494>>>>>>>>>        String retVal
74494>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74495>>>>>>>>>        Function_Return retVal
74496>>>>>>>>>    End_Function
74497>>>>>>>>>
74497>>>>>>>>>    Procedure Set ComColorScheme String value
74499>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74500>>>>>>>>>    End_Procedure
74501>>>>>>>>>
74501>>>>>>>>>    Function ComFontSize Returns String
74503>>>>>>>>>        String retVal
74503>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74504>>>>>>>>>        Function_Return retVal
74505>>>>>>>>>    End_Function
74506>>>>>>>>>
74506>>>>>>>>>    Procedure Set ComFontSize String value
74508>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74509>>>>>>>>>    End_Procedure
74510>>>>>>>>>
74510>>>>>>>>>    Function ComIniFileName Returns String
74512>>>>>>>>>        String retVal
74512>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
74513>>>>>>>>>        Function_Return retVal
74514>>>>>>>>>    End_Function
74515>>>>>>>>>
74515>>>>>>>>>    Procedure Set ComIniFileName String value
74517>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
74518>>>>>>>>>    End_Procedure
74519>>>>>>>>>End_Class
74520>>>>>>>>>
74520>>>>>>>>>// CLSID: {C0DE2000-4834-499E-95B4-30E0C3F43A10}
74520>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
74521>>>>>>>>>
74521>>>>>>>>>    Function ComName Returns String
74523>>>>>>>>>        String retVal
74523>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74524>>>>>>>>>        Function_Return retVal
74525>>>>>>>>>    End_Function
74526>>>>>>>>>
74526>>>>>>>>>    Procedure Set ComName String value
74528>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74529>>>>>>>>>    End_Procedure
74530>>>>>>>>>
74530>>>>>>>>>    Function ComPath Returns String
74532>>>>>>>>>        String retVal
74532>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74533>>>>>>>>>        Function_Return retVal
74534>>>>>>>>>    End_Function
74535>>>>>>>>>
74535>>>>>>>>>    Procedure Set ComPath String value
74537>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74538>>>>>>>>>    End_Procedure
74539>>>>>>>>>
74539>>>>>>>>>    Function ComCount Returns Integer
74541>>>>>>>>>        Handle hDispatchDriver
74541>>>>>>>>>        Integer retVal
74541>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74542>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74543>>>>>>>>>        Function_Return retVal
74544>>>>>>>>>    End_Function
74545>>>>>>>>>
74545>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
74547>>>>>>>>>        Handle hDispatchDriver
74547>>>>>>>>>        Variant retVal
74547>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74548>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74549>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74550>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74551>>>>>>>>>        Function_Return retVal
74552>>>>>>>>>    End_Function
74553>>>>>>>>>
74553>>>>>>>>>    Function Com_NewEnum Returns Variant
74555>>>>>>>>>        Handle hDispatchDriver
74555>>>>>>>>>        Variant retVal
74555>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74556>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74557>>>>>>>>>        Function_Return retVal
74558>>>>>>>>>    End_Function
74559>>>>>>>>>End_Class
74560>>>>>>>>>
74560>>>>>>>>>// CLSID: {C0DE2000-FB37-4B08-A2B9-F6F8B253D697}
74560>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
74561>>>>>>>>>
74561>>>>>>>>>    Function ComCount Returns Integer
74563>>>>>>>>>        Handle hDispatchDriver
74563>>>>>>>>>        Integer retVal
74563>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74564>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74565>>>>>>>>>        Function_Return retVal
74566>>>>>>>>>    End_Function
74567>>>>>>>>>
74567>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
74569>>>>>>>>>        Handle hDispatchDriver
74569>>>>>>>>>        Variant retVal
74569>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74570>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74571>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74572>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74573>>>>>>>>>        Function_Return retVal
74574>>>>>>>>>    End_Function
74575>>>>>>>>>
74575>>>>>>>>>    Function Com_NewEnum Returns Variant
74577>>>>>>>>>        Handle hDispatchDriver
74577>>>>>>>>>        Variant retVal
74577>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74578>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74579>>>>>>>>>        Function_Return retVal
74580>>>>>>>>>    End_Function
74581>>>>>>>>>End_Class
74582>>>>>>>>>
74582>>>>>>>>>// CLSID: {C0DE2000-C56F-43C0-BCF1-8193B35FE4C4}
74582>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
74583>>>>>>>>>
74583>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74585>>>>>>>>>        Handle hDispatchDriver
74585>>>>>>>>>        OLE_COLOR retVal
74585>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74586>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74587>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74588>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
74589>>>>>>>>>        Function_Return retVal
74590>>>>>>>>>    End_Function
74591>>>>>>>>>End_Class
74592>>>>>>>Use cApplication.pkg
74592>>>>>>>
74592>>>>>>>Struct tSkinInformation
74592>>>>>>>    String sName     // description of the skin
74592>>>>>>>    String sSkinfile // file path. Can be relative or full
74592>>>>>>>    String sSkinIni  // section name
74592>>>>>>>End_Struct
74592>>>>>>>
74592>>>>>>>
74592>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
74593>>>>>>>    
74593>>>>>>>    Procedure Construct_Object
74595>>>>>>>        Forward Send Construct_Object
74597>>>>>>>        
74597>>>>>>>        Property String psSkinFile ""
74598>>>>>>>        Property String psSkinIni ""
74599>>>>>>>        Property Boolean pbLoadPreference False
74600>>>>>>>        
74600>>>>>>>        Set peAutoCreate to acAutoCreate
74601>>>>>>>        
74601>>>>>>>        Move Self to ghoSkinFramework
74602>>>>>>>    End_Procedure
74603>>>>>>>    
74603>>>>>>>    // return the default skin path, which is the programs directory.
74603>>>>>>>    // This requires an application object.
74603>>>>>>>    // If you want to different skin path, override this.
74603>>>>>>>    Function SkinPath Returns String
74605>>>>>>>        String sPath sPaths
74605>>>>>>>        Handle hoWorkspace
74605>>>>>>>        If ghoApplication Begin
74607>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74608>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
74609>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
74610>>>>>>>        End
74610>>>>>>>>
74610>>>>>>>        Else Begin
74611>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74612>>>>>>>>
74612>>>>>>>        End
74612>>>>>>>>
74612>>>>>>>        Function_Return sPath
74613>>>>>>>    End_Function
74614>>>>>>>    
74614>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
74614>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
74614>>>>>>>    Function SkinQFile Returns String
74616>>>>>>>        String sFile sPath sSep
74616>>>>>>>        Boolean bQualified
74616>>>>>>>        Get psSkinFile to sFile
74617>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
74619>>>>>>>            Get SkinPath to sPath
74620>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74621>>>>>>>            Move (sPath - sSep - sFile) to sFile
74622>>>>>>>        End
74622>>>>>>>>
74622>>>>>>>        Function_Return sFile
74623>>>>>>>    End_Function
74624>>>>>>>    
74624>>>>>>>    // defines the default VDF window class mapping.
74624>>>>>>>    Procedure OnAddVDFWindowClasses
74626>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
74627>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
74628>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
74629>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
74630>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
74631>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
74632>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
74633>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
74634>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
74635>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
74636>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
74637>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
74638>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
74639>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
74640>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
74641>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
74642>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74643>>>>>>>        // External class
74643>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74644>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74645>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74646>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74647>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74648>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74649>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74650>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74651>>>>>>>    End_Procedure
74652>>>>>>>    
74652>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
74652>>>>>>>    Procedure OnAddCustomWindowClasses
74654>>>>>>>    End_Procedure
74655>>>>>>>    
74655>>>>>>>    // called when object is created during end_construct_object.
74655>>>>>>>    Procedure OnCreate
74657>>>>>>>        Integer iOpts
74657>>>>>>>        Boolean bUseWindowsFont
74657>>>>>>>        Forward Send OnCreate
74659>>>>>>>        
74659>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
74659>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
74659>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74660>>>>>>>        If bUseWindowsFont Begin
74662>>>>>>>            Get ComApplyOptions to iOpts
74663>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74664>>>>>>>        End
74664>>>>>>>>
74664>>>>>>>        
74664>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74664>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74664>>>>>>>        // and this was the suggested workaround.
74664>>>>>>>        Set ComAutoApplyNewThreads to False
74665>>>>>>>        
74665>>>>>>>        Send OnAddVDFWindowClasses
74666>>>>>>>        Send OnAddCustomWindowClasses
74667>>>>>>>        
74667>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74667>>>>>>>        If (pbLoadPreference(Self)) Begin
74669>>>>>>>            Send LoadSkinPreference
74670>>>>>>>        End
74670>>>>>>>>
74670>>>>>>>        // if a skin file name exists, we apply the skin.
74670>>>>>>>        If (psSkinFile(Self)<>"") Begin
74672>>>>>>>            Send ApplySkin
74673>>>>>>>        End
74673>>>>>>>>
74673>>>>>>>    End_Procedure
74674>>>>>>>    
74674>>>>>>>    // called by framework as part of application exit.
74674>>>>>>>    Procedure Broadcast_Notify_Exit_Application
74676>>>>>>>        Send Notify_Exit_Application
74677>>>>>>>    End_Procedure
74678>>>>>>>    
74678>>>>>>>    Procedure Notify_Exit_Application
74680>>>>>>>        If (pbLoadPreference(Self)) Begin
74682>>>>>>>            Send SaveSkinPreference
74683>>>>>>>        End
74683>>>>>>>>
74683>>>>>>>    End_Procedure
74684>>>>>>>    
74684>>>>>>>    Procedure NotifyPreApplySkin
74686>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
74688>>>>>>>    End_Procedure
74689>>>>>>>    
74689>>>>>>>    Procedure NotifyPostApplySkin
74691>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
74693>>>>>>>    End_Procedure
74694>>>>>>>    
74694>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
74694>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
74694>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74696>>>>>>>        tSkinInformation[] Skins
74696>>>>>>>        tSkinInformation[] Skins
74697>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
74697>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74697>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74697>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74697>>>>>>>        Integer iPos iDfltLen
74697>>>>>>>        Boolean bUseRelativePath
74697>>>>>>>        
74697>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74698>>>>>>>        
74698>>>>>>>        Get SkinPath to sDefaultPath
74699>>>>>>>        If (sPath="") Begin
74701>>>>>>>            Move sDefaultPath to sPath
74702>>>>>>>        End
74702>>>>>>>>
74702>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74703>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
74704>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74705>>>>>>>        
74705>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74706>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74708>>>>>>>            
74708>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74709>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
74710>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74711>>>>>>>            
74711>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74712>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74713>>>>>>>            
74713>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74719>>>>>>>>
74719>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74720>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
74721>>>>>>>                
74721>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
74722>>>>>>>                
74722>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
74728>>>>>>>>
74728>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74729>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74730>>>>>>>                    
74730>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74731>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
74732>>>>>>>                    If bUseRelativePath Begin
74734>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74735>>>>>>>                        If iPos Begin
74737>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74738>>>>>>>                            While (Left(sSkinFile,1)=sSep)
74742>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74743>>>>>>>                            Loop
74744>>>>>>>>
74744>>>>>>>                        End
74744>>>>>>>>
74744>>>>>>>                    End
74744>>>>>>>>
74744>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74745>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74746>>>>>>>                    
74746>>>>>>>                    Increment iArrayItem
74747>>>>>>>                Loop
74748>>>>>>>>
74748>>>>>>>            Loop
74749>>>>>>>>
74749>>>>>>>            
74749>>>>>>>            Send Destroy of hSkinDescriptions
74750>>>>>>>            Send Destroy of hSkinDescription
74751>>>>>>>            Send Destroy of hSkinIniFile
74752>>>>>>>            
74752>>>>>>>        End
74752>>>>>>>>
74752>>>>>>>        Function_Return Skins
74753>>>>>>>    End_Function
74754>>>>>>>    
74754>>>>>>>    // Save the skin preference. This requires an application object.
74754>>>>>>>    // Only do this if the application object allows it.
74754>>>>>>>    // This is called during startup if pbLoadPreference is True
74754>>>>>>>    // Suitable for override
74754>>>>>>>    Procedure SaveSkinPreference
74756>>>>>>>        String sSkin sIni
74756>>>>>>>        If ghoApplication Begin
74758>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74760>>>>>>>                Get psSkinFile to sSkin
74761>>>>>>>                Get psSkinIni to sIni
74762>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74763>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74764>>>>>>>            End
74764>>>>>>>>
74764>>>>>>>        End
74764>>>>>>>>
74764>>>>>>>        Else Begin
74765>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74766>>>>>>>>
74766>>>>>>>        End
74766>>>>>>>>
74766>>>>>>>    End_Procedure
74767>>>>>>>    
74767>>>>>>>    // Load the skin preference. This requires an application object.
74767>>>>>>>    // Only do this if the application object allows it.
74767>>>>>>>    // This is called during startup if pbLoadPreference is True
74767>>>>>>>    // Suitable for override
74767>>>>>>>    Procedure LoadSkinPreference
74769>>>>>>>        String sSkin sIni
74769>>>>>>>        Boolean bExists
74769>>>>>>>        If ghoApplication Begin
74771>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74773>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74774>>>>>>>                If bExists Begin
74776>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74777>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
74778>>>>>>>                    Set psSkinFile to sSkin
74779>>>>>>>                    Set psSkinIni to sIni
74780>>>>>>>                End
74780>>>>>>>>
74780>>>>>>>            End
74780>>>>>>>>
74780>>>>>>>        End
74780>>>>>>>>
74780>>>>>>>        Else Begin
74781>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74782>>>>>>>>
74782>>>>>>>        End
74782>>>>>>>>
74782>>>>>>>    End_Procedure
74783>>>>>>>    
74783>>>>>>>    // Can be called to apply the current skin.
74783>>>>>>>    Procedure ApplySkin
74785>>>>>>>        Boolean bOk
74785>>>>>>>        String sSkin sIni
74785>>>>>>>        If (IsComObjectCreated(Self)) Begin
74787>>>>>>>            Get SkinQFile to sSkin
74788>>>>>>>            Get psSkinIni to sIni
74789>>>>>>>            
74789>>>>>>>            Send NotifyPreApplySkin
74790>>>>>>>            // when skins are used we don't want to use built in Visual Styles
74790>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
74791>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
74792>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
74794>>>>>>>                // if not ok, no skin was appied. Enable visual styles
74794>>>>>>>                Send EnableVisualStyles of Desktop True
74795>>>>>>>            End
74795>>>>>>>>
74795>>>>>>>            Send NotifyPostApplySkin
74796>>>>>>>        End
74796>>>>>>>>
74796>>>>>>>    End_Procedure
74797>>>>>>>    
74797>>>>>>>    
74797>>>>>>>End_Class
74798>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cProgressBar.pkg)
74798>>>>>>>Use Windows.pkg
74798>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cWinControl.pkg)
74798>>>>>>>>>Use Windows.pkg
74798>>>>>>>>>
74798>>>>>>>>>// Key State Masks for Mouse Messages
74798>>>>>>>>>
74798>>>>>>>>>Define MK_LBUTTON  for |CI$0001
74798>>>>>>>>>Define MK_RBUTTON  for |CI$0002
74798>>>>>>>>>Define MK_SHIFT    for |CI$0004
74798>>>>>>>>>Define MK_CONTROL  for |CI$0008
74798>>>>>>>>>Define MK_MBUTTON  for |CI$0010
74798>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
74798>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
74798>>>>>>>>>
74798>>>>>>>>>Enum_List // Mouse Key Flags
74798>>>>>>>>>    Define mkLeft    for MK_LBUTTON
74798>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
74798>>>>>>>>>    Define mkRight   for MK_RBUTTON
74798>>>>>>>>>    Define mkX1      for MK_XBUTTON1
74798>>>>>>>>>    Define mkX2      for MK_XBUTTON2
74798>>>>>>>>>    Define mkShift   for MK_SHIFT
74798>>>>>>>>>    Define mkControl for MK_CONTROL
74798>>>>>>>>>End_Enum_List
74798>>>>>>>>>
74798>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
74798>>>>>>>>>    Define mbLeft
74798>>>>>>>>>    Define mbMiddle
74798>>>>>>>>>    Define mbRight
74798>>>>>>>>>    Define mbX1
74798>>>>>>>>>    Define mbX2
74798>>>>>>>>>End_Enum_List
74798>>>>>>>>>
74798>>>>>>>>>Class cWinControl is a DfBaseControl
74799>>>>>>>>>    Procedure Construct_Object
74801>>>>>>>>>        Forward Send Construct_Object
74803>>>>>>>>>        Property Integer private_pbEnabled True
74804>>>>>>>>>        Property Integer private_pbVisible True
74805>>>>>>>>>    End_Procedure
74806>>>>>>>>>    
74806>>>>>>>>>    Procedure End_Construct_Object
74808>>>>>>>>>        Forward Send End_Construct_Object
74810>>>>>>>>>        
74810>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
74811>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
74812>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
74813>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
74814>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
74815>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
74816>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
74817>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
74818>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
74819>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
74820>>>>>>>>>    End_Procedure
74821>>>>>>>>>    
74821>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
74823>>>>>>>>>        //Intentionally cancelled
74823>>>>>>>>>    End_Procedure
74824>>>>>>>>>    
74824>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
74826>>>>>>>>>        //Intentionally cancelled
74826>>>>>>>>>    End_Procedure
74827>>>>>>>>>    
74827>>>>>>>>>    Procedure DoRecreateWindow
74829>>>>>>>>>        // Recreates the window
74829>>>>>>>>>        If (Window_Handle(Self)) Begin
74831>>>>>>>>>            // attempt to do this without disturbing the focus tree.
74831>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
74832>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
74833>>>>>>>>>        End
74833>>>>>>>>>>
74833>>>>>>>>>    End_Procedure
74834>>>>>>>>>    
74834>>>>>>>>>    Procedure DoUpdateWindow
74836>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
74836>>>>>>>>>        Handle hWnd
74836>>>>>>>>>        
74836>>>>>>>>>        Get Window_Handle to hWnd
74837>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
74840>>>>>>>>>    End_Procedure
74841>>>>>>>>>    
74841>>>>>>>>>    Procedure Page Integer iState
74843>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
74844>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
74845>>>>>>>>>        Forward Send Page iState
74847>>>>>>>>>    End_Procedure
74848>>>>>>>>>    
74848>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
74850>>>>>>>>>        Integer x y eButton
74850>>>>>>>>>        
74850>>>>>>>>>        Move (Hi(lParam))  to y
74851>>>>>>>>>        Move (Low(lParam)) to x
74852>>>>>>>>>        
74852>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
74853>>>>>>>>>    End_Procedure
74854>>>>>>>>>    
74854>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
74856>>>>>>>>>        Integer x y eButton
74856>>>>>>>>>        
74856>>>>>>>>>        Move (Hi(lParam))  to y
74857>>>>>>>>>        Move (Low(lParam)) to x
74858>>>>>>>>>        
74858>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
74859>>>>>>>>>    End_Procedure
74860>>>>>>>>>    
74860>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
74862>>>>>>>>>        Integer x y eButton
74862>>>>>>>>>        
74862>>>>>>>>>        Move (Hi(lParam))  to y
74863>>>>>>>>>        Move (Low(lParam)) to x
74864>>>>>>>>>        
74864>>>>>>>>>        Send OnMouseUp mbRight x y wParam
74865>>>>>>>>>    End_Procedure
74866>>>>>>>>>    
74866>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
74868>>>>>>>>>        Integer x y eButton fKeys
74868>>>>>>>>>        
74868>>>>>>>>>        Move (Hi(lParam))  to y
74869>>>>>>>>>        Move (Low(lParam)) to x
74870>>>>>>>>>        
74870>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
74871>>>>>>>>>    End_Procedure
74872>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
74874>>>>>>>>>        Integer x y eButton
74874>>>>>>>>>        
74874>>>>>>>>>        Move (Hi(lParam))  to y
74875>>>>>>>>>        Move (Low(lParam)) to x
74876>>>>>>>>>        
74876>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
74877>>>>>>>>>    End_Procedure
74878>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
74880>>>>>>>>>        Integer x y eButton
74880>>>>>>>>>        
74880>>>>>>>>>        Move (Hi(lParam))  to y
74881>>>>>>>>>        Move (Low(lParam)) to x
74882>>>>>>>>>        
74882>>>>>>>>>        Send OnMouseDown mbRight x y wParam
74883>>>>>>>>>    End_Procedure
74884>>>>>>>>>    
74884>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
74886>>>>>>>>>        Integer x y eButton
74886>>>>>>>>>        
74886>>>>>>>>>        Move (Hi(lParam))  to y
74887>>>>>>>>>        Move (Low(lParam)) to x
74888>>>>>>>>>        
74888>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
74889>>>>>>>>>    End_Procedure
74890>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
74892>>>>>>>>>        Integer x y eButton
74892>>>>>>>>>        
74892>>>>>>>>>        Move (Hi(lParam))  to y
74893>>>>>>>>>        Move (Low(lParam)) to x
74894>>>>>>>>>        
74894>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
74895>>>>>>>>>    End_Procedure
74896>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
74898>>>>>>>>>        Integer x y eButton
74898>>>>>>>>>        
74898>>>>>>>>>        Move (Hi(lParam))  to y
74899>>>>>>>>>        Move (Low(lParam)) to x
74900>>>>>>>>>        
74900>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
74901>>>>>>>>>    End_Procedure
74902>>>>>>>>>    
74902>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
74904>>>>>>>>>        Integer x y eButton
74904>>>>>>>>>        
74904>>>>>>>>>        Move (Hi(lParam))  to y
74905>>>>>>>>>        Move (Low(lParam)) to x
74906>>>>>>>>>        
74906>>>>>>>>>        Send OnMouseMove x y wParam
74907>>>>>>>>>    End_Procedure
74908>>>>>>>>>    
74908>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
74910>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74910>>>>>>>>>        //String sButton
74910>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74910>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74910>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74910>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74910>>>>>>>>>        
74910>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74910>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74910>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74910>>>>>>>>>    End_Procedure
74911>>>>>>>>>    
74911>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
74913>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74913>>>>>>>>>        //String sButton
74913>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74913>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74913>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74913>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74913>>>>>>>>>        
74913>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74913>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74913>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74913>>>>>>>>>    End_Procedure
74914>>>>>>>>>    
74914>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
74916>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74916>>>>>>>>>        //String sButton
74916>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74916>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74916>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74916>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74916>>>>>>>>>        
74916>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74916>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74916>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74916>>>>>>>>>    End_Procedure
74917>>>>>>>>>    
74917>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
74919>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74919>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74919>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74919>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74919>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74919>>>>>>>>>        
74919>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74919>>>>>>>>>    End_Procedure
74920>>>>>>>>>    
74920>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
74922>>>>>>>>>        Handle hWnd
74922>>>>>>>>>        
74922>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
74924>>>>>>>>>            Set private_pbEnabled to bEnabled
74925>>>>>>>>>            Get Window_Handle to hWnd
74926>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
74929>>>>>>>>>        End
74929>>>>>>>>>>
74929>>>>>>>>>    End_Procedure
74930>>>>>>>>>    Function pbEnabled Returns Boolean
74932>>>>>>>>>        Function_Return (private_pbEnabled(Self))
74933>>>>>>>>>    End_Function
74934>>>>>>>>>    
74934>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
74936>>>>>>>>>        Handle  hWnd
74936>>>>>>>>>        Integer iVoid
74936>>>>>>>>>        
74936>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
74938>>>>>>>>>            Set private_pbVisible to bVisible
74939>>>>>>>>>            Get Window_Handle to hWnd
74940>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
74943>>>>>>>>>        End
74943>>>>>>>>>>
74943>>>>>>>>>    End_Procedure
74944>>>>>>>>>    Function pbVisible Returns Boolean
74946>>>>>>>>>        Function_Return (private_pbVisible(Self))
74947>>>>>>>>>    End_Function
74948>>>>>>>>>    
74948>>>>>>>>>End_Class
74949>>>>>>>Use CommCtrl.pkg
74949>>>>>>>
74949>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
74949>>>>>>>Class cProgressBar is a cWinControl
74950>>>>>>>    
74950>>>>>>>    Procedure Construct_Object
74952>>>>>>>        Forward Send Construct_Object
74954>>>>>>>        Property Integer private_piMinimum
74955>>>>>>>        Property Integer private_piMaximum   100
74956>>>>>>>        Property Integer private_piAdvanceBy 10
74957>>>>>>>        Property Integer private_piPosition
74958>>>>>>>        Property Integer private_pbVertical  False
74959>>>>>>>        Property Integer private_pbSmooth    False
74960>>>>>>>        Property Integer private_piBackColor clDefault
74961>>>>>>>        Property Integer private_piBarColor  clDefault
74962>>>>>>>        
74962>>>>>>>        Send Define_ToolTip_Support_Mixin
74963>>>>>>>        
74963>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
74964>>>>>>>        Set Focus_Mode to NonFocusable
74965>>>>>>>        Set Skip_State to True
74966>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
74967>>>>>>>    End_Procedure
74968>>>>>>>    
74968>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
74969>>>>>>>    
74969>>>>>>>    Procedure Set piMinimum Integer iMin
74971>>>>>>>        Integer iMax
74971>>>>>>>        
74971>>>>>>>        Set private_piMinimum to iMin
74972>>>>>>>        Get private_piMaximum to iMax
74973>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74974>>>>>>>    End_Procedure
74975>>>>>>>    Function piMinimum Returns Integer
74977>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
74980>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
74982>>>>>>>    End_Function
74983>>>>>>>    
74983>>>>>>>    Procedure Set piMaximum Integer iMax
74985>>>>>>>        Integer iMin
74985>>>>>>>        
74985>>>>>>>        Set private_piMaximum to iMax
74986>>>>>>>        Get private_piMinimum to iMin
74987>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74988>>>>>>>    End_Procedure
74989>>>>>>>    Function piMaximum Returns Integer
74991>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
74994>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
74996>>>>>>>    End_Function
74997>>>>>>>    
74997>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
74999>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
75000>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
75001>>>>>>>    End_Procedure
75002>>>>>>>    Function piAdvanceBy Returns Integer
75004>>>>>>>        Function_Return (private_piAdvanceBy(Self))
75005>>>>>>>    End_Function
75006>>>>>>>    
75006>>>>>>>    Procedure Set piPosition Integer iPos
75008>>>>>>>        Set private_piPosition to iPos
75009>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
75010>>>>>>>    End_Procedure
75011>>>>>>>    
75011>>>>>>>    Function piPosition Returns Integer
75013>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
75016>>>>>>>        Else;            Function_Return (private_piPosition(Self))
75018>>>>>>>    End_Function
75019>>>>>>>    
75019>>>>>>>    Procedure Set pbVertical Boolean bVertical
75021>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
75023>>>>>>>            Set private_pbVertical to bVertical
75024>>>>>>>            Send DoRecreateWindow
75025>>>>>>>        End
75025>>>>>>>>
75025>>>>>>>    End_Procedure
75026>>>>>>>    
75026>>>>>>>    Function pbVertical Returns Boolean
75028>>>>>>>        Function_Return (private_pbVertical(Self))
75029>>>>>>>    End_Function
75030>>>>>>>    
75030>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
75032>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
75034>>>>>>>            Set private_pbSmooth to bSmooth
75035>>>>>>>            Send DoRecreateWindow
75036>>>>>>>        End
75036>>>>>>>>
75036>>>>>>>    End_Procedure
75037>>>>>>>    Function pbSmooth Returns Boolean
75039>>>>>>>        Function_Return (private_pbSmooth(Self))
75040>>>>>>>    End_Function
75041>>>>>>>    
75041>>>>>>>    Procedure Set piBackColor Integer rgbColor
75043>>>>>>>        Set private_piBackColor to rgbColor
75044>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
75045>>>>>>>    End_Procedure
75046>>>>>>>    Function piBackColor Returns Integer
75048>>>>>>>        Function_Return (private_piBackColor(Self))
75049>>>>>>>    End_Function
75050>>>>>>>    
75050>>>>>>>    Procedure Set piBarColor Integer rgbColor
75052>>>>>>>        Set private_piBarColor to rgbColor
75053>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
75054>>>>>>>    End_Procedure
75055>>>>>>>    Function piBarColor Returns Integer
75057>>>>>>>        Function_Return (private_piBarColor(Self))
75058>>>>>>>    End_Function
75059>>>>>>>    
75059>>>>>>>    Procedure DoAdvance
75061>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
75062>>>>>>>    End_Procedure
75063>>>>>>>    
75063>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
75065>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
75066>>>>>>>    End_Procedure
75067>>>>>>>    
75067>>>>>>>    Procedure private_DoInitWindow
75069>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
75070>>>>>>>        Set piBackColor to (private_piBackColor(Self))
75071>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
75072>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
75073>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
75074>>>>>>>        Set piPosition  to (private_piPosition(Self))
75075>>>>>>>    End_Procedure
75076>>>>>>>    
75076>>>>>>>    Procedure Page_Object Integer iState
75078>>>>>>>        Handle hWnd
75078>>>>>>>        
75078>>>>>>>        Get Window_Handle to hWnd
75079>>>>>>>        If (hWnd=0 and iState) Begin
75081>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
75082>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
75083>>>>>>>            Forward Send Page_Object True
75085>>>>>>>        End
75085>>>>>>>>
75085>>>>>>>        Else ;            Forward Send Page_Object iState
75088>>>>>>>        
75088>>>>>>>        // Handle tooltip support....
75088>>>>>>>        If (iState = 0) Begin
75090>>>>>>>            Send RequestDeleteToolTip
75091>>>>>>>        End
75091>>>>>>>>
75091>>>>>>>        Else Begin
75092>>>>>>>            Send RequestAddToolTip
75093>>>>>>>        End
75093>>>>>>>>
75093>>>>>>>    End_Procedure
75094>>>>>>>    
75094>>>>>>>    Procedure Page Integer iState
75096>>>>>>>        Forward Send Page iState
75098>>>>>>>        If (iState =1);            Send private_DoInitWindow
75101>>>>>>>    End_Procedure
75102>>>>>>>    
75102>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
75102>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
75102>>>>>>>    // is implemented in a mixin class.
75102>>>>>>>    Procedure RequestAddToolTip
75104>>>>>>>        Send AddToolTip
75105>>>>>>>    End_Procedure
75106>>>>>>>    
75106>>>>>>>    
75106>>>>>>>    // Called by Page_Object. Handles tooltip removal.
75106>>>>>>>    Procedure RequestDeleteToolTip
75108>>>>>>>        Send DeleteToolTip
75109>>>>>>>    End_Procedure
75110>>>>>>>End_Class
75111>>>>>Use Windows.pkg
75111>>>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\DUFLanguageConstants.inc)
75111>>>>>>>// *** The Database Update Framework Include file for Languages ***
75111>>>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
75111>>>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
75111>>>>>>>//
75111>>>>>>>Use LanguageText.Pkg
75111>>>>>>>
75111>>>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
75111>>>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
75111>>>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
75111>>>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
75111>>>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
75111>>>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
75111>>>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
75111>>>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
75111>>>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
75111>>>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
75111>>>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
75111>>>>>>>    Define CS_DUF_CopyingData               for "Copying data"
75111>>>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
75111>>>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
75111>>>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
75111>>>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
75111>>>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
75111>>>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
75111>>>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
75111>>>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
75111>>>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
75111>>>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
75111>>>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
75111>>>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
75111>>>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
75111>>>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
75111>>>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
75111>>>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
75111>>>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
75111>>>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
75111>>>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
75111>>>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
75111>>>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
75111>>>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
75111>>>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
75111>>>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
75111>>>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
75111>>>>>>>
75111>>>>>>>
75111>>>>>>>
75111>>>>>>>
75111>>>>>>>
75111>>>>>>>
75111>>>>>>>
75111>>>>>>>
75111>>>>>>>
75111>>>>>>>
75111>>>>>>>
75111>>>>>>>
75111>>>>>
75111>>>>>
75111>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
75111>>>>>
75111>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
75111>>>>>
75111>>>>>Object Status_Panel is a cProcessStatusPanel
75113>>>>>    Set Size to 152 222
75114>>>>>    Set Border_Style to Border_Dialog
75115>>>>>    Set Icon to "Default.ico"
75116>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
75117>>>>>
75117>>>>>    Property Boolean Cancel_Button_Visible_State True
75119>>>>>
75119>>>>>    Procedure Activate
75122>>>>>        Integer iSizeBefore
75122>>>>>        Get GuiSize to iSizeBefore
75123>>>>>        Forward Send Activate
75125>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
75126>>>>>    End_Procedure
75127>>>>>
75127>>>>>    Procedure End_Construct_Object
75130>>>>>        Forward Send End_Construct_Object
75132>>>>>        Set Label of oTitleTxt      to ""
75133>>>>>        Set Label of oTableNameTxt  to ""
75134>>>>>        Set Label of oMessageTxt    to ""
75135>>>>>        Set Label of oActionTxt     to ""
75136>>>>>    End_Procedure
75137>>>>>
75137>>>>>    Object oTitleTxt is a TextBox
75139>>>>>        Set Location to 5 21
75140>>>>>        Set Size to 8 179
75141>>>>>        Set Auto_Size_State to False
75142>>>>>        Set Justification_Mode  to jMode_Center
75143>>>>>        Set Label to "This is the Title Text"
75144>>>>>    End_Object
75145>>>>>
75145>>>>>    Object oTableNameTxt is a TextBox
75147>>>>>        Set Size to 19 204
75148>>>>>        Set Location to 18 9
75149>>>>>        Set Auto_Size_State to False
75150>>>>>        Set Justification_Mode to JMode_Left
75151>>>>>        Set Label to "This is the TableName Text"
75152>>>>>    End_Object
75153>>>>>
75153>>>>>    Object oMessageTxt is a TextBox
75155>>>>>        Set Location to 39 9
75156>>>>>        Set Size to 19 204
75157>>>>>        Set Auto_Size_State to False
75158>>>>>        Set Justification_Mode to JMode_Left
75159>>>>>        Set Label to "This is the Message text"
75160>>>>>    End_Object
75161>>>>>
75161>>>>>    Object oActionTxt is a TextBox
75163>>>>>        Set Size to 16 204
75164>>>>>        Set Location to 60 9
75165>>>>>        Set Auto_Size_State to False
75166>>>>>        Set Justification_Mode to JMode_Left
75167>>>>>        Set Label to "This is the Action Text"
75168>>>>>    End_Object
75169>>>>>
75169>>>>>    Object oStopButton is a Button
75171>>>>>        Set Location to 123 82
75172>>>>>        Set Label to C_$Cancel
75173>>>>>
75173>>>>>        Procedure OnClick 
75176>>>>>            Integer iRetval
75176>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
75177>>>>>            If (iRetval = MBR_Yes) Begin
75179>>>>>                Send Exit_Application
75180>>>>>            End
75180>>>>>>
75180>>>>>        End_Procedure
75181>>>>>
75181>>>>>    End_Object
75182>>>>>
75182>>>>>    Object oPercentage_tb is a TextBox
75184>>>>>        Set Location to 74 196
75185>>>>>        Set Size to 10 25
75186>>>>>//        Set Label to "% Done"
75186>>>>>    End_Object
75187>>>>>
75187>>>>>    Object oCopyRight is a TextBox
75189>>>>>        Set Location to 140 21
75190>>>>>        Set Size to 9 197
75191>>>>>        Set FontPointHeight to 8
75192>>>>>        Set Auto_Size_State to False
75193>>>>>        Set Justification_Mode  to jMode_Center
75194>>>>>        Set Label to "Copyright 2001-2020 RDC Tools International"
75195>>>>>    End_Object
75196>>>>>
75196>>>>>    Object oProgressBar is a cProgressBar
75198>>>>>        Set Size to 10 179
75199>>>>>        Set Location to 83 22
75200>>>>>        Set pbVisible to True // default
75201>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
75202>>>>>    End_Object
75203>>>>>
75203>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
75206>>>>>        Set pbVisible of ghoProgressBar to bVisible
75207>>>>>    End_Procedure
75208>>>>>
75208>>>>>    Function Progress_Bar_Visible_State Returns Boolean
75211>>>>>        Boolean bVisible
75211>>>>>        Get pbVisible of ghoProgressBar to bVisible
75212>>>>>        Function_Return (bVisible)
75213>>>>>    End_Function
75214>>>>>
75214>>>>>    Object oProgressBarOverall is a cProgressBar
75216>>>>>        Set Size to 10 179
75217>>>>>        Set Location to 107 22
75218>>>>>        Set pbVisible to True // default
75219>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
75220>>>>>    End_Object
75221>>>>>
75221>>>>>    Object oOverallProgress_tb is a TextBox
75223>>>>>        Set Size to 10 65
75224>>>>>        Set Location to 95 24
75225>>>>>        Set Label to "Overall Progress"
75226>>>>>    End_Object
75227>>>>>
75227>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
75230>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
75231>>>>>    End_Procedure
75232>>>>>
75232>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
75235>>>>>        Boolean bVisible
75235>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
75236>>>>>        Function_Return (bVisible)
75237>>>>>    End_Function
75238>>>>>
75238>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
75238>>>>>    // objects defined within this instance of the status panel.
75238>>>>>
75238>>>>>    // note: all of the messages that change text should be forwarded
75238>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
75238>>>>>
75238>>>>>    Procedure Set Message_Text String sText
75241>>>>>        Set Label of oMessageTxt to sText
75242>>>>>        Forward Set Message_Text to sText
75244>>>>>    End_Procedure
75245>>>>>
75245>>>>>    Function Message_Text Returns String
75248>>>>>        Function_Return (Label(oMessageTxt))
75249>>>>>    End_Function
75250>>>>>
75250>>>>>    Procedure Set Action_Text String sText
75253>>>>>        Set Label of oActionTxt to sText
75254>>>>>        Forward Set Action_Text to sText
75256>>>>>    End_Procedure
75257>>>>>
75257>>>>>    Function Action_Text Returns String
75260>>>>>        Function_Return (Label(oActionTxt))
75261>>>>>    End_Function
75262>>>>>
75262>>>>>    Procedure Set Button_Text String sText
75265>>>>>        Set Label of oStopButton to sText
75266>>>>>        Forward Set Button_Text to sText
75268>>>>>    End_Procedure
75269>>>>>
75269>>>>>    Function Button_Text Returns String
75272>>>>>        Function_Return (Label(oStopButton))
75273>>>>>    End_Function
75274>>>>>
75274>>>>>    Procedure Set Title_Text String sText
75277>>>>>        Set Label of oTitleTxt to sText
75278>>>>>        Forward Set Title_Text to sText
75280>>>>>    End_Procedure
75281>>>>>
75281>>>>>    Function Title_Text Returns String
75284>>>>>        Function_Return (Label(oTitleTxt))
75285>>>>>    End_Function
75286>>>>>
75286>>>>>    Procedure Set TableName_Text String sText
75289>>>>>        Set Label of oTableNameTxt to sText
75290>>>>>    End_Procedure
75291>>>>>
75291>>>>>    Function TableName_Text Returns String
75294>>>>>        Function_Return (Label(oTableNameTxt))
75295>>>>>    End_Function
75296>>>>>
75296>>>>>    Procedure Set License_Text String sText
75299>>>>>//        Set Label of oLicense_txt to sText
75299>>>>>    End_Procedure
75300>>>>>
75300>>>>>    // gets called when status panel is activated passing whether a button
75300>>>>>    // should appear
75300>>>>>    Procedure EnableCancelButton Boolean bEnable
75303>>>>>        Boolean bVisible
75303>>>>>        Get Cancel_Button_Visible_State to bVisible
75304>>>>>        If (bEnable = False) Begin
75306>>>>>            Set Visible_State of oStopButton to bVisible
75307>>>>>        End
75307>>>>>>
75307>>>>>        Set Enabled_State of oStopButton to bEnable
75308>>>>>    End_Procedure
75309>>>>>
75309>>>>>    Procedure Reset_StatusPanel
75312>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
75313>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
75314>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
75315>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
75316>>>>>    End_Procedure
75317>>>>>
75317>>>>>//    Object oProgressBar is a cProgressBar
75317>>>>>//        Move Self to ghoProgressBar
75317>>>>>//        Set Location to 1 25
75317>>>>>//        Set Size to 9 173
75317>>>>>//        Set piMinimum        to 0
75317>>>>>//        Set piMaximum        to 2000
75317>>>>>//        Set piAdvanceBy      to 100
75317>>>>>//        Set pbSmooth to True
75317>>>>>//
75317>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
75317>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
75317>>>>>//        // color will show correctly.
75317>>>>>//        Procedure Page Integer iPageObject
75317>>>>>//            Handle hWin
75317>>>>>//            Forward Send Page iPageObject
75317>>>>>//            If (ghoSkinFramework <> 0) Begin
75317>>>>>//                Get Window_Handle to hWin
75317>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
75317>>>>>//            End
75317>>>>>//        End_Procedure
75317>>>>>//    End_Object
75317>>>>>
75317>>>>>End_Object
75318>>>>>
75318>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
75318>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
75318>>>>>//
75318>>>>>// We need to create a mixin class for the library.
75318>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
75318>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
75318>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
75318>>>>>// Note: This class should _not_ have a construct_object defined.
75318>>>>>//
75318>>>>>Use VdfBase.pkg
75318>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 20.1\Pkg\WinUuid.pkg)
75318>>>>>>>Use Unicode.Pkg
75318>>>>>>>
75318>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
75319>>>>>>>
75319>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
75320>>>>>>>
75320>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
75321>>>>>>>
75321>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
75322>>>>>>>
75322>>>>>>>
75322>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
75322>>>>>>>Function RandomHexUUID Global Returns String
75324>>>>>>>    Pointer pUUID pUUIDStr
75324>>>>>>>    Integer iRetval iOffset iChar
75324>>>>>>>    String sUUID
75324>>>>>>>    
75324>>>>>>>    Move (Alloc(16)) to pUUID
75325>>>>>>>    
75325>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
75326>>>>>>>    
75326>>>>>>>    If (iRetval = 0) Begin
75328>>>>>>>        Move 0 to pUUIDStr
75329>>>>>>>        
75329>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75330>>>>>>>        If (iRetval = 0) Begin
75332>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75333>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75334>>>>>>>            
75334>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75335>>>>>>>        End
75335>>>>>>>>
75335>>>>>>>    End
75335>>>>>>>>
75335>>>>>>>    
75335>>>>>>>    Move (Free(pUUID)) to iRetval
75336>>>>>>>    
75336>>>>>>>    Function_Return sUUID
75337>>>>>>>End_Function
75338>>>>>>>
75338>>>>>>>
75338>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
75338>>>>>>>Function SeqHexUUID Global Returns String
75340>>>>>>>    Pointer pUUID pUUIDStr
75340>>>>>>>    Integer iRetval iOffset iChar
75340>>>>>>>    String sUUID
75340>>>>>>>    
75340>>>>>>>    Move (Alloc(16)) to pUUID
75341>>>>>>>    
75341>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
75342>>>>>>>    
75342>>>>>>>    If (iRetval = 0) Begin
75344>>>>>>>        Move 0 to pUUIDStr
75345>>>>>>>        
75345>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75346>>>>>>>        If (iRetval = 0) Begin
75348>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75349>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75350>>>>>>>            
75350>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75351>>>>>>>        End
75351>>>>>>>>
75351>>>>>>>    End
75351>>>>>>>>
75351>>>>>>>    
75351>>>>>>>    Move (Free(pUUID)) to iRetval
75352>>>>>>>    
75352>>>>>>>    Function_Return sUUID
75353>>>>>>>End_Function
75354>>>>>Use cli.pkg
75354>>>>>Use sql.pkg
75354>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\MSSqldrv.pkg)
75354>>>>>>>//     Package that declares MS SQL driver constants and functions.
75354>>>>>>>//     This package can be used by developers who want to add Data Access
75354>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75354>>>>>>>
75354>>>>>>>Use Cli.pkg
75354>>>>>>>Use SQL.pkg
75354>>>>>>>
75354>>>>>>>//   Driver Indentification
75354>>>>>>>
75354>>>>>>>//   Error number constants
75354>>>>>>>
75354>>>>>>>
75354>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75354>>>>>>>
75354>>>>>>>
75354>>>>>>>
75354>>>>>>>
75354>>>>>>>
75354>>>>>>>
75354>>>>>>>// SQL Server spcific types.
75354>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75354>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75354>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75354>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75354>>>>>>>
75354>>>>>>>// SQL Server spcific types.
75354>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75354>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75354>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75354>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75354>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75354>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75354>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75354>>>>>>>
75354>>>>>>>
75354>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75354>>>>>>>//
75354>>>>>>>//     Setup a constraint for a file.
75354>>>>>>>
75354>>>>>>>
75354>>>>>>>Class cMSSQLHandler is a cCLIHandler
75355>>>>>>>    
75355>>>>>>>    Procedure Construct_Object
75357>>>>>>>        Forward Send Construct_Object
75359>>>>>>>        
75359>>>>>>>        Set psDriverID to MSSQLDRV_ID
75360>>>>>>>    End_Procedure
75361>>>>>>>    
75361>>>>>>>    
75361>>>>>>>    
75361>>>>>>>    //   Extract the list from the out connect string.
75361>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75363>>>>>>>        String  sItem
75363>>>>>>>        Integer iStart
75363>>>>>>>        Integer iEnd
75363>>>>>>>        
75363>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75366>>>>>>>        
75366>>>>>>>        Send Delete_Data to hoStore
75367>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75368>>>>>>>        While (iStart > 0)
75372>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75373>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75376>>>>>>>            Else Begin
75377>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75378>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75379>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75382>>>>>>>                
75382>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75385>>>>>>>                
75385>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75388>>>>>>>            End
75388>>>>>>>>
75388>>>>>>>        Loop
75389>>>>>>>>
75389>>>>>>>        
75389>>>>>>>        Function_Return (Item_Count(hoStore))
75390>>>>>>>    End_Procedure
75391>>>>>>>    
75391>>>>>>>    
75391>>>>>>>    
75391>>>>>>>    //   Call the driver's browse connect function
75391>>>>>>>    Function BrowseConnect String sInConnStr Returns String
75393>>>>>>>        String  sDriver
75393>>>>>>>        String  sOutConnStr
75393>>>>>>>        Integer iArg
75393>>>>>>>        Integer iRetval
75393>>>>>>>        
75393>>>>>>>        Get psDriverID to sDriver
75394>>>>>>>        If (sDriver <> "") Begin
75396>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75397>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75402>>>>>>>        End
75402>>>>>>>>
75402>>>>>>>        
75402>>>>>>>        Function_Return sOutConnStr
75403>>>>>>>    End_Function// BrowseConnect
75404>>>>>>>    
75404>>>>>>>    
75404>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
75406>>>>>>>        String  sDriver
75406>>>>>>>        String  sOutConnStr
75406>>>>>>>        Integer iArg
75406>>>>>>>        Integer iRetval
75406>>>>>>>        
75406>>>>>>>        Move 1 to iArg // Browses only local
75407>>>>>>>        
75407>>>>>>>        Get psDriverID to sDriver
75408>>>>>>>        If (sDriver <> "") Begin
75410>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75411>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75416>>>>>>>        End
75416>>>>>>>>
75416>>>>>>>        
75416>>>>>>>        Function_Return sOutConnStr
75417>>>>>>>    End_Function// BrowseConnect
75418>>>>>>>    
75418>>>>>>>    
75418>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
75420>>>>>>>        
75420>>>>>>>        String  sServerList
75420>>>>>>>        Integer iNumServers
75420>>>>>>>        Integer iDriver
75420>>>>>>>        Integer iClientVersion
75420>>>>>>>        String  sDriver
75420>>>>>>>        
75420>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75421>>>>>>>        
75421>>>>>>>        If (iDriver) Begin
75423>>>>>>>            
75423>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75426>>>>>>>            
75426>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
75427>>>>>>>            
75427>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
75428>>>>>>>            If (iNetworkLocal = 0) Begin
75430>>>>>>>                Get BrowseConnect sDriver to sServerList
75431>>>>>>>            End
75431>>>>>>>>
75431>>>>>>>            Else Begin
75432>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
75433>>>>>>>            End
75433>>>>>>>>
75433>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
75434>>>>>>>        End
75434>>>>>>>>
75434>>>>>>>        
75434>>>>>>>        Function_Return iNumServers
75435>>>>>>>        
75435>>>>>>>    End_Function
75436>>>>>>>    
75436>>>>>>>    //   Enumerate the available SQL Server database servers
75436>>>>>>>    //   This function will return all SQL Server instances on the network.
75436>>>>>>>    //   This may take a long time.
75436>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
75436>>>>>>>    Function EnumerateServers Returns Integer
75438>>>>>>>        
75438>>>>>>>        Integer iNumServers
75438>>>>>>>        Integer iNetworkLocal
75438>>>>>>>        
75438>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
75439>>>>>>>        
75439>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75440>>>>>>>        
75440>>>>>>>        Function_Return iNumServers
75441>>>>>>>        
75441>>>>>>>    End_Function
75442>>>>>>>    
75442>>>>>>>    
75442>>>>>>>    //   Enumerate the available SQL Server database servers
75442>>>>>>>    //   This function will return only return SQL Server instance on the local machine
75442>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
75442>>>>>>>    Function EnumerateServersLocal Returns Integer
75444>>>>>>>        
75444>>>>>>>        Integer iNumServers
75444>>>>>>>        Integer iNetworkLocal
75444>>>>>>>        
75444>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
75445>>>>>>>        
75445>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75446>>>>>>>        
75446>>>>>>>        Function_Return iNumServers
75447>>>>>>>        
75447>>>>>>>    End_Function
75448>>>>>>>    
75448>>>>>>>    
75448>>>>>>>    
75448>>>>>>>    //   Enumerate database in a given server.
75448>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
75450>>>>>>>        Integer hoSQL
75450>>>>>>>        String  sConnect
75450>>>>>>>        String  sDatabase
75450>>>>>>>        Integer hdbc
75450>>>>>>>        Integer hstmt
75450>>>>>>>        Integer iFetchResult
75450>>>>>>>        
75450>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
75453>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
75456>>>>>>>        
75456>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
75459>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
75461>>>>>>>        
75461>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
75463>>>>>>>            Move Current_Object to hoSQL
75464>>>>>>>        End_Object
75465>>>>>>>        
75465>>>>>>>        If (hoSQL <> 0) Begin
75467>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
75468>>>>>>>            If (hdbc <> 0) Begin
75470>>>>>>>                Get SQLOpen of hdbc to hstmt
75471>>>>>>>                If (hstmt <> 0) Begin
75473>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
75473>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
75473>>>>>>>                    //   approach in case meta data might change, the stored procedure will
75473>>>>>>>                    //   stay the same.
75473>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
75474>>>>>>>                    Send SQLCall to hstmt
75475>>>>>>>                    Repeat
75475>>>>>>>>
75475>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
75476>>>>>>>                        If (iFetchResult <> 0) Begin
75478>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
75479>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
75480>>>>>>>                        End
75480>>>>>>>>
75480>>>>>>>                    Until (iFetchResult = 0)
75482>>>>>>>                    
75482>>>>>>>                    Send SQLClose to hstmt
75483>>>>>>>                End
75483>>>>>>>>
75483>>>>>>>                Send SQLDisconnect to hdbc
75484>>>>>>>            End
75484>>>>>>>>
75484>>>>>>>        End
75484>>>>>>>>
75484>>>>>>>        Send Destroy_Object to hoSQL
75485>>>>>>>        
75485>>>>>>>        Function_Return (Item_Count(Current_Object))
75486>>>>>>>    End_Function
75487>>>>>>>    
75487>>>>>>>    
75487>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
75489>>>>>>>        
75489>>>>>>>        String  sSqlServerClientVersionName
75489>>>>>>>        
75489>>>>>>>        
75489>>>>>>>        Case Begin
75489>>>>>>>            
75489>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
75491>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
75492>>>>>>>                Case Break
75493>>>>>>>                
75493>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
75496>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
75497>>>>>>>                Case Break
75498>>>>>>>            
75498>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
75501>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
75502>>>>>>>                Case Break
75503>>>>>>>            
75503>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
75506>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
75507>>>>>>>                Case Break
75508>>>>>>>            
75508>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
75511>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
75512>>>>>>>                Case Break
75513>>>>>>>            
75513>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
75516>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
75517>>>>>>>                Case Break
75518>>>>>>>            
75518>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
75521>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
75522>>>>>>>                Case Break
75523>>>>>>>            
75523>>>>>>>            Case Else
75523>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
75524>>>>>>>                
75524>>>>>>>        Case End
75524>>>>>>>        
75524>>>>>>>        
75524>>>>>>>        Function_Return sSqlServerClientVersionName
75525>>>>>>>        
75525>>>>>>>    End_Function
75526>>>>>>>
75526>>>>>>>
75526>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
75528>>>>>>>        
75528>>>>>>>        String  sSqlServerClientDriverName
75528>>>>>>>        
75528>>>>>>>        Case Begin
75528>>>>>>>            
75528>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
75530>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
75531>>>>>>>                Case Break
75532>>>>>>>                
75532>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
75535>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
75536>>>>>>>                Case Break
75537>>>>>>>            
75537>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
75540>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
75541>>>>>>>                Case Break
75542>>>>>>>            
75542>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
75545>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
75546>>>>>>>                Case Break
75547>>>>>>>            
75547>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
75550>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
75551>>>>>>>                Case Break
75552>>>>>>>            
75552>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
75555>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
75556>>>>>>>                Case Break
75557>>>>>>>            
75557>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
75560>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
75561>>>>>>>                Case Break
75562>>>>>>>            
75562>>>>>>>            Case Else
75562>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
75563>>>>>>>                
75563>>>>>>>        Case End
75563>>>>>>>        
75563>>>>>>>        
75563>>>>>>>        Function_Return sSqlServerClientDriverName
75564>>>>>>>        
75564>>>>>>>    End_Function
75565>>>>>>>    
75565>>>>>>>    
75565>>>>>>>End_Class
75566>>>>>>>
75566>>>>>>>
75566>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\db2_drv.pkg)
75566>>>>>>>// DB2_DRV.PKG                                                          
75566>>>>>>>//   Package that declares DB2 driver constants and functions.          
75566>>>>>>>//   This package can be used by developers who want to add DB2 driver  
75566>>>>>>>//   specific code to a DataFlex application.                           
75566>>>>>>>
75566>>>>>>>Use Cli.pkg
75566>>>>>>>
75566>>>>>>>// Driver attributes
75566>>>>>>>
75566>>>>>>>
75566>>>>>>>// Driver Indentification
75566>>>>>>>
75566>>>>>>>// Error number constants
75566>>>>>>>
75566>>>>>>>// Call driver function identifiers
75566>>>>>>>
75566>>>>>>>// DB2 specific data types
75566>>>>>>>Define SQL_CLOB           for   (-99)
75566>>>>>>>Define SQL_BLOB           for   (-98)
75566>>>>>>>Define SQL_XML            for   (-370)
75566>>>>>>>// DB2 Graphic types are Unicode types
75566>>>>>>>Define SQL_GRAPHIC        for   (-95)
75566>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
75566>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
75566>>>>>>>Define SQL_DBCLOB         for   (-350)
75566>>>>>>>
75566>>>>>>>
75566>>>>>>>// Extra DB2 commands
75566>>>>>>>
75566>>>>>>>
75566>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
75566>>>>>>>//   Setup a constraint for a file.                                     
75566>>>>>>>
75566>>>>>>>
75566>>>>>>>
75566>>>>>>>Class cDB2Handler is a cCLIHandler
75567>>>>>>>    
75567>>>>>>>    Procedure Construct_Object
75569>>>>>>>        Forward Send Construct_Object
75571>>>>>>>        
75571>>>>>>>        Set psDriverID to DB2_DRV_ID
75572>>>>>>>    End_Procedure
75573>>>>>>>    
75573>>>>>>>    
75573>>>>>>>    
75573>>>>>>>    // Reset the datasource list to the beginning
75573>>>>>>>    Procedure SeedDataSources
75575>>>>>>>        String  sDriver
75575>>>>>>>        String  sVoid
75575>>>>>>>        Integer iRetval
75575>>>>>>>        
75575>>>>>>>        Get psDriverID to sDriver
75576>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
75583>>>>>>>    End_Procedure
75584>>>>>>>    
75584>>>>>>>    
75584>>>>>>>    
75584>>>>>>>    // Call the driver's data sources function
75584>>>>>>>    Function DataSources Returns String
75586>>>>>>>        String  sDriver
75586>>>>>>>        String  sDataSource
75586>>>>>>>        String  sDescription
75586>>>>>>>        Integer iLength
75586>>>>>>>        Integer iRetval
75586>>>>>>>        
75586>>>>>>>        Get psDriverID to sDriver
75587>>>>>>>        If (sDriver <> "") Begin
75589>>>>>>>            Move 8192 to iLength
75590>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
75591>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
75592>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
75597>>>>>>>        End
75597>>>>>>>>
75597>>>>>>>        
75597>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
75600>>>>>>>        Else ;            Function_Return ""
75602>>>>>>>    End_Function
75603>>>>>>>    
75603>>>>>>>End_Class
75604>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\odbc_drv.pkg)
75604>>>>>>>//   Package that declares ODBC driver constants and functions.         
75604>>>>>>>//   This package can be used by developers who want to add Data Access 
75604>>>>>>>//   ODBC Client specific code to a DataFlex application.               
75604>>>>>>>
75604>>>>>>>Use Cli.pkg
75604>>>>>>>
75604>>>>>>>// Driver Indentification
75604>>>>>>>
75604>>>>>>>// Error number constants
75604>>>>>>>
75604>>>>>>>// Call driver function identifiers
75604>>>>>>>
75604>>>>>>>Class cODBCHandler is a cCLIHandler
75605>>>>>>>    
75605>>>>>>>    Procedure Construct_Object
75607>>>>>>>        Forward Send Construct_Object
75609>>>>>>>        
75609>>>>>>>        Set psDriverID to ODBC_DRV_ID
75610>>>>>>>    End_Procedure
75611>>>>>>>    
75611>>>>>>>    
75611>>>>>>>    
75611>>>>>>>    // Setup the type of data sources returned by the datasources function
75611>>>>>>>    Procedure Set DataSourceType Integer iNewType
75613>>>>>>>        String  sDriver
75613>>>>>>>        String  sVoid
75613>>>>>>>        Integer iRetval
75613>>>>>>>        
75613>>>>>>>        Get psDriverID to sDriver
75614>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
75621>>>>>>>    End_Procedure
75622>>>>>>>    
75622>>>>>>>    
75622>>>>>>>    // Call the driver's data sources function
75622>>>>>>>    Function DataSources Returns String
75624>>>>>>>        String  sDriver
75624>>>>>>>        String  sDataSource
75624>>>>>>>        String  sDescription
75624>>>>>>>        Integer iLength
75624>>>>>>>        Integer iRetval
75624>>>>>>>        
75624>>>>>>>        Get psDriverID to sDriver
75625>>>>>>>        If (sDriver <> "") Begin
75627>>>>>>>            Move 8192 to iLength
75628>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
75629>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
75630>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
75635>>>>>>>        End
75635>>>>>>>>
75635>>>>>>>        
75635>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
75638>>>>>>>        Else ;            Function_Return ""
75640>>>>>>>    End_Function
75641>>>>>>>    
75641>>>>>>>End_Class
75642>>>>>>>
75642>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 20.1\Pkg\DFBTRDRV.PKG)
75642>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
75642>>>>>>>// Notice      : This package contains constants and commands, used to call
75642>>>>>>>//               specific functions in the DFBTRDRV.
75642>>>>>>>Use Ui
75642>>>>>>>//
75642>>>>>>>// Driver Indentification
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>// Driver attributes
75642>>>>>>>//
75642>>>>>>>// Call_Driver functions ID's
75642>>>>>>>//
75642>>>>>>>//
75642>>>>>>>// DFBTRFN_CONVERT_FILE options
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// DFBTRFN_SET_OWNER options
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// Command to create all vars which may be needed
75642>>>>>>>// in other commands.
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// Command to set the owner of a Btrieve file.
75642>>>>>>>// File must have been opened.
75642>>>>>>>// Filenumber needs to be passed.
75642>>>>>>>// To clear set the owner to "".
75642>>>>>>>// Examples:
75642>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
75642>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
75642>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
75642>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
75642>>>>>>>// To clear:
75642>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// Command to parse DFBTR_SET_OWNVER
75642>>>>>>>// options.
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// Command to parse for Callback
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// Command to clear the owner of a Btrieve file.
75642>>>>>>>// File must have been opened.
75642>>>>>>>// Filenumber needs to be passed.
75642>>>>>>>// Examples:
75642>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// Command to add a owner name to the internal list of ownernames
75642>>>>>>>// which will be tries when opening files.
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// Command to remove all owners from the internal list of ownernames
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// Command to set the owner name to be used when opening the DDF files.
75642>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
75642>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
75642>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// Command to change the transaction type.
75642>>>>>>>// Valid types are:
75642>>>>>>>//     DFBTRTT_NONE
75642>>>>>>>//     DFBTRTT_EXCLUSIVE
75642>>>>>>>//     DFBTRTT_CONCURRENT
75642>>>>>>>//
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// Command to get the current transaction type.
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// Command to set explicit_locking
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// Command to get explicit locking
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>//
75642>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
75642>>>>>>>//
75642>>>>>>>
75642>>>>>>>// Purpose: An instance of this class can be used as a broker object to
75642>>>>>>>//          call several Dfbtrdrv releated methods.
75642>>>>>>>
75642>>>>>>>Class cDFBtrDrvHandler is an Array
75643>>>>>>>    
75643>>>>>>>    Procedure Construct_Object Integer iImage
75645>>>>>>>        Forward Send Construct_object iImage
75647>>>>>>>        
75647>>>>>>>        Property String  psDriverID "DFBTRDRV"
75648>>>>>>>    End_Procedure
75649>>>>>>>    
75649>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
75649>>>>>>>    //
75649>>>>>>>    
75649>>>>>>>    Function CKRevision Returns String
75651>>>>>>>        String  sDriverID
75651>>>>>>>        String  sRevision
75651>>>>>>>        String  sVoid
75651>>>>>>>        Integer iRetval
75651>>>>>>>        
75651>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75651>>>>>>>        // This error would otherwise be raised when we have an older
75651>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75651>>>>>>>        Send Ignore_error to Error_object_Id 20491
75652>>>>>>>        Get psDriverID to sDriverID
75653>>>>>>>        Move (Repeat(" ", 255)) to sRevision
75654>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
75659>>>>>>>        Send Trap_Error to Error_object_Id 20491
75660>>>>>>>        If (Trim(sRevision) = "") Begin
75662>>>>>>>            // Unable to get the revision. return all zeroes.
75662>>>>>>>            Move "0.0.0.0" to sRevision
75663>>>>>>>        End
75663>>>>>>>>
75663>>>>>>>        Function_Return sRevision
75664>>>>>>>    End_Function
75665>>>>>>>    
75665>>>>>>>    Function CkUsesUri Returns Integer
75667>>>>>>>        String  sDriverID
75667>>>>>>>        String  sVoid1
75667>>>>>>>        String  sVoid2
75667>>>>>>>        Integer iRetval
75667>>>>>>>        
75667>>>>>>>        Get psDriverID to sDriverID
75668>>>>>>>        
75668>>>>>>>        Move 0 to iRetval
75669>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75669>>>>>>>        // This error would otherwise be raised when we have an older
75669>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
75669>>>>>>>        Send Ignore_error to Error_object_Id 20491
75670>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
75675>>>>>>>        Send Trap_Error to Error_object_Id 20491
75676>>>>>>>        
75676>>>>>>>        Function_Return iRetval
75677>>>>>>>    End_Function
75678>>>>>>>    
75678>>>>>>>    
75678>>>>>>>    
75678>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
75678>>>>>>>    //
75678>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
75678>>>>>>>    //
75678>>>>>>>    
75678>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
75680>>>>>>>        Integer iPartRev
75680>>>>>>>        Integer iCurrentPart
75680>>>>>>>        Integer iSeparatorPos
75680>>>>>>>        
75680>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
75683>>>>>>>        
75683>>>>>>>        Move 0 to iCurrentPart
75684>>>>>>>        Repeat
75684>>>>>>>>
75684>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
75685>>>>>>>            If (iSeparatorPos > 0) Begin
75687>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
75688>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
75689>>>>>>>                Increment iCurrentPart
75690>>>>>>>            End
75690>>>>>>>>
75690>>>>>>>            Else If (sRevision <> "") Begin
75693>>>>>>>                Move sRevision to iPartRev
75694>>>>>>>                Move "" to sRevision
75695>>>>>>>                Increment iCurrentPart
75696>>>>>>>            End
75696>>>>>>>>
75696>>>>>>>            Else ;                Move -1 to iPartRev
75698>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
75700>>>>>>>        
75700>>>>>>>        Function_Return iPartRev
75701>>>>>>>    End_Function
75702>>>>>>>    
75702>>>>>>>    
75702>>>>>>>    
75702>>>>>>>    //
75702>>>>>>>    //  Returns the major revision of the CK
75702>>>>>>>    //
75702>>>>>>>    
75702>>>>>>>    Function CKMajorRevision Returns Integer
75704>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
75705>>>>>>>    End_Function
75706>>>>>>>    
75706>>>>>>>    
75706>>>>>>>    
75706>>>>>>>    //  Returns the minor revision of the CK
75706>>>>>>>    //
75706>>>>>>>    
75706>>>>>>>    Function CKMinorRevision Returns Integer
75708>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
75709>>>>>>>    End_Function
75710>>>>>>>    
75710>>>>>>>    
75710>>>>>>>    //  Returns the release revision of the CK
75710>>>>>>>    //
75710>>>>>>>    
75710>>>>>>>    Function CKReleaseRevision Returns Integer
75712>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
75713>>>>>>>    End_Function
75714>>>>>>>    
75714>>>>>>>    
75714>>>>>>>    //  Returns the major revision of the CK
75714>>>>>>>    //
75714>>>>>>>    
75714>>>>>>>    Function CKBuildRevision Returns Integer
75716>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
75717>>>>>>>    End_Function
75718>>>>>>>    
75718>>>>>>>    
75718>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
75718>>>>>>>    //
75718>>>>>>>    
75718>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
75720>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
75723>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
75726>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
75729>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
75732>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
75735>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
75739>>>>>>>            End
75739>>>>>>>>
75739>>>>>>>        End
75739>>>>>>>>
75739>>>>>>>        
75739>>>>>>>        Function_Return (False)
75740>>>>>>>    End_Function
75741>>>>>>>    
75741>>>>>>>    //   Functions to query the Pervasive.SQL version:
75741>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
75741>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
75741>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
75741>>>>>>>    //
75741>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
75741>>>>>>>    //   in the following format:
75741>>>>>>>    //       <version>.<revision>.<type>
75741>>>>>>>    //   possible values for <type>:
75741>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
75741>>>>>>>    //         server using Workgroup authentication mode
75741>>>>>>>    //       C for client cache engine
75741>>>>>>>    //       D for DOS workstation
75741>>>>>>>    //       N for client Requester
75741>>>>>>>    //       S for NetWare server
75741>>>>>>>    //       T for 32-bit Windows server engine
75741>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
75741>>>>>>>    //
75741>>>>>>>    //   example:
75741>>>>>>>    //       8.50.T
75741>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
75741>>>>>>>    //   32-bits Windows server.
75741>>>>>>>    //
75741>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
75741>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
75741>>>>>>>    //
75741>>>>>>>    //   If the version information is not available or can not be obtained
75741>>>>>>>    //   the functions will return "0.0.0"
75741>>>>>>>    
75741>>>>>>>    //  Returns the version information of the
75741>>>>>>>    //           Pervasive.SQL Client requester.
75741>>>>>>>    
75741>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
75743>>>>>>>        
75743>>>>>>>        String  sDriverID
75743>>>>>>>        String  sVersion
75743>>>>>>>        String  sVoid
75743>>>>>>>        Integer iRetval
75743>>>>>>>        
75743>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75743>>>>>>>        // This error would otherwise be raised when we have an older
75743>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75743>>>>>>>        Send Ignore_error to Error_object_Id 20491
75744>>>>>>>        Get psDriverID to sDriverID
75745>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75746>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75751>>>>>>>        Send Trap_Error to Error_object_Id 20491
75752>>>>>>>        If (Trim(sVersion) = "") Begin
75754>>>>>>>            // Unable to get the revision. return all zeroes.
75754>>>>>>>            Move "0.0.0" to sVersion
75755>>>>>>>        End
75755>>>>>>>>
75755>>>>>>>        Function_Return sVersion
75756>>>>>>>    End_Function
75757>>>>>>>    
75757>>>>>>>    //           Pervasive.SQL Engine
75757>>>>>>>    
75757>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
75759>>>>>>>        
75759>>>>>>>        String  sDriverID
75759>>>>>>>        String  sVersion
75759>>>>>>>        String  sVoid
75759>>>>>>>        Integer iRetval
75759>>>>>>>        
75759>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75759>>>>>>>        // This error would otherwise be raised when we have an older
75759>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75759>>>>>>>        Send Ignore_error to Error_object_Id 20491
75760>>>>>>>        Get psDriverID to sDriverID
75761>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75762>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75767>>>>>>>        Send Trap_Error to Error_object_Id 20491
75768>>>>>>>        If (Trim(sVersion) = "") Begin
75770>>>>>>>            // Unable to get the revision. return all zeroes.
75770>>>>>>>            Move "0.0.0" to sVersion
75771>>>>>>>        End
75771>>>>>>>>
75771>>>>>>>        Function_Return sVersion
75772>>>>>>>    End_Function
75773>>>>>>>    
75773>>>>>>>    //  Returns the version information of the
75773>>>>>>>    //           Pervasive.SQL Server Engine
75773>>>>>>>    
75773>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
75775>>>>>>>        
75775>>>>>>>        String  sDriverID
75775>>>>>>>        String  sVersion
75775>>>>>>>        String  sVoid
75775>>>>>>>        Integer iRetval
75775>>>>>>>        
75775>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75775>>>>>>>        // This error would otherwise be raised when we have an older
75775>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75775>>>>>>>        Send Ignore_error to Error_object_Id 20491
75776>>>>>>>        Get psDriverID to sDriverID
75777>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75778>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75783>>>>>>>        Send Trap_Error to Error_object_Id 20491
75784>>>>>>>        If (Trim(sVersion) = "") Begin
75786>>>>>>>            // Unable to get the revision. return all zeroes.
75786>>>>>>>            Move "0.0.0" to sVersion
75787>>>>>>>        End
75787>>>>>>>>
75787>>>>>>>        Function_Return sVersion
75788>>>>>>>    End_Function
75789>>>>>>>    
75789>>>>>>>End_Class
75790>>>>>>>
75790>>>>>>>
75790>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cSQLConnectionIniFile.inc)
75790>>>>>>>//****************************************************************************
75790>>>>>>>// $Module type: Include file
75790>>>>>>>// $Module name: cSQLConnectionIniFile.inc
75790>>>>>>>//
75790>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
75790>>>>>>>// Copyright (c) 2012 RDC Tools International
75790>>>>>>>// E-mail      : support@rdctools.com
75790>>>>>>>// Web-site    : http://www.rdctools.com
75790>>>>>>>//
75790>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
75790>>>>>>>//
75790>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
75790>>>>>>>//
75790>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
75790>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
75790>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
75790>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
75790>>>>>>>// in the help folder for more details.
75790>>>>>>>//
75790>>>>>>>Use Winkern.pkg
75790>>>>>>>Use cIniFile.pkg
75790>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCryptographerEx.pkg)
75790>>>>>>>>>Use VdfBase.pkg
75790>>>>>>>>>
75790>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 20.1\Pkg\CryptographerConstants.pkg)
75790>>>>>>>>>>>//   Author  : Ulbe Stellema
75790>>>>>>>>>>>// Algorithm classes
75790>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
75790>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
75790>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
75790>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
75790>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
75790>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
75790>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
75790>>>>>>>>>>>
75790>>>>>>>>>>>// Algorithm types
75790>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
75790>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
75790>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
75790>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
75790>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
75790>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
75790>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
75790>>>>>>>>>>>
75790>>>>>>>>>>>// Generic sub-ids
75790>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
75790>>>>>>>>>>>
75790>>>>>>>>>>>// RSA sub-ids
75790>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
75790>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
75790>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
75790>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
75790>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
75790>>>>>>>>>>>
75790>>>>>>>>>>>// DSS sub-ids
75790>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
75790>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
75790>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
75790>>>>>>>>>>>
75790>>>>>>>>>>>// DES sub_ids
75790>>>>>>>>>>>Define ALG_SID_DES                      for 1
75790>>>>>>>>>>>Define ALG_SID_3DES                     for 3
75790>>>>>>>>>>>Define ALG_SID_DESX                     for 4
75790>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
75790>>>>>>>>>>>Define ALG_SID_CAST                     for 6
75790>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
75790>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
75790>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
75790>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
75790>>>>>>>>>>>Define ALG_SID_RC5                      for 13
75790>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
75790>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
75790>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
75790>>>>>>>>>>>Define ALG_SID_AES                      for 17
75790>>>>>>>>>>>
75790>>>>>>>>>>>// Fortezza sub-ids
75790>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
75790>>>>>>>>>>>Define ALG_SID_TEK                      for 11
75790>>>>>>>>>>>
75790>>>>>>>>>>>// RC2 sub-ids
75790>>>>>>>>>>>Define ALG_SID_RC2                      for 2
75790>>>>>>>>>>>
75790>>>>>>>>>>>// Stream cipher sub-ids
75790>>>>>>>>>>>Define ALG_SID_RC4                      for 1
75790>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
75790>>>>>>>>>>>
75790>>>>>>>>>>>// Diffie-Hellman sub-ids
75790>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
75790>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
75790>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
75790>>>>>>>>>>>Define ALG_SID_KEA                      for 4
75790>>>>>>>>>>>
75790>>>>>>>>>>>// Hash sub ids
75790>>>>>>>>>>>Define ALG_SID_MD2                      for 1
75790>>>>>>>>>>>Define ALG_SID_MD4                      for 2
75790>>>>>>>>>>>Define ALG_SID_MD5                      for 3
75790>>>>>>>>>>>Define ALG_SID_SHA                      for 4
75790>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
75790>>>>>>>>>>>Define ALG_SID_MAC                      for 5
75790>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
75790>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
75790>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
75790>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
75790>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
75790>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
75790>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
75790>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
75790>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
75790>>>>>>>>>>>
75790>>>>>>>>>>>// secure channel sub ids
75790>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
75790>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
75790>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
75790>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
75790>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
75790>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
75790>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
75790>>>>>>>>>>>
75790>>>>>>>>>>>// algorithm identifier definitions
75790>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
75790>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
75790>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
75790>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
75790>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
75790>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
75790>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
75790>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
75790>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
75790>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
75790>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
75790>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
75790>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
75790>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
75790>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
75790>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
75790>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
75790>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
75790>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
75790>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
75790>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
75790>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
75790>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
75790>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
75790>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
75790>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
75790>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
75790>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
75790>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
75790>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
75790>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
75790>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
75790>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
75790>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
75790>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
75790>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
75790>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
75790>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
75790>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
75790>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
75790>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
75790>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
75790>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
75790>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
75790>>>>>>>>>>>
75790>>>>>>>>>>>// Providers
75790>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
75790>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
75790>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
75790>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
75790>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
75790>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
75790>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
75790>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
75790>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
75790>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
75790>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
75790>>>>>>>>>>>
75790>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
75790>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
75790>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
75790>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
75790>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
75790>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
75790>>>>>>>>>>>
75790>>>>>>>>>>>// dwFlag definitions for CryptGenKey
75790>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
75790>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
75790>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
75790>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
75790>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
75790>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
75790>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
75790>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
75790>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
75790>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
75790>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
75790>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
75790>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
75790>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
75790>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
75790>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
75790>>>>>>>>>>>
75790>>>>>>>>>>>// Provider types
75790>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
75790>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
75790>>>>>>>>>>>Define PROV_DSS                         for 3
75790>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
75790>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
75790>>>>>>>>>>>Define PROV_SSL                         for 6
75790>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
75790>>>>>>>>>>>Define PROV_DSS_DH                      for 13
75790>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
75790>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
75790>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
75790>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
75790>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
75790>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
75790>>>>>>>>>>>Define PROV_RNG                         for 21
75790>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
75790>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
75790>>>>>>>>>>>Define PROV_RSA_AES                     for 24
75790>>>>>>>>>>>
75790>>>>>>>>>>>// KP_MODE
75790>>>>>>>>>>>// KP_MODE
75790>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
75790>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
75790>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
75790>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
75790>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
75790>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
75790>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
75790>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
75790>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
75790>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
75790>>>>>>>>>>>
75790>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
75790>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
75790>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
75790>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
75790>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
75790>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
75790>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
75790>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
75790>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
75790>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
75790>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
75790>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
75790>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
75790>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
75790>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
75790>>>>>>>>>>>Define KP_Y                             for 15      // Y value
75790>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
75790>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
75790>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
75790>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
75790>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
75790>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
75790>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
75790>>>>>>>>>>>Define KP_RP                            for 23
75790>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
75790>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
75790>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
75790>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
75790>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
75790>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
75790>>>>>>>>>>>Define KP_KEYVAL                        for 30
75790>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
75790>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
75790>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
75790>>>>>>>>>>>Define KP_PREHASH                       for 34
75790>>>>>>>>>>>Define KP_ROUNDS                        for 35
75790>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
75790>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
75790>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
75790>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
75790>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
75790>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
75790>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
75790>>>>>>>>>>>
75790>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
75790>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
75790>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
75790>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
75790>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
75790>>>>>>>>>>>
75790>>>>>>>>>>>// key BLOB types
75790>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
75790>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
75790>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
75790>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
75790>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
75790>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
75790>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
75790>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
75790>>>>>>>>>>>
75790>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
75790>>>>>>>>>>>
75790>>>>>>>>>>>// KP_PADDING
75790>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
75790>>>>>>>>>>>Define RANDOM_PADDING                   for 2
75790>>>>>>>>>>>Define ZERO_PADDING                     for 3
75790>>>>>>>>>>>
75790>>>>>>>>>>>//  Structure cryptimportkey
75790>>>>>>>>>>>Struct PUBLICKEYSTRUC
75790>>>>>>>>>>>    UChar    bType
75790>>>>>>>>>>>    UChar    bVersion
75790>>>>>>>>>>>    UShort   reserved
75790>>>>>>>>>>>    UInteger aiKeyAlg
75790>>>>>>>>>>>End_Struct
75790>>>>>>>>>>>
75790>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
75790>>>>>>>>>>>    PUBLICKEYSTRUC hdr
75790>>>>>>>>>>>    PUBLICKEYSTRUC hdr
75790>>>>>>>>>>>    UInteger       dwKeySize
75790>>>>>>>>>>>//    UChar[]        rgbKeyData
75790>>>>>>>>>>>End_Struct
75790>>>>>>>>>>>
75790>>>>>>>>>>>
75790>>>>>>>>>>>
75790>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
75790>>>>>>>>>>>Struct HMAC_INFO
75790>>>>>>>>>>>    UInteger HashAlgid
75790>>>>>>>>>>>    Pointer pbInnerString
75790>>>>>>>>>>>    DWord cbInnerString
75790>>>>>>>>>>>    Pointer pbOuterString
75790>>>>>>>>>>>    DWord cbOuterString
75790>>>>>>>>>>>End_Struct
75790>>>>>>>>>>>
75790>>>>>>>>>>>Struct BLOBHEADER
75790>>>>>>>>>>>    UChar   bType
75790>>>>>>>>>>>    UChar   bVersion
75790>>>>>>>>>>>    Short   reserved
75790>>>>>>>>>>>    Integer aiKeyAlg
75790>>>>>>>>>>>End_Struct
75790>>>>>>>>>>>
75790>>>>>>>>>>>Struct CryptoBlob
75790>>>>>>>>>>>    BLOBHEADER  header
75790>>>>>>>>>>>    BLOBHEADER  header
75790>>>>>>>>>>>    Integer     cbKeySize
75790>>>>>>>>>>>    UChar[32]   rgbKeyData
75790>>>>>>>>>>>End_Struct
75790>>>>>>>>>>>
75790>>>>>>>>>>>
75790>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
75790>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
75791>>>>>>>>>>>
75791>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
75791>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
75793>>>>>>>>>>>    
75793>>>>>>>>>>>    Boolean bResult
75793>>>>>>>>>>>    UWide   uwContainer uwProvider
75793>>>>>>>>>>>    UWide   uwContainer uwProvider
75793>>>>>>>>>>>
75793>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
75794>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
75795>>>>>>>>>>>    
75795>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
75796>>>>>>>>>>>
75796>>>>>>>>>>>    Function_Return bResult
75797>>>>>>>>>>>End_Function
75798>>>>>>>>>>>
75798>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
75799>>>>>>>>>>>
75799>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
75800>>>>>>>>>>>
75800>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
75801>>>>>>>>>>>
75801>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
75802>>>>>>>>>>>
75802>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
75803>>>>>>>>>>>
75803>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
75804>>>>>>>>>>>
75804>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
75805>>>>>>>>>>>
75805>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
75806>>>>>>>>>>>
75806>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
75807>>>>>>>>>>>    
75807>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
75808>>>>>>>>>>>
75808>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
75809>>>>>>>>>>>
75809>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
75810>>>>>>>>>>>
75810>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
75811>>>>>>>>>>>    
75811>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
75812>>>>>>>>>>>    
75812>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
75813>>>>>>>>>>>    
75813>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
75814>>>>>>>>>
75814>>>>>>>>>Class cCryptographerEx is a cObject
75815>>>>>>>>>    
75815>>>>>>>>>    Procedure Construct_Object
75817>>>>>>>>>        Forward Send Construct_Object
75819>>>>>>>>>        
75819>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
75820>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
75821>>>>>>>>>        Property Integer    piCipher    CALG_RC4
75822>>>>>>>>>        Property Integer    piHash      CALG_MD5
75823>>>>>>>>>        
75823>>>>>>>>>        // Private properties
75823>>>>>>>>>        Property Handle     Private_phProv
75824>>>>>>>>>        
75824>>>>>>>>>        // Block cipher properties
75824>>>>>>>>>        Property UChar[]    paKey
75825>>>>>>>>>        Property UChar[]    paIV
75826>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
75827>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
75828>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
75829>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
75830>>>>>>>>>        Property Integer    piBlockSize     16
75831>>>>>>>>>    End_Procedure
75832>>>>>>>>>    
75832>>>>>>>>>    
75832>>>>>>>>>    // Acquire key container handle
75832>>>>>>>>>    Function AcquireContext Returns Handle
75834>>>>>>>>>        Integer iProvider
75834>>>>>>>>>        WString wProvider
75834>>>>>>>>>        Handle hProv
75834>>>>>>>>>        Boolean bOk
75834>>>>>>>>>        Pointer pProv
75834>>>>>>>>>        
75834>>>>>>>>>        Move 0 to hProv
75835>>>>>>>>>        Get piProvider to iProvider
75836>>>>>>>>>        Get psProvider to wProvider
75837>>>>>>>>>        
75837>>>>>>>>>        //  Determine address to be passed as provider
75837>>>>>>>>>        If (Trim(wProvider) <> "") Begin
75839>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
75840>>>>>>>>>        End
75840>>>>>>>>>>
75840>>>>>>>>>        Else Begin
75841>>>>>>>>>            Move 0 to pProv
75842>>>>>>>>>        End
75842>>>>>>>>>>
75842>>>>>>>>>        
75842>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
75842>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
75843>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
75845>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
75846>>>>>>>>>        End
75846>>>>>>>>>>
75846>>>>>>>>>        
75846>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
75848>>>>>>>>>            // Fallback to original
75848>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
75849>>>>>>>>>            
75849>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
75851>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
75852>>>>>>>>>            End
75852>>>>>>>>>>
75852>>>>>>>>>        End
75852>>>>>>>>>>
75852>>>>>>>>>        Set Private_phProv to hProv
75853>>>>>>>>>        
75853>>>>>>>>>        Function_Return hProv
75854>>>>>>>>>    End_Function
75855>>>>>>>>>    
75855>>>>>>>>>    // Releases key container handle
75855>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
75857>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
75858>>>>>>>>>    End_Function
75859>>>>>>>>>    
75859>>>>>>>>>    // Creates hash object
75859>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
75861>>>>>>>>>        Integer iAlgorithm
75861>>>>>>>>>        Handle hHash
75861>>>>>>>>>        Boolean bOk
75861>>>>>>>>>        
75861>>>>>>>>>        Move 0 to hHash
75862>>>>>>>>>        Get piHash to iAlgorithm
75863>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
75864>>>>>>>>>        
75864>>>>>>>>>        Function_Return hHash
75865>>>>>>>>>    End_Function
75866>>>>>>>>>    
75866>>>>>>>>>    // Destroys the hash object
75866>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
75868>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
75869>>>>>>>>>    End_Function
75870>>>>>>>>>    
75870>>>>>>>>>    // Adds data to hash object
75870>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
75872>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
75873>>>>>>>>>    End_Function
75874>>>>>>>>>    
75874>>>>>>>>>    // Generates session key
75874>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
75876>>>>>>>>>        Integer iAlgorithm
75876>>>>>>>>>        Handle hKey
75876>>>>>>>>>        Boolean bOk
75876>>>>>>>>>        
75876>>>>>>>>>        Move 0 to hKey
75877>>>>>>>>>        Get piCipher to iAlgorithm
75878>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
75879>>>>>>>>>        
75879>>>>>>>>>        Function_Return hKey
75880>>>>>>>>>    End_Function
75881>>>>>>>>>    
75881>>>>>>>>>    // Imports a plain text key
75881>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
75883>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
75883>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
75883>>>>>>>>>        Boolean   bSuccess
75883>>>>>>>>>        Handle    hKey
75883>>>>>>>>>        Integer   iHeadSize iKeySize
75883>>>>>>>>>        UChar[]   ucaKeyblob
75884>>>>>>>>>        Integer iVoid
75884>>>>>>>>>        
75884>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
75885>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
75886>>>>>>>>>        
75886>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
75887>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
75888>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
75889>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
75890>>>>>>>>>        
75890>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
75891>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
75892>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
75893>>>>>>>>>        
75893>>>>>>>>>        Move 0 to hKey
75894>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
75895>>>>>>>>>        If (not(bSuccess)) Begin
75897>>>>>>>>>            Move (ShowLastError()) to iVoid
75898>>>>>>>>>        End
75898>>>>>>>>>>
75898>>>>>>>>>        
75898>>>>>>>>>        Function_Return hKey
75899>>>>>>>>>    End_Function
75900>>>>>>>>>    
75900>>>>>>>>>    // Destroys the key
75900>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
75902>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
75903>>>>>>>>>    End_Function
75904>>>>>>>>>    
75904>>>>>>>>>    // Retrieves key data
75904>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
75906>>>>>>>>>        Integer iBuffer iLen
75906>>>>>>>>>        Boolean bOk
75906>>>>>>>>>        
75906>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
75907>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
75908>>>>>>>>>        Function_Return iBuffer
75909>>>>>>>>>    End_Function
75910>>>>>>>>>    
75910>>>>>>>>>    // Retrieves a hash value
75910>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
75912>>>>>>>>>        UChar[] ucHash
75913>>>>>>>>>        Integer liResult
75913>>>>>>>>>        DWord   dwDataLen
75913>>>>>>>>>        
75913>>>>>>>>>        Move 0 to dwDataLen
75914>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
75915>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
75918>>>>>>>>>        
75918>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
75919>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
75920>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
75923>>>>>>>>>        
75923>>>>>>>>>        Function_Return ucHash
75924>>>>>>>>>    End_Function
75925>>>>>>>>>
75925>>>>>>>>>    // Encrypts data
75925>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
75927>>>>>>>>>        Handle hProv hHash hKey
75927>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
75927>>>>>>>>>        Boolean bOk
75927>>>>>>>>>        
75927>>>>>>>>>        Get AcquireContext to hProv
75928>>>>>>>>>        If (hProv) Begin
75930>>>>>>>>>            Get CreateHash hProv to hHash
75931>>>>>>>>>            If (hHash) Begin
75933>>>>>>>>>                Get HashData hHash ucPassword to bOk
75934>>>>>>>>>                If (bOk) Begin
75936>>>>>>>>>                    Get piCipher to iAlgorithm
75937>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
75938>>>>>>>>>                End
75938>>>>>>>>>>
75938>>>>>>>>>                Get DestroyHash hHash to bOk
75939>>>>>>>>>            End
75939>>>>>>>>>>
75939>>>>>>>>>            
75939>>>>>>>>>            If (hKey) Begin
75941>>>>>>>>>                //  First call to determine resulting data size
75941>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
75942>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
75943>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
75944>>>>>>>>>                
75944>>>>>>>>>                //  Reserve space in string
75944>>>>>>>>>                If (iDataLen < iCipherLen) Begin
75946>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
75947>>>>>>>>>                End
75947>>>>>>>>>>
75947>>>>>>>>>                
75947>>>>>>>>>                //  Call to really decrypt
75947>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
75948>>>>>>>>>                //If (not(bOk)) Begin
75948>>>>>>>>>                //Move "" to sData
75948>>>>>>>>>                //Move (GetLastError()) to iErr
75948>>>>>>>>>                //End
75948>>>>>>>>>                
75948>>>>>>>>>                Get DestroyKey hKey to bOk
75949>>>>>>>>>            End 
75949>>>>>>>>>>
75949>>>>>>>>>            Get ReleaseContext hProv to bOk
75950>>>>>>>>>        End 
75950>>>>>>>>>>
75950>>>>>>>>>        Function_Return ucData
75951>>>>>>>>>    End_Function
75952>>>>>>>>>    
75952>>>>>>>>>    // Decrypts data
75952>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
75954>>>>>>>>>        Handle hProv hHash hKey
75954>>>>>>>>>        Integer iAlgorithm iDataLen
75954>>>>>>>>>        Boolean bOk
75954>>>>>>>>>        
75954>>>>>>>>>        Get AcquireContext to hProv
75955>>>>>>>>>        If (hProv) Begin
75957>>>>>>>>>            Get CreateHash hProv to hHash
75958>>>>>>>>>            If (hHash) Begin
75960>>>>>>>>>                Get HashData hHash ucPassword to bOk
75961>>>>>>>>>                If (bOk) Begin
75963>>>>>>>>>                    Get piCipher to iAlgorithm
75964>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
75965>>>>>>>>>                End
75965>>>>>>>>>>
75965>>>>>>>>>                Get DestroyHash hHash to bOk
75966>>>>>>>>>            End
75966>>>>>>>>>>
75966>>>>>>>>>            
75966>>>>>>>>>            If (hKey) Begin
75968>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
75969>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
75970>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
75970>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
75972>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
75973>>>>>>>>>                End
75973>>>>>>>>>>
75973>>>>>>>>>                
75973>>>>>>>>>                Get DestroyKey hKey to bOk
75974>>>>>>>>>            End
75974>>>>>>>>>>
75974>>>>>>>>>            Get ReleaseContext hProv to bOk
75975>>>>>>>>>        End
75975>>>>>>>>>>
75975>>>>>>>>>        Function_Return ucData
75976>>>>>>>>>    End_Function
75977>>>>>>>>>    
75977>>>>>>>>>    // Creates a key
75977>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
75979>>>>>>>>>        Integer iAlg iType iByte iLength iSize
75979>>>>>>>>>        CryptoBlob keyBlob
75979>>>>>>>>>        CryptoBlob keyBlob
75979>>>>>>>>>        Boolean bOk
75979>>>>>>>>>        Handle hKey
75979>>>>>>>>>        UChar[] aKey
75980>>>>>>>>>
75980>>>>>>>>>        Get paKey to aKey
75981>>>>>>>>>        Get piKeyAlg to iAlg
75982>>>>>>>>>        Get piKeyType to iType
75983>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
75984>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
75985>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
75986>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
75987>>>>>>>>>        
75987>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
75988>>>>>>>>>        For iByte from 0 to iLength
75994>>>>>>>>>>
75994>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
75995>>>>>>>>>        Loop
75996>>>>>>>>>>
75996>>>>>>>>>        
75996>>>>>>>>>        Move 0 to hKey
75997>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
75998>>>>>>>>>        Function_Return hKey
75999>>>>>>>>>    End_Function
76000>>>>>>>>>    
76000>>>>>>>>>    // Sets the key parameters
76000>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
76002>>>>>>>>>        Integer iPadding iMode
76002>>>>>>>>>        Boolean bOk
76002>>>>>>>>>        UChar[] aIV
76003>>>>>>>>>        
76003>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
76003>>>>>>>>>        //For iByte from 0 to iLength
76003>>>>>>>>>        //    Move iByte to aIV[iByte]
76003>>>>>>>>>        //Loop
76003>>>>>>>>>
76003>>>>>>>>>        // Set initialization vector
76003>>>>>>>>>        Get paIV to aIV
76004>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
76005>>>>>>>>>        If (bOk) Begin
76007>>>>>>>>>            // Set padding
76007>>>>>>>>>            Get piKeyPadding to iPadding
76008>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
76009>>>>>>>>>            If (bOk) Begin
76011>>>>>>>>>                // Set move
76011>>>>>>>>>                Get piKeyMode to iMode
76012>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
76013>>>>>>>>>            End
76013>>>>>>>>>>
76013>>>>>>>>>        End
76013>>>>>>>>>>
76013>>>>>>>>>        Function_Return bOk        
76014>>>>>>>>>    End_Function
76015>>>>>>>>>    
76015>>>>>>>>>    // Encrypts using block cipher
76015>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
76017>>>>>>>>>        Handle hProv hKey
76017>>>>>>>>>        Integer iLen iSize iBlocks
76017>>>>>>>>>        Boolean bOk
76017>>>>>>>>>        
76017>>>>>>>>>        Get AcquireContext to hProv
76018>>>>>>>>>        If (hProv) Begin
76020>>>>>>>>>            // Create key
76020>>>>>>>>>            Get CreateKey hProv to hKey
76021>>>>>>>>>            If (hKey) Begin
76023>>>>>>>>>                Get SetKeyParameters hKey to bOk
76024>>>>>>>>>                If (bOk) Begin
76026>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
76026>>>>>>>>>                    Get piBlockSize to iSize
76027>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76028>>>>>>>>>                    
76028>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
76029>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
76030>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
76031>>>>>>>>>                End
76031>>>>>>>>>>
76031>>>>>>>>>                Get DestroyKey hKey to bOk
76032>>>>>>>>>            End
76032>>>>>>>>>>
76032>>>>>>>>>            Get ReleaseContext hProv to bOk
76033>>>>>>>>>        End
76033>>>>>>>>>>
76033>>>>>>>>>        Function_Return ucData
76034>>>>>>>>>    End_Function
76035>>>>>>>>>    
76035>>>>>>>>>    // Decrypts using block cipher
76035>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
76037>>>>>>>>>        Handle hProv hKey
76037>>>>>>>>>        Integer iLen
76037>>>>>>>>>        Boolean bOk
76037>>>>>>>>>        
76037>>>>>>>>>        Get AcquireContext to hProv
76038>>>>>>>>>        If (hProv) Begin
76040>>>>>>>>>            // Create key
76040>>>>>>>>>            Get CreateKey hProv to hKey
76041>>>>>>>>>            If (hKey) Begin
76043>>>>>>>>>                Get SetKeyParameters hKey to bOk
76044>>>>>>>>>                If (bOk) Begin
76046>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76047>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
76048>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
76049>>>>>>>>>                End
76049>>>>>>>>>>
76049>>>>>>>>>                Get DestroyKey hKey to bOk
76050>>>>>>>>>            End
76050>>>>>>>>>>
76050>>>>>>>>>            Get ReleaseContext hProv to bOk
76051>>>>>>>>>        End
76051>>>>>>>>>>
76051>>>>>>>>>        Function_Return ucData
76052>>>>>>>>>    End_Function
76053>>>>>>>>>    
76053>>>>>>>>>    
76053>>>>>>>>>    //  Generates random data.
76053>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
76055>>>>>>>>>        Handle hProv
76055>>>>>>>>>        UChar[] uaResult
76056>>>>>>>>>        Boolean bRes
76056>>>>>>>>>        
76056>>>>>>>>>        Get AcquireContext to hProv
76057>>>>>>>>>        
76057>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
76058>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
76059>>>>>>>>>        
76059>>>>>>>>>        Get ReleaseContext hProv to bRes
76060>>>>>>>>>        
76060>>>>>>>>>        Function_Return uaResult
76061>>>>>>>>>    End_Function
76062>>>>>>>>>    
76062>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
76062>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
76064>>>>>>>>>        String sResult
76064>>>>>>>>>        UChar[] ucData
76065>>>>>>>>>        Pointer pBase64
76065>>>>>>>>>        Integer iVoid
76065>>>>>>>>>        
76065>>>>>>>>>        Get GenerateRandom iLength to ucData
76066>>>>>>>>>        
76066>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
76067>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76068>>>>>>>>>        Move (Free(pBase64)) to iVoid
76069>>>>>>>>>        
76069>>>>>>>>>        Function_Return (Left(sResult, iLength))
76070>>>>>>>>>    End_Function
76071>>>>>>>>>    
76071>>>>>>>>>End_Class
76072>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\Base64Functions.pkg)
76072>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
76072>>>>>>>>>//>
76072>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
76072>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
76072>>>>>>>>>//>
76072>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
76072>>>>>>>>>//> strings.
76072>>>>>>>>>//>
76072>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
76072>>>>>>>>>//> Base64Decode) that are built into the runtime.
76072>>>>>>>>>//>
76072>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
76072>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
76072>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
76072>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
76072>>>>>>>>>
76072>>>>>>>>>Use VdfBase.pkg
76072>>>>>>>>>
76072>>>>>>>>>// Functions in vdfBase64.dll
76072>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
76073>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
76074>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
76075>>>>>>>>>
76075>>>>>>>>>// Structure
76075>>>>>>>>>Struct txxfBase64Buffer
76075>>>>>>>>>    Pointer pData
76075>>>>>>>>>    Integer iLength
76075>>>>>>>>>End_Struct 
76075>>>>>>>>>
76075>>>>>>>>>Global_Variable Integer oBase64Functions
76075>>>>>>>>>
76075>>>>>>>>>Object _oBase64Functions is a cObject
76077>>>>>>>>>    Move Self to oBase64Functions
76078>>>>>>>>>
76078>>>>>>>>>
76078>>>>>>>>>    Function EncodeString String sValue Returns String
76081>>>>>>>>>        Address pBase64
76081>>>>>>>>>        String sResult
76081>>>>>>>>>        Integer iVoid
76081>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
76082>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76083>>>>>>>>>        Move (Free(pBase64)) to iVoid
76084>>>>>>>>>        Function_Return sResult
76085>>>>>>>>>    End_Function
76086>>>>>>>>>
76086>>>>>>>>>    Function DecodeString String sValue Returns String
76089>>>>>>>>>        Address pBinary
76089>>>>>>>>>        String sBinary
76089>>>>>>>>>        Integer iVoid iLen
76089>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
76090>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
76091>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
76092>>>>>>>>>        Move (Free(pBinary)) to iVoid
76093>>>>>>>>>        Function_Return sBinary
76094>>>>>>>>>    End_Function
76095>>>>>>>>>
76095>>>>>>>>>End_Object
76096>>>>>>>Use MSSqldrv.pkg
76096>>>>>>>Use db2_drv.pkg
76096>>>>>>>Use odbc_drv.pkg
76096>>>>>>>Use DFBtrDrv.pkg
76096>>>>>>>Use vWin32fh.pkg
76096>>>>>>>
76096>>>>>>>Use DUFLanguageConstants.inc
76096>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\MertechDUF.pkg)
76096>>>>>>>>>//
76096>>>>>>>>>// Use of Mertech drivers:
76096>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
76096>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
76096>>>>>>>>>//Define DUF_Use_Mertech_Drivers
76096>>>>>>>>>//
#REM DO ~ USE MERTECH.INC
76096>>>>>>>>>// MySQL Data Types
76096>>>>>>>>>Define eMySQL_DECIMAL                               for 0
76096>>>>>>>>>Define eMySQL_TINY                                  for 1
76096>>>>>>>>>Define eMySQL_SHORT                                 for 2
76096>>>>>>>>>Define eMySQL_LONG                                  for 3
76096>>>>>>>>>Define eMySQL_FLOAT                                 for 4
76096>>>>>>>>>Define eMySQL_DOUBLE                                for 5
76096>>>>>>>>>Define eMySQL_NULL                                  for 6
76096>>>>>>>>>Define eMySQL_TIMESTAMP                             for 7
76096>>>>>>>>>Define eMySQL_LONGLONG                              for 8
76096>>>>>>>>>Define eMySQL_INT24                                 for 9
76096>>>>>>>>>Define eMySQL_DATE                                  for 10
76096>>>>>>>>>Define eMySQL_TIME                                  for 11
76096>>>>>>>>>Define eMySQL_DATETIME                              for 12
76096>>>>>>>>>Define eMySQL_YEAR                                  for 13
76096>>>>>>>>>Define eMySQL_NEWDATE                               for 14
76096>>>>>>>>>Define eMySQL_BIT                                   for 16
76096>>>>>>>>>Define eMySQL_NEWDECIMAL                            for 246
76096>>>>>>>>>Define eMySQL_ENUM                                  for 247
76096>>>>>>>>>Define eMySQL_SET                                   for 248
76096>>>>>>>>>Define eMySQL_TINY_BLOB                             for 249
76096>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           for 250
76096>>>>>>>>>Define eMySQL_LONG_BLOB                             for 251
76096>>>>>>>>>Define eMySQL_BLOB                                  for 252
76096>>>>>>>>>Define eMySQL_VAR_STRING                            for 253
76096>>>>>>>>>Define eMySQL_STRING                                for 254
76096>>>>>>>>>Define eMySQL_TINY_TEXT                             for -249
76096>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           for -250
76096>>>>>>>>>Define eMySQL_LONG_TEXT                             for -251
76096>>>>>>>>>Define eMySQL_TEXT                                  for -252
76096>>>>>>>>>
76096>>>>>>>>>// Oracle Data Types
76096>>>>>>>>>Define eOracle_VARCHAR2                             for   1
76096>>>>>>>>>Define eOracle_NUMBER                               for   2
76096>>>>>>>>>Define eOracle_INT                                  for   3
76096>>>>>>>>>Define eOracle_FLOAT                                for   4
76096>>>>>>>>>Define eOracle_STRING                               for   5
76096>>>>>>>>>Define eOracle_LONG                                 for   8
76096>>>>>>>>>Define eOracle_ROWID                                for  11
76096>>>>>>>>>Define eOracle_DATE                                 for  12
76096>>>>>>>>>Define eOracle_RAW                                  for  23
76096>>>>>>>>>Define eOracle_LONGRAW                              for  24
76096>>>>>>>>>Define eOracle_CHAR                                 for  96
76096>>>>>>>>>Define eOracle_MSLABEL                              for 106
76096>>>>>>>>>Define eOracle_CLOB                                 for 112
76096>>>>>>>>>Define eOracle_BLOB                                 for 113
76096>>>>>>>>>Define eOracle_TIMESTAMP                            for 187
76096>>>>>>>>>Define eOracle_TIMESTAMPTZ                          for 188
76096>>>>>>>>>Define eOracle_INTERVALYM                           for 189
76096>>>>>>>>>Define eOracle_INTERVALDS                           for 190
76096>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         for 232
76096>>>>>>>>>Define eOracle_NCHAR                                for 286
76096>>>>>>>>>Define eOracle_NVARCHAR2                            for 287
76096>>>>>>>>>Define eOracle_NCLOB                                for 288
76096>>>>>>>>>
76096>>>>>>>>>// PostgreSQL Data Types
76096>>>>>>>>>Define ePgSQL_CIRCLE                                for  718
76096>>>>>>>>>Define ePgSQL_MONEY                                 for  790
76096>>>>>>>>>Define ePgSQL_BOOL                                  for   16
76096>>>>>>>>>Define ePgSQL_BYTEA                                 for   17
76096>>>>>>>>>Define ePgSQL_CHAR                                  for   18
76096>>>>>>>>>Define ePgSQL_INT2                                  for   21
76096>>>>>>>>>Define ePgSQL_INT4                                  for   23
76096>>>>>>>>>Define ePgSQL_REGPROC                               for   24
76096>>>>>>>>>Define ePgSQL_REGPROCEDURE                          for 2202
76096>>>>>>>>>Define ePgSQL_REGOPER                               for 2203
76096>>>>>>>>>Define ePgSQL_REGOPERATOR                           for 2204
76096>>>>>>>>>Define ePgSQL_REGCLASS                              for 2205
76096>>>>>>>>>Define ePgSQL_REGTYPE                               for 2206
76096>>>>>>>>>Define ePgSQL_TEXT                                  for   25
76096>>>>>>>>>Define ePgSQL_CITEXT                                for  -25
76096>>>>>>>>>Define ePgSQL_OID                                   for   26
76096>>>>>>>>>Define ePgSQL_TID                                   for   27
76096>>>>>>>>>Define ePgSQL_XID                                   for   28
76096>>>>>>>>>Define ePgSQL_CID                                   for   29
76096>>>>>>>>>Define ePgSQL_XML                                   for  142
76096>>>>>>>>>Define ePgSQL_BPCHAR                                for 1042
76096>>>>>>>>>Define ePgSQL_VARCHAR                               for 1043
76096>>>>>>>>>Define ePgSQL_INT8                                  for   20
76096>>>>>>>>>Define ePgSQL_PATH                                  for  602
76096>>>>>>>>>Define ePgSQL_FLOAT4                                for  700
76096>>>>>>>>>Define ePgSQL_FLOAT8                                for  701
76096>>>>>>>>>Define ePgSQL_ABSTIME                               for  702
76096>>>>>>>>>Define ePgSQL_RELTIME                               for  703
76096>>>>>>>>>Define ePgSQL_TINTERVAL                             for  704
76096>>>>>>>>>Define ePgSQL_POINT                                 for  600
76096>>>>>>>>>Define ePgSQL_LINE                                  for  628
76096>>>>>>>>>Define ePgSQL_LSEG                                  for  601
76096>>>>>>>>>Define ePgSQL_BOX                                   for  603
76096>>>>>>>>>Define ePgSQL_POLYGON                               for  604
76096>>>>>>>>>Define ePgSQL_ACLITEM                               for 1033
76096>>>>>>>>>Define ePgSQL_MACADDR                               for  829
76096>>>>>>>>>Define ePgSQL_INET                                  for  869
76096>>>>>>>>>Define ePgSQL_CIDR                                  for  650
76096>>>>>>>>>Define ePgSQL_TIMESTAMP                             for 1114
76096>>>>>>>>>Define ePgSQL_DATE                                  for 1082
76096>>>>>>>>>Define ePgSQL_TIME                                  for 1083
76096>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           for 1184
76096>>>>>>>>>Define ePgSQL_INTERVAL                              for 1186
76096>>>>>>>>>Define ePgSQL_NUMERIC                               for 1700
76096>>>>>>>>>Define ePgSQL_TIMETZ                                for 1266
76096>>>>>>>>>Define ePgSQL_BIT                                   for 1560
76096>>>>>>>>>Define ePgSQL_VARBIT                                for 1562
76096>>>>>>>>>Define ePgSQL_UUID                                  for 2950
76096>>>>>>>>>
76096>>>>>>>>>// SQL Server Data Types
76096>>>>>>>>>Define eSQLServer_NA                                for    0
76096>>>>>>>>>Define eSQLServer_CHAR                              for    1
76096>>>>>>>>>Define eSQLServer_NUMERIC                           for    2
76096>>>>>>>>>Define eSQLServer_DECIMAL                           for    3
76096>>>>>>>>>Define eSQLServer_INT                               for    4
76096>>>>>>>>>Define eSQLServer_SMALLINT                          for    5
76096>>>>>>>>>Define eSQLServer_FLOAT                             for    6
76096>>>>>>>>>Define eSQLServer_REAL                              for    7
76096>>>>>>>>>Define eSQLServer_DOUBLE                            for    8
76096>>>>>>>>>Define eSQLServer_DATETIME                          for   11
76096>>>>>>>>>Define eSQLServer_VARCHAR                           for   12
76096>>>>>>>>>Define eSQLServer_DATE                              for   40
76096>>>>>>>>>Define eSQLServer_TIME                              for   41
76096>>>>>>>>>Define eSQLServer_DATETIME2                         for   42
76096>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    for   43
76096>>>>>>>>>Define eSQLServer_SMALLDATETIME                     for   58
76096>>>>>>>>>Define eSQLServer_TIMESTAMP                         for   93
76096>>>>>>>>>Define eSQLServer_HIERARCHYID                       for  128
76096>>>>>>>>>Define eSQLServer_GEOMETRY                          for  129
76096>>>>>>>>>Define eSQLServer_GEOGRAPHY                         for  130
76096>>>>>>>>>Define eSQLServer_TEXT                              for   -1
76096>>>>>>>>>Define eSQLServer_BINARY                            for   -2
76096>>>>>>>>>Define eSQLServer_VARBINARY                         for   -3
76096>>>>>>>>>Define eSQLServer_IMAGE                             for   -4
76096>>>>>>>>>Define eSQLServer_BIGINT                            for   -5
76096>>>>>>>>>Define eSQLServer_TINYINT                           for   -6
76096>>>>>>>>>Define eSQLServer_BIT                               for   -7
76096>>>>>>>>>Define eSQLServer_NCHAR                             for   -8
76096>>>>>>>>>Define eSQLServer_NVARCHAR                          for   -9
76096>>>>>>>>>Define eSQLServer_NTEXT                             for  -10
76096>>>>>>>>>Define eSQLServer_GUID                              for  -11
76096>>>>>>>>>Define eSQLServer_VARBINARYMAX                      for  -98
76096>>>>>>>>>Define eSQLServer_VARCHARMAX                        for  -99
76096>>>>>>>>>Define eSQLServer_NVARCHARMAX                       for -100
76096>>>>>>>>>Define eSQLServer_SQLVARIANT                        for -150
76096>>>>>>>>>Define eSQLServer_XML                               for -370
76096>>>>>>>>>
76096>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cDbUpdateFunctionLibrary.inc)
76096>>>>>>>>>>>Use DUFLanguageConstants.inc
76096>>>>>>>>>>>
76096>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
76096>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define DATAFLEX_ID for "DATAFLEX"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_SERVER for "SERVER"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
76096>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
76096>>>>>>>>>>>
76096>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
76096>>>>>>>>>>>
76096>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
76096>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateHandler    
76096>>>>>>>>>>>    Move 0 to ghoDbUpdateHandler
76097>>>>>>>>>>>
76097>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
76097>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tSQLScriptArray
76098>>>>>>>>>>>    Boolean bError
76098>>>>>>>>>>>    Boolean bArgumentSizeChanged
76098>>>>>>>>>>>    Integer iOrgArgumentSize
76098>>>>>>>>>>>    String[] sSQLScriptArray
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tSqlErrorArray
76098>>>>>>>>>>>    String[]  sSqlErrorArray
76098>>>>>>>>>>>    String[]  sSqlStatementArray
76098>>>>>>>>>>>    Integer[] iSqlErrorArray
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tSqlColumnNew
76098>>>>>>>>>>>    String  sBaseColumnName
76098>>>>>>>>>>>    String  sBaseTableName
76098>>>>>>>>>>>    String  sLabel
76098>>>>>>>>>>>    Integer iSqlType
76098>>>>>>>>>>>    Integer iSize
76098>>>>>>>>>>>    Integer iPrecision
76098>>>>>>>>>>>    Integer iDFType
76098>>>>>>>>>>>    Integer iDFNativeType
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tColumnType
76098>>>>>>>>>>>    String  sSQLType
76098>>>>>>>>>>>    Integer iSQLType
76098>>>>>>>>>>>    Boolean bCanEditSize
76098>>>>>>>>>>>    Integer iDefaultSize
76098>>>>>>>>>>>    Integer iMinSize
76098>>>>>>>>>>>    Number  nMaxSize
76098>>>>>>>>>>>    String  sDataFlexType
76098>>>>>>>>>>>    Integer iDataFlexType
76098>>>>>>>>>>>    Boolean bNativeDataType
76098>>>>>>>>>>>    String  sPrecision
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
76098>>>>>>>>>>>// Various SQL back-ends can have slightly different
76098>>>>>>>>>>>// keywords.
76098>>>>>>>>>>>Struct tSQLKeyWords
76098>>>>>>>>>>>    Integer iSQLWord
76098>>>>>>>>>>>    Integer iSQLDbType
76098>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tSQLRelation
76098>>>>>>>>>>>    Integer iFileNumber
76098>>>>>>>>>>>    Integer iFieldNumber
76098>>>>>>>>>>>    String  sFileName
76098>>>>>>>>>>>    String  sFieldName
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tSQLLoggedInUser
76098>>>>>>>>>>>    String sUser
76098>>>>>>>>>>>    String sProgram
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
76098>>>>>>>>>>>Enumeration_List
76098>>>>>>>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
76098>>>>>>>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
76098>>>>>>>>>>>End_Enumeration_List
76098>>>>>>>>>>>
76098>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76098>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76098>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76098>>>>>>>>>>>// They can have slightly different SQL keywords.
76098>>>>>>>>>>>// Note: If a new type is added to the list,
76098>>>>>>>>>>>//       the struct array xxx must be adjusted
76098>>>>>>>>>>>//       so that it is filled with all SQL
76098>>>>>>>>>>>//       keywords for that new type.
76098>>>>>>>>>>>Enum_List
76098>>>>>>>>>>>    Define EN_DbTypeDataFlex   for 0
76098>>>>>>>>>>>    Define EN_DbTypeMSSQL      for 1
76098>>>>>>>>>>>    Define EN_DbTypeMySQL      for 2
76098>>>>>>>>>>>    Define EN_DbTypeOracle     for 3
76098>>>>>>>>>>>    Define EN_DbTypeDB2        for 4
76098>>>>>>>>>>>    Define EN_DbTypePostgre    for 5
76098>>>>>>>>>>>    Define EN_DbTypePervasive  for 6
76098>>>>>>>>>>>//    Define EN_DbTypeMSSQL
76098>>>>>>>>>>>//    Define EN_DbTypeMySQL
76098>>>>>>>>>>>//    Define EN_DbTypeOracle
76098>>>>>>>>>>>//    Define EN_DbTypeDB2
76098>>>>>>>>>>>//    Define EN_DbTypePostgre
76098>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
76098>>>>>>>>>>>End_Enum_List
76098>>>>>>>>>>>
76098>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76098>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76098>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76098>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76098>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76098>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76098>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76098>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76098>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76098>>>>>>>>>>>
76098>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76098>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76098>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
76098>>>>>>>>>>>Enum_List
76098>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
76098>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
76098>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
76098>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
76098>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
76098>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
76098>>>>>>>>>>>End_Enum_List
76098>>>>>>>>>>>
76098>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
76098>>>>>>>>>>>
76098>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
76098>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
76098>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
76098>>>>>>>>>>>
76098>>>>>>>>>>>// These are not defined pre DF 18:
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tSQLIntTableInfo
76098>>>>>>>>>>>    String sDriverName
76098>>>>>>>>>>>    String sServerName
76098>>>>>>>>>>>    String sDatabaseName
76098>>>>>>>>>>>    String sSchemaName
76098>>>>>>>>>>>    Boolean bRecnumTable
76098>>>>>>>>>>>    Integer iPrimaryIndex
76098>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
76098>>>>>>>>>>>    String sTableCharacterFormat
76098>>>>>>>>>>>    Boolean bUseDummyZeroDate
76098>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
76098>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
76098>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
76098>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
76098>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
76098>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
76098>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
76098>>>>>>>>>>>    String sFileIndexTablespace
76098>>>>>>>>>>>    String sFileLongTablespace
76098>>>>>>>>>>>    String sTableTablespace
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tSQLIntColumnInfo
76098>>>>>>>>>>>    Integer iFieldNumber
76098>>>>>>>>>>>    Integer iFieldIndex
76098>>>>>>>>>>>    Integer iFieldRelatedFile
76098>>>>>>>>>>>    Integer iFieldRelatedField
76098>>>>>>>>>>>    Integer iIndexNumber
76098>>>>>>>>>>>    Integer iIndexNumberSegments
76098>>>>>>>>>>>    Integer iIndexSegmentField1
76098>>>>>>>>>>>    Integer iIndexSegmentField2
76098>>>>>>>>>>>    Integer iIndexSegmentFieldn
76098>>>>>>>>>>>    String  sIndexName
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tAPIColumn
76098>>>>>>>>>>>    Integer iFieldNumber
76098>>>>>>>>>>>    String  sFieldName
76098>>>>>>>>>>>    Integer iType
76098>>>>>>>>>>>    String  sType
76098>>>>>>>>>>>    Integer iLength
76098>>>>>>>>>>>    Integer iPrecision
76098>>>>>>>>>>>    Integer iOptions
76098>>>>>>>>>>>    Boolean bIsSQLType
76098>>>>>>>>>>>    Boolean bAllowNULL
76098>>>>>>>>>>>    String  sDefaultValue
76098>>>>>>>>>>>    Boolean bShouldChange
76098>>>>>>>>>>>    Boolean bCancel
76098>>>>>>>>>>>    Boolean bError
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tAPIColumnCompare
76098>>>>>>>>>>>    Integer iFieldNumber
76098>>>>>>>>>>>    // FROM database:
76098>>>>>>>>>>>    Boolean bExistsFrom
76098>>>>>>>>>>>    String  sFieldNameFrom
76098>>>>>>>>>>>    Integer iTypeFrom
76098>>>>>>>>>>>    String  sTypeFrom
76098>>>>>>>>>>>    Integer iLengthFrom
76098>>>>>>>>>>>    Integer iPrecisionFrom
76098>>>>>>>>>>>    Integer iOptionsFrom
76098>>>>>>>>>>>    Boolean bIsSQLTypeFrom
76098>>>>>>>>>>>    Boolean bAllowNULLFrom
76098>>>>>>>>>>>    String  sDefaultValueFrom
76098>>>>>>>>>>>    Boolean bShouldChangeFrom
76098>>>>>>>>>>>    Boolean bCancelFrom
76098>>>>>>>>>>>    Boolean bErrorFrom
76098>>>>>>>>>>>    // TO database:
76098>>>>>>>>>>>    Boolean bExistsTo
76098>>>>>>>>>>>    Integer iFieldNumberTo
76098>>>>>>>>>>>    String  sFieldNameTo
76098>>>>>>>>>>>    Integer iTypeTo
76098>>>>>>>>>>>    String  sTypeTo
76098>>>>>>>>>>>    Integer iLengthTo
76098>>>>>>>>>>>    Integer iPrecisionTo
76098>>>>>>>>>>>    Integer iOptionsTo
76098>>>>>>>>>>>    Boolean bIsSQLTypeTo
76098>>>>>>>>>>>    Boolean bAllowNULLTo
76098>>>>>>>>>>>    String  sDefaultValueTo
76098>>>>>>>>>>>    Boolean bShouldChangeTo
76098>>>>>>>>>>>    Boolean bCancelTo
76098>>>>>>>>>>>    Boolean bErrorTo
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tAPIRelation
76098>>>>>>>>>>>    Handle  hTableFrom
76098>>>>>>>>>>>    Integer iColumnFrom
76098>>>>>>>>>>>    Handle  hTableTo
76098>>>>>>>>>>>    Integer iColumnTo
76098>>>>>>>>>>>    String  sLogicalNameFrom
76098>>>>>>>>>>>    String  sLogicalNameTo
76098>>>>>>>>>>>    String  sFieldNameFrom
76098>>>>>>>>>>>    String  sFieldNameTo
76098>>>>>>>>>>>    Boolean bShouldChange
76098>>>>>>>>>>>    Boolean bCancel
76098>>>>>>>>>>>    Boolean bError
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tAPIRelationCompare
76098>>>>>>>>>>>    // Common:
76098>>>>>>>>>>>    Handle  hTableFrom
76098>>>>>>>>>>>    Integer iColumnFrom
76098>>>>>>>>>>>    Handle  hTableTo
76098>>>>>>>>>>>    Integer iColumnTo
76098>>>>>>>>>>>    // FROM database:
76098>>>>>>>>>>>    Boolean bExistsFrom
76098>>>>>>>>>>>    String  sLogicalNameFrom_From
76098>>>>>>>>>>>    String  sLogicalNameTo_From
76098>>>>>>>>>>>    String  sFieldNameFrom_From
76098>>>>>>>>>>>    String  sFieldNameTo_From
76098>>>>>>>>>>>    Boolean bShouldChange_From
76098>>>>>>>>>>>    Boolean bCancel_From
76098>>>>>>>>>>>    Boolean bError_From
76098>>>>>>>>>>>    // TO database:
76098>>>>>>>>>>>    Boolean bExistsTo
76098>>>>>>>>>>>    String  sLogicalNameFrom_To
76098>>>>>>>>>>>    String  sLogicalNameTo_To
76098>>>>>>>>>>>    String  sFieldNameFrom_To
76098>>>>>>>>>>>    String  sFieldNameTo_To
76098>>>>>>>>>>>    Boolean bShouldChange_To
76098>>>>>>>>>>>    Boolean bCancel_To
76098>>>>>>>>>>>    Boolean bError_To
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tAPIIndexSegment
76098>>>>>>>>>>>    Integer iFieldNumber
76098>>>>>>>>>>>    String  sFieldName
76098>>>>>>>>>>>    Boolean bUppercase
76098>>>>>>>>>>>    Boolean bAscending
76098>>>>>>>>>>>    Boolean bShouldChange
76098>>>>>>>>>>>    Boolean bCancel
76098>>>>>>>>>>>    Boolean bError
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tAPIIndex
76098>>>>>>>>>>>    Integer iIndexNumber
76098>>>>>>>>>>>    Integer iPrimaryIndex
76098>>>>>>>>>>>    String  sSQLIndexName
76098>>>>>>>>>>>    Integer iSQLIndexType
76098>>>>>>>>>>>    Boolean bIsSQLClustered
76098>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
76098>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76098>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76098>>>>>>>>>>>    Boolean bShouldChange
76098>>>>>>>>>>>    Boolean bCancel
76098>>>>>>>>>>>    Boolean bError
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tAPIIndexCompare
76098>>>>>>>>>>>    // Common:
76098>>>>>>>>>>>    Integer iIndexNumber
76098>>>>>>>>>>>    // FROM database:
76098>>>>>>>>>>>    Boolean bExistsFrom
76098>>>>>>>>>>>    Integer iPrimaryIndexFrom
76098>>>>>>>>>>>    String  sSQLIndexNameFrom
76098>>>>>>>>>>>    Integer iSQLIndexTypeFrom
76098>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
76098>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
76098>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76098>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76098>>>>>>>>>>>    Boolean bShouldChangeFrom
76098>>>>>>>>>>>    Boolean bCancelFrom
76098>>>>>>>>>>>    Boolean bErrorFrom
76098>>>>>>>>>>>    // TO database:
76098>>>>>>>>>>>    Boolean bExistsTo
76098>>>>>>>>>>>    Integer iPrimaryIndexTo
76098>>>>>>>>>>>    String  sSQLIndexNameTo
76098>>>>>>>>>>>    Integer iSQLIndexTypeTo
76098>>>>>>>>>>>    Boolean bIsSQLClusteredTo
76098>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
76098>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76098>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76098>>>>>>>>>>>    Boolean bShouldChangeTo
76098>>>>>>>>>>>    Boolean bCancelTo
76098>>>>>>>>>>>    Boolean bErrorTo
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tAPITableNameInfo
76098>>>>>>>>>>>    Integer iTableNumber
76098>>>>>>>>>>>    String  sRootName
76098>>>>>>>>>>>    String  sLogicalName
76098>>>>>>>>>>>    String  sDisplayName
76098>>>>>>>>>>>    String  sDriverID
76098>>>>>>>>>>>    Boolean bIsAlias
76098>>>>>>>>>>>    Boolean bIsSQL
76098>>>>>>>>>>>    Boolean bIsSystemFile
76098>>>>>>>>>>>    Boolean bShouldChange
76098>>>>>>>>>>>    Boolean bCancel
76098>>>>>>>>>>>    Boolean bError
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tAPITableNameInfoCompare
76098>>>>>>>>>>>    Integer iTableNumber
76098>>>>>>>>>>>    // FROM
76098>>>>>>>>>>>    Boolean bExistsFrom
76098>>>>>>>>>>>    String  sRootNameFrom
76098>>>>>>>>>>>    String  sLogicalNameFrom
76098>>>>>>>>>>>    String  sDisplayNameFrom
76098>>>>>>>>>>>    String  sDriverIDFrom
76098>>>>>>>>>>>    Boolean bIsAliasFrom
76098>>>>>>>>>>>    Boolean bIsSQLFrom
76098>>>>>>>>>>>    Boolean bIsSystemFileFrom
76098>>>>>>>>>>>    // TO database:
76098>>>>>>>>>>>    Boolean bExistsTo
76098>>>>>>>>>>>    String  sRootNameTo
76098>>>>>>>>>>>    String  sLogicalNameTo
76098>>>>>>>>>>>    String  sDisplayNameTo
76098>>>>>>>>>>>    String  sDriverIDTo
76098>>>>>>>>>>>    Boolean bIsAliasTo
76098>>>>>>>>>>>    Boolean bIsSQLTo
76098>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
76098>>>>>>>>>>>    Boolean bShouldChange
76098>>>>>>>>>>>    Boolean bCancel
76098>>>>>>>>>>>    Boolean bError
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tAPITable
76098>>>>>>>>>>>    Handle hTable
76098>>>>>>>>>>>    Boolean bFromTable
76098>>>>>>>>>>>    Boolean bToTable
76098>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76098>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76098>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76098>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76098>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76098>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76098>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76098>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76098>>>>>>>>>>>    Boolean bShouldChange
76098>>>>>>>>>>>    Boolean bCancel
76098>>>>>>>>>>>    Boolean bError
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tAPITableCompare
76098>>>>>>>>>>>    Handle hTable
76098>>>>>>>>>>>    // FROM database:
76098>>>>>>>>>>>    Boolean bExistsFrom
76098>>>>>>>>>>>    // TO database:
76098>>>>>>>>>>>    Boolean bExistsTo
76098>>>>>>>>>>>    // Both:
76098>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76098>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76098>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76098>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76098>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76098>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76098>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76098>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76098>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
76098>>>>>>>>>>>    Boolean bCancel         // User cancel
76098>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Struct tAPITableBooleans
76098>>>>>>>>>>>    Boolean bApiTableUpdateAuto
76098>>>>>>>>>>>    Boolean bCompareDate_DateTime
76098>>>>>>>>>>>    Boolean bCompareIndexAscending
76098>>>>>>>>>>>    Boolean bCompareIndexUppercase
76098>>>>>>>>>>>    Boolean bCompareFilelistUppercase
76098>>>>>>>>>>>End_Struct
76098>>>>>>>>>>>
76098>>>>>>>>>>>Define C_tAPIColumn_None for 0
76098>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
76098>>>>>>>>>>>
76098>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
76098>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
76098>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
76098>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
76098>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
76098>>>>>>>>>>>Enum_List
76098>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
76098>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
76098>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
76098>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
76098>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
76098>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
76098>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
76098>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
76098>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
76098>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
76098>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
76098>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
76098>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
76098>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
76098>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
76098>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
76098>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
76098>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
76098>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
76098>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
76098>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
76098>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
76098>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
76098>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
76098>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
76098>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
76098>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
76098>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
76098>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
76098>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
76098>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
76098>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
76098>>>>>>>>>>>
76098>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
76098>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
76098>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
76098>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
76098>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
76098>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
76098>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
76098>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
76098>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
76098>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
76098>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
76098>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
76098>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
76098>>>>>>>>>>>End_Enum_List
76098>>>>>>>>>>>
76098>>>>>>>>>>>
76098>>>>>>>
76098>>>>>>>// This needs to be after Mertech drivers are defined.
76098>>>>>>>//Use cDbUpdateFunctionLibrary_Mixin.pkg
76098>>>>>>>
76098>>>>>>>
76098>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
76098>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
76098>>>>>>>
76098>>>>>>>    Define SQLFLEX   for "SQL_DRV"
76098>>>>>>>
76098>>>>>>>    Define MDSPgSQL  for "MDSPGSQL"
76098>>>>>>>
76098>>>>>>>    Define MDSMySQL  for "MDSMYSQL"
76098>>>>>>>
76098>>>>>>>    Define MDSDB2    for "MDS_DB2"
76098>>>>>>>
76098>>>>>>>    Define ORAFLEX   for "ORA_DRV"
76098>>>>>>>
76098>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76098>>>>>>>// They can have slightly different SQL keywords.
76098>>>>>>>// Note: If a new type is added to the list,
76098>>>>>>>//       the struct array xxx must be adjusted
76098>>>>>>>//       so that it is filled with all SQL
76098>>>>>>>//       keywords for that new type.
76098>>>>>>>Enum_List  
76098>>>>>>>End_Enum_List
76098>>>>>>>
76098>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76098>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76098>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76098>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76098>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76098>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76098>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76098>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76098>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76098>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
76098>>>>>>>
76098>>>>>>>
76098>>>>>>>// SQLConnection.ini constants:
76098>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
76098>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
76098>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
76098>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
76098>>>>>>>Define CS_SQLIniSectionName             for "Connection"
76098>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
76098>>>>>>>
76098>>>>>>>// DF 19 ini-file settings:
76098>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
76098>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
76098>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
76098>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
76098>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
76098>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
76098>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
76098>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
76098>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
76098>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
76098>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
76098>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
76098>>>>>>>
76098>>>>>>>// Database Update Framework extended settings:
76098>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
76098>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
76098>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
76098>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
76098>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
76098>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
76098>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
76098>>>>>>>
76098>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
76098>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
76098>>>>>>>Define CS_SQLIniConnectionNo            for "No"
76098>>>>>>>
76098>>>>>>>Struct tSQLConnection
76098>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
76098>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
76098>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
76098>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
76098>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
76098>>>>>>>    String sDatabase                // 6. SQL Database
76098>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
76098>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
76098>>>>>>>    String sUserID                  // 9. User ID
76098>>>>>>>    String sPassword                // 10. Password
76098>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
76098>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
76098>>>>>>>    String sLongTableSpace          // 13. DB2 specific
76098>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
76098>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
76098>>>>>>>    Boolean bError                  // 16. Set to true on error.
76098>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
76098>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
76098>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
76098>>>>>>>End_Struct
76098>>>>>Use cDbUpdateFunctionLibrary.inc
76098>>>>>
76098>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
76099>>>>>    Procedure CreateDbUpdateLibraryProperties
76101>>>>>        Handle hoSQLManagerMT
76101>>>>>
76101>>>>>        Property String private.psUseDatabase ""
76102>>>>>
76102>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
76102>>>>>        Property Handle  private.phCurrentTable 0
76103>>>>>        Property Integer private.piCurrentField 0
76104>>>>>
76104>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
76105>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
76106>>>>>
76106>>>>>        Property Handle phoSQLManagerMT
76107>>>>>
76107>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
76108>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
76109>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
76110>>>>>        Property Handle phoSQLConnectionHandler 0
76111>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
76112>>>>>
76112>>>>>        Property Boolean pbHandleQueryErrors True
76113>>>>>
76113>>>>>        Property tSqlColumnNew[] paQueryColumns
76114>>>>>        Property String[] paSQLFetchResults
76115>>>>>
76115>>>>>        // Error handling
76115>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
76116>>>>>        Property Boolean pbSqlError False
76117>>>>>        Property tSqlErrorArray paSqlErrorArray
76118>>>>>        Property Boolean pbProcessingError False
76119>>>>>
76119>>>>>        // Statistics on query
76119>>>>>        Property TimeSpan ptsTotalQueryTime
76120>>>>>        Property TimeSpan ptsQueryExec
76121>>>>>        Property TimeSpan ptsFetchResults
76122>>>>>        Property Integer piColumns 0
76123>>>>>        Property Integer piRows 0
76124>>>>>        Property Integer piRowType 0
76125>>>>>        Property String[] paQueryMessages
76126>>>>>        Property String psSQLStatementString
76127>>>>>
76127>>>>>        Property Integer[] paTableConvertExceptions
76128>>>>>
76128>>>>>        Property Integer[] paTableDateCorrectionExceptions
76129>>>>>
76129>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
76129>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
76129>>>>>        // the statements in smaller chunks than to execute them all at the same time.
76129>>>>>        Property Integer piChunkMax 500
76130>>>>>
76130>>>>>        // Fill the paSQLKeywordArray array with values;
76130>>>>>        Send SetupSQLKeywordArray
76131>>>>>        Move Self to ghoDbUpdateFunctionLibrary
76132>>>>>    End_Procedure
76133>>>>>
76133>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
76133>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76135>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
76137>>>>>            Function_Return (EQ)
76138>>>>>        End
76138>>>>>>
76138>>>>>        Function_Return (GT)
76139>>>>>    End_Function
76140>>>>>
76140>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
76140>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76142>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
76145>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
76148>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
76151>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
76154>>>>>
76154>>>>>        Function_Return (EQ)
76155>>>>>    End_Function
76156>>>>>
76156>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
76158>>>>>        tSQLKeyWords[] SQLKeywordArray
76158>>>>>        tSQLKeyWords[] SQLKeywordArray
76159>>>>>        Integer iSize
76159>>>>>
76159>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76160>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
76161>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
76162>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
76163>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
76164>>>>>
76164>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76165>>>>>    End_Procedure
76166>>>>>
76166>>>>>    // Creates a struct array with all SQL keywords
76166>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
76166>>>>>    // have slightly different wording.
76166>>>>>    // If a new EN_dbTypexxx type is added; additions
76166>>>>>    // needs to be done for every keyword group below.
76166>>>>>    Procedure SetupSQLKeywordArray
76168>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76168>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76170>>>>>
76170>>>>>        // This should only be called once; but in case it is
76170>>>>>        // we delete the array first.
76170>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76171>>>>>
76171>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
76171>>>>>        //
76171>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
76172>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
76173>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
76174>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
76175>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
76176>>>>>
76176>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
76177>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
76178>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
76179>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
76180>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
76181>>>>>
76181>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
76182>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
76183>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
76184>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
76185>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
76186>>>>>
76186>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
76187>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
76188>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
76189>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
76190>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
76191>>>>>
76191>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
76192>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
76193>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
76194>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
76195>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
76196>>>>>
76196>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
76197>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
76198>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
76199>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
76200>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
76201>>>>>
76201>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
76202>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
76203>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
76204>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
76205>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
76206>>>>>
76206>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
76207>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
76208>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
76209>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
76210>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
76211>>>>>
76211>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
76212>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
76213>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
76214>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
76215>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
76216>>>>>
76216>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
76217>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
76218>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
76219>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
76220>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
76221>>>>>
76221>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
76222>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
76223>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
76224>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
76225>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
76226>>>>>
76226>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
76227>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
76228>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
76229>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
76230>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
76231>>>>>
76231>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
76232>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
76233>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
76234>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
76235>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
76236>>>>>
76236>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
76237>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
76238>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
76239>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
76240>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
76241>>>>>
76241>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
76242>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
76243>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
76244>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
76245>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
76246>>>>>
76246>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
76247>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
76248>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
76249>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
76250>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
76251>>>>>
76251>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
76252>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
76253>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
76254>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
76255>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
76256>>>>>
76256>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
76257>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
76258>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
76259>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
76260>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
76261>>>>>
76261>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
76262>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
76263>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
76264>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
76265>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
76266>>>>>
76266>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
76267>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
76268>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
76269>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
76270>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
76271>>>>>
76271>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
76272>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
76273>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
76274>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
76275>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
76276>>>>>
76276>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
76277>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
76278>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
76279>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
76280>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
76281>>>>>
76281>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
76282>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
76283>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
76284>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
76285>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
76286>>>>>
76286>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
76287>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
76288>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
76289>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
76290>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
76291>>>>>
76291>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
76292>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
76293>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
76294>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
76295>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
76296>>>>>
76296>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
76297>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
76298>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
76299>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
76300>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
76301>>>>>
76301>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
76302>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
76303>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
76304>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
76305>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
76306>>>>>
76306>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
76307>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
76308>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
76309>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
76310>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
76311>>>>>
76311>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
76312>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
76313>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
76314>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
76315>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
76316>>>>>
76316>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
76317>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
76318>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
76319>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
76320>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
76321>>>>>
76321>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
76322>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
76323>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
76324>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
76325>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
76326>>>>>
76326>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
76327>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
76328>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
76329>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
76330>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
76331>>>>>
76331>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
76332>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
76333>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
76334>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
76335>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
76336>>>>>
76336>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
76337>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
76338>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
76339>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
76340>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
76341>>>>>
76341>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
76342>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
76343>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
76344>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
76345>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
76346>>>>>
76346>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
76347>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
76348>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
76349>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
76350>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
76351>>>>>
76351>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
76352>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
76353>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
76354>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
76355>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
76356>>>>>
76356>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
76357>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
76358>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
76359>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
76360>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
76361>>>>>
76361>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
76362>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
76363>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
76364>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
76365>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
76366>>>>>
76366>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
76367>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
76368>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
76369>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
76370>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
76371>>>>>
76371>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
76372>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
76373>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
76374>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
76375>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
76376>>>>>
76376>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
76377>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
76378>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
76379>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
76380>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
76381>>>>>
76381>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
76382>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
76383>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
76384>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
76385>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
76386>>>>>
76386>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
76387>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
76388>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
76389>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
76390>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
76391>>>>>
76391>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
76391>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76392>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
76393>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
76394>>>>>
76394>>>>>    End_Procedure
76395>>>>>
76395>>>>>End_Class
76396>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cSQLConnectionHandler.pkg)
76396>>>>>//****************************************************************************
76396>>>>>// $Module type: Class
76396>>>>>// $Module name: cSQLConnectionHandler.pkg
76396>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
76396>>>>>// Web-site    : http://www.rdctools.com
76396>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
76396>>>>>//
76396>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
76396>>>>>//
76396>>>>>// $Rev History:
76396>>>>>//    2015-08-11  Module header created
76396>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
76396>>>>>//                Added a new structure for passing connection data back & forth.
76396>>>>>//                Added better error handling.
76396>>>>>//                Added a decompose message for the connection string.
76396>>>>>//    2017-01-09  Added support for Mertech drivers
76396>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
76396>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
76396>>>>>//    2017-02-12  Reworked the whole connection property interface.
76396>>>>>//                Now there is one struct property that is the at cencter of a connection.
76396>>>>>//****************************************************************************
76396>>>>>Use cli.pkg
76396>>>>>Use MSSqldrv.pkg
76396>>>>>Use db2_drv.pkg
76396>>>>>Use odbc_drv.pkg
76396>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cSQLConnectionIniFile.pkg)
76396>>>>>>>//****************************************************************************
76396>>>>>>>// $Module type: Class
76396>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
76396>>>>>>>//
76396>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
76396>>>>>>>// Copyright (c) 2012 RDC Tools International
76396>>>>>>>// E-mail      : support@rdctools.com
76396>>>>>>>// Web-site    : http://www.rdctools.com
76396>>>>>>>//
76396>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
76396>>>>>>>//
76396>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
76396>>>>>>>//               properties of that object.
76396>>>>>>>//
76396>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76396>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76396>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76396>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76396>>>>>>>// in the help folder for more details.
76396>>>>>>>//
76396>>>>>>>Use cSQLConnectionIniFile.inc
76396>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cDbUpdateDatabaseDriver.pkg)
76396>>>>>>>>>Use cSQLConnectionIniFile.inc
76396>>>>>>>>>
76396>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
76397>>>>>>>>>    Procedure Construct_Object
76399>>>>>>>>>        Forward Send Construct_Object
76401>>>>>>>>>        Property String psDriverID DATAFLEX_ID
76402>>>>>>>>>    End_Procedure
76403>>>>>>>>>
76403>>>>>>>>>    Function ServerKeyword String sServer Returns String
76405>>>>>>>>>        String sRetval
76405>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
76407>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
76408>>>>>>>>>        End                                        
76408>>>>>>>>>>
76408>>>>>>>>>        Else Begin
76409>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
76410>>>>>>>>>        End
76410>>>>>>>>>>
76410>>>>>>>>>            
76410>>>>>>>>>        Function_Return sRetval
76411>>>>>>>>>    End_Function
76412>>>>>>>>>
76412>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76414>>>>>>>>>        String sConnect sServerKeyWord sDriverID
76414>>>>>>>>>
76414>>>>>>>>>        Get psDriverID to sDriverID
76415>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
76416>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
76417>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
76419>>>>>>>>>            Move "" to sDatabase
76420>>>>>>>>>        End
76420>>>>>>>>>>
76420>>>>>>>>>        
76420>>>>>>>>>        // 2019-10-20 I think this was plain wrong for the DAW ODBC_DRV driver. At least it didn't work for login to an MS-SQL db.
76420>>>>>>>>>//        If (bTrusted = False and (sDriverID = ODBC_DRV_ID and sServerKeyWord = CS_SQLIniDSNKeyword)) Begin
76420>>>>>>>>>//            Function_Return sConnect
76420>>>>>>>>>//        End
76420>>>>>>>>>
76420>>>>>>>>>        If (sDatabase <> "") Begin
76422>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
76423>>>>>>>>>        End
76423>>>>>>>>>>
76423>>>>>>>>>        If (bTrusted = True) Begin
76425>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
76426>>>>>>>>>        End
76426>>>>>>>>>>
76426>>>>>>>>>        Else Begin
76427>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
76428>>>>>>>>>        End
76428>>>>>>>>>>
76428>>>>>>>>>        Function_Return sConnect
76429>>>>>>>>>    End_Function
76430>>>>>>>>>
76430>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76432>>>>>>>>>        Boolean bLoginSuccessful
76432>>>>>>>>>        String sDriverID
76432>>>>>>>>>
76432>>>>>>>>>        Get psDriverID to sDriverID
76433>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
76435>>>>>>>>>            Function_Return True
76436>>>>>>>>>        End
76436>>>>>>>>>>
76436>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
76437>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
76439>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
76440>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
76442>>>>>>>>>        End
76442>>>>>>>>>>
76442>>>>>>>>>        Else Begin
76443>>>>>>>>>            Login sConnectionString "" "" sDriverID
76445>>>>>>>>>        End
76445>>>>>>>>>>
76445>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
76446>>>>>>>>>        Function_Return bLoginSuccessful
76447>>>>>>>>>    End_Function
76448>>>>>>>>>End_Class
76449>>>>>>>>>
76449>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
76450>>>>>>>>>    Function ServerKeyword String sServer Returns String
76452>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
76453>>>>>>>>>    End_Function
76454>>>>>>>>>End_Class
76455>>>>>>>>>
76455>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
76456>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76458>>>>>>>>>        Boolean bLoginSuccessful
76458>>>>>>>>>        String sDriverID
76458>>>>>>>>>
76458>>>>>>>>>        Get psDriverID to sDriverID
76459>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
76460>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
76462>>>>>>>>>            Function_Return True
76463>>>>>>>>>        End
76463>>>>>>>>>>
76463>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
76464>>>>>>>>>        If (bTrusted = False) Begin
76466>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
76468>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
76469>>>>>>>>>            End
76469>>>>>>>>>>
76469>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
76472>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
76473>>>>>>>>>            End
76473>>>>>>>>>>
76473>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
76475>>>>>>>>>        End
76475>>>>>>>>>>
76475>>>>>>>>>        Else Begin
76476>>>>>>>>>            Login sConnectionString "" "" sDriverID
76478>>>>>>>>>        End
76478>>>>>>>>>>
76478>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
76479>>>>>>>>>
76479>>>>>>>>>        Function_Return bLoginSuccessful
76480>>>>>>>>>    End_Function
76481>>>>>>>>>End_Class
76482>>>>>>>>>
76482>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
76483>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76485>>>>>>>>>        Boolean bLoginSuccessful
76485>>>>>>>>>        String sDriverID
76485>>>>>>>>>
76485>>>>>>>>>        Move False to Err
76486>>>>>>>>>        Get psDriverID to sDriverID
76487>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
76489>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
76490>>>>>>>>>        End
76490>>>>>>>>>>
76490>>>>>>>>>        Login sServer sUserId sPassword sDriverID
76492>>>>>>>>>
76492>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
76493>>>>>>>>>        Function_Return bLoginSuccessful
76494>>>>>>>>>    End_Function
76495>>>>>>>>>End_Class
76496>>>>>>>>>
76496>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
76497>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76499>>>>>>>>>        Boolean bLoginSuccessful
76499>>>>>>>>>        String sDriverID
76499>>>>>>>>>
76499>>>>>>>>>        Move False to Err
76500>>>>>>>>>        Get psDriverID to sDriverID
76501>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
76501>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
76501>>>>>>>>>//        End
76501>>>>>>>>>        Login sServer sUserId sPassword sDriverID
76503>>>>>>>>>
76503>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
76504>>>>>>>>>        Function_Return bLoginSuccessful
76505>>>>>>>>>    End_Function
76506>>>>>>>>>End_Class
76507>>>>>>>>>
76507>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
76508>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76510>>>>>>>>>        Function_Return ""
76511>>>>>>>>>    End_Function
76512>>>>>>>>>End_Class
76513>>>>>>>>>
76513>>>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
76514>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76516>>>>>>>>>        Boolean bLoginSuccessful
76516>>>>>>>>>        String sDriverID
76516>>>>>>>>>
76516>>>>>>>>>        Get psDriverID to sDriverID
76517>>>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
76517>>>>>>>>>        Move False to Err
76518>>>>>>>>>        If (bTrusted = False) Begin
76520>>>>>>>>>            Login sServer sUserId sPassword sDriverID
76522>>>>>>>>>        End
76522>>>>>>>>>>
76522>>>>>>>>>        Else Begin
76523>>>>>>>>>            Login sServer "" "" sDriverID
76525>>>>>>>>>        End
76525>>>>>>>>>>
76525>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
76526>>>>>>>>>
76526>>>>>>>>>        Function_Return bLoginSuccessful
76527>>>>>>>>>    End_Function
76528>>>>>>>>>End_Class
76529>>>>>>>>>
76529>>>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
76530>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76532>>>>>>>>>        Boolean bLoginSuccessful
76532>>>>>>>>>        String sDriverID
76532>>>>>>>>>        Integer iPos
76532>>>>>>>>>
76532>>>>>>>>>        Get psDriverID to sDriverID
76533>>>>>>>>>        Move (Pos("/", sServer)) to iPos
76534>>>>>>>>>        If (iPos = 0) Begin
76536>>>>>>>>>            If (sDatabase <> "") Begin
76538>>>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
76539>>>>>>>>>            End
76539>>>>>>>>>>
76539>>>>>>>>>        End
76539>>>>>>>>>>
76539>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
76539>>>>>>>>>        Move False to Err
76540>>>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
76540>>>>>>>>>        Login sServer sUserId sPassword sDriverID
76542>>>>>>>>>
76542>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
76543>>>>>>>>>        Function_Return bLoginSuccessful
76544>>>>>>>>>    End_Function
76545>>>>>>>>>End_Class
76546>>>>>>>>>
76546>>>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
76547>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76549>>>>>>>>>        Boolean bLoginSuccessful
76549>>>>>>>>>        String sDriverID
76549>>>>>>>>>
76549>>>>>>>>>        Get psDriverID to sDriverID
76550>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
76550>>>>>>>>>        Move False to Err
76551>>>>>>>>>        If (bTrusted = False) Begin
76553>>>>>>>>>            Login sServer sUserId sPassword sDriverID
76555>>>>>>>>>        End
76555>>>>>>>>>>
76555>>>>>>>>>        Else Begin
76556>>>>>>>>>            Login sServer "" "" sDriverID
76558>>>>>>>>>        End
76558>>>>>>>>>>
76558>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
76559>>>>>>>>>        Function_Return bLoginSuccessful
76560>>>>>>>>>    End_Function
76561>>>>>>>>>End_Class
76562>>>>>>>>>
76562>>>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
76563>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76565>>>>>>>>>        Boolean bLoginSuccessful
76565>>>>>>>>>        String sDriverID
76565>>>>>>>>>
76565>>>>>>>>>        Get psDriverID to sDriverID
76566>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
76566>>>>>>>>>        Move False to Err
76567>>>>>>>>>        If (bTrusted = False) Begin
76569>>>>>>>>>            Login sServer sUserId sPassword sDriverID
76571>>>>>>>>>        End
76571>>>>>>>>>>
76571>>>>>>>>>        Else Begin
76572>>>>>>>>>            Login sServer "" "" sDriverID
76574>>>>>>>>>        End
76574>>>>>>>>>>
76574>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
76575>>>>>>>>>        Function_Return bLoginSuccessful
76576>>>>>>>>>    End_Function
76577>>>>>>>>>End_Class
76578>>>>>>>>>
76578>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
76579>>>>>>>>>    Procedure Construct_Object
76581>>>>>>>>>        Forward Send Construct_Object
76583>>>>>>>>>        Property String psDriverID DATAFLEX_ID
76584>>>>>>>>>        Property Handle phoDriverSpecificObject
76585>>>>>>>>>    End_Procedure
76586>>>>>>>>>
76586>>>>>>>>>    Function CreateDriver Returns Handle
76588>>>>>>>>>        String sDriverID
76588>>>>>>>>>        Handle hoDriver hcDriverClass
76588>>>>>>>>>
76588>>>>>>>>>        Get psDriverID to sDriverID
76589>>>>>>>>>        Case Begin
76589>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
76591>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
76592>>>>>>>>>                Case Break
76593>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
76596>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
76597>>>>>>>>>                Case Break
76598>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
76601>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
76602>>>>>>>>>                Case Break               
76603>>>>>>>>>//            Case (sDriverID = DFBTRDRV_ID)
76603>>>>>>>>>//                Move (RefClass(cDbUpdateDatabaseDriver)) to hcDriverClass
76603>>>>>>>>>//                Case Break
76603>>>>>>>>>            Case (sDriverID = SQLFLEX)
76606>>>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
76607>>>>>>>>>                Case Break
76608>>>>>>>>>            Case (sDriverID = ORAFLEX)
76611>>>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
76612>>>>>>>>>                Case Break
76613>>>>>>>>>            Case (sDriverID = MDSPgSQL)
76616>>>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
76617>>>>>>>>>                Case Break
76618>>>>>>>>>            Case (sDriverID = MDSMySQL)
76621>>>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
76622>>>>>>>>>                Case Break
76623>>>>>>>>>            // DATAFLEX_ID = Default driver
76623>>>>>>>>>            Case Else
76623>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
76624>>>>>>>>>                Move DATAFLEX_ID to sDriverID
76625>>>>>>>>>        Case End
76625>>>>>>>>>
76625>>>>>>>>>        Get Create hcDriverClass to hoDriver
76626>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
76627>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
76628>>>>>>>>>
76628>>>>>>>>>        Function_Return hoDriver
76629>>>>>>>>>    End_Function
76630>>>>>>>>>
76630>>>>>>>>>    Procedure DestroyDriver
76632>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
76634>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
76635>>>>>>>>>        End
76635>>>>>>>>>>
76635>>>>>>>>>    End_Procedure
76636>>>>>>>>>
76636>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76638>>>>>>>>>        String sConnect
76638>>>>>>>>>        Handle hoDriver
76638>>>>>>>>>
76638>>>>>>>>>        Get CreateDriver to hoDriver
76639>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
76640>>>>>>>>>        Send DestroyDriver
76641>>>>>>>>>        Function_Return sConnect
76642>>>>>>>>>    End_Function
76643>>>>>>>>>
76643>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76645>>>>>>>>>        Boolean bLoginSuccessful
76645>>>>>>>>>        Handle hoDriver
76645>>>>>>>>>
76645>>>>>>>>>        Get CreateDriver to hoDriver
76646>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
76647>>>>>>>>>        Send DestroyDriver
76648>>>>>>>>>        Function_Return bLoginSuccessful
76649>>>>>>>>>    End_Function
76650>>>>>>>>>
76650>>>>>>>>>End_Class
76651>>>>>>>
76651>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cLoginEncryption.pkg)
76651>>>>>>>>>Use cCryptographerEx.pkg
76651>>>>>>>>>
76651>>>>>>>>>Class cLoginEncryption is a cObject
76652>>>>>>>>>    
76652>>>>>>>>>    Procedure Construct_Object
76654>>>>>>>>>        Forward Send Construct_Object
76656>>>>>>>>>        // this must be set to a multi (40ish) character random key
76656>>>>>>>>>        Property String psEncryptPassword ""
76657>>>>>>>>>        
76657>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
76659>>>>>>>>>            Set piHash to CALG_SHA_256
76660>>>>>>>>>            Set piCipher to CALG_AES_256
76661>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
76662>>>>>>>>>            Set piProvider to PROV_RSA_AES
76663>>>>>>>>>        End_Object
76664>>>>>>>>>    End_Procedure
76665>>>>>>>>>    
76665>>>>>>>>>    // This can be augmented to return a password encryption key using any
76665>>>>>>>>>    // hidden mechanism desired.
76665>>>>>>>>>    Function GetEncryptionPassword Returns String
76667>>>>>>>>>        String sPassword
76667>>>>>>>>>        Get psEncryptPassword to sPassword
76668>>>>>>>>>        Function_Return sPassword
76669>>>>>>>>>    End_Function
76670>>>>>>>>>    
76670>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
76670>>>>>>>>>    //
76670>>>>>>>>>    // Params:
76670>>>>>>>>>    //   sPlainText     String to encrypt.
76670>>>>>>>>>    // Returns:
76670>>>>>>>>>    //   Base64 encoded hash.
76670>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
76672>>>>>>>>>        String sEncryptPassword sBase64
76672>>>>>>>>>        UChar[] ucBinary
76673>>>>>>>>>        Pointer pBase64
76673>>>>>>>>>        Integer iVoid
76673>>>>>>>>>        
76673>>>>>>>>>        //  Encrypt Key
76673>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
76674>>>>>>>>>        If (sEncryptPassword = "") Begin
76676>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
76677>>>>>>>>>>
76677>>>>>>>>>        End
76677>>>>>>>>>>
76677>>>>>>>>>        
76677>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
76678>>>>>>>>>        
76678>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
76680>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
76681>>>>>>>>>>
76681>>>>>>>>>            Function_Return ""
76682>>>>>>>>>        End
76682>>>>>>>>>>
76682>>>>>>>>>        
76682>>>>>>>>>        //  Encode binary hash to Base64
76682>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
76683>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
76684>>>>>>>>>        Move (Free(pBase64)) to iVoid
76685>>>>>>>>>        
76685>>>>>>>>>        Function_Return sBase64
76686>>>>>>>>>    End_Function
76687>>>>>>>>>    
76687>>>>>>>>>    
76687>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
76687>>>>>>>>>    //
76687>>>>>>>>>    // Params:
76687>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
76687>>>>>>>>>    // Returns:
76687>>>>>>>>>    //   Readable plain text password
76687>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
76689>>>>>>>>>        String sEncryptPassword
76689>>>>>>>>>        UChar[] ucBinary ucPlain
76691>>>>>>>>>        Boolean bIsHex
76691>>>>>>>>>        Integer iLen iVoid
76691>>>>>>>>>        Pointer pBinary
76691>>>>>>>>>        
76691>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
76693>>>>>>>>>            //  Decode from Base64
76693>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
76694>>>>>>>>>            
76694>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
76695>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
76696>>>>>>>>>                        
76696>>>>>>>>>            Move (Free(pBinary)) to iVoid
76697>>>>>>>>>            
76697>>>>>>>>>            //  Encrypted binary hash to string
76697>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
76698>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
76699>>>>>>>>>        End
76699>>>>>>>>>>
76699>>>>>>>>>        
76699>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
76700>>>>>>>>>    End_Function
76701>>>>>>>>>End_Class
76702>>>>>>>
76702>>>>>>>Class cSQLConnectionIniFile is a cIniFile
76703>>>>>>>    Procedure Construct_Object
76705>>>>>>>        Forward Send Construct_Object
76707>>>>>>>
76707>>>>>>>        Property String Private_psIniFilePath
76708>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
76709>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
76710>>>>>>>
76710>>>>>>>        Property Boolean pbDFConnId False
76711>>>>>>>
76711>>>>>>>        // *** You really want to change this value! ***
76711>>>>>>>        // It is used when encrypting/decrypting passwords.
76711>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
76712>>>>>>>
76712>>>>>>>    End_Procedure
76713>>>>>>>
76713>>>>>>>    Procedure End_Construct_Object
76715>>>>>>>        Forward Send End_Construct_Object
76717>>>>>>>    End_Procedure
76718>>>>>>>
76718>>>>>>>    Procedure Set psIniFilePath String sPath
76720>>>>>>>        String sIniFile
76720>>>>>>>        Get vFolderFormat sPath to sPath
76721>>>>>>>        Set private_psIniFilePath to sPath
76722>>>>>>>        Get psIniFileName to sIniFile
76723>>>>>>>        Set psFileName to (sPath + sIniFile)
76724>>>>>>>    End_Procedure
76725>>>>>>>
76725>>>>>>>    Function psIniFilePath Returns String
76727>>>>>>>        Function_Return (private_psIniFilePath(Self))
76728>>>>>>>    End_Function
76729>>>>>>>
76729>>>>>>>    Procedure Set psIniFileName String sFileName
76731>>>>>>>        String sPath
76731>>>>>>>        Get psIniFilePath to sPath
76732>>>>>>>        Set psFileName to (sPath + sFileName)
76733>>>>>>>        Set private_psIniFileName to sFileName
76734>>>>>>>    End_Procedure
76735>>>>>>>
76735>>>>>>>    Function psIniFileName Returns String
76737>>>>>>>        Function_Return (private_psIniFileName(Self))
76738>>>>>>>    End_Function
76739>>>>>>>
76739>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
76739>>>>>>>    // Sets a value in the program's ini file (write)
76739>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
76739>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
76741>>>>>>>        String sIniFile sPath
76741>>>>>>>
76741>>>>>>>        Get psIniFilePath to sPath
76742>>>>>>>        Get psIniFileName to sIniFile
76743>>>>>>>        Move (sPath + sIniFile) to sIniFile
76744>>>>>>>        Set psFileName to sIniFile
76745>>>>>>>        Send WriteString sSection sValueName sValue
76746>>>>>>>    End_Procedure
76747>>>>>>>
76747>>>>>>>    // Get a value from program's ini-file (read)
76747>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
76747>>>>>>>    // Returns the value
76747>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
76749>>>>>>>        String sValue sIniFile sPath
76749>>>>>>>
76749>>>>>>>        Get psIniFilePath to sPath
76750>>>>>>>        Get psIniFileName to sIniFile
76751>>>>>>>        Move (sPath + sIniFile) to sIniFile
76752>>>>>>>        Set psFileName to sIniFile
76753>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
76754>>>>>>>
76754>>>>>>>        Function_Return sValue
76755>>>>>>>    End_Function
76756>>>>>>>
76756>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
76756>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
76758>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
76761>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
76764>>>>>>>
76764>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
76767>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
76770>>>>>>>
76770>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
76773>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
76776>>>>>>>
76776>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
76779>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
76782>>>>>>>
76782>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
76785>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
76788>>>>>>>
76788>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
76791>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
76794>>>>>>>
76794>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
76797>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
76800>>>>>>>
76800>>>>>>>        Function_Return (EQ)
76801>>>>>>>    End_Function
76802>>>>>>>
76802>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
76804>>>>>>>        Handle hoSections
76804>>>>>>>        Integer iItems
76804>>>>>>>
76804>>>>>>>        Send ReadSections hoSections
76805>>>>>>>        Move (Item_Count(hoSections)) to iItems
76806>>>>>>>        Function_Return iItems
76807>>>>>>>    End_Function
76808>>>>>>>
76808>>>>>>>    // The normal connection string looks something like this;
76808>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
76808>>>>>>>    // ...but the full connection string looks like this;
76808>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
76808>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
76808>>>>>>>//        String sSection
76808>>>>>>>//        Integer iCount
76808>>>>>>>//
76808>>>>>>>//        Move False to Err
76808>>>>>>>//        Get psIniSectionName to sSection
76808>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
76808>>>>>>>//        Increment iCount
76808>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
76808>>>>>>>//
76808>>>>>>>//        Function_Return (Err = False)
76808>>>>>>>//    End_Function
76808>>>>>>>
76808>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
76810>>>>>>>        Integer iCount
76810>>>>>>>        Boolean bExists
76810>>>>>>>        String sSection
76810>>>>>>>
76810>>>>>>>        Move False to Err
76811>>>>>>>        Move 1 to iCount
76812>>>>>>>        Get psIniSectionName to sSection
76813>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
76814>>>>>>>        While (bExists = True)
76818>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
76819>>>>>>>            Increment iCount
76820>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
76821>>>>>>>        Loop
76822>>>>>>>>
76822>>>>>>>        Function_Return (Err = False)
76823>>>>>>>    End_Function
76824>>>>>>>
76824>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
76826>>>>>>>        Integer iCount
76826>>>>>>>        String sSection
76826>>>>>>>        Boolean bExists
76826>>>>>>>
76826>>>>>>>        Move False to Err
76827>>>>>>>        Move 1 to iCount
76828>>>>>>>        Get psIniSectionName to sSection
76829>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
76830>>>>>>>        While (bExists = True)
76834>>>>>>>            If (iCount = iItem) Begin
76836>>>>>>>                Send DeleteSection sSection
76837>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
76837>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
76838>>>>>>>            End
76838>>>>>>>>
76838>>>>>>>            Increment iCount
76839>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
76840>>>>>>>        Loop
76841>>>>>>>>
76841>>>>>>>
76841>>>>>>>        Function_Return (Err = False)
76842>>>>>>>    End_Function
76843>>>>>>>
76843>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
76843>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
76843>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
76845>>>>>>>        tSQLConnection[] SQLConnectionsArray
76845>>>>>>>        tSQLConnection[] SQLConnectionsArray
76846>>>>>>>        tSQLConnection   SQLConnection
76846>>>>>>>        tSQLConnection   SQLConnection
76846>>>>>>>        Integer iIndex
76846>>>>>>>
76846>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
76847>>>>>>>        If (iIndex = -1) Begin
76849>>>>>>>            Move True to SQLConnection.bError
76850>>>>>>>            Function_Return SQLConnection
76851>>>>>>>        End
76851>>>>>>>>
76851>>>>>>>
76851>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76852>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
76853>>>>>>>
76853>>>>>>>        Function_Return SQLConnection
76854>>>>>>>    End_Function
76855>>>>>>>
76855>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
76855>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
76857>>>>>>>        tSQLConnection[] SQLConnectionsArray
76857>>>>>>>        tSQLConnection[] SQLConnectionsArray
76858>>>>>>>        Integer iRetval iCount iSize
76858>>>>>>>        String sValue
76858>>>>>>>        Boolean bExists
76858>>>>>>>
76858>>>>>>>        Move -1 to iRetval
76859>>>>>>>
76859>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76860>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
76861>>>>>>>        Decrement iSize
76862>>>>>>>        For iCount from 0 to iSize
76868>>>>>>>>
76868>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
76869>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
76870>>>>>>>            If (bExists) Begin
76872>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
76873>>>>>>>                Move iSize to iCount         // We're done!
76874>>>>>>>            End
76874>>>>>>>>
76874>>>>>>>        Loop
76875>>>>>>>>
76875>>>>>>>
76875>>>>>>>        Function_Return iRetval
76876>>>>>>>    End_Function
76877>>>>>>>
76877>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
76877>>>>>>>    // Used to check that ConnectionID's are unique.
76877>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
76879>>>>>>>        Integer iCount iSize iItems
76879>>>>>>>        String sValue
76879>>>>>>>        Boolean bExists
76879>>>>>>>        tSQLConnection[] SQLConnectionsArray
76879>>>>>>>        tSQLConnection[] SQLConnectionsArray
76880>>>>>>>
76880>>>>>>>        Move 0 to iItems
76881>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76882>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
76883>>>>>>>        Decrement iSize
76884>>>>>>>        For iCount from 0 to iSize
76890>>>>>>>>
76890>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
76891>>>>>>>            Move (sValue = sConnectionID) to bExists
76892>>>>>>>            If (bExists) Begin
76894>>>>>>>                Increment iItems
76895>>>>>>>            End
76895>>>>>>>>
76895>>>>>>>        Loop
76896>>>>>>>>
76896>>>>>>>
76896>>>>>>>        Function_Return (iItems > 1)
76897>>>>>>>    End_Function
76898>>>>>>>
76898>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
76898>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
76900>>>>>>>        Boolean bOK
76900>>>>>>>        Integer iSize iCount
76900>>>>>>>        tSQLConnection[] SQLConnectionsArray
76900>>>>>>>        tSQLConnection[] SQLConnectionsArray
76901>>>>>>>        tSQLConnection SQLConnection
76901>>>>>>>        tSQLConnection SQLConnection
76901>>>>>>>        String sConnectionString
76901>>>>>>>
76901>>>>>>>        Move False to Err
76902>>>>>>>        Get psConnectionString to sConnectionString
76903>>>>>>>
76903>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76904>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
76905>>>>>>>        Decrement iSize
76906>>>>>>>        // Set all current connection to inactive.
76906>>>>>>>        For iCount from 0 to iSize
76912>>>>>>>>
76912>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
76913>>>>>>>        Loop
76914>>>>>>>>
76914>>>>>>>
76914>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
76915>>>>>>>        Move True              to SQLConnection.bEnabled
76916>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
76917>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
76918>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
76919>>>>>>>
76919>>>>>>>        Function_Return (bOK = True)
76920>>>>>>>    End_Function
76921>>>>>>>
76921>>>>>>>    // Used for updating an existing connection with new data.
76921>>>>>>>    // Returns True if successful.
76921>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
76923>>>>>>>        Boolean bOK
76923>>>>>>>        Integer iItem iSize iCount
76923>>>>>>>        tSQLConnection[] SQLConnectionsArray
76923>>>>>>>        tSQLConnection[] SQLConnectionsArray
76924>>>>>>>
76924>>>>>>>        Move False to Err
76925>>>>>>>        Move -1 to iItem
76926>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
76927>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
76928>>>>>>>        Decrement iSize
76929>>>>>>>        // Set all current connection to inactive.
76929>>>>>>>        For iCount from 0 to iSize
76935>>>>>>>>
76935>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
76936>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
76938>>>>>>>                Move iCount to iItem
76939>>>>>>>            End
76939>>>>>>>>
76939>>>>>>>        Loop
76940>>>>>>>>
76940>>>>>>>
76940>>>>>>>        If (iItem <> -1) Begin
76942>>>>>>>            Move True to SQLConnection.bEnabled
76943>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
76944>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
76945>>>>>>>        End
76945>>>>>>>>
76945>>>>>>>
76945>>>>>>>        Function_Return (bOK = True)
76946>>>>>>>    End_Function
76947>>>>>>>
76947>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
76949>>>>>>>        tSQLConnection[] SQLConnectionsArray
76949>>>>>>>        tSQLConnection[] SQLConnectionsArray
76950>>>>>>>        String sSection sValue
76950>>>>>>>        Integer iCount
76950>>>>>>>        Boolean bExists
76950>>>>>>>
76950>>>>>>>        Get psIniSectionName to sSection
76951>>>>>>>        Get SectionExists sSection to bExists
76952>>>>>>>        If (bExists = False) Begin
76954>>>>>>>            Function_Return SQLConnectionsArray
76955>>>>>>>        End
76955>>>>>>>>
76955>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
76956>>>>>>>        If (bExists = True) Begin
76958>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
76959>>>>>>>>
76959>>>>>>>        End
76959>>>>>>>>
76959>>>>>>>
76959>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
76960>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
76961>>>>>>>
76961>>>>>>>        While (bExists = True)                 
76965>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
76965>>>>>>>            // We always put the enabled/active connection at the top
76965>>>>>>>//            Move (iCount = 1) to bEnabled
76965>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
76965>>>>>>>
76965>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
76966>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
76967>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
76968>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
76969>>>>>>>
76969>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
76969>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
76970>>>>>>>            If (sValue = "99") Begin
76972>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
76973>>>>>>>            End
76973>>>>>>>>
76973>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
76974>>>>>>>
76974>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
76975>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
76976>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
76978>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
76979>>>>>>>            End
76979>>>>>>>>
76979>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
76981>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
76982>>>>>>>            End
76982>>>>>>>>
76982>>>>>>>
76982>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
76983>>>>>>>
76983>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
76984>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
76985>>>>>>>
76985>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
76986>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
76987>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
76989>>>>>>>                Get DecryptPassword sValue to sValue
76990>>>>>>>            End
76990>>>>>>>>
76990>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
76991>>>>>>>
76991>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
76991>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
76992>>>>>>>
76992>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
76993>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
76994>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
76995>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
76996>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
76997>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
76998>>>>>>>
76998>>>>>>>            Increment iCount
76999>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77000>>>>>>>        Loop
77001>>>>>>>>
77001>>>>>>>
77001>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
77001>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
77003>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
77004>>>>>>>        End
77004>>>>>>>>
77004>>>>>>>
77004>>>>>>>        Function_Return SQLConnectionsArray
77005>>>>>>>    End_Function
77006>>>>>>>
77006>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
77008>>>>>>>        Integer iCount iSize
77008>>>>>>>        Boolean bOK
77008>>>>>>>        String sSection sValue
77008>>>>>>>
77008>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
77008>>>>>>>        Move 0 to iCount
77009>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
77010>>>>>>>        If (bOK = False) Begin
77012>>>>>>>            Function_Return False
77013>>>>>>>        End
77013>>>>>>>>
77013>>>>>>>
77013>>>>>>>        Move False to Err
77014>>>>>>>        Get psIniSectionName to sSection
77015>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
77015>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
77016>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77017>>>>>>>        Decrement iSize
77018>>>>>>>
77018>>>>>>>        For iCount from 0 to iSize
77024>>>>>>>>
77024>>>>>>>            // DF 19 compatible settings:
77024>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
77025>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
77026>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
77027>>>>>>>            
77027>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
77028>>>>>>>
77028>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
77029>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77031>>>>>>>                Get EncryptPassword sValue to sValue
77032>>>>>>>            End
77032>>>>>>>>
77032>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
77033>>>>>>>
77033>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
77035>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
77036>>>>>>>            End
77036>>>>>>>>
77036>>>>>>>
77036>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
77037>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
77038>>>>>>>
77038>>>>>>>            // The Database Update Framework extended settings:
77038>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
77039>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
77040>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
77041>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
77042>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
77043>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
77044>>>>>>>        Loop
77045>>>>>>>>
77045>>>>>>>
77045>>>>>>>        Function_Return (bOK and Err = False)
77046>>>>>>>    End_Function
77047>>>>>>>
77047>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
77047>>>>>>>    //
77047>>>>>>>    // SQL utility function that returns a database type (string) constant
77047>>>>>>>    // corresponding to the passed iDbType.
77047>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
77049>>>>>>>        String sRetval
77049>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77051>>>>>>>            Move CS_dbTypeMSSQL to sRetval
77052>>>>>>>        End
77052>>>>>>>>
77052>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77054>>>>>>>            Move CS_dbTypeMySQL to sRetval
77055>>>>>>>        End
77055>>>>>>>>
77055>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77057>>>>>>>            Move CS_dbTypeOracle to sRetval
77058>>>>>>>        End
77058>>>>>>>>
77058>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77060>>>>>>>            Move CS_dbTypeDB2 to sRetval
77061>>>>>>>        End
77061>>>>>>>>
77061>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77063>>>>>>>            Move CS_dbTypePostgre to sRetval
77064>>>>>>>        End
77064>>>>>>>>
77064>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77066>>>>>>>            Move CS_DbTypePervasive to sRetval
77067>>>>>>>        End
77067>>>>>>>>
77067>>>>>>>        Function_Return sRetval
77068>>>>>>>    End_Function
77069>>>>>>>
77069>>>>>>>    // SQL utility function that returns a database type constant (integer)
77069>>>>>>>    // corresponding to the passed sDbType string constant.
77069>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
77071>>>>>>>        Integer iRetval
77071>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
77073>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77074>>>>>>>        End
77074>>>>>>>>
77074>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
77076>>>>>>>            Move EN_dbTypeMySQL to iRetval
77077>>>>>>>        End
77077>>>>>>>>
77077>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
77079>>>>>>>            Move EN_dbTypeOracle to iRetval
77080>>>>>>>        End
77080>>>>>>>>
77080>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
77082>>>>>>>            Move EN_dbTypeDB2 to iRetval
77083>>>>>>>        End
77083>>>>>>>>
77083>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
77085>>>>>>>            Move EN_dbTypePostgre to iRetval
77086>>>>>>>        End
77086>>>>>>>>
77086>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
77088>>>>>>>            Move EN_DbTypePervasive to iRetval
77089>>>>>>>        End
77089>>>>>>>>
77089>>>>>>>        Function_Return iRetval
77090>>>>>>>    End_Function
77091>>>>>>>
77091>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
77091>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
77091>>>>>>>    // the SQL Connection program's grid.
77091>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
77093>>>>>>>        String sRetval
77093>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77095>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
77096>>>>>>>        End
77096>>>>>>>>
77096>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77098>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
77099>>>>>>>        End
77099>>>>>>>>
77099>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77101>>>>>>>            Move "EN_dbTypeOracle" to sRetval
77102>>>>>>>        End
77102>>>>>>>>
77102>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77104>>>>>>>            Move "EN_dbTypeDB2" to sRetval
77105>>>>>>>        End
77105>>>>>>>>
77105>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77107>>>>>>>            Move "EN_dbTypePostgre" to sRetval
77108>>>>>>>        End
77108>>>>>>>>
77108>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77110>>>>>>>            Move "EN_dbTypePervasive" to sRetval
77111>>>>>>>        End
77111>>>>>>>>
77111>>>>>>>        Function_Return sRetval
77112>>>>>>>    End_Function
77113>>>>>>>
77113>>>>>>>    // Pass a driver id and the function will return
77113>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
77113>>>>>>>    // quite work and always returns "MS SQL Server"
77113>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
77115>>>>>>>        Integer iRetval
77115>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77117>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77118>>>>>>>        End
77118>>>>>>>>
77118>>>>>>>        If (sDriverID = SQLFLEX) Begin
77120>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77121>>>>>>>        End
77121>>>>>>>>
77121>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
77123>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77124>>>>>>>        End
77124>>>>>>>>
77124>>>>>>>        If (sDriverID = MDSMySQL) Begin
77126>>>>>>>            Move EN_dbTypeMySQL to iRetval
77127>>>>>>>        End
77127>>>>>>>>
77127>>>>>>>        If (sDriverID = ORAFLEX) Begin
77129>>>>>>>            Move EN_dbTypeOracle to iRetval
77130>>>>>>>        End
77130>>>>>>>>
77130>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
77132>>>>>>>            Move EN_dbTypeDB2 to iRetval
77133>>>>>>>        End
77133>>>>>>>>
77133>>>>>>>        If (sDriverID = MDSPgSQL) Begin
77135>>>>>>>            Move EN_dbTypePostgre to iRetval
77136>>>>>>>        End
77136>>>>>>>>
77136>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
77138>>>>>>>            Move EN_DbTypePervasive to iRetval
77139>>>>>>>        End
77139>>>>>>>>
77139>>>>>>>        Function_Return iRetval
77140>>>>>>>    End_Function
77141>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\ParseKeyWord.pkg)
77141>>>>>>>>
77141>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
77143>>>>>>>>    Integer iStart iEnd
77143>>>>>>>>    String sRetval
77143>>>>>>>>
77143>>>>>>>>    Move (Trim(sConnect)) to sConnect
77144>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
77145>>>>>>>>    If (iStart = 0) Begin
77147>>>>>>>>        Function_Return ""
77148>>>>>>>>    End
77148>>>>>>>>>
77148>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
77149>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
77150>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
77152>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77153>>>>>>>>    End
77153>>>>>>>>>
77153>>>>>>>>    Else Begin
77154>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
77155>>>>>>>>    End
77155>>>>>>>>>
77155>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
77157>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77158>>>>>>>>        Decrement iEnd
77159>>>>>>>>    End
77159>>>>>>>>>
77159>>>>>>>>    If (iEnd <> 0) Begin
77161>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
77162>>>>>>>>    End
77162>>>>>>>>>
77162>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
77163>>>>>>>>
77163>>>>>>>>    Function_Return (Trim(sRetval))
77164>>>>>>>>End_Function
77165>>>>>>>>
77165>>>>>>>>
77165>>>>>>>
77165>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77167>>>>>>>        String sConnect
77167>>>>>>>        Handle hoDriver
77167>>>>>>>
77167>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
77168>>>>>>>        Set psDriverID of hoDriver to sDriverID
77169>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77170>>>>>>>        Send Destroy of hoDriver
77171>>>>>>>
77171>>>>>>>        Function_Return sConnect
77172>>>>>>>    End_Function
77173>>>>>>>
77173>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
77173>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
77175>>>>>>>        String sConnect
77175>>>>>>>
77175>>>>>>>        Case Begin
77175>>>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
77177>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
77178>>>>>>>                If (sDatabase <> "") Begin
77180>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77181>>>>>>>                End
77181>>>>>>>>
77181>>>>>>>                Case Break
77182>>>>>>>
77182>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77185>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
77187>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
77188>>>>>>>                End
77188>>>>>>>>
77188>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
77191>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77192>>>>>>>                End
77192>>>>>>>>
77192>>>>>>>
77192>>>>>>>                If (sDatabase <> "") Begin
77194>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77195>>>>>>>                End
77195>>>>>>>>
77195>>>>>>>                Case Break
77196>>>>>>>
77196>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77199>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77200>>>>>>>                If (sDatabase <> "") Begin
77202>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77203>>>>>>>                End
77203>>>>>>>>
77203>>>>>>>                Case Break
77204>>>>>>>
77204>>>>>>>            Case (sDriverID = ORAFLEX)
77207>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77208>>>>>>>                If (sDatabase <> "") Begin
77210>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77211>>>>>>>                End
77211>>>>>>>>
77211>>>>>>>                Case Break
77212>>>>>>>
77212>>>>>>>            Case (sDriverID = MDSPgSQL)
77215>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77216>>>>>>>                If (sDatabase <> "") Begin
77218>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77219>>>>>>>                End
77219>>>>>>>>
77219>>>>>>>                Case Break
77220>>>>>>>
77220>>>>>>>            Case (sDriverID = MDSMySQL)
77223>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77224>>>>>>>                If (sDatabase <> "") Begin
77226>>>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77227>>>>>>>                End
77227>>>>>>>>
77227>>>>>>>                Case Break
77228>>>>>>>
77228>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
77231>>>>>>>                Break
77232>>>>>>>
77232>>>>>>>            Case Else
77232>>>>>>>                Move "" to sConnect
77233>>>>>>>        Case End
77233>>>>>>>
77233>>>>>>>        Function_Return sConnect
77234>>>>>>>    End_Function
77235>>>>>>>
77235>>>>>>>    // Use Base64
77235>>>>>>>    Function EncryptPassword String sPassword Returns String
77237>>>>>>>        String sRetval
77237>>>>>>>        Handle hoLoginEncryption
77237>>>>>>>
77237>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77238>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77239>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
77240>>>>>>>        Send Destroy of hoLoginEncryption
77241>>>>>>>          
77241>>>>>>>        Function_Return sRetval
77242>>>>>>>    End_Function
77243>>>>>>>
77243>>>>>>>    Function DecryptPassword String sPassword Returns String
77245>>>>>>>        String sRetval
77245>>>>>>>        Handle hoLoginEncryption
77245>>>>>>>
77245>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77246>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77247>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
77248>>>>>>>        Send Destroy of hoLoginEncryption
77249>>>>>>>
77249>>>>>>>        Function_Return sRetval
77250>>>>>>>    End_Function
77251>>>>>>>
77251>>>>>>>    // Returns the full path of the Application (no trailing "\")
77251>>>>>>>    Function ApplicationPath Returns String
77253>>>>>>>        String sApplicationFileName sPath
77253>>>>>>>        Integer iNumChars iRetval
77253>>>>>>>
77253>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
77254>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
77255>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
77256>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
77257>>>>>>>        Move (CString(sApplicationFileName)) to sPath
77258>>>>>>>
77258>>>>>>>        Function_Return sPath
77259>>>>>>>    End_Function
77260>>>>>>>
77260>>>>>>>    // Pass a filename including the extension. The return value
77260>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
77260>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
77260>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
77262>>>>>>>        Boolean bExists
77262>>>>>>>        Handle hoPaths hoIniFile
77262>>>>>>>        String[] asWorkSpaceFiles
77263>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
77263>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
77263>>>>>>>        
77263>>>>>>>        Get psIniFilePath to sProgramsPath
77264>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
77265>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
77266>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
77267>>>>>>>        If (bExists = True) Begin
77269>>>>>>>            Function_Return sProgramsPath
77270>>>>>>>        End                      
77270>>>>>>>>
77270>>>>>>>    
77270>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77271>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77273>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77274>>>>>>>        End                                              
77274>>>>>>>>
77274>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
77275>>>>>>>        
77275>>>>>>>        Move False to bExists
77276>>>>>>>        Get Create (RefClass(Array)) to hoPaths
77277>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
77278>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
77279>>>>>>>        Decrement iSize       
77280>>>>>>>        
77280>>>>>>>        For iCount from 0 to iSize
77286>>>>>>>>
77286>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
77287>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
77288>>>>>>>            Set psFileName of hoIniFile to sFileName
77289>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
77290>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
77296>>>>>>>>
77296>>>>>>>                Get Value of hoPaths iPath to sSection    
77297>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
77298>>>>>>>                // Check if there are more than one path specified;
77298>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
77299>>>>>>>                If (iNoOfPaths > 1) Begin         
77301>>>>>>>                    Move sRelativePath to sRelativePaths
77302>>>>>>>                    For iCountPath from 1 to iNoOfPaths
77308>>>>>>>>
77308>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
77309>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77310>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77311>>>>>>>                        Get vFolderFormat sPath to sPath
77312>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
77313>>>>>>>                        If (bExists = True) Begin
77315>>>>>>>                            Move iNoOfPaths to iCountPath
77316>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
77317>>>>>>>                            Move iSize to iCount
77318>>>>>>>                        End                                                    
77318>>>>>>>>
77318>>>>>>>                    Loop
77319>>>>>>>>
77319>>>>>>>                End
77319>>>>>>>>
77319>>>>>>>                Else Begin
77320>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77321>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77322>>>>>>>                    Get vFolderFormat sPath to sPath
77323>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
77324>>>>>>>                    If (bExists = True) Begin
77326>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
77327>>>>>>>                        Move iSize to iCount
77328>>>>>>>                    End                                                    
77328>>>>>>>>
77328>>>>>>>                End
77328>>>>>>>>
77328>>>>>>>            Loop
77329>>>>>>>>
77329>>>>>>>            If (bExists = False) Begin
77331>>>>>>>                Move "" to sPath    
77332>>>>>>>            End
77332>>>>>>>>
77332>>>>>>>            Send Destroy of hoIniFile          
77333>>>>>>>        Loop        
77334>>>>>>>>
77334>>>>>>>        Send Destroy of hoPaths
77335>>>>>>>        
77335>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
77335>>>>>>>        If (sPath = "") Begin
77337>>>>>>>            Get_File_Path sSearchFileName to sFileName   
77338>>>>>>>            Get ParseFolderName sFileName to sPath
77339>>>>>>>        End                  
77339>>>>>>>>
77339>>>>>>>        
77339>>>>>>>        Function_Return sPath    
77340>>>>>>>    End_Function
77341>>>>>>>    
77341>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
77341>>>>>>>    // with one or more .ws file names.
77341>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
77341>>>>>>>    // workspace file (.ws) and returns it as a string array.
77341>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
77341>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
77343>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
77345>>>>>>>        String sFile sHomePath sDirSep
77345>>>>>>>        Integer iCh iSize
77345>>>>>>>        Boolean bExists      
77345>>>>>>>        Handle hoIniFile 
77345>>>>>>>        
77345>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
77346>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
77347>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77349>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77350>>>>>>>        End                                              
77350>>>>>>>>
77350>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77351>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
77352>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
77353>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
77354>>>>>>>        
77354>>>>>>>        // First check if theres an .sws file. If there is we will open it and
77354>>>>>>>        // read the name of the .ws file name.
77354>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
77355>>>>>>>        If (bExists = True) Begin
77357>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
77358>>>>>>>            If (iCh < 0) Begin
77360>>>>>>>                Function_Return asSWSFiles
77361>>>>>>>            End                                 
77361>>>>>>>>
77361>>>>>>>            
77361>>>>>>>            Repeat
77361>>>>>>>>
77361>>>>>>>                Readln channel iCh sFile
77363>>>>>>>                If (Trim(sFile) <> "") Begin
77365>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
77366>>>>>>>                End
77366>>>>>>>>
77366>>>>>>>            Until (SeqEof = True)
77368>>>>>>>            Send Seq_Close_Channel iCh    
77369>>>>>>>            
77369>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
77370>>>>>>>            If (iSize <> 0) Begin
77372>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
77373>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
77373>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
77373>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
77374>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
77375>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
77376>>>>>>>                If (sFile <> "") Begin
77378>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
77379>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
77380>>>>>>>                    File_Exist sFile bExists
77381>>>>>>>                    If (bExists = True) Begin
77383>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
77384>>>>>>>                    End
77384>>>>>>>>
77384>>>>>>>                End
77384>>>>>>>>
77384>>>>>>>                Send Destroy of hoIniFile
77385>>>>>>>            End
77385>>>>>>>>
77385>>>>>>>        End
77385>>>>>>>>
77385>>>>>>>        
77385>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
77385>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
77387>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
77388>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
77389>>>>>>>            If (bExists = False) Begin
77391>>>>>>>                Function_Return asWorkspaceFiles
77392>>>>>>>            End
77392>>>>>>>>
77392>>>>>>>        
77392>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
77393>>>>>>>            If (iCh < 0) Begin
77395>>>>>>>                Function_Return asWorkspaceFiles
77396>>>>>>>            End                                 
77396>>>>>>>>
77396>>>>>>>            
77396>>>>>>>            Repeat
77396>>>>>>>>
77396>>>>>>>                Readln channel iCh sFile
77398>>>>>>>                If (Trim(sFile) <> "") Begin
77400>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
77401>>>>>>>                End
77401>>>>>>>>
77401>>>>>>>            Until (SeqEof = True)
77403>>>>>>>            Send Seq_Close_Channel iCh
77404>>>>>>>        End
77404>>>>>>>>
77404>>>>>>>        
77404>>>>>>>        Function_Return asWorkspaceFiles
77405>>>>>>>    End_Function
77406>>>>>>>
77406>>>>>>>End_Class
77407>>>>>Use cDbUpdateDatabaseDriver.pkg
77407>>>>>Use vWin32fh.pkg
77407>>>>>
77407>>>>>// The cConnection class is the new SQL connections class for DF 19.
77407>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
77407>>>>>
77407>>>>>// We're making references to this object handle so we need it defined
77407>>>>>// here as well as for the cDbUpdateHandler class
77407>>>>>
77407>>>>>    Global_Variable Handle ghoSQLConnectionHandler
77407>>>>>    Move 0 to ghoSQLConnectionHandler
77408>>>>>
77408>>>>>Class cSQLConnectionHandler is a cObject
77409>>>>>
77409>>>>>    Procedure Construct_Object
77411>>>>>        Forward Send Construct_Object
77413>>>>>        Move Self to ghoSQLConnectionHandler
77414>>>>>
77414>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
77415>>>>>
77415>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
77415>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
77415>>>>>        // methods to this class.
77415>>>>>        Property Boolean pbUseConnectionID True
77416>>>>>        Property Boolean pbToANSI          True
77417>>>>>        Property Boolean pbRecnum          True
77418>>>>>        Property Boolean pbCopyData        True
77419>>>>>        Property Boolean pbApiTableUpdateAuto    False
77420>>>>>        Property Boolean pbCompareDate_DateTime  False
77421>>>>>        Property Boolean pbCompareIndexAscending False
77422>>>>>        Property Boolean pbCompareIndexUppercase False
77423>>>>>
77423>>>>>        // Driver default value settings:
77423>>>>>        // Note: When the object is created the corresponding values
77423>>>>>        // from the driver .int files are read.
77423>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
77423>>>>>        Property String psDriverDefaultValueASCII    ""
77424>>>>>        Property String psDriverDefaultValueBinary   ""
77425>>>>>        Property String psDriverDefaultValueDate     ""
77426>>>>>        Property String psDriverDefaultValueDateTime ""
77427>>>>>        Property String psDriverDefaultValueNumeric  ""
77428>>>>>        Property String psDriverDefaultValueText     ""
77429>>>>>
77429>>>>>        // Driver "nullability" settings:
77429>>>>>        // Note: When the object is created the corresponding values
77429>>>>>        // from the driver .int files are read.
77429>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
77429>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
77430>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
77431>>>>>        Property Boolean pbDriverDefaultNullableDate     False
77432>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
77433>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
77434>>>>>        Property Boolean pbDriverDefaultNullableText     False
77435>>>>>
77435>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
77435>>>>>        //     It is private because the get/set version also updates the DAW/Mertech
77435>>>>>        //     driver interfaces.
77435>>>>>        //     There are also procedure/function pairs to set/get individual data members
77435>>>>>        //     of the struct they are all routed throu this struct property.
77435>>>>>        Property tSQLConnection Private.pSQLConnection
77436>>>>>
77436>>>>>    End_Procedure
77437>>>>>
77437>>>>>    Procedure End_Construct_Object
77439>>>>>        tSQLConnection SQLConnection
77439>>>>>        tSQLConnection SQLConnection
77439>>>>>
77439>>>>>        Forward Send End_Construct_Object
77441>>>>>
77441>>>>>        // Now is the time to read and apply SQL connection settings.
77441>>>>>        Get SetupSQLConnection True True to SQLConnection
77442>>>>>        Set Private.pSQLConnection to SQLConnection
77443>>>>>    End_Procedure
77444>>>>>
77444>>>>>    // *** Properties ***
77444>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
77444>>>>>    // private.pSQLConnection struct connection property. These "properties" are
77444>>>>>    // merely here for conveniance.
77444>>>>>    //
77444>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
77444>>>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
77444>>>>>    // This struct property contains all the connection data.
77444>>>>>    //
77444>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
77446>>>>>        Boolean bOK
77446>>>>>
77446>>>>>        Set Private.pSQLConnection to SQLConnection
77447>>>>>
77447>>>>>        // When starting a program we might not have a connection id yet:
77447>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
77449>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
77449>>>>>            Procedure_Return
77450>>>>>        End
77450>>>>>>
77450>>>>>
77450>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
77450>>>>>        // be logged in already and don't want to do it again.
77450>>>>>        If (SQLConnection.bDAWConnection = False) Begin
77452>>>>>            // After we have set the class property we need to tell the DAW/Mertech
77452>>>>>            // driver interfaces about the change & make a new login.
77452>>>>>            Get SQLLogin SQLConnection to bOK
77453>>>>>            If (bOK = False) Begin
77455>>>>>                Error DFERR_PROGRAM "Login error."
77456>>>>>>
77456>>>>>            End
77456>>>>>>
77456>>>>>        End
77456>>>>>>
77456>>>>>
77456>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
77456>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
77457>>>>>
77457>>>>>    End_Procedure
77458>>>>>
77458>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
77458>>>>>    // attempt to load the driver.
77458>>>>>    // Returns true if the passed driver is SQL based.
77458>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
77460>>>>>        Boolean bOK
77460>>>>>
77460>>>>>        Get IsDAWSQLDriver sDriverID to bOK
77461>>>>>        If (bOK = False) Begin
77463>>>>>            Get IsMertechDriver sDriverID to bOK
77464>>>>>        End
77464>>>>>>
77464>>>>>
77464>>>>>        Function_Return bOK
77465>>>>>    End_Function
77466>>>>>
77466>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
77466>>>>>    Procedure SetupDriverDefaults String sDriverID
77468>>>>>        String sAttributeValue
77468>>>>>        Integer iDriverID
77468>>>>>        Boolean bNULL bSQLDriver bIsMertechDriver
77468>>>>>
77468>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
77469>>>>>        If (bSQLDriver = False) Begin
77471>>>>>            Procedure_Return
77472>>>>>        End                                      
77472>>>>>>
77472>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
77473>>>>>        If (bIsMertechDriver = True) Begin
77475>>>>>            Procedure_Return
77476>>>>>        End
77476>>>>>>
77476>>>>>        
77476>>>>>        Get DriverIndex sDriverID to iDriverID
77477>>>>>
77477>>>>>        // Driver default values for various data types:
77477>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
77480>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
77481>>>>>
77481>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
77484>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
77485>>>>>
77485>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
77488>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
77489>>>>>
77489>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
77492>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
77493>>>>>
77493>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
77496>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
77497>>>>>
77497>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
77500>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
77501>>>>>
77501>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
77501>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
77504>>>>>        Set pbDriverDefaultNullableASCII to bNULL
77505>>>>>
77505>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
77508>>>>>        Set pbDriverDefaultNullableBinary to bNULL
77509>>>>>
77509>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
77512>>>>>        Set pbDriverDefaultNullableDate to bNULL
77513>>>>>
77513>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
77516>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
77517>>>>>
77517>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
77520>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
77521>>>>>
77521>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
77524>>>>>        Set pbDriverDefaultNullableText to bNULL
77525>>>>>
77525>>>>>    End_Procedure
77526>>>>>
77526>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
77528>>>>>        Boolean bOK bIsDaw bIsMertech
77528>>>>>        String sConnectionString
77528>>>>>        Handle hoErrorObj hoDriver hoIniFile
77528>>>>>        Integer iDriverID
77528>>>>>
77528>>>>>        Move False to bOK
77529>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
77530>>>>>        If (bIsDaw = False) Begin
77532>>>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
77533>>>>>            If (bIsMertech = False) Begin
77535>>>>>                Function_Return False
77536>>>>>            End
77536>>>>>>
77536>>>>>        End
77536>>>>>>
77536>>>>>
77536>>>>>        Get phoSQLConnectionIniFile to hoIniFile
77537>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
77538>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
77539>>>>>        If (iDriverID = 0) Begin
77541>>>>>            Move hoErrorObj to Error_Object_Id
77542>>>>>            Function_Return False
77543>>>>>        End
77543>>>>>>
77543>>>>>
77543>>>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
77543>>>>>        If (bIsMertech = False) Begin
77545>>>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
77548>>>>>        End
77548>>>>>>
77548>>>>>
77548>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
77549>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
77550>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
77551>>>>>        Send Destroy   of hoDriver
77552>>>>>
77552>>>>>        Function_Return bOK
77553>>>>>    End_Function
77554>>>>>
77554>>>>>    Function pSQLConnection Returns tSQLConnection
77556>>>>>        tSQLConnection SQLConnection
77556>>>>>        tSQLConnection SQLConnection
77556>>>>>        Get Private.pSQLConnection to SQLConnection
77557>>>>>        Function_Return SQLConnection
77558>>>>>    End_Function
77559>>>>>
77559>>>>>    Procedure Set psConnectionID String sValue
77561>>>>>        tSQLConnection SQLConnection
77561>>>>>        tSQLConnection SQLConnection
77561>>>>>
77561>>>>>        Get Private.pSQLConnection to SQLConnection
77562>>>>>        If (SQLConnection.sConnectionID = "") Begin
77564>>>>>            Move sValue to SQLConnection.sConnectionID
77565>>>>>        End
77565>>>>>>
77565>>>>>
77565>>>>>        // Else we might want to change the current connection ID
77565>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
77568>>>>>            Move False to Err
77569>>>>>            Logout SQLConnection.sDriverID
77570>>>>>            // This will also make a login to the new server.
77570>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
77571>>>>>        End
77571>>>>>>
77571>>>>>        Set pSQLConnection to SQLConnection
77572>>>>>    End_Procedure
77573>>>>>
77573>>>>>    Function psConnectionID Returns String
77575>>>>>        tSQLConnection SQLConnection
77575>>>>>        tSQLConnection SQLConnection
77575>>>>>        Get Private.pSQLConnection to SQLConnection
77576>>>>>        Function_Return SQLConnection.sConnectionID
77577>>>>>    End_Function
77578>>>>>
77578>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
77578>>>>>    //       the psDriverID *must* be the first property that is changed!
77578>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
77578>>>>>    //       for a connection string has the wrong format for that driver.
77578>>>>>    Procedure Set psDriverID String sValue
77580>>>>>        tSQLConnection SQLConnection
77580>>>>>        tSQLConnection SQLConnection
77580>>>>>        Get pSQLConnection to SQLConnection
77581>>>>>        Move sValue        to SQLConnection.sDriverID
77582>>>>>        Set pSQLConnection to SQLConnection
77583>>>>>        If (sValue <> DATAFLEX_ID) Begin
77585>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77586>>>>>        End
77586>>>>>>
77586>>>>>    End_Procedure
77587>>>>>
77587>>>>>    Function psDriverID Returns String
77589>>>>>        tSQLConnection SQLConnection
77589>>>>>        tSQLConnection SQLConnection
77589>>>>>        Get Private.pSQLConnection to SQLConnection
77590>>>>>        If (SQLConnection.sDriverID = "") Begin
77592>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
77593>>>>>        End
77593>>>>>>
77593>>>>>        Function_Return SQLConnection.sDriverID
77594>>>>>    End_Function
77595>>>>>
77595>>>>>    Procedure Set psConnectionString String sValue
77597>>>>>        tSQLConnection SQLConnection
77597>>>>>        tSQLConnection SQLConnection
77597>>>>>        Get Private.pSQLConnection to SQLConnection
77598>>>>>        Move sValue        to SQLConnection.sConnectionString
77599>>>>>        Set pSQLConnection to SQLConnection
77600>>>>>    End_Procedure
77601>>>>>
77601>>>>>    Function psConnectionString Returns String
77603>>>>>        tSQLConnection SQLConnection
77603>>>>>        tSQLConnection SQLConnection
77603>>>>>        Get Private.pSQLConnection to SQLConnection
77604>>>>>        Function_Return SQLConnection.sConnectionString
77605>>>>>    End_Function
77606>>>>>
77606>>>>>    Procedure Set psServer String sValue
77608>>>>>        tSQLConnection SQLConnection
77608>>>>>        tSQLConnection SQLConnection
77608>>>>>        Get Private.pSQLConnection to SQLConnection
77609>>>>>        Move sValue        to SQLConnection.sServer
77610>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77611>>>>>        Set pSQLConnection to SQLConnection
77612>>>>>    End_Procedure
77613>>>>>
77613>>>>>    Function psServer Returns String
77615>>>>>        tSQLConnection SQLConnection
77615>>>>>        tSQLConnection SQLConnection
77615>>>>>        Get Private.pSQLConnection to SQLConnection
77616>>>>>        Function_Return SQLConnection.sServer
77617>>>>>    End_Function
77618>>>>>
77618>>>>>    Procedure Set psDatabase String sValue
77620>>>>>        tSQLConnection SQLConnection
77620>>>>>        tSQLConnection SQLConnection
77620>>>>>        Get Private.pSQLConnection to SQLConnection
77621>>>>>        Move sValue        to SQLConnection.sDatabase
77622>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77623>>>>>        Set pSQLConnection to SQLConnection
77624>>>>>    End_Procedure
77625>>>>>
77625>>>>>    Function psDatabase Returns String
77627>>>>>        tSQLConnection SQLConnection
77627>>>>>        tSQLConnection SQLConnection
77627>>>>>        Get Private.pSQLConnection to SQLConnection
77628>>>>>        Function_Return SQLConnection.sDatabase
77629>>>>>    End_Function
77630>>>>>
77630>>>>>    Procedure Set psUserID String sValue
77632>>>>>        tSQLConnection SQLConnection
77632>>>>>        tSQLConnection SQLConnection
77632>>>>>        Get Private.pSQLConnection to SQLConnection
77633>>>>>        Move sValue        to SQLConnection.sUserID
77634>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77635>>>>>        Set pSQLConnection to SQLConnection
77636>>>>>    End_Procedure
77637>>>>>
77637>>>>>    Function psUserID Returns String
77639>>>>>        tSQLConnection SQLConnection
77639>>>>>        tSQLConnection SQLConnection
77639>>>>>        Get Private.pSQLConnection to SQLConnection
77640>>>>>        Function_Return SQLConnection.sUserID
77641>>>>>    End_Function
77642>>>>>
77642>>>>>    // This is the uncrypted password
77642>>>>>    Procedure Set psPassword String sValue
77644>>>>>        tSQLConnection SQLConnection
77644>>>>>        tSQLConnection SQLConnection
77644>>>>>        Get Private.pSQLConnection to SQLConnection
77645>>>>>        Move sValue        to SQLConnection.sPassword
77646>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77647>>>>>        Set pSQLConnection to SQLConnection
77648>>>>>    End_Procedure
77649>>>>>
77649>>>>>    Function psPassword Returns String
77651>>>>>        tSQLConnection SQLConnection
77651>>>>>        tSQLConnection SQLConnection
77651>>>>>        Get Private.pSQLConnection to SQLConnection
77652>>>>>        Function_Return SQLConnection.sPassword
77653>>>>>    End_Function
77654>>>>>
77654>>>>>    Procedure Set pbTrusted Boolean bValue
77656>>>>>        tSQLConnection SQLConnection
77656>>>>>        tSQLConnection SQLConnection
77656>>>>>        Get Private.pSQLConnection to SQLConnection
77657>>>>>        Move bValue        to SQLConnection.bTrusted
77658>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77659>>>>>        Set pSQLConnection to SQLConnection
77660>>>>>    End_Procedure
77661>>>>>
77661>>>>>    Function pbTrusted Returns Boolean
77663>>>>>        tSQLConnection SQLConnection
77663>>>>>        tSQLConnection SQLConnection
77663>>>>>        Get Private.pSQLConnection to SQLConnection
77664>>>>>        Function_Return SQLConnection.bTrusted
77665>>>>>    End_Function
77666>>>>>
77666>>>>>    // *** All of these properties are special to the Database Update Framework ***
77666>>>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
77666>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
77666>>>>>    //     the central pSQLConnection "hub".
77666>>>>>    Procedure Set pbSilentLogin Boolean bValue
77668>>>>>        tSQLConnection SQLConnection
77668>>>>>        tSQLConnection SQLConnection
77668>>>>>        Get Private.pSQLConnection to SQLConnection
77669>>>>>        Move bValue to SQLConnection.bTrusted
77670>>>>>        Set Private.pSQLConnection to SQLConnection
77671>>>>>    End_Procedure
77672>>>>>
77672>>>>>    Function pbSilentLogin Returns Boolean
77674>>>>>        tSQLConnection SQLConnection
77674>>>>>        tSQLConnection SQLConnection
77674>>>>>        Get Private.pSQLConnection to SQLConnection
77675>>>>>        Function_Return SQLConnection.bSilentLogin
77676>>>>>    End_Function
77677>>>>>
77677>>>>>    Procedure Set piDbType Integer iValue
77679>>>>>        tSQLConnection SQLConnection
77679>>>>>        tSQLConnection SQLConnection
77679>>>>>        Get Private.pSQLConnection to SQLConnection
77680>>>>>        Move iValue to SQLConnection.iDbType
77681>>>>>        Set Private.pSQLConnection to SQLConnection
77682>>>>>    End_Procedure
77683>>>>>
77683>>>>>    Function piDbType Returns Integer
77685>>>>>        tSQLConnection SQLConnection
77685>>>>>        tSQLConnection SQLConnection
77685>>>>>        Get Private.pSQLConnection to SQLConnection
77686>>>>>        Function_Return SQLConnection.iDbType
77687>>>>>    End_Function
77688>>>>>
77688>>>>>    Procedure Set psBaseTableSpace String sValue
77690>>>>>        tSQLConnection SQLConnection
77690>>>>>        tSQLConnection SQLConnection
77690>>>>>        Get Private.pSQLConnection to SQLConnection
77691>>>>>        Move sValue to SQLConnection.sBaseTableSpace
77692>>>>>        Set Private.pSQLConnection to SQLConnection
77693>>>>>    End_Procedure
77694>>>>>
77694>>>>>    Function psBaseTableSpace Returns String
77696>>>>>        tSQLConnection SQLConnection
77696>>>>>        tSQLConnection SQLConnection
77696>>>>>        Get Private.pSQLConnection to SQLConnection
77697>>>>>        Function_Return SQLConnection.sBaseTableSpace
77698>>>>>    End_Function
77699>>>>>
77699>>>>>    Procedure Set psIndexTableSpace String sValue
77701>>>>>        tSQLConnection SQLConnection
77701>>>>>        tSQLConnection SQLConnection
77701>>>>>        Get Private.pSQLConnection to SQLConnection
77702>>>>>        Move sValue to SQLConnection.sIndexTableSpace
77703>>>>>        Set Private.pSQLConnection to SQLConnection
77704>>>>>    End_Procedure
77705>>>>>
77705>>>>>    Function psIndexTableSpace Returns String
77707>>>>>        tSQLConnection SQLConnection
77707>>>>>        tSQLConnection SQLConnection
77707>>>>>        Get Private.pSQLConnection to SQLConnection
77708>>>>>        Function_Return SQLConnection.sIndexTableSpace
77709>>>>>    End_Function
77710>>>>>
77710>>>>>    Procedure Set psLongTableSpace String sValue
77712>>>>>        tSQLConnection SQLConnection
77712>>>>>        tSQLConnection SQLConnection
77712>>>>>        Get Private.pSQLConnection to SQLConnection
77713>>>>>        Move sValue to SQLConnection.sLongTableSpace
77714>>>>>        Set Private.pSQLConnection to SQLConnection
77715>>>>>    End_Procedure
77716>>>>>
77716>>>>>    Function psLongTableSpace Returns String
77718>>>>>        tSQLConnection SQLConnection
77718>>>>>        tSQLConnection SQLConnection
77718>>>>>        Get Private.pSQLConnection to SQLConnection
77719>>>>>        Function_Return SQLConnection.sLongTableSpace
77720>>>>>    End_Function
77721>>>>>
77721>>>>>    Procedure Set psSchema String sValue
77723>>>>>        tSQLConnection SQLConnection
77723>>>>>        tSQLConnection SQLConnection
77723>>>>>        Get Private.pSQLConnection to SQLConnection
77724>>>>>        Move sValue to SQLConnection.sSchema
77725>>>>>        Set Private.pSQLConnection to SQLConnection
77726>>>>>    End_Procedure
77727>>>>>
77727>>>>>    Function psSchema Returns String
77729>>>>>        tSQLConnection SQLConnection
77729>>>>>        tSQLConnection SQLConnection
77729>>>>>        Get Private.pSQLConnection to SQLConnection
77730>>>>>        Function_Return SQLConnection.sSchema
77731>>>>>    End_Function
77732>>>>>
77732>>>>>    Procedure Set pbEnabled Boolean bValue
77734>>>>>        tSQLConnection SQLConnection
77734>>>>>        tSQLConnection SQLConnection
77734>>>>>        Get Private.pSQLConnection to SQLConnection
77735>>>>>        Move bValue to SQLConnection.bEnabled
77736>>>>>        Set Private.pSQLConnection to SQLConnection
77737>>>>>    End_Procedure
77738>>>>>
77738>>>>>    Function pbEnabled Returns Boolean
77740>>>>>        tSQLConnection SQLConnection
77740>>>>>        tSQLConnection SQLConnection
77740>>>>>        Get Private.pSQLConnection to SQLConnection
77741>>>>>        Function_Return SQLConnection.bEnabled
77742>>>>>    End_Function
77743>>>>>
77743>>>>>
77743>>>>>    // ************************************
77743>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
77745>>>>>        tSQLConnection SQLConnection
77745>>>>>        tSQLConnection SQLConnection
77745>>>>>
77745>>>>>        // If this object was created by the cDbUpdateHandler class we will
77745>>>>>        // deferr reading SQL connection values until later.
77745>>>>>        If (bReadDFConnSettings = True) Begin
77747>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
77747>>>>>            If (ghoConnection > 0) Begin
77749>>>>>                Get ReadcConnections to SQLConnection
77750>>>>>            End
77750>>>>>>
77750>>>>>
77750>>>>>            // In addition to the above; there might be other values set even if a cConnection
77750>>>>>            // object is used.
77750>>>>>            If (bReadSQLConnections = True) Begin
77752>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
77753>>>>>            End
77753>>>>>>
77753>>>>>        End
77753>>>>>>
77753>>>>>
77753>>>>>        Function_Return SQLConnection
77754>>>>>    End_Function
77755>>>>>
77755>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
77755>>>>>    Function ReadcConnections Returns tSQLConnection
77757>>>>>        tConnection Connection
77757>>>>>        tConnection Connection
77757>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
77757>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
77757>>>>>        Integer iRetval iDbType
77757>>>>>        Boolean bOK bConnected
77757>>>>>        String sConnectionID
77757>>>>>
77757>>>>>            tConnection[] Connections
77757>>>>>            tConnection[] Connections
77758>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
77758>>>>>            // - and there are multiple connection id's defined for the same driver. This is
77758>>>>>            //   because otherwise we can't possibly know which connection id to use... So
77758>>>>>            //   we then generate an error and abort the program...
77758>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
77759>>>>>            If (bOK = False) Begin
77761>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
77762>>>>>>
77762>>>>>                Abort
77763>>>>>>
77763>>>>>            End
77763>>>>>>
77763>>>>>            If (sConnectionID = "") Begin
77765>>>>>                Get ConnectionIDs of ghoConnection to Connections
77766>>>>>                If (SizeOfArray(Connections) > 0) Begin
77768>>>>>                    Move Connections[0].sId to sConnectionID
77769>>>>>                End
77769>>>>>>
77769>>>>>            End
77769>>>>>>
77769>>>>>
77769>>>>>            Move 0 to iRetval
77770>>>>>            // DAW DF19 connection info:
77770>>>>>            // We first check that the connection is OK:
77770>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
77771>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
77771>>>>>            If (iRetval = -1) Begin
77773>>>>>                Function_Return SQLConnectionEmpty
77774>>>>>            End
77774>>>>>>
77774>>>>>
77774>>>>>            If (sConnectionID <> "") Begin
77776>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
77777>>>>>            End
77777>>>>>>
77777>>>>>            If (Connection.sId = "") Begin
77779>>>>>                Move True to SQLConnectionEmpty.bError
77780>>>>>                Function_Return SQLConnectionEmpty
77781>>>>>            End
77781>>>>>>
77781>>>>>
77781>>>>>            // DUF connection info struct property:
77781>>>>>            Get Private.pSQLConnection                       to SQLConnection
77782>>>>>
77782>>>>>            Move Connection.sId to sConnectionID
77783>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
77784>>>>>
77784>>>>>            If (bConnected = False) Begin
77786>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
77787>>>>>                If (iRetval <> 0) Begin
77789>>>>>                    Send UserError CS_DUF_CannotLoginToServer
77790>>>>>                    Send Exit_Application
77791>>>>>                End
77791>>>>>>
77791>>>>>                Move True                                   to SQLConnection.bDAWConnection
77792>>>>>                // We need to get the DAW connection info again as it might have
77792>>>>>                // been changed in the DAW db login dialog.
77792>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
77793>>>>>            End
77793>>>>>>
77793>>>>>
77793>>>>>            Move True                                        to SQLConnection.bEnabled
77794>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
77795>>>>>
77795>>>>>            // Not used in DUF:
77795>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
77795>>>>>
77795>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
77796>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
77797>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
77798>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
77799>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
77800>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
77801>>>>>
77801>>>>>            // Not used in DUF:
77801>>>>>            // Move Connection.sSection to SQLConnection.xxx
77801>>>>>
77801>>>>>            // The rest of the properties of the SQLConnection struct should have been
77801>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
77801>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
77803>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
77804>>>>>            End
77804>>>>>>
77804>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
77806>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
77807>>>>>                If (SQLConnection.sServer = "") Begin
77809>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
77810>>>>>                End
77810>>>>>>
77810>>>>>            End
77810>>>>>>
77810>>>>>
77810>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
77811>>>>>
77811>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
77811>>>>>            // the value from the driver id:
77811>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
77812>>>>>            // ...but in case it has been explicitly set in the object we use that value.
77812>>>>>            Get piDbType                                     to iDbType
77813>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
77815>>>>>                Move iDbType to SQLConnection.iDbType
77816>>>>>            End
77816>>>>>>
77816>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
77817>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
77818>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
77819>>>>>            Get psSchema                                     to SQLConnection.sSchema
77820>>>>>
77820>>>>>            // We finally set the struct property to the newly fetched values.
77820>>>>>            Set pSQLConnection to SQLConnection
77821>>>>>
77821>>>>>        Function_Return SQLConnection
77822>>>>>    End_Function
77823>>>>>
77823>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
77823>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
77823>>>>>    // connection id for a particular driver.
77823>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
77823>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
77823>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
77823>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
77823>>>>>    // connections of the DAW cConnect class.
77823>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
77825>>>>>        tConnection[] ConnIdArray
77825>>>>>        tConnection[] ConnIdArray
77826>>>>>        Integer iCount iSize iConnectionIDCounter
77826>>>>>        Boolean bEnabled bFound
77826>>>>>        String sConnectionID2 sDriverID sDriverConn
77826>>>>>
77826>>>>>        Move False to bFound
77827>>>>>        If (ghoConnection > 0) Begin
77829>>>>>
77829>>>>>            // The property of the cDbUpdateHandler container object
77829>>>>>            Get psDriverID to sDriverID
77830>>>>>
77830>>>>>            Move 0 to iConnectionIDCounter
77831>>>>>            // This is the the DAW cConnect array with all registered connection id's.
77831>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
77832>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
77833>>>>>            Decrement iSize
77834>>>>>            For iCount from 0 to iSize
77840>>>>>>
77840>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
77841>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
77842>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
77843>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
77843>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
77843>>>>>                If (sConnectionID = "") Begin
77845>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
77846>>>>>                End
77846>>>>>>
77846>>>>>                Else Begin
77847>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
77849>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
77850>>>>>                    End
77850>>>>>>
77850>>>>>                End
77850>>>>>>
77850>>>>>
77850>>>>>                If (bFound = True) Begin
77852>>>>>                    Increment iConnectionIDCounter
77853>>>>>                End
77853>>>>>>
77853>>>>>            Loop
77854>>>>>>
77854>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
77855>>>>>            If (bFound = True) Begin
77857>>>>>                Move sConnectionID2 to sConnectionID
77858>>>>>            End
77858>>>>>>
77858>>>>>        End
77858>>>>>>
77858>>>>>
77858>>>>>        // Special case; a cConnection object has been setup in the cApplication,
77858>>>>>        // but no DFConn.ini record has been created.
77858>>>>>        If (iSize = -1) Begin
77860>>>>>            Move True to bFound
77861>>>>>        End
77861>>>>>>
77861>>>>>
77861>>>>>        Function_Return bFound
77862>>>>>    End_Function
77863>>>>>
77863>>>>>    // Send on object creation to read the default connection string settings, and
77863>>>>>    // create a connection to the server.
77863>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
77865>>>>>        String sPath sFileName
77865>>>>>        Boolean bExists bActive
77865>>>>>        tSQLConnection[] SQLConnectionArray
77865>>>>>        tSQLConnection[] SQLConnectionArray
77866>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
77866>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
77866>>>>>        Handle hoIniFile
77866>>>>>        Integer iSize iCount iRetval
77866>>>>>
77866>>>>>        Get psIniFilePath to sPath
77867>>>>>        Get phoSQLConnectionIniFile to hoIniFile
77868>>>>>        If (sPath = "") Begin
77870>>>>>            Get ApplicationPath of hoIniFile to sPath
77871>>>>>            Set psIniFilePath   of hoIniFile to sPath
77872>>>>>        End
77872>>>>>>
77872>>>>>        Get vFolderFormat sPath to sPath
77873>>>>>        Get psIniFileName to sFileName
77874>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
77875>>>>>
77875>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
77876>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
77877>>>>>        If (iSize = 0) Begin
77879>>>>>            // This may have been set by the "ReadcConnections" function,
77879>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
77879>>>>>            // in the cApplication object.
77879>>>>>            Get pSQLConnection to SQLConnection
77880>>>>>            If (SQLConnection.sConnectionID = "") Begin
77882>>>>>                Function_Return SQLConnectionEmpty
77883>>>>>            End
77883>>>>>>
77883>>>>>            Move SQLConnection to SQLConnectionArray[0] 
77884>>>>>            Move 1 to iSize
77885>>>>>        End
77885>>>>>>
77885>>>>>
77885>>>>>        Move False to bActive
77886>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
77886>>>>>        Decrement iSize
77887>>>>>        For iCount from 0 to iSize
77893>>>>>>
77893>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
77894>>>>>            If (SQLConnection.bEnabled = True) Begin
77896>>>>>                Move True to bActive
77897>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
77898>>>>>            End
77898>>>>>>
77898>>>>>        Loop
77899>>>>>>
77899>>>>>
77899>>>>>        // In case all connections have been disabled, we're out of here.
77899>>>>>        If (bActive = False) Begin
77901>>>>>            Function_Return SQLConnectionEmpty
77902>>>>>        End
77902>>>>>>
77902>>>>>
77902>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
77903>>>>>
77903>>>>>        Set pSQLConnection to SQLConnection
77904>>>>>        Get AutoSetConnectionID to iRetval
77905>>>>>
77905>>>>>        Function_Return SQLConnection
77906>>>>>    End_Function
77907>>>>>
77907>>>>>    Procedure Set psIniFilePath String sPath
77909>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
77910>>>>>    End_Procedure
77911>>>>>
77911>>>>>    Function psIniFilePath Returns String
77913>>>>>        String sRetval
77913>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
77914>>>>>        Function_Return sRetval
77915>>>>>    End_Function
77916>>>>>
77916>>>>>    Procedure Set psIniFileName String sFileName
77918>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
77919>>>>>    End_Procedure
77920>>>>>
77920>>>>>    Function psIniFileName Returns String
77922>>>>>        String sRetval
77922>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
77923>>>>>        Function_Return sRetval
77924>>>>>    End_Function
77925>>>>>
77925>>>>>    Procedure Set psIniSectionName String sSection
77927>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
77928>>>>>    End_Procedure
77929>>>>>
77929>>>>>    Function psIniSectionName Returns String
77931>>>>>        String sRetval
77931>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
77932>>>>>        Function_Return sRetval
77933>>>>>    End_Function
77934>>>>>
77934>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
77936>>>>>        Handle ho
77936>>>>>        Get phoSQLConnectionIniFile to ho
77937>>>>>        Set IniFileValue of ho to sSection sValueName sValue
77938>>>>>    End_Procedure
77939>>>>>
77939>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
77941>>>>>        Handle ho
77941>>>>>        String sRetval
77941>>>>>        Get phoSQLConnectionIniFile to ho
77942>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
77943>>>>>        Function_Return sRetval
77944>>>>>    End_Function
77945>>>>>
77945>>>>>    Function SectionExists String sSection Returns Boolean
77947>>>>>        Handle ho
77947>>>>>        Boolean bRetval
77947>>>>>        Get phoSQLConnectionIniFile to ho
77948>>>>>        Get SectionExists of ho sSection to bRetval
77949>>>>>        Function_Return bRetval
77950>>>>>    End_Function
77951>>>>>
77951>>>>>    Function KeyExists String sSection String sKey Returns Boolean
77953>>>>>        Handle ho
77953>>>>>        Boolean bRetval
77953>>>>>        Get phoSQLConnectionIniFile to ho
77954>>>>>        Get KeyExists of ho sSection sKey to bRetval
77955>>>>>        Function_Return bRetval
77956>>>>>    End_Function
77957>>>>>
77957>>>>>    Function EncryptPassword String sPassword Returns String
77959>>>>>        Handle ho
77959>>>>>        String sRetval
77959>>>>>        Get phoSQLConnectionIniFile to ho
77960>>>>>        Get EncryptPassword of ho sPassword to sRetval
77961>>>>>        Function_Return sRetval
77962>>>>>    End_Function
77963>>>>>
77963>>>>>    Function DecryptPassword String sPassword Returns String
77965>>>>>        Handle ho
77965>>>>>        String sRetval
77965>>>>>        Get phoSQLConnectionIniFile to ho
77966>>>>>        Get DecryptPassword of ho sPassword to sRetval
77967>>>>>        Function_Return sRetval
77968>>>>>    End_Function
77969>>>>>
77969>>>>>    // *** Main Connection Message ***
77969>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
77971>>>>>        Handle hoDriver
77971>>>>>        String sConnectionString sError
77971>>>>>        Boolean bLoginSuccessful
77971>>>>>
77971>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
77972>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
77973>>>>>        Set psDriverID of hoDriver to sDriverID
77974>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
77975>>>>>        If (bLoginSuccessful = False) Begin
77977>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
77978>>>>>>
77978>>>>>            If (bExitProgram = True) Begin
77980>>>>>                Send Exit_Application
77981>>>>>            End
77981>>>>>>
77981>>>>>        End
77981>>>>>>
77981>>>>>        Send Destroy of hoDriver
77982>>>>>    End_Procedure
77983>>>>>
77983>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
77985>>>>>        Integer iRetval
77985>>>>>        Handle hoCLI
77985>>>>>        String sDriverID
77985>>>>>
77985>>>>>        Get psDriverID to sDriverID
77986>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
77987>>>>>        If (hoCLI <> 0) Begin
77989>>>>>            Set psDriverID of hoCLI to sDriverID
77990>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
77991>>>>>            Send Destroy of hoCLI
77992>>>>>        End
77992>>>>>>
77992>>>>>
77992>>>>>        Function_Return iRetval
77993>>>>>    End_Function
77994>>>>>
77994>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
77996>>>>>        tSQLConnection SQLConnection
77996>>>>>        tSQLConnection SQLConnection
77996>>>>>
77996>>>>>        Set psDriverID to sDriverID
77997>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
77998>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
77999>>>>>    End_Procedure
78000>>>>>
78000>>>>>    // This is needed when e.g. the connection id we have specified in the program code
78000>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
78000>>>>>    // or the one in the DataFlex Bin folder.)
78000>>>>>    // We then need to delete the current one before creating a new one.
78000>>>>>    // This is because the parameters may differ between the program code and the
78000>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
78000>>>>>    // when one tries to create a Connection ID that already exists.
78000>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
78002>>>>>        Integer iResult iDriver iNumConn iConn
78002>>>>>        Handle hoCLI
78002>>>>>        String sID
78002>>>>>
78002>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
78004>>>>>            Procedure_Return
78005>>>>>        End
78005>>>>>>
78005>>>>>
78005>>>>>        Move 0 to iResult
78006>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78007>>>>>        If (hoCLI <> 0) Begin
78009>>>>>            Set psDriverID of hoCLI to sDriverID
78010>>>>>            Get DriverIndex sDriverID to iDriver
78011>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78014>>>>>            Decrement iNumConn
78015>>>>>            For iConn from 0 to iNumConn
78021>>>>>>
78021>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78024>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78026>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
78027>>>>>                End
78027>>>>>>
78027>>>>>            Loop
78028>>>>>>
78028>>>>>            Send Destroy of hoCLI
78029>>>>>        End
78029>>>>>>
78029>>>>>
78029>>>>>    End_Procedure
78030>>>>>
78030>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
78032>>>>>        Integer iResult iDriver iNumConn iConn
78032>>>>>        Handle hoCLI
78032>>>>>        String sID sConnectionString sVal sDatabase
78032>>>>>        tSQLConnection SQLConnection
78032>>>>>        tSQLConnection SQLConnection
78032>>>>>        Boolean bTrusted
78032>>>>>
78032>>>>>        Move 0 to iResult
78033>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78034>>>>>        If (hoCLI <> 0) Begin
78036>>>>>            Set psDriverID of hoCLI to sDriverID
78037>>>>>            Get DriverIndex sDriverID to iDriver
78038>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78041>>>>>            Decrement iNumConn
78042>>>>>            For iConn from 0 to iNumConn
78048>>>>>>
78048>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78051>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78053>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
78054>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
78057>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
78060>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
78061>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
78064>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
78065>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
78066>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
78067>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
78068>>>>>
78068>>>>>                    Case Begin
78068>>>>>                        Case (sDriverID = MSSQLDRV_ID)
78070>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
78071>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
78072>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
78073>>>>>                            Case Break
78074>>>>>                        Case (sDriverID = DB2_DRV_ID)
78077>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78078>>>>>                            Case Break
78079>>>>>                        Case (sDriverID = ODBC_DRV_ID)
78082>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78083>>>>>                            If (SQLConnection.sServer = "") Begin
78085>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78086>>>>>                            End
78086>>>>>>
78086>>>>>                            Case Break
78087>>>>>                        Case (sDriverID = SQLFLEX)
78090>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78091>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
78092>>>>>                            If (SQLConnection.bTrusted = True) Begin
78094>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
78095>>>>>                            End
78095>>>>>>
78095>>>>>                            Else Begin
78096>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
78097>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
78098>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
78099>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
78100>>>>>                            End
78100>>>>>>
78100>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
78101>>>>>                            Case Break
78102>>>>>                        Case (sDriverID = MDSMySQL)
78105>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78106>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
78107>>>>>                            If (SQLConnection.bTrusted = True) Begin
78109>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
78110>>>>>                            End
78110>>>>>>
78110>>>>>                            Else Begin
78111>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
78112>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
78113>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
78114>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
78115>>>>>                            End
78115>>>>>>
78115>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
78116>>>>>                            Case Break
78117>>>>>                        Case (sDriverID = MDSPgSQL)
78120>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78121>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
78122>>>>>                            If (SQLConnection.bTrusted = True) Begin
78124>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
78125>>>>>                            End
78125>>>>>>
78125>>>>>                            Else Begin
78126>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
78127>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
78128>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
78129>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
78130>>>>>                            End
78130>>>>>>
78130>>>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
78131>>>>>                            Case Break
78132>>>>>
78132>>>>>                        Case (sDriverID = ORAFLEX)
78135>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
78136>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
78137>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78138>>>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
78140>>>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
78141>>>>>                            End
78141>>>>>>
78141>>>>>                            If (SQLConnection.bTrusted = True) Begin
78143>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
78144>>>>>                            End
78144>>>>>>
78144>>>>>                            Else Begin
78145>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
78146>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
78147>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
78148>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
78149>>>>>                            End
78149>>>>>>
78149>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
78150>>>>>                            Case Break
78151>>>>>                        Case Else
78151>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
78152>>>>>>
78152>>>>>                            Case Break
78153>>>>>                    Case End
78153>>>>>                End
78153>>>>>>
78153>>>>>            Loop
78154>>>>>>
78154>>>>>            Send Destroy of hoCLI
78155>>>>>        End
78155>>>>>>
78155>>>>>
78155>>>>>        Function_Return SQLConnection
78156>>>>>    End_Function
78157>>>>>
78157>>>>>    Function DriverIndex String sDriverID Returns Integer
78159>>>>>        String  sCurrentDriver
78159>>>>>        Integer iNumberOfDrivers iDriver iCount
78159>>>>>
78159>>>>>        Move 0 to iDriver
78160>>>>>        Move 0 to iCount
78161>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78164>>>>>        For iCount from 1 to iNumberOfDrivers
78170>>>>>>
78170>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
78173>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
78175>>>>>                Function_Return iCount
78176>>>>>            End
78176>>>>>>
78176>>>>>        Loop
78177>>>>>>
78177>>>>>
78177>>>>>        // If driver not previously loaded; attempt to do so now.
78177>>>>>        If (iDriver = 0) Begin
78179>>>>>            Move 0 to LastErr
78180>>>>>            Load_Driver sDriverID
78181>>>>>            // If driver could not be loaded.
78181>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
78183>>>>>                Move -1 to iCount
78184>>>>>            End
78184>>>>>>
78184>>>>>        End
78184>>>>>>
78184>>>>>        Function_Return iCount
78185>>>>>    End_Function
78186>>>>>
78186>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
78186>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
78188>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
78188>>>>>        Boolean bTrusted bSilent
78188>>>>>        Integer iRetval
78188>>>>>
78188>>>>>        Move SQLConnection.sDriverID     to sDriverID
78189>>>>>        Move SQLConnection.sConnectionID to sConnectionID
78190>>>>>        Move SQLConnection.sServer       to sServer
78191>>>>>        Move SQLConnection.sDatabase     to sDatabase
78192>>>>>        Move SQLConnection.bTrusted      to bTrusted
78193>>>>>        Move SQLConnection.sUserID       to sUserID
78194>>>>>        Move SQLConnection.sPassword     to sPassword
78195>>>>>        Move SQLConnection.bSilentLogin  to bSilent
78196>>>>>
78196>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
78197>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
78197>>>>>        Get AutoSetConnectionID to iRetval
78198>>>>>    End_Procedure
78199>>>>>
78199>>>>>    // Called when the object is constructed.
78199>>>>>    // It will check the psDriverID for a ConnectionID and save it
78199>>>>>    // as psConnectionID property. It is later used whenever a login to
78199>>>>>    // the database is needed.
78199>>>>>    Function AutoSetConnectionID Returns Boolean
78201>>>>>        String sConnectionID sDriverID sConnectionString
78201>>>>>        Integer iDriver iRetval
78201>>>>>        Handle hoCLI
78201>>>>>        Boolean bOK bSilent bMertechDriver
78201>>>>>
78201>>>>>        Get pbSilentLogin      to bSilent
78202>>>>>        Get psConnectionID     to sConnectionID
78203>>>>>        Get psConnectionString to sConnectionString
78204>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
78204>>>>>        Get psDriverID to sDriverID
78205>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78206>>>>>        If (bOK = False) Begin
78208>>>>>            Function_Return False
78209>>>>>        End
78209>>>>>>
78209>>>>>
78209>>>>>        // Mertech drivers can't use connection ID's.
78209>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
78210>>>>>        If (bMertechDriver = True) Begin
78212>>>>>            // This ensures that the correct Server & Database attributes are set both for
78212>>>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
78212>>>>>            Get _MertechSQLManagerHandle to hoCLI
78213>>>>>            Function_Return (hoCLI <> 0)
78214>>>>>        End
78214>>>>>>
78214>>>>>
78214>>>>>        Get DriverIndex sDriverID          to iDriver
78215>>>>>        // If driver not loaded; load it.
78215>>>>>        If (iDriver = 0) Begin
78217>>>>>            Load_Driver sDriverID
78218>>>>>            Get DriverIndex sDriverID      to iDriver
78219>>>>>        End
78219>>>>>>
78219>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
78219>>>>>        If (iDriver = 0) Begin
78221>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
78222>>>>>>
78222>>>>>            Function_Return False
78223>>>>>        End           
78223>>>>>>
78223>>>>>        Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
78226>>>>>        
78226>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78227>>>>>        Set psDriverID of hoCLI            to sDriverID
78228>>>>>        // Delete the connection first; in case it exists
78228>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
78229>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
78230>>>>>        Send Destroy of hoCLI
78231>>>>>
78231>>>>>        Function_Return (iRetval = 0)
78232>>>>>    End_Function
78233>>>>>
78233>>>>>    // Returns the handle of the Mertech SQL handler.
78233>>>>>    // It also ensures that the correct Server & Database attributes are set both for
78233>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
78233>>>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
78233>>>>>    //       So the return value is of no use! But we don't need the handle for this class.
78233>>>>>    Function _MertechSQLManagerHandle Returns Handle
78235>>>>>        Handle hoSQLHandler
78235>>>>>        String sDriverID sServer sDatabase
78235>>>>>
78235>>>>>        Move 0 to hoSQLHandler
78236>>>>>        Get psDriverID to sDriverID
78237>>>>>        Get psServer   to sServer
78238>>>>>        Get psDatabase to sDatabase
78239>>>>>
78239>>>>>        Function_Return hoSQLHandler
78240>>>>>    End_Function
78241>>>>>
78241>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
78243>>>>>        Boolean bOK bMertechDriver
78243>>>>>
78243>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78244>>>>>
78244>>>>>        If (bOK = False) Begin
78246>>>>>            Get IsMertechDriver sDriverID to bOK
78247>>>>>        End
78247>>>>>>
78247>>>>>
78247>>>>>        If (bOK = False) Begin
78249>>>>>            Get IsMertechDriver sDriverID to bMertechDriver
78250>>>>>            If (bMertechDriver = True) Begin
78252>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
78253>>>>>>
78253>>>>>            End
78253>>>>>>
78253>>>>>            Else Begin
78254>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
78255>>>>>>
78255>>>>>            End
78255>>>>>>
78255>>>>>            Function_Return False
78256>>>>>        End
78256>>>>>>
78256>>>>>
78256>>>>>        Function_Return True
78257>>>>>    End_Function
78258>>>>>
78258>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78260>>>>>        Boolean bOK
78260>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
78261>>>>>        Function_Return bOK
78262>>>>>    End_Function
78263>>>>>
78263>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
78265>>>>>        Boolean bOK
78265>>>>>        Move False to bOK
78266>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
78266>>>>>            Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMYSQL) to bOK
78267>>>>>//        #ENDIF
78267>>>>>        Function_Return bOK
78268>>>>>    End_Function
78269>>>>>
78269>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78271>>>>>        Handle hoIniFile
78271>>>>>        String sConnect
78271>>>>>
78271>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78272>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
78273>>>>>
78273>>>>>        Function_Return sConnect
78274>>>>>    End_Function
78275>>>>>
78275>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
78275>>>>>    // Pass a complete driver connection string
78275>>>>>    // Returns the following as a struct:
78275>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
78275>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
78275>>>>>    //
78275>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
78277>>>>>        tSQLConnection SQLConnection
78277>>>>>        tSQLConnection SQLConnection
78277>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
78277>>>>>        Boolean bTrusted bSilent bOK
78277>>>>>        Integer iPos
78277>>>>>
78277>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78278>>>>>        If (bOK = False) Begin
78280>>>>>            Function_Return SQLConnection
78281>>>>>        End
78281>>>>>>
78281>>>>>
78281>>>>>        Move False to bTrusted
78282>>>>>        Move False to bSilent
78283>>>>>
78283>>>>>        Case Begin
78283>>>>>            Case (sDriverID = MSSQLDRV_ID)
78285>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78286>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78287>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78288>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78289>>>>>                If (bTrusted = False) Begin
78291>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78292>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78293>>>>>                End
78293>>>>>>
78293>>>>>                Case Break
78294>>>>>
78294>>>>>            Case (sDriverID = ODBC_DRV_ID)
78297>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
78299>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
78300>>>>>                End
78300>>>>>>
78300>>>>>                Else Begin
78301>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78302>>>>>                End
78302>>>>>>
78302>>>>>
78302>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78303>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78304>>>>>                If (bTrusted = False) Begin
78306>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78307>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78308>>>>>                End
78308>>>>>>
78308>>>>>                Case Break
78309>>>>>
78309>>>>>            Case (sDriverID = DB2_DRV_ID)
78312>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78313>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78314>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78315>>>>>                Case Break
78316>>>>>
78316>>>>>            Case (sDriverID = SQLFLEX)
78319>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78320>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78321>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78322>>>>>                If (bTrusted = False) Begin
78324>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78325>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78326>>>>>                End
78326>>>>>>
78326>>>>>                Case Break
78327>>>>>
78327>>>>>            Case (sDriverID = ORAFLEX)
78330>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78331>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78332>>>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
78334>>>>>                    Move (sServer + "/" + sDatabase)                                to sServer
78335>>>>>                End
78335>>>>>>
78335>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78336>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78337>>>>>                Case Break
78338>>>>>
78338>>>>>            Case (sDriverID = MDSPgSQL)
78341>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78342>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78343>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78344>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78345>>>>>                Case Break
78346>>>>>
78346>>>>>            Case (sDriverID = MDSMySQL)
78349>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78350>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78351>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78352>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78353>>>>>                Case Break
78354>>>>>
78354>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78357>>>>>                Break
78358>>>>>        Case End
78358>>>>>
78358>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
78359>>>>>
78359>>>>>        // bSilent?
78359>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
78360>>>>>        If (iPos = 0) Begin
78362>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
78363>>>>>        End
78363>>>>>>
78363>>>>>        If (iPos = 0) Begin
78365>>>>>            Move "0"                                                            to sValue
78366>>>>>        End
78366>>>>>>
78366>>>>>        Else Begin
78367>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
78368>>>>>        End
78368>>>>>>
78368>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
78369>>>>>
78369>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
78370>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
78371>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
78372>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
78373>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
78374>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
78375>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
78376>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
78377>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
78378>>>>>
78378>>>>>        Function_Return SQLConnection
78379>>>>>    End_Function
78380>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\ParseKeyWord.pkg)
78380>>>>>>
78380>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78382>>>>>>    Integer iStart iEnd
78382>>>>>>    String sRetval
78382>>>>>>
78382>>>>>>    Move (Trim(sConnect)) to sConnect
78383>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78384>>>>>>    If (iStart = 0) Begin
78386>>>>>>        Function_Return ""
78387>>>>>>    End
78387>>>>>>>
78387>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78388>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78389>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78391>>>>>>        Move (Pos(",", sRetval))          to iEnd
78392>>>>>>    End
78392>>>>>>>
78392>>>>>>    Else Begin
78393>>>>>>        Move (Pos(";", sRetval))          to iEnd
78394>>>>>>    End
78394>>>>>>>
78394>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78396>>>>>>        Move (Pos(",", sRetval))          to iEnd
78397>>>>>>        Decrement iEnd
78398>>>>>>    End
78398>>>>>>>
78398>>>>>>    If (iEnd <> 0) Begin
78400>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78401>>>>>>    End
78401>>>>>>>
78401>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78402>>>>>>
78402>>>>>>    Function_Return (Trim(sRetval))
78403>>>>>>End_Function
78404>>>>>>
78404>>>>>>
78404>>>>>
78404>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
78404>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78406>>>>>        Handle ho
78406>>>>>        Integer iIndex
78406>>>>>        Boolean bRetval bOK
78406>>>>>        tSQLConnection SQLConnection
78406>>>>>        tSQLConnection SQLConnection
78406>>>>>
78406>>>>>        Get pSQLConnection to SQLConnection
78407>>>>>        Get phoSQLConnectionIniFile to ho
78408>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
78409>>>>>        If (iIndex = -1) Begin
78411>>>>>            Function_Return False
78412>>>>>        End
78412>>>>>>
78412>>>>>
78412>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
78413>>>>>        Send UpdateConnectionString SQLConnection
78414>>>>>        If (ghoConnection > 0) Begin
78416>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
78417>>>>>            If (iIndex <> -1) Begin
78419>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
78420>>>>>            End
78420>>>>>>
78420>>>>>        End
78420>>>>>>
78420>>>>>
78420>>>>>        Function_Return bRetval
78421>>>>>    End_Function
78422>>>>>
78422>>>>>End_Class
78423>>>Use vWin32fh.pkg
78423>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\Libraries\DFAbout\DfAbout.pkg)
78423>>>>>Use LanguageText.pkg
78423>>>>>Use Windows.pkg
78423>>>>>Use Dfclient.pkg
78423>>>>>Use DFbitmap.pkg
78423>>>>>Use GlobalFunctionsProcedures.pkg
78423>>>>>Use cRichEdit.pkg
78423>>>>>Use cTextEdit.pkg
78423>>>>>Use cRichEdit.pkg
78423>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 20.1\Pkg\gFormatNumbers.pkg)
78423>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cFormatter.pkg)
78423>>>>>>>>>Use VDFBase.pkg
78423>>>>>>>>>
78423>>>>>>>>>Class cFormatter is an cObject
78424>>>>>>>>>    
78424>>>>>>>>>    Procedure Construct_object
78426>>>>>>>>>        Integer iCh
78426>>>>>>>>>        Forward Send construct_object
78428>>>>>>>>>        Property String  psCurrencySymbol
78429>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
78430>>>>>>>>>        
78430>>>>>>>>>        Property String  psLeft
78431>>>>>>>>>        Property String  psright
78432>>>>>>>>>        Property Integer pbThousandsSep
78433>>>>>>>>>        Property Integer piPoints
78434>>>>>>>>>        
78434>>>>>>>>>        Property String  psCurPosLeft
78435>>>>>>>>>        Property String  psCurPosright
78436>>>>>>>>>        Property Integer pbCurPosThousandsSep
78437>>>>>>>>>        Property Integer piCurPosPoints
78438>>>>>>>>>        
78438>>>>>>>>>        Property String  psCurNegLeft
78439>>>>>>>>>        Property String  psCurNegright
78440>>>>>>>>>        Property Integer pbCurNegThousandsSep
78441>>>>>>>>>        Property Integer piCurNegPoints
78442>>>>>>>>>        
78442>>>>>>>>>        Property String  psNumPosLeft
78443>>>>>>>>>        Property String  psNumPosright
78444>>>>>>>>>        Property Integer pbNumPosThousandsSep
78445>>>>>>>>>        Property Integer piNumPosPoints
78446>>>>>>>>>        
78446>>>>>>>>>        Property String  psNumNegLeft
78447>>>>>>>>>        Property String  psNumNegright
78448>>>>>>>>>        Property Integer pbNumNegThousandsSep
78449>>>>>>>>>        Property Integer piNumNegPoints
78450>>>>>>>>>        
78450>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
78451>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
78452>>>>>>>>>        
78452>>>>>>>>>    End_Procedure
78453>>>>>>>>>    
78453>>>>>>>>>    // internal
78453>>>>>>>>>    // parse passed format string and set temporary properties with result
78453>>>>>>>>>    Procedure ParseFormat String sFmt
78455>>>>>>>>>        
78455>>>>>>>>>        String sLeft sRight sDigit
78455>>>>>>>>>        Integer bSep iPos i iDigits
78455>>>>>>>>>        
78455>>>>>>>>>        // replace any literals. A "/" followed by anything.
78455>>>>>>>>>        // some literals are special. $ . , / #
78455>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
78456>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
78457>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
78458>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
78459>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
78460>>>>>>>>>        Move (Character(9)) to sDigit
78461>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
78462>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
78463>>>>>>>>>        
78463>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
78464>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
78467>>>>>>>>>        
78467>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
78468>>>>>>>>>        
78468>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
78469>>>>>>>>>        
78469>>>>>>>>>        // Move all the special literals back into place before parsing
78469>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
78470>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
78471>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
78472>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
78473>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
78474>>>>>>>>>        
78474>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
78476>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
78477>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
78479>>>>>>>>>                Move -2 to iDigits
78480>>>>>>>>>                Increment i
78481>>>>>>>>>            End
78481>>>>>>>>>>
78481>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
78485>>>>>>>>>                Increment i
78486>>>>>>>>>            Loop
78487>>>>>>>>>>
78487>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
78488>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
78491>>>>>>>>>            //
78491>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
78492>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
78496>>>>>>>>>                Increment i
78497>>>>>>>>>            Loop
78498>>>>>>>>>>
78498>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
78499>>>>>>>>>        End
78499>>>>>>>>>>
78499>>>>>>>>>        Else Begin                             // we have no decinal
78500>>>>>>>>>            Move 0 to iDigits                  // so points is none
78501>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
78502>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
78504>>>>>>>>>                Move sFmt to sLeft
78505>>>>>>>>>                Move ""   to sRight
78506>>>>>>>>>            End
78506>>>>>>>>>>
78506>>>>>>>>>            Else Begin
78507>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
78508>>>>>>>>>                Move 1 to i
78509>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
78513>>>>>>>>>                    Increment i
78514>>>>>>>>>                Loop
78515>>>>>>>>>>
78515>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
78516>>>>>>>>>            End
78516>>>>>>>>>>
78516>>>>>>>>>        End
78516>>>>>>>>>>
78516>>>>>>>>>        // set temporary format properties and exit
78516>>>>>>>>>        Set pbThousandsSep to bSep
78517>>>>>>>>>        Set psLeft         to sLeft
78518>>>>>>>>>        Set psRight        to sRight
78519>>>>>>>>>        Set piPoints       to iDigits
78520>>>>>>>>>    End_Procedure
78521>>>>>>>>>    
78521>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
78521>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
78521>>>>>>>>>    //
78521>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
78521>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
78523>>>>>>>>>        String sPos sNeg
78523>>>>>>>>>        Integer iPos
78523>>>>>>>>>        
78523>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78524>>>>>>>>>        If iPos Begin
78526>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
78527>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
78528>>>>>>>>>        End
78528>>>>>>>>>>
78528>>>>>>>>>        Else Begin
78529>>>>>>>>>            Move sFmt         to sPos
78530>>>>>>>>>            Move ("-" + sFmt) to sNeg
78531>>>>>>>>>        End
78531>>>>>>>>>>
78531>>>>>>>>>        Send ParseFormat sPos
78532>>>>>>>>>        If bCurrency Begin
78534>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
78535>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
78536>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
78537>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
78538>>>>>>>>>        End
78538>>>>>>>>>>
78538>>>>>>>>>        Else Begin
78539>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
78540>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
78541>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
78542>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
78543>>>>>>>>>        End
78543>>>>>>>>>>
78543>>>>>>>>>        
78543>>>>>>>>>        Send ParseFormat sNeg
78544>>>>>>>>>        If bCurrency Begin
78546>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
78547>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
78548>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
78549>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
78550>>>>>>>>>        End
78550>>>>>>>>>>
78550>>>>>>>>>        Else Begin
78551>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
78552>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
78553>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
78554>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
78555>>>>>>>>>        End
78555>>>>>>>>>>
78555>>>>>>>>>    End_Procedure
78556>>>>>>>>>    
78556>>>>>>>>>    // low level formatting. Pass parameters
78556>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
78558>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
78558>>>>>>>>>        Integer bIsNegative iDec iLen iCh
78558>>>>>>>>>        
78558>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
78561>>>>>>>>>        Move (Character(iCh)) to sDec
78562>>>>>>>>>        
78562>>>>>>>>>        Move (abs(nNumber)) to sNumber
78563>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
78564>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
78565>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
78566>>>>>>>>>        // format for decimal separator
78566>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
78569>>>>>>>>>        
78569>>>>>>>>>        // format for thousand sep.
78569>>>>>>>>>        If bSep Begin
78571>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
78574>>>>>>>>>            Move (Character(iCh)) to sSep
78575>>>>>>>>>            Move (Length(sLeft)) to iLen
78576>>>>>>>>>            While (iLen>3)
78580>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
78581>>>>>>>>>                Move (iLen-3) to iLen
78582>>>>>>>>>            Loop
78583>>>>>>>>>>
78583>>>>>>>>>        End
78583>>>>>>>>>>
78583>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
78583>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
78586>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
78587>>>>>>>>>    End_Function
78588>>>>>>>>>    
78588>>>>>>>>>    // Public: Format for currency
78588>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
78590>>>>>>>>>        String  sLeft sRight
78590>>>>>>>>>        Integer bSep
78590>>>>>>>>>        If (nNumber<0) Begin
78592>>>>>>>>>            Get pbCurNegThousandsSep to bSep
78593>>>>>>>>>            Get psCurNegLeft         to sLeft
78594>>>>>>>>>            Get psCurNegRight        to sRight
78595>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
78598>>>>>>>>>        End
78598>>>>>>>>>>
78598>>>>>>>>>        Else Begin
78599>>>>>>>>>            Get pbCurPosThousandsSep to bSep
78600>>>>>>>>>            Get psCurPosLeft         to sLeft
78601>>>>>>>>>            Get psCurPosRight        to sRight
78602>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
78605>>>>>>>>>        End
78605>>>>>>>>>>
78605>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78606>>>>>>>>>    End_Function
78607>>>>>>>>>    
78607>>>>>>>>>    // Public: Format for numeric
78607>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
78609>>>>>>>>>        String  sLeft sRight
78609>>>>>>>>>        Integer bSep
78609>>>>>>>>>        If (nNumber<0) Begin
78611>>>>>>>>>            Get pbNumNegThousandsSep to bSep
78612>>>>>>>>>            Get psNumNegLeft         to sLeft
78613>>>>>>>>>            Get psNumNegRight        to sRight
78614>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
78617>>>>>>>>>        End
78617>>>>>>>>>>
78617>>>>>>>>>        Else Begin
78618>>>>>>>>>            Get pbNumPosThousandsSep to bSep
78619>>>>>>>>>            Get psNumPosLeft         to sLeft
78620>>>>>>>>>            Get psNumPosRight        to sRight
78621>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
78624>>>>>>>>>        End
78624>>>>>>>>>>
78624>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78625>>>>>>>>>    End_Function
78626>>>>>>>>>    
78626>>>>>>>>>    
78626>>>>>>>>>    // Public: Format passing format string
78626>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
78628>>>>>>>>>        Integer iPos bIsNeg
78628>>>>>>>>>        String  sLeft sRight
78628>>>>>>>>>        Integer iPoints bSep
78628>>>>>>>>>        Move (nNumber<0) to bIsNeg
78629>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78630>>>>>>>>>        Case Begin
78630>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
78633>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
78637>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
78641>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
78643>>>>>>>>>        Case End
78643>>>>>>>>>        Send ParseFormat sFmt
78644>>>>>>>>>        Get pbThousandsSep to bSep
78645>>>>>>>>>        Get psLeft         to sLeft
78646>>>>>>>>>        Get psRight        to sRight
78647>>>>>>>>>        Get piPoints       to iPoints
78648>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78649>>>>>>>>>    End_Function
78650>>>>>>>>>    
78650>>>>>>>>>End_Class
78651>>>>>>>
78651>>>>>>>Global_Variable Handle ghoFormatter
78651>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
78652>>>>>>>
78652>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
78654>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
78655>>>>>>>End_Function
78656>>>>>>>
78656>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
78658>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
78659>>>>>>>End_Function
78660>>>>>>>
78660>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
78662>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
78663>>>>>>>End_Function
78664>>>>>>>
78664>>>>>>>Procedure SetCurrencyFormat Global String sFmt
78666>>>>>>>    Send SetFormat of ghoFormatter sFmt True
78667>>>>>>>End_Procedure
78668>>>>>>>
78668>>>>>>>Procedure SetNumberFormat Global String sFmt
78670>>>>>>>    Send SetFormat of ghoFormatter sFmt False
78671>>>>>>>End_Procedure
78672>>>>>>>
78672>>>>>>>
78672>>>>>Use tWinStructs.pkg
78672>>>>>
78672>>>>>Use cli.pkg
78672>>>>>Use DFBTRDRV.PKG
78672>>>>>Use MSSqldrv.pkg
78672>>>>>Use db2_drv.pkg
78672>>>>>Use odbc_drv.pkg
78672>>>>>Use seq_chnl.pkg
78672>>>>>
78672>>>>>Register_Function phoWorkspace Returns Handle
78672>>>>>Register_Function Help_filename Returns String
78672>>>>>Register_Function GetHelpFile Returns String
78672>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
78672>>>>>
78672>>>>>// Use of Mertech drivers:
78672>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
78672>>>>>
78672>>>>>
78672>>>>>
78672>>>>>
78672>>>>>
78672>>>>>// *** Constant Declarations: ***
78672>>>>>//
78672>>>>>
78672>>>>>
78672>>>>>
78672>>>>>
78672>>>>>
78672>>>>>
78672>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
78672>>>>>
78672>>>>>
78672>>>>>
78672>>>>>
78672>>>>>
78672>>>>>
78672>>>>>
78672>>>>>
78672>>>>>
78672>>>>>// System icon menu constants. If the upper left hand
78672>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
78672>>>>>    Define SC_RESTORE  for |CI$F120
78672>>>>>    Define SC_MOVE     for |CI$F010
78672>>>>>    Define SC_SIZE     for |CI$F000
78672>>>>>    Define SC_MINIMIZE for |CI$F020
78672>>>>>    Define SC_MAXIMIZE for |CI$F030
78672>>>>>    Define SC_CLOSE    for |CI$F060
78672>>>>>    Define SC_KEYMENU  for |CI$F100
78672>>>>>    Define SC_NEXTWINDOW for |CI$F040
78672>>>>>    Define SC_PREVWINDOW for |CI$F050
78672>>>>>
78672>>>>>Define CS_SignProgram        for "signtool.exe"
78672>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
78672>>>>>Define CS_VerifyCredentials  for "verify"
78672>>>>>Define CS_VerifyFileParam    for "/a"
78672>>>>>Define CS_DefAuthVerPolicy   for "/pa"
78672>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
78672>>>>>
78672>>>>>// *** Struct Declarations: ***
78672>>>>>
78672>>>>>Struct AboutSHELLEXECUTEINFO
78672>>>>>    DWord   cbSize
78672>>>>>    Integer fMask
78672>>>>>    Handle  hwnd
78672>>>>>    Pointer lpVerb
78672>>>>>    Pointer lpFile
78672>>>>>    Pointer lpParameters
78672>>>>>    Pointer lpDirectory
78672>>>>>    Integer nShow
78672>>>>>    Pointer hInstApp
78672>>>>>    Pointer lpIDList
78672>>>>>    Pointer lpClass
78672>>>>>    Handle  hkeyClass
78672>>>>>    DWord   dwHotKey
78672>>>>>    Handle  hIconMonitor // Union
78672>>>>>    //Handle  hMonitor     // Union
78672>>>>>    Handle  hProcess
78672>>>>>End_Struct
78672>>>>>
78672>>>>>
78672>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
78672>>>>>//Type MEMORYSTATUS
78672>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
78672>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
78672>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
78672>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
78672>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
78672>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
78672>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
78672>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
78672>>>>>//End_Type
78672>>>>>
78672>>>>>// *** External Function calls: ***
78672>>>>>//
78672>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
78673>>>>>
78673>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
78674>>>>>
78674>>>>>// Do not call directly, use the wrapper function instead
78674>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
78675>>>>>
78675>>>>>    // Wrapper Function WNetGetUser
78675>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
78677>>>>>
78677>>>>>        DWord   dwResult
78677>>>>>        UWide   uwName uwUserName
78677>>>>>        UWide   uwName uwUserName
78677>>>>>
78677>>>>>        Send StringToWide lpName (&uwName)
78678>>>>>
78678>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
78679>>>>>
78679>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
78680>>>>>
78680>>>>>        Send WideToString (&uwUserName) lpUser_Name
78681>>>>>
78681>>>>>        Function_Return dwResult
78682>>>>>    End_Function
78683>>>>>
78683>>>>>
78683>>>>>
78683>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
78684>>>>>
78684>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
78685>>>>>
78685>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
78686>>>>>
78686>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
78687>>>>>
78687>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
78688>>>>>
78688>>>>>// *** Global/Desktop Function Declarations: ***
78688>>>>>
78688>>>>>Function ComputerName Desktop Returns String
78690>>>>>    String sName
78690>>>>>    Get_Environment "COMPUTERNAME" to sName
78691>>>>>>
78691>>>>>    Function_Return sName
78692>>>>>End_Function
78693>>>>>
78693>>>>>Function Network_User_Name Desktop Returns String
78695>>>>>    WString wName
78695>>>>>    Integer iRetval iLength
78695>>>>>
78695>>>>>    Move 0 to iLength
78696>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
78697>>>>>    Move (ZeroString(iLength)) to wName
78698>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
78699>>>>>
78699>>>>>    If (iRetval = NO_ERROR) Begin
78701>>>>>        Function_Return (CString (wName))
78702>>>>>    End
78702>>>>>>
78702>>>>>
78702>>>>>    Function_Return "User Unknown"
78703>>>>>End_Function
78704>>>>>
78704>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
78706>>>>>    String sClient sDriver sClientDriver
78706>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
78706>>>>>    Handle hoMsqlDrv
78706>>>>>
78706>>>>>    Move 0 to iDriver
78707>>>>>    Move "" to sClient
78708>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78711>>>>>    For iCount from 1 to iNumberOfDrivers
78717>>>>>>
78717>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
78720>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
78722>>>>>            Move iCount to iDriver
78723>>>>>            Move iNumberOfDrivers to iCount // We're done.
78724>>>>>        End
78724>>>>>>
78724>>>>>    Loop
78725>>>>>>
78725>>>>>
78725>>>>>    // This info is (at current) only available for the MS SQL driver:
78725>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
78727>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
78730>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
78731>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
78732>>>>>        Send Destroy of hoMsqlDrv
78733>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
78734>>>>>    End
78734>>>>>>
78734>>>>>
78734>>>>>    Function_Return sClient
78735>>>>>End_Function
78736>>>>>
78736>>>>>// *** Class Declarations: ***
78736>>>>>//
78736>>>>>Class cBitmapContainerDFLink is a BitmapContainer
78737>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
78739>>>>>        Send Mouse_Up iWindowNumber iPosition
78740>>>>>    End_Procedure
78741>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
78743>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
78745>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
78746>>>>>    End_Procedure
78747>>>>>End_Class
78748>>>>>
78748>>>>>Class cCopyEditorContentButton is a Button
78749>>>>>    Procedure Construct_Object
78751>>>>>        Forward Send Construct_Object
78753>>>>>        Property Handle phoEditorHandle
78754>>>>>        Set psToolTip to C_$DescCopy
78755>>>>>    End_Procedure
78756>>>>>
78756>>>>>    Procedure CopyToWindowsClipboard
78758>>>>>        Handle hoEditor
78758>>>>>        Boolean bCanCopy
78758>>>>>        Address aEditorAddress
78758>>>>>
78758>>>>>        Get phoEditorHandle to hoEditor
78759>>>>>        Send Select_All of hoEditor
78760>>>>>        Get CanCopy of hoEditor to bCanCopy
78761>>>>>        If (bCanCopy = True) Begin
78763>>>>>            Get paValue of hoEditor to aEditorAddress
78764>>>>>            Send Copy   of hoEditor
78765>>>>>            // Remove the selection after text is copied to the clipboard.
78765>>>>>            Send Beginning_of_Data of hoEditor
78766>>>>>            Send Info_Box C_$CopyToClipboard_Text
78767>>>>>        End
78767>>>>>>
78767>>>>>    End_Procedure
78768>>>>>End_Class
78769>>>>>
78769>>>>>Class SysinfoDisplay is a cTextEdit
78770>>>>>    Procedure Construct_Object
78772>>>>>        Forward Send Construct_Object
78774>>>>>
78774>>>>>        Set Size to 100 245
78775>>>>>        Set Location to 6 6
78776>>>>>        Set Border_Style to Border_None
78777>>>>>        Set Read_Only_State to True
78778>>>>>        Set pbWrap to True
78779>>>>>        Set peAnchors to anAll
78780>>>>>    End_Procedure
78781>>>>>
78781>>>>>    // Augmented class message to adjust certain text strings that are wrong...
78781>>>>>
78781>>>>>    Procedure AppendTextLn String sText
78783>>>>>        String sWorkspaceWSFile
78783>>>>>
78783>>>>>        // Only works for English:
78783>>>>>        If (ghoApplication > 0) Begin
78785>>>>>            If (sText contains "Workspace Name") Begin
78787>>>>>                Move "Workspace Config Filename:" to sText
78788>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
78789>>>>>                Move (sText * sWorkspaceWSFile) to sText
78790>>>>>            End
78790>>>>>>
78790>>>>>        End
78790>>>>>>
78790>>>>>        Send AppendText sText
78791>>>>>        Send AppendText (character(10))
78792>>>>>    End_Procedure
78793>>>>>
78793>>>>>    //    This method will show the name Of the current directory in the system
78793>>>>>    //    information box
78793>>>>>    Procedure Show_Current_Directory
78795>>>>>        String sDir
78795>>>>>
78795>>>>>        Get_Current_Directory To sDir
78796>>>>>
78796>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
78797>>>>>    End_Procedure
78798>>>>>
78798>>>>>    Procedure Show_Windows_Directory
78800>>>>>        String sWindir
78800>>>>>
78800>>>>>        Get_Windows_Directory To sWindir
78801>>>>>
78801>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
78802>>>>>    End_Procedure
78803>>>>>
78803>>>>>    Procedure Show_Current_User
78805>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
78806>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
78807>>>>>    End_Procedure
78808>>>>>
78808>>>>>    Procedure Show_Number_Format
78810>>>>>        Integer iFormat
78810>>>>>        String sFormatText
78810>>>>>
78810>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
78813>>>>>        Move (Character (iFormat)) To sFormatText
78814>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
78815>>>>>
78815>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
78818>>>>>        Move (Character (iFormat)) to sFormatText
78819>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
78820>>>>>    End_Procedure
78821>>>>>
78821>>>>>    Procedure Show_Filelist_Name
78823>>>>>        String sFilename
78823>>>>>
78823>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
78826>>>>>
78826>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
78827>>>>>    End_Procedure
78828>>>>>
78828>>>>>    Procedure Show_Lock_Delay
78830>>>>>        Integer iLockdelay
78830>>>>>
78830>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
78833>>>>>
78833>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
78834>>>>>    End_Procedure
78835>>>>>
78835>>>>>    Procedure Show_Lock_Timeout
78837>>>>>        Integer iLockTimeout
78837>>>>>
78837>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
78840>>>>>
78840>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
78841>>>>>    End_Procedure
78842>>>>>
78842>>>>>    Procedure Show_Screen_Size
78844>>>>>        Integer iYscreensize iXscreensize
78844>>>>>
78844>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
78845>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
78846>>>>>
78846>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
78847>>>>>    End_Procedure
78848>>>>>
78848>>>>>    Procedure Show_Page_Size
78850>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
78851>>>>>    End_procedure
78852>>>>>
78852>>>>>    Procedure Show_Date
78854>>>>>        Date dToday
78854>>>>>
78854>>>>>        Move (CurrentDateTime()) to dToday
78855>>>>>
78855>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
78856>>>>>    End_procedure
78857>>>>>
78857>>>>>    Procedure Show_Date_Format
78859>>>>>        Integer iDateFormat
78859>>>>>        String sDateFormat
78859>>>>>
78859>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
78862>>>>>        Case Begin
78862>>>>>            Case (iDateFormat = DF_DATE_USA)
78864>>>>>                Move C_$USA To sDateFormat
78865>>>>>                Case Break
78866>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
78869>>>>>                Move C_$European To sDateFormat
78870>>>>>                Case Break
78871>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
78874>>>>>                Move C_$Military To sDateFormat
78875>>>>>                Case Break
78876>>>>>            Case Else
78876>>>>>                Move C_$UnknownDateType To sDateFormat
78877>>>>>                Case Break
78878>>>>>        Case End
78878>>>>>
78878>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
78879>>>>>    End_Procedure
78880>>>>>
78880>>>>>    // 2013-08-14 NGS
78880>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
78880>>>>>    Procedure Show_Systemresources
78882>>>>>        tWinMemoryStatusEx MemoryStatusInfo
78882>>>>>        tWinMemoryStatusEx MemoryStatusInfo
78882>>>>>        Integer iRetval
78882>>>>>        Number nValue
78882>>>>>        String sValue
78882>>>>>
78882>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
78883>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
78884>>>>>        If (iRetval = 0) Begin
78886>>>>>            Move (ShowLastError ()) to iRetval
78887>>>>>            Procedure_Return
78888>>>>>        End
78888>>>>>>
78888>>>>>
78888>>>>>        Send AppendTextLn ""
78889>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
78890>>>>>
78890>>>>>        // Show memory in Gigabytes:
78890>>>>>        Move (nValue/1024/1024/1024) to nValue
78891>>>>>        Move (Round(nValue)) to nValue
78892>>>>>        Get FormatNumber nValue 2 to sValue
78893>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
78894>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
78895>>>>>
78895>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
78895>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
78896>>>>>        Move (Round(nValue)) to nValue
78897>>>>>        Get FormatNumber nValue 0 to sValue
78898>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
78899>>>>>
78899>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
78899>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
78900>>>>>        Move (Round(nValue)) to nValue
78901>>>>>        Get FormatNumber nValue 0 to sValue
78902>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
78903>>>>>
78903>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
78903>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
78904>>>>>        Move (Round(nValue)) to nValue
78905>>>>>        Get FormatNumber nValue 0 to sValue
78906>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
78907>>>>>
78907>>>>>        // Add an empty row after the memory information:
78907>>>>>        Send AppendTextLn ""
78908>>>>>    End_Procedure
78909>>>>>
78909>>>>>    Procedure Show_Registration
78911>>>>>        String sRegName
78911>>>>>        Integer iSN iUsersMax iUserCount
78911>>>>>
78911>>>>>        Registration sRegName iSN
78912>>>>>>
78912>>>>>        Get_Licensed_Max_Users to iUsersMax
78913>>>>>        Get_Current_User_Count to iUserCount
78914>>>>>
78914>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
78915>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
78916>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
78917>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
78918>>>>>    End_Procedure
78919>>>>>
78919>>>>>    //****************************************************************************
78919>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
78919>>>>>    // To the workspace object passing the an object and message To send back
78919>>>>>    // To this object. It is expected that the workspace object will send this
78919>>>>>    // message for every line Of information it wants displayed (passing the
78919>>>>>    // information To be displayed
78919>>>>>    //****************************************************************************
78919>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
78919>>>>>
78919>>>>>    Procedure Show_ServicePack
78921>>>>>        String sKey sVersion sDataFlex
78921>>>>>        Handle hoRegistry
78921>>>>>        Boolean bExists bOpened
78921>>>>>
78921>>>>>        Move "DataFlex"        to sDataFlex
78922>>>>>
78922>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
78923>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
78924>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
78925>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
78926>>>>>
78926>>>>>        If (bExists) Begin
78928>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
78929>>>>>        End
78929>>>>>>
78929>>>>>        Else Begin
78930>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
78931>>>>>        End
78931>>>>>>
78931>>>>>        Get KeyExists of hoRegistry sKey to bExists
78932>>>>>        If (bExists) Begin
78934>>>>>            Get OpenKey of hoRegistry sKey to bOpened
78935>>>>>            If (bOpened) Begin
78937>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
78938>>>>>                If (bExists) Begin
78940>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
78941>>>>>                End
78941>>>>>>
78941>>>>>                Send CloseKey of hoRegistry
78942>>>>>            End
78942>>>>>>
78942>>>>>        End
78942>>>>>>
78942>>>>>        Send Destroy of hoRegistry
78943>>>>>
78943>>>>>        If (sVersion <> "") Begin
78945>>>>>           Send AppendTextLn sVersion
78946>>>>>           Send AppendTextLn ""
78947>>>>>        End
78947>>>>>>
78947>>>>>    End_Procedure
78948>>>>>
78948>>>>>    Procedure Show_WorkspaceInformation
78950>>>>>        Integer hoWorkspace
78950>>>>>
78950>>>>>        If (ghoApplication <> 0) Begin
78952>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
78953>>>>>            If (hoWorkspace <> 0) Begin
78955>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
78956>>>>>            End
78956>>>>>>
78956>>>>>        End
78956>>>>>>
78956>>>>>    End_Procedure
78957>>>>>
78957>>>>>    //****************************************************************************
78957>>>>>    // If connection ids are used, we will send the message EnumerateConnections
78957>>>>>    // to the connection manager object passing the an object and message to send
78957>>>>>    // back to this object. It is expected that the connection manager object will
78957>>>>>    // send this message for every line Of information it wants displayed (passing
78957>>>>>    // the information To be displayed
78957>>>>>    //****************************************************************************
78957>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
78957>>>>>
78957>>>>>    Procedure Show_ConnectionIdInformation
78959>>>>>        If (ghoConnection > 0) Begin
78961>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
78962>>>>>            Send AppendTextLn ""
78963>>>>>        End
78963>>>>>>
78963>>>>>    End_Procedure
78964>>>>>
78964>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
78966>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
78967>>>>>    End_Function
78968>>>>>
78968>>>>>    Procedure Show_Versions
78970>>>>>        Integer iVersion iRevision iBuild
78970>>>>>
78970>>>>>        Version_information iVersion iRevision iBuild
78972>>>>>
78972>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
78973>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
78974>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
78975>>>>>        Send AppendTextLn "This is a 32-bit exe file"
78976>>>>>    End_Procedure
78977>>>>>
78977>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78979>>>>>        Boolean bOK
78979>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
78980>>>>>        Function_Return bOK
78981>>>>>    End_Function
78982>>>>>
78982>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
78984>>>>>        Boolean bOK
78984>>>>>        Function_Return bOK
78985>>>>>    End_Function
78986>>>>>
78986>>>>>    //***
78986>>>>>    //*** BW
78986>>>>>    //*** Procedure: Show_Drivers
78986>>>>>    //*** Purpose  : Show loaded database drivers
78986>>>>>    //***
78986>>>>>
78986>>>>>    Procedure Show_Drivers
78988>>>>>        String sDriverID sVersion sClient sValue
78988>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
78988>>>>>        Handle hoCLIHandler hoBtrvHandler
78988>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
78988>>>>>
78988>>>>>        Move False to bStudioLicense
78989>>>>>
78989>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
78990>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
78991>>>>>
78991>>>>>        // For testing purposes:
78991>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
78991>>>>>//        Load_Driver MSSQLDRV_ID
78991>>>>>//        Load_Driver ODBC_DRV_ID
78991>>>>>//        Load_Driver DB2_DRV_ID
78991>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
78991>>>>>//
78991>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
78991>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
78991>>>>>//            Load_Driver SQLFLEX
78991>>>>>//            Load_Driver MDSPgSQL
78991>>>>>//            Load_Driver MDSMySQL
78991>>>>>//            Load_Driver ORAFLEX
78991>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
78991>>>>>//        #ENDIF
78991>>>>>        Move False to Err
78992>>>>>
78992>>>>>        // Loop through all loaded drivers.
78992>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78995>>>>>        If (iNumberOfDrivers > 1) Begin
78997>>>>>            Send AppendTextLn ""
78998>>>>>        End
78998>>>>>>
78998>>>>>        For iDriver from 1 to iNumberOfDrivers
79004>>>>>>
79004>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
79004>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
79004>>>>>            // would be thrown, so we safeguard from that here.
79004>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79005>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
79008>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79009>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
79010>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
79011>>>>>
79011>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
79013>>>>>
79013>>>>>                // Pervasive/Btrieve database
79013>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
79015>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
79016>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
79017>>>>>                    If (sClient <> "0.0.0") Begin
79019>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
79020>>>>>                    End
79020>>>>>>
79020>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
79021>>>>>                    If (sClient <> "0.0.0") Begin
79023>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
79024>>>>>                    End
79024>>>>>>
79024>>>>>                End
79024>>>>>>
79024>>>>>
79024>>>>>                Else Begin
79025>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
79026>>>>>                    Move 0 to iNumServers
79027>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
79029>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
79032>>>>>                    End
79032>>>>>>
79032>>>>>
79032>>>>>                    If (bIsDAWDriver = True) Begin
79034>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
79036>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
79037>>>>>                        End
79037>>>>>>
79037>>>>>                        Get CKRevision of hoCLIHandler to sVersion
79038>>>>>                    End
79038>>>>>>
79038>>>>>
79038>>>>>                    If (bIsMertechDriver = True) Begin
79040>>>>>                    End
79040>>>>>>
79040>>>>>
79040>>>>>                    // If the serialnumber is = 0, it means that the
79040>>>>>                    // Studio licens is in use and there is no
79040>>>>>                    // number of max users defined because the driver is
79040>>>>>                    // relying on the info from the VDF license.
79040>>>>>                    If (bStudioLicense = False) Begin
79042>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
79043>>>>>                        Move (iSerialNo = 0) to bStudioLicense
79044>>>>>                    End
79044>>>>>>
79044>>>>>                End
79044>>>>>>
79044>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
79045>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
79047>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
79048>>>>>                End
79048>>>>>>
79048>>>>>                If (iNumServers <> 0) Begin
79050>>>>>                    For iCount from 1 to iNumServers
79056>>>>>>
79056>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
79059>>>>>                        If (not(sValue contains ";PWD=")) Begin
79061>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
79062>>>>>                        End
79062>>>>>>
79062>>>>>                    Loop
79063>>>>>>
79063>>>>>                End
79063>>>>>>
79063>>>>>            End
79063>>>>>>
79063>>>>>        Loop
79064>>>>>>
79064>>>>>
79064>>>>>        Send AppendTextLn ""
79065>>>>>        If (bStudioLicense = False) Begin
79067>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
79068>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
79069>>>>>        End
79069>>>>>>
79069>>>>>        Else Begin
79070>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
79071>>>>>        End
79071>>>>>>
79071>>>>>        Send Destroy of hoCLIHandler
79072>>>>>        Send Destroy of hoBtrvHandler
79073>>>>>    End_Procedure
79074>>>>>
79074>>>>>    Procedure Show_HelpFile
79076>>>>>        String sHelpFile
79076>>>>>        Integer eHelpType
79076>>>>>
79076>>>>>        If (ghoApplication <> 0) Begin
79078>>>>>            Get peHelpType Of ghoApplication To eHelpType
79079>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
79081>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
79082>>>>>            End
79082>>>>>>
79082>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
79085>>>>>                Get Help_filename Of Help_object_id To sHelpFile
79086>>>>>            End
79086>>>>>>
79086>>>>>            Else Begin
79087>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
79088>>>>>            End
79088>>>>>>
79088>>>>>
79088>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
79089>>>>>        End
79089>>>>>>
79089>>>>>    End_Procedure
79090>>>>>
79090>>>>>    Procedure Show_EnterAsTab
79092>>>>>        Boolean bEnterKeyAsTabKey
79092>>>>>        String sText
79092>>>>>
79092>>>>>        If (ghoApplication <> 0) Begin
79094>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
79095>>>>>            If (bEnterKeyAsTabKey) Begin
79097>>>>>                Move "True" To sText
79098>>>>>            End
79098>>>>>>
79098>>>>>            Else Begin
79099>>>>>                Move "False" To sText
79100>>>>>            End
79100>>>>>>
79100>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
79101>>>>>        End
79101>>>>>>
79101>>>>>    End_Procedure
79102>>>>>
79102>>>>>    //    During activation we will remove the old information and add the newly
79102>>>>>    //    found systeminformation
79102>>>>>    Procedure Add_Focus Integer hoRoot
79104>>>>>        Forward Send Add_Focus hoRoot
79106>>>>>
79106>>>>>        Send Delete_Data
79107>>>>>
79107>>>>>        Set Changed_State To False
79108>>>>>        Set Read_Only_State To True
79109>>>>>
79109>>>>>        Send Show_Registration
79110>>>>>        Send Show_Drivers
79111>>>>>        Send Show_ServicePack
79112>>>>>        Send Show_Versions
79113>>>>>        Send AppendTextLn ""
79114>>>>>
79114>>>>>        If (ghoApplication <> 0) Begin
79116>>>>>            Send Show_WorkSpaceInformation
79117>>>>>            Send Show_HelpFile
79118>>>>>            Send AppendTextLn ""
79119>>>>>        End
79119>>>>>>
79119>>>>>        Else Begin
79120>>>>>            Send AppendTextLn ""
79121>>>>>        End
79121>>>>>>
79121>>>>>
79121>>>>>        If (ghoConnection <> 0) Begin
79123>>>>>            Send Show_ConnectionIdInformation
79124>>>>>        End
79124>>>>>>
79124>>>>>
79124>>>>>        Send Show_Current_User
79125>>>>>        Send Show_Windows_Directory
79126>>>>>        Send Show_Current_Directory
79127>>>>>
79127>>>>>        // This is already shown in the workspace details,
79127>>>>>        // unless no workspace object is present:
79127>>>>>        If (ghoApplication = 0) Begin
79129>>>>>            Send Show_Filelist_Name
79130>>>>>        End
79130>>>>>>
79130>>>>>
79130>>>>>        If (ghoApplication <> 0) Begin
79132>>>>>            Send AppendTextLn ""
79133>>>>>            Send Show_EnterAsTab
79134>>>>>        End
79134>>>>>>
79134>>>>>
79134>>>>>        Send Show_Screen_Size
79135>>>>>        Send Show_Page_Size
79136>>>>>        Send Show_Number_Format
79137>>>>>        Send Show_Date_Format
79138>>>>>        Send Show_Lock_Delay
79139>>>>>        Send Show_Lock_Timeout
79140>>>>>        Send Show_Date
79141>>>>>        Send Show_Systemresources
79142>>>>>        Send Beginning_of_Data
79143>>>>>
79143>>>>>        Set Icon to 'default.ico'
79144>>>>>    End_Procedure
79145>>>>>End_Class
79146>>>>>
79146>>>>>Class SysInfoDialog is a ModalPanel
79147>>>>>    Procedure Construct_Object
79149>>>>>        Forward Send Construct_Object
79151>>>>>
79151>>>>>        Set Label to C_$SystemInformation
79152>>>>>        Set Size to 140 267
79153>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79154>>>>>        Set Border_Style to Border_Thick
79155>>>>>        Set Sysmenu_Icon to False
79156>>>>>
79156>>>>>        // "+1" will make the panel to paint correctly.
79156>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
79157>>>>>
79157>>>>>        // 2014-09-14 NGS
79157>>>>>        // Added a container object around the cTexteditor
79157>>>>>        // object to get a border around the text.
79157>>>>>        Object oSysinfoDisplayContainer is a Container3d
79159>>>>>            Set Location to 2 4
79160>>>>>            Set Size to 110 255
79161>>>>>            Set Border_Style to Border_ClientEdge
79162>>>>>            Set Color to clWhite
79163>>>>>            Set peAnchors to anAll
79164>>>>>
79164>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
79166>>>>>            End_Object
79167>>>>>
79167>>>>>        End_Object
79168>>>>>
79168>>>>>        Object oCloseButton is a Button
79170>>>>>            Set Label to C_$Close
79171>>>>>            Set Location to 120 210
79172>>>>>            Set Message item 0 to msg_Close_Panel
79173>>>>>            Set Default_State To True
79174>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
79174>>>>>            // and changes its peAnchors, we might as well prepare this object
79174>>>>>            // for that situation.
79174>>>>>            Set peAnchors to anBottomRight
79175>>>>>        End_Object
79176>>>>>
79176>>>>>        Object oCopyButton is a cCopyEditorContentButton
79178>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79179>>>>>            Set Size to 14 50
79180>>>>>            Set Location to 120 158
79181>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79181>>>>>            // we might as well prepare the object for it.
79181>>>>>            Set peAnchors to anBottomRight
79182>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
79183>>>>>        End_Object
79184>>>>>
79184>>>>>        On_Key kCancel Send Close_Panel
79185>>>>>    End_Procedure
79186>>>>>
79186>>>>>    Procedure Page Integer iPageObject
79188>>>>>        Handle hMenu
79188>>>>>        Integer iPrevState
79188>>>>>
79188>>>>>        Forward Send Page iPageObject
79190>>>>>
79190>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
79190>>>>>        //
79190>>>>>    End_Procedure
79191>>>>>
79191>>>>>End_Class
79192>>>>>
79192>>>>>Class cAboutEdit is an cRichEdit
79193>>>>>    Procedure Construct_Object
79195>>>>>        Forward Send Construct_Object
79197>>>>>
79197>>>>>        Property String psContentText
79198>>>>>
79198>>>>>        Set Size to 77 153
79199>>>>>        Set Location to 8 60
79200>>>>>        Set Read_Only_State to True
79201>>>>>        Set Skip_State to True
79202>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
79202>>>>>        // or 1/20 of a printer's point.
79202>>>>>        Set piRightMargin to (0.1 * 1440)
79203>>>>>        Set Border_Style  to Border_None
79204>>>>>    End_Procedure
79205>>>>>
79205>>>>>    // Adds a line of text to the edit object
79205>>>>>    Procedure Add_Line String sText
79207>>>>>        String sContentText
79207>>>>>        Get psContentText to sContentText
79208>>>>>        Move (sContentText + String(sText)) to sContentText
79209>>>>>        Set psContentText to sContentText
79210>>>>>    End_Procedure
79211>>>>>
79211>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
79211>>>>>    // Note that we use a property psContentText and add to it,
79211>>>>>    // because the object isn't paged yet when we add these
79211>>>>>    // values and the COM edit object needs to be paged
79211>>>>>    // for the text to become visible. See Also: Procedure Page below.
79211>>>>>    Procedure Add_LineLn String sText
79213>>>>>        String sContentText sCR
79213>>>>>
79213>>>>>        Move (Character(10) + String(Character(13))) to sCR
79214>>>>>        Get psContentText to sContentText
79215>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
79216>>>>>        Set psContentText to sContentText
79217>>>>>    End_Procedure
79218>>>>>
79218>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
79220>>>>>        String sLinkText
79220>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
79221>>>>>        Send Show_HomePage sLinkText
79222>>>>>    End_Procedure
79223>>>>>
79223>>>>>    Procedure Page Integer iPageObject
79225>>>>>        String sContentText
79225>>>>>
79225>>>>>        Forward Send Page iPageObject
79227>>>>>        Get psContentText to sContentText
79228>>>>>        Send AppendText sContentText
79229>>>>>        send Beginning_of_Data
79230>>>>>    End_Procedure
79231>>>>>
79231>>>>>End_Class
79232>>>>>
79232>>>>>Class AboutDialog is a ModalPanel
79233>>>>>    Procedure Construct_Object
79235>>>>>
79235>>>>>        Forward Send Construct_Object
79237>>>>>
79237>>>>>        Set Label to C_$About
79238>>>>>        Set Size to 118 230
79239>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79240>>>>>        Set Border_Style to Border_Thick
79241>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
79242>>>>>
79242>>>>>        Object oSysInfoDialog is a SysInfoDialog
79244>>>>>        End_Object
79245>>>>>
79245>>>>>        Object oBox is a Container3d
79247>>>>>            Set Border_Style to Border_Normal
79248>>>>>            Set Size to 90 220
79249>>>>>            Set Location to 4 5
79250>>>>>            Set Color to clWhite
79251>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79251>>>>>            // we might as well prepare the object for it.
79251>>>>>            Set peAnchors to anAll
79252>>>>>
79252>>>>>            Object oAboutGraphic is a BitmapContainer
79254>>>>>                Set Border_Style To Border_None
79255>>>>>                Set Bitmap_Style to Bitmap_Center
79256>>>>>                Set Color to clWhite
79257>>>>>                Set Size to 45 50
79258>>>>>                Set Location to 0 3
79259>>>>>            End_Object
79260>>>>>
79260>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
79262>>>>>                Set Border_Style to Border_None
79263>>>>>                Set Bitmap_Style to Bitmap_Center
79264>>>>>                Set Color to clWhite
79265>>>>>                Set Size to 30 55
79266>>>>>                Set Location to 50 3
79267>>>>>            End_Object
79268>>>>>
79268>>>>>            Object oInfoList_Editor is an cAboutEdit
79270>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
79270>>>>>                // we might as well prepare the object for it.
79270>>>>>                Set peAnchors to anAll
79271>>>>>            End_Object
79272>>>>>
79272>>>>>            // These objects are here for backwards compatability only.
79272>>>>>            // They are not used.
79272>>>>>            Object oProductName is a TextBox
79274>>>>>                Set Label To C_$ProductName
79275>>>>>                Set Size To 10 45
79276>>>>>                Set Location To 8 53
79277>>>>>                Set Visible_State to False
79278>>>>>                Set Focus_Mode to NonFocusable
79279>>>>>            End_Object
79280>>>>>
79280>>>>>            Object oVersion is a TextBox
79282>>>>>                Set Label To C_$Version
79283>>>>>                Set Size To 10 25
79284>>>>>                Set Location To 21 53
79285>>>>>                Set Visible_State to False
79286>>>>>                Set Focus_Mode to NonFocusable
79287>>>>>            End_Object
79288>>>>>
79288>>>>>            Object oCopyright is a TextBox
79290>>>>>                Set Label To C_$Copyright
79291>>>>>                Set Size To 10 31
79292>>>>>                Set Location To 34 53
79293>>>>>                Set Visible_State to False
79294>>>>>                Set Focus_Mode to NonFocusable
79295>>>>>            End_Object
79296>>>>>
79296>>>>>            Object oAuthor is a TextBox
79298>>>>>                Set Label To C_$Author
79299>>>>>                Set Size To 10 22
79300>>>>>                Set Location To 46 53
79301>>>>>                Set Visible_State to False
79302>>>>>                Set Focus_Mode to NonFocusable
79303>>>>>            End_Object
79304>>>>>
79304>>>>>        End_Object
79305>>>>>
79305>>>>>        Object oOKButton is a Button
79307>>>>>            On_Item C_$Close Send Close_Panel
79308>>>>>            Set Location to 98 176
79309>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79309>>>>>            // we might as well prepare the object for it.
79309>>>>>            Set peAnchors to anBottomRight
79310>>>>>        End_Object
79311>>>>>
79311>>>>>        Object oSysInfoButton is a Button
79313>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
79314>>>>>            Set Location to 98 123
79315>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79315>>>>>            // we might as well prepare the object for it.
79315>>>>>            Set peAnchors to anBottomRight
79316>>>>>        End_Object
79317>>>>>
79317>>>>>        Object oCopyButton is a cCopyEditorContentButton
79319>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79320>>>>>            Set Size to 14 50
79321>>>>>            Set Location to 98 70
79322>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79322>>>>>            // we might as well prepare the object for it.
79322>>>>>            Set peAnchors to anBottomRight
79323>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
79324>>>>>        End_Object
79325>>>>>
79325>>>>>        On_Key Kcancel Send KeyAction of oOKButton
79326>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
79327>>>>>        Set LogoDF to "DF32.bmp"
79328>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
79328>>>>>    End_Procedure
79329>>>>>
79329>>>>>    Procedure Page Integer iPageObject
79331>>>>>        Handle hMenu
79331>>>>>        Integer iPrevState
79331>>>>>
79331>>>>>        Forward Send Page iPageObject
79333>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
79333>>>>>        Set Icon to "Default.ico"
79334>>>>>
79334>>>>>        // Shadow upper left corner menu items: (icon menu items)
79334>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
79335>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79336>>>>>        // The "Move" menu command may come in handy to have.
79336>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79336>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79337>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79338>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79339>>>>>        // The "Close" menu command may be good to have.
79339>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79339>>>>>    End_Procedure
79340>>>>>
79340>>>>>    Procedure Set ProductName String sText
79342>>>>>        Set Value of oProductName to sText
79343>>>>>    End_Procedure
79344>>>>>
79344>>>>>    Procedure Set Copyright String sText
79346>>>>>        Set Value of oCopyright to sText
79347>>>>>    End_Procedure
79348>>>>>
79348>>>>>    Procedure Set Author String sText
79350>>>>>        Set Value of oAuthor to sText
79351>>>>>    End_Procedure
79352>>>>>
79352>>>>>    Procedure Set Version String sVersion
79354>>>>>        Handle hoVersionInfo
79354>>>>>        Boolean bIncluded
79354>>>>>        Integer iMajor iMinor iRelease iBuild
79354>>>>>        Date dCompileDate
79354>>>>>        String sCertInfo
79354>>>>>
79354>>>>>        If (sVersion = "") Begin
79356>>>>>            // This automatically shows the program version of the program, if available.
79356>>>>>            // It will be displayed as the second item in the edit object.
79356>>>>>            If (ghoApplication <> 0) Begin
79358>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
79359>>>>>                If (hoVersionInfo <> 0) Begin
79361>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
79362>>>>>                    If (bIncluded) Begin
79364>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
79365>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
79366>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
79367>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
79368>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
79369>>>>>                    End
79369>>>>>>
79369>>>>>                End
79369>>>>>>
79369>>>>>            End
79369>>>>>>
79369>>>>>        End
79369>>>>>>
79369>>>>>
79369>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
79369>>>>>        Get GetCompileDate to dCompileDate
79370>>>>>        If (sVersion <> "") Begin
79372>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
79373>>>>>        End
79373>>>>>>
79373>>>>>
79373>>>>>        Get IsProgramDigitallySigned to sCertInfo
79374>>>>>        If (sCertInfo <> "-1") Begin
79376>>>>>            If (sCertInfo <> "") Begin
79378>>>>>                Send Add_LineLn sCertInfo
79379>>>>>            End
79379>>>>>>
79379>>>>>            Else Begin
79380>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
79381>>>>>            End
79381>>>>>>
79381>>>>>        End
79381>>>>>>
79381>>>>>    End_Procedure
79382>>>>>
79382>>>>>    Function IsDate String sDate Returns Boolean
79384>>>>>        Boolean bIsDate
79384>>>>>        String sGoodCharacters sChar
79384>>>>>        Integer iCount iLength
79384>>>>>
79384>>>>>        Move True to bIsDate
79385>>>>>        Move "0123456789-/" to sGoodCharacters
79386>>>>>        Move (Length(sDate)) to iLength
79387>>>>>        For iCount from 1 to iLength
79393>>>>>>
79393>>>>>            Move (Left(sDate, 1)) to sChar
79394>>>>>            Move (Mid(sDate, 12, 2)) to sDate
79395>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
79396>>>>>            If (bIsDate = False) Begin
79398>>>>>                Move iLength to iCount
79399>>>>>            End
79399>>>>>>
79399>>>>>        Loop
79400>>>>>>
79400>>>>>        Function_Return bIsDate
79401>>>>>    End_Function
79402>>>>>
79402>>>>>    Function GetCompileDate Returns Date
79404>>>>>        Date dCompileDate
79404>>>>>        String sAppFilename sProgram sData sCompileDate
79404>>>>>        Integer iChannel iPos iDateFormat iCount iSize
79404>>>>>        Boolean bIsValid
79404>>>>>
79404>>>>>        Move 0 to dCompileDate
79405>>>>>        // Get full path to the current running executable
79405>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
79406>>>>>        Get GetApplicationName     of ghoApplication to sProgram
79407>>>>>
79407>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
79407>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
79408>>>>>
79408>>>>>        Get_Argument_Size to iSize
79409>>>>>        Set_Argument_Size 15000000
79410>>>>>>
79410>>>>>        Read_Block channel iChannel sData 15000000   // This must be big enough to reach the compile date location
79412>>>>>        Move (Pos(sProgram,sData)) to iPos
79413>>>>>        If (iPos > 0) Begin
79415>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
79415>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
79416>>>>>
79416>>>>>            // If the current date format is non US, we need to temporary
79416>>>>>            // change the format and then move the string to the date variable.
79416>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
79419>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
79422>>>>>            Move (Date(sCompileDate))    to dCompileDate
79423>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79426>>>>>        End
79426>>>>>>
79426>>>>>        Else Begin
79427>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
79428>>>>>>
79428>>>>>        End
79428>>>>>>
79428>>>>>
79428>>>>>        Send Seq_Close_Channel iChannel
79429>>>>>        Set_Argument_Size iSize
79430>>>>>>
79430>>>>>//        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
79430>>>>>//        Read_Block channel iChannel sData 75            // The compile information we're interested in
79430>>>>>
79430>>>>>        // The data is padded with Character(0)s. Strip them out
79430>>>>>//        Move (CString(sData)) to sData
79430>>>>>
79430>>>>>        // The compile date is after the first ", ", so string parsing is required
79430>>>>>//        Move (Pos(", ", sData)) to iPos
79430>>>>>//        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
79430>>>>>        // If the current date format is non US, we need to temporary
79430>>>>>        // change the format and then move the string to the date variable.
79430>>>>>//        Get_Attribute DF_DATE_FORMAT        to iDateFormat
79430>>>>>//        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
79430>>>>>//
79430>>>>>//        // Note the build in IsDateValid can return the wrong result
79430>>>>>//        // when controls characters are part of the sCompileDate.
79430>>>>>//        Get IsDate sCompileDate))           to bIsValid
79430>>>>>//        If (bIsValid = True) Begin
79430>>>>>//            Move (Date(sCompileDate))       to dCompileDate
79430>>>>>//        End
79430>>>>>//
79430>>>>>//        // As of DataFlex 19.1 the header has changed; and so has the compile date location.
79430>>>>>//        // It seems to me that the position for the compilation date can vary. So we read line-by-line
79430>>>>>//        // until we encounter the program name that appears just in front of the compile date.
79430>>>>>//        // Although I'm not sure about if/how the position varies, the below seems to work just fine.
79430>>>>>//        If (dCompileDate = 0) Begin
79430>>>>>//            Move "" to sCompileDate
79430>>>>>//            Move 30000 to iSize
79430>>>>>//            For iCount from 1 to iSize
79430>>>>>//                Readln channel iChannel sData
79430>>>>>//                Move (Pos(sProgram, sData)) to iPos
79430>>>>>//                If (iPos <> 0) Begin
79430>>>>>//                    Move (Mid(sData, 10, (iPos + (Length(sProgram) + 2)))) to sCompileDate
79430>>>>>//                    Move (Trim(sCompileDate)) to sCompileDate
79430>>>>>//                    Move iSize to iCount // We're out of here.
79430>>>>>//                End
79430>>>>>//            Loop
79430>>>>>//            If (Left(sCompileDate, 1) = "0") Begin
79430>>>>>//                Move ("1" + String(sCompileDate)) to sCompileDate
79430>>>>>//            End
79430>>>>>//            Get IsDate sCompileDate)) to bIsValid
79430>>>>>//            If (bIsValid = True) Begin
79430>>>>>//                Move (Date(sCompileDate)) to dCompileDate
79430>>>>>//            End
79430>>>>>//        End
79430>>>>>//        Send Seq_Close_Channel iChannel
79430>>>>>//        Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79430>>>>>
79430>>>>>        Function_Return dCompileDate
79431>>>>>    End_Function
79432>>>>>
79432>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
79432>>>>>    // (the passed program), has been finished
79432>>>>>    // The DOS box does also _not_ flash briefly.
79432>>>>>    Procedure RunProgramWait String sProgram String sParameter
79434>>>>>        Handle hProcess
79434>>>>>        Integer iVoid
79434>>>>>        AboutSHELLEXECUTEINFO sInfo
79434>>>>>        AboutSHELLEXECUTEINFO sInfo
79434>>>>>
79434>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
79435>>>>>
79435>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
79436>>>>>        Move SW_SHOW                 to sInfo.nShow
79437>>>>>
79437>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
79438>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
79439>>>>>        // This will "hide" the DOS box from showing (no flasing box):
79439>>>>>        Move 0                       to sInfo.nShow
79440>>>>>
79440>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
79441>>>>>        Move sInfo.hProcess to hProcess
79442>>>>>        If (hProcess) Begin
79444>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
79445>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
79446>>>>>        End
79446>>>>>>
79446>>>>>    End_Procedure
79447>>>>>
79447>>>>>    Function AddFolderDelimiter String sPath Returns String
79449>>>>>        String sDirSep
79449>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79450>>>>>        Move (Trim(sPath)) to sPath
79451>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79453>>>>>            Move (sPath + sDirSep) to sPath
79454>>>>>        End
79454>>>>>>
79454>>>>>        Function_Return sPath
79455>>>>>    End_Function
79456>>>>>
79456>>>>>    // Returns an empty string if the current program is not digitally signed,
79456>>>>>    // or there is a problem with the certificate.
79456>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
79456>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
79456>>>>>    Function IsProgramDigitallySigned Returns String
79458>>>>>        Boolean bExists
79458>>>>>        String sPath sProgram sParams sRetval
79458>>>>>        Integer iCh
79458>>>>>
79458>>>>>        Move "" to sRetval
79459>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
79460>>>>>        Get AddFolderDelimiter sPath to sPath
79461>>>>>        File_Exist (sPath + CS_SignProgram) bExists
79462>>>>>        If (bExists = False) Begin
79464>>>>>            Function_Return "-1"
79465>>>>>        End
79465>>>>>>
79465>>>>>
79465>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
79466>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
79467>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
79468>>>>>        Move (sParams * String("| clip"))    to sParams
79469>>>>>        Get Seq_New_Channel to iCh
79470>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
79472>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
79475>>>>>        Close_Output channel iCh
79477>>>>>        // New ShellExecute based message that waits for the passed process to end.
79477>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
79478>>>>>        Direct_Input channel iCh "CLIPBOARD:"
79480>>>>>            Readln channel iCh sRetval
79482>>>>>            Readln channel iCh sRetval
79484>>>>>            Readln channel iCh sRetval
79486>>>>>            Readln channel iCh sRetval
79488>>>>>        Close_Input channel iCh
79490>>>>>        Send Seq_Release_Channel iCh
79491>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
79493>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
79494>>>>>        End
79494>>>>>>
79494>>>>>        Else Begin
79495>>>>>            Move "" to sRetval
79496>>>>>        End
79496>>>>>>
79496>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
79496>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
79497>>>>>>
79497>>>>>        Function_Return sRetval
79498>>>>>    End_Function
79499>>>>>
79499>>>>>    Procedure Add_LineLn String sValue
79501>>>>>        Send Add_LineLn of oInfoList_Editor sValue
79502>>>>>    End_Procedure
79503>>>>>
79503>>>>>    Procedure Add_Line String sValue
79505>>>>>        Send Add_Line of oInfoList_Editor sValue
79506>>>>>    End_Procedure
79507>>>>>
79507>>>>>    Procedure Set Logo string sLogo
79509>>>>>        // Square bitmaps of 80x80 work best
79509>>>>>        Set Bitmap of oAboutGraphic to sLogo
79510>>>>>    End_Procedure
79511>>>>>
79511>>>>>    Procedure Set LogoDF String sLogo
79513>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
79514>>>>>    End_Procedure
79515>>>>>
79515>>>>>    Procedure Show_Sysinfo
79517>>>>>        Send Popup_Modal of oSysinfoDialog
79518>>>>>    End_Procedure
79519>>>>>
79519>>>>>    Procedure Show_HomePage String sWebpage
79521>>>>>        Handle hWnd
79521>>>>>        Get Window_Handle to hWnd
79522>>>>>        Runprogram Shell Background (Trim(sWebpage))
79523>>>>>    End_Procedure
79524>>>>>
79524>>>>>End_Class
79525>>>
79525>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
79525>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
79525>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
79525>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
79525>>>// decimals you may Get truncation that again may cause problems with finding.
79525>>>//
79525>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
79525>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
79525>>>
79525>>>
79525>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
79525>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
79525>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
79525>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
79525>>>//
79525>>>
79525>>>Class cDbUpdateFunctionLibrary is a cObject
79526>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\ParseKeyWord.pkg)
79527>>>>
79527>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
79529>>>>    Integer iStart iEnd
79529>>>>    String sRetval
79529>>>>
79529>>>>    Move (Trim(sConnect)) to sConnect
79530>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
79531>>>>    If (iStart = 0) Begin
79533>>>>        Function_Return ""
79534>>>>    End
79534>>>>>
79534>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
79535>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
79536>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
79538>>>>        Move (Pos(",", sRetval))          to iEnd
79539>>>>    End
79539>>>>>
79539>>>>    Else Begin
79540>>>>        Move (Pos(";", sRetval))          to iEnd
79541>>>>    End
79541>>>>>
79541>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
79543>>>>        Move (Pos(",", sRetval))          to iEnd
79544>>>>        Decrement iEnd
79545>>>>    End
79545>>>>>
79545>>>>    If (iEnd <> 0) Begin
79547>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
79548>>>>    End
79548>>>>>
79548>>>>    Move (Replace("=", sRetval, ""))      to sRetval
79549>>>>
79549>>>>    Function_Return (Trim(sRetval))
79550>>>>End_Function
79551>>>>
79551>>>>
79551>>>
79551>>>    Procedure Construct_Object
79553>>>        Handle ho
79553>>>        Forward Send Construct_Object
79555>>>
79555>>>        Move Self to ghoDbUpdateFunctionLibrary
79556>>>
79556>>>        Send CreateDbUpdateLibraryProperties
79557>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
79557>>>        // we will create one as it is used for all ConnectionID, ConnectionString
79557>>>        // etc settings.
79557>>>        If (ghoSQLConnectionHandler = 0) Begin
79559>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
79560>>>            Set phoSQLConnectionHandler to ho
79561>>>        End   
79561>>>>
79561>>>        
79561>>>        Property String private.psCollation "Latin1_General_CS_AS"
79562>>>
79562>>>    End_Procedure
79563>>>
79563>>>    Procedure End_Construct_Object
79565>>>        Forward Send End_Construct_Object
79567>>>    End_Procedure
79568>>>
79568>>>    // *** SQL Messages for making changes to the SQL back-end ***
79568>>>    //
79568>>>    // * Dummy function for the Studio's Code Explorer *
79568>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
79570>>>        Function_Return False
79571>>>    End_Function
79572>>>
79572>>>    // Function for creating a new *Database*.
79572>>>    // Note: This is for creating SQL DATABASES - not tables!
79572>>>    // Returns True if successful.
79572>>>    // ToDo: Currently only works for MS-SQL...
79572>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
79574>>>        String sSQL sSQL1 sConnectionID sConnectionString
79574>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
79574>>>        Handle hConnection hStmt hoSQLManager
79574>>>        Integer iFetchResult iDbType
79574>>>        Boolean bOK bMertechDriver bExists
79574>>>
79574>>>        Get piDbType to iDbType
79575>>>//        If (iDbType <> EN_DbTypeMSSQL and sDriverID <> MDSMySQL and sDriverID <> MDSDB2 and sDriverID <> ODBC_DRV_ID) Begin
79575>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
79577>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 with Mertech drivers"
79578>>>>
79578>>>            Function_Return False
79579>>>        End
79579>>>>
79579>>>
79579>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
79580>>>        If (bExists = True) Begin
79582>>>            Function_Return True
79583>>>        End
79583>>>>
79583>>>
79583>>>        Get IsMertechDriver sDriverID to bMertechDriver
79584>>>        If (bMertechDriver = False) Begin
79586>>>            Get phoSQLManager to hoSQLManager
79587>>>        End
79587>>>>
79587>>>        Else Begin
79588>>>            Get _MertechSQLManagerHandle to hoSQLManager
79589>>>        End
79589>>>>
79589>>>
79589>>>        Get psConnectionID     to sConnectionID
79590>>>        Get psConnectionString to sConnectionString
79591>>>        Move 0 to LastErr
79592>>>
79592>>>        If (sDriverID = ODBC_DRV_ID) Begin
79594>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
79594>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
79594>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
79594>>>//                Move (Pos(";", sConnectionString)) to iPos
79594>>>//                If (iPos > 0) Begin
79594>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
79594>>>//                    Move (Trim(sConnectionString)) to sConnectionString
79594>>>//                End
79594>>>//            End
79594>>>        End
79594>>>>
79594>>>
79594>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
79595>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
79596>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
79597>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
79599>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
79600>>>>
79600>>>            Function_Return False
79601>>>        End
79601>>>>
79601>>>
79601>>>        Get SqlOpen of hConnection to hStmt
79602>>>
79602>>>        If (hStmt = 0) Begin
79604>>>            Send SqlDisconnect of hoSQLManager
79605>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
79606>>>>
79606>>>            Function_Return False
79607>>>        End
79607>>>>
79607>>>
79607>>>        Get psCollation to sCollation
79608>>>
79608>>>        Case Begin
79608>>>            Case (sDriverID = MSSQLDRV_ID)
79610>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
79611>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
79612>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
79613>>>
79613>>>                // Check if database exists
79613>>>                Send SqlExecDirect of hStmt sSQL
79614>>>                Get SqlFetch of hStmt to iFetchResult
79615>>>                Send SqlClose of hStmt
79616>>>                Send SqlDisconnect of hConnection
79617>>>                // If database already exists we're out of here!
79617>>>                // Note that we return True as this is not an error.
79617>>>                If (iFetchResult > 0) Begin
79619>>>                    Function_Return True
79620>>>                End
79620>>>>
79620>>>                // Database doesn't exist, create it.
79620>>>                If (iFetchResult = 0) Begin
79622>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
79623>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
79624>>>                    If (sCollation <> "") Begin
79626>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
79627>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
79628>>>                    End
79628>>>>
79628>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
79629>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
79630>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
79632>>>                        Function_Return False
79633>>>                    End
79633>>>>
79633>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
79633>>>                    Sleep 1
79634>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
79635>>>                End
79635>>>>
79635>>>                Case Break
79636>>>
79636>>>            Case (sDriverID = MDSPgSQL)
79639>>>                SQLIncludeScriptFile ..\Scripts\CreatePostgreSQLDatabase.sql as CreatePostgreSQLDatabase.sql
79639>>>                Get _SqlUtilCreatePostGreSQLDatabaseByScript "CreatePostgreSQLDatabase.sql" sDatabase to bOK
79640>>>                Case Break
79641>>>
79641>>>            Case (sDriverID = MDSMySQL or (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID))
79644>>>                // ToDo: How should this be set/checked?
79644>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
79644>>>//                    Set psCollation to "utf8"
79644>>>//                End
79644>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
79644>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
79645>>>                Case Break
79646>>>
79646>>>            Case (sDriverID = MDSDB2)
79649>>>                Case Break
79650>>>
79650>>>            Case Else
79650>>>                Error DFERR_PROGRAM "Unsupported database type"
79651>>>>
79651>>>        Case End
79651>>>
79651>>>        If (Err = False) Begin
79653>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
79654>>>        End
79654>>>>
79654>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
79654>>>        // the one we just created.
79654>>>        If (bUpdateConnectionString = True and Err = False) Begin
79656>>>            Set psDatabase to sDatabase
79657>>>            //...and perhaps also the SQLConnections.ini file setting.
79657>>>            If (bPermanantly = True) Begin
79659>>>                If (ghoSQLConnectionHandler <> 0) Begin
79661>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
79662>>>                End
79662>>>>
79662>>>            End
79662>>>>
79662>>>        End
79662>>>>
79662>>>
79662>>>        Function_Return (Err = False)
79663>>>    End_Function
79664>>>
79664>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
79664>>>    // will be used.
79664>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
79666>>>        Boolean bOK bExists bShowProgress
79666>>>        String sStatement sDriverID
79666>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
79666>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
79666>>>        Integer iDbType
79666>>>
79666>>>        If (sDatabase = "") Begin
79668>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
79669>>>>
79669>>>            Function_Return False
79670>>>        End
79670>>>>
79670>>>        If (sBackupName = "") Begin
79672>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
79673>>>>
79673>>>            Function_Return False
79674>>>        End
79674>>>>
79674>>>
79674>>>        // Create backup-folder if it doesn't exist
79674>>>        Get vFolderExists sPath to bExists
79675>>>        If (bExists = False) Begin
79677>>>            Get vCreateDirectory sPath to bOK
79678>>>            If (bOK = False) Begin
79680>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
79681>>>>
79681>>>                Function_Return False
79682>>>            End
79682>>>>
79682>>>        End
79682>>>>
79682>>>        // Make sure the path ends with a back-slash
79682>>>        If (sPath <> "") Begin
79684>>>            Get vFolderFormat sPath to sPath
79685>>>        End
79685>>>>
79685>>>
79685>>>        Get psDriverID to sDriverID
79686>>>        Get piDbType   to iDbType
79687>>>        If (num_arguments > 3) Begin
79689>>>            Move bShowProg to bShowProgress
79690>>>        End
79690>>>>
79690>>>
79690>>>        Case Begin
79690>>>            Case (iDbType = EN_DbTypeMSSQL)
79692>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
79692>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
79692>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
79693>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
79694>>>
79694>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
79695>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
79696>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
79697>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
79698>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
79699>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
79700>>>                Case Break
79701>>>            Case Else
79701>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
79702>>>        Case End
79702>>>
79702>>>        Function_Return bOK
79703>>>    End_Function
79704>>>
79704>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
79706>>>//        Boolean bOK bExists
79706>>>        String sStatement sDriverID sRetval //sPrevious
79706>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
79706>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
79706>>>        Integer iDbType iRows iFetchResult //iColumn
79706>>>        Handle hoSQLHandler hoSQLConnect hstmt
79706>>>        tSQLConnection SQLConnection
79706>>>        tSQLConnection SQLConnection
79706>>>
79706>>>        If (sDatabase = "") Begin
79708>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
79709>>>>
79709>>>            Function_Return ""
79710>>>        End
79710>>>>
79710>>>
79710>>>        Move "" to sRetval
79711>>>        Get psDriverID to sDriverID
79712>>>        Get piDbType   to iDbType
79713>>>
79713>>>        Case Begin
79713>>>            Case (iDbType = EN_DbTypeMSSQL)
79715>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
79715>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
79716>>>
79716>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
79717>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
79718>>>                Get phoSQLManager to hoSQLHandler
79719>>>
79719>>>                If (hoSQLHandler <> 0) Begin
79721>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
79722>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
79723>>>
79723>>>                    If (hoSQLConnect <> 0) Begin
79725>>>                        Get SQLOpen of hoSQLConnect to hstmt
79726>>>                        If (hstmt <> 0) Begin
79728>>>                            Send SqlExecDirect of hstmt sStatement
79729>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
79730>>>                            Get SQLFetch of hstmt to iFetchResult
79731>>>                            If (iFetchResult <> 0) Begin
79733>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
79734>>>                            End
79734>>>>
79734>>>                            Send SQLClose of hstmt
79735>>>                        End
79735>>>>
79735>>>                        Send SQLDisconnect of hoSQLConnect
79736>>>                    End
79736>>>>
79736>>>                End
79736>>>>
79736>>>                Case Break
79737>>>            Case Else
79737>>>                If (bSilent = False) Begin
79739>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
79740>>>                End
79740>>>>
79740>>>        Case End
79740>>>
79740>>>        Function_Return sRetval
79741>>>    End_Function
79742>>>
79742>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
79744>>>        Boolean bMertechDriver // bOK bExists 
79744>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
79744>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
79744>>>        Handle hConnection hStmt hoSQLManager
79744>>>        Integer iDbType // iFetchResult
79744>>>
79744>>>        If (sDatabase = "") Begin
79746>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
79747>>>>
79747>>>            Function_Return False
79748>>>        End
79748>>>>
79748>>>
79748>>>        If (sSQLCollation = "") Begin
79750>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
79751>>>>
79751>>>            Function_Return False
79752>>>        End
79752>>>>
79752>>>
79752>>>        Get psDriverID to sDriverID
79753>>>        Get piDbType   to iDbType
79754>>>
79754>>>        Get IsMertechDriver sDriverID to bMertechDriver
79755>>>        If (bMertechDriver = False) Begin
79757>>>            Get phoSQLManager to hoSQLManager
79758>>>        End
79758>>>>
79758>>>        Else Begin
79759>>>            Get _MertechSQLManagerHandle to hoSQLManager
79760>>>        End
79760>>>>
79760>>>
79760>>>        Get psConnectionID     to sConnectionID
79761>>>        Get psConnectionString to sConnectionString
79762>>>        Move 0 to LastErr
79763>>>
79763>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
79764>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
79765>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
79766>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
79768>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
79769>>>>
79769>>>            Function_Return False
79770>>>        End
79770>>>>
79770>>>
79770>>>        Get SqlOpen of hConnection to hStmt
79771>>>
79771>>>        If (hStmt = 0) Begin
79773>>>            Send SqlDisconnect of hoSQLManager
79774>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
79775>>>>
79775>>>            Function_Return False
79776>>>        End
79776>>>>
79776>>>
79776>>>        // Check if collation already exists
79776>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
79777>>>        // If the current collate is the same as the new; do nothing.
79777>>>        If (sSQLCollation = sSQLCollationCheck) Begin
79779>>>            Function_Return True
79780>>>        End
79780>>>>
79780>>>
79780>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
79781>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
79782>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
79783>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
79784>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
79785>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
79786>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
79787>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
79788>>>
79788>>>        // MS-SQL Syntax:
79788>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
79788>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
79788>>>        // ALTER DATABASE [database] SET MULTI_USER;
79788>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
79789>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
79790>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
79791>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
79791>>>
79791>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
79792>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
79793>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
79794>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
79796>>>           Function_Return False
79797>>>        End
79797>>>>
79797>>>
79797>>>        Function_Return (Err = False)
79798>>>    End_Function
79799>>>
79799>>>
79799>>>    // * Dummy function for the Studio's Code Explorer *
79799>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
79801>>>        Function_Return False
79802>>>    End_Function
79803>>>
79803>>>    // Converts from SQL to Embedded (DataFlex .dat files).
79803>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
79803>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
79803>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
79803>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
79803>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
79805>>>        Handle hToTable
79805>>>        Boolean bOK bExists bOpened bMertechDriver bCopyData
79805>>>        String sDriverID sPhysicalName sRootName sDisplayName
79805>>>        tSQLConnection SQLConnection
79805>>>        tSQLConnection SQLConnection
79805>>>        Integer iPos iMaxRecords
79805>>>
79805>>>        Get psDriverID to sDriverID
79806>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
79807>>>        If (bExists = False) Begin
79809>>>            Function_Return False
79810>>>        End
79810>>>>
79810>>>
79810>>>        If (num_arguments > 1) Begin
79812>>>            Move bCpyDat to bCopyData
79813>>>        End
79813>>>>
79813>>>        Else Begin
79814>>>            Move False to bCopyData
79815>>>        End
79815>>>>
79815>>>
79815>>>        Open hTable
79817>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
79820>>>        If (bOpened = False) Begin
79822>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
79823>>>>
79823>>>            Function_Return False
79824>>>        End
79824>>>>
79824>>>        Move 0 to hToTable
79825>>>
79825>>>        Move 16711679 to iMaxRecords
79826>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
79829>>>        Move (Pos(".", sDisplayName)) to iPos
79830>>>        If (iPos > 0) Begin
79832>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
79833>>>        End
79833>>>>
79833>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
79836>>>        Get _TableNameOnly sRootName                 to sRootName
79837>>>        Move (sRootName + ".dat")                    to sPhysicalName
79838>>>
79838>>>        If (ghoProgressBar <> 0) Begin
79840>>>            Send DoAdvance of ghoProgressBar
79841>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
79842>>>        End
79842>>>>
79842>>>
79842>>>        Move False to Err
79843>>>
79843>>>        Structure_Start hToTable DATAFLEX_ID
79844>>>            Structure_Copy hTable to hToTable
79845>>>
79845>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
79848>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
79851>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
79854>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
79857>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
79860>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
79861>>>
79861>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
79863>>>
79863>>>        Set Action_Text of ghoStatusPanel to ""
79864>>>        Move (not(Err)) to bOK
79865>>>        If (bOK = True and bCopyData = True) Begin
79867>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
79868>>>        End
79868>>>>
79868>>>
79868>>>        Get IsMertechDriver sDriverID to bMertechDriver
79869>>>        If (bMertechDriver = True) Begin
79871>>>            Open hTable
79873>>>        End
79873>>>>
79873>>>
79873>>>        // This must be after copying data...
79873>>>        If (Err = False) Begin
79875>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
79878>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
79881>>>        End
79881>>>>
79881>>>        Move (not(Err)) to bOK
79882>>>
79882>>>        Function_Return (bOK = True)
79883>>>    End_Function
79884>>>
79884>>>    Function AddFolderDelimiter String sPath Returns String
79886>>>        String sDirSep
79886>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79887>>>        Move (Trim(sPath)) to sPath
79888>>>        If (Right(sPath, 1) <> sDirSep) Begin
79890>>>            Move (sPath + sDirSep) to sPath
79891>>>        End
79891>>>>
79891>>>        Function_Return sPath
79892>>>    End_Function
79893>>>
79893>>>    // Creates an SQL Table at the SQL end by its filelist number;
79893>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
79893>>>    Function SqlTableCreate Integer hTable Returns Boolean
79895>>>        String sTableName sSQLString sPath sCreateTable sDriverID
79895>>>        Integer iDbType
79895>>>        Boolean bExists
79895>>>
79895>>>        Get psDriverID to sDriverID
79896>>>        Get UtilTableHandleToString hTable to sTableName
79897>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
79898>>>        If (bExists = True) Begin
79900>>>            Function_Return False
79901>>>        End
79901>>>>
79901>>>
79901>>>        Get psDataPathFirstPart to sPath
79902>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
79903>>>
79903>>>        Get piDbType to iDbType
79904>>>        Get _SqlProperTableName sTableName to sTableName
79905>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
79906>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
79907>>>
79907>>>        Move False to Err
79908>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
79909>>>
79909>>>        Function_Return (Err = False)
79910>>>    End_Function
79911>>>
79911>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
79911>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
79911>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
79913>>>        String sSQLString sPath sCreateTable sDriverID
79913>>>        Integer iDbType
79913>>>        Boolean bExists
79913>>>
79913>>>        Get psDriverID to sDriverID
79914>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
79915>>>        If (bExists = True) Begin
79917>>>            Function_Return False
79918>>>        End
79918>>>>
79918>>>
79918>>>        Get psDataPathFirstPart to sPath
79919>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
79920>>>        If (bExists = True) Begin
79922>>>            // ToDo: What should we do if an .int file already exists?
79922>>>        End
79922>>>>
79922>>>
79922>>>        Get piDbType to iDbType
79923>>>        Get _SqlProperTableName sTableName to sTableName
79924>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
79925>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
79926>>>
79926>>>        Move False to Err
79927>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
79928>>>
79928>>>        Function_Return (Err = False)
79929>>>    End_Function
79930>>>    
79930>>>    // ToDo: 2019-09-23 This needs to be finilized 
79930>>>    // It resets SQL constraints after a Structure_End, if necessary.
79930>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
79932>>>        Boolean bOK                                                            
79932>>>        String sStatement
79932>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
79933>>>        Function_Return bOK
79934>>>    End_Function
79935>>>    
79935>>>    // First deletes the data cache file and then drops the passed SQL table.
79935>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
79935>>>    //       else try using the SqlTableRemoveByTableName message.
79935>>>    Function SqlTableRemove Handle hTable Returns Boolean
79937>>>        String sSQLString sPath sDropTable sTableName sDriverID
79937>>>        Integer iRetval iDbType
79937>>>        Boolean bExists bMertechDriver bOK
79937>>>
79937>>>        Get psDriverID to sDriverID
79938>>>        Get IsMertechDriver sDriverID to bMertechDriver
79939>>>        Get UtilTableHandleToString hTable to sTableName
79940>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
79941>>>        If (bExists = False) Begin
79943>>>            Function_Return False
79944>>>        End
79944>>>>
79944>>>
79944>>>        Get psDataPathFirstPart to sPath
79945>>>        Get UtilDeleteCacheFile sTableName to iRetval
79946>>>
79946>>>        Get piDbType to iDbType
79947>>>        Get _SqlProperTableName sTableName to sTableName
79948>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
79949>>>        Move (sDropTable * String(sTableName)) to sSQLString
79950>>>
79950>>>        Move False to Err
79951>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
79952>>>
79952>>>        // We also need to remove the cache-file since the table has been changed
79952>>>        Get UtilDeleteCacheFile sTableName to bOK
79953>>>
79953>>>        Function_Return (Err = False)
79954>>>    End_Function
79955>>>
79955>>>    // First deletes the data cache file and then drops the passed data table.
79955>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
79957>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
79957>>>        Integer iRetval iDbType
79957>>>        Boolean bMertechDriver bOK
79957>>>
79957>>>        Get psDriverID to sDriverID
79958>>>        Get IsMertechDriver sDriverID to bMertechDriver
79959>>>        Get psDataPathFirstPart to sPath
79960>>>        Get UtilDeleteCacheFile sTableName to iRetval
79961>>>
79961>>>        Get piDbType to iDbType
79962>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
79963>>>        Get psSchema to sSchema
79964>>>        If (sSchema = "") Begin
79966>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
79967>>>        End
79967>>>>
79967>>>        Move (Uppercase(sTableName)) to sVal
79968>>>        If (not(sVal contains (sSchema + "."))) Begin
79970>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
79971>>>        End
79971>>>>
79971>>>        Move (sDropTable * String(sTableName)) to sSQLString
79972>>>
79972>>>        Move False to Err
79973>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
79974>>>
79974>>>        // We also need to remove the cache-file since the table has been changed
79974>>>        Get UtilDeleteCacheFile sTableName to bOK
79975>>>
79975>>>        Function_Return (Err = False)
79976>>>    End_Function
79977>>>
79977>>>    // *** Sql View Messages ***
79977>>>
79977>>>    // First deletes the data cache file and then drops the passed Sql data view.
79977>>>    Function SqlViewRemove String sDataView Returns Boolean
79979>>>        String sDriverID sSQLString sDropViewKeyWord
79979>>>        Integer iRetval
79979>>>        Boolean bMertechDriver bOK
79979>>>
79979>>>        Get psDriverID to sDriverID
79980>>>        Get IsMertechDriver sDriverID to bMertechDriver
79981>>>        Get UtilDeleteCacheFile sDataView to iRetval
79982>>>
79982>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
79983>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
79984>>>        Set psSQLStatementString to sSQLString
79985>>>
79985>>>        // As we don't check if the view exist or not, it might happen
79985>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
79985>>>        Move False to Err
79986>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
79987>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
79988>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
79989>>>        Move 0 to LastErr
79990>>>
79990>>>        // We also need to remove the cache-file since the table has been changed
79990>>>        Get UtilDeleteCacheFile sDataView to bOK
79991>>>
79991>>>        Function_Return (Err = False)
79992>>>    End_Function
79993>>>
79993>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
79995>>>        Boolean bOK
79995>>>        Integer iDbType
79995>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
79995>>>
79995>>>        Get psDriverID to sDriverID
79996>>>        Get piDbType   to iDbType
79997>>>
79997>>>        Case Begin
79997>>>            Case (iDbType = EN_DbTypeDB2)
79999>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
80000>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
80001>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
80002>>>            Break
80003>>>
80003>>>            Case (iDbType = EN_DbTypeMSSQL)
80006>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
80007>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
80008>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
80009>>>            Break
80010>>>
80010>>>            Case (iDbType = EN_DbTypeOracle)
80013>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
80014>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
80015>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
80016>>>            Break
80017>>>
80017>>>            Case (iDbType = EN_DbTypePostgre)
80020>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
80021>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
80022>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
80023>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
80024>>>            Break
80025>>>
80025>>>            Case (iDbType = EN_DbTypeMySQL)
80028>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
80029>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
80030>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
80031>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
80032>>>            Break
80033>>>        Case End
80033>>>
80033>>>        Move False to Err
80034>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
80035>>>        Move (Err = False) to bOK
80036>>>
80036>>>        Function_Return bOK
80037>>>    End_Function
80038>>>
80038>>>    // * Dummy function for the Studio's Code Explorer *
80038>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
80040>>>        Function_Return False
80041>>>    End_Function
80042>>>
80042>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
80042>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
80044>>>        Integer iLength iDecimals
80044>>>        String sColumnValue
80044>>>        String sTableName sDriverID
80044>>>        Boolean bOK bInitializeValue
80044>>>
80044>>>        Get psDriverID to sDriverID
80045>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80046>>>        If (bOK = False) Begin
80048>>>            Function_Return False
80049>>>        End
80049>>>>
80049>>>
80049>>>        Get UtilTableHandleToString hTable to sTableName
80050>>>        If (sTableName = "") Begin
80052>>>            Function_Return False
80053>>>        End
80053>>>>
80053>>>
80053>>>        If (num_arguments > 3) Begin
80055>>>            Move iLen     to iLength
80056>>>            Move iDec     to iDecimals
80057>>>            Move bInitVal to bInitializeValue
80058>>>            Move sColVal  to sColumnValue
80059>>>        End
80059>>>>
80059>>>
80059>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
80060>>>
80060>>>        Function_Return (bOK = True)
80061>>>    End_Function
80062>>>
80062>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
80062>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
80064>>>        Integer iDbType iLength iDecimals iDriver
80064>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
80064>>>        String sDriverID sNotNull
80064>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState bIsMertechDriver
80064>>>        Handle hTable
80064>>>
80064>>>        Get psDriverID to sDriverID
80065>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80066>>>        If (bOK = False) Begin
80068>>>            Function_Return True
80069>>>        End
80069>>>>
80069>>>
80069>>>        Get UtilTableNameToHandle sTableName to hTable
80070>>>        If (hTable = 0) Begin
80072>>>            Get NextFreeFilelistSlot to hTable
80073>>>        End
80073>>>>
80073>>>
80073>>>        Get piDbType to iDbType
80074>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
80074>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
80075>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
80077>>>            Function_Return True
80078>>>        End
80078>>>>
80078>>>
80078>>>        Get DriverIndex sDriverID to iDriver
80079>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
80080>>>        If (bIsMertechDriver = False) Begin
80082>>>            Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
80085>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
80088>>>        End
80088>>>>
80088>>>
80088>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
80089>>>        If (num_arguments > 3) Begin
80091>>>            Move iLen     to iLength
80092>>>            Move iDec     to iDecimals
80093>>>            Move bInitVal to bInitializeValue
80094>>>            Move sColVal  to sColumnValue
80095>>>        End
80095>>>>
80095>>>
80095>>>        Get _SqlProperTableName sTableName   to sTableName
80096>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
80097>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
80098>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
80099>>>
80099>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
80100>>>        If (bFixed = False) Begin
80102>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
80103>>>        End
80103>>>>
80103>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
80104>>>
80104>>>        Move False to Err
80105>>>        Send SqlUtilExecuteQuery sStmt sDriverID
80106>>>
80106>>>        If (bInitializeValue = True and Err = False) Begin
80108>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
80109>>>        End
80109>>>>
80109>>>
80109>>>        If (Err = False) Begin
80111>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
80112>>>        End
80112>>>>
80112>>>
80112>>>        Move (not(Err)) to bRetval
80113>>>
80113>>>        // We also need to remove the cache-file since the table has been changed
80113>>>        Get UtilDeleteCacheFile sTableName to bOK
80114>>>        If (bIsMertechDriver = False) Begin
80116>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
80119>>>        End
80119>>>>
80119>>>        Function_Return bRetval
80120>>>    End_Function
80121>>>
80121>>>    // To update all current rows for a table column with a common value.
80121>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
80123>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
80123>>>        Boolean bRetval bSQLDriver
80123>>>        Integer iCurrErr iDbType
80123>>>
80123>>>        Move False to bRetval
80124>>>        Get piDbType to iDbType
80125>>>        Get psDriverID to sDriverID
80126>>>        Get IsSQLDriver sDriverID to bSQLDriver
80127>>>        If (bSQLDriver = False) Begin
80129>>>            Function_Return bRetval
80130>>>        End
80130>>>>
80130>>>        Get UtilTableHandleToString hTable to sTableName
80131>>>
80131>>>        Move Err to iCurrErr
80132>>>        Move False to Err
80133>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
80134>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
80135>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
80136>>>        If (sDriverID = MDSMySQL) Begin
80138>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
80139>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'" * sSet * sSqlSafe_Updates + "=1") to sStmt
80140>>>        End
80140>>>>
80140>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
80140>>>        If (iDbType = EN_DbTypeMySQL) Begin
80142>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
80143>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
80144>>>        End
80144>>>>
80144>>>        Else Begin
80145>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
80146>>>        End
80146>>>>
80146>>>
80146>>>        Send SqlUtilExecuteQuery sStmt sDriverID
80147>>>        Move (Err = False) to bRetval
80148>>>        Move iCurrErr to Err
80149>>>
80149>>>        Function_Return bRetval
80150>>>    End_Function
80151>>>
80151>>>    // The fourth & fifth arguments are optional, depending on the iDataType
80151>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
80151>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
80153>>>        String sDriverID sTableName
80153>>>        Boolean bOK
80153>>>
80153>>>        Get psDriverID to sDriverID
80154>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80155>>>        If (bOK = False) Begin
80157>>>            Function_Return False
80158>>>        End
80158>>>>
80158>>>
80158>>>        Get UtilTableHandleToString hTable to sTableName
80159>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
80160>>>
80160>>>        Function_Return (Err = False)
80161>>>    End_Function
80162>>>
80162>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
80162>>>    // The fourth & fifth arguments are optional, depending on the iDataType
80162>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
80162>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
80164>>>        Integer iDbType iLength iDecimals
80164>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
80164>>>        Boolean bExists bOK bFixed
80164>>>        Handle hTable
80164>>>
80164>>>        Get psDriverID to sDriverID
80165>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80166>>>        If (bOK = False) Begin
80168>>>            Function_Return False
80169>>>        End
80169>>>>
80169>>>
80169>>>        Get UtilTableNameToHandle sTableName to hTable
80170>>>        If (hTable = 0) Begin
80172>>>            Get NextFreeFilelistSlot to hTable
80173>>>        End
80173>>>>
80173>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
80174>>>        If (bExists = False) Begin
80176>>>            Function_Return False
80177>>>        End
80177>>>>
80177>>>
80177>>>        If (num_arguments > 3) Begin
80179>>>            Move iLen to iLength
80180>>>        End
80180>>>>
80180>>>        If (num_arguments > 4) Begin
80182>>>            Move iDec to iDecimals
80183>>>        End
80183>>>>
80183>>>
80183>>>        Get piDbType to iDbType
80184>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
80185>>>
80185>>>        Move False to Err
80186>>>        Get _SqlProperTableName sTableName    to sTableName
80187>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
80188>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
80189>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
80190>>>
80190>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
80191>>>        If (bFixed = False) Begin
80193>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
80194>>>        End
80194>>>>
80194>>>
80194>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
80195>>>        Send SqlUtilExecuteQuery sStmt sDriverID
80196>>>
80196>>>        // We also need to remove the cache-file since the table has been changed
80196>>>        Get UtilDeleteCacheFile sTableName to bOK
80197>>>
80197>>>        Function_Return (Err = False)
80198>>>    End_Function
80199>>>
80199>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
80201>>>        Boolean bOK bErr bIsSQLDriver
80201>>>        String sDriverID
80201>>>        Integer iDataType
80201>>>
80201>>>        Get psDriverID to sDriverID
80202>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
80203>>>        If (bIsSQLDriver = False) Begin
80205>>>            Function_Return False
80206>>>        End
80206>>>>
80206>>>
80206>>>        Move Err to bErr
80207>>>        Move False to bErr
80208>>>
80208>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
80208>>>        // inserts randomly character(10) and spaces, so we correct from that here:
80208>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
80209>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
80212>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
80214>>>            Move ("[" + String(sValue) + "]") to sValue
80215>>>        End
80215>>>>
80215>>>
80215>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
80218>>>        Move (not(Err)) to bOK
80219>>>        Move bErr to Err
80220>>>
80220>>>        Function_Return bOK
80221>>>    End_Function
80222>>>
80222>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
80224>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
80224>>>        String sDriverID
80224>>>
80224>>>        Get psDriverID to sDriverID
80225>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
80226>>>        If (bIsSQLDriver = False) Begin
80228>>>            Function_Return False
80229>>>        End
80229>>>>
80229>>>
80229>>>        Move Err to bErr
80230>>>        Move False to bErr
80231>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
80234>>>        If (bNullable = bCurrentState) Begin
80236>>>            Function_Return True
80237>>>        End
80237>>>>
80237>>>
80237>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
80240>>>        If (bOpen = False) Begin
80242>>>            Get AutoConnectionIDLogin to bOK
80243>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
80244>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
80245>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
80246>>>            Open hTable
80248>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
80249>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
80250>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
80251>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
80254>>>        End
80254>>>>
80254>>>        If (bOpen = True) Begin
80256>>>            Structure_Start hTable sDriverID
80257>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
80260>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
80261>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
80263>>>            Set Action_Text of ghoStatusPanel to ""
80264>>>        End
80264>>>>
80264>>>
80264>>>        Move (not(Err)) to bOK
80265>>>        Move bErr to Err
80266>>>
80266>>>        Function_Return bOK
80267>>>    End_Function
80268>>>
80268>>>    // Drop column by its table handle
80268>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
80270>>>        String sDriverID sTableName
80270>>>        Boolean bOK
80270>>>
80270>>>        Get psDriverID to sDriverID
80271>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80272>>>        If (bOK = False) Begin
80274>>>            Function_Return False
80275>>>        End
80275>>>>
80275>>>
80275>>>        Get UtilTableHandleToString hTable to sTableName
80276>>>        If (sTableName = "") Begin
80278>>>            Function_Return False
80279>>>        End
80279>>>>
80279>>>
80279>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
80280>>>
80280>>>        Function_Return (bOK = True)
80281>>>    End_Function
80282>>>
80282>>>    // Drop column by its table name as a string.
80282>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
80284>>>        Integer iDbType iDriver
80284>>>        String sDriverID sStmt sAlterTable sDropColumn
80284>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
80284>>>        Handle hTable
80284>>>
80284>>>        Get psDriverID to sDriverID
80285>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80286>>>        If (bOK = False) Begin
80288>>>            Function_Return False
80289>>>        End
80289>>>>
80289>>>
80289>>>        Get DriverIndex sDriverID to iDriver
80290>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
80293>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
80296>>>
80296>>>        Get UtilTableNameToHandle sTableName to hTable
80297>>>        If (hTable <> 0) Begin
80299>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
80300>>>            If (bExists = False) Begin
80302>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
80305>>>                Function_Return False
80306>>>            End
80306>>>>
80306>>>        End
80306>>>>
80306>>>
80306>>>        Get piDbType to iDbType
80307>>>        If (iDbType = EN_DbTypeMSSQL) Begin
80309>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
80310>>>            Get UtilDeleteCacheFile sTableName to bOK
80311>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
80314>>>            Function_Return bOK
80315>>>        End
80315>>>>
80315>>>
80315>>>        Move False to Err
80316>>>        Get _SqlProperTableName sTableName    to sTableName
80317>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
80318>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
80319>>>
80319>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
80320>>>        Send SqlUtilExecuteQuery sStmt sDriverID
80321>>>        Move (not(Err)) to bRetval
80322>>>
80322>>>        // We also need to remove the cache-file since the table has been changed
80322>>>        Get UtilDeleteCacheFile sTableName to bOK
80323>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
80326>>>
80326>>>        Function_Return bRetval
80327>>>    End_Function
80328>>>
80328>>>    // Rename a field/column by table handle (filelist number)
80328>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
80330>>>        String sDriverID sTableName
80330>>>        Boolean bOK
80330>>>
80330>>>        Get psDriverID to sDriverID
80331>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80332>>>        If (bOK = False) Begin
80334>>>            Function_Return False
80335>>>        End
80335>>>>
80335>>>
80335>>>        Get UtilTableHandleToString hTable to sTableName
80336>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
80337>>>
80337>>>        Function_Return (Err = False)
80338>>>    End_Function
80339>>>
80339>>>    // Rename a field/column by table name.
80339>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
80341>>>        Integer iDbType iDataType
80341>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
80341>>>        Boolean bOK bRetval
80341>>>        Handle hTable
80341>>>
80341>>>        Move sTableName to sOrgTableName
80342>>>        Get psDriverID to sDriverID
80343>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80344>>>        If (bOK = False) Begin
80346>>>            Function_Return False
80347>>>        End
80347>>>>
80347>>>
80347>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
80348>>>        If (sVal = "") Begin
80350>>>            Function_Return False
80351>>>        End
80351>>>>
80351>>>
80351>>>        Get piDbType to iDbType
80352>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
80353>>>        Get _SqlProperTableName sTableName     to sTableName
80354>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
80355>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
80356>>>
80356>>>        Case Begin
80356>>>            Case (iDbType = EN_dbTypeMSSQL)
80358>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
80359>>>                Case Break
80360>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
80360>>>            Case (iDbType = EN_dbTypeOracle)
80363>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
80364>>>                Case Break
80365>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
80365>>>            Case (iDbType = EN_dbTypeDB2)
80368>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
80369>>>                Case Break
80370>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
80370>>>            Case (iDbType = EN_dbTypePostgre)
80373>>>                Move sOrgTableName to sTableName
80374>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
80375>>>                Case Break
80376>>>            Case (iDbType = EN_dbTypeMySQL)
80379>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
80379>>>                Move sOrgTableName to sTableName
80380>>>                Get psDatabase to sDatabase
80381>>>                Get UtilTableNameToHandle sTableName to hTable
80382>>>                If (hTable = 0) Begin
80384>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
80385>>>                    If (bOK = False) Begin
80387>>>                        Function_Return False
80388>>>                    End
80388>>>>
80388>>>                    Get NextFreeFilelistSlot to hTable
80389>>>                End
80389>>>>
80389>>>                Else Begin
80390>>>                    Open hTable
80392>>>                End
80392>>>>
80392>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
80393>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
80394>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
80395>>>                Case Break
80396>>>            Case Else
80396>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
80397>>>        Case End
80397>>>
80397>>>        Move False to Err
80398>>>        Send SqlUtilExecuteQuery sStmt sDriverID
80399>>>        Move (Err = False) to bRetval
80400>>>        // We also need to remove the cache-file since the table has been changed
80400>>>        Get UtilDeleteCacheFile sTableName to bOK
80401>>>
80401>>>        Function_Return bRetval
80402>>>    End_Function
80403>>>
80403>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
80405>>>        Handle hoSQLHandler hSQLConnect hStmt
80405>>>        Boolean bMertechDriver
80405>>>        Integer iNumCols iCount iDataType
80405>>>        String sValue
80405>>>
80405>>>        Get IsMertechDriver sDriverID to bMertechDriver
80406>>>        If (bMertechDriver = False) Begin
80408>>>            Get phoSQLManager to hoSQLHandler
80409>>>        End
80409>>>>
80409>>>        Else Begin
80410>>>            Get _MertechSQLManagerHandle to hoSQLHandler
80411>>>        End
80411>>>>
80411>>>
80411>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
80412>>>        If (hSQLConnect <> 0) Begin
80414>>>            Get SQLOpen of hSQLConnect to hStmt
80415>>>            If (hStmt <> 0) Begin
80417>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
80418>>>
80418>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
80419>>>                For iCount from 1 to iNumCols
80425>>>>
80425>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
80426>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
80428>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
80429>>>                        Move iNumCols to iCount // We're out of here
80430>>>                    End
80430>>>>
80430>>>                Loop
80431>>>>
80431>>>
80431>>>                Send SQLClose of hStmt
80432>>>            End
80432>>>>
80432>>>            Send SQLDisconnect of hSQLConnect
80433>>>        End
80433>>>>
80433>>>
80433>>>        Function_Return iDataType
80434>>>    End_Function
80435>>>
80435>>>    // * Dummy function for the Studio's Code Explorer *
80435>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
80437>>>        Function_Return False
80438>>>    End_Function
80439>>>
80439>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
80441>>>        String sMessage // sConnectionString
80441>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
80441>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
80441>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
80444>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
80444>>>        TimeSpan tsQuery tsFetch
80444>>>        tSqlErrorArray aSqlErrorArray
80444>>>        tSqlErrorArray aSqlErrorArray
80444>>>        Boolean bOK bMertechDriver bShowProgress
80444>>>        tSQLConnection SQLConnection
80444>>>        tSQLConnection SQLConnection
80444>>>
80444>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80445>>>        If (bOK = False) Begin
80447>>>            Procedure_Return
80448>>>        End
80448>>>>
80448>>>
80448>>>        If (num_arguments > 2) Begin
80450>>>            Move bShowProgr to bShowProgress
80451>>>        End
80451>>>>
80451>>>
80451>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80452>>>
80452>>>        Get IsMertechDriver sDriverID to bMertechDriver
80453>>>        If (bMertechDriver = True) Begin
80455>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
80456>>>        End
80456>>>>
80456>>>        If (bMertechDriver = False) Begin
80458>>>            Get phoSQLManager to hoSqlHandler
80459>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
80460>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
80461>>>        End
80461>>>>
80461>>>
80461>>>        If (hoSQLConnect <> 0) Begin
80463>>>            Get SqlOpen of hoSQLConnect to hoStmt
80464>>>            If (hoStmt <> 0) Begin
80466>>>                // record starting date/time stamp
80466>>>                Move (CurrentDateTime()) to dtQueryExecStart
80467>>>                // turn on error handling if enabled
80467>>>                If (pbHandleQueryErrors(Self)) Begin
80469>>>                    Set pbSqlError to False
80470>>>                    Set paSqlErrorArray to aSqlErrorArray
80471>>>                    Move Error_Object_Id to hoError
80472>>>                    If (ghoDbUpdateHandler <> 0) Begin
80474>>>                        Move ghoDbUpdateHandler to Error_Object_Id
80475>>>                    End
80475>>>>
80475>>>                    Else Begin
80476>>>                        Move Self to Error_Object_Id
80477>>>                    End
80477>>>>
80477>>>                End
80477>>>>
80477>>>
80477>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
80477>>>                Set psSQLStatementString to sStmt
80478>>>                Send Cursor_Wait of Cursor_Control
80479>>>                Send SqlExecDirect of hoStmt sStmt
80480>>>                Send Cursor_Ready of Cursor_Control
80481>>>
80481>>>                If (pbHandleQueryErrors(Self)) Begin
80483>>>                    Move hoError to Error_Object_Id
80484>>>                End
80484>>>>
80484>>>
80484>>>                Move 0 to iMsgs
80485>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
80485>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
80485>>>                If (bMertechDriver = False) Begin
80487>>>                    Move Err to iErr
80488>>>                    Move LastErr to iLastErr
80489>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
80490>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
80491>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
80492>>>                    Send _SqlColumnInfo hoStmt
80493>>>                    Send Ignore_Error of Error_Object_Id 12289
80494>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
80495>>>                    Repeat
80495>>>>
80495>>>                        Get SqlFetch of hoStmt to iFetchResult
80496>>>                        If (iFetchResult <> 0) Begin
80498>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
80499>>>                        End
80499>>>>
80499>>>                    Until (iFetchResult = 0)
80501>>>                    Send Trap_Error of Error_Object_Id 12289
80502>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
80503>>>                    Move iErr to Err
80504>>>                    Move iLastErr to LastErr
80505>>>                    Set paSQLFetchResults to aSQLFetchResults
80506>>>                End
80506>>>>
80506>>>
80506>>>                Set piRows    to iRows
80507>>>                Set piRowType to iRowType
80508>>>                Move (CurrentDateTime()) to dtQueryExecEnd
80509>>>                Move (CurrentDateTime()) to dtFetchStart
80510>>>
80510>>>                If (iMsgs <> 0) Begin
80512>>>                    If (ghoDbUpdateHandler > 0) Begin
80514>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
80515>>>                    End
80515>>>>
80515>>>                    For i from 1 to iMsgs
80521>>>>
80521>>>                        Get SqlGetMessage of hoStmt i to sMessage
80522>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
80523>>>                        If (bShowProgress = True) Begin
80525>>>                            If (Active_State(ghoStatusPanel)) Begin
80527>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
80528>>>                            End
80528>>>>
80528>>>                            Else Begin
80529>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
80531>>>                            End
80531>>>>
80531>>>                        End
80531>>>>
80531>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
80532>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
80533>>>                    Loop
80534>>>>
80534>>>                    If (ghoDbUpdateHandler > 0) Begin
80536>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
80537>>>                    End
80537>>>>
80537>>>                    Set paQueryMessages to sMsg
80538>>>                End
80538>>>>
80538>>>                Else Begin
80539>>>                    If (bShowProgress = True) Begin
80541>>>                        Get paSqlErrorArray to aSqlErrorArray
80542>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
80544>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
80545>>>                            Decrement iMsgs
80546>>>                            For i from 0 to iMsgs
80552>>>>
80552>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
80555>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
80558>>>                            Loop
80559>>>>
80559>>>                        End
80559>>>>
80559>>>                    End
80559>>>>
80559>>>                End
80559>>>>
80559>>>                Move (CurrentDateTime()) to dtFetchEnd
80560>>>            End
80560>>>>
80560>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
80561>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
80562>>>            Set ptsQueryExec to tsQuery
80563>>>            Set ptsFetchResults to tsFetch
80564>>>            Send SqlClose of hoStmt
80565>>>        End
80565>>>>
80565>>>
80565>>>        Send SqlDisconnect of hoSQLConnect
80566>>>    End_Procedure
80567>>>
80567>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
80567>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
80567>>>    // Returns False if no error occured.
80567>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
80569>>>        Boolean bOK bShowProgress
80569>>>        tSQLScriptArray SQLScriptArray
80569>>>        tSQLScriptArray SQLScriptArray
80569>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
80569>>>        TimeSpan tsTotalTime
80569>>>
80569>>>        Move (CurrentDateTime()) to dtTotalQueryStart
80570>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
80571>>>        If (SQLScriptArray.bError = True) Begin
80573>>>            Function_Return False
80574>>>        End
80574>>>>
80574>>>
80574>>>        If (num_arguments > 3) Begin
80576>>>            Move bShowProgr to bShowProgress
80577>>>        End
80577>>>>
80577>>>
80577>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
80578>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
80579>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
80580>>>
80580>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
80581>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
80582>>>        Set ptsTotalQueryTime to tsTotalTime
80583>>>
80583>>>        Function_Return bOK
80584>>>    End_Function
80585>>>
80585>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
80585>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
80585>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
80585>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
80587>>>        Integer iChannel iArgumentSize iCount
80587>>>        Number nByteCount
80587>>>        String sSQLScript
80587>>>        tSQLScriptArray SqlScriptArray
80587>>>        tSQLScriptArray SqlScriptArray
80587>>>        UChar[] uCharData
80588>>>
80588>>>        Move False to Err
80589>>>        Get Seq_New_Channel to iChannel
80590>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
80592>>>            Error DFERR_PROGRAM 'No channel available...'
80593>>>>
80593>>>            Move True to SqlScriptArray.bError
80594>>>            Function_Return SqlScriptArray
80595>>>        End
80595>>>>
80595>>>
80595>>>        // First decide the size of the script
80595>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
80597>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
80599>>>        Close_Input channel iChannel
80601>>>
80601>>>        Move (SizeOfArray(uCharData)) to nByteCount
80602>>>        If (nByteCount  < 1) Begin
80604>>>            Send Seq_Release_Channel iChannel
80605>>>            Move True to SqlScriptArray.bError
80606>>>            Function_Return SqlScriptArray
80607>>>        End
80607>>>>
80607>>>
80607>>>        // If necessary change the string argument_size
80607>>>        // Read the script file from memory line-by-line
80607>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
80609>>>            Move 0 to iCount
80610>>>            Repeat
80610>>>>
80610>>>                Readln channel iChannel sSQLScript
80612>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
80613>>>                Increment iCount
80614>>>            Until (SeqEof = True)
80616>>>        Close_Input channel iChannel
80618>>>        Send Seq_Release_Channel iChannel
80619>>>
80619>>>        // Finally "sanitize" the script by removing all comments.
80619>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
80620>>>
80620>>>        Function_Return SqlScriptArray
80621>>>    End_Function
80622>>>
80622>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
80624>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
80624>>>        Handle hoSql hoSQLConnect hoStmt hoError
80624>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
80624>>>        String[] sMsg aSQLQueryMessages
80626>>>        DateTime dtQueryExecStart dtQueryExecEnd
80626>>>        TimeSpan tsQuery
80626>>>        tSqlErrorArray aSqlErrorArray
80626>>>        tSqlErrorArray aSqlErrorArray
80626>>>        tSQLConnection SQLConnection
80626>>>        tSQLConnection SQLConnection
80626>>>        Boolean bMertechDriver bShowProgress
80626>>>
80626>>>        If (num_arguments > 4) Begin
80628>>>            Move bShowProgr to bShowProgress
80629>>>        End
80629>>>>
80629>>>        Get IsMertechDriver sDriverID to bMertechDriver
80630>>>        If (bMertechDriver = False) Begin
80632>>>            Get phoSQLManager to hoSql
80633>>>        End
80633>>>>
80633>>>        Else Begin
80634>>>            Get _MertechSQLManagerHandle to hoSql
80635>>>        End
80635>>>>
80635>>>
80635>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
80636>>>        // There seems to be a problem to pass strings when their value gets really big, aka
80636>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
80636>>>        // or later SqlExecDirect stops working correctly with no error messages!
80636>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
80636>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
80636>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
80636>>>        Get piChunkMax to iChunkMax
80637>>>        Move 0 to iChunkCounter
80638>>>        Move "" to sStmt
80639>>>
80639>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
80640>>>        Move (Character(13) + Character(10)) to sCR
80641>>>
80641>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80642>>>
80642>>>        If (bMertechDriver = True) Begin
80644>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
80645>>>        End
80645>>>>
80645>>>        If (bMertechDriver = False) Begin
80647>>>            Get phoSQLManager  to hoSQL
80648>>>            If (sDriverID = ODBC_DRV_ID) Begin
80650>>>                If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
80652>>>                    Move (Pos(";", SQLConnection.sConnectionString)) to iPos
80653>>>                    If (iPos > 0) Begin
80655>>>                        Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
80656>>>                        Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
80657>>>                    End
80657>>>>
80657>>>                End
80657>>>>
80657>>>            End
80657>>>>
80657>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
80658>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
80659>>>        End
80659>>>>
80659>>>
80659>>>        If (hoSQLConnect <> 0) Begin
80661>>>            Move False to Err
80662>>>            Get SqlOpen of hoSQLConnect to hoStmt
80663>>>            If (hoStmt <> 0) Begin
80665>>>
80665>>>                // If the embedded resource should be written as a script file to disk:
80665>>>                If (bCreateScriptFile = True) Begin
80667>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
80668>>>                    Get vFolderFormat sExportFile to sExportFile
80669>>>                    Move (sExportFile + sMemFileName) to sExportFile
80670>>>                    Get Seq_New_Channel to iOut
80671>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
80673>>>                        Direct_Output channel iOut sExportFile
80675>>>                    End
80675>>>>
80675>>>                End
80675>>>>
80675>>>
80675>>>                // Record starting date/time stamp
80675>>>                Move (CurrentDateTime()) to dtQueryExecStart
80676>>>                // Turn on error handling if enabled
80676>>>                If (pbHandleQueryErrors(Self)) Begin
80678>>>                    Set pbSqlError to False
80679>>>                    Set paSqlErrorArray to aSqlErrorArray
80680>>>                    Move Error_Object_Id to hoError
80681>>>                    Move Self to Error_Object_Id
80682>>>                End
80682>>>>
80682>>>
80682>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
80683>>>                Decrement iRows
80684>>>                If (sDriverID = MSSQLDRV_ID) Begin
80686>>>                    Move (sNoCountKeyWord + sCR) to sStmt
80687>>>                End
80687>>>>
80687>>>
80687>>>                For iCount from 0 to iRows
80693>>>>
80693>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
80694>>>
80694>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
80696>>>                        If (sSQLVal <> "") Begin
80698>>>                            Move (sSQLVal + sCR) to sSQLVal
80699>>>                        End
80699>>>>
80699>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
80700>>>                    End
80700>>>>
80700>>>
80700>>>                    // - Each time we encounter a "GO" statement we execute it,
80700>>>                    // or if at the very end of the script.
80700>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
80702>>>
80702>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
80702>>>                        // instead of all in one go.
80702>>>                        Send SqlExecDirect of hoStmt sStmt
80703>>>
80703>>>                        If (bCreateScriptFile = True) Begin
80705>>>                            Write channel iOut sStmt
80707>>>                        End
80707>>>>
80707>>>                        Move "" to sStmt
80708>>>                        Move 0 to iChunkCounter
80709>>>                    End
80709>>>>
80709>>>                    Increment iChunkCounter
80710>>>                Loop
80711>>>>
80711>>>
80711>>>                // ToDo: This sometimes generates a GPF with Mertech drivers;
80711>>>                //       so not used for now.
80711>>>                If (bMertechDriver = False) Begin
80713>>>                    Repeat
80713>>>>
80713>>>                        If (pbHandleQueryErrors(Self)) Begin
80715>>>                            Move hoError to Error_Object_Id
80716>>>                        End
80716>>>>
80716>>>                        Move (CurrentDateTime()) to dtQueryExecEnd
80717>>>
80717>>>                        Send _SqlColumnInfo hoStmt
80718>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
80719>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
80720>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
80721>>>                        Set piRows    to iRows
80722>>>                        Set piRowType to iRowType
80723>>>
80723>>>                        If (iMsgs <> 0) Begin
80725>>>                            If (ghoDbUpdateHandler > 0) Begin
80727>>>                                Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
80728>>>                            End
80728>>>>
80728>>>                            For i from 1 to iMsgs
80734>>>>
80734>>>                                Get SqlGetMessage of hoStmt i to sMessage
80735>>>                                Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
80736>>>                                If (bShowProgress = True) Begin
80738>>>                                    If (Active_State(ghoStatusPanel)) Begin
80740>>>                                        Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
80741>>>                                    End
80741>>>>
80741>>>                                    Else Begin
80742>>>                                        Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
80744>>>                                    End
80744>>>>
80744>>>                                End
80744>>>>
80744>>>                                Move sMessage to sMsg[SizeOfArray(sMsg)]
80745>>>                                Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
80746>>>                            Loop
80747>>>>
80747>>>
80747>>>
80747>>>                            If (ghoDbUpdateHandler > 0) Begin
80749>>>                                Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
80750>>>                            End
80750>>>>
80750>>>                            Set paQueryMessages to sMsg
80751>>>                        End
80751>>>>
80751>>>
80751>>>                        Get SQLNextResultSet of hoStmt to iNextSet
80752>>>                    Until (iNextSet = 0)
80754>>>                End
80754>>>>
80754>>>                Move (CurrentDateTime()) to dtQueryExecEnd
80755>>>            End
80755>>>>
80755>>>
80755>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
80756>>>            Set ptsQueryExec to tsQuery
80757>>>            Send SqlClose of hoStmt
80758>>>
80758>>>            If (bCreateScriptFile = True) Begin
80760>>>                Close_Output channel iOut
80762>>>                Send Seq_Release_Channel iOut
80763>>>            End
80763>>>>
80763>>>        End
80763>>>>
80763>>>        Send SqlDisconnect of hoSQLConnect
80764>>>
80764>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
80765>>>    End_Function
80766>>>
80766>>>    // * Dummy function for the Studio's Code Explorer *
80766>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
80768>>>        Function_Return False
80769>>>    End_Function
80770>>>
80770>>>    // Does three things with auxilirary files;
80770>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
80770>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
80770>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
80770>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
80772>>>        String sDataPath sDDSrcPath sDriverID
80772>>>        Boolean bOK bExists bMertechDriver
80772>>>        Integer iCount iCh iPos
80772>>>
80772>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
80772>>>        If (sTableName contains ".") Begin
80774>>>            Move (Pos(".", sTableName)) to iPos
80775>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
80776>>>        End
80776>>>>
80776>>>
80776>>>        Get psDriverID to sDriverID
80777>>>        Get psDataPathFirstPart to sDataPath
80778>>>        Get vFolderExists sDataPath to bOK
80779>>>        If (bOK = False) Begin
80781>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
80782>>>>
80782>>>            Function_Return False
80783>>>        End
80783>>>>
80783>>>
80783>>>        Get IsMertechDriver sDriverID to bMertechDriver
80784>>>        // First delete the cache file:
80784>>>        Get UtilDeleteCacheFile sTableName to bOK
80785>>>
80785>>>        Get Seq_New_Channel to iCh
80786>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
80788>>>            Function_Return False
80789>>>        End
80789>>>>
80789>>>
80789>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
80790>>>        If (bExists = False) Begin
80792>>>            Function_Return False
80793>>>        End
80793>>>>
80793>>>
80793>>>        Get SqlUtilUpdateIntFile hTable to bOK
80794>>>        // Add the new column name to the .tag filen (if it doesn't exist):
80794>>>        Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
80795>>>
80795>>>        // If in development environment; output new .fd file:
80795>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
80796>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
80797>>>        If (iCount > 1) Begin
80799>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
80800>>>        End
80800>>>>
80800>>>        Get vFolderExists sDDSrcPath to bExists
80801>>>        If (bExists = True) Begin
80803>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
80804>>>            Move False to Err
80805>>>            Get AutoConnectionIDLogin to bOK
80806>>>            If (hTable <> 0) Begin
80808>>>                Open hTable
80810>>>            End
80810>>>>
80810>>>            Else Begin
80811>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
80812>>>            End
80812>>>>
80812>>>
80812>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
80815>>>            If (bOK = True) Begin
80817>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
80819>>>            End
80819>>>>
80819>>>            If (Err = True) Begin
80821>>>                Move False to bOK
80822>>>            End
80822>>>>
80822>>>        End
80822>>>>
80822>>>
80822>>>        Function_Return (bOK = True)
80823>>>    End_Function
80824>>>
80824>>>    Function UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
80826>>>        Integer iChIn iChOut // iCount
80826>>>        Boolean bExists
80826>>>        String sExistingColumn
80826>>>
80826>>>        Move False to bExists
80827>>>        Get Seq_New_Channel to iChIn
80828>>>        Get Seq_New_Channel to iChOut
80829>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
80831>>>            Function_Return True
80832>>>        End
80832>>>>
80832>>>
80832>>>        Move False to Err
80833>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
80833>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
80835>>>        While (not(SeqEof))
80839>>>            Readln channel iChIn sExistingColumn
80841>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
80843>>>                Move True to bExists
80844>>>            End
80844>>>>
80844>>>            If (Trim(sExistingColumn) = "") Begin
80846>>>                Move True to SeqEof
80847>>>            End
80847>>>>
80847>>>        Loop
80848>>>>
80848>>>        Close_Input channel iChIn
80850>>>        Send Seq_Release_Channel iChIn
80851>>>
80851>>>        If (bExists = False) Begin
80853>>>            Append_Output channel iChOut sFullTAGFileName
80855>>>            Writeln channel iChOut sColumnName
80858>>>            Close_Output channel iChOut
80860>>>            Send Seq_Release_Channel iChOut
80861>>>        End
80861>>>>
80861>>>
80861>>>        Function_Return (Err = False)
80862>>>    End_Function
80863>>>
80863>>>    // Message for changing .int files to use connection ID's
80863>>>    //
80863>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
80863>>>    // OR changes an existing connection id to a new id.
80863>>>    // Pass the full path to the data folder and the name of the connection id (string value).
80863>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
80863>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
80865>>>        String sFileName sDriverID sDriverFile sConnectionString
80865>>>        String[] sFilesData
80866>>>        Boolean bOK bCancel
80866>>>        Integer iSize iCount
80866>>>
80866>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
80867>>>        Move (SizeOfArray(sFilesData))    to iSize
80868>>>        If (iSize = 0) Begin
80870>>>            If (ghoStatusPanel <> 0) Begin
80872>>>                If (Active_State(ghoStatusPanel)) Begin
80874>>>                    Send Stop_StatusPanel of ghoStatusPanel
80875>>>                End
80875>>>>
80875>>>            End
80875>>>>
80875>>>            Send Info_Box CS_DUF_NoIntFilesFound
80876>>>            Procedure_Return
80877>>>        End
80877>>>>
80877>>>
80877>>>        Move (Trim(sConnectionID)) to sConnectionID
80878>>>        Get vFolderFormat sDataPath to sDataPath
80879>>>        Decrement iSize
80880>>>        For iCount from 0 to iSize
80886>>>>
80886>>>            Move sFilesData[iCount] to sFileName
80887>>>            // This makes sure that we also can change an existing connection id to something new:
80887>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
80888>>>            If (ghoStatusPanel <> 0) Begin
80890>>>                If (Active_State(ghoStatusPanel)) Begin
80892>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
80893>>>                    If (bCancel = True) Begin
80895>>>                        Send Deactivate of ghoStatusPanel
80896>>>                        Procedure_Return
80897>>>                    End
80897>>>>
80897>>>                End
80897>>>>
80897>>>            End
80897>>>>
80897>>>        Loop
80898>>>>
80898>>>
80898>>>        Get psDriverID to sDriverID
80899>>>
80899>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
80899>>>        Move "" to sFileName
80900>>>        If (sDriverID = MSSQLDRV_ID) Begin
80902>>>            Move "MSSQLDrv.int" to sFileName
80903>>>        End
80903>>>>
80903>>>        If (sDriverID = DB2_DRV_ID) Begin
80905>>>            Move "DB2_Drv.int" to sFileName
80906>>>        End
80906>>>>
80906>>>        If (sDriverID = ODBC_DRV_ID) Begin
80908>>>            Move "ODBC_Drv.int" to sFileName
80909>>>        End
80909>>>>
80909>>>        If (sFileName <> "") Begin
80911>>>            Move "" to sDriverFile
80912>>>            Get_File_Path sFileName to sDriverFile
80913>>>            If (sDriverFile <> "") Begin
80915>>>                Get psConnectionString to sConnectionString
80916>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
80917>>>            End
80917>>>>
80917>>>        End
80917>>>>
80917>>>    End_Procedure
80918>>>
80918>>>    // Checks if the database exists in SQL. Returns = True if it does.
80918>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
80920>>>        String[] sDatabaseArray
80921>>>        String sVal sServer sDriverID
80921>>>        Integer iCount iSize iPos
80921>>>        Boolean bExists
80921>>>        tSQLConnection SQLConnection
80921>>>        tSQLConnection SQLConnection
80921>>>
80921>>>        Move False to bExists
80922>>>        Get psDriverID to sDriverID
80923>>>        // DB2 doesn't have a "Database" name, so we always return True.
80923>>>        If (sDriverID = DB2_DRV_ID) Begin
80925>>>            Function_Return bExists
80926>>>        End
80926>>>>
80926>>>
80926>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
80927>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
80929>>>            Function_Return False
80930>>>        End
80930>>>>
80930>>>
80930>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80931>>>        Move SQLConnection.sServer to sServer
80932>>>
80932>>>        // Special code to handle a FILEDSN that also can contain "/"
80932>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
80934>>>            Move sDatabaseArray[0] to sVal  // Dummy!
80935>>>        End
80935>>>>
80935>>>        Else If (sServer contains "/") Begin
80938>>>            Move (Pos("/", sServer)) to iPos
80939>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
80940>>>        End
80940>>>>
80940>>>
80940>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
80941>>>        Decrement iSize
80942>>>        For iCount from 0 to iSize
80948>>>>
80948>>>            Move sDatabaseArray[iCount] to sVal
80949>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
80951>>>                Move True to bExists
80952>>>                If (bExists = True) Begin
80954>>>                    Move iSize to iCount // We're done.
80955>>>                End
80955>>>>
80955>>>            End
80955>>>>
80955>>>        Loop
80956>>>>
80956>>>
80956>>>        Function_Return bExists
80957>>>    End_Function
80958>>>
80958>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
80958>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
80960>>>        String sDatabase sSchema sTableName sVal
80960>>>        Boolean bExists
80960>>>        String[] sTablesArray
80961>>>        Integer iSize iCount
80961>>>
80961>>>        Move False to bExists
80962>>>        Get UtilTableHandleToString hTable to sTableName
80963>>>        Get psDatabase to sDatabase
80964>>>        Get psSchema   to sSchema
80965>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
80966>>>        Move (SizeOfArray(sTablesArray)) to iSize
80967>>>        Decrement iSize
80968>>>        For iCount from 0 to iSize
80974>>>>
80974>>>            Move sTablesArray[iCount] to sVal
80975>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
80977>>>                Move True to bExists
80978>>>                Move iSize to iCount // We're done!
80979>>>            End
80979>>>>
80979>>>        Loop
80980>>>>
80980>>>
80980>>>        Function_Return bExists
80981>>>    End_Function
80982>>>
80982>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
80982>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
80984>>>        String sDatabase sSchema sVal
80984>>>        Boolean bExists
80984>>>        String[] sTablesArray
80985>>>        Integer iSize iCount
80985>>>
80985>>>        Move False to bExists
80986>>>        Get psDatabase to sDatabase
80987>>>        Get psSchema   to sSchema
80988>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
80989>>>        Move (SizeOfArray(sTablesArray)) to iSize
80990>>>        Decrement iSize
80991>>>        For iCount from 0 to iSize
80997>>>>
80997>>>            Move sTablesArray[iCount] to sVal
80998>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
81000>>>                Move True to bExists
81001>>>                Move iSize to iCount // We're done!
81002>>>            End
81002>>>>
81002>>>        Loop
81003>>>>
81003>>>
81003>>>        Function_Return bExists
81004>>>    End_Function
81005>>>
81005>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
81007>>>        String sVal sTableSpelledCorrectly
81007>>>        Boolean bExists
81007>>>        String[] sTablesArray
81008>>>        Integer iSize iCount
81008>>>
81008>>>        Move False to bExists
81009>>>        Move sTableName to sTableSpelledCorrectly
81010>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
81011>>>        Move (SizeOfArray(sTablesArray)) to iSize
81012>>>        Decrement iSize
81013>>>        For iCount from 0 to iSize
81019>>>>
81019>>>            Move sTablesArray[iCount] to sVal
81020>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
81022>>>                Move sVal to sTableSpelledCorrectly
81023>>>                Move iSize to iCount // We're done!
81024>>>            End
81024>>>>
81024>>>        Loop
81025>>>>
81025>>>
81025>>>        Function_Return sTableSpelledCorrectly
81026>>>    End_Function
81027>>>
81027>>>    // ToDo: This index name function needs to be finished...
81027>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
81029>>>        String sSchema sTableName sDriverID
81029>>>        Boolean bExists
81029>>>
81029>>>        Get psDriverID to sDriverID
81030>>>        Get psSchema to sSchema
81031>>>        Get UtilTableHandleToString hTable to sTableName
81032>>>
81032>>>        Function_Return bExists
81033>>>    End_Function
81034>>>
81034>>>    // Checks if a column/field name exists in a SQL table definition
81034>>>    // Returns True if it does
81034>>>    // Sample:
81034>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
81034>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
81036>>>        Integer iNumColumns iColumn
81036>>>        String sColumn sDriverID
81036>>>        String[] sColumnsArray
81037>>>        Boolean bExists bOK
81037>>>
81037>>>        Move False to bExists
81038>>>        Get AutoConnectionIDLogin to bOK
81039>>>        Get psDriverID to sDriverID
81040>>>
81040>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
81041>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
81042>>>        Decrement iNumColumns
81043>>>        For iColumn from 0 to iNumColumns
81049>>>>
81049>>>            Move sColumnsArray[iColumn] to sColumn
81050>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
81052>>>                Move True to bExists
81053>>>                Move iNumColumns to iColumn // We're out of here
81054>>>            End
81054>>>>
81054>>>        Loop
81055>>>>
81055>>>
81055>>>        Function_Return bExists
81056>>>    End_Function
81057>>>
81057>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
81059>>>        Integer iNumColumns iColumn iDFType iNativeType
81059>>>        Boolean bOpened bOK
81059>>>        String sColumnName sNativeTypeName
81059>>>
81059>>>        Get AutoConnectionIDLogin to bOK
81060>>>        Get OpenTableExclusive hTable to bOK
81061>>>        If (bOK = False) Begin
81063>>>            Function_Return False
81064>>>        End
81064>>>>
81064>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81067>>>        If (bOpened = False) Begin
81069>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
81070>>>>
81070>>>            Function_Return False
81071>>>        End
81071>>>>
81071>>>
81071>>>        Move False to Err
81072>>>
81072>>>        Structure_Start hTable
81073>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
81076>>>
81076>>>            For iColumn from 1 to iNumColumns
81082>>>>
81082>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
81085>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
81088>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
81091>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
81094>>>
81094>>>                Case Begin
81094>>>                    Case (iDFType = DF_DATE)
81096>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
81098>>>                            // Convert datetime to date
81098>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
81101>>>                        End
81101>>>>
81101>>>                        Case Break
81102>>>                    Case (iDFType = DF_DATETIME)
81105>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
81107>>>                            // Convert datetime to datetime2
81107>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
81110>>>                        End
81110>>>>
81110>>>                        Case Break
81111>>>                    Case (iDFType = DF_ASCII)
81114>>>                        If (iNativeType = SQL_CHAR) Begin
81116>>>                            // Convert char to varchar
81116>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
81119>>>                        End
81119>>>>
81119>>>                        Case Break
81120>>>                    Case (iDFType = DF_TEXT)
81123>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
81125>>>                            // Convert text to varchar(max)
81125>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
81128>>>                        End
81128>>>>
81128>>>                        Case Break
81129>>>                    Case (iDFType = DF_BINARY)
81132>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
81134>>>                            // Convert image to varbinary(max)
81134>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
81137>>>                        End
81137>>>>
81137>>>                        Case Break
81138>>>                Case End
81138>>>            Loop
81139>>>>
81139>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
81140>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
81142>>>
81142>>>        Set Action_Text of ghoStatusPanel to ""
81143>>>        Function_Return (Err = False)
81144>>>    End_Function
81145>>>
81145>>>
81145>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
81145>>>    // the DbUpdateVersion database revision in.
81145>>>    // Also pass the file number of the current (embedded?) table number used in development.
81145>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
81145>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
81147>>>        Boolean bOK bOpened
81147>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
81147>>>
81147>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
81150>>>        Get _TableNameOnly sTableName to sTableName
81151>>>        If (sTableName = "") Begin
81153>>>            Function_Return False
81154>>>        End
81154>>>>
81154>>>
81154>>>        // This just creates the table and a "dummy" column.
81154>>>        Get SqlTableCreate hTable sDriverID to bOK
81155>>>        If (bOK = False) Begin
81157>>>            Function_Return False
81158>>>        End
81158>>>>
81158>>>
81158>>>        Close hTable
81159>>>        Move False to Err
81160>>>
81160>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
81161>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
81162>>>        Move "Decimal" to sDataType
81163>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
81164>>>
81164>>>        // Adds the "sColumnName" passed to the function
81164>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
81165>>>        Send SqlUtilExecuteQuery sStmt sDriverID
81166>>>
81166>>>        // Now we can delete the dummy column:
81166>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
81167>>>
81167>>>        // Finally, we attach to the newly created table.
81167>>>        If (Err = False) Begin
81169>>>            Get ApiTableAttachToSQL hTable True to bOK
81170>>>        End
81170>>>>
81170>>>        Open hTable
81172>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81175>>>
81175>>>        Function_Return (Err = False and bOK = True and bOpened = True)
81176>>>    End_Function
81177>>>
81177>>>    // The table must already exist in the filelist for this function to work.
81177>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
81177>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
81179>>>        Boolean bOK bExists bUseConnectionID bMertech
81179>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
81179>>>        String[] sIndexArray
81180>>>        Integer iCount iCh iSize
81180>>>
81180>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
81181>>>        Get psConnectionString to sConnectionString
81182>>>
81182>>>        Move CS_ANSI_Txt to sANSI_OEM
81183>>>        If (bANSI = False) Begin
81185>>>            Move CS_OEM_Txt to sANSI_OEM
81186>>>        End
81186>>>>
81186>>>
81186>>>        Get psDataPathFirstPart to sDataPath
81187>>>        Get vFolderExists sDataPath to bOK
81188>>>        If (bOK = False) Begin
81190>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
81191>>>>
81191>>>            Function_Return False
81192>>>        End
81192>>>>
81192>>>        Get vFolderFormat sDataPath to sDataPath
81193>>>
81193>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81196>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81199>>>        Get _TableNameOnly sRootName to sDatabaseName
81200>>>        Move sLogicalName  to sPhysicalFileName
81201>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
81202>>>
81202>>>        Get IsMertechDriver sDriverID to bMertech
81203>>>        If (bMertech = True) Begin
81205>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
81205>>>            // Else it will create an error in the error log (although it won't do anything...)
81205>>>            // Get _MertechSqlUtilCreateIntFile hTable sLogicalName sDataPath sPhysicalFileName to bOK
81205>>>            Function_Return (bOK = True)
81206>>>        End
81206>>>>
81206>>>
81206>>>        Get psSchema hTable to sSchemaName
81207>>>        If (sSchemaName = "") Begin
81209>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
81210>>>        End
81210>>>>
81210>>>
81210>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
81210>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
81211>>>        If (bExists = True) Begin
81213>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
81214>>>        End
81214>>>>
81214>>>
81214>>>        Get UtilDeleteCacheFile sRootName to bOK
81215>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
81216>>>
81216>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
81217>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
81222>>>            If (bUseConnectionID = True) Begin
81224>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
81231>>>            End
81231>>>>
81231>>>            Else Begin
81232>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
81239>>>            End
81239>>>>
81239>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
81244>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
81249>>>            // There seems to be a new order how these are set from DF19.
81249>>>            If (bSysFile = True) Begin
81251>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
81256>>>            End
81256>>>>
81256>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
81261>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
81266>>>            If (bSysFile = True) Begin
81268>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
81273>>>            End
81273>>>>
81273>>>
81273>>>            If (bSysFile = False) Begin
81275>>>                Move (SizeOfArray(sIndexArray)) to iSize
81276>>>                Move (SortArray(sIndexArray)) to sIndexArray
81277>>>                If (iSize > 0) Begin
81279>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
81282>>>                    Writeln channel iCh // Just an empty line
81284>>>                End
81284>>>>
81284>>>                Decrement iSize
81285>>>                For iCount from 0 to iSize
81291>>>>
81291>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
81294>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
81297>>>                    Writeln channel iCh
81299>>>                Loop
81300>>>>
81300>>>            End
81300>>>>
81300>>>        Send Seq_Close_Channel iCh
81301>>>
81301>>>        // Wait a sec for Windows to finish writing the file:
81301>>>        Sleep 1
81302>>>
81302>>>        Function_Return (bOK = True)
81303>>>    End_Function
81304>>>
81304>>>    // Returns a handle to the SQL server associated with the passed driver ID.
81304>>>    // Pass e.g. the psServer property to determine the current connection server.
81304>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
81304>>>    // This handle can be used to obtain attributes about the server, such as default
81304>>>    // column types.
81304>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
81306>>>        Handle hDatabase
81306>>>        Integer iDriver iServers iCount
81306>>>        String sValue
81306>>>
81306>>>        If (sServer = "") Begin
81308>>>            Function_Return 0
81309>>>        End
81309>>>>
81309>>>
81309>>>        Get DriverIndex sDriverID to iDriver
81310>>>        If (iDriver = 0) Begin
81312>>>            Function_Return 0
81313>>>        End
81313>>>>
81313>>>
81313>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
81316>>>        For iCount from 1 to iServers
81322>>>>
81322>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
81325>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
81327>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
81330>>>            End
81330>>>>
81330>>>        Loop
81331>>>>
81331>>>
81331>>>        Function_Return hDatabase
81332>>>    End_Function
81333>>>
81333>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
81333>>>//        String sRootName
81333>>>//        Boolean bOK
81333>>>//
81333>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81333>>>//        Move (sRootName contains sDriverID) to bOK
81333>>>//
81333>>>//        Function_Return bOK
81333>>>//    End_Function
81333>>>
81333>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
81333>>>//        String sDriverID sRootName sDisplayName sSchema sVal
81333>>>//        Integer iDbType
81333>>>//        Boolean bOK
81333>>>//
81333>>>//        Get UtilIsFilelistEntryDriverBased to bOK
81333>>>//        If (bOK = True) Begin
81333>>>//            Function_Return False
81333>>>//        End
81333>>>//
81333>>>//        Get psDriverID to sDriverID
81333>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81333>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
81333>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
81333>>>//
81333>>>//        Get psDriverID to sDriverID
81333>>>//        Get piDbType   to iDbType
81333>>>//        Get psSchema   to sSchema
81333>>>//        If (sSchema = "") Begin
81333>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81333>>>//        End
81333>>>//
81333>>>//        Move (Uppercase(sDisplayName)) to sVal
81333>>>//        If (not(sVal contains (sSchema + "."))) Begin
81333>>>//            If (iDbType = EN_dbTypeDB2) Begin
81333>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
81333>>>//            End
81333>>>//            Else Begin
81333>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
81333>>>//            End
81333>>>//        End
81333>>>//
81333>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81333>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
81333>>>//
81333>>>//        Function_Return True
81333>>>//    End_Function
81333>>>
81333>>>    // Removes all driver identifications (e.g. "MSSQLDRV;MyTable" or "MyTable.MSSQLDRV"
81333>>>    // from the passed filelist.
81333>>>    // Returns the number of tables affected.
81333>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
81335>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
81335>>>        Integer iRetval
81335>>>        Handle hTable
81335>>>
81335>>>        // We first save the current filelist as the passed filelist name
81335>>>        // may come from another workspace, to restore it when we're ready.
81335>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
81338>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
81341>>>        Move 0 to hTable
81342>>>        Move 0 to iRetval
81343>>>
81343>>>        Repeat
81343>>>>
81343>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81346>>>            If (hTable <> 0) Begin
81348>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81351>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
81354>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81357>>>                Move (Uppercase(sRootName)) to sVal
81358>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
81360>>>                    // Prefixes:
81360>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
81361>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
81362>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
81363>>>                    // Suffixes:
81363>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
81364>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
81365>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
81366>>>
81366>>>                    // Change Filelist entry:
81366>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
81369>>>
81369>>>                    Move (Lowercase(sDisplayName)) to sVal
81370>>>                    If (sVal contains "dbo.") Begin
81372>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
81373>>>
81373>>>                        // Change Filelist entry:
81373>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
81376>>>                    End
81376>>>>
81376>>>                    Increment iRetval
81377>>>                End
81377>>>>
81377>>>            End
81377>>>>
81377>>>        Until (hTable = 0)
81379>>>
81379>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
81382>>>
81382>>>        Function_Return iRetval
81383>>>    End_Function
81384>>>
81384>>>    // To open all Sql based tables in Filelist.cfg
81384>>>    Procedure SqlUtilOpenAllTables
81386>>>        Handle hTable
81386>>>        String sRoot sDriverID
81386>>>        Boolean bOK
81386>>>
81386>>>        Move 0 to hTable
81387>>>        Move "" to sDriverID
81388>>>        Get AutoConnectionIDLogin to bOK
81389>>>
81389>>>        Repeat
81389>>>>
81389>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81392>>>            If (hTable > 0) Begin
81394>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
81397>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
81399>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
81402>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
81404>>>                        Open hTable
81406>>>                    End
81406>>>>
81406>>>                End
81406>>>>
81406>>>            End
81406>>>>
81406>>>
81406>>>        Until (hTable = 0)
81408>>>    End_Procedure
81409>>>
81409>>>//    Function SqlUtilSchemaName Handle hTable Returns String
81409>>>//        String sRetval sDriverID
81409>>>//        String sTableName
81409>>>//        Integer iDbType iIndex
81409>>>//        Boolean bOK
81409>>>//
81409>>>//        Get psDriverID to sDriverID
81409>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
81409>>>//        If (hTable = 0 or bOK = False) Begin
81409>>>//            Function_Return ""
81409>>>//        End
81409>>>//
81409>>>//        Move False to Err
81409>>>//        Get UtilTableHandleToString hTable to sTableName
81409>>>//        Get piDbType to iDbType
81409>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
81409>>>//        If (iIndex = -1) Begin
81409>>>//            Function_Return ""
81409>>>//        End
81409>>>//
81409>>>//        Function_Return sRetval
81409>>>//    End_Function
81409>>>
81409>>>    // Checks if the passed Table;
81409>>>    // 1) Already has a Filelist entry that points to SQL and
81409>>>    // 2) It has an .int file.
81409>>>    // If both is True it should already be connected to SQL
81409>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
81411>>>        Boolean bExists bRootName
81411>>>        String sRootName sDataPath
81411>>>
81411>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81414>>>        Move (sRootName contains sDriverID) to bRootName
81415>>>
81415>>>        Get psDataPathFirstPart to sDataPath
81416>>>        Get vFolderExists sDataPath to bExists
81417>>>        If (bExists = False) Begin
81419>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
81419>>>            Function_Return False
81420>>>        End
81420>>>>
81420>>>
81420>>>        Get vFolderFormat sDataPath to sDataPath
81421>>>        Get _TableNameOnly sRootName to sRootName
81422>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
81423>>>
81423>>>        Function_Return (bRootName = True and bExists = True)
81424>>>    End_Function
81425>>>
81425>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
81427>>>        Boolean bViewTableType bOpen bOK
81427>>>        Integer iTableCount iNumTables
81427>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
81427>>>        Handle hoCliHandler
81427>>>        tSQLConnection SQLConnection
81427>>>        tSQLConnection SQLConnection
81427>>>
81427>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
81430>>>        If (bOpen = False) Begin
81432>>>            Get AutoConnectionIDLogin to bOK
81433>>>            Open hTable
81435>>>        End
81435>>>>
81435>>>
81435>>>        Get pSQLConnection to SQLConnection
81436>>>        Get phoCLIHandler to hoCliHandler
81437>>>        Set psDriverID of hoCliHandler to sDriverID
81438>>>
81438>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
81441>>>        Get _TableNameOnly sTableName to sTableName
81442>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
81445>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
81446>>>
81446>>>        For iTableCount from 1 to iNumTables
81452>>>>
81452>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
81453>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
81454>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
81456>>>                Get TableType of hoCliHandler iTableCount to sTableType
81457>>>                Move iNumTables to iTableCount // We're done.
81458>>>            End
81458>>>>
81458>>>        Loop
81459>>>>
81459>>>
81459>>>        Move (sTableType = "VIEW") to bViewTableType
81460>>>        If (bOpen = False) Begin
81462>>>            Close hTable
81463>>>        End
81463>>>>
81463>>>
81463>>>        Function_Return bViewTableType
81464>>>    End_Function
81465>>>
81465>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
81465>>>    //
81465>>>    // SQL utility function that returns a database type (string) constant
81465>>>    // corresponding to the passed iDbType.
81465>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
81467>>>        String sRetval
81467>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
81468>>>        Function_Return sRetval
81469>>>    End_Function
81470>>>
81470>>>    // SQL utility function that returns a database type constant (integer)
81470>>>    // corresponding to the passed sDbType string constant.
81470>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
81472>>>        Integer iRetval
81472>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
81473>>>        Function_Return iRetval
81474>>>    End_Function
81475>>>
81475>>>    // Pass an integer DbType and function returns the database type integer as a string value.
81475>>>    // Used e.g. when reading a connection ini-file to display the database type in
81475>>>    // the SQL Connection program's grid.
81475>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
81477>>>        String sRetval
81477>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
81478>>>        Function_Return sRetval
81479>>>    End_Function
81480>>>
81480>>>    // Pass a driver name as a string and the function will return
81480>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
81480>>>    // quite work and always returns "MS SQL Server"
81480>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
81482>>>        Integer iRetval
81482>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
81483>>>        Function_Return iRetval
81484>>>    End_Function
81485>>>
81485>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
81485>>>    // that "fits" in the max allowed length for table names.
81485>>>    // Max number of characters allowed for table names;
81485>>>    // IBM DB2      = 128
81485>>>    // MS-SQL       = 128
81485>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
81485>>>    // MySQL        = 64
81485>>>    // PostgreSQL   = 64
81485>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
81487>>>        String sGUIDName
81487>>>        Integer iDbType iLength
81487>>>
81487>>>        Get piDbType to iDbType
81488>>>        Move (RandomHexUUID()) to sGUIDName
81489>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
81490>>>        Move (Length(sGUIDName)) to iLength
81491>>>
81491>>>        Case Begin
81491>>>            Case (iDbType = EN_DbTypeDB2)
81493>>>            If (iLength > 128) Begin
81495>>>                Move (Left(sGUIDName, 128)) to sGUIDName
81496>>>            End
81496>>>>
81496>>>            Case Break
81497>>>
81497>>>            Case (iDbType = EN_DbTypeMSSQL)
81500>>>            If (iLength > 128) Begin
81502>>>                Move (Left(sGUIDName, 128)) to sGUIDName
81503>>>            End
81503>>>>
81503>>>            Case Break
81504>>>
81504>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
81507>>>            If (iLength > 128) Begin
81509>>>                Move (Left(sGUIDName, 128)) to sGUIDName
81510>>>            End
81510>>>>
81510>>>            Case Break
81511>>>
81511>>>            Case (iDbType = EN_DbTypeMySQL)
81514>>>            If (iLength > 64) Begin
81516>>>                Move (Left(sGUIDName, 64)) to sGUIDName
81517>>>            End
81517>>>>
81517>>>            Case Break
81518>>>
81518>>>            Case (iDbType = EN_DbTypePostgre)
81521>>>            If (iLength > 64) Begin
81523>>>                Move (Left(sGUIDName, 64)) to sGUIDName
81524>>>            End
81524>>>>
81524>>>        Case End
81524>>>
81524>>>        Function_Return sGUIDName
81525>>>    End_Function
81526>>>
81526>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
81526>>>    // Pass the memory resource file reference and the filename to be created,
81526>>>    // including full path.
81526>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
81528>>>        String sText
81528>>>        Integer iCh iSize iArgSize
81528>>>
81528>>>        Move ("Resource:" + sMemFileName) to sMemFileName
81529>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
81530>>>        Get_Channel_Size iCh to iSize
81531>>>        Read_Block channel iCh sText iSize
81533>>>        Send Seq_Close_Channel iCh
81534>>>
81534>>>        Get Seq_Open_Output_Channel sFileName to iCh
81535>>>            Write channel iCh sText
81537>>>        Send Seq_Close_Channel iCh
81538>>>
81538>>>        // Wait for file to be written to disk.
81538>>>        Sleep 2
81539>>>    End_Procedure
81540>>>
81540>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
81542>>>        String sNotNull sRetval sDefaultValue
81542>>>        Boolean bOK
81542>>>
81542>>>        Get IsSQLDriver sDriverID to bOK
81543>>>        If (bOK = False) Begin
81545>>>            Function_Return ""
81546>>>        End
81546>>>>
81546>>>
81546>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
81547>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
81548>>>
81548>>>        Case Begin
81548>>>            Case (iDbType = EN_dbTypeMSSQL)
81550>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
81551>>>                Case Break
81552>>>            Case (iDbType = EN_dbTypeMySQL)
81555>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
81556>>>                Case Break
81557>>>            Case (iDbType = EN_dbTypePostgre)
81560>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
81561>>>                Case Break
81562>>>            Case (iDbType = EN_dbTypeDB2)
81565>>>                Move (String(sNotNull))                                     to sRetval
81566>>>                Case Break
81567>>>
81567>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
81567>>>            // ToDo: We need to look deeper into how Oracle handles NULL
81567>>>            Case (iDbType = EN_dbTypeOracle)
81570>>>                Move  ""                                                    to sRetval
81571>>>                Case Break
81572>>>
81572>>>            Case Else
81572>>>                Move  ""                                                    to sRetval
81573>>>        Case End
81573>>>
81573>>>        Function_Return sRetval
81574>>>    End_Function
81575>>>
81575>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
81577>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
81577>>>        Boolean bOpened bOK bMertech
81577>>>
81577>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
81577>>>        // which makes the program unable to run because they can't be opened.
81577>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
81577>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
81577>>>        // proper .int files for the two tables.
81577>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
81579>>>            Function_Return True
81580>>>        End
81580>>>>
81580>>>
81580>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81583>>>        Get _TableNameOnly sRootName to sDatabaseName
81584>>>        Move CS_OEM_Txt  to sOrgFormat
81585>>>        Move CS_ANSI_Txt to sNewFormat
81586>>>        Get AutoConnectionIDLogin to bOK
81587>>>
81587>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
81587>>>        Sleep 1
81588>>>
81588>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81591>>>        If (bOpened = False) Begin
81593>>>            Open hTable
81595>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
81598>>>        End
81598>>>>
81598>>>        If (bOpened = False) Begin
81600>>>            Function_Return False
81601>>>        End
81601>>>>
81601>>>
81601>>>        Get psDriverID to sDriverID
81602>>>        Get IsMertechDriver sDriverID to bMertech
81603>>>        If (bMertech = True) Begin
81605>>>            Get psDataPathFirstPart to sDataPath
81606>>>            Get vFolderExists sDataPath to bOK
81607>>>            If (bOK = False) Begin
81609>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
81610>>>>
81610>>>                Function_Return False
81611>>>            End
81611>>>>
81611>>>            Get vFolderFormat sDataPath to sDataPath
81612>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81615>>>            Get _TableNameOnly sRootName to sDatabaseName
81616>>>            Move sDatabaseName to sPhysicalFileName
81617>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
81618>>>            Get _MertechSqlUtilCreateIntFile hTable sDatabaseName sDataPath sPhysicalFileName to bOK
81619>>>            Function_Return (bOK = True)
81620>>>        End
81620>>>>
81620>>>
81620>>>        Move False to Err
81621>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81624>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
81625>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81625>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81625>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81626>>>
81626>>>        Move False to Err
81627>>>
81627>>>        If (hTable > 0) Begin
81629>>>            Structure_Start hTable
81630>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81633>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81636>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
81638>>>        End
81638>>>>
81638>>>        Else Begin
81639>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81642>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81645>>>        End
81645>>>>
81645>>>        Function_Return (Err = False)
81646>>>    End_Function
81647>>>
81647>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
81649>>>        String[] sReturnArray
81650>>>        String sValue // sUserID sPassword
81650>>>        Handle hoSQLHandler hoSQLConnect hStmt
81650>>>        Integer iFetchResult iRetval
81650>>>        tSQLConnection SQLConnection
81650>>>        tSQLConnection SQLConnection
81650>>>
81650>>>        Get _MertechSQLManagerHandle to hoSQLHandler
81651>>>        If (hoSQLHandler <> 0) Begin
81653>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81654>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
81655>>>            If (hoSQLConnect <> 0) Begin
81657>>>                Get SQLOpen of hoSQLConnect to hStmt
81658>>>                If (hStmt <> 0) Begin
81660>>>                    Send SQLSetProcedureName of hStmt sStmt
81661>>>                    If (sArgument <> "") Begin
81663>>>                        Send SqlSetArgument  of hStmt 1 sArgument
81664>>>                    End
81664>>>>
81664>>>                    Send SQLCall of hStmt
81665>>>
81665>>>                    Get SqlReturnValue       of hStmt to iRetval
81666>>>                    If (iRetval = 0) Begin
81668>>>                        Repeat
81668>>>>
81668>>>                            Get SQLFetch of hStmt to iFetchResult
81669>>>                            If (iFetchResult <> 0) Begin
81671>>>                                Get SQLColumnValue of hStmt 1 to sValue
81672>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
81673>>>                            End
81673>>>>
81673>>>                        Until (iFetchResult = 0)
81675>>>                        Send SQLClose of hStmt
81676>>>                    End
81676>>>>
81676>>>                End
81676>>>>
81676>>>                Send SQLDisconnect of hoSQLConnect
81677>>>            End
81677>>>>
81677>>>        End
81677>>>>
81677>>>
81677>>>        Function_Return sReturnArray
81678>>>    End_Function
81679>>>
81679>>>    // * Dummy function for the Studio's Code Explorer *
81679>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
81681>>>        Function_Return False
81682>>>    End_Function
81683>>>
81683>>>    // Enumerate SQL Servers.
81683>>>    // Pass a driver id. Returns a string array.
81683>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
81683>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
81683>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
81685>>>        String[] sReturnArray
81686>>>        Handle hoSQLHandler
81686>>>        String sServer
81686>>>        Integer iCount iNumItems iDataSourceType
81686>>>
81686>>>        If (num_arguments > 1) Begin
81688>>>            Move iDatSrcType to iDataSourceType
81689>>>        End
81689>>>>
81689>>>
81689>>>        Case Begin
81689>>>            Case (sDriverID = MSSQLDRV_ID)
81691>>>                Get phoMSSQLHandler to hoSQLHandler
81692>>>                Get EnumerateServers of hoSQLHandler to iNumItems
81693>>>                For iCount from 0 to (iNumItems - 1)
81699>>>>
81699>>>                    Get String_Value of hoSQLHandler iCount to sServer
81700>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
81701>>>                Loop
81702>>>>
81702>>>                Case Break
81703>>>
81703>>>            Case (sDriverID = DB2_DRV_ID)
81706>>>                Get phoDB2SQLHandler to hoSQLHandler
81707>>>                Send SeedDataSources of hoSQLHandler
81708>>>                Move 0 to iCount
81709>>>                Repeat
81709>>>>
81709>>>                    Get DataSources of hoSQLHandler to sServer
81710>>>                    If (sServer <> "") Begin
81712>>>                        Move (Replace(",", sServer, "")) to sServer
81713>>>                        Move sServer to sReturnArray[iCount]
81714>>>                    End
81714>>>>
81714>>>                    Increment iCount
81715>>>                Until (sServer = "")
81717>>>                Case Break
81718>>>
81718>>>            Case (sDriverID = ODBC_DRV_ID)
81721>>>                Get phoODBCSQLHandler to hoSQLHandler
81722>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
81723>>>                Move 0 to iCount
81724>>>                Repeat
81724>>>>
81724>>>                    Get DataSources of hoSQLHandler to sServer
81725>>>                    If (sServer <> "") Begin
81727>>>                        Move (Replace(",", sServer, ", ")) to sServer
81728>>>                        Move sServer to sReturnArray[iCount]
81729>>>                    End
81729>>>>
81729>>>                    Increment iCount
81730>>>                Until (sServer = "")
81732>>>                Case Break
81733>>>
81733>>>            Case (sDriverID = SQLFLEX)
81736>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
81737>>>                Case Break
81738>>>
81738>>>            Case (sDriverID = ORAFLEX)
81741>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
81742>>>                Case Break
81743>>>
81743>>>            // There appearantly is no way to enumerate servers for this backend.
81743>>>            Case (sDriverID = MDSPgSQL)
81746>>>                Move "localhost" to sReturnArray[0]
81747>>>                Case Break
81748>>>
81748>>>            // There appearantly is no way to enumerate servers for this backend.
81748>>>            Case (sDriverID = MDSMySQL)
81751>>>                Move "localhost" to sReturnArray[0]
81752>>>                Case Break
81753>>>
81753>>>            Case Else
81753>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
81754>>>>
81754>>>        Case End
81754>>>
81754>>>        Function_Return sReturnArray
81755>>>    End_Function
81756>>>
81756>>>    // Returns all databases as a string array for the passed driver id.
81756>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
81758>>>        String[] sReturnArray
81759>>>        String sServer sVal
81759>>>        tSQLIntTableInfo[] sReturnStructArray
81759>>>        tSQLIntTableInfo[] sReturnStructArray
81760>>>        tSQLConnection SQLConnection
81760>>>        tSQLConnection SQLConnection
81760>>>        Boolean bOK
81760>>>        Integer iCount iSize
81760>>>
81760>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
81761>>>        If (bOK = False) Begin
81763>>>            Function_Return sReturnArray
81764>>>        End
81764>>>>
81764>>>
81764>>>        Case Begin
81764>>>            Case (sDriverID = MSSQLDRV_ID)
81766>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
81767>>>                Case Break
81768>>>            Case (sDriverID = DB2_DRV_ID)
81771>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
81772>>>                Case Break
81773>>>
81773>>>            // This is needed to be able to check if a database exists or not.
81773>>>            Case (sDriverID = ODBC_DRV_ID)
81776>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
81777>>>                If (SizeOfArray(sReturnStructArray)) Begin
81779>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
81781>>>                        // If a FILEDSN: (can only be one database name)
81781>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
81782>>>                    End
81782>>>>
81782>>>                    Else Begin
81783>>>                        // Else the DSN's were read from the registry.
81783>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81784>>>                        Move SQLConnection.sServer to sServer
81785>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
81786>>>                        Decrement iSize
81787>>>                        for iCount from 0 to iSize
81793>>>>
81793>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
81794>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
81796>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
81797>>>                                Move iSize to iCount // We're done.
81798>>>                            End
81798>>>>
81798>>>                        Loop
81799>>>>
81799>>>                    End
81799>>>>
81799>>>                End
81799>>>>
81799>>>                Case Break
81800>>>
81800>>>            Case (sDriverID = SQLFLEX)
81803>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
81804>>>                Case Break
81805>>>
81805>>>            Case (sDriverID = MDSPgSQL)
81808>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
81809>>>                Case Break
81810>>>
81810>>>            Case (sDriverID = MDSMySQL)
81813>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
81814>>>                Case Break
81815>>>
81815>>>            Case (sDriverID = ORAFLEX)
81818>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
81819>>>                Case Break
81820>>>
81820>>>            Case Else
81820>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
81820>>>        Case End
81820>>>
81820>>>        Function_Return sReturnArray
81821>>>    End_Function
81822>>>
81822>>>    // Returns all table spaces as a string array for the passed driver id.
81822>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
81824>>>        String[] sReturnArray
81825>>>        Boolean bOK
81825>>>
81825>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
81826>>>        If (bOK = False) Begin
81828>>>            Function_Return sReturnArray
81829>>>        End
81829>>>>
81829>>>
81829>>>        Case Begin
81829>>>            Case (sDriverID = DB2_DRV_ID)
81831>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
81832>>>                Case Break
81833>>>
81833>>>            Case (sDriverID = MDSPgSQL)
81836>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
81837>>>                Case Break
81838>>>
81838>>>            Case (sDriverID = ORAFLEX)
81841>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
81842>>>                Case Break
81843>>>
81843>>>            Case Else
81843>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
81844>>>>
81844>>>                Case Break
81845>>>        Case End
81845>>>
81845>>>        Function_Return sReturnArray
81846>>>    End_Function
81847>>>
81847>>>    // Returns all schemas as a string array for the passed driver id.
81847>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
81849>>>        String[] sReturnArray
81850>>>        Boolean bOK
81850>>>
81850>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
81851>>>        If (bOK = False) Begin
81853>>>            Function_Return sReturnArray
81854>>>        End
81854>>>>
81854>>>
81854>>>        Case Begin
81854>>>            Case (sDriverID = DB2_DRV_ID)
81856>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
81857>>>                Case Break
81858>>>
81858>>>            Case (sDriverID = MDSPgSQL)
81861>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
81862>>>                Case Break
81863>>>
81863>>>            Case (sDriverID = ORAFLEX)
81866>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
81867>>>                Case Break
81868>>>
81868>>>            Case Else
81868>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
81869>>>>
81869>>>                Case Break
81870>>>        Case End
81870>>>
81870>>>        Function_Return sReturnArray
81871>>>    End_Function
81872>>>
81872>>>    // Returns a string array with all tables for the current database.
81872>>>    Function SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
81874>>>        String[] sReturnArray sArray
81876>>>        String sConnectionString sSelect
81876>>>        Integer iSize iCount iDbType
81876>>>        Boolean bOK
81876>>>
81876>>>        If (sDriverID = DATAFLEX_ID) Begin
81878>>>            Function_Return sArray
81879>>>        End
81879>>>>
81879>>>
81879>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
81880>>>        If (bOK = False) Begin
81882>>>            Function_Return sReturnArray
81883>>>        End
81883>>>>
81883>>>        If (sSchema = "") Begin
81885>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81886>>>        End
81886>>>>
81886>>>
81886>>>        Get psConnectionString to sConnectionString
81887>>>
81887>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
81887>>>        // the dbType.
81887>>>        Get piDbType to iDbType
81888>>>        If (sDriverID = ODBC_DRV_ID) Begin
81890>>>            If (iDbType = EN_DbTypeMySQL) Begin
81892>>>                Move MDSMySQL to sDriverID
81893>>>            End
81893>>>>
81893>>>            If (iDbType = EN_DbTypeMSSQL) Begin
81895>>>                Move MSSQLDRV_ID to sDriverID
81896>>>            End
81896>>>>
81896>>>            If (iDbType = EN_DbTypeDB2) Begin
81898>>>                Move DB2_DRV_ID to sDriverID
81899>>>            End
81899>>>>
81899>>>            If (iDbType = EN_DbTypePostgre) Begin
81901>>>                Move MDSPgSQL to sDriverID
81902>>>            End
81902>>>>
81902>>>        End
81902>>>>
81902>>>
81902>>>        Case Begin
81902>>>            Case (sDriverID = MSSQLDRV_ID)
81904>>>                Get _SqlTableArrayDAW to sReturnArray
81905>>>                Case Break
81906>>>
81906>>>            Case (sDriverID = DB2_DRV_ID)
81909>>>                Get _SqlTableArrayDAW to sReturnArray
81910>>>                Case Break
81911>>>
81911>>>            Case (sDriverID = ODBC_DRV_ID)
81914>>>                Get _SqlTableArrayDAW to sReturnArray
81915>>>                Case Break
81916>>>
81916>>>            Case (sDriverID = SQLFLEX)
81919>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
81920>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
81921>>>                Case Break
81922>>>
81922>>>            Case (sDriverID = MDSMySQL)
81925>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
81926>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
81927>>>                Case Break
81928>>>
81928>>>            Case (sDriverID = MDSPgSQL)
81931>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
81932>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
81933>>>                Case Break
81934>>>
81934>>>            Case (sDriverID = ORAFLEX)
81937>>>                Move "SELECT table_name from user_tables" to sSelect
81938>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
81939>>>                Move (SizeOfArray(sArray)) to iSize
81940>>>                Decrement iSize
81941>>>                For iCount from 0 to iSize
81947>>>>
81947>>>                    If (not(sArray[iCount] contains "$")) Begin
81949>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
81950>>>                    End
81950>>>>
81950>>>                Loop
81951>>>>
81951>>>                Case Break
81952>>>
81952>>>            Case Else
81952>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
81953>>>>
81953>>>                Case Break
81954>>>        Case End
81954>>>
81954>>>        Function_Return sReturnArray
81955>>>    End_Function
81956>>>
81956>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
81956>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
81958>>>        String[] sReturnArray
81959>>>        String sConnectionString sSelect sSchema
81959>>>        Boolean bOK
81959>>>        Integer iDbType
81959>>>
81959>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
81960>>>        If (bOK = False) Begin
81962>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
81963>>>>
81963>>>            Function_Return sReturnArray
81964>>>        End
81964>>>>
81964>>>
81964>>>        Get psConnectionString to sConnectionString
81965>>>        Get psSchema to sSchema
81966>>>
81966>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
81966>>>        // the dbType.
81966>>>        Get piDbType to iDbType
81967>>>
81967>>>        Case Begin
81967>>>            Case (sDriverID = ODBC_DRV_ID)
81969>>>                If (iDbType = EN_DbTypeMySQL) Begin
81971>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
81972>>>                End
81972>>>>
81972>>>                If (iDbType = EN_DbTypePostgre) Begin
81974>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
81975>>>                End
81975>>>>
81975>>>                If (iDbType = EN_DbTypeMSSQL) Begin
81977>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
81978>>>                End
81978>>>>
81978>>>
81978>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
81979>>>                Case Break
81980>>>
81980>>>            Case (sDriverID = MSSQLDRV_ID)
81983>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
81984>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
81985>>>                Case Break
81986>>>
81986>>>            Case (sDriverID = DB2_DRV_ID)
81989>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
81990>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
81991>>>                Case Break
81992>>>
81992>>>            Case (sDriverID = SQLFLEX)
81995>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
81996>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
81997>>>                Case Break
81998>>>
81998>>>            Case (sDriverID = MDSMySQL)
82001>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
82002>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
82003>>>                Case Break
82004>>>
82004>>>            Case (sDriverID = MDSPgSQL)
82007>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
82008>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
82009>>>                Case Break
82010>>>
82010>>>            Case (sDriverID = ORAFLEX)
82013>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
82014>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
82015>>>                Case Break
82016>>>
82016>>>            Case Else
82016>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
82017>>>>
82017>>>                Case Break
82018>>>        Case End
82018>>>
82018>>>        Function_Return sReturnArray
82019>>>    End_Function
82020>>>
82020>>>
82020>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
82020>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
82022>>>        String[] sReturnArray sReturnArray2
82024>>>        String sConnectionString sSelect sSchema
82024>>>        Boolean bOK
82024>>>        Integer iCount iSize
82024>>>
82024>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82025>>>        If (bOK = False) Begin
82027>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
82028>>>>
82028>>>            Function_Return sReturnArray
82029>>>        End
82029>>>>
82029>>>
82029>>>        Get psConnectionString to sConnectionString
82030>>>        Get psSchema to sSchema
82031>>>
82031>>>        Case Begin
82031>>>            Case (sDriverID = MSSQLDRV_ID)
82033>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
82034>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
82035>>>                Case Break
82036>>>
82036>>>            Case (sDriverID = DB2_DRV_ID)
82039>>>                Error "Not implemented yet! The select statement has not been finalized."
82040>>>>
82040>>>//                Move () to sSelect
82040>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
82040>>>                Case Break
82041>>>
82041>>>            Case (sDriverID = SQLFLEX)
82044>>>                Error "Not implemented yet! The select statement has not been finalized."
82045>>>>
82045>>>//                Move () to sSelect
82045>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
82045>>>                Case Break
82046>>>
82046>>>            Case (sDriverID = MDSMySQL)
82049>>>                Error "Not implemented yet! The select statement has not been finalized."
82050>>>>
82050>>>//                Move () to sSelect
82050>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
82050>>>                Case Break
82051>>>
82051>>>            Case (sDriverID = MDSPgSQL)
82054>>>                Error "Not implemented yet! The select statement has not been finalized."
82055>>>>
82055>>>//                Move () to sSelect
82055>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
82055>>>                Case Break
82056>>>
82056>>>            Case (sDriverID = ORAFLEX)
82059>>>                Error "Not implemented yet! The select statement has not been finalized."
82060>>>>
82060>>>//                Move () to sSelect
82060>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
82060>>>                Case Break
82061>>>
82061>>>            Case Else
82061>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
82062>>>>
82062>>>                Case Break
82063>>>        Case End
82063>>>
82063>>>        Move (SizeOfArray(sReturnArray)) to iSize
82064>>>        Decrement iSize
82065>>>        For iCount from 0 to iSize
82071>>>>
82071>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
82073>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
82074>>>            End
82074>>>>
82074>>>        Loop
82075>>>>
82075>>>
82075>>>        Function_Return sReturnArray2
82076>>>    End_Function
82077>>>
82077>>>    // Returns a string array with all table names the passed table handle has relation ships with.
82077>>>    // The format of the array is "TableName.FieldName"
82077>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
82079>>>        String[] sFileNameArray sFieldNameArray
82081>>>        tSQLRelation[] sRelationsArray
82081>>>        tSQLRelation[] sRelationsArray
82082>>>        String sConnectionString sSelect sSchema sFileName sFieldName
82082>>>        Boolean bOK
82082>>>        Integer iCount iSize iLength
82082>>>
82082>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82083>>>        If (bOK = False) Begin
82085>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
82086>>>>
82086>>>            Function_Return sRelationsArray
82087>>>        End
82087>>>>
82087>>>
82087>>>        Get psConnectionString to sConnectionString
82088>>>        Get psSchema to sSchema
82089>>>
82089>>>        Case Begin
82089>>>            Case (sDriverID = MSSQLDRV_ID)
82091>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
82092>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
82093>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
82094>>>                Case Break
82095>>>
82095>>>            Case (sDriverID = DB2_DRV_ID)
82098>>>                Error "Not implemented yet! The select statement has not been finalized."
82099>>>>
82099>>>//                Move () to sSelect
82099>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
82099>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
82099>>>                Case Break
82100>>>
82100>>>            Case (sDriverID = SQLFLEX)
82103>>>                Error "Not implemented yet! The select statement has not been finalized."
82104>>>>
82104>>>//                Move () to sSelect
82104>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
82104>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
82104>>>                Case Break
82105>>>
82105>>>            Case (sDriverID = MDSMySQL)
82108>>>                Error "Not implemented yet! The select statement has not been finalized."
82109>>>>
82109>>>//                Move () to sSelect
82109>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
82109>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
82109>>>                Case Break
82110>>>
82110>>>            Case (sDriverID = MDSPgSQL)
82113>>>                Error "Not implemented yet! The select statement has not been finalized."
82114>>>>
82114>>>//                Move () to sSelect
82114>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
82114>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
82114>>>                Case Break
82115>>>
82115>>>            Case (sDriverID = ORAFLEX)
82118>>>                Error "Not implemented yet! The select statement has not been finalized."
82119>>>>
82119>>>//                Move () to sSelect
82119>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
82119>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
82119>>>                Case Break
82120>>>
82120>>>            Case Else
82120>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
82121>>>>
82121>>>                Case Break
82122>>>        Case End
82122>>>
82122>>>        Move (Length(sTableName)) to iLength
82123>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
82124>>>        Move (SizeOfArray(sFileNameArray)) to iSize
82125>>>        Decrement iSize
82126>>>        For iCount from 0 to iSize
82132>>>>
82132>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
82134>>>                Move sFileNameArray[iCount]         to sFileName
82135>>>                Move sFieldNameArray[iCount]        to sFieldName
82136>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
82137>>>                Move sFileName  to sRelationsArray[iCount].sFileName
82138>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
82139>>>            End
82139>>>>
82139>>>        Loop
82140>>>>
82140>>>
82140>>>        Function_Return sRelationsArray
82141>>>    End_Function
82142>>>
82142>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
82144>>>        tSQLLoggedInUser[] SQLLoggedInUser
82144>>>        tSQLLoggedInUser[] SQLLoggedInUser
82145>>>        String[] sUsers sPrograms
82147>>>        String sSelect
82147>>>        Integer iSize iCount
82147>>>
82147>>>        Case Begin
82147>>>            Case (sDriverID = MSSQLDRV_ID)
82149>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
82150>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
82151>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
82152>>>                Case Break
82153>>>            Case (sDriverID = SQLFLEX)
82156>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
82157>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
82158>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
82159>>>                Case Break
82160>>>            Case Else
82160>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
82161>>>>
82161>>>        Case End
82161>>>
82161>>>        Move (SizeOfArray(sUsers)) to iSize
82162>>>        Decrement iSize
82163>>>        For iCount from 0 to iSize
82169>>>>
82169>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
82170>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
82171>>>        Loop
82172>>>>
82172>>>
82172>>>        Function_Return SQLLoggedInUser
82173>>>    End_Function
82174>>>
82174>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
82174>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
82174>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
82176>>>        String[] sFilesData
82177>>>        Boolean bExists
82177>>>        Integer iCh
82177>>>        String sFileName sExt
82177>>>
82177>>>        Get vFolderExists sDataPath to bExists
82178>>>        If (bExists = True) Begin
82180>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
82181>>>            Move ("dir:" + sDataPath)      to sDataPath
82182>>>            Get Seq_New_Channel to iCh  // get free channel for input
82183>>>            Direct_Input channel iCh sDataPath
82185>>>                Repeat
82185>>>>
82185>>>                    Readln channel iCh sFileName
82187>>>                    Get ParseFileExtension sFileName to sExt
82188>>>                    If (Uppercase(sExt) = "INT") Begin
82190>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
82192>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
82193>>>                        End
82193>>>>
82193>>>                    End
82193>>>>
82193>>>                Until (SeqEof = True)
82195>>>            Close_Input channel iCh
82197>>>            Send Seq_Release_Channel iCh
82198>>>        End
82198>>>>
82198>>>        Function_Return sFilesData
82199>>>    End_Function
82200>>>
82200>>>    // Only done for MSSQLDRV_ID so far...
82200>>>    Function SqlEnumerateDatabaseCollations String sDriverID Returns String[]
82202>>>        Boolean bMertechDriver
82202>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
82202>>>        String sDescription sFrom sSys sValue sPrevious
82202>>>        Handle hStmt hoSQLManager hoSQLConnect
82202>>>        Integer iFetchResult iRows iColumn iPos
82202>>>        tSQLConnection SQLConnection
82202>>>        tSQLConnection SQLConnection
82202>>>        String[] asCollations
82203>>>        
82203>>>        If (sDriverID = "") Begin
82205>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
82206>>>>
82206>>>            Function_Return asCollations
82207>>>        End
82207>>>>
82207>>>
82207>>>        // Only done for MSSQLDRV_ID so far...
82207>>>        If (sDriverID <> MSSQLDRV_ID) Begin
82209>>>            Function_Return asCollations
82210>>>        End                 
82210>>>>
82210>>>
82210>>>        Get IsMertechDriver sDriverID to bMertechDriver
82211>>>        If (bMertechDriver = False) Begin
82213>>>            Get phoSQLManager to hoSQLManager
82214>>>        End
82214>>>>
82214>>>        Else Begin
82215>>>            Get _MertechSQLManagerHandle to hoSQLManager
82216>>>        End
82216>>>>
82216>>>
82216>>>        Get psConnectionID     to sConnectionID
82217>>>        Get psConnectionString to sConnectionString
82218>>>        Move 0 to LastErr
82219>>>
82219>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82220>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
82221>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82222>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
82224>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
82225>>>>
82225>>>            Function_Return asCollations
82226>>>        End
82226>>>>
82226>>>
82226>>>        Get SqlOpen of hoSQLConnect to hStmt
82227>>>
82227>>>        If (hStmt = 0) Begin
82229>>>            Send SqlDisconnect of hoSQLManager
82230>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
82231>>>>
82231>>>            Function_Return asCollations
82232>>>        End
82232>>>>
82232>>>
82232>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
82233>>>        Get _SqlFindKeyWord CI_SQLName        to sName
82234>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
82235>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
82236>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
82237>>>
82237>>>        // MS-SQL Syntax:  
82237>>>        // SELECT name, description
82237>>>        //   from sys.fn_helpcollations();
82237>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
82238>>>
82238>>>        Move 1 to iColumn
82239>>>        Send SqlExecDirect of hStmt sSQL
82240>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
82241>>>        Repeat
82241>>>>
82241>>>            Get SQLFetch of hStmt to iFetchResult
82242>>>            If (iFetchResult <> 0) Begin
82244>>>                Get SQLColumnValue of hStmt iColumn to sValue 
82245>>>                If (sValue <> sPrevious) Begin         
82247>>>                    // We need to skip all collations starting with "SQL" because they
82247>>>                    // are obsolete and for pre-SQL Server 2000.
82247>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
82248>>>                    If (iPos <> 1) Begin
82250>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
82251>>>                    End
82251>>>>
82251>>>                End
82251>>>>
82251>>>                Move sValue to sPrevious
82252>>>            End
82252>>>>
82252>>>        Until (iFetchResult = 0)
82254>>>        Send SQLClose of hStmt
82255>>>        Send SQLDisconnect of hoSQLConnect
82256>>>
82256>>>        Function_Return asCollations
82257>>>    End_Function
82258>>>
82258>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
82258>>>    // for DAW drivers.
82258>>>    // Returns: A string array.
82258>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
82260>>>        String[] sReturnArray
82261>>>        String sValue sPrevious
82261>>>        Handle hoSQLHandler hoSQLConnect hstmt
82261>>>        Integer iFetchResult iRows
82261>>>        tSQLConnection SQLConnection
82261>>>        tSQLConnection SQLConnection
82261>>>
82261>>>        Get phoSQLManager to hoSQLHandler
82262>>>
82262>>>        If (hoSQLHandler <> 0) Begin
82264>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
82265>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
82266>>>
82266>>>            If (hoSQLConnect <> 0) Begin
82268>>>                Get SQLOpen of hoSQLConnect to hstmt
82269>>>                If (hstmt <> 0) Begin
82271>>>                    Send SqlExecDirect of hstmt sStmt
82272>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
82273>>>                    Repeat
82273>>>>
82273>>>                        Get SQLFetch of hstmt to iFetchResult
82274>>>                        If (iFetchResult <> 0) Begin
82276>>>                            Get SQLColumnValue of hstmt iColumn to sValue
82277>>>                            If (sValue <> sPrevious) Begin
82279>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
82280>>>                            End
82280>>>>
82280>>>                            Move sValue to sPrevious
82281>>>                        End
82281>>>>
82281>>>                    Until (iFetchResult = 0)
82283>>>                    Send SQLClose of hstmt
82284>>>                End
82284>>>>
82284>>>                Send SQLDisconnect of hoSQLConnect
82285>>>            End
82285>>>>
82285>>>        End
82285>>>>
82285>>>
82285>>>        Function_Return sReturnArray
82286>>>    End_Function
82287>>>
82287>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
82287>>>    // for Mertech drivers.
82287>>>    // Returns: A string array.
82287>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
82289>>>        String[] sReturnArray
82290>>>        String sValue
82290>>>        Handle hoSQLHandler hoSQLConnect hStmt
82290>>>        Integer iFetchResult iRows
82290>>>        tSQLConnection SQLConnection
82290>>>        tSQLConnection SQLConnection
82290>>>
82290>>>        Get _MertechSQLManagerHandle to hoSQLHandler
82291>>>
82291>>>        If (hoSQLHandler <> 0) Begin
82293>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
82294>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
82295>>>
82295>>>            If (hoSQLConnect <> 0) Begin
82297>>>                Get SQLOpen of hoSQLConnect to hStmt
82298>>>                If (hStmt <> 0) Begin
82300>>>                    Send SqlExecDirect of hStmt sStmt
82301>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
82302>>>                    Repeat
82302>>>>
82302>>>                        Get SQLFetch of hStmt to iFetchResult
82303>>>                        If (iFetchResult <> 0) Begin
82305>>>                            Get SQLColumnValue of hStmt 1 to sValue
82306>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
82307>>>                        End
82307>>>>
82307>>>                    Until (iFetchResult = 0)
82309>>>                    Send SQLClose of hStmt
82310>>>                End
82310>>>>
82310>>>                Send SQLDisconnect of hoSQLConnect
82311>>>            End
82311>>>>
82311>>>        End
82311>>>>
82311>>>
82311>>>        Function_Return sReturnArray
82312>>>    End_Function
82313>>>
82313>>>    // * Dummy function for the Studio's Code Explorer *
82313>>>    Function PRIVATE_SQL_SUB_FUNCTIONS Returns Boolean
82315>>>        Function_Return False
82316>>>    End_Function
82317>>>
82317>>>    // Returns the index for the passed sTableName
82317>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
82317>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
82319>>>        Integer iIndex iSize iCount
82319>>>        String[] sTablesArray
82320>>>        String sDatabase sSchema sVal sConnectionString
82320>>>
82320>>>        Move -1 to iIndex
82321>>>        Get psConnectionString to sConnectionString
82322>>>        Get psDatabase to sDatabase
82323>>>        Get psSchema   to sSchema
82324>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
82325>>>        Move (SizeOfArray(sTablesArray)) to iSize
82326>>>        Decrement iSize
82327>>>        For iCount from 0 to iSize
82333>>>>
82333>>>            Move sTablesArray[iCount] to sVal
82334>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
82336>>>                Move iCount to iIndex // We found it!
82337>>>                Move iSize to iCount  // End the loop
82338>>>            End
82338>>>>
82338>>>        Loop
82339>>>>
82339>>>
82339>>>        Function_Return iIndex
82340>>>    End_Function
82341>>>
82341>>>    // Helper function that builds a string like;
82341>>>    // "SELECT name from [Master].[sys].[databases] where name"
82341>>>    Function _SqlSelectFromWhereName Returns String
82343>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
82343>>>
82343>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
82344>>>        Get _SqlFindKeyWord CI_SQLName         to sName
82345>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
82346>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
82347>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
82348>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
82349>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
82350>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
82351>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
82352>>>        Function_Return sRetval
82353>>>    End_Function
82354>>>
82354>>>    // Helper function to create a SQL statement like;
82354>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
82354>>>    // Used for checking if an index exists.
82354>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
82356>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
82356>>>
82356>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
82357>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
82358>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
82359>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
82360>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
82361>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
82362>>>        Get _SqlFindKeyWord CI_SQLName to sName
82363>>>
82363>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
82364>>>
82364>>>        Function_Return sRetval
82365>>>    End_Function
82366>>>
82366>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
82366>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
82366>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
82368>>>        String sRetval
82368>>>        If (iLength <> 0) Begin
82370>>>            Move ("(" + String(iLength)) to sRetval
82371>>>            If (iDecimals <> 0) Begin
82373>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
82374>>>            End
82374>>>>
82374>>>            Move (sRetval + ")") to sRetval
82375>>>        End
82375>>>>
82375>>>        Function_Return sRetval
82376>>>    End_Function
82377>>>
82377>>>    Procedure _SqlColumnInfo Handle hoStmt
82379>>>        Integer i iCols iItem
82379>>>        tSqlColumnNew[] aQueryColumns
82379>>>        tSqlColumnNew[] aQueryColumns
82380>>>
82380>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
82381>>>        For i from 1 to iCols
82387>>>>
82387>>>            Move (SizeOfArray(aQueryColumns)) to iItem
82388>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
82389>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
82390>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
82391>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
82392>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
82393>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
82394>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
82395>>>        Loop
82396>>>>
82396>>>        Set piColumns to iCols
82397>>>        Set paQueryColumns to aQueryColumns
82398>>>    End_Procedure
82399>>>
82399>>>    // Checks that the passed sDriverID is defined.
82399>>>    // Also checks if the driver has been loaded; else it gets loaded.
82399>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
82401>>>        Boolean bOK
82401>>>        Integer iDriver
82401>>>
82401>>>        If (sDriverID = DATAFLEX_ID) Begin
82403>>>            Function_Return False
82404>>>        End
82404>>>>
82404>>>
82404>>>        Get IsDAWSQLDriver sDriverID to bOK
82405>>>
82405>>>        If (bOK = False) Begin
82407>>>            Get IsMertechDriver sDriverID to bOK
82408>>>        End
82408>>>>
82408>>>
82408>>>        If (bOK = False) Begin
82410>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
82411>>>>
82411>>>            Function_Return False
82412>>>        End
82412>>>>
82412>>>
82412>>>        Get DriverIndex sDriverID to iDriver
82413>>>        If (iDriver = 0) Begin
82415>>>            Load_Driver sDriverID
82416>>>        End
82416>>>>
82416>>>
82416>>>        Function_Return True
82417>>>    End_Function
82418>>>
82418>>>    // Checks that the length parameter has been passed correctly.
82418>>>    // This is only of concern for certain SQL data types.
82418>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
82420>>>        Integer iLength
82420>>>        Boolean bOK bCheckTypeLength
82420>>>
82420>>>        If (num_arguments > 1) Begin
82422>>>            Move iLen to iLength
82423>>>        End
82423>>>>
82423>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
82424>>>
82424>>>        If (bCheckTypeLength = True) Begin
82426>>>            Move (iLength > 0) to bOK
82427>>>        End
82427>>>>
82427>>>
82427>>>        Function_Return (bOK = True)
82428>>>    End_Function
82429>>>
82429>>>    Function _SqlProperTableName String sTableName Returns String
82431>>>        String sVal sSchema sDriverID
82431>>>        Integer iDbType
82431>>>
82431>>>        If (Trim(sTableName) = "") Begin
82433>>>            Function_Return ""
82434>>>        End
82434>>>>
82434>>>
82434>>>        Get psDriverID to sDriverID
82435>>>        Get piDbType   to iDbType
82436>>>        If (iDbType = EN_dbTypeOracle) Begin
82438>>>            Get psUserID to sSchema
82439>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
82439>>>            Move (Uppercase(sSchema)) to sSchema
82440>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
82441>>>            Function_Return sTableName
82442>>>        End
82442>>>>
82442>>>        If (iDbType = EN_DbTypeMySQL) Begin
82444>>>            Get psDatabase to sVal
82445>>>            Move (sVal + "." + sTableName) to sTableName
82446>>>            Function_Return sTableName
82447>>>        End
82447>>>>
82447>>>        If (iDbType = EN_DbTypePostgre) Begin
82449>>>            Move ('"' + sTableName + '"') to sTableName
82450>>>            Function_Return sTableName
82451>>>        End
82451>>>>
82451>>>
82451>>>        Get psSchema to sSchema
82452>>>        If (sSchema = "") Begin
82454>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
82455>>>        End
82455>>>>
82455>>>
82455>>>        Move (Uppercase(sTableName)) to sVal
82456>>>        If (not(sVal contains (sSchema + "."))) Begin
82458>>>            If (iDbType = EN_dbTypeDB2) Begin
82460>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
82461>>>            End
82461>>>>
82461>>>            Else Begin
82462>>>                Move (sSchema + "." + sTableName) to sTableName
82463>>>            End
82463>>>>
82463>>>        End
82463>>>>
82463>>>
82463>>>        Function_Return sTableName
82464>>>    End_Function
82465>>>
82465>>>    // SQL column names can be case-sensitive. This function is used to check that
82465>>>    // the passed sFieldName has the correct spelling.
82465>>>    // Used with Embedded SQL statement calls.
82465>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
82465>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
82467>>>        String sRetval sValue sDriverID
82467>>>        String[] sColumnNamesArray
82468>>>        Integer iCount iColumns
82468>>>
82468>>>        Move "" to sRetval
82469>>>        Get psDriverID to sDriverID
82470>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
82471>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
82472>>>        Decrement iColumns
82473>>>
82473>>>        For iCount from 0 to iColumns
82479>>>>
82479>>>            Move sColumnNamesArray[iCount] to sValue
82480>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
82482>>>                Move sValue to sRetval
82483>>>                Move iColumns to iCount // We're done.
82484>>>            End
82484>>>>
82484>>>        Loop
82485>>>>
82485>>>
82485>>>        Function_Return sRetval
82486>>>    End_Function
82487>>>
82487>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
82489>>>        String[] sReturnArray
82490>>>        Handle hoSQLHandler
82490>>>        Integer iCount iSize iItem
82490>>>        String sServer
82490>>>        tSQLConnection SQLConnection
82490>>>        tSQLConnection SQLConnection
82490>>>
82490>>>        Get phoMSSQLHandler to hoSQLHandler
82491>>>        Send Delete_Data    of hoSQLHandler
82492>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
82493>>>
82493>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82494>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
82495>>>        Decrement iSize
82496>>>
82496>>>        For iCount from 0 to iSize
82502>>>>
82502>>>            Get String_Value of hoSQLHandler iCount to sServer
82503>>>            Move (Trim(sServer)) to sReturnArray[iItem]
82504>>>            Increment iItem
82505>>>        Loop
82506>>>>
82506>>>
82506>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82507>>>
82507>>>        Function_Return sReturnArray
82508>>>    End_Function
82509>>>
82509>>>    Function _SqlTableArrayDAW Returns String[]
82511>>>        String[] sReturnArray
82512>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
82512>>>        Handle hoSQLHandler
82512>>>        Integer iCount iSize iItem iPos
82512>>>        Boolean bOK
82512>>>        tSQLConnection SQLConnection
82512>>>        tSQLConnection SQLConnection
82512>>>
82512>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
82513>>>        If (SQLConnection.sConnectionString = "") Begin
82515>>>            Function_Return sReturnArray
82516>>>        End
82516>>>>
82516>>>
82516>>>        Move SQLConnection.sSchema      to sDefSchema
82517>>>        Move (Uppercase(sDefSchema))    to sDefSchema
82518>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
82519>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
82520>>>
82520>>>        Get phoCLIHandler to hoSQLHandler
82521>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
82522>>>        Send Delete_Data  of hoSQLHandler
82523>>>
82523>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82524>>>        Move SQLConnection.sConnectionString to sConnectionString
82525>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
82525>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
82525>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
82525>>>//                Move (Pos(";", sConnectionString)) to iPos
82525>>>//                If (iPos > 0) Begin
82525>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
82525>>>//                    Move (Trim(sConnectionString)) to sConnectionString
82525>>>//                End
82525>>>//            End
82525>>>//        End
82525>>>
82525>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
82526>>>        Move False to Err
82527>>>        Move 0 to iItem
82528>>>
82528>>>        // Note that the enumeration starts from table no 1. (not zero)
82528>>>        for iCount from 1 to iSize
82534>>>>
82534>>>            Get TableName    of hoSQLHandler iCount to sTable
82535>>>            Get TableType    of hoSQLHandler iCount to sTableType
82536>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
82537>>>            If (sSchema = "") Begin
82539>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
82540>>>            End
82540>>>>
82540>>>            Get TableComment of hoSQLHandler iCount to sComment
82541>>>            Move (Trim(sTable)) to sTable
82542>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
82544>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
82545>>>            End
82545>>>>
82545>>>            Else Begin
82546>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
82547>>>            End
82547>>>>
82547>>>            If (bOK = True) Begin
82549>>>                Move sTable to sReturnArray[iItem]
82550>>>                Increment iItem
82551>>>            End
82551>>>>
82551>>>        Loop
82552>>>>
82552>>>
82552>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82553>>>
82553>>>        Function_Return sReturnArray
82554>>>    End_Function
82555>>>
82555>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
82557>>>        String[] sReturnArray
82558>>>        String sValue
82558>>>        Handle hoSQLHandler hoSQLConnect hStmt
82558>>>        Integer iRetval iCols iFetchResult
82558>>>        tSQLConnection SQLConnection
82558>>>        tSQLConnection SQLConnection
82558>>>
82558>>>        Get phoSQLManager to hoSQLHandler
82559>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
82560>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
82561>>>
82561>>>        If (hoSQLConnect <> 0) Begin
82563>>>            Get SqlOpen of hoSQLConnect to hStmt
82564>>>            If (hStmt <> 0) Begin
82566>>>                Send SqlSetProcedurename of hStmt sStmt
82567>>>                If (sArgument <> "") Begin
82569>>>                    Send SqlSetArgument  of hStmt 1 sArgument
82570>>>                End
82570>>>>
82570>>>
82570>>>                Send SqlCall             of hStmt
82571>>>                Get SqlReturnValue       of hStmt to iRetval
82572>>>                If (iRetval = 0) Begin
82574>>>                    Repeat
82574>>>>
82574>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
82575>>>                        If (iCols > 0) Begin
82577>>>                            Repeat
82577>>>>
82577>>>                                Get SqlFetch of hStmt to iFetchResult
82578>>>                                If (iFetchResult <> 0) Begin
82580>>>                                    Get SqlColumnValue of hStmt 1 to sValue
82581>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
82582>>>                                End
82582>>>>
82582>>>                            Until (iFetchResult = 0)
82584>>>                        End
82584>>>>
82584>>>                        Get SqlNextResultSet of hStmt to iRetval
82585>>>                    Until (iRetval = 0)
82587>>>                    Send SqlClose of hStmt
82588>>>                End
82588>>>>
82588>>>            End
82588>>>>
82588>>>            Send SqlDisconnect of hoSQLConnect
82589>>>        End
82589>>>>
82589>>>        Function_Return sReturnArray
82590>>>    End_Function
82591>>>
82591>>>    Function _SqlDatabasesArrayDB2 Returns String[]
82593>>>        String[] sReturnArray
82594>>>        String sDataSource
82594>>>        Handle hoSQLHandler
82594>>>        Integer iItem
82594>>>
82594>>>        Get phoDB2SQLHandler to hoSQLHandler
82595>>>        Send SeedDataSources of hoSQLHandler
82596>>>
82596>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82597>>>
82597>>>        Repeat
82597>>>>
82597>>>            Get DataSources of hoSQLHandler to sDataSource
82598>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
82599>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
82600>>>            Increment iItem
82601>>>        Until (sDataSource = "")
82603>>>
82603>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82604>>>
82604>>>        Function_Return sReturnArray
82605>>>    End_Function
82606>>>
82606>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
82608>>>        String[] sReturnArray
82609>>>        String sDataSource
82609>>>        Handle hoSQLHandler
82609>>>        Integer iItem
82609>>>
82609>>>        Get phoODBCSQLHandler to hoSQLHandler
82610>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82611>>>
82611>>>        Send SeedDataSources of hoSQLHandler
82612>>>
82612>>>        Repeat
82612>>>>
82612>>>            Get DataSources of hoSQLHandler to sDataSource
82613>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
82615>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
82616>>>                Increment iItem
82617>>>            End
82617>>>>
82617>>>        Until (sDataSource = "")
82619>>>
82619>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82620>>>
82620>>>        Function_Return sReturnArray
82621>>>    End_Function
82622>>>
82622>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
82624>>>        String[] sDataSources
82625>>>        tSQLConnection SQLConnection
82625>>>        tSQLConnection SQLConnection
82625>>>        tSQLIntTableInfo[] sReturnArray
82625>>>        tSQLIntTableInfo[] sReturnArray
82626>>>        Integer iDataSources iCount iItem
82626>>>        String sConnection sServer sDatabase sKey sSubKey
82626>>>        Handle hoIniFile hoRegistry hoODBCDataSources
82626>>>        Boolean bExists bKeyOpened
82626>>>
82626>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
82627>>>        Move SQLConnection.sConnectionString to sConnection
82628>>>        Move SQLConnection.sServer           to sServer
82629>>>
82629>>>        // FileDSN - read DATABASE name from DSN ini-file
82629>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
82631>>>            Get Create (RefClass(cIniFile)) to hoIniFile
82632>>>            Set psFileName of hoIniFile to sServer
82633>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
82634>>>            Move sDatabase to sReturnArray[0].sDatabaseName
82635>>>            Send Destroy of hoIniFile
82636>>>        End
82636>>>>
82636>>>
82636>>>        // DSN - read DATABASE name from the registry
82636>>>        Else Begin
82637>>>            Get Create (RefClass(cRegistry)) to hoRegistry
82638>>>
82638>>>            // We start with checking the "System DNS" area in the registry as it is the
82638>>>            // most probably place the info is kept that we're after.
82638>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
82639>>>            Set pfAccessRights of hoRegistry to Key_Read
82640>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
82641>>>            If (bExists = True) Begin
82643>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
82644>>>            End
82644>>>>
82644>>>            Else Begin
82645>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
82646>>>            End
82646>>>>
82646>>>
82646>>>            Get KeyExists of hoRegistry sKey to bExists
82647>>>            If (bExists) Begin
82649>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
82650>>>                If (bKeyOpened) Begin
82652>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
82653>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
82654>>>                    If (iDataSources > 0) Begin
82656>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
82657>>>                        Decrement iDataSources
82658>>>                        for iCount from 0 to iDataSources
82664>>>>
82664>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
82665>>>                        Loop
82666>>>>
82666>>>                        Move 0 to iItem
82667>>>                        for iCount from 0 to iDataSources
82673>>>>
82673>>>                            Move sDataSources[iCount] to sSubKey
82674>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
82675>>>                            If (bKeyOpened = True) Begin
82677>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
82678>>>                                If (bExists = True) Begin
82680>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
82681>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
82682>>>                                    Increment iItem
82683>>>                                End
82683>>>>
82683>>>                            End
82683>>>>
82683>>>                        Loop
82684>>>>
82684>>>                    End
82684>>>>
82684>>>                    Send CloseKey of hoRegistry
82685>>>                    Send Destroy of hoODBCDataSources
82686>>>                End
82686>>>>
82686>>>            End
82686>>>>
82686>>>
82686>>>            // We then check the "User DNS" area in the registry.
82686>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
82687>>>            Set pfAccessRights of hoRegistry to Key_Read
82688>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
82689>>>            Get KeyExists of hoRegistry sKey to bExists
82690>>>
82690>>>            If (bExists) Begin
82692>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
82693>>>                If (bKeyOpened) Begin
82695>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
82696>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
82697>>>                    If (iDataSources > 0) Begin
82699>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
82700>>>                        Decrement iDataSources
82701>>>                        for iCount from 0 to iDataSources
82707>>>>
82707>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
82708>>>                        Loop
82709>>>>
82709>>>                        for iCount from 0 to iDataSources
82715>>>>
82715>>>                            Move sDataSources[iCount] to sSubKey
82716>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
82717>>>                            If (bKeyOpened = True) Begin
82719>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
82720>>>                                If (bExists = True) Begin
82722>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
82723>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
82724>>>                                    Increment iItem
82725>>>                                End
82725>>>>
82725>>>                            End
82725>>>>
82725>>>                        Loop
82726>>>>
82726>>>                    End
82726>>>>
82726>>>                    Send CloseKey of hoRegistry
82727>>>                    Send Destroy of hoODBCDataSources
82728>>>                End
82728>>>>
82728>>>            End
82728>>>>
82728>>>
82728>>>            Send Destroy of hoRegistry
82729>>>        End
82729>>>>
82729>>>
82729>>>        Function_Return sReturnArray
82730>>>    End_Function
82731>>>
82731>>>    // We might have a split Sql script where the info about which database to use is
82731>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
82731>>>    // insert it for scriplets to come after the first one.
82731>>>    Function _SqlFormatStatement String sStmt Returns String
82733>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
82733>>>        Integer iStart iEnd iDbType
82733>>>        Boolean bOK
82733>>>
82733>>>        Get piDbType to iDbType
82734>>>        Get psDriverID to sDriverID
82735>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
82736>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
82737>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
82738>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
82739>>>        Move (Replaces(" ", sStmt, "")) to sTmp
82740>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
82742>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
82743>>>            Move (Pos("]", sTmp)) to iEnd
82744>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
82745>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
82746>>>            Set Private.psUseDatabase to sUseDatabase
82747>>>        End
82747>>>>
82747>>>        Else Begin
82748>>>            Move (Uppercase(sStmt)) to sTmp
82749>>>
82749>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
82749>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
82751>>>                Get Private.psUseDatabase to sUseDatabase
82752>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
82753>>>            End
82753>>>>
82753>>>
82753>>>            // This is a bit special to place here but was done so because it was easier that way.
82753>>>            // We will get an error when trying to create a view if it already exists.
82753>>>            // So to avoid such errors; we first remove it & then recreate it.
82753>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
82756>>>                // Make sure we only have one space between statements/words.
82756>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
82757>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
82758>>>                Move (Trim(sTmp)) to sTmp
82759>>>                Move (Pos(" ", sTmp)) to iEnd
82760>>>                Move (Left(sTmp, iEnd)) to sTmp
82761>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
82763>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
82764>>>                End
82764>>>>
82764>>>                Move (Trim(sTmp)) to sTmp
82765>>>                // Remove data view as it already exists!
82765>>>                Get SqlViewRemove sDriverID sTmp to bOK
82766>>>            End
82766>>>>
82766>>>        End
82766>>>>
82766>>>
82766>>>        Function_Return sStmt
82767>>>    End_Function
82768>>>
82768>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
82768>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
82770>>>        String sRetval
82770>>>        Integer iDbType iIndex
82770>>>        tSQLKeyWords[] SQLKeywordArray
82770>>>        tSQLKeyWords[] SQLKeywordArray
82771>>>        tSQLKeyWords   SQLKeyWords
82771>>>        tSQLKeyWords   SQLKeyWords
82771>>>
82771>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
82771>>>        Move "" to sRetval
82772>>>        Get piDbType to iDbType
82773>>>        Move iDbType             to SQLKeyWords.iSQLDbType
82774>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
82775>>>
82775>>>        Get paSQLKeywordArray to SQLKeywordArray
82776>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
82777>>>        If (iIndex >= 0) Begin
82779>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
82780>>>        End
82780>>>>
82780>>>
82780>>>        Function_Return sRetval
82781>>>    End_Function
82782>>>
82782>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
82782>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
82784>>>        String[] sSQLScriptArray
82785>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
82785>>>        Integer iSize iCount
82785>>>        Boolean bCommentStart bCommentEnd bDashComment
82785>>>
82785>>>        Move False to bCommentStart
82786>>>        Move False to bCommentEnd
82787>>>        Move False to bDashComment
82788>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
82789>>>        Move "*/"  to sCommentEnd
82790>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
82791>>>
82791>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
82792>>>        Decrement iSize
82793>>>        Move "" to sText
82794>>>
82794>>>        For iCount from 0 to iSize
82800>>>>
82800>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
82801>>>            Move (Trim(sLine)) to sTmp
82802>>>            If (sTmp <> "") Begin
82804>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
82805>>>                If (bCommentStart = False) Begin
82807>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
82808>>>                    If (bCommentStart = False) Begin
82810>>>                    End
82810>>>>
82810>>>                End
82810>>>>
82810>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
82811>>>                If (bCommentEnd = True) Begin
82813>>>                    Move False to bCommentStart
82814>>>                End
82814>>>>
82814>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
82816>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
82817>>>                End
82817>>>>
82817>>>            End
82817>>>>
82817>>>        Loop
82818>>>>
82818>>>
82818>>>        // Update the retval struct array:
82818>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
82819>>>        Function_Return SqlScriptArray
82820>>>    End_Function
82821>>>
82821>>>
82821>>>    // *** Database API Functions: ***
82821>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
82821>>>    // make changes/updates to the database.
82821>>>
82821>>>    // * Dummy function for the Studio's Code Explorer *
82821>>>    Function API_TABLE_FUNCTIONS Returns Boolean
82823>>>        Function_Return False
82824>>>    End_Function
82825>>>
82825>>>    // This might not do what you think - Here's what it does:
82825>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
82825>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
82825>>>    // to the SQL table.
82825>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
82825>>>    // already exists in SQL.
82825>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
82825>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
82825>>>    // restructuring an existing table.
82825>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
82827>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
82827>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
82827>>>        Handle hToTable
82827>>>
82827>>>        Move True to bUseConnectionID
82828>>>        If (num_arguments > 1) Begin
82830>>>            Move bUseConnID to bUseConnectionID
82831>>>        End
82831>>>>
82831>>>
82831>>>        Get psDriverID to sDriverID
82832>>>        // If the table doesn't exist on the SQL back-end we do nothing.
82832>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
82833>>>        If (bExists = False) Begin
82835>>>            Function_Return False
82836>>>        End
82836>>>>
82836>>>
82836>>>        Get UtilTableIsAlias hTable to bIsAlias
82837>>>
82837>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82838>>>        If (bOK = False) Begin
82840>>>            Function_Return False
82841>>>        End
82841>>>>
82841>>>
82841>>>        // Then we need to check that the function hasn't been called before; which in case
82841>>>        // we do nothing
82841>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
82842>>>        If (bExists = True) Begin
82844>>>            Function_Return False
82845>>>        End
82845>>>>
82845>>>
82845>>>        Get psConnectionID     to sConnectionID
82846>>>        Get psConnectionString to sConnectionString
82847>>>        If (sConnectionID = "" or sConnectionString = "") Begin
82849>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
82850>>>>
82850>>>            Function_Return False
82851>>>        End
82851>>>>
82851>>>
82851>>>        Set Private.phCurrentTable to hTable
82852>>>        Get psSchema to sSchema
82853>>>        If (sSchema = "") Begin
82855>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
82856>>>        End
82856>>>>
82856>>>
82856>>>        Get IsMertechDriver sDriverID to bMertechDriver
82857>>>
82857>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
82857>>>        // was a programmer's error and we adjust for it here.
82857>>>        If (bMertechDriver = True) Begin
82859>>>            Move False to bUseConnectionID
82860>>>        End
82860>>>>
82860>>>
82860>>>        // If we should use a connection id we need to check it exists;
82860>>>        // else we create it before attempting creating the table
82860>>>        If (bUseConnectionID = True) Begin
82862>>>            Get AutoConnectionIDLogin to bOK
82863>>>            If (bOk = False) Begin
82865>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
82866>>>>
82866>>>                Function_Return False
82867>>>            End
82867>>>>
82867>>>        End
82867>>>>
82867>>>
82867>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
82870>>>        Get _TableNameOnly sRootName to sRootName
82871>>>        If (sRootName = "") Begin
82873>>>            Function_Return False
82874>>>        End
82874>>>>
82874>>>        Move (sRootName + ".int")                    to sPhysicalName
82875>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
82878>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
82881>>>
82881>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
82881>>>        //
82881>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
82881>>>        // because then the table should not be visible to users.
82881>>>//        Move (Pos("@", sDisplayName)) to iPos
82881>>>//        If (iPos <> 1) Begin
82881>>>//            If (sDisplayName contains ".") Begin
82881>>>//                Move (Pos(".", sDisplayName)) to iPos
82881>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
82881>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
82881>>>//            End
82881>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
82881>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
82881>>>//            End
82881>>>//        End
82881>>>
82881>>>        If (bIsAlias = False) Begin
82883>>>            Get OpenTableExclusive hTable to bOpened
82884>>>            If (bOpened = False) Begin
82886>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
82887>>>>
82887>>>                Function_Return False
82888>>>            End
82888>>>>
82888>>>        End
82888>>>>
82888>>>
82888>>>        If (ghoProgressBar <> 0) Begin
82890>>>            Send DoAdvance of ghoProgressBar
82891>>>            Set Message_Text of ghoStatusPanel to ""
82892>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
82893>>>        End
82893>>>>
82893>>>        // Note: The hToTable will get changed by the Structure_xxx command...
82893>>>        Move hTable to hToTable
82894>>>        Move False to Err
82895>>>
82895>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
82895>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
82895>>>        // a proper and updated .int file.
82895>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
82898>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
82899>>>
82899>>>        If (bIsAlias = False) Begin
82901>>>            Structure_Start hToTable sDriverID
82902>>>                Set Private.phCurrentTable to hTable
82903>>>                If (bUseConnectionID = True) Begin
82905>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
82908>>>                End
82908>>>>
82908>>>                Else Begin
82909>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
82912>>>                End
82912>>>>
82912>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
82915>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
82915>>>                Move False to Err
82916>>>                Move 0 to LastErr
82917>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
82918>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
82920>>>            Set Action_Text of ghoStatusPanel to ""
82921>>>        End
82921>>>>
82921>>>
82921>>>        Move (not(Err)) to bOK
82922>>>        If (bOK = True) Begin
82924>>>            // The attributes set above will always trigger an error
82924>>>            // We also adjust the Filelist entries
82924>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
82927>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
82930>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
82933>>>
82933>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
82933>>>            Get SqlUtilUpdateIntFile hTable to bOK
82934>>>        End
82934>>>>
82934>>>
82934>>>        Function_Return (bOK = True)
82935>>>    End_Function
82936>>>
82936>>>    // Sample usage:
82936>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
82936>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
82936>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
82938>>>        Boolean bOK bIsSQLTable
82938>>>
82938>>>        Get AutoConnectionIDLogin to bOK
82939>>>        Move False to Err
82940>>>        Get OpenTableExclusive hTable to bOK
82941>>>        If (bOK = False) Begin
82943>>>            Function_Return False
82944>>>        End
82944>>>>
82944>>>
82944>>>        // ToDo: Add to all table change functions!
82944>>>            Get UtilTableIsSQL hTable to bIsSQLTable
82945>>>            If (bIsSQLTable = True) Begin
82947>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
82950>>>            End
82950>>>>
82950>>>
82950>>>        Set Private.phCurrentTable to hTable
82951>>>        Structure_Start hTable
82952>>>            Set_Attribute iAttribute of hTable to iValue
82955>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
82956>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
82958>>>
82958>>>        Set Action_Text of ghoStatusPanel to ""
82959>>>        Function_Return (Err = False)
82960>>>    End_Function
82961>>>
82961>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
82963>>>        Boolean bOK
82963>>>        
82963>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
82964>>>        If (bOK = True) Begin
82966>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
82967>>>        End
82967>>>>
82967>>>        
82967>>>        Function_Return (bOK = True)
82968>>>    End_Function
82969>>>    
82969>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
82969>>>    // or to change the filelist slot names.
82969>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
82971>>>        String sFileListName
82971>>>        
82971>>>        Move False to Err
82972>>>
82972>>>        If (ghoProgressBar <> 0) Begin
82974>>>            Send DoAdvance of ghoProgressBar
82975>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
82976>>>        End
82976>>>>
82976>>>        // If all strings are empty it means that we should remove this entry from filelist.
82976>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
82978>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
82981>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
82984>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
82987>>>            Function_Return (Err = False) // And we're done.
82988>>>        End
82988>>>>
82988>>>
82988>>>        If (sDriverID <> DATAFLEX_ID) Begin
82990>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
82990>>>            Move (sDriverID + ":" + sRootName) to sRootName
82991>>>        End
82991>>>>
82991>>>//        Else Begin
82991>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
82991>>>//        End
82991>>>//
82991>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
82991>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
82991>>>
82991>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
82994>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
82997>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
83000>>>        
83000>>>        Function_Return (Err = False)
83001>>>    End_Function
83002>>>
83002>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
83004>>>        Boolean bOK
83004>>>
83004>>>        Get AutoConnectionIDLogin to bOK
83005>>>        Move False to Err
83006>>>        Get OpenTableExclusive hTable to bOK
83007>>>        If (bOK = False) Begin
83009>>>            Function_Return False
83010>>>        End
83010>>>>
83010>>>
83010>>>        Set Private.phCurrentTable to hTable
83011>>>        Structure_Start hTable
83012>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
83015>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
83016>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83018>>>
83018>>>        Set Action_Text of ghoStatusPanel to ""
83019>>>        Function_Return (Err = False)
83020>>>    End_Function
83021>>>
83021>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
83023>>>        Boolean bOK bIsSQLTable
83023>>>
83023>>>        Move False to Err
83024>>>        Get AutoConnectionIDLogin to bOK
83025>>>        Open hToTable
83027>>>        Get OpenTableExclusive hTable to bOK
83028>>>        If (bOK = False) Begin
83030>>>            Function_Return False
83031>>>        End
83031>>>>
83031>>>
83031>>>            Get UtilTableIsSQL hTable to bIsSQLTable
83032>>>            If (bIsSQLTable = True) Begin
83034>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
83037>>>            End
83037>>>>
83037>>>
83037>>>        Set Private.phCurrentTable to hTable
83038>>>        Structure_Start hTable
83039>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
83042>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
83045>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
83046>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83048>>>
83048>>>        Set Action_Text of ghoStatusPanel to ""
83049>>>        Function_Return (Err = False)
83050>>>    End_Function
83051>>>
83051>>>    Procedure ApiTableConvertAllAddException Integer hTable
83053>>>        Integer[] aTableConvertExceptions
83054>>>        Get paTableConvertExceptions to aTableConvertExceptions
83055>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
83056>>>        Set paTableConvertExceptions to aTableConvertExceptions
83057>>>    End_Procedure
83058>>>
83058>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
83060>>>        Integer[] aTableDateCorrectionExceptions
83061>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83062>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
83063>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83064>>>    End_Procedure
83065>>>
83065>>>    Procedure ApiTableConvertALLToSql
83067>>>        Integer[] iTablesArray
83068>>>        Integer iSize iCount
83068>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
83068>>>        String sDriverID
83068>>>
83068>>>        Get psDriverID to sDriverID
83069>>>        Get pbUseConnectionID to bUseConnectionID
83070>>>        Get pbToANSI          to bToANSI
83071>>>        Get pbRecnum          to bRecnum
83072>>>        Get pbCopyData        to bCopyData
83073>>>        If (ghoDbUpdateHandler > 0) Begin
83075>>>            Get pbContinueOnError to bContinueOnError
83076>>>        End
83076>>>>
83076>>>
83076>>>        Get _AllTablesToConvert to iTablesArray
83077>>>        Move (SizeOfArray(iTablesArray)) to iSize
83078>>>        Set pbVisible   of ghoProgressBarOverall to True
83079>>>        Set piPosition  of ghoProgressBarOverall to 0
83080>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
83081>>>        Set piMaximum   of ghoProgressBarOverall to iSize
83082>>>
83082>>>        Decrement iSize
83083>>>        For iCount from 0 to iSize
83089>>>>
83089>>>            Set piPosition of ghoProgressBarOverall to iCount
83090>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
83091>>>            // Probably the right logic here is to just continue trying to convert every table even
83091>>>            // if there was an error converting one table...
83091>>>            //If (bContinueOnError = False and bOK = False) Break
83091>>>        Loop
83092>>>>
83092>>>
83092>>>    End_Procedure
83093>>>
83093>>>    Procedure ApiTableAttachALLToSql
83095>>>        Integer[] iTablesArray
83096>>>        Integer iSize iCount
83096>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
83096>>>        String sDriverID
83096>>>
83096>>>        Get psDriverID to sDriverID
83097>>>        Get pbUseConnectionID to bUseConnectionID
83098>>>        Get pbToANSI          to bToANSI
83099>>>        Get pbRecnum          to bRecnum
83100>>>        Get pbCopyData        to bCopyData
83101>>>        If (ghoDbUpdateHandler > 0) Begin
83103>>>            Get pbContinueOnError to bContinueOnError
83104>>>        End
83104>>>>
83104>>>
83104>>>        Get _AllTablesToConvert to iTablesArray
83105>>>        Move (SizeOfArray(iTablesArray)) to iSize
83106>>>        Decrement iSize
83107>>>        For iCount from 0 to iSize
83113>>>>
83113>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
83114>>>        Loop
83115>>>>
83115>>>
83115>>>    End_Procedure
83116>>>
83116>>>    // Subfunction to the ApiTableUpdate function (et al)
83116>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
83118>>>        Handle hTable
83118>>>        String sConnectionID
83118>>>        Boolean bTableExists bSameTableNames bANSI bOK
83118>>>
83118>>>        Get ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
83119>>>        If (bSameTableNames = True) Begin
83121>>>            Function_Return True
83122>>>        End
83122>>>>
83122>>>
83122>>>        Move True to bOK
83123>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
83124>>>        Set Private.phCurrentTable              to hTable
83125>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
83128>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
83131>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
83134>>>
83134>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
83136>>>            Get psConnectionID to sConnectionID
83137>>>            Get UtilTableExists hTable to bTableExists
83138>>>            If (bTableExists = True) Begin
83140>>>                Get SqlUtilUpdateIntFile hTable to bOK
83141>>>            End
83141>>>>
83141>>>            Else Begin
83142>>>                Get pbToANSI to bANSI
83143>>>                Get SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
83144>>>            End
83144>>>>
83144>>>        End
83144>>>>
83144>>>
83144>>>        Function_Return bOK
83145>>>    End_Function
83146>>>
83146>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
83148>>>        Handle hToTable hoLogFile
83148>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
83148>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
83148>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
83148>>>        tSQLConnection SQLConnection
83148>>>        tSQLConnection SQLConnection
83148>>>
83148>>>        Get UtilTableExists hTable to bExists
83149>>>        If (bExists = False) Begin
83151>>>            Set Private.phCurrentTable to hTable
83152>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
83153>>>>
83153>>>            Function_Return False
83154>>>        End
83154>>>>
83154>>>
83154>>>        Get UtilTableIsAlias hTable to bIsAlias
83155>>>        // If this is an Alias file there is nothing to convert to SQL.
83155>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
83155>>>        If (bIsAlias = True) Begin
83157>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
83160>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
83162>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
83165>>>                Get psConnectionID to sConnectionID
83166>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
83167>>>            End
83167>>>>
83167>>>            Function_Return True
83168>>>        End
83168>>>>
83168>>>
83168>>>        Set Private.phCurrentTable to hTable
83169>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
83172>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
83175>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
83178>>>
83178>>>        If (ghoProgressBar <> 0) Begin
83180>>>            Send DoAdvance of ghoProgressBar
83181>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
83182>>>            Set Message_Text   of ghoStatusPanel to ""
83183>>>            Set Action_Text    of ghoStatusPanel to ""
83184>>>        End
83184>>>>
83184>>>
83184>>>        // Marco Kuipers suggestion;
83184>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
83184>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
83184>>>        // SQL table.
83184>>>        Get UtilTableIsSQL hTable to bOK
83185>>>        If (bOK = False) Begin
83187>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
83188>>>            If (bExists = True) Begin
83190>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
83190>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
83190>>>                Get phoLogFile to hoLogFile
83191>>>                If (hoLogFile <> 0) Begin          
83193>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
83194>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
83194>>>                    Send LogError sWarning False
83195>>>                End
83195>>>>
83195>>>                Else Begin
83196>>>                    Error DFERR_PROGRAM sWarning
83197>>>>
83197>>>                End                                                       
83197>>>>
83197>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
83198>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
83199>>>            End
83199>>>>
83199>>>        End
83199>>>>
83199>>>
83199>>>        // Does the rootname contain a driver?
83199>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
83201>>>            // Does the table already exist as an SQL table?
83201>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
83202>>>            // It can happen that the table is missing from Filelist.cfg but still
83202>>>            // exist on the SQL side, in case we want to search for the table by its name.
83202>>>            If (bExists = False) Begin
83204>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
83205>>>            End
83205>>>>
83205>>>            If (bExists = True) Begin
83207>>>                Set TableName_Text of ghoStatusPanel to ""
83208>>>                Function_Return False
83209>>>            End
83209>>>>
83209>>>        End
83209>>>>
83209>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
83210>>>
83210>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
83211>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
83211>>>        // passed as True, we adjust for that here.
83211>>>        Get IsMertechDriver sDriverID to bMertechDriver
83212>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
83214>>>            Move False to bUseConnectionID
83215>>>        End
83215>>>>
83215>>>
83215>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83216>>>        Move SQLConnection.sSchema           to sSchema
83217>>>        If (sSchema = "") Begin
83219>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
83220>>>            Move (Lowercase(sSchema))        to sSchema
83221>>>        End
83221>>>>
83221>>>
83221>>>        If (sDriverID = ORAFLEX) Begin
83223>>>            Move SQLConnection.sUserID       to sSchema
83224>>>        End
83224>>>>
83224>>>
83224>>>        Move SQLConnection.sDatabase         to sDatabase
83225>>>        Move SQLConnection.sConnectionID     to sConnectionID
83226>>>        Move SQLConnection.sConnectionString to sConnectionString
83227>>>        If (sConnectionID = "" or sConnectionString = "") Begin
83229>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
83230>>>>
83230>>>            Function_Return False
83231>>>        End
83231>>>>
83231>>>
83231>>>        Get AutoConnectionIDLogin to bOK
83232>>>        Open hTable
83234>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
83237>>>        If (bOpened = False) Begin
83239>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
83240>>>>
83240>>>            Function_Return False
83241>>>        End
83241>>>>
83241>>>
83241>>>        If (ghoProgressBar <> 0) Begin
83243>>>            Send DoAdvance of ghoProgressBar
83244>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
83245>>>        End
83245>>>>
83245>>>
83245>>>        Move 0 to hToTable
83246>>>        Get _TableNameOnly sRootName                 to sRootName
83247>>>        Move (sRootName + ".int")                    to sPhysicalName
83248>>>
83248>>>        Case Begin
83248>>>            Case (sDriverID = MSSQLDRV_ID)
83250>>>                Case Break
83251>>>            Case (sDriverID = ODBC_DRV_ID)
83254>>>                Case Break
83255>>>            Case (sDriverID = DB2_DRV_ID)
83258>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
83259>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
83260>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
83261>>>                Case Break
83262>>>            Case (sDriverID = ORAFLEX)
83265>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
83266>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
83267>>>                Case Break
83268>>>            Case (sDriverID = MDSMySQL)
83271>>>                Case Break
83272>>>            Case (sDriverID = MDSPgSQL)
83275>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
83276>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
83277>>>                Case Break
83278>>>            Case (sDriverID = DATAFLEX_ID)
83281>>>                Case Break
83282>>>            Case Else
83282>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
83283>>>>
83283>>>                Case Break
83284>>>        Case End
83284>>>
83284>>>        Move False to Err
83285>>>
83285>>>        If (bMertechDriver = True) Begin
83287>>>            // Note: This function also sets the Err flag.
83287>>>            Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bToAnsi bCopyData to bOK
83288>>>        End
83288>>>>
83288>>>
83288>>>        If (bMertechDriver = False) Begin
83290>>>            Structure_Start hToTable sDriverID
83291>>>                Structure_Copy hTable to hToTable
83292>>>                Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
83295>>>
83295>>>                If (sDriverID <> DATAFLEX_ID) Begin
83297>>>                    If (bUseConnectionID = True) Begin
83299>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
83302>>>                    End
83302>>>>
83302>>>                    Else Begin
83303>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
83306>>>                    End
83306>>>>
83306>>>
83306>>>                    Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
83309>>>
83309>>>                    If (sSchema <> "") Begin
83311>>>                        Set_Attribute DF_FILE_OWNER of hToTable to sSchema
83314>>>                    End
83314>>>>
83314>>>
83314>>>                    If (sDriverID = DB2_DRV_ID) Begin
83316>>>                        If (sLongTableSpace <> "") Begin
83318>>>                            Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
83321>>>                        End
83321>>>>
83321>>>                        If (sBaseTableSpace <> "") Begin
83323>>>                            Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
83326>>>                        End
83326>>>>
83326>>>                        If (sIndexTableSpace <> "") Begin
83328>>>                            Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
83331>>>                        End
83331>>>>
83331>>>                    End
83331>>>>
83331>>>                End
83331>>>>
83331>>>
83331>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
83332>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83334>>>            Set Action_Text of ghoStatusPanel to ""
83335>>>        End
83335>>>>
83335>>>
83335>>>        Move (not(Err)) to bOK
83336>>>
83336>>>        If (bOK = True and bCopyData = True) Begin
83338>>>            If (bMertechDriver = False) Begin
83340>>>                Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
83341>>>            End
83341>>>>
83341>>>            Else Begin
83342>>>                Get _MertechCopyDataToSQL hTable sRootName sDriverID to bOK
83343>>>            End
83343>>>>
83343>>>
83343>>>            If (ghoDbUpdateHandler > 0) Begin
83345>>>                Get pbContinueOnError to bContinueOnError
83346>>>            End
83346>>>>
83346>>>            // If the data copy failed we will keep the newly created SQL table but
83346>>>            // rename it by adding a GUID to the end of the table name
83346>>>            // - or as much as "fit" because different SQL back-ends have
83346>>>            // different rules how long a table name can be.
83346>>>            // The new table will probably contain data but something went
83346>>>            // wrong while converting the data from embedded to SQL.
83346>>>            If (bOK = False and bContinueOnError = False) Begin
83348>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
83349>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
83350>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
83351>>>>
83351>>>            End
83351>>>>
83351>>>        End
83351>>>>
83351>>>
83351>>>        // This must be after copying data...
83351>>>        If (Err = False) Begin
83353>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
83356>>>            // It seems the Studio does not do this any more, so commented out.
83356>>>            // We also adjust the display name by prefixing it by the schema name;
83356>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
83356>>>            //                // The max length for the display_name is 31 characters...
83356>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
83356>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
83356>>>            //                End
83356>>>            //            End
83356>>>        End
83356>>>>
83356>>>
83356>>>        Close hTable
83357>>>        Move (not(Err)) to bOK
83358>>>        Function_Return bOK
83359>>>    End_Function
83360>>>
83360>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
83360>>>    // It will first drop all indicies, copy the data and then recreate indicies.
83360>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
83360>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
83362>>>        Boolean bOpened bOK
83362>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
83362>>>        String sErrorFile sEmpty sPath
83362>>>
83362>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
83365>>>        Get AutoConnectionIDLogin to bOK
83366>>>        If (sDriverID = DATAFLEX_ID) Begin
83368>>>            Send IncreaseSortBufferSize
83369>>>//            Send SetAllIndexesToBatch hToTable
83369>>>        End
83369>>>>
83369>>>
83369>>>        Move False to Err
83370>>>        Open sPhysicalName as hToTable
83372>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
83375>>>        If (bOpened = False) Begin
83377>>>            Function_Return False
83378>>>        End
83378>>>>
83378>>>
83378>>>        If (ghoStatusPanel <> 0) Begin
83380>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
83381>>>            Set piMinimum of ghoProgressBar to 0
83382>>>            Set piMaximum of ghoProgressBar to 100 // 100%
83383>>>        End
83383>>>>
83383>>>
83383>>>        Move "" to sEmpty
83384>>>        Move False to Err
83385>>>        Move True to bOK
83386>>>        Set Private.phCurrentTable to hToTable
83387>>>
83387>>>        // No need to get the record identifier
83387>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
83390>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
83393>>>        If (sDriverID <> DATAFLEX_ID) Begin
83395>>>            // Remove all indices to speed up copying of data:
83395>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
83400>>>            If (iRetval <> 0) Begin       
83402>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
83403>>>>
83403>>>                Close hToTable
83404>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
83407>>>                Function_Return False
83408>>>            End
83408>>>>
83408>>>        End
83408>>>>
83408>>>
83408>>>        Move (sRootName + ".err") to sErrorFile
83409>>>        Move 0 to iIndex
83410>>>        Move False to Err
83411>>>
83411>>>        If (sDriverID = MSSQLDRV_ID) Begin
83413>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
83416>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
83421>>>            If (iRetval <> 0) Begin
83423>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
83424>>>>
83424>>>                Close hToTable
83425>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
83428>>>                Function_Return False
83429>>>            End
83429>>>>
83429>>>        End
83429>>>>
83429>>>        Else Begin
83430>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
83433>>>        End
83433>>>>
83433>>>
83433>>>        If (Err = False) Begin
83435>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
83436>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
83437>>>        End
83437>>>>
83437>>>
83437>>>        If (sDriverID <> DATAFLEX_ID) Begin
83439>>>            // Recreate indices:
83439>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
83444>>>            If (iRetval <> 0) Begin
83446>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
83447>>>>
83447>>>                Close hToTable
83448>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
83451>>>                Function_Return False
83452>>>            End
83452>>>>
83452>>>        End
83452>>>>
83452>>>
83452>>>        Close hToTable
83453>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
83456>>>
83456>>>        If (bOK = True) Begin
83458>>>            Move (not(Err)) to bOK
83459>>>        End
83459>>>>
83459>>>
83459>>>        If (ghoStatusPanel <> 0) Begin
83461>>>            Set TableName_Text of ghoStatusPanel to ""
83462>>>            Set Message_Text   of ghoStatusPanel to ""
83463>>>            Set Action_Text    of ghoStatusPanel to ""
83464>>>        End
83464>>>>
83464>>>
83464>>>        Function_Return (bOK = True)
83465>>>    End_Function
83466>>>
83466>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
83466>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
83466>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
83468>>>        Handle hFile
83468>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
83468>>>        Integer iIdentityType iDataType iDbType iCount iSize
83468>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile
83468>>>        tSQLConnection SQLConnection
83468>>>        tSQLConnection SQLConnection
83468>>>        tAPIColumn[] aColumns
83468>>>        tAPIColumn[] aColumns
83469>>>        tColumnType ColumnType
83469>>>        tColumnType ColumnType
83469>>>
83469>>>        // First check if the passed filenumber already exists; in case we do nothing
83469>>>        Get UtilTableExists hTable to bOk
83470>>>        If (bOk = True) Begin
83472>>>            Function_Return False
83473>>>        End
83473>>>>
83473>>>
83473>>>        Set Private.phCurrentTable to hTable
83474>>>        Move sLogicalName to sTableName
83475>>>        If (ghoProgressBar <> 0) Begin
83477>>>            Send DoAdvance of ghoProgressBar
83478>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
83479>>>        End
83479>>>>
83479>>>
83479>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
83480>>>        Get psDriverID to sDriverID
83481>>>        Get IsSQLDriver sDriverID to bSqlDriver
83482>>>        Get piDbType to iDbType
83483>>>
83483>>>        // If no columns passed in, we need to create a "dummy" column
83483>>>        Move False to bDeleteDummy
83484>>>        If (Num_Arguments = 8) Begin
83486>>>            Move aColumnIn to aColumns
83487>>>        End
83487>>>>
83487>>>        If ((SizeOfArray(aColumns)) = 0) Begin
83489>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
83490>>>            Move ColumnType.iSQLType to iDataType
83491>>>            If (bRecnum = False) Begin
83493>>>                Move C_tAPIColumn_Identity to iIdentityType
83494>>>            End
83494>>>>
83494>>>            Else Begin
83495>>>                Move C_tAPIColumn_None     to iIdentityType
83496>>>            End
83496>>>>
83496>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
83497>>>            Move True to bDeleteDummy
83498>>>        End
83498>>>>
83498>>>
83498>>>        // If columns have been passed as an array we need to check if an identity column
83498>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
83498>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
83498>>>        // two identity columns and SQL doesn't like that and throws an error.
83498>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
83500>>>            Move (SizeOfArray(aColumns)) to iSize
83501>>>            Decrement iSize
83502>>>            for iCount from 0 to iSize
83508>>>>
83508>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
83510>>>                    Move False to bRecnum
83511>>>                    Move iSize to iCount
83512>>>                End
83512>>>>
83512>>>            Loop
83513>>>>
83513>>>        End
83513>>>>
83513>>>
83513>>>        // If this is a SQL based driver we also check if the table exists
83513>>>        // in the SQL back end; in case we do nothing.
83513>>>        If (bSqlDriver = True) Begin
83515>>>            // Get all connection properties
83515>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83516>>>            Move SQLConnection.sSchema to sSchema
83517>>>            If (sSchema = "") Begin
83519>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
83520>>>            End
83520>>>>
83520>>>
83520>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
83521>>>            // It can happen that the table is missing from Filelist.cfg but still
83521>>>            // exist on the SQL side, in case we want to search for the table by its name.
83521>>>            If (bExists = False) Begin
83523>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
83524>>>            End
83524>>>>
83524>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
83524>>>            // we will just add it to Filelist.cfg
83524>>>            If (bExists = True) Begin
83526>>>                If (bExistsInFilelist = False) Begin
83528>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
83530>>>                        Move (sDriverID + ":" + sRootName) to sRootName
83531>>>                    End
83531>>>>
83531>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
83534>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
83537>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
83540>>>                    Move False to bSysFile
83541>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
83542>>>                End
83542>>>>
83542>>>                Function_Return False
83543>>>            End
83543>>>>
83543>>>        End
83543>>>>
83543>>>
83543>>>        Move CS_ANSI_Txt to sANSI_OEM
83544>>>        If (num_arguments > 6) Begin
83546>>>            If (bANSI = False) Begin
83548>>>                Move CS_OEM_Txt to sANSI_OEM
83549>>>            End
83549>>>>
83549>>>        End
83549>>>>
83549>>>
83549>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
83549>>>        // is a programmer's error and we auto-correct for it here.
83549>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
83549>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
83549>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
83549>>>        // set it back and use a Mertech function to convert it to SQL.
83549>>>        Get IsMertechDriver sDriverID to bMertechDriver
83550>>>        If (bMertechDriver = True) Begin
83552>>>            If (bUseConnectionID = True) Begin
83554>>>                Move False to bUseConnectionID
83555>>>            End
83555>>>>
83555>>>            Move sDriverID to sOriginalDriverID
83556>>>            Move DATAFLEX_ID to sDriverID
83557>>>        End
83557>>>>
83557>>>
83557>>>        Move False to Err
83558>>>        If (sDriverID = DATAFLEX_ID) Begin
83560>>>            Move sRootName to sPhysicalFile
83561>>>        End
83561>>>>
83561>>>
83561>>>        If (sDriverID <> DATAFLEX_ID) Begin
83563>>>            Move SQLConnection.sConnectionID to sConnectionID
83564>>>
83564>>>            // If DAW driver and we should use a connection id we need to
83564>>>            // check if the connection ID exists; else we create it before attempting creating the table
83564>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
83566>>>                Get IsConnectionID sConnectionID sDriverID to bExists
83567>>>                If (bExists = False) Begin
83569>>>                    Get AutoSetConnectionID sConnectionID to bOk
83570>>>                    If (bOk = False) Begin
83572>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
83573>>>>
83573>>>                        Function_Return False
83574>>>                    End
83574>>>>
83574>>>                End
83574>>>>
83574>>>            End
83574>>>>
83574>>>
83574>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
83576>>>                Move (sTableName + ".int") to sPhysicalFile
83577>>>            End
83577>>>>
83577>>>            Else Begin
83578>>>                Move (sRootName + ".int") to sPhysicalFile
83579>>>            End
83579>>>>
83579>>>            Move (Uppercase(sDisplayName)) to sVal
83580>>>//            If (not(sVal contains (sSchema + "."))) Begin
83580>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
83580>>>//            End
83580>>>        End
83580>>>>
83580>>>        Move False to Err
83581>>>        Move 0 to hFile
83582>>>
83582>>>        Structure_Start hFile sDriverID
83583>>>            If (sDriverID <> DATAFLEX_ID) Begin
83585>>>                If (bUseConnectionID = True) Begin
83587>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
83590>>>                End
83590>>>>
83590>>>                Else Begin
83591>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
83594>>>                End
83594>>>>
83594>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
83597>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
83600>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
83603>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
83606>>>
83606>>>                If (sSchema <> "") Begin
83608>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
83611>>>                End
83611>>>>
83611>>>
83611>>>                If (sDriverID = DB2_DRV_ID) Begin
83613>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
83615>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
83618>>>                    End
83618>>>>
83618>>>                End
83618>>>>
83618>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
83620>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
83622>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
83625>>>                    End
83625>>>>
83625>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
83627>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
83630>>>                    End
83630>>>>
83630>>>                End
83630>>>>
83630>>>            End
83630>>>>
83630>>>
83630>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
83633>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
83634>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
83635>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83637>>>        Set Action_Text of ghoStatusPanel to ""
83638>>>
83638>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
83638>>>        If (bMertechDriver = True) Begin
83640>>>            Move sOriginalDriverID to sDriverID
83641>>>            If (not(sVal contains (sSchema + "."))) Begin
83643>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
83644>>>            End
83644>>>>
83644>>>            // Note: This function also sets the Err flag.
83644>>>            //Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
83644>>>        End
83644>>>>
83644>>>
83644>>>        Move (not(Err)) to bOK
83645>>>        If (bOk = True) Begin
83647>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
83649>>>                Move (sDriverID + ":" + sRootName) to sRootName
83650>>>            End
83650>>>>
83650>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
83653>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
83656>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
83659>>>
83659>>>            // Lastly we remove the temporary column we created above, if all went well.
83659>>>            If (bDeleteDummy) Begin
83661>>>                Get ApiColumnRemove hTable "temp" to bOk
83662>>>            End
83662>>>>
83662>>>        End
83662>>>>
83662>>>
83662>>>        Set TableName_Text of ghoStatusPanel to ""
83663>>>        Close hTable
83664>>>        Function_Return (bOK = True)
83665>>>    End_Function
83666>>>
83666>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
83668>>>        Move False to Err
83669>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
83672>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
83675>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
83678>>>
83678>>>        Function_Return (Err = False)
83679>>>    End_Function
83680>>>
83680>>>    // ToDo: Needs to be revised
83680>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
83682>>>        Handle hTable
83682>>>        String sDEFName sDataPath
83682>>>        Boolean bExists
83682>>>
83682>>>        // Do nothing if MSSQL Driver.
83682>>>//        Get IsMSSQLDriver to bExists
83682>>>//        If (bExists = True) Begin
83682>>>//            Procedure_Return
83682>>>//        End
83682>>>
83682>>>        Get psDataPathFirstPart to sDataPath
83683>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
83684>>>        If (bExists = True) Begin
83686>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
83686>>>            // still be missing from the filelist and needs to be added.
83686>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
83687>>>            If (bExists = True) Begin
83689>>>                Procedure_Return
83690>>>            End
83690>>>>
83690>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
83690>>>            Else Begin
83691>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
83694>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
83697>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
83700>>>                Procedure_Return
83701>>>            End
83701>>>>
83701>>>        End
83701>>>>
83701>>>
83701>>>        Move (sPath + sFileName + ".def") to sDEFName
83702>>>        Move 0 to hTable
83703>>>        Move False to Err
83704>>>
83704>>>        Structure_Start hTable DATAFLEX_ID
83705>>>            Load_Def sDEFName Onto hTable
83706>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
83709>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
83710>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83712>>>        Set Action_Text of ghoStatusPanel to ""
83713>>>
83713>>>        Move iFilelistSlot to hTable
83714>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
83717>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83720>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
83723>>>
83723>>>    End_Procedure
83724>>>
83724>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
83726>>>        Boolean bTmp bErr bOK
83726>>>        String sTableName sDisplayName sFileName
83726>>>
83726>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
83726>>>        Move Err to bTmp
83727>>>        Move False to Err
83728>>>
83728>>>        Get AutoConnectionIDLogin to bOK
83729>>>        // First get the info for the current filelist slot:
83729>>>        Open iFromFileSlot
83731>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
83734>>>        If (bOK = True) Begin
83736>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
83739>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
83742>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
83745>>>
83745>>>            //...then move it.
83745>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
83748>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
83751>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
83754>>>
83754>>>            //...and finally remove the old filelist values.
83754>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
83757>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
83760>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
83763>>>        End
83763>>>>
83763>>>        Close iFromFileSlot
83764>>>
83764>>>        Move Err to bErr
83765>>>        Move bTmp to Err
83766>>>        Function_Return (bErr = False)
83767>>>    End_Function
83768>>>
83768>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
83770>>>        Handle hTable
83770>>>        Boolean bOK
83770>>>        String sDriverID
83770>>>
83770>>>        Get UtilTableExists hTableFrom to bOK
83771>>>        If (bOK = False) Begin
83773>>>            Set Private.phCurrentTable to hTableFrom
83774>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
83775>>>>
83775>>>            Function_Return False
83776>>>        End
83776>>>>
83776>>>
83776>>>        Get UtilTableExists hTableTo to bOK
83777>>>        If (bOK = False) Begin
83779>>>            Set Private.phCurrentTable to hTableTo
83780>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
83781>>>>
83781>>>            Function_Return False
83782>>>        End
83782>>>>
83782>>>
83782>>>        Get AutoConnectionIDLogin to bOK
83783>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
83784>>>        If (bOK = False) Begin
83786>>>            Function_Return False
83787>>>        End
83787>>>>
83787>>>
83787>>>        Move False to Err
83788>>>        Open hTableTo
83790>>>
83790>>>        Move hTableFrom to hTable
83791>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
83794>>>        Set Private.phCurrentTable to hTable
83795>>>
83795>>>        Structure_Start hTable sDriverID
83796>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
83799>>>            If (iColumnTo <> 0) Begin
83801>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
83804>>>            End
83804>>>>
83804>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
83805>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83807>>>        Set Action_Text of ghoStatusPanel to ""
83808>>>
83808>>>        If (hTableTo > 0) Begin
83810>>>            Close hTableTo
83811>>>        End
83811>>>>
83811>>>
83811>>>        Function_Return (Err = False)
83812>>>    End_Function
83813>>>
83813>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
83813>>>    Function ApiTableRemove Handle hTable Returns Boolean
83815>>>        String sTableName sDriverID
83815>>>        Boolean bOk
83815>>>        String sDataPath
83815>>>
83815>>>        Get AutoConnectionIDLogin to bOK
83816>>>        Move False to Err
83817>>>        Get psDriverID to sDriverID
83818>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
83819>>>        If (sTableName = "") Begin
83821>>>            Function_Return False
83822>>>        End
83822>>>>
83822>>>
83822>>>        Set Private.phCurrentTable to hTable
83823>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
83824>>>        Delete_db sTableName
83825>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
83826>>>
83826>>>        If (sDriverID <> DATAFLEX_ID) Begin
83828>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
83828>>>            Get psDataPathFirstPart to sDataPath
83829>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
83830>>>        End
83830>>>>
83830>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
83830>>>        If (hTable <> 0) Begin
83832>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
83835>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
83838>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
83841>>>        End
83841>>>>
83841>>>
83841>>>        Close hTable
83842>>>        Function_Return (hTable <> 0)
83843>>>    End_Function
83844>>>
83844>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
83846>>>        Handle hTable
83846>>>        Boolean bOK
83846>>>
83846>>>        Get AutoConnectionIDLogin to bOK
83847>>>        Move False to Err
83848>>>        Open hTableFrom Mode DF_EXCLUSIVE
83850>>>        Move hTableFrom to hTable
83851>>>
83851>>>        Structure_Start hTable
83852>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
83855>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
83856>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83858>>>        Set Action_Text of ghoStatusPanel to ""
83859>>>
83859>>>        Close hTableFrom
83860>>>        Function_Return (Err = False)
83861>>>    End_Function
83862>>>
83862>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
83864>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
83864>>>        Boolean bOK bExists bOpened
83864>>>        tAPITableNameInfo APITableNameInfo
83864>>>        tAPITableNameInfo APITableNameInfo
83864>>>
83864>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
83867>>>        If (bOpened = False) Begin
83869>>>            Get OpenTableExclusive hTable to bOpened
83870>>>            If (bOpened = False) Begin
83872>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
83873>>>                Function_Return False
83874>>>            End
83874>>>>
83874>>>        End
83874>>>>
83874>>>
83874>>>        Set Private.phCurrentTable to hTable
83875>>>        Move hTable         to APITableNameInfo.iTableNumber
83876>>>        Move sRootName      to APITableNameInfo.sRootName
83877>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
83878>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
83879>>>        Get ApiTableFilelistNamesCompare True APITableNameInfo to bExists
83880>>>        If (bExists = True) Begin
83882>>>            Function_Return True
83883>>>        End
83883>>>>
83883>>>
83883>>>        Set Private.phCurrentTable to hTable
83884>>>        Move False to Err
83885>>>        Get psDataPathFirstPart to sDataPath
83886>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
83889>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
83892>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
83895>>>
83895>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
83898>>>        Close hTable
83899>>>        If (sDriverID = DATAFLEX_ID) Begin
83901>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
83902>>>            If (bExists = True) Begin
83904>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
83906>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
83909>>>                    // We need a short break here before attempting to delete the physical old files or Windows
83909>>>                    // might report "File in use..." and the deletion will fail.
83909>>>                    Sleep 2
83910>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
83911>>>                End
83911>>>>
83911>>>            End
83911>>>>
83911>>>        End
83911>>>>
83911>>>
83911>>>        If (sDriverID <> DATAFLEX_ID) Begin
83913>>>            If (not(sPhysicalName contains ".")) Begin
83915>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
83916>>>            End
83916>>>>
83916>>>
83916>>>            // Change the table name in the .int file to the new table new:
83916>>>            Get UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
83917>>>            If (bOK = False) Begin
83919>>>                Function_Return False
83920>>>            End
83920>>>>
83920>>>
83920>>>            // Change table name at the SQL side:
83920>>>            Get psSchema to sSchema
83921>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
83922>>>
83922>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
83923>>>            // Remove cache file and Rename the physical file names:
83923>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
83924>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
83925>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
83926>>>            Move (sDriverID + ":" + sRootName) to sRootName
83927>>>
83927>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
83927>>>//            If (not(sDisplayName contains ".")) Begin
83927>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
83927>>>//            End
83927>>>        End
83927>>>>
83927>>>
83927>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
83930>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
83933>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
83936>>>
83936>>>        Function_Return (Err = False)
83937>>>    End_Function
83938>>>
83938>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
83940>>>        Move False to Err
83941>>>        Set Private.phCurrentTable to hTable
83942>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
83945>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
83948>>>
83948>>>        Function_Return (Err = False)
83949>>>    End_Function
83950>>>
83950>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
83950>>>    // Note that it first removes any driver prefixes in the rootname.
83950>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
83952>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
83952>>>        Handle hTable
83952>>>        Boolean bIsSame
83952>>>
83952>>>        Move APITableInfo.iTableNumber      to hTable
83953>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
83954>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
83957>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
83958>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
83961>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
83964>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
83965>>>
83965>>>        If (bCompareFilelistUppercase = True) Begin
83967>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
83968>>>        End
83968>>>>
83968>>>        Else Begin
83969>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
83970>>>        End
83970>>>>
83970>>>
83970>>>        Function_Return bIsSame
83971>>>    End_Function
83972>>>
83972>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
83972>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
83974>>>        Handle hTable
83974>>>        String sTableName
83974>>>        String sDriverIDFrom sDriverIDTo
83974>>>        Integer iDbType
83974>>>        Boolean bOk bMertechDriver bOpened bApiTableUpdateAuto
83974>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
83974>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
83974>>>        tSQLConnection SQLConnection
83974>>>        tSQLConnection SQLConnection
83974>>>        tAPITable      APITableFrom APITableTo
83974>>>        tAPITable      APITableFrom APITableTo
83974>>>        tColumnType    ColumnType
83974>>>        tColumnType    ColumnType
83974>>>        tAPIColumnCompare[]   aAPIColumnCompare
83974>>>        tAPIColumnCompare[]   aAPIColumnCompare
83975>>>        tAPIIndexCompare[]    aAPIIndexCompare
83975>>>        tAPIIndexCompare[]    aAPIIndexCompare
83976>>>        tAPIRelationCompare[] aAPIRelationCompare
83976>>>        tAPIRelationCompare[] aAPIRelationCompare
83977>>>
83977>>>        // We don't allow changes to the framework's DbVersion table.
83977>>>        If (Lowercase(sTableName) = "dbversion") Begin
83979>>>            Function_Return False
83980>>>        End
83980>>>>
83980>>>
83980>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
83981>>>        Get piDbType                            to iDbType
83982>>>        Get pbRecnum                            to bRecnum
83983>>>        Get pbToANSI                            to bToANSI
83984>>>        Get pbCopyData                          to bCopyData
83985>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
83986>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
83987>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
83988>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
83989>>>        Get IsMertechDriver sDriverIDFrom       to bMertechDriver
83990>>>        Get pbUseConnectionID                   to bUseConnectionID
83991>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
83993>>>            Move False                          to bUseConnectionID
83994>>>        End
83994>>>>
83994>>>
83994>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
83995>>>        Set Private.phCurrentTable              to hTable
83996>>>        Get UtilTableExists  hTable             to bTableExists
83997>>>
83997>>>        If (ghoProgressBar <> 0) Begin
83999>>>            Send DoAdvance of ghoProgressBar
84000>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
84001>>>            Set Message_Text   of ghoStatusPanel to ""
84002>>>            Set Action_Text    of ghoStatusPanel to ""
84003>>>        End
84003>>>>
84003>>>
84003>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
84004>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
84005>>>        Get UtilTableIsSQL hTable               to bIsSQLTableTo
84006>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
84007>>>        Move True                               to APITableFrom.bFromTable
84008>>>        Move hTable                             to APITableFrom.hTable
84009>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
84010>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
84011>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
84012>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
84013>>>
84013>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
84015>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
84016>>>            If (bOk = True) Begin
84018>>>                Get ApiTableAttachToSql hTable True to bOk
84019>>>                Function_Return bOk
84020>>>            End 
84020>>>>
84020>>>        End
84020>>>>
84020>>>
84020>>>        If (bTableExists = True) Begin
84022>>>            If (bIsSQLTableTo = True) Begin
84024>>>                Get UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
84025>>>            End
84025>>>>
84025>>>
84025>>>            Get OpenTableExclusive hTable to bOpened
84026>>>            If (bOpened = False) Begin
84028>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
84029>>>                Function_Return False
84030>>>            End
84030>>>>
84030>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
84031>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
84032>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
84033>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
84034>>>        End
84034>>>>
84034>>>
84034>>>        Move False to Err
84035>>>        Case Begin
84035>>>            // Alias table:
84035>>>            Case (bIsAliasFrom = True)
84037>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
84038>>>                Case Break
84039>>>
84039>>>            // New Table:
84039>>>            Case (bTableExists = False)
84042>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
84043>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
84043>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
84045>>>                    Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
84046>>>                End                                                                 
84046>>>>
84046>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
84047>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
84048>>>                Case Break
84049>>>
84049>>>            // Update table:
84049>>>            Case (bTableExists = True)
84052>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
84053>>>                If (bIsSame = True) Begin
84055>>>                    Case Break
84056>>>                End
84056>>>>
84056>>>                If (bFilelistError = True) Begin
84058>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
84059>>>                    If (bOk = False) Begin
84061>>>                        Case Break
84062>>>                    End
84062>>>>
84062>>>                End
84062>>>>
84062>>>
84062>>>                If (ghoProgressBar <> 0) Begin
84064>>>                    Send DoAdvance of ghoProgressBar
84065>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
84066>>>                End
84066>>>>
84066>>>
84066>>>                // Columns:
84066>>>                Move True to bOk
84067>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
84068>>>                If (bIsSame = False) Begin
84070>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
84071>>>                End
84071>>>>
84071>>>                If (bOk = False) Begin
84073>>>                    Case Break
84074>>>                End
84074>>>>
84074>>>
84074>>>                // Indexes:
84074>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
84075>>>                If (bIsSame = False) Begin
84077>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
84078>>>                End
84078>>>>
84078>>>
84078>>>                // Relations:
84078>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
84079>>>                If (bIsSame = False) Begin
84081>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
84082>>>                    If (bOk = False) Begin
84084>>>                        Case Break
84085>>>                    End
84085>>>>
84085>>>                End
84085>>>>
84085>>>
84085>>>                Case Break
84086>>>
84086>>>            Case Else
84086>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
84087>>>>
84087>>>                Move False to bOk
84088>>>        Case End
84088>>>        
84088>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
84088>>>        // or convert an embedded table to SQL
84088>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
84090>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
84091>>>            If (bOk = False) Begin
84093>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
84094>>>            End
84094>>>>
84094>>>        End
84094>>>>
84094>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
84097>>>            Get SqlTableConvertToEmbedded hTable True to bOk
84098>>>        End
84098>>>>
84098>>>        
84098>>>        // Filelist Names:
84098>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
84099>>>        Close hTable
84100>>>        Set TableName_Text of ghoStatusPanel to ""
84101>>>
84101>>>        Function_Return (bOK = True)
84102>>>    End_Function
84103>>>
84103>>>    // * Dummy function for the Studio's Code Explorer *
84103>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
84105>>>        Function_Return False
84106>>>    End_Function
84107>>>
84107>>>    // Adds a column name to the passed table number.
84107>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
84109>>>        Integer iColumn iCount iFile iPrecision iLastErr
84109>>>        Boolean bExists bOK bInitializeValue bRetval bMertechDriver
84109>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
84109>>>
84109>>>        Get UtilColumnExists hTable sFieldName to bExists
84110>>>        If (bExists = True) Begin
84112>>>            Function_Return False
84113>>>        End
84113>>>>
84113>>>
84113>>>        Move False to Err
84114>>>        If (num_arguments > 4) Begin
84116>>>            Move iPrec to iPrecision
84117>>>        End
84117>>>>
84117>>>        If (num_arguments > 6) Begin
84119>>>            Move bInitVal to bInitializeValue
84120>>>            Move sColVal  to sColumnValue
84121>>>        End
84121>>>>
84121>>>        If (iType < -1490) Begin
84123>>>            Move (iType + 1500) to iType
84124>>>        End
84124>>>>
84124>>>
84124>>>        Move hTable to iFile
84125>>>        Get psDriverID to sDriverID
84126>>>        Get IsMertechDriver sDriverID to bMertechDriver
84127>>>        Get AutoConnectionIDLogin to bOK
84128>>>        Move False to Err
84129>>>        Move LastErr to iLastErr
84130>>>        Open iFile Mode DF_EXCLUSIVE
84132>>>        Set Private.phCurrentTable to hTable
84133>>>        Structure_Start iFile sDriverID
84134>>>            Move 0 to iColumn
84135>>>            Set Private.piCurrentField to iColumn
84136>>>            Create_Field hTable At iColumn
84137>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
84140>>>            If (bMertechDriver = True) Begin
84142>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84143>>>                Send Ignore_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
84144>>>            End
84144>>>>
84144>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
84147>>>            If (bMertechDriver = True) Begin
84149>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
84150>>>                Send Trap_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
84151>>>                Move False to Err
84152>>>                Move iLastErr to LastErr
84153>>>            End
84153>>>>
84153>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
84156>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
84159>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84160>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84162>>>
84162>>>        Set Action_Text of ghoStatusPanel to ""
84163>>>
84163>>>        // If in development environment; create .fd file:
84163>>>        Open hTable
84165>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
84166>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
84167>>>        If (iCount > 1) Begin
84169>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
84170>>>        End
84170>>>>
84170>>>        Get vFolderExists sDDSrcPath to bExists
84171>>>        If (bExists = True) Begin
84173>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
84174>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
84177>>>            Get _TableNameOnly sTableName to sTableName
84178>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
84180>>>        End
84180>>>>
84180>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
84182>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
84183>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
84184>>>            If (iCount > 1) Begin
84186>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
84187>>>            End
84187>>>>
84187>>>            Get vFolderFormat sDataPath to sDataPath
84188>>>            // Add the new column name to the .tag filen (if it doesn't exist):
84188>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
84188>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
84188>>>        End
84188>>>>
84188>>>        // Check for a default value
84188>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
84190>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
84191>>>        End
84191>>>>
84191>>>        Close hTable
84192>>>
84192>>>        Function_Return (Err = False)
84193>>>    End_Function
84194>>>
84194>>>    // Adds a column name to the passed table number.
84194>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
84196>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
84196>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
84196>>>        String sDdSrcPath sTableName
84196>>>
84196>>>        Get UtilColumnExists hTable sFieldName to bExists
84197>>>        Move False to Err
84198>>>        If (bExists = True) Begin
84200>>>            Function_Return False
84201>>>        End
84201>>>>
84201>>>        If (num_arguments > 4) Begin
84203>>>            Move iPrec to iPrecision
84204>>>        End
84204>>>>
84204>>>        If (iType < -1490) Begin
84206>>>            Move (iType + 1500) to iType
84207>>>        End
84207>>>>
84207>>>
84207>>>        Get AutoConnectionIDLogin to bOK
84208>>>        Move False to Err
84209>>>        Get UtilTableIsSql hTable to bIsSQLTypeTo
84210>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
84210>>>        // data types between Embedded and SQL, else we can't compare the data types. 
84210>>>        Get piDbType to iDbType
84211>>>        If (bIsSQLTypeTo = False) Begin
84213>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
84214>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
84216>>>                Move DF_DATE to iType
84217>>>            End
84217>>>>
84217>>>        End
84217>>>>
84217>>>
84217>>>        // Structure_start will change the value of hTable...
84217>>>        Move hTable to iFile
84218>>>        Get OpenTableExclusive iFile to bOK
84219>>>        If (bOK = False) Begin
84221>>>            Function_Return False
84222>>>        End
84222>>>>
84222>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
84225>>>
84225>>>        // If the passed column number is higher than the current number of fields
84225>>>        // in the table, this means we should _not_ insert a field but rather add
84225>>>        // a new field to the end:
84225>>>        If (iColumn > iNumberOfFields) Begin
84227>>>            Move 0 to iColumn
84228>>>        End
84228>>>>
84228>>>
84228>>>        Set Private.phCurrentTable to hTable
84229>>>        Set Private.piCurrentField to iColumn
84230>>>
84230>>>        Structure_Start iFile
84231>>>            Create_Field iFile At iColumn
84232>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
84235>>>            If (bIsSQLTypeTo = False) Begin
84237>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
84240>>>            End
84240>>>>
84240>>>            Else Begin
84241>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
84244>>>            End
84244>>>>
84244>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
84245>>>            If (bIsDateType = False) Begin
84247>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
84250>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
84253>>>            End
84253>>>>
84253>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84254>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84256>>>
84256>>>        Set Action_Text of ghoStatusPanel to ""
84257>>>        // If in development environment; create .fd file:
84257>>>        Open hTable
84259>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
84260>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
84261>>>        If (iCount > 1) Begin
84263>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
84264>>>        End
84264>>>>
84264>>>        Get vFolderExists sDDSrcPath to bExists
84265>>>        If (bExists = True) Begin
84267>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
84268>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
84271>>>            Get _TableNameOnly sTableName to sTableName
84272>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
84274>>>        End
84274>>>>
84274>>>
84274>>>        // Check for a default value
84274>>>        Close hTable
84275>>>
84275>>>        Function_Return (Err = False)
84276>>>    End_Function
84277>>>
84277>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean
84277>>>//        Integer iColumn iCount iFile
84277>>>//        Boolean bExists bOK
84277>>>//        String sDdSrcPath sTableName
84277>>>//
84277>>>//        Get AutoConnectionIDLogin to bOK
84277>>>//        Move False to Err
84277>>>//
84277>>>//        // Structure_start will change the value of hTable...
84277>>>//        Move hTable to iFile
84277>>>//        Open iFile Mode DF_EXCLUSIVE
84277>>>//
84277>>>//        Structure_Start iFile
84277>>>//            Send ApiColumnsAddToTable iFile aColumns False
84277>>>//        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84277>>>//
84277>>>//        // If in development environment; create .fd file:
84277>>>//        Open hTable
84277>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
84277>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
84277>>>//        If (iCount > 1) Begin
84277>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
84277>>>//        End
84277>>>//        Get vFolderExists sDDSrcPath to bExists
84277>>>//        If (bExists = True) Begin
84277>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath
84277>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
84277>>>//            Get _TableNameOnly sTableName to sTableName
84277>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
84277>>>//        End
84277>>>//        Close hTable
84277>>>//
84277>>>//        Function_Return (Err = False)
84277>>>//    End_Function
84277>>>
84277>>>    // To update all records for a table column with a fixed value.
84277>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
84279>>>        Integer iRecs iCurrErr iField iRecord
84279>>>        Boolean bRetval bOpen
84279>>>
84279>>>        Move 0 to iRecs
84280>>>        Move False to bRetval
84281>>>        Move Err to iCurrErr
84282>>>        Move False to Err
84283>>>
84283>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
84286>>>        If (bOpen = False) Begin
84288>>>            Open hTable
84290>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
84293>>>            If (bOpen = False) Begin
84295>>>                Function_Return bRetval
84296>>>            End
84296>>>>
84296>>>        End
84296>>>>
84296>>>
84296>>>        Field_Map hTable sFieldName to iField
84298>>>        If (iField <> 0) Begin
84300>>>            Set Private.phCurrentTable to hTable
84301>>>            Set Private.piCurrentField to iField
84302>>>            Clear hTable
84303>>>            Repeat
84303>>>>
84303>>>                Vfind hTable 0 GT
84305>>>                If (Found) Begin
84307>>>                    If (ghoStatusPanel <> 0) Begin
84309>>>                        Get_Field_Value hTable 0 to iRecord
84312>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
84313>>>                    End
84313>>>>
84313>>>                    Reread hTable
84317>>>                        Set_Field_Value hTable iField to sColumnValue
84320>>>                        SaveRecord hTable
84321>>>                    Unlock
84322>>>>
84322>>>                End
84322>>>>
84322>>>           Until (not(Found))
84324>>>        End
84324>>>>
84324>>>
84324>>>        Move (Err = False) to bRetval
84325>>>        Move iCurrErr to Err
84326>>>
84326>>>        Function_Return bRetval
84327>>>    End_Function
84328>>>
84328>>>    // Note: This can only be used from within a Structure_Start/End construct.
84328>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
84330>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
84330>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
84330>>>        String sFieldName sDriverID sTableName sDefaultValue
84330>>>
84330>>>//        Set Private.phCurrentTable to hTable
84330>>>        Get psDriverID to sDriverID
84331>>>        Get piDbType to iDbType
84332>>>        Get UtilTableHandleToString hTable to sTableName
84333>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
84334>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
84335>>>        Get UtilTableIsSQL hTable to bIsSqlTable
84336>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
84338>>>            Move True to bIsSqlTable
84339>>>        End
84339>>>>
84339>>>        Move False to bIsOpen
84340>>>        If (hTable > 0) Begin
84342>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
84345>>>        End
84345>>>>
84345>>>        If (bIsOpen = True) Begin
84347>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
84350>>>        End
84350>>>>
84350>>>        Else Begin
84351>>>            Get pbRecnum to bRecnumTable
84352>>>        End
84352>>>>
84352>>>
84352>>>        Move False to Err
84353>>>        Move (SizeOfArray(aColumns)) to iSize
84354>>>        Decrement iSize
84355>>>        for iCount from 0 to iSize
84361>>>>
84361>>>            Move aColumns[iCount].sFieldName to sFieldName
84362>>>            If (hTable > 0) Begin
84364>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84365>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84366>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
84369>>>                Move (Trim(sFieldName) <> "") to bFieldExists
84370>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
84371>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84372>>>            End
84372>>>>
84372>>>            Else Begin
84373>>>                Move False to bFieldExists
84374>>>            End
84374>>>>
84374>>>
84374>>>            If (bFieldExists = False) Begin
84376>>>                Move 0 to iColumn
84377>>>                Create_Field hTable At iColumn
84378>>>            End
84378>>>>
84378>>>            Else Begin
84379>>>                Move iCount to iColumn
84380>>>            End
84380>>>>
84380>>>
84380>>>            Set Private.piCurrentField to iColumn
84381>>>
84381>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
84382>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
84385>>>
84385>>>            Move aColumns[iCount].iType to iType
84386>>>            Move (not(iType < -1490)) to bNativeType
84387>>>            If (iType < -1490) Begin
84389>>>                Move (iType + 1500) to iType
84390>>>            End
84390>>>>
84390>>>
84390>>>            If (bIsSqlTable = True) Begin
84392>>>                If (aColumns[iCount].bIsSQLType = True) Begin
84394>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
84395>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
84398>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
84401>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
84404>>>
84404>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
84405>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
84407>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
84408>>>                    End
84408>>>>
84408>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
84411>>>
84411>>>                End
84411>>>>
84411>>>                Else Begin
84412>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
84415>>>                End
84415>>>>
84415>>>            End
84415>>>>
84415>>>            Else Begin
84416>>>                If (bCreating = False) Begin
84418>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
84419>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
84421>>>                        Move DF_DATE to iType
84422>>>                    End
84422>>>>
84422>>>                End
84422>>>>
84422>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
84425>>>            End
84425>>>>
84425>>>
84425>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
84426>>>            If (bIsDateType = False) Begin
84428>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
84431>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
84434>>>            End
84434>>>>
84434>>>
84434>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
84436>>>                Move 0 to iIndex
84437>>>                Create_Index hTable at iIndex
84438>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
84441>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
84444>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
84447>>>
84447>>>                // If we have an identity table - we must create a primary_key table.
84447>>>                If (bIsSqlTable = True) Begin
84449>>>                End
84449>>>>
84449>>>            End
84449>>>>
84449>>>        Loop
84450>>>>
84450>>>
84450>>>        Function_Return (Err = False)
84451>>>    End_Function
84452>>>
84452>>>    // Changes a field type, length and precision for the passed table number and field name
84452>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
84454>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
84454>>>        Boolean bOK bIsSqlTable
84454>>>        String sFieldNameTo
84454>>>
84454>>>        If (num_arguments > 4) Begin
84456>>>            Move iPrec to iPrecFrom
84457>>>        End
84457>>>>
84457>>>        If (iTypeFrom < -1490) Begin
84459>>>            Move (iTypeFrom + 1500) to iTypeFrom
84460>>>        End
84460>>>>
84460>>>
84460>>>        Get AutoConnectionIDLogin to bOK
84461>>>        Move False to Err
84462>>>        Get OpenTableExclusive hTable to bOK
84463>>>        If (bOK = False) Begin
84465>>>            Function_Return False
84466>>>        End
84466>>>>
84466>>>
84466>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84467>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84468>>>        Field_Map hTable sFieldNameFrom to iColumn
84470>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84471>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84472>>>        If (Err = True) Begin
84474>>>            Function_Return False
84475>>>        End
84475>>>>
84475>>>
84475>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
84478>>>        Get UtilTableIsSQL hTable to bIsSqlTable
84479>>>        If (bIsSqlTable = False) Begin
84481>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
84484>>>        End
84484>>>>
84484>>>        Else Begin
84485>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
84488>>>        End
84488>>>>
84488>>>        // Let the driver decide the other values;
84488>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
84491>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
84494>>>
84494>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
84496>>>            Function_Return False
84497>>>        End
84497>>>>
84497>>>
84497>>>        Set Private.phCurrentTable to hTable
84498>>>        Set Private.piCurrentField to iColumn
84499>>>
84499>>>        Structure_Start hTable
84500>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
84503>>>//            If (bIsSqlTable = False) Begin
84503>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
84506>>>//            End
84506>>>//            Else Begin
84506>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
84506>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
84506>>>//            End
84506>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
84509>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
84512>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84513>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84515>>>
84515>>>        Set Action_Text of ghoStatusPanel to ""
84516>>>        Function_Return (Err = False)
84517>>>    End_Function
84518>>>
84518>>>    // Changes a field type, length and precision for the passed table number and field name
84518>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
84520>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
84520>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
84520>>>        String sFieldNameTo sDriverIDTo
84520>>>        tColumnType ColumnType
84520>>>        tColumnType ColumnType
84520>>>
84520>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
84521>>>        Get piDbType to iDbType
84522>>>        If (num_arguments > 4) Begin
84524>>>            Move iPrec to iPrecFrom
84525>>>            Move iOpt  to iOptionFrom
84526>>>        End
84526>>>>
84526>>>        If (iTypeFrom < -1490) Begin
84528>>>            Move (iTypeFrom + 1500) to iTypeFrom
84529>>>        End
84529>>>>
84529>>>
84529>>>        Get AutoConnectionIDLogin to bOK
84530>>>        Move False to Err
84531>>>        Close hTable
84532>>>        Get OpenTableExclusive hTable to bOK
84533>>>        If (bOK = False) Begin
84535>>>            Function_Return False
84536>>>        End
84536>>>>
84536>>>
84536>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
84539>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
84542>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
84543>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
84545>>>            Move DF_DATE to iDataFlexType
84546>>>        End
84546>>>>
84546>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
84549>>>
84549>>>        If (bIsSQLTableTo = True) Begin
84551>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
84554>>>        End
84554>>>>
84554>>>        Else Begin
84555>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
84558>>>        End
84558>>>>
84558>>>
84558>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
84561>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
84564>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
84567>>>
84567>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
84567>>>        // data types between Embedded and SQL, else we can't compare the data types.
84567>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
84569>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
84570>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
84572>>>                Move DF_DATE to iTypeTo  
84573>>>            End
84573>>>>
84573>>>        End
84573>>>>
84573>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
84576>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
84577>>>        End
84577>>>>
84577>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
84578>>>
84578>>>        If (bCompareDate_DateTime = False) Begin
84580>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
84581>>>            If (bSkip = True) Begin
84583>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
84585>>>                    Function_Return True
84586>>>                End
84586>>>>
84586>>>            End
84586>>>>
84586>>>        End
84586>>>>
84586>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
84589>>>            Function_Return True
84590>>>        End
84590>>>>
84590>>>
84590>>>        Set Private.phCurrentTable to hTable
84591>>>        Set Private.piCurrentField to iColumn
84592>>>
84592>>>        Structure_Start hTable
84593>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
84595>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
84598>>>            End
84598>>>>
84598>>>
84598>>>            If (bIsSameDataType = False) Begin
84600>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
84603>>>                If (bIsSQLTableTo = True) Begin
84605>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
84608>>>                End
84608>>>>
84608>>>            End
84608>>>>
84608>>>
84608>>>            If (iLengthFrom <> iLengthTo) Begin
84610>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
84613>>>            End
84613>>>>
84613>>>            If (iPrecFrom <> iPrecTo) Begin
84615>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
84618>>>            End
84618>>>>
84618>>>
84618>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
84620>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
84620>>>                If (bRecnumTable = True) Begin
84622>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
84625>>>                End
84625>>>>
84625>>>
84625>>>                // We might need to create an index here.
84625>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
84625>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
84625>>>                // index update checking logic.
84625>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
84628>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
84630>>>                    Create_Index hTable At iIndex
84631>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
84634>>>                End
84634>>>>
84634>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
84637>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
84640>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
84643>>>                If (bIsSQLTableTo = True) Begin
84645>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
84648>>>                End
84648>>>>
84648>>>            End
84648>>>>
84648>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84649>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84651>>>
84651>>>        Set Action_Text of ghoStatusPanel to ""
84652>>>        Function_Return (Err = False)
84653>>>    End_Function
84654>>>
84654>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
84656>>>        Boolean bOK
84656>>>
84656>>>        Get AutoConnectionIDLogin to bOK
84657>>>        Move False to Err
84658>>>        Get OpenTableExclusive hTable to bOK
84659>>>        If (bOK = False) Begin
84661>>>            Function_Return False
84662>>>        End
84662>>>>
84662>>>
84662>>>        Structure_Start hTable
84663>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
84666>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84667>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84669>>>
84669>>>        Set Action_Text of ghoStatusPanel to ""
84670>>>        Function_Return (Err = False)
84671>>>    End_Function
84672>>>
84672>>>    // To move an existing field to another position in a table.
84672>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
84674>>>        String sColumn sDriverID
84674>>>        Integer iType
84674>>>        Boolean bOK bIsDate
84674>>>
84674>>>        Close hTable
84675>>>        Get AutoConnectionIDLogin to bOK
84676>>>        Get OpenTableExclusive hTable to bOK
84677>>>        If (bOK = False) Begin
84679>>>            Function_Return False
84680>>>        End
84680>>>>
84680>>>
84680>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
84683>>>        If (sDriverID = DFBTRDRV_ID) Begin
84685>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
84686>>>>
84686>>>            Function_Return False
84687>>>        End
84687>>>>
84687>>>
84687>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
84690>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
84693>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
84694>>>
84694>>>        Set Private.phCurrentTable to hTable
84695>>>        Set Private.piCurrentField to iOld
84696>>>
84696>>>//        If (bIsDate = False) Begin
84696>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
84696>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
84696>>>//        End
84696>>>//        Else Begin
84696>>>//            Move 6 to iLength
84696>>>//            Move 0 to iPrecision
84696>>>//        End
84696>>>
84696>>>        Move False to Err
84697>>>
84697>>>        Structure_Start hTable
84698>>>            Delete_Field hTable iOld
84699>>>            Create_Field hTable At iNew
84700>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
84703>>>
84703>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
84706>>>            If (bIsSQLType = False) Begin
84708>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
84711>>>            End
84711>>>>
84711>>>            Else Begin
84712>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
84715>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
84715>>>            End
84715>>>>
84715>>>
84715>>>            If (bIsDate = False) Begin
84717>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
84720>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
84723>>>            End
84723>>>>
84723>>>
84723>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84724>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84726>>>
84726>>>        Set Action_Text of ghoStatusPanel to ""
84727>>>        Function_Return (Err = False)
84728>>>    End_Function
84729>>>
84729>>>    // Deletes a column name for the passed table number (and column number).
84729>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
84731>>>        Integer iColumn
84731>>>        Boolean bOK
84731>>>
84731>>>        Get AutoConnectionIDLogin to bOK
84732>>>        Move False to Err
84733>>>        Close hTable
84734>>>        Get OpenTableExclusive hTable to bOK
84735>>>        If (bOK = False) Begin
84737>>>            Function_Return False
84738>>>        End
84738>>>>
84738>>>
84738>>>        If (not(Err)) Begin
84740>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84741>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84742>>>            Field_Map hTable sFieldName to iColumn
84744>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
84745>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84746>>>            If (iColumn = 0) Begin
84748>>>                Move 0 to LastErr
84749>>>                Function_Return False
84750>>>            End
84750>>>>
84750>>>            Move False to Err
84751>>>
84751>>>            Set Private.phCurrentTable to hTable
84752>>>            Set Private.piCurrentField to iColumn
84753>>>
84753>>>            Structure_Start hTable
84754>>>                Delete_Field hTable iColumn
84755>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
84756>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84758>>>            Set Action_Text of ghoStatusPanel to ""
84759>>>        End
84759>>>>
84759>>>        Else Begin
84760>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
84761>>>>
84761>>>        End
84761>>>>
84761>>>
84761>>>        Function_Return (Err = False)
84762>>>    End_Function
84763>>>
84763>>>    // Renames a field for the passed table number & old field name & new field name
84763>>>    // Returns True if no errors occured.
84763>>>    // Sample usage:
84763>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
84763>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
84765>>>        Integer iField
84765>>>        Boolean bOK bExists bIsOpen
84765>>>
84765>>>        Get UtilColumnExists hTable sNewFieldName to bExists
84766>>>        If (bExists = True) Begin
84768>>>            Function_Return False
84769>>>        End
84769>>>>
84769>>>
84769>>>        // Note: The Field_Map command does _not_ work if the table has been
84769>>>        //       opened exclusively, so we first open it in normal mode.
84769>>>        Close hTable
84770>>>        Open hTable
84772>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
84775>>>        If (bIsOpen = False) Begin
84777>>>            Function_Return False
84778>>>        End
84778>>>>
84778>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84779>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84780>>>        Field_Map hTable sOldFieldName to iField
84782>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84783>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84784>>>
84784>>>        Get AutoConnectionIDLogin to bOK
84785>>>        Get OpenTableExclusive hTable to bOK
84786>>>        If (bOK = False) Begin
84788>>>            Function_Return False
84789>>>        End
84789>>>>
84789>>>
84789>>>        Move False to Err
84790>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
84791>>>        Set Private.phCurrentTable to hTable
84792>>>        Set Private.piCurrentField to iField
84793>>>
84793>>>        If (iField > 0) Begin
84795>>>            Structure_Start hTable
84796>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
84799>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
84800>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84802>>>        End
84802>>>>
84802>>>        Else Begin
84803>>>            Move 0 to LastErr
84804>>>            Move False to Err
84805>>>        End
84805>>>>
84805>>>
84805>>>        Set Action_Text of ghoStatusPanel to ""
84806>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
84807>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84808>>>
84808>>>        Function_Return (Err = False)
84809>>>    End_Function
84810>>>
84810>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
84812>>>        tAPIColumnCompare[] aAPIColumnsToInsert
84812>>>        tAPIColumnCompare[] aAPIColumnsToInsert
84813>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
84813>>>        Boolean bRenameField
84813>>>
84813>>>        Open hTable
84815>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84816>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84817>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
84818>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
84821>>>        Move (iSize max iNumberOfFieldsTo) to iSize
84822>>>        Decrement iSize
84823>>>        for iCount from 0 to iSize
84829>>>>
84829>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
84831>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84832>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84833>>>
84833>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
84835>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
84837>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
84838>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
84839>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
84841>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
84842>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
84843>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
84844>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
84845>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
84846>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
84847>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
84848>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
84849>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
84850>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
84851>>>                        Increment iItem
84852>>>                    End
84852>>>>
84852>>>                End
84852>>>>
84852>>>            End
84852>>>>
84852>>>        Loop
84853>>>>
84853>>>
84853>>>        Move False to Err
84854>>>        Move 0 to LastErr
84855>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84856>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84857>>>        Function_Return aAPIColumnsToInsert
84858>>>    End_Function
84859>>>
84859>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
84861>>>        Integer iSize iCount
84861>>>        Boolean bOK
84861>>>        tAPIColumn[] aColumnsTo
84861>>>        tAPIColumn[] aColumnsTo
84862>>>        tAPIColumnCompare[] aAPIColumnCompare
84862>>>        tAPIColumnCompare[] aAPIColumnCompare
84863>>>
84863>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
84864>>>        If (iSize = 0) Begin
84866>>>            Function_Return True
84867>>>        End
84867>>>>
84867>>>
84867>>>        Move False to Err
84868>>>        Decrement iSize
84869>>>        for iCount from 0 to iSize
84875>>>>
84875>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
84876>>>        Loop
84877>>>>
84877>>>
84877>>>        Function_Return bOK
84878>>>    End_Function
84879>>>
84879>>>    // Returns a struct array with fields that has the same names but different field numbers.
84879>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
84881>>>        tAPIColumnCompare[] aAPIColumnsToMove
84881>>>        tAPIColumnCompare[] aAPIColumnsToMove
84882>>>        Integer iSize iCount iItem iShouldMove
84882>>>
84882>>>        Move 0 to iItem
84883>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
84884>>>        Decrement iSize
84885>>>        for iCount from 0 to iSize
84891>>>>
84891>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
84893>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
84894>>>                If (iShouldMove <> -1) Begin
84896>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
84897>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
84898>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
84899>>>                    Increment iItem
84900>>>                End
84900>>>>
84900>>>            End
84900>>>>
84900>>>        Loop
84901>>>>
84901>>>
84901>>>        Move False to Err
84902>>>        Move 0 to LastErr
84903>>>        Function_Return aAPIColumnsToMove
84904>>>    End_Function
84905>>>
84905>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
84907>>>        Integer iSize iCount
84907>>>        Boolean bOK
84907>>>        tAPIColumnCompare[] aAPIColumnCompare
84907>>>        tAPIColumnCompare[] aAPIColumnCompare
84908>>>
84908>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
84909>>>        If (iSize = 0) Begin
84911>>>            Function_Return True
84912>>>        End
84912>>>>
84912>>>
84912>>>        Move False to Err
84913>>>        Decrement iSize
84914>>>        for iCount from 0 to iSize
84920>>>>
84920>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84921>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
84922>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
84924>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
84925>>>                Get UtilColumnsStructFill hTable to aColumnsTo
84926>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
84927>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
84928>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
84930>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
84931>>>                    Decrement iSize
84932>>>                    Move 0 to iCount
84933>>>                End
84933>>>>
84933>>>            End
84933>>>>
84933>>>        Loop
84934>>>>
84934>>>
84934>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84935>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
84936>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
84938>>>            Move 0 to LastErr
84939>>>        End
84939>>>>
84939>>>        Function_Return bOK
84940>>>    End_Function
84941>>>
84941>>>    // Checks if the "FROM" and "TO" database field is the same _except_ for the field name.
84941>>>    // We then assume this field should be renamed.
84941>>>//    Function UtilColumCheckRename Handle hTable tAPIColumnCompare aAPIColumnCompare Returns Boolean
84941>>>//        Boolean bDifferentFieldNames bShouldBeRenamed
84941>>>//
84941>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84941>>>//        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom) <> Uppercase(aAPIColumnCompare.sFieldNameTo)) to bDifferentFieldNames
84941>>>//
84941>>>//        If (bDifferentFieldNames = True) Begin
84941>>>//            Move (aAPIColumnCompare.iFieldNumber = aAPIColumnCompare.iFieldNumberTo) to bShouldBeRenamed
84941>>>//            If (bShouldBeRenamed = False) Begin
84941>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
84941>>>//                Function_Return False
84941>>>//            End
84941>>>//
84941>>>//            Move (aAPIColumnCompare.iTypeFrom = aAPIColumnCompare.iTypeTo) to bShouldBeRenamed
84941>>>//            If (bShouldBeRenamed = False) Begin
84941>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
84941>>>//                Function_Return False
84941>>>//            End
84941>>>//
84941>>>//            Move (aAPIColumnCompare.iLengthFrom = aAPIColumnCompare.iLengthTo) to bShouldBeRenamed
84941>>>//            If (bShouldBeRenamed = False) Begin
84941>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
84941>>>//                Function_Return False
84941>>>//            End
84941>>>//
84941>>>//            Move (aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo) to bShouldBeRenamed
84941>>>//            If (bShouldBeRenamed = False) Begin
84941>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
84941>>>//                Function_Return False
84941>>>//            End
84941>>>//        End
84941>>>//
84941>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
84941>>>//        Function_Return True
84941>>>//    End_Function
84941>>>
84941>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
84941>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
84941>>>    // - The "FROM" field name is <> "TO" field name
84941>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
84941>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
84941>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
84943>>>        Boolean bShouldRename
84943>>>        String sFieldNameFrom sFieldNameTo
84943>>>
84943>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
84944>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
84945>>>        If (sFieldNameFrom = sFieldNameTo) Begin
84947>>>            Function_Return False
84948>>>        End
84948>>>>
84948>>>
84948>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
84949>>>//        If (bShouldRename = False) Begin
84949>>>//            Function_Return False
84949>>>//        End
84949>>>//
84949>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
84949>>>//            Function_Return True
84949>>>//        End
84949>>>
84949>>>        Function_Return bShouldRename
84950>>>    End_Function
84951>>>
84951>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
84951>>>    // Else it returns the column/field number of the field that exists in another position.
84951>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
84953>>>        Integer iCount iSize iRetval
84953>>>        String sFieldNameFrom
84953>>>
84953>>>        Move -1 to iRetval
84954>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
84956>>>            Function_Return iRetval
84957>>>        End
84957>>>>
84957>>>
84957>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
84958>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
84959>>>        Decrement iSize
84960>>>        for iCount from 0 to iSize
84966>>>>
84966>>>            // We're only interested in fields other than the passed field/column number:
84966>>>            If (iCount <> iColumn) Begin
84968>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
84970>>>                    Move (iCount + 1) to iRetval
84971>>>                End
84971>>>>
84971>>>            End
84971>>>>
84971>>>        Loop
84972>>>>
84972>>>
84972>>>        Move 0 to LastErr
84973>>>        Function_Return iRetval
84974>>>    End_Function
84975>>>
84975>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
84977>>>        tAPIColumnCompare[] aAPIColumnsToRename
84977>>>        tAPIColumnCompare[] aAPIColumnsToRename
84978>>>        Integer iSize iCount iItem iFieldTo iShouldMove
84978>>>        Boolean bRenameField
84978>>>
84978>>>        Open hTable
84980>>>        Move 0 to iItem
84981>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
84982>>>        Decrement iSize
84983>>>        for iCount from 0 to iSize
84989>>>>
84989>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
84991>>>                // Check if the field exists in another position (other field number)
84991>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
84992>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
84993>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
84995>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
84996>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
84997>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
84998>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
84999>>>                    Increment iItem
85000>>>                End
85000>>>>
85000>>>            End
85000>>>>
85000>>>        Loop
85001>>>>
85001>>>
85001>>>        Move False to Err
85002>>>        Move 0 to LastErr
85003>>>        Function_Return aAPIColumnsToRename
85004>>>    End_Function
85005>>>
85005>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
85007>>>        Integer iSize iCount
85007>>>        Boolean bOK
85007>>>        tAPIColumn[] aColumnsTo
85007>>>        tAPIColumn[] aColumnsTo
85008>>>        tAPIColumnCompare[] aAPIColumnCompare
85008>>>        tAPIColumnCompare[] aAPIColumnCompare
85009>>>
85009>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
85010>>>        If (iSize = 0) Begin
85012>>>            Function_Return True
85013>>>        End
85013>>>>
85013>>>
85013>>>        Move False to Err
85014>>>        Decrement iSize
85015>>>        For iCount from 0 to iSize
85021>>>>
85021>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85022>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
85023>>>        Loop
85024>>>>
85024>>>
85024>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85025>>>        Function_Return bOK
85026>>>    End_Function
85027>>>
85027>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
85029>>>        Boolean bDateType
85029>>>
85029>>>        If (bIsSQLTableTo = True) Begin
85031>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
85032>>>        End
85032>>>>
85032>>>        Else Begin
85033>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
85034>>>        End
85034>>>>
85034>>>
85034>>>        Function_Return bDateType
85035>>>    End_Function
85036>>>
85036>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
85038>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
85038>>>        Integer iCount2 iColumn2
85038>>>        Handle hFile
85038>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
85038>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
85038>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
85038>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
85038>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
85043>>>        tColumnType ColumnType
85043>>>        tColumnType ColumnType
85043>>>
85043>>>        Move False to Err
85044>>>        Close hTable
85045>>>        Get OpenTableExclusive hTable to bIsOpen
85046>>>        If (bIsOpen = False) Begin
85048>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
85049>>>>
85049>>>            Function_Return False
85050>>>        End 
85050>>>>
85050>>>        
85050>>>        Get piDbType to iDbType
85051>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
85054>>>        Move bIsSQLTableFrom to bIsSQLDriver
85055>>>        Get UtilTableIsSQL hTable to bIsSQLTableTo
85056>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
85059>>>
85059>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
85060>>>
85060>>>        // Before we start to change the table we need to do three things;
85060>>>        // 1) Insert any new fields
85060>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
85061>>>        If (SizeOfArray(aApiInsertColumns)) Begin
85063>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
85064>>>            If (bOK = False) Begin
85066>>>                Function_Return False
85067>>>            End
85067>>>>
85067>>>            // Update info with changes made.
85067>>>            Get UtilColumnsStructFill hTable to aColumnsTo
85068>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
85069>>>        End
85069>>>>
85069>>>
85069>>>        // 2) Move fields with same names
85069>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
85070>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
85072>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
85073>>>            If (bOK = False) Begin
85075>>>                Function_Return False
85076>>>            End
85076>>>>
85076>>>            Get UtilColumnsStructFill hTable to aColumnsTo
85077>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
85078>>>        End
85078>>>>
85078>>>        
85078>>>        // 3) Rename fields
85078>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
85079>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
85081>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
85082>>>            If (bOK = False) Begin
85084>>>                Function_Return False
85085>>>            End
85085>>>>
85085>>>            Get UtilColumnsStructFill hTable to aColumnsTo
85086>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
85087>>>        End
85087>>>>
85087>>>
85087>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
85087>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
85087>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
85087>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
85087>>>//            If (bOK = False) Begin
85087>>>//                Function_Return False
85087>>>//            End
85087>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
85087>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
85087>>>//        End
85087>>>
85087>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
85087>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
85089>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
85090>>>            If (bIsSame = True) Begin
85092>>>                Function_Return True
85093>>>            End
85093>>>>
85093>>>        End
85093>>>>
85093>>>
85093>>>        // We can now continue to make standard field changes:
85093>>>        Get OpenTableExclusive hTable to bIsOpen
85094>>>        Set Private.phCurrentTable to hTable
85095>>>        Move hTable to hFile
85096>>>        Structure_Start hFile sDriverIDTo
85097>>>
85097>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
85098>>>            Decrement iColumns
85099>>>            for iCount from 0 to iColumns
85105>>>>
85105>>>                Send DoAdvance of ghoProgressBar
85106>>>
85106>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
85107>>>                Set Private.piCurrentField                  to iColumn
85108>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
85109>>>                If (bIsSame = False) Begin
85111>>>
85111>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
85112>>>                    If (bFieldExistsFrom = True) Begin
85114>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
85115>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
85116>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
85117>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
85118>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
85119>>>
85119>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
85120>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
85121>>>                        If (iTypeFrom < -1490) Begin
85123>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
85124>>>                        End
85124>>>>
85124>>>
85124>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
85124>>>                        // data types between Embedded and SQL, else we can't compare the data types.
85124>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
85126>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
85127>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
85129>>>                                Move DF_DATE to iTypeFrom
85130>>>                            End
85130>>>>
85130>>>                        End
85130>>>>
85130>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
85133>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
85134>>>                        End
85134>>>>
85134>>>
85134>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
85135>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
85136>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
85137>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
85138>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
85139>>>
85139>>>                        Move False to bSkipTypeChange
85140>>>                        If (bCompareDate_DateTime = False) Begin
85142>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
85143>>>                        End
85143>>>>
85143>>>
85143>>>                        If (bFieldExistsTo = False) Begin
85145>>>                            Move 0 to iColumn
85146>>>                            Create_Field hFile At iColumn
85147>>>                            Set Private.piCurrentField to iColumn
85148>>>                        End
85148>>>>
85148>>>
85148>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
85150>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
85153>>>                        End
85153>>>>
85153>>>
85153>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
85155>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
85158>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
85159>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
85161>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
85162>>>                            End
85162>>>>
85162>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
85165>>>                        End
85165>>>>
85165>>>
85165>>>                        If (bSkipTypeChange = False) Begin
85167>>>                            If (iTypeFrom <> iTypeTo) Begin
85169>>>                                If (bIsSQLTableTo = True) Begin
85171>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
85174>>>                                End
85174>>>>
85174>>>                                Else Begin                                                   
85175>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
85177>>>                                        Move DF_DATE to iDataFlexType  // Date
85178>>>                                    End
85178>>>>
85178>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
85181>>>                                End
85181>>>>
85181>>>                            End
85181>>>>
85181>>>                        End
85181>>>>
85181>>>
85181>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
85182>>>                        // We can't set the length or precision for Date type columns (they are fixed).
85182>>>                        If (bIsDateType = False) Begin
85184>>>                            If (iLengthFrom <> iLengthTo) Begin
85186>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
85189>>>                            End
85189>>>>
85189>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
85191>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
85194>>>                            End
85194>>>>
85194>>>                        End
85194>>>>
85194>>>
85194>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
85196>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
85196>>>                            If (bRecnumTable = True) Begin
85198>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
85201>>>                            End
85201>>>>
85201>>>
85201>>>                            // We might need to create an index here.
85201>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
85201>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
85201>>>                            // index update checking logic.
85201>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
85204>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
85206>>>                                Create_Index hFile at iIndex
85207>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
85210>>>                            End
85210>>>>
85210>>>
85210>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
85213>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
85216>>>                                // Note: The order of these two are crucial!
85216>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
85219>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
85222>>>                        End
85222>>>>
85222>>>                    End
85222>>>>
85222>>>                    Else Begin
85223>>>                        Delete_Field hFile iColumn
85224>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
85225>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
85226>>>                        Decrement iCount2
85227>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
85227>>>                        // starting with the array number we just deleted the field for.
85227>>>                        for iColumn2 from iCount to iCount2
85233>>>>
85233>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
85234>>>                        Loop
85235>>>>
85235>>>                        Decrement iCount
85236>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
85237>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
85238>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
85240>>>                            Move iColumns to iCount 
85241>>>                        End
85241>>>>
85241>>>                    End
85241>>>>
85241>>>                End
85241>>>>
85241>>>            Loop
85242>>>>
85242>>>
85242>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85243>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85245>>>
85245>>>        Set Action_Text of ghoStatusPanel to ""
85246>>>        Function_Return (Err = False)
85247>>>    End_Function
85248>>>
85248>>>    // * Dummy function for the Studio's Code Explorer *
85248>>>    Function API_INDEX_FUNCTIONS Returns Boolean
85250>>>        Function_Return False
85251>>>    End_Function
85252>>>
85252>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
85252>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
85252>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
85252>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
85254>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
85254>>>        String sDriverID
85254>>>        Boolean bOK bExists bIsMertechDriver bIsSQLTable
85254>>>
85254>>>        Get AutoConnectionIDLogin to bOK
85255>>>        Get OpenTableExclusive hTable to bOK
85256>>>        If (bOK = False) Begin
85258>>>            Function_Return False
85259>>>        End
85259>>>>
85259>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85262>>>
85262>>>            Get UtilTableIsSQL hTable to bIsSQLTable
85263>>>            If (bIsSQLTable = True) Begin
85265>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85268>>>            End
85268>>>>
85268>>>
85268>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
85271>>>            Move (iIndexSegments > 0) to bExists
85272>>>        If (bExists = True) Begin
85274>>>            Function_Return True
85275>>>        End
85275>>>>
85275>>>
85275>>>        Move -1 to iSegment1
85276>>>        Move -1 to iSegment2
85277>>>        Move -1 to iSegment3
85278>>>        Move -1 to iSegment4
85279>>>        Move -1 to iSegment5
85280>>>        Move -1 to iSegment6
85281>>>        Move -1 to iSegment7
85282>>>        Move -1 to iSegment8
85283>>>        Move -1 to iSegment9
85284>>>        Move -1 to iSegment10
85285>>>
85285>>>        If (num_arguments > 3) Begin
85287>>>            Move iSgmnt1 to iSegment1
85288>>>        End
85288>>>>
85288>>>        If (num_arguments > 4) Begin
85290>>>            Move iSgmnt2 to iSegment2
85291>>>        End
85291>>>>
85291>>>        If (num_arguments > 5) Begin
85293>>>            Move iSgmnt3 to iSegment3
85294>>>        End
85294>>>>
85294>>>        If (num_arguments > 6) Begin
85296>>>            Move iSgmnt4 to iSegment4
85297>>>        End
85297>>>>
85297>>>        If (num_arguments > 7) Begin
85299>>>            Move iSgmnt5 to iSegment5
85300>>>        End
85300>>>>
85300>>>        If (num_arguments > 8) Begin
85302>>>            Move iSgmnt6 to iSegment6
85303>>>        End
85303>>>>
85303>>>        If (num_arguments > 9) Begin
85305>>>            Move iSgmnt7 to iSegment7
85306>>>        End
85306>>>>
85306>>>        If (num_arguments > 10) Begin
85308>>>            Move iSgmnt8 to iSegment8
85309>>>        End
85309>>>>
85309>>>        If (num_arguments > 11) Begin
85311>>>            Move iSgmnt9 to iSegment9
85312>>>        End
85312>>>>
85312>>>        If (num_arguments > 12) Begin
85314>>>            Move iSgmnt10 to iSegment10
85315>>>        End
85315>>>>
85315>>>
85315>>>        Move False to Err
85316>>>        Move hTable to iTableNo
85317>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85318>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
85319>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
85320>>>
85320>>>        // We start by deleting the index, if it exists.
85320>>>        If (bExists = True) Begin
85322>>>            Structure_Start hTable sDriverID
85323>>>                Delete_Index iTableNo iIndex
85324>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85325>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85327>>>        End
85327>>>>
85327>>>
85327>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85328>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
85329>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
85330>>>        Set Action_Text of ghoStatusPanel to ""
85331>>>        Move False to Err
85332>>>        Move 0 to LastErr
85333>>>
85333>>>        // Need to re-open if index deleted.
85333>>>        Move iTableNo to hTable
85334>>>        Get OpenTableExclusive hTable to bOK
85335>>>        If (bOK = False) Begin
85337>>>            Function_Return False
85338>>>        End
85338>>>>
85338>>>
85338>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85339>>>        Structure_Start hTable sDriverID
85340>>>            Create_Index hTable At iIndex
85341>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
85344>>>
85344>>>            If (iSgmnt1 <> -1) Begin
85346>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
85349>>>            End
85349>>>>
85349>>>            If (iSegment2 <> -1) Begin
85351>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
85354>>>            End
85354>>>>
85354>>>            If (iSegment3 <> -1) Begin
85356>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
85359>>>            End
85359>>>>
85359>>>            If (iSegment4 <> -1) Begin
85361>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
85364>>>            End
85364>>>>
85364>>>            If (iSegment5 <> -1) Begin
85366>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
85369>>>            End
85369>>>>
85369>>>            If (iSegment6 <> -1) Begin
85371>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
85374>>>            End
85374>>>>
85374>>>            If (iSegment7 <> -1) Begin
85376>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
85379>>>            End
85379>>>>
85379>>>            If (iSegment8 <> -1) Begin
85381>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
85384>>>            End
85384>>>>
85384>>>            If (iSegment9 <> -1) Begin
85386>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
85389>>>            End
85389>>>>
85389>>>            If (iSegment10 <> -1) Begin
85391>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
85394>>>            End
85394>>>>
85394>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85395>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85397>>>
85397>>>        Set Action_Text of ghoStatusPanel to ""
85398>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85399>>>
85399>>>        Function_Return (Err = False)
85400>>>    End_Function
85401>>>
85401>>>    // Example:
85401>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
85401>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
85401>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
85403>>>        Integer iTableNo iNumSgmnt iNumSgmnts
85403>>>        String sDriverID
85403>>>        Boolean bOK bIsSQLTable
85403>>>
85403>>>        Get AutoConnectionIDLogin to bOK
85404>>>
85404>>>        Move False to Err
85405>>>        Move hTable to iTableNo
85406>>>        Get OpenTableExclusive hTable to bOK
85407>>>        If (bOK = False) Begin
85409>>>            Function_Return False
85410>>>        End
85410>>>>
85410>>>
85410>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85413>>>            Get UtilTableIsSQL hTable to bIsSQLTable
85414>>>            If (bIsSQLTable = True) Begin
85416>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85419>>>            End
85419>>>>
85419>>>
85419>>>        // We start by deleting the index
85419>>>        Structure_Start hTable sDriverID
85420>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85421>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
85422>>>            Delete_Index iTableNo iIndex
85423>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
85424>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
85425>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
85427>>>
85427>>>        Move False to Err
85428>>>        Move iTableNo to hTable
85429>>>        Get OpenTableExclusive hTable to bOK
85430>>>        If (bOK = False) Begin
85432>>>            Function_Return False
85433>>>        End
85433>>>>
85433>>>
85433>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85434>>>        Structure_Start hTable sDriverID
85435>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
85436>>>
85436>>>            Create_Index hTable at iIndex
85437>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
85440>>>
85440>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
85446>>>>
85446>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
85449>>>            Loop
85450>>>>
85450>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
85452>>>
85452>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85453>>>
85453>>>        Function_Return (Err = False)
85454>>>    End_Function
85455>>>
85455>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
85457>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
85457>>>        String sDriverID sSQLIndexName
85457>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
85457>>>
85457>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
85458>>>        If (iSegmentsFrom = 0) Begin
85460>>>            Function_Return False
85461>>>        End
85461>>>>
85461>>>
85461>>>        Get AutoConnectionIDLogin to bOK
85462>>>        Move False to Err
85463>>>        Get OpenTableExclusive hTable to bIsOpen
85464>>>        If (bIsOpen = False) Begin
85466>>>            Function_Return False
85467>>>        End
85467>>>>
85467>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85470>>>        Get UtilTableIsSql hTable to bIsSQLTable
85471>>>            If (bIsSQLTable = True) Begin
85473>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85476>>>            End
85476>>>>
85476>>>
85476>>>        Move 0     to iSegmentsTo
85477>>>        Move 0     to iSQLIndexType
85478>>>        Move ""    to sSQLIndexName
85479>>>        Move False to bIsSQLTemporaryIndex
85480>>>        Move False to bIsSQLPrimaryKey
85481>>>        Move False to bIsSQLClustered
85482>>>
85482>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
85483>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
85486>>>        Move (iSegmentsTo > 0) to bExists
85487>>>        If (bExists = True) Begin
85489>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
85491>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
85494>>>                    Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
85497>>>                    Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
85498>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
85501>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
85504>>>            End
85504>>>>
85504>>>        End
85504>>>>
85504>>>
85504>>>        Move hTable to iTableNo
85505>>>        Move False to Err
85506>>>        Move 0 to LastErr
85507>>>
85507>>>        // Note: If the SQL index type = DF_INDEX_TEMPORARY, we _must_ set the DF_INDEX_SQL_TYPE
85507>>>        //       _outside_ the Structure_Start/End construct.
85507>>>//        Move False to bIsSQLTemporaryIndex
85507>>>//        #IF (!@ > 170)
85507>>>//            If (bIsSQLTemporaryIndex = True and APIIndex.iIndexNumber <= iLastIndex) Begin
85507>>>//                If (APIIndex.iSQLIndexType <> iSQLIndexType) Begin
85507>>>//                    Set_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
85507>>>//                End
85507>>>//            End
85507>>>//        #ENDIF
85507>>>
85507>>>        Structure_Start hTable sDriverID
85508>>>            If (bExists = True) Begin
85510>>>                Delete_Index iTableNo APIIndex.iIndexNumber
85511>>>            End
85511>>>>
85511>>>
85511>>>            Create_Index hTable At APIIndex.iIndexNumber
85512>>>
85512>>>            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
85514>>>                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
85517>>>                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
85520>>>                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
85523>>>                Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
85526>>>            End
85526>>>>
85526>>>
85526>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
85529>>>
85529>>>            for iCount from 0 to (iSegmentsFrom -1)
85535>>>>
85535>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
85536>>>                If (iFieldFrom <> -1 ) Begin
85538>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
85541>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
85544>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
85547>>>                End
85547>>>>
85547>>>            Loop
85548>>>>
85548>>>
85548>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85549>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85551>>>
85551>>>        Set Action_Text of ghoStatusPanel to ""
85552>>>
85552>>>        Function_Return (Err = False)
85553>>>    End_Function
85554>>>
85554>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
85554>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
85554>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
85556>>>        Integer iLastIndex iCount iTableNo iSegments
85556>>>        String sSQLIndexNameCompare sTmpIndexName
85556>>>        Boolean bIsOpen bExists bIsSQLDriver bIsMertechDriver
85556>>>
85556>>>        // The Mertech drivers DF_INDEX_NAME property is read_only,
85556>>>        // so we can then not rename the index.
85556>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
85557>>>        If (bIsMertechDriver = True) Begin
85559>>>            Function_Return False
85560>>>        End    
85560>>>>
85560>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
85561>>>        
85561>>>        If (bIsSQLDriver = False) Begin
85563>>>            Function_Return False
85564>>>        End
85564>>>>
85564>>>
85564>>>        Move False to Err
85565>>>        Move hTable to iTableNo
85566>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
85569>>>        for iCount from 0 to iLastIndex
85575>>>>
85575>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
85578>>>            Move (iSegments > 0) to bExists
85579>>>            If (bExists = True) Begin
85581>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
85584>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
85586>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
85587>>>                    Structure_Start iTableNo sDriverID
85588>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
85591>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85593>>>                    Open hTable
85595>>>                End
85595>>>>
85595>>>            End
85595>>>>
85595>>>        Loop
85596>>>>
85596>>>
85596>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
85599>>>        If (bIsOpen = False) Begin
85601>>>            Get OpenTableExclusive hTable to bIsOpen
85602>>>        End
85602>>>>
85602>>>        If (bIsOpen = False) Begin
85604>>>            Function_Return False
85605>>>        End
85605>>>>
85605>>>
85605>>>        Function_Return (Err = False)
85606>>>    End_Function
85607>>>
85607>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
85607>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
85607>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
85609>>>        Integer iSize iCount
85609>>>        Integer iRetVal
85609>>>
85609>>>        Move 0 to iRetVal
85610>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
85613>>>        If (iRetVal = 0) Begin
85615>>>            Function_Return 0
85616>>>        End
85616>>>>
85616>>>        Move (SizeOfArray(APIIndexTo)) to iSize
85617>>>        Decrement iSize
85618>>>        for iCount from 0 to iSize
85624>>>>
85624>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
85626>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
85628>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
85629>>>                End
85629>>>>
85629>>>            End
85629>>>>
85629>>>        Loop
85630>>>>
85630>>>
85630>>>        Function_Return iRetVal
85631>>>    End_Function
85632>>>
85632>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
85634>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
85634>>>        Boolean bIsSQLTable
85634>>>        
85634>>>            Get UtilTableIsSQL hTable to bIsSQLTable
85635>>>            If (bIsSQLTable = True) Begin
85637>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85640>>>            End
85640>>>>
85640>>>
85640>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
85643>>>        If (iSegment = iNumSegments) Begin
85645>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
85645>>>        End
85645>>>>
85645>>>
85645>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
85648>>>            for iCurSegment from iSegment to (iNumSegments - 1)
85654>>>>
85654>>>                //*** Move index segment attributes
85654>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
85657>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
85660>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
85663>>>
85663>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
85666>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
85669>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
85672>>>            Loop
85673>>>>
85673>>>
85673>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
85676>>>        End
85676>>>>
85676>>>
85676>>>        Function_Return (Err = False)
85677>>>    End_Function
85678>>>
85678>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
85680>>>        Integer iCount iSize iIndex
85680>>>        String sDriverID
85680>>>        Boolean bOK bIsSQLTable bIsOpen
85680>>>
85680>>>        Move (SizeOfArray(APIIndex)) to iSize
85681>>>        If (iSize = 0) Begin
85683>>>            Function_Return True
85684>>>        End
85684>>>>
85684>>>
85684>>>        Get AutoConnectionIDLogin to bOK
85685>>>        Move False to Err
85686>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
85689>>>        If (bIsOpen = False) Begin
85691>>>            Get OpenTableExclusive hTable to bIsOpen
85692>>>            If (bIsOpen = False) Begin
85694>>>                Function_Return False
85695>>>            End
85695>>>>
85695>>>        End
85695>>>>
85695>>>
85695>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85698>>>        Get UtilTableIsSql hTable to bIsSQLTable
85699>>>            If (bIsSQLTable = True) Begin
85701>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85704>>>            End
85704>>>>
85704>>>
85704>>>        Move False to Err
85705>>>        Move 0 to LastErr
85706>>>        Decrement iSize
85707>>>
85707>>>        Structure_Start hTable sDriverID
85708>>>            for iCount from 0 to iSize
85714>>>>
85714>>>//                Move False to bIsSQLPrimaryKey
85714>>>//                #IF (!@ > 180)   // DF 18.1 and up
85714>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85714>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
85714>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
85714>>>//                #ENDIF
85714>>>                // We can't delete if this is a primary key index:
85714>>>//                If (bIsSQLPrimaryKey = False) Begin
85714>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
85715>>>                    Delete_Index hTable iIndex
85716>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
85716>>>//                End
85716>>>            Loop
85717>>>>
85717>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85718>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85720>>>//        Move False to Err
85720>>>        Move 0 to LastErr
85721>>>
85721>>>        Set Action_Text of ghoStatusPanel to ""
85722>>>        Function_Return (Err = False)
85723>>>    End_Function
85724>>>
85724>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
85726>>>        Boolean bOK
85726>>>
85726>>>        Get AutoConnectionIDLogin to bOK
85727>>>        Move False to Err
85728>>>        Get OpenTableExclusive hTable to bOK
85729>>>        If (bOK = False) Begin
85731>>>            Function_Return False
85732>>>        End
85732>>>>
85732>>>        Structure_Start hTable
85733>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
85736>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85737>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85739>>>
85739>>>        Set Action_Text of ghoStatusPanel to ""
85740>>>        Function_Return (Err = False)
85741>>>    End_Function
85742>>>
85742>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
85744>>>        Integer iCase
85744>>>        Boolean bOK
85744>>>
85744>>>        If (bUppercase = True) Begin
85746>>>            Move DF_CASE_IGNORED to iCase
85747>>>        End
85747>>>>
85747>>>        Else Begin
85748>>>            Move DF_CASE_USED to iCase
85749>>>        End
85749>>>>
85749>>>
85749>>>        Get AutoConnectionIDLogin to bOK
85750>>>        Move False to Err
85751>>>        Get OpenTableExclusive hTable to bOK
85752>>>        If (bOK = False) Begin
85754>>>            Function_Return False
85755>>>        End
85755>>>>
85755>>>        Structure_Start hTable
85756>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
85759>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85760>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85762>>>
85762>>>        Set Action_Text of ghoStatusPanel to ""
85763>>>        Function_Return (Err = False)
85764>>>    End_Function
85765>>>
85765>>>    // To delete an index
85765>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
85767>>>        Integer iTableNo iNumSegments
85767>>>        String sDriverID
85767>>>        Boolean bOK bIsSQLTable
85767>>>
85767>>>        Get AutoConnectionIDLogin to bOK
85768>>>        Move False to Err
85769>>>        Move hTable to iTableNo
85770>>>        Get OpenTableExclusive hTable to bOK
85771>>>        If (bOK = False) Begin
85773>>>            Function_Return False
85774>>>        End
85774>>>>
85774>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85777>>>            Get UtilTableIsSQL hTable to bIsSQLTable
85778>>>            If (bIsSQLTable = True) Begin
85780>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85783>>>            End
85783>>>>
85783>>>
85783>>>        // Check to see if the index exists or not...
85783>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
85786>>>        If (iNumSegments = 0) Begin
85788>>>            Function_Return True // Then nothing to do.
85789>>>        End
85789>>>>
85789>>>
85789>>>        Structure_Start hTable sDriverID
85790>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
85791>>>            Delete_Index iTableNo iIndex
85792>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
85793>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85794>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85796>>>
85796>>>        Set Action_Text of ghoStatusPanel to ""
85797>>>        Function_Return (Err = False)
85798>>>    End_Function
85799>>>
85799>>>    // Delete an Index Segment
85799>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
85801>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
85801>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
85801>>>        Integer iIndexType
85801>>>        String sDriverID
85801>>>
85801>>>        Get AutoConnectionIDLogin to bOK
85802>>>        Move False to Err
85803>>>
85803>>>        Get OpenTableExclusive hTable to bOK
85804>>>        If (bOK = False) Begin
85806>>>            Function_Return False
85807>>>        End
85807>>>>
85807>>>
85807>>>            Get UtilTableIsSQL hTable to bIsSQLTable
85808>>>            If (bIsSQLTable = True) Begin
85810>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85813>>>            End
85813>>>>
85813>>>
85813>>>        // Check to see if the index exists or not...
85813>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
85816>>>        If (iNumSegments = 0) Begin
85818>>>            Function_Return False
85819>>>        End
85819>>>>
85819>>>
85819>>>        Move False to bIndexTemporary
85820>>>        Get psDriverID to sDriverID
85821>>>        Get IsSQLDriver sDriverID to bSQLDriver
85822>>>        If (bSQLDriver) Begin
85824>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
85827>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
85830>>>                Move True to bIndexTemporary
85831>>>        End
85831>>>>
85831>>>
85831>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
85831>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
85833>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
85836>>>            If (iSegment = iNumSegments) Begin
85838>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
85841>>>            End
85841>>>>
85841>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
85844>>>                For iCurSegment from iSegment to (iNumSegments - 1)
85850>>>>
85850>>>                    //*** Move index segment attributes
85850>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
85853>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
85856>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
85859>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
85862>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
85865>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
85868>>>                Loop
85869>>>>
85869>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
85872>>>            End
85872>>>>
85872>>>        End
85872>>>>
85872>>>
85872>>>        Else Begin
85873>>>           Structure_Start hTable
85874>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
85877>>>               If (iSegment = iNumSegments) Begin
85879>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
85882>>>               End
85882>>>>
85882>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
85885>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
85891>>>>
85891>>>                       //*** Move index segment attributes
85891>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
85894>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
85897>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
85900>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
85903>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
85906>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
85909>>>                   Loop
85910>>>>
85910>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
85913>>>               End
85913>>>>
85913>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85914>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85916>>>            Set Action_Text of ghoStatusPanel to ""
85917>>>        End
85917>>>>
85917>>>
85917>>>        Function_Return (Err = False)
85918>>>    End_Function
85919>>>
85919>>>    // Add/Insert an Index Segment
85919>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
85921>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
85921>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
85921>>>        Integer iIndexType
85921>>>        String sDriverId
85921>>>
85921>>>        Get AutoConnectionIDLogin to bOK
85922>>>        Move False to Err
85923>>>
85923>>>        Get OpenTableExclusive hTable to bOK
85924>>>        If (bOK = False) Begin
85926>>>            Function_Return False
85927>>>        End
85927>>>>
85927>>>
85927>>>            Get UtilTableIsSQL hTable to bIsSQLTable
85928>>>            If (bIsSQLTable = True) Begin
85930>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85933>>>            End
85933>>>>
85933>>>
85933>>>        Move False to bIndexTemporary
85934>>>        // Check to see if the index exists or not...
85934>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
85937>>>        If (iNumSegments = 0) Begin
85939>>>            Function_Return False
85940>>>        End
85940>>>>
85940>>>
85940>>>        Get psDriverID to sDriverID
85941>>>        Get IsSQLDriver sDriverID to bSQLDriver
85942>>>        If (bSQLDriver) Begin
85944>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
85947>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
85950>>>                Move True to bIndexTemporary
85951>>>        End
85951>>>>
85951>>>
85951>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
85951>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
85953>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
85956>>>
85956>>>           If (iSegment > iNumSegments) Begin
85958>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
85961>>>               Move (iNumSegments + 1) to iCurSegment
85962>>>           End
85962>>>>
85962>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
85965>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
85968>>>               Move iNumSegments to iCurSegment
85969>>>
85969>>>               While (iCurSegment > iSegment)
85973>>>                   //*** Move index segment attributes
85973>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
85976>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
85979>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
85982>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
85985>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
85988>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
85991>>>                   Decrement iCurSegment
85992>>>               Loop
85993>>>>
85993>>>
85993>>>               //*** Now set new segment attributes
85993>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
85996>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
85999>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
86002>>>           End
86002>>>>
86002>>>        End
86002>>>>
86002>>>
86002>>>        Else Begin
86003>>>        Structure_Start hTable
86004>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
86007>>>
86007>>>            If (iSegment > iNumSegments) Begin
86009>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
86012>>>                Move (iNumSegments + 1) to iCurSegment
86013>>>            End
86013>>>>
86013>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
86016>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
86019>>>                Move iNumSegments to iCurSegment
86020>>>
86020>>>                While (iCurSegment > iSegment)
86024>>>                    //*** Move index segment attributes
86024>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
86027>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
86030>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
86033>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
86036>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
86039>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
86042>>>                    Decrement iCurSegment
86043>>>                Loop
86044>>>>
86044>>>
86044>>>                //*** Now set new segment attributes
86044>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
86047>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
86050>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
86053>>>            End
86053>>>>
86053>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86054>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86056>>>            Set Action_Text of ghoStatusPanel to ""
86057>>>        End
86057>>>>
86057>>>
86057>>>        Function_Return (Err = False)
86058>>>    End_Function
86059>>>
86059>>>    // * Dummy function for the Studio's Code Explorer *
86059>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
86061>>>        Function_Return False
86062>>>    End_Function  
86063>>>    
86063>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
86063>>>    // for an SQL conversion.
86063>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
86065>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
86065>>>        
86065>>>        Move True to bConvertTo30FormatbOK
86066>>>        Move True to bRepairAndReindexOK
86067>>>        Move True to bFixBogusDatesOK
86068>>>        Move True to bMoveMiscFilesToBackupOK
86069>>>        
86069>>>        If (bMoveMiscFilesToBackup = True) Begin   
86071>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
86072>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
86073>>>        End                                                                                
86073>>>>
86073>>>        If (bFixALLBogusFilelistEntries = True) Begin
86075>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
86076>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
86077>>>        End
86077>>>>
86077>>>        If (bConvertTo30Format = True) Begin
86079>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
86080>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
86081>>>        End                                                 
86081>>>>
86081>>>        If (bRepairAndReindex = True) Begin
86083>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
86084>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
86085>>>        End  
86085>>>>
86085>>>        If (bFixBogusDates = True) Begin
86087>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
86088>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
86089>>>        End                                    
86089>>>>
86089>>>        
86089>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
86090>>>    End_Function
86091>>>
86091>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
86093>>>        Boolean bOK bFlexErrs bTemp
86093>>>        Handle hTable
86093>>>        String sTableName
86093>>>        Integer iCount iSize
86093>>>        
86093>>>        Move True to bOK
86094>>>        Move 0 to hTable    
86095>>>
86095>>>        Get UtilFilelistNoOfTables to iSize
86096>>>        Set pbVisible    of ghoProgressBarOverall to True
86097>>>        Set piPosition   of ghoProgressBarOverall to 0
86098>>>        Set piMaximum    of ghoProgressBarOverall to iSize
86099>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
86100>>>
86100>>>        Repeat
86100>>>>
86100>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
86101>>>            Set piPosition of ghoProgressBarOverall to iCount  
86102>>>            Increment iCount
86103>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86106>>>            If (hTable > 0) Begin
86108>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86111>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
86112>>>                If (bFlexErrs = False) Begin
86114>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
86115>>>                    If (bTemp = False) Begin
86117>>>                        Move False to bOK
86118>>>                    End
86118>>>>
86118>>>                End
86118>>>>
86118>>>            End
86118>>>>
86118>>>        Until (hTable = 0)
86120>>>        
86120>>>        Set Action_Text of ghoStatusPanel to ""
86121>>>        Function_Return bOK
86122>>>    End_Function
86123>>>    
86123>>>    // Converts an embedded table from 2.3 -> 3.0.
86123>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
86123>>>    // It will return a TRUE if successful or the table is an SQL table.
86123>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
86125>>>        Boolean bOK bIsEmbedded bIsAlias
86125>>>        String sRevision
86125>>>        
86125>>>        Get AutoConnectionIDLogin to bOK
86126>>>        If (bOK = False) Begin
86128>>>            Function_Return True
86129>>>        End
86129>>>>
86129>>>        Get OpenTableExclusive hTable to bOK
86130>>>        If (bOK = False) Begin
86132>>>            Function_Return True
86133>>>        End
86133>>>>
86133>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
86134>>>        If (bIsEmbedded = False) Begin
86136>>>            Function_Return True
86137>>>        End                             
86137>>>>
86137>>>        Get UtilTableIsAlias hTable to bIsAlias
86138>>>        If (bIsAlias = True) Begin
86140>>>            Function_Return True
86141>>>        End                     
86141>>>>
86141>>>        
86141>>>        Move False to Err
86142>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
86145>>>        If (sRevision contains "2.3") Begin
86147>>>            Move False to Err
86148>>>            Set Private.phCurrentTable to hTable
86149>>>            Structure_Start hTable    
86150>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
86153>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
86154>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
86156>>>            Set Action_Text of ghoStatusPanel to ""
86157>>>        End
86157>>>>
86157>>>        
86157>>>        Function_Return (Err = False)
86158>>>    End_Function
86159>>>
86159>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
86161>>>        Boolean bIgnore bExists bOK bResponse
86161>>>        Handle hTable   
86161>>>        String sTableName
86161>>>        
86161>>>        Move False to Err 
86162>>>        Move True to bOK
86163>>>        Move 0 to hTable
86164>>>        Repeat
86164>>>>
86164>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86167>>>            If (hTable > 0) Begin
86169>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86172>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
86173>>>                If (bIgnore = False) Begin
86175>>>                    Get UtilTableExists hTable to bExists
86176>>>                    If (bExists = False) Begin
86178>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
86179>>>                        If (bResponse = False) Begin
86181>>>                            Move False to bOK
86182>>>                        End
86182>>>>
86182>>>                        
86182>>>                    End
86182>>>>
86182>>>                End
86182>>>>
86182>>>            End
86182>>>>
86182>>>        Until (hTable = 0)                     
86184>>>        
86184>>>        Set Action_Text of ghoStatusPanel to "" 
86185>>>        Function_Return bOK
86186>>>    End_Function
86187>>>    
86187>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
86187>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
86187>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
86187>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
86187>>>    //
86187>>>    // The root of the problem is the following:
86187>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
86187>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
86187>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
86187>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
86187>>>    // an SQL error will be thrown;
86187>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
86187>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
86189>>>        Boolean bOK bIsAlias bIsSQL
86189>>>        Integer iCount iSize iDateSize
86189>>>        Handle hTable
86189>>>        String sLogicalName
86189>>>        Integer[] aTablesToCheck aDateFields
86191>>>
86191>>>        Get _AllTablesDateCorrections to aTablesToCheck
86192>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
86193>>>        Set pbVisible    of ghoProgressBarOverall to True
86194>>>        Set piPosition   of ghoProgressBarOverall to 0
86195>>>        Set piMaximum    of ghoProgressBarOverall to iSize
86196>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
86197>>>
86197>>>        Move True to bOK
86198>>>        Decrement iSize
86199>>>        for iCount from 0 to iSize
86205>>>>
86205>>>            Move aTablesToCheck[iCount] to hTable
86206>>>            Set piPosition of ghoProgressBarOverall to iCount
86207>>>            Get UtilTableIsAlias hTable to bIsAlias
86208>>>            Get UtilTableIsSql   hTable to bIsSQL
86209>>>
86209>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86212>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
86213>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
86214>>>
86214>>>            If (bIsAlias = False and bIsSQL = False) Begin
86216>>>                Get UtilCheckForDateFields hTable to aDateFields
86217>>>                Move (SizeOfArray(aDateFields)) to iDateSize
86218>>>                If (iDateSize > 0) Begin
86220>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
86221>>>                    Close hTable
86222>>>                End
86222>>>>
86222>>>            End
86222>>>>
86222>>>        Loop
86223>>>>
86223>>>
86223>>>        Close DF_ALL
86224>>>        Function_Return bOK
86225>>>    End_Function
86226>>>
86226>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
86226>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
86228>>>        Integer[] aDateFields aDateFieldsEmpty
86230>>>        Integer iSize iCount iType
86230>>>        Boolean bOpen bOK
86230>>>        
86230>>>        Get UtilTableExists hTable to bOK
86231>>>        If (bOK = False) Begin
86233>>>            Set Private.phCurrentTable to hTable
86234>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86235>>>>
86235>>>            Function_Return aDateFieldsEmpty
86236>>>        End
86236>>>>
86236>>>        Set Private.phCurrentTable to hTable
86237>>>        Set Private.piCurrentField to 0
86238>>>
86238>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
86238>>>        Open hTable
86240>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
86243>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
86243>>>        If (bOpen = False) Begin
86245>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
86245>>>            Function_Return aDateFieldsEmpty
86246>>>        End
86246>>>>
86246>>>
86246>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
86249>>>        For iCount from 1 to iSize
86255>>>>
86255>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
86258>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
86260>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
86261>>>            End
86261>>>>
86261>>>        Loop
86262>>>>
86262>>>
86262>>>        Function_Return aDateFields
86263>>>    End_Function
86264>>>
86264>>>    // Loops through all records for the passed hTable, and checks that all Date values
86264>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
86264>>>    // and the record is saved
86264>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
86264>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
86264>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
86266>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
86266>>>        String sDriverID sDateMin
86266>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
86266>>>        Date dDate dDateMin
86266>>>        Integer[] iaChangeField
86267>>>
86267>>>        Get UtilTableExists hTable to bOK
86268>>>        // I believe we should just skip files not found and not report an error.
86268>>>        // This is because a filelist may have entries but no files/tables on disk, but
86268>>>        // this may be adjusted by other calls to DUF in a later update package. 
86268>>>        // Especially considering that this call is probably done at the very
86268>>>        // beginning of a DUF update.
86268>>>        If (bOK = False) Begin
86270>>>//            Set Private.phCurrentTable to hTable
86270>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86270>>>//            Function_Return False
86270>>>            Function_Return True
86271>>>        End
86271>>>>
86271>>>
86271>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
86271>>>        // date format to "USA" = "MM/DD/YYYY"
86271>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
86274>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
86277>>>
86277>>>//        Send SetAllIndexesToBatch hTable True
86277>>>        Open hTable
86279>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86282>>>        If (bOpened = False) Begin
86284>>>            Function_Return False
86285>>>        End
86285>>>>
86285>>>        
86285>>>        Set Private.phCurrentTable to hTable
86286>>>        Move 0 to iRecord
86287>>>        Move (SizeOfArray(aDateFields)) to iSize
86288>>>        Decrement iSize
86289>>>
86289>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86292>>>        Get DriverIndex sDriverID to iDriverIndex
86293>>>        If (iDriverIndex <> 0) Begin
86295>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
86298>>>            If (sDateMin = "") Begin
86300>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
86301>>>            End
86301>>>>
86301>>>            Else Begin
86302>>>                If (IsDate(sDateMin)) Begin
86304>>>                    Move sDateMin to dDateMin
86305>>>                End
86305>>>>
86305>>>                Else Begin
86306>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
86307>>>                End
86307>>>>
86307>>>            End
86307>>>>
86307>>>        End
86307>>>>
86307>>>        Else Begin
86308>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
86309>>>        End
86309>>>>
86309>>>
86309>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
86312>>>        Set piPosition   of ghoProgressBar to 0
86313>>>        Set piAdvanceBy  of ghoProgressBar to 100
86314>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
86315>>>        Move False to Err
86316>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
86317>>>
86317>>>        Clear hTable
86318>>>        Repeat
86318>>>>
86318>>>            Vfind hTable 0 GT
86320>>>            Move Found to bFound
86321>>>            If (bFound = True) Begin
86323>>>                Move False to bSaveChanges
86324>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
86325>>>                Move (SizeOfArray(aDateFields)) to iSize
86326>>>                Decrement iSize
86327>>>                For iCount from 0 to iSize
86333>>>>
86333>>>                    Move aDateFields[iCount] to iField
86334>>>                    Get_Field_Value hTable iField to dDate
86337>>>                    If (bFixZeroDates = True) Begin
86339>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
86340>>>                    End
86340>>>>
86340>>>                    Else Begin
86341>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
86342>>>                    End
86342>>>>
86342>>>                    If (bChange = True) Begin
86344>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
86345>>>                    End
86345>>>>
86345>>>                Loop
86346>>>>
86346>>>
86346>>>                // Only change Date fields that needs to be changed.
86346>>>                If (SizeOfArray(iaChangeField)) Begin
86348>>>                    Reread hTable
86352>>>                        Move (SizeOfArray(iaChangeField)) to iSize
86353>>>                        Decrement iSize
86354>>>                        For iCount from 0 to iSize
86360>>>>
86360>>>                            Move iaChangeField[iCount] to iField
86361>>>                            Set Private.piCurrentField to iField
86362>>>                            Set_Field_Value hTable iField to dDateMin
86365>>>                        Loop
86366>>>>
86366>>>                        Move False to Err
86367>>>                        SaveRecord hTable
86368>>>                    Unlock
86369>>>>
86369>>>                End
86369>>>>
86369>>>
86369>>>                Increment iRecord
86370>>>                // Increment the StatusPanel counter and check the
86370>>>                // cancel status every 100 records rather than every
86370>>>                // record, it's way faster.
86370>>>                If (Mod(iRecord, 100) = 0) Begin
86372>>>                    Send DoAdvance of ghoProgressBar
86373>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
86374>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
86375>>>                End
86375>>>>
86375>>>            End
86375>>>>
86375>>>        Until (bFound = False)
86377>>>
86377>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
86380>>>        If (bResetIndexesToOnLine = True) Begin
86382>>>            Send SetAllIndexesToBatch hTable False
86383>>>        End
86383>>>>
86383>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
86384>>>
86384>>>        Function_Return (Err = False)
86385>>>    End_Function
86386>>>
86386>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
86386>>>    // Note that it first removes any driver prefixes in the rootname.
86386>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
86388>>>        Boolean bIsSame
86388>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
86388>>>
86388>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
86389>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
86390>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
86391>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
86392>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
86393>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
86394>>>
86394>>>        If (bCompareFilelistUppercase = True) Begin
86396>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
86397>>>        End
86397>>>>
86397>>>        Else Begin
86398>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
86399>>>        End
86399>>>>
86399>>>        If (bIsSame = False) Begin
86401>>>            Function_Return False
86402>>>        End
86402>>>>
86402>>>
86402>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
86403>>>        If (bIsSame = False) Begin
86405>>>            Function_Return False
86406>>>        End
86406>>>>
86406>>>
86406>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
86407>>>        If (bIsSame = False) Begin
86409>>>            Function_Return False
86410>>>        End
86410>>>>
86410>>>
86410>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
86411>>>        If (bIsSame = False) Begin
86413>>>            Function_Return False
86414>>>        End
86414>>>>
86414>>>
86414>>>        Function_Return bIsSame
86415>>>    End_Function
86416>>>
86416>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
86418>>>        Handle hTableFrom hTableTo
86418>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
86418>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
86418>>>        String sRootName sDriverIDFrom sDriverIDTo
86418>>>        tAPIColumnCompare[]   aAPIColumnCompare
86418>>>        tAPIColumnCompare[]   aAPIColumnCompare
86419>>>        tAPIIndexCompare[]    aAPIIndexCompare
86419>>>        tAPIIndexCompare[]    aAPIIndexCompare
86420>>>        tAPIRelationCompare[] aAPIRelationCompare
86420>>>        tAPIRelationCompare[] aAPIRelationCompare
86421>>>
86421>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
86422>>>        If (bIsSame = True) Begin
86424>>>            Function_Return True
86425>>>        End
86425>>>>
86425>>>
86425>>>        Move False to bFilelistError
86426>>>        Move True to bIsSame
86427>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
86428>>>        Get pbCompareIndexAscending to bCompareIndexAscending
86429>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
86430>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
86431>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
86432>>>
86432>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
86433>>>        Get _TableNameOnly sRootName             to sRootName
86434>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
86435>>>
86435>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
86435>>>        // bCodeGenerateMode = True = Code Generation mode.
86435>>>        If (bCodeGenerateMode = True) Begin
86437>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
86437>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
86439>>>                Function_Return False
86440>>>            End
86440>>>>
86440>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
86441>>>            If (bIsSame = False) Begin
86443>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
86444>>>                Move True to bFilelistError
86445>>>                Function_Return False
86446>>>            End
86446>>>>
86446>>>        End
86446>>>>
86446>>>
86446>>>        If (bCodeGenerateMode = False) Begin
86448>>>            // Then we want to create this table
86448>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
86450>>>                Function_Return False
86451>>>            End
86451>>>>
86451>>>
86451>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
86452>>>            If (bIsSame = False) Begin
86454>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
86455>>>>
86455>>>                Move True to bFilelistError
86456>>>                Function_Return False
86457>>>            End
86457>>>>
86457>>>        End
86457>>>>
86457>>>
86457>>>        // Check columns:
86457>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
86458>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
86459>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
86460>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
86461>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
86462>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
86463>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
86464>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
86465>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
86466>>>        If (bIsSame = False) Begin
86468>>>            Function_Return False
86469>>>        End
86469>>>>
86469>>>
86469>>>        // ...then check indexes:
86469>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
86470>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
86471>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
86472>>>        If (bIsSame = False) Begin
86474>>>            Function_Return False
86475>>>        End
86475>>>>
86475>>>
86475>>>        // ...and finally relationships:
86475>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
86476>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
86477>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
86478>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
86479>>>
86479>>>        Function_Return (bIsSame = True)
86480>>>    End_Function
86481>>>
86481>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
86481>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
86483>>>        Handle hTable
86483>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
86483>>>        String sRootName sDriverIDFrom sDriverIDTo
86483>>>
86483>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
86485>>>            Move True to bFilelistError
86486>>>            Function_Return False
86487>>>        End
86487>>>>
86487>>>
86487>>>        Move APITableCompare.hTable to hTable
86488>>>        Move True  to bIsSame
86489>>>        Move False to bFilelistError
86490>>>
86490>>>        If (APITableCompare.bExistsFrom = True) Begin
86492>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
86493>>>        End
86493>>>>
86493>>>        Else Begin
86494>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
86495>>>        End
86495>>>>
86495>>>        Get _TableNameOnly sRootName                                   to sRootName
86496>>>
86496>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
86497>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
86498>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
86499>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
86500>>>
86500>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
86500>>>        // bCodeGenerateMode = True = Code Generation mode.
86500>>>        If (bCodeGenerateMode = True) Begin
86502>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
86502>>>            If (APITableCompare.bExistsTo = False) Begin
86504>>>                Function_Return False
86505>>>            End
86505>>>>
86505>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
86506>>>            If (bIsSame = False) Begin
86508>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
86509>>>                Move True to bFilelistError
86510>>>                Function_Return False
86511>>>            End
86511>>>>
86511>>>        End
86511>>>>
86511>>>
86511>>>        If (bCodeGenerateMode = False) Begin
86513>>>            If (APITableCompare.bExistsTo = False) Begin
86515>>>                // Then we might want to create this table
86515>>>                Function_Return False
86516>>>            End
86516>>>>
86516>>>
86516>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
86517>>>            If (bIsSame = False) Begin
86519>>>                Function_Return False
86520>>>            End
86520>>>>
86520>>>
86520>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
86521>>>            If (bIsSame = False) Begin
86523>>>                Function_Return False
86524>>>            End
86524>>>>
86524>>>
86524>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
86525>>>            If (bIsSame = False) Begin
86527>>>                Function_Return False
86528>>>            End
86528>>>>
86528>>>
86528>>>            // Check table names et al.
86528>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
86529>>>            If (bIsSame = False) Begin
86531>>>                Function_Return False
86532>>>            End
86532>>>>
86532>>>        End
86532>>>>
86532>>>
86532>>>        // Check Columns:
86532>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
86533>>>        If (bIsSame = False) Begin
86535>>>            Function_Return False
86536>>>        End
86536>>>>
86536>>>
86536>>>        // ...then check Indexes:
86536>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
86537>>>        If (bIsSame = False) Begin
86539>>>            Function_Return False
86540>>>        End
86540>>>>
86540>>>
86540>>>        // ...and finally Relationships:
86540>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
86541>>>
86541>>>        Function_Return (bIsSame = True)
86542>>>    End_Function
86543>>>
86543>>>    // To fill a complete Table array structure (tAPITable[]) with data.
86543>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
86543>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
86543>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
86543>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
86545>>>        tAPITableNameInfo ApiTableNameInfo
86545>>>        tAPITableNameInfo ApiTableNameInfo
86545>>>        tAPITable[]     aApiTables aApiTablesEmpty
86545>>>        tAPITable[]     aApiTables aApiTablesEmpty
86547>>>        tAPIColumn[]    aApiColumns
86547>>>        tAPIColumn[]    aApiColumns
86548>>>        tAPIIndex[]     aApiIndexes
86548>>>        tAPIIndex[]     aApiIndexes
86549>>>        tAPIRelation[]  aApiRelations
86549>>>        tAPIRelation[]  aApiRelations
86550>>>        Handle hTable
86550>>>        Integer iCount
86550>>>        Boolean bUserCancel bOK
86550>>>        String sLogicalName sMessageText
86550>>>
86550>>>        Get AutoConnectionIDLogin to bOK
86551>>>        Move 0 to hTable
86552>>>        If (bFromTables = True) Begin
86554>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
86555>>>            If (bCompareUtil = True) Begin
86557>>>                Move (sMessageText * "(1 of 3)") to sMessageText
86558>>>            End
86558>>>>
86558>>>        End
86558>>>>
86558>>>        Else Begin
86559>>>            Move "Reading 'TO' Table Structure:" to sMessageText
86560>>>            If (bCompareUtil = True) Begin
86562>>>                Move (sMessageText * "(2 of 3)") to sMessageText
86563>>>            End
86563>>>>
86563>>>        End
86563>>>>
86563>>>        Set Message_Text of ghoStatusPanel to sMessageText
86564>>>
86564>>>        Get UtilFilelistNoOfTables to iCount
86565>>>        Set piMaximum of ghoProgressBar to iCount
86566>>>        Move 0 to iCount
86567>>>
86567>>>        Repeat
86567>>>>
86567>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86570>>>            If (hTable > 0 and hTable <> 50) Begin
86572>>>
86572>>>                Open hTable
86574>>>                // ToDo: Needs to be revised
86574>>>                // For some reason tables may be reported as "unopened", while in
86574>>>                // fact the open was successful (!)
86574>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
86574>>>//                If (bIsOpen = False) Begin
86574>>>//                    Move True to aApiTablesEmpty[0].bError
86574>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
86574>>>//                    Function_Return aApiTablesEmpty
86574>>>//                End
86574>>>
86574>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86577>>>                Set piPosition of ghoProgressBar to iCount
86578>>>                Send DoAdvance of ghoProgressBarOverall
86579>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
86580>>>
86580>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
86581>>>//                Close hTable DF_PERMANENT
86581>>>                Increment iCount
86582>>>            End
86582>>>>
86582>>>
86582>>>            If (bStatusPanel = True) Begin
86584>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
86585>>>                If (bUserCancel = True) Begin
86587>>>                    Move True to aApiTablesEmpty[0].bCancel
86588>>>                    Function_Return aApiTablesEmpty
86589>>>                End
86589>>>>
86589>>>            End
86589>>>>
86589>>>
86589>>>        Until (hTable = 0)
86591>>>
86591>>>        Function_Return aApiTables
86592>>>    End_Function
86593>>>
86593>>>    // Returns a 'single' table APITable struct.
86593>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
86595>>>        tAPITableNameInfo ApiTableNameInfo
86595>>>        tAPITableNameInfo ApiTableNameInfo
86595>>>        tAPITable         ApiTable ApiTableEmpty
86595>>>        tAPITable         ApiTable ApiTableEmpty
86595>>>        tAPIColumn[]     aApiColumns
86595>>>        tAPIColumn[]     aApiColumns
86596>>>        tAPIIndex[]      aApiIndexes
86596>>>        tAPIIndex[]      aApiIndexes
86597>>>        tAPIRelation[]   aApiRelations
86597>>>        tAPIRelation[]   aApiRelations
86598>>>        Boolean bIsOpen
86598>>>
86598>>>        Open hTable
86600>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
86603>>>        If (bIsOpen = False) Begin
86605>>>            Move True to ApiTableEmpty.bError
86606>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
86607>>>            Function_Return ApiTableEmpty
86608>>>        End
86608>>>>
86608>>>
86608>>>        // Fill Table Name Info
86608>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
86609>>>
86609>>>        // Fill columns
86609>>>        Get UtilColumnsStructFill hTable to aApiColumns
86610>>>        If (SizeOfArray(aApiColumns)) Begin
86612>>>            If (aApiColumns[0].bCancel = True) Begin
86614>>>                Move True to ApiTableEmpty.bError
86615>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
86616>>>                Function_Return ApiTableEmpty
86617>>>            End
86617>>>>
86617>>>        End
86617>>>>
86617>>>
86617>>>        // Fill indexes
86617>>>        Get UtilIndexesStructFill hTable to aApiIndexes
86618>>>        If (SizeOfArray(aApiIndexes)) Begin
86620>>>            If (aApiIndexes[0].bCancel = True) Begin
86622>>>                Move True to ApiTableEmpty.bError
86623>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
86624>>>                Function_Return ApiTableEmpty
86625>>>            End
86625>>>>
86625>>>        End
86625>>>>
86625>>>
86625>>>        // Fill relationships
86625>>>        Get UtilRelationsStructFill hTable to aApiRelations
86626>>>        If (SizeOfArray(aApiRelations)) Begin
86628>>>            If (aApiRelations[0].bCancel = True) Begin
86630>>>                Move True to ApiTableEmpty.bError
86631>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
86632>>>                Function_Return ApiTableEmpty
86633>>>            End
86633>>>>
86633>>>        End
86633>>>>
86633>>>
86633>>>        Move hTable             to ApiTable.hTable
86634>>>        Move bFromTables        to ApiTable.bFromTable
86635>>>        Move (not(bFromTables)) to ApiTable.bToTable
86636>>>
86636>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
86637>>>        Move aApiColumns        to ApiTable.aApiColumns
86638>>>        Move aApiIndexes        to ApiTable.aApiIndexes
86639>>>        Move aApiRelations      to ApiTable.aApiRelations
86640>>>
86640>>>        Function_Return ApiTable
86641>>>    End_Function
86642>>>
86642>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
86644>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
86644>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
86644>>>        Boolean bIsOpen
86644>>>
86644>>>        Open hTable
86646>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
86649>>>        If (bIsOpen = False) Begin
86651>>>            Move True   to APITableNameInfoEmpty.bError
86652>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
86653>>>            Function_Return APITableNameInfoEmpty
86654>>>        End
86654>>>>
86654>>>
86654>>>        Move hTable                                  to APITableNameInfo.iTableNumber
86655>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
86658>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
86661>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
86664>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
86667>>>
86667>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
86668>>>        Get UtilTableIsSQL                    hTable to APITableNameInfo.bIsSQL
86669>>>
86669>>>        Function_Return APITableNameInfo
86670>>>    End_Function
86671>>>
86671>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
86673>>>        Integer iSize iCount iItem
86673>>>        tAPITableNameInfo ApiTableNameInfo
86673>>>        tAPITableNameInfo ApiTableNameInfo
86673>>>
86673>>>        Move -1 to iItem
86674>>>        Move (SizeOfArray(aTableStructure)) to iSize
86675>>>        Decrement iSize
86676>>>        for iCount from 0 to iSize
86682>>>>
86682>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
86683>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
86685>>>                Move iCount to iItem
86686>>>                Move iSize  to iCount // We're done.
86687>>>            End
86687>>>>
86687>>>        Loop
86688>>>>
86688>>>
86688>>>        Function_Return iItem
86689>>>    End_Function
86690>>>
86690>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
86692>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
86695>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
86698>>>
86698>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
86701>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
86704>>>
86704>>>        Function_Return (EQ)
86705>>>    End_Function
86706>>>
86706>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
86708>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
86708>>>        Handle hTable
86708>>>        tAPITable[] aAPITableFromAndTo
86708>>>        tAPITable[] aAPITableFromAndTo
86709>>>        tAPITable   APITableFrom APITableTo APITableEmpty
86709>>>        tAPITable   APITableFrom APITableTo APITableEmpty
86709>>>        tAPITableNameInfoCompare APITableNameInfoCompare
86709>>>        tAPITableNameInfoCompare APITableNameInfoCompare
86709>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
86709>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
86710>>>        tAPIColumnCompare[]   aAPIColumnCompare
86710>>>        tAPIColumnCompare[]   aAPIColumnCompare
86711>>>        tAPIIndexCompare[]    aAPIIndexCompare
86711>>>        tAPIIndexCompare[]    aAPIIndexCompare
86712>>>        tAPIRelationCompare[] aAPIRelationCompare
86712>>>        tAPIRelationCompare[] aAPIRelationCompare
86713>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
86713>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
86713>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
86713>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
86716>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
86716>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
86719>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
86719>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
86722>>>
86722>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
86723>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
86724>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
86726>>>            Function_Return aAPITableCompare
86727>>>        End
86727>>>>
86727>>>
86727>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
86728>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
86729>>>
86729>>>        Move 0 to iItem
86730>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
86731>>>        Decrement iSize
86732>>>        for iCount from 0 to iSize
86738>>>>
86738>>>
86738>>>            Move iCount to iItemFrom
86739>>>            Move iCount to iItemTo
86740>>>            Move APITableEmpty to APITableFrom
86741>>>            Move APITableEmpty to APITableTo
86742>>>
86742>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
86744>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
86745>>>            End
86745>>>>
86745>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
86747>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
86748>>>            End
86748>>>>
86748>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
86750>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
86751>>>                Move (iCount + 1) to iItemTo
86752>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
86753>>>            End
86753>>>>
86753>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
86755>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
86756>>>                If (iItemTo <> -1) Begin
86758>>>                    Move aAPITableTo[iItemTo] to APITableTo
86759>>>                End
86759>>>>
86759>>>                Else Begin
86760>>>                    Move APITableEmpty to APITableTo
86761>>>                End
86761>>>>
86761>>>            End
86761>>>>
86761>>>
86761>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
86762>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
86763>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
86764>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
86765>>>
86765>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
86766>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
86767>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
86768>>>            Move APITableTo.aApiRelations   to aApiRelationTo
86769>>>
86769>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
86770>>>
86770>>>            If (hTable > 0) Begin
86772>>>
86772>>>                // Table info:
86772>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
86773>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
86774>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
86775>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
86776>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
86777>>>
86777>>>                // Column info:
86777>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
86778>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
86779>>>
86779>>>                // Index info:
86779>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
86780>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
86781>>>
86781>>>                // Relation info:
86781>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
86782>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
86783>>>
86783>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
86784>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
86785>>>                Move False                                                              to aAPITableCompare[iItem].bError
86786>>>                If (iItemTo > iItemFrom) Begin
86788>>>                    Increment iCount
86789>>>                End
86789>>>>
86789>>>                Increment iItem
86790>>>            End
86790>>>>
86790>>>
86790>>>        Loop
86791>>>>
86791>>>
86791>>>        Function_Return aAPITableCompare
86792>>>    End_Function
86793>>>
86793>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
86795>>>        Integer iSize iCount iItem
86795>>>        tAPITableNameInfo ApiTableNameInfo
86795>>>        tAPITableNameInfo ApiTableNameInfo
86795>>>
86795>>>        Move -1 to iItem
86796>>>        Move (SizeOfArray(aTableStructure)) to iSize
86797>>>        Decrement iSize
86798>>>        For iCount from 0 to iSize
86804>>>>
86804>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
86805>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
86807>>>                Move iCount to iItem
86808>>>                Move iSize  to iCount // We're done.
86809>>>            End
86809>>>>
86809>>>        Loop
86810>>>>
86810>>>
86810>>>        Function_Return iItem
86811>>>    End_Function
86812>>>
86812>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
86814>>>        tAPITableNameInfoCompare APITableNameInfoCompare
86814>>>        tAPITableNameInfoCompare APITableNameInfoCompare
86814>>>
86814>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
86816>>>            Function_Return APITableNameInfoCompare
86817>>>        End
86817>>>>
86817>>>
86817>>>        // FROM database info:
86817>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
86819>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
86820>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
86821>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
86822>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
86823>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
86824>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
86825>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
86826>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
86827>>>        End
86827>>>>
86827>>>
86827>>>        // TO database info:
86827>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
86829>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
86830>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
86831>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
86832>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
86833>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
86834>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
86835>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
86836>>>            Move True                               to APITableNameInfoCompare.bExistsTo
86837>>>        End
86837>>>>
86837>>>
86837>>>        Function_Return APITableNameInfoCompare
86838>>>    End_Function
86839>>>
86839>>>    // Note:
86839>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
86839>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
86839>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
86839>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
86839>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
86839>>>    Function UtilTableHandleToString Handle hTable Returns String
86841>>>        String sTableName
86841>>>        Boolean bOpen bExists bOK
86841>>>
86841>>>        Get UtilTableNumberIsInUse hTable to bExists
86842>>>        If (bExists = False) Begin
86844>>>            Function_Return ""
86845>>>        End
86845>>>>
86845>>>
86845>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
86846>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
86849>>>        If (bOpen = False) Begin
86851>>>            Get AutoConnectionIDLogin to bOK
86852>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
86853>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
86854>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
86855>>>            Open hTable
86857>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
86858>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
86859>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
86860>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
86863>>>        End
86863>>>>
86863>>>        If (bOpen = True) Begin
86865>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
86866>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
86869>>>            // If blank it is an embedded table:
86869>>>            If (sTableName = "") Begin
86871>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86874>>>                Move 0 to LastErr
86875>>>                Move False to Err
86876>>>            End
86876>>>>
86876>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
86877>>>        End
86877>>>>
86877>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
86878>>>        Move 0 to LastErr
86879>>>
86879>>>        Function_Return sTableName
86880>>>    End_Function
86881>>>
86881>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
86881>>>    // Returns 0 if unsuccessful.
86881>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
86881>>>    Function UtilTableNameToHandle String sTableName Returns Integer
86883>>>        String sValue sPrefixTableName sDriverID
86883>>>        Handle hTable hRetval
86883>>>
86883>>>        Get psDriverID to sDriverID
86884>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
86886>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
86887>>>        End
86887>>>>
86887>>>        Move 0 to hTable
86888>>>        Move 0 to hRetval
86889>>>        Repeat
86889>>>>
86889>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86892>>>            If (hTable <> 0) Begin
86894>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
86897>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
86899>>>                    Move hTable to hRetval
86900>>>                    Move 0 to hTable
86901>>>                End
86901>>>>
86901>>>            End
86901>>>>
86901>>>        Until (hTable = 0)
86903>>>
86903>>>        Function_Return hRetval
86904>>>    End_Function
86905>>>
86905>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
86905>>>    // _after_ all tables have successfully been converted to SQL (.int files)
86905>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
86907>>>        Boolean bOK bExists
86907>>>        String sDataPath sBackupFolder
86907>>>
86907>>>        Close DF_ALL DF_PERMANENT
86908>>>        Send DoAdvance of ghoProgressBar
86909>>>
86909>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
86910>>>        Move CS_DUFBackupDataFolder to sBackupFolder
86911>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
86912>>>        Get vFolderFormat sDataPath to sDataPath
86913>>>
86913>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
86914>>>        If (bExists = False) Begin
86916>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
86917>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
86918>>>            If (bExists = False) Begin
86920>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
86921>>>>
86921>>>                Function_Return False
86922>>>            End
86922>>>>
86922>>>        End
86922>>>>
86922>>>
86922>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
86923>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
86924>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
86925>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
86926>>>        // We need to wait for Windows before we can copy files back
86926>>>        Sleep 2  
86927>>>        
86927>>>        //...except for these files that needs to be copied back to the Data folder:
86927>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
86928>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
86929>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
86930>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
86931>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
86932>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
86933>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
86933>>>        
86933>>>
86933>>>        Set Message_Text of ghoStatusPanel to ""
86934>>>        Function_Return True
86935>>>    End_Function
86936>>>    
86936>>>    Function UtilTableRepairAndReindexALL Returns Boolean
86938>>>        Boolean bOK bRetval
86938>>>        Handle hTable
86938>>>        Integer iSize iCount
86938>>>        
86938>>>        Move True to bOK
86939>>>        Get UtilFilelistNoOfTables to iSize
86940>>>        Set pbVisible    of ghoProgressBarOverall to True
86941>>>        Set piPosition   of ghoProgressBarOverall to 0
86942>>>        Set piMaximum    of ghoProgressBarOverall to iSize
86943>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
86944>>>
86944>>>        Repeat
86944>>>>
86944>>>            Set piPosition of ghoProgressBarOverall to iCount
86945>>>            Increment iCount
86946>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86949>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
86951>>>                Get UtilTableRepairAndReindex hTable to bRetval
86952>>>                If (bRetval = False) Begin
86954>>>                    Move False to bOK
86955>>>                End
86955>>>>
86955>>>            End
86955>>>>
86955>>>        Until (hTable = 0)
86957>>>                
86957>>>        Function_Return bOK
86958>>>    End_Function           
86959>>>    
86959>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
86959>>>    // After the header has been repaired - also makes a re-index.  
86959>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
86959>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
86961>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
86961>>>        Integer iRetval
86961>>>        String sRootName sFileName sDataPath
86961>>>        
86961>>>        Move False to Err
86962>>>        Move 0 to LastErr 
86963>>>        Move True to bOK
86964>>>        
86964>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
86965>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
86967>>>            Function_Return True
86968>>>        End
86968>>>>
86968>>>        Get UtilTableIsAlias hTable to bIsAlias 
86969>>>        If (bIsAlias = True) Begin
86971>>>            Function_Return True
86972>>>        End
86972>>>>
86972>>>        
86972>>>        // Check for bad file and remove if exists
86972>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86975>>>        Set private.phCurrentTable to hTable  
86976>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
86977>>>        
86977>>>        // This is important! Else it can happen that the table can't be opened,
86977>>>        // with a "4077 - File in use" error.
86977>>>        Close DF_ALL DF_PERMANENT    
86978>>>        Open hTable
86980>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
86983>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
86984>>>        If (bIsOpen = False) Begin
86986>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
86987>>>>
86987>>>            Function_Return False        
86988>>>        End
86988>>>>
86988>>>
86988>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
86989>>>        If (bBadExists = True) Begin
86991>>>            Get_File_Path (sRootName + ".BAD") to sFileName
86992>>>            Get vDeleteFile sFileName to iRetval
86993>>>        End
86993>>>>
86993>>>        
86993>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
86994>>>        
86994>>>        Move False to Err
86995>>>        // **** Repair and reindex the table. ****
86995>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
86996>>>
86996>>>        // Check for bad file: if it exists, something went wrong
86996>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
86997>>>        Get vFolderFormat sDataPath to sDataPath
86998>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
86999>>>        If (bBadExists = True) Begin
87001>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
87002>>>>
87002>>>            Move False to bOK
87003>>>        End
87003>>>>
87003>>>        Close hTable
87004>>>
87004>>>        Function_Return bOK
87005>>>    End_Function
87006>>>
87006>>>    // Repair and reindex the named DataFlex data-table.
87006>>>    // No checks are done if the passed table name is an embedded or SQL,
87006>>>    // so use with care (make sure you only pass embedded table names).
87006>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
87008>>>        String sMode
87008>>>        Integer iVoid
87008>>>
87008>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
87009>>>        Move "0" to sMode   // 0=Reindex after repair!    
87010>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
87011>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
87016>>>        Set Message_Text of ghoStatusPanel to ""
87017>>>        Function_Return (iVoid = 0)
87018>>>    End_Function
87019>>>
87019>>>    // Returns _two_ arrays.
87019>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
87019>>>    // Also returns all files that are Alias files in a second array.
87019>>>    // IMPORTANT: All master & alias files _must_ have been included into
87019>>>    //            the DoSetAllMasterAndAlias message.
87019>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
87021>>>        Integer[] iaFileIsAlias
87022>>>        Integer hTable iFileAlias iSize
87022>>>        Boolean bOpen
87022>>>
87022>>>        Move 0 to hTable
87023>>>        Repeat
87023>>>>
87023>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
87026>>>            If (hTable <> 0) Begin
87028>>>                Open hTable
87030>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
87033>>>                If (bOpen = True) Begin
87035>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
87038>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
87040>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
87041>>>                        Move hTable to iaFileIsMaster[iSize]
87042>>>                    End
87042>>>>
87042>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
87045>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
87046>>>                        Move hTable to iaFileIsAlias[iSize]
87047>>>                    End
87047>>>>
87047>>>                End
87047>>>>
87047>>>            End
87047>>>>
87047>>>        Until (hTable = 0)
87049>>>
87049>>>        Function_Return iaFileIsAlias
87050>>>    End_Function  
87051>>>    
87051>>>    // Is a repair of the data-header necessary? (Embedded tables only)
87051>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
87053>>>        String sMode
87053>>>        Integer iRepairNeeded bIsOpen
87053>>>
87053>>>        Move "0" to sMode
87054>>>        Set private.phCurrentTable to hTable 
87055>>>        Close hTable
87056>>>        Open hTable
87058>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87061>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
87066>>>
87066>>>        Function_Return iRepairNeeded
87067>>>    End_Function
87068>>>
87068>>>
87068>>>    // Helper function
87068>>>    // Takes two params:
87068>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
87068>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
87068>>>    // Returns:
87068>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
87068>>>    //  DF_FILE_IS_MASTER if master
87068>>>    //  DF_FILE_IS_ALIAS if alias
87068>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
87070>>>        Integer i iSize
87070>>>
87070>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
87071>>>        Decrement iSize
87072>>>        for i from 0 to iSize
87078>>>>
87078>>>            If (hTable = iaFileIsMaster[i]) Begin
87080>>>                Function_Return DF_FILE_IS_MASTER
87081>>>            End
87081>>>>
87081>>>        Loop
87082>>>>
87082>>>
87082>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
87083>>>        Decrement iSize
87084>>>        for i from 0 to iSize
87090>>>>
87090>>>            If (hTable = iaFileIsAlias[i]) Begin
87092>>>                Function_Return DF_FILE_IS_ALIAS
87093>>>            End
87093>>>>
87093>>>        Loop
87094>>>>
87094>>>
87094>>>        Function_Return DF_FILE_ALIAS_DEFAULT
87095>>>    End_Function
87096>>>
87096>>>    // Determine the available indexes of a table.
87096>>>    //
87096>>>    // Arguments:
87096>>>    //   Handle hTable - The number of the table
87096>>>    //
87096>>>    // Returns:
87096>>>    //   String - A string to be used with the sort command
87096>>>    //   to re-index all indexes of a table.
87096>>>    Function UtilTableIndexString Handle hTable Returns String
87098>>>        String  sSortString
87098>>>        Integer iLastIndex iNumSegments iCount
87098>>>
87098>>>        Move "" to sSortString
87099>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
87102>>>
87102>>>        for iCount from 1 to iLastIndex
87108>>>>
87108>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
87111>>>            If iNumSegments Begin
87113>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
87116>>>                Move (Append(sSortString, iCount)) to sSortString
87117>>>            End
87117>>>>
87117>>>        Loop
87118>>>>
87118>>>
87118>>>        Function_Return sSortString
87119>>>    End_Function
87120>>>
87120>>>    
87120>>>    // * Dummy function for the Studio's Code Explorer *
87120>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
87122>>>        Function_Return False
87123>>>    End_Function
87124>>>
87124>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
87124>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
87126>>>        Boolean bIsSame
87126>>>        Integer iCount iColumns iColumn
87126>>>
87126>>>        Move True to bIsSame
87127>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
87128>>>        Set piMaximum of ghoProgressBar  to iColumns
87129>>>        Decrement iColumns
87130>>>
87130>>>        for iCount from 0 to iColumns
87136>>>>
87136>>>            Set piPosition of ghoProgressBar to iCount
87137>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
87138>>>            If (bIsSame = False) Begin
87140>>>                Function_Return False
87141>>>            End
87141>>>>
87141>>>        Loop
87142>>>>
87142>>>
87142>>>        Function_Return (bIsSame = True)
87143>>>    End_Function
87144>>>
87144>>>    // Compares a single column (For 'FROM' & 'TO' tables)
87144>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
87146>>>        Integer iFromType iToType iDbType
87146>>>        tColumnType ColumnType
87146>>>        tColumnType ColumnType
87146>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
87146>>>
87146>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
87148>>>            Function_Return False
87149>>>        End
87149>>>>
87149>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
87151>>>            Function_Return False
87152>>>        End
87152>>>>
87152>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
87154>>>            Function_Return False
87155>>>        End                                                                
87155>>>>
87155>>>
87155>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
87157>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
87159>>>                Function_Return False
87160>>>            End
87160>>>>
87160>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
87162>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
87164>>>                    End
87164>>>>
87164>>>                Else Begin
87165>>>                    Function_Return False
87166>>>                End
87166>>>>
87166>>>            End
87166>>>>
87166>>>        End
87166>>>>
87166>>>
87166>>>        Get piDbType                       to iDbType
87167>>>        Move APIColumnCompare.iTypeFrom    to iFromType
87168>>>        Move APIColumnCompare.iTypeTo      to iToType
87169>>>
87169>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87169>>>        // data types between Embedded and SQL.
87169>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
87171>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
87172>>>        End
87172>>>>
87172>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
87174>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
87175>>>        End
87175>>>>
87175>>>
87175>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
87176>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
87177>>>
87177>>>        // Make Date and DateTime comparison?
87177>>>        If (bCompareDate_DataTime = True) Begin
87179>>>            If (iFromType <> iToType) Begin
87181>>>                Function_Return False
87182>>>            End
87182>>>>
87182>>>        End
87182>>>>
87182>>>
87182>>>        // This is when not checking for Date/DateTime differences but all other other field types...
87182>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
87184>>>            If (iFromType <> iToType) Begin
87186>>>                Function_Return False
87187>>>            End
87187>>>>
87187>>>        End
87187>>>>
87187>>>
87187>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
87187>>>        If (bIsDateTypeFrom = False) Begin
87189>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
87191>>>                Function_Return False
87192>>>            End
87192>>>>
87192>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
87194>>>                Function_Return False
87195>>>            End
87195>>>>
87195>>>        End
87195>>>>
87195>>>
87195>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
87197>>>            Function_Return False
87198>>>        End
87198>>>>
87198>>>
87198>>>        Function_Return True
87199>>>    End_Function
87200>>>
87200>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
87202>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
87202>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
87202>>>        tAPIColumn[] APIColumns APIColumnsEmpty
87202>>>        tAPIColumn[] APIColumns APIColumnsEmpty
87204>>>        String sDriverID sRootName sLogicalName
87204>>>
87204>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87205>>>        Get piDbType to iDbType
87206>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
87209>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
87212>>>
87212>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87215>>>        If (bIsOpen = False) Begin
87217>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87218>>>            Open hTable
87220>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87221>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87224>>>            If (bIsOpen = False) Begin
87226>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87227>>>                Move True to APIColumnsEmpty[0].bError
87228>>>                Function_Return APIColumnsEmpty
87229>>>            End
87229>>>>
87229>>>        End
87229>>>>
87229>>>
87229>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87232>>>        Get IsSQLDriver    sDriverID to bSqlDriver
87233>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
87234>>>
87234>>>        Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
87235>>>        If (bIsSqlTable = True) Begin
87237>>>            Get UtilTableExists hTable to bExists
87238>>>            If (bExists = False) Begin
87240>>>                Move True to APIColumnsEmpty[0].bError
87241>>>                Function_Return APIColumnsEmpty
87242>>>            End
87242>>>>
87242>>>        End
87242>>>>
87242>>>
87242>>>        Move 0 to iCount
87243>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
87246>>>        Set piMaximum of ghoProgressBar to iNumColumns
87247>>>
87247>>>        for iColumn from 1 to iNumColumns
87253>>>>
87253>>>            Move 0 to iOptions
87254>>>            Move False to bIdentityKey
87255>>>            Move False to Err
87256>>>            Move 0     to LastErr
87257>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
87258>>>            Set piPosition of ghoProgressBar to iColumn
87259>>>            If (bDawSqlDriver = True) Begin
87261>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
87262>>>                If (bIsSqlTable = True) Begin
87264>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
87267>>>                    Move iType                                                to APIColumns[iCount].iType
87268>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
87271>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
87274>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
87277>>>                End
87277>>>>
87277>>>                Else Begin
87278>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
87281>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
87282>>>                End
87282>>>>
87282>>>
87282>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
87282>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
87285>>>                Move (iCheckFieldNumber >= 0) to bExists
87286>>>                If (bExists = False) Begin
87288>>>                    Move 0 to APIColumns[iCount].iType
87289>>>                End
87289>>>>
87289>>>                If (bExists = True) Begin
87291>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
87294>>>                End
87294>>>>
87294>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
87295>>>                If (bIdentityKey = True) Begin
87297>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
87298>>>                End
87298>>>>
87298>>>            End
87298>>>>
87298>>>            Else Begin
87299>>>                Move False to Err
87300>>>                Move 0     to LastErr
87301>>>                If (bIsSqlTable = True) Begin
87303>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
87306>>>                End
87306>>>>
87306>>>                Else Begin
87307>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
87310>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
87311>>>                End
87311>>>>
87311>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
87311>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
87312>>>                If (bExists = False) Begin
87314>>>                    Move 0 to APIColumns[iCount].iType
87315>>>                End
87315>>>>
87315>>>            End
87315>>>>
87315>>>
87315>>>            If (bExists = True) Begin
87317>>>                Move iColumn to APIColumns[iCount].iFieldNumber
87318>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
87321>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
87321>>>//                If (bIsSqlTable = True) Begin
87321>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
87321>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
87321>>>//                End
87321>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
87324>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
87327>>>
87327>>>                // If the length was zero we might have an Overlap(!) field.
87327>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
87327>>>                If (APIColumns[iCount].iLength = 0) Begin
87329>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
87332>>>                    If (iType = DF_OVERLAP) Begin
87334>>>                        Move 0 to APIColumns[iCount].iFieldNumber
87335>>>                        Move 0 to APIColumns[iCount].iLength
87336>>>                        Move 0 to APIColumns[iCount].iOptions
87337>>>                        Move 0 to APIColumns[iCount].iPrecision
87338>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
87339>>>                        Move "" to APIColumns[iCount].sFieldName
87340>>>                        Decrement iCount
87341>>>                    End
87341>>>>
87341>>>                End
87341>>>>
87341>>>            End
87341>>>>
87341>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
87342>>>            If (bUserCancel = True) Begin
87344>>>                Move True to APIColumnsEmpty[0].bCancel
87345>>>                Function_Return APIColumnsEmpty
87346>>>            End
87346>>>>
87346>>>            Increment iCount
87347>>>        Loop
87348>>>>
87348>>>
87348>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87349>>>        Function_Return APIColumns
87350>>>    End_Function
87351>>>
87351>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
87351>>>    // The combined data will be sorted on the first struct member: iIndexNumber
87351>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
87351>>>    // have "holes" in the series of index numbers.
87351>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
87353>>>        tAPIColumnCompare[] aAPIColumnCompare
87353>>>        tAPIColumnCompare[] aAPIColumnCompare
87354>>>        tAPIColumnCompare   APIColumnCompare
87354>>>        tAPIColumnCompare   APIColumnCompare
87354>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
87354>>>
87354>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
87355>>>        Decrement iSizeFrom
87356>>>        for iCount from 0 to iSizeFrom
87362>>>>
87362>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
87363>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
87364>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
87365>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
87366>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
87367>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
87368>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
87369>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
87370>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
87371>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
87372>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
87373>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
87374>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
87375>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
87376>>>        Loop
87377>>>>
87377>>>
87377>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
87378>>>        Decrement iSizeTo
87379>>>        for iCount from 0 to iSizeTo
87385>>>>
87385>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
87386>>>            // Search if the field number already exists in the array; else add it.
87386>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
87387>>>            If (iItem = -1) Begin
87389>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
87390>>>            End
87390>>>>
87390>>>
87390>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
87391>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
87392>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
87393>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
87394>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
87395>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
87396>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
87397>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
87398>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
87399>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
87400>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
87401>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
87402>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
87403>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
87404>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
87405>>>        Loop
87406>>>>
87406>>>
87406>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
87407>>>
87407>>>        Function_Return aAPIColumnCompare
87408>>>    End_Function
87409>>>
87409>>>    // Checks if a field name exists in a table definition
87409>>>    // Returns True if it does
87409>>>    // Sample:
87409>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
87409>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
87411>>>        Integer iNumColumns iColumn
87411>>>        String sColumn
87411>>>        Boolean bExists bOK bOpen
87411>>>
87411>>>        Get AutoConnectionIDLogin to bOK
87412>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87413>>>        Open hTable
87415>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87416>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87419>>>        If (bOpen = False) Begin
87421>>>            Function_Return False
87422>>>        End
87422>>>>
87422>>>
87422>>>        Move False to bExists
87423>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
87426>>>        for iColumn from 1 to iNumColumns
87432>>>>
87432>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
87435>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
87437>>>                Move iNumColumns to iColumn
87438>>>                Move True to bExists
87439>>>            End
87439>>>>
87439>>>        Loop
87440>>>>
87440>>>        Close hTable
87441>>>
87441>>>        Function_Return bExists
87442>>>    End_Function
87443>>>
87443>>>    // Returns the field/column number for the passed FieldName as an integer.
87443>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
87445>>>        Integer iNumColumns iColumn iRetval
87445>>>        String sColumn
87445>>>        Boolean bOK bOpen
87445>>>
87445>>>        Get AutoConnectionIDLogin to bOK
87446>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87447>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87448>>>        Open hTable
87450>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87451>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87454>>>        If (bOpen = False) Begin
87456>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87457>>>            Function_Return False
87458>>>        End
87458>>>>
87458>>>
87458>>>        Move 0 to iColumn
87459>>>        Move 0 to iRetval
87460>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
87463>>>        for iColumn from 1 to iNumColumns
87469>>>>
87469>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
87472>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
87474>>>                Move iColumn to iRetval
87475>>>                Move iNumColumns to iColumn
87476>>>            End
87476>>>>
87476>>>        Loop
87477>>>>
87477>>>        Close hTable
87478>>>
87478>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87479>>>        Function_Return iRetval
87480>>>    End_Function
87481>>>
87481>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
87481>>>    // The reciprocal function is UtilColumnTypeToInteger.
87481>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
87483>>>        tColumnType RetvalType
87483>>>        tColumnType RetvalType
87483>>>
87483>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
87484>>>        Function_Return RetvalType.iSQLType
87485>>>    End_Function
87486>>>
87486>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
87486>>>    // The reciprocal function is UtilColumnTypeToString.
87486>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
87488>>>        tColumnType RetvalType
87488>>>        tColumnType RetvalType
87488>>>
87488>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
87489>>>        Function_Return RetvalType.sSQLType
87490>>>    End_Function
87491>>>
87491>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
87493>>>        tColumnType RetvalType
87493>>>        tColumnType RetvalType
87493>>>
87493>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
87494>>>        Function_Return RetvalType.sPrecision
87495>>>    End_Function
87496>>>
87496>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
87498>>>        tColumnType RetvalType
87498>>>        tColumnType RetvalType
87498>>>
87498>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
87499>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
87499>>>        // if the column type length is _not_ fixed.
87499>>>        Function_Return (RetvalType.bCanEditSize = False)
87500>>>    End_Function
87501>>>
87501>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
87503>>>        tColumnType RetvalType
87503>>>        tColumnType RetvalType
87503>>>        String sValue
87503>>>        Integer iRetval iPos
87503>>>
87503>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
87504>>>        Move RetvalType.sPrecision to sValue
87505>>>        Move (Pos(".", sValue)) to iPos
87506>>>        If (iPos <> 0) Begin
87508>>>            Move (Left(sValue, (iPos -1))) to iRetval
87509>>>        End
87509>>>>
87509>>>        Else Begin
87510>>>            Move sValue to iRetval
87511>>>        End
87511>>>>
87511>>>        Function_Return iRetval
87512>>>    End_Function
87513>>>
87513>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
87515>>>        tColumnType RetvalType
87515>>>        tColumnType RetvalType
87515>>>        String sValue
87515>>>        Integer iRetval iPos
87515>>>
87515>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
87516>>>        Move RetvalType.sPrecision to sValue
87517>>>        Move (Pos(".", sValue)) to iPos
87518>>>        If (iPos = 0) Begin
87520>>>            Function_Return 0
87521>>>        End
87521>>>>
87521>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
87522>>>
87522>>>        Function_Return iRetval
87523>>>    End_Function
87524>>>
87524>>>    // * Dummy function for the Studio's Code Explorer *
87524>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
87526>>>        Function_Return False
87527>>>    End_Function
87528>>>
87528>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
87528>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
87530>>>        Boolean bIsSame
87530>>>        Integer iCount iSize
87530>>>
87530>>>        Move True to bIsSame
87531>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
87532>>>        Decrement iSize
87533>>>        For iCount from 0 to iSize
87539>>>>
87539>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87540>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87541>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
87542>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87543>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87544>>>            If (bIsSame = False) Begin
87546>>>                Function_Return False
87547>>>            End
87547>>>>
87547>>>        Loop
87548>>>>
87548>>>
87548>>>        Function_Return bIsSame
87549>>>    End_Function
87550>>>
87550>>>    // Compares a single index for a 'FROM' and a 'TO' table.
87550>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
87552>>>        Boolean bIsSame
87552>>>        Integer iSegment
87552>>>
87552>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
87553>>>        If (bIsSame = False) Begin
87555>>>            Function_Return False
87556>>>        End
87556>>>>
87556>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
87557>>>        If (bIsSame = False) Begin
87559>>>            Function_Return False
87560>>>        End
87560>>>>
87560>>>
87560>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
87562>>>            // * We should probably not compare SQL index names?
87562>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
87562>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
87562>>>            //     Function_Return False
87562>>>            // End
87562>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
87563>>>            If (bIsSame = False) Begin
87565>>>                Function_Return False
87566>>>            End
87566>>>>
87566>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
87567>>>            If (bIsSame = False) Begin
87569>>>                Function_Return False
87570>>>            End
87570>>>>
87570>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
87571>>>            If (bIsSame = False) Begin
87573>>>                Function_Return False
87574>>>            End
87574>>>>
87574>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
87575>>>            If (bIsSame = False) Begin
87577>>>                Function_Return False
87578>>>            End
87578>>>>
87578>>>        End
87578>>>>
87578>>>
87578>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
87579>>>        Move (iSegment = -1) to bIsSame
87580>>>
87580>>>        Function_Return (bIsSame = True)
87581>>>    End_Function
87582>>>
87582>>>    // Compares each segment for the passed index.
87582>>>    // Returns -1 if same; else returns the index segment that differs.
87582>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
87584>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
87584>>>        Boolean bIsSame
87584>>>
87584>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87585>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87586>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
87587>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
87588>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
87589>>>
87589>>>        Decrement iNumSegments
87590>>>        for iSegment from 0 to iNumSegments
87596>>>>
87596>>>            Move False to bIsSame
87597>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
87599>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
87600>>>            End
87600>>>>
87600>>>            If (bIsSame = False) Begin
87602>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87603>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87604>>>                Function_Return iSegment
87605>>>            End
87605>>>>
87605>>>        Loop
87606>>>>
87606>>>
87606>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87607>>>        Function_Return -1 // This means bIsSame = True
87608>>>    End_Function
87609>>>
87609>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
87611>>>        Boolean bIsSame
87611>>>
87611>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
87612>>>        If (bIsSame = False) Begin
87614>>>            Function_Return False
87615>>>        End
87615>>>>
87615>>>        If (bCompareIndexUppercase = True) Begin
87617>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
87618>>>            If (bIsSame = False) Begin
87620>>>                Function_Return False
87621>>>            End
87621>>>>
87621>>>        End
87621>>>>
87621>>>        If (bCompareIndexAscending = True) Begin
87623>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
87624>>>            If (bIsSame = False) Begin
87626>>>                Function_Return False
87627>>>            End
87627>>>>
87627>>>        End
87627>>>>
87627>>>
87627>>>        Function_Return True
87628>>>    End_Function
87629>>>
87629>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
87631>>>        Boolean bIsSame bOK
87631>>>        Integer iSize iSizeTo iCount
87631>>>        tAPIIndexCompare[] aAPIIndexCompare
87631>>>        tAPIIndexCompare[] aAPIIndexCompare
87632>>>
87632>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
87633>>>        If (iSize = 0) Begin
87635>>>            Function_Return True
87636>>>        End
87636>>>>
87636>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
87637>>>        Get UtilTableIsSql hTable to bIsSQLTableTo
87638>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
87639>>>
87639>>>        for iCount from 0 to (iSize - 1)
87645>>>>
87645>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
87646>>>            If (bIsSame = False) Begin
87648>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
87649>>>            End
87649>>>>
87649>>>        Loop
87650>>>>
87650>>>
87650>>>        // We probably should delete other indexes if they exists.
87650>>>        for iCount from (iSize +1) to iSizeTo
87656>>>>
87656>>>            Get ApiIndexRemove hTable iCount to bOK
87657>>>        Loop
87658>>>>
87658>>>
87658>>>        Function_Return bOK
87659>>>    End_Function
87660>>>
87660>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
87660>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
87660>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
87660>>>//        String sFieldName sDriverID
87660>>>//
87660>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87660>>>//        If (bIsOpen = False) Begin
87660>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87660>>>//            Open hTable
87660>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87660>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87660>>>//            If (bIsOpen = False) Begin
87660>>>//                Function_Return False
87660>>>//            End
87660>>>//        End
87660>>>//
87660>>>//        Move True to bEqual
87660>>>//        Get psDriverID to sDriverID
87660>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
87660>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
87660>>>//        Move (SizeOfArray(aColumns)) to iSize
87660>>>//        Decrement iSize
87660>>>//
87660>>>//        For iCount from 0 to iSize
87660>>>//            Move 0 to iOptions
87660>>>//            Move False to bIdentityKey
87660>>>//            Move aColumns[iCount].sFieldName to sFieldName
87660>>>//
87660>>>//            // We need to use the column name - not the column integer as
87660>>>//            // the order does not need to be the same, and the logic should still work.
87660>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
87660>>>//            If (iColumn > 0) Begin
87660>>>//                If (bDawSqlDriver = True) Begin
87660>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
87660>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
87660>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
87660>>>//                        Move False to bEqual
87660>>>//                    End
87660>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
87660>>>//                    If (bIdentityKey = True) Begin
87660>>>//                        Move C_tAPIColumn_Identity to iOptions
87660>>>//                    End
87660>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
87660>>>//                        Move False to bEqual
87660>>>//                    End
87660>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
87660>>>//                End
87660>>>//                Else Begin
87660>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
87660>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
87660>>>//                        Move False to bEqual
87660>>>//                    End
87660>>>//                End
87660>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
87660>>>//                If (iLength <> aColumns[iCount].iLength) Begin
87660>>>//                    Move False to bEqual
87660>>>//                End
87660>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
87660>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
87660>>>//                    Move False to bEqual
87660>>>//                End
87660>>>//                If (bEqual = False) Begin
87660>>>//                    Function_Return False
87660>>>//                End
87660>>>//            End
87660>>>//
87660>>>//            Else Begin
87660>>>//                Function_Return False
87660>>>//            End
87660>>>//        Loop
87660>>>//
87660>>>//        Function_Return bEqual
87660>>>//    End_Function
87660>>>
87660>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
87662>>>        tAPIIndex[] APIIndexes
87662>>>        tAPIIndex[] APIIndexes
87663>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
87663>>>        String sDriverID
87663>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
87663>>>
87663>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87664>>>        Get psDriverID to sDriverID
87665>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
87666>>>        Get UtilTableIsSQL hTable to bIsSQLTable
87667>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87670>>>        If (bIsOpen = False) Begin
87672>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87673>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87674>>>            Open hTable
87676>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87677>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87678>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87681>>>            If (bIsOpen = False) Begin
87683>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87684>>>                Move True to APIIndexes[0].bError
87685>>>                Function_Return APIIndexes
87686>>>            End
87686>>>>
87686>>>        End
87686>>>>
87686>>>
87686>>>        Move 0 to iCount
87687>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
87690>>>        for iIndex from 1 to iIndexes
87696>>>>
87696>>>            // This is a test that the index exists as there might be "holes" aka the index
87696>>>            // numbers doesn't not need to be consequitive:
87696>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
87699>>>            If (iNumSegments > 0) Begin
87701>>>
87701>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
87702>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
87705>>>                If (bIsSQLTable = True) Begin
87707>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
87710>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
87713>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
87716>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
87719>>>                End
87719>>>>
87719>>>
87719>>>                Move 0 to iSegmentCount
87720>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
87723>>>                For iSegment from 1 to iNumSegments
87729>>>>
87729>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
87732>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
87733>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
87736>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
87739>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
87742>>>                    Increment iSegmentCount
87743>>>                Loop
87744>>>>
87744>>>                Increment iCount
87745>>>            End
87745>>>>
87745>>>        Loop
87746>>>>
87746>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87747>>>
87747>>>        Function_Return APIIndexes
87748>>>    End_Function
87749>>>
87749>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
87749>>>    // The combined data will be sorted on the first struct member: iIndexNumber
87749>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
87749>>>    // have "holes" in the series of index numbers.
87749>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
87751>>>        tAPIIndexCompare[] aAPIIndexCompare
87751>>>        tAPIIndexCompare[] aAPIIndexCompare
87752>>>        tAPIIndexCompare   APIIndexCompare
87752>>>        tAPIIndexCompare   APIIndexCompare
87752>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
87752>>>
87752>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
87753>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
87754>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
87756>>>            Function_Return aAPIIndexCompare
87757>>>        End
87757>>>>
87757>>>
87757>>>        Decrement iSizeFrom
87758>>>        for iCount from 0 to iSizeFrom
87764>>>>
87764>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
87765>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
87766>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
87767>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
87768>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
87769>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
87770>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
87771>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
87772>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
87773>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
87774>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
87775>>>        Loop
87776>>>>
87776>>>
87776>>>        Decrement iSizeTo
87777>>>        for iCount from 0 to iSizeTo
87783>>>>
87783>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
87784>>>            // Search if the Index number already exists in the array; else add it.
87784>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
87785>>>            If (iItem = -1) Begin
87787>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
87788>>>            End
87788>>>>
87788>>>
87788>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
87789>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
87790>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
87791>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
87792>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
87793>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
87794>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
87795>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
87796>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
87797>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
87798>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
87799>>>        Loop
87800>>>>
87800>>>
87800>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
87801>>>
87801>>>        Function_Return aAPIIndexCompare
87802>>>    End_Function
87803>>>
87803>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
87803>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
87805>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
87805>>>        String sDriverID
87805>>>
87805>>>        Get psDriverID to sDriverID
87806>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
87807>>>        Get IsSQLDriver sDriverID to bIsSqlTable
87808>>>        If (bIsSqlTable = True) Begin
87810>>>            Get UtilTableIsSQL hTable to bIsSqlTable
87811>>>        End
87811>>>>
87811>>>
87811>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
87812>>>        If (bIsSame = False) Begin
87814>>>            Function_Return False
87815>>>        End
87815>>>>
87815>>>
87815>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
87817>>>            // Don't think we should do this. Or should we?
87817>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
87817>>>
87817>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
87818>>>            If (bIsSame = False) Begin
87820>>>                Function_Return False
87821>>>            End
87821>>>>
87821>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
87822>>>            If (bIsSame = False) Begin
87824>>>                Function_Return False
87825>>>            End
87825>>>>
87825>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
87826>>>            If (bIsSame = False) Begin
87828>>>                Function_Return False
87829>>>            End
87829>>>>
87829>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
87830>>>            If (bIsSame = False) Begin
87832>>>                Function_Return False
87833>>>            End
87833>>>>
87833>>>        End
87833>>>>
87833>>>
87833>>>        Function_Return bIsSame
87834>>>    End_Function
87835>>>
87835>>>    // DF_INDEX_SQL_TYPE values
87835>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
87835>>>    // returns a string with the name.
87835>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
87837>>>        String sRetval
87837>>>        Case Begin
87837>>>            Case (iIndexType = DF_INDEX_CLIENT)
87839>>>                Move "DF_INDEX_CLIENT" to sRetval
87840>>>                Case Break
87841>>>            Case (iIndexType = DF_INDEX_SERVER)
87844>>>                Move "DF_INDEX_SERVER" to sRetval
87845>>>                Case Break
87846>>>            Case (iIndexType = DF_INDEX_SERVER_ONLY)
87849>>>                Move "DF_INDEX_SERVER_ONLY" to sRetval
87850>>>                Case Break
87851>>>            Case (iIndexType = DF_INDEX_TEMPORARY)
87854>>>                Move "DF_INDEX_TEMPORARY" to sRetval
87855>>>                Case Break
87856>>>            Case Else
87856>>>                Move "UNKNOWN INDEX TYPE" to sRetval
87857>>>        Case End
87857>>>        Function_Return sRetval
87858>>>    End_Function
87859>>>
87859>>>    // * Dummy function for the Studio's Code Explorer *
87859>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
87861>>>        Function_Return False
87862>>>    End_Function
87863>>>
87863>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
87863>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
87865>>>        Boolean bIsSame
87865>>>        Integer iSize iCount
87865>>>
87865>>>        Move True to bIsSame
87866>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
87867>>>        Decrement iSize
87868>>>        For iCount from 0 to iSize
87874>>>>
87874>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
87875>>>            If (bIsSame = False) Begin
87877>>>                Function_Return False
87878>>>            End
87878>>>>
87878>>>        Loop
87879>>>>
87879>>>
87879>>>        Function_Return bIsSame
87880>>>    End_Function
87881>>>
87881>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
87881>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
87883>>>        Boolean bIsSame
87883>>>
87883>>>        Move True to bIsSame
87884>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
87886>>>            Function_Return False
87887>>>        End
87887>>>>
87887>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
87889>>>            Function_Return False
87890>>>        End
87890>>>>
87890>>>
87890>>>        // We could also compare field names, but I don't think that is necessary...
87890>>>
87890>>>        Function_Return bIsSame
87891>>>    End_Function
87892>>>
87892>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
87892>>>    // already exists.
87892>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
87894>>>        Boolean bOK
87894>>>        Integer iSizeTo iSize iCount iColumn
87894>>>        String sDriverID
87894>>>
87894>>>        Move True to bOK
87895>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
87896>>>        If (iSizeTo > 0) Begin
87898>>>            Get AutoConnectionIDLogin to bOK
87899>>>            Move False to Err
87900>>>            Open hTable Mode DF_EXCLUSIVE
87902>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87905>>>            Decrement iSizeTo
87906>>>
87906>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
87906>>>            // for the "TO" database. But start by deleting all current "TO" relations:
87906>>>            Structure_Start hTable sDriverID
87907>>>                for iCount from 0 to iSizeTo
87913>>>>
87913>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
87914>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
87917>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
87920>>>                Loop
87921>>>>
87921>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87922>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87924>>>            Set Action_Text of ghoStatusPanel to ""
87925>>>        End
87925>>>>
87925>>>
87925>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
87926>>>        Decrement iSize
87927>>>        for iCount from 0 to iSize
87933>>>>
87933>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
87934>>>        Loop
87935>>>>
87935>>>
87935>>>        Function_Return bOK
87936>>>    End_Function
87937>>>
87937>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
87939>>>        tAPIRelation[] APIRelations
87939>>>        tAPIRelation[] APIRelations
87940>>>        Integer iColumn iColumnTo iNumColumns iCount
87940>>>        Handle hParent
87940>>>        Boolean bIsOpen
87940>>>
87940>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87941>>>        Move 0 to iCount
87942>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87945>>>        If (bIsOpen = False) Begin
87947>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87948>>>            Open hTable
87950>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87951>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87954>>>            If (bIsOpen = False) Begin
87956>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87957>>>                Move True to APIRelations[0].bError
87958>>>                Function_Return APIRelations
87959>>>            End
87959>>>>
87959>>>        End
87959>>>>
87959>>>
87959>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
87962>>>        For iColumn from 1 to iNumColumns
87968>>>>
87968>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
87971>>>            If (hParent <> 0) Begin
87973>>>                Open hParent
87975>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
87976>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
87979>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
87980>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
87983>>>
87983>>>                Move hParent                                            to APIRelations[iCount].hTableTo
87984>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
87987>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
87990>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
87991>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
87994>>>                Move False                                              to APIRelations[iCount].bShouldChange
87995>>>                Move False                                              to APIRelations[iCount].bCancel
87996>>>                Move False                                              to APIRelations[iCount].bError
87997>>>                Close hParent
87998>>>                Increment iCount
87999>>>            End
87999>>>>
87999>>>        Loop
88000>>>>
88000>>>
88000>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88001>>>        Function_Return APIRelations
88002>>>    End_Function
88003>>>
88003>>>    Function UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
88005>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
88007>>>            Function_Return (EQ)
88008>>>        End
88008>>>>
88008>>>
88008>>>        Function_Return (GT)
88009>>>    End_Function
88010>>>
88010>>>    Function SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
88012>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
88015>>>
88015>>>        Function_Return (GT)
88016>>>    End_Function
88017>>>
88017>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
88017>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
88017>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
88019>>>        tAPIRelation[] aAPIRelationFromAndTo
88019>>>        tAPIRelation[] aAPIRelationFromAndTo
88020>>>        tAPIRelationCompare[] aAPIRelationCompare
88020>>>        tAPIRelationCompare[] aAPIRelationCompare
88021>>>        tAPIRelationCompare   APIRelationCompare
88021>>>        tAPIRelationCompare   APIRelationCompare
88021>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
88021>>>
88021>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
88022>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
88023>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
88025>>>            Function_Return aAPIRelationCompare
88026>>>        End
88026>>>>
88026>>>
88026>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
88027>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(UtilRelationArrayCompare))) to aAPIRelationFromAndTo
88028>>>
88028>>>        Decrement iSizeFrom
88029>>>        for iCount from 0 to iSizeFrom
88035>>>>
88035>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
88036>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
88037>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
88038>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
88039>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
88040>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
88041>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
88042>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
88043>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
88044>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
88045>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
88046>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
88047>>>        Loop
88048>>>>
88048>>>
88048>>>        Decrement iSizeTo
88049>>>        for iCount from 0 to iSizeTo
88055>>>>
88055>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
88056>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
88057>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
88058>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
88059>>>
88059>>>            // Search if the relation already exists in the array; else add it.
88059>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to iItem
88060>>>            If (iItem = -1) Begin
88062>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
88063>>>            End
88063>>>>
88063>>>
88063>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
88064>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
88065>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
88066>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
88067>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
88068>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
88069>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
88070>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
88071>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
88072>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
88073>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
88074>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
88075>>>        Loop
88076>>>>
88076>>>
88076>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to aAPIRelationCompare
88077>>>
88077>>>        Function_Return aAPIRelationCompare
88078>>>    End_Function
88079>>>
88079>>>    // * Dummy function for the Studio's Code Explorer *
88079>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
88081>>>        Function_Return False
88082>>>    End_Function
88083>>>
88083>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
88083>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
88083>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
88083>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
88085>>>        Boolean bFound
88085>>>
88085>>>        Move False to Err
88086>>>        Open CodeMast
88088>>>        Open CodeType
88090>>>
88090>>>        If (bCodeType = True) Begin
88092>>>            Set Private.phCurrentTable to CODETYPE.File_Number
88093>>>            Clear CodeType
88094>>>            Move sTypeValue to CODETYPE.Type
88095>>>            Find eq CODETYPE by 1
88096>>>>
88096>>>            Move Found to bFound
88097>>>            If (bFound = True) Begin
88099>>>                Reread CodeType
88103>>>            End
88103>>>>
88103>>>            Else Begin
88104>>>                Clear CodeType
88105>>>            End
88105>>>>
88105>>>
88105>>>            Move sTypeValue to CODETYPE.Type
88106>>>            Move sValue2    to CODETYPE.Description
88107>>>            Move sValue3    to CODETYPE.Comment
88108>>>            SaveRecord CODETYPE
88109>>>
88109>>>            If (bFound = True) Begin
88111>>>                Unlock
88112>>>>
88112>>>            End
88112>>>>
88112>>>        End
88112>>>>
88112>>>
88112>>>        If (bCodeType = False) Begin
88114>>>            Set Private.phCurrentTable to CODEMAST.File_Number
88115>>>            Clear CODEMAST
88116>>>            Move sTypeValue to CODEMAST.Type
88117>>>            Move sValue2    to CODEMAST.Code
88118>>>            Find eq CODEMAST by 1
88119>>>>
88119>>>            Move Found to bFound
88120>>>            If (bFound = True) Begin
88122>>>                Reread CODEMAST
88126>>>            End
88126>>>>
88126>>>            Else Begin
88127>>>                Clear CODEMAST
88128>>>            End
88128>>>>
88128>>>
88128>>>            Move sTypeValue to CODEMAST.Type
88129>>>            Move sValue2    to CODEMAST.Code
88130>>>            Move sValue3    to CODEMAST.Description
88131>>>            SaveRecord CODEMAST
88132>>>
88132>>>            If (bFound = True) Begin
88134>>>                Unlock
88135>>>>
88135>>>            End
88135>>>>
88135>>>        End
88135>>>>
88135>>>
88135>>>        Close CodeMast
88136>>>        Close CodeType
88137>>>
88137>>>        Function_Return (Err = False)
88138>>>    End_Function
88139>>>
88139>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
88139>>>    // CodeType and then spins through all CodeMast records to change all related records.
88139>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
88141>>>        Boolean bFound
88141>>>
88141>>>        Move False to Err
88142>>>        Open CodeMast
88144>>>        Open CodeType
88146>>>
88146>>>        Clear CodeType
88147>>>        Move sFromValue to CODETYPE.Type
88148>>>        Find eq CODETYPE.Type
88149>>>>
88149>>>        If (Found = True) Begin
88151>>>            Reread CODETYPE
88155>>>                Move sToValue to CODETYPE.Type
88156>>>                SaveRecord CODETYPE
88157>>>            Unlock
88158>>>>
88158>>>        End
88158>>>>
88158>>>
88158>>>        Clear CODEMAST
88159>>>        Find gt CODEMAST by Recnum
88160>>>>
88160>>>        While (Found = True)
88164>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
88165>>>            If (bFound = True) Begin
88167>>>                Reread CODEMAST
88171>>>                    Move sToValue to CODEMAST.Type
88172>>>                    SaveRecord CODEMAST
88173>>>                Unlock
88174>>>>
88174>>>            End
88174>>>>
88174>>>            Find gt CODEMAST by Recnum
88175>>>>
88175>>>        Loop
88176>>>>
88176>>>
88176>>>        Close CodeMast
88177>>>        Close CodeType
88178>>>
88178>>>        Function_Return (Err = False)
88179>>>    End_Function
88180>>>
88180>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
88180>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
88182>>>        Boolean bFound
88182>>>
88182>>>        Move False to Err
88183>>>        Open CodeMast
88185>>>
88185>>>        Clear CODEMAST
88186>>>        Move sTypeValue to CODEMAST.Type
88187>>>        Move sValue2    to CODEMAST.Code
88188>>>        Find eq CODEMAST.Code
88189>>>>
88189>>>        Move Found to bFound
88190>>>        If (bFound = True) Begin
88192>>>            Delete CODEMAST
88193>>>        End
88193>>>>
88193>>>
88193>>>        Close CodeMast
88194>>>
88194>>>        Function_Return (Err = False)
88195>>>    End_Function
88196>>>
88196>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
88198>>>        Boolean bRecnum bToAnsi
88198>>>        Integer iCh
88198>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
88198>>>
88198>>>        If (Trim(sDataPath) = "") Begin
88200>>>            Function_Return False
88201>>>        End
88201>>>>
88201>>>
88201>>>        Move False to Err
88202>>>        Get psDriverID     to sDriverID
88203>>>        Get psConnectionID to sConnectionID
88204>>>        Get psSchema       to sSchemaName
88205>>>        Get True           to bRecnum
88206>>>        Get pbToANSI       to bToAnsi
88207>>>        Move CS_ANSI_Txt to sANSI_OEM
88208>>>        If (bToAnsi = False) Begin
88210>>>            Move CS_OEM_Txt to sANSI_OEM
88211>>>        End
88211>>>>
88211>>>
88211>>>        Get vFolderFormat sDataPath to sDataPath
88212>>>        Move "CodeMast.int"         to sFileName
88213>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
88214>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
88217>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
88220>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
88223>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
88226>>>            Writeln channel iCh ("")
88229>>>            Writeln channel iCh ("RECNUM_TABLE YES")
88232>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
88235>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
88238>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
88241>>>            Writeln channel iCh ("")
88244>>>            Writeln channel iCh ("INDEX_NUMBER 1")
88247>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
88250>>>            Writeln channel iCh ("")
88253>>>        Send Seq_Close_Channel iCh
88254>>>
88254>>>        Get vFolderFormat sDataPath to sDataPath
88255>>>        Move "CodeType.int"         to sFileName
88256>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
88257>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
88260>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
88263>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
88266>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
88269>>>            Writeln channel iCh ("")
88272>>>            Writeln channel iCh ("RECNUM_TABLE YES")
88275>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
88278>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
88281>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
88284>>>            Writeln channel iCh ("")
88287>>>            Writeln channel iCh ("INDEX_NUMBER 0")
88290>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
88293>>>            Writeln channel iCh ("")
88296>>>            Writeln channel iCh ("INDEX_NUMBER 1")
88299>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
88302>>>            Writeln channel iCh ("")
88305>>>        Send Seq_Close_Channel iCh
88306>>>
88306>>>        Function_Return (Err = False)
88307>>>    End_Function
88308>>>
88308>>>    // * Dummy function for the Studio's Code Explorer *
88308>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
88310>>>        Function_Return False
88311>>>    End_Function
88312>>>
88312>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
88312>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
88312>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
88314>>>        Boolean bOK bExists
88314>>>        String sDataPath sBackupFolder
88314>>>
88314>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
88315>>>        Move CS_DUFBackupDataFolder to sBackupFolder
88316>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
88317>>>        Get vFolderFormat sDataPath to sDataPath
88318>>>
88318>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
88319>>>        If (bExists = False) Begin
88321>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
88322>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
88323>>>            If (bExists = False) Begin
88325>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
88326>>>>
88326>>>                Function_Return False
88327>>>            End
88327>>>>
88327>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
88328>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
88329>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
88330>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
88331>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
88332>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
88333>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
88334>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
88335>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
88336>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
88337>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
88338>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
88339>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
88340>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
88341>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
88342>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
88343>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
88344>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
88345>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
88346>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
88347>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
88348>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
88349>>>        End
88349>>>>
88349>>>
88349>>>        Set Message_Text of ghoStatusPanel to ""
88350>>>        Function_Return True
88351>>>    End_Function
88352>>>    
88352>>>    // Check if the file exists in the Data folder,
88352>>>    // else creates it from memory as it has been compiled into the program as a resource:
88352>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
88354>>>        String sPath
88354>>>        Boolean bExists
88354>>>
88354>>>        Get psDataPathFirstPart to sPath
88355>>>        Move (sPath + sFileName) to sFileName
88356>>>        Get vFilePathExists sFileName to bExists
88357>>>
88357>>>        If (bExists = False) Begin
88359>>>            // Read from memory & create file on disk.
88359>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
88360>>>            Get vFilePathExists sFileName to bExists
88361>>>        End
88361>>>>
88361>>>        Function_Return bExists
88362>>>    End_Function
88363>>>
88363>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
88365>>>        tColumnType RetvalType
88365>>>        tColumnType RetvalType
88365>>>        Integer iRetval
88365>>>
88365>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
88366>>>        Move RetvalType.iDataFlexType to iRetval
88367>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
88369>>>            If (iLength <= 255) Begin
88371>>>                Move DF_ASCII to iRetval
88372>>>            End
88372>>>>
88372>>>        End
88372>>>>
88372>>>        Function_Return iRetval
88373>>>    End_Function
88374>>>
88374>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
88376>>>        String sRetval
88376>>>
88376>>>        Case Begin
88376>>>            Case (iDataType = DF_ASCII)
88378>>>                Move "DF_ASCII" to sRetval
88379>>>                Case Break
88380>>>            Case (iDataType = DF_BCD)
88383>>>                Move "DF_BCD" to sRetval
88384>>>                Case Break
88385>>>            Case (iDataType = DF_BINARY)
88388>>>                Move "DF_BINARY" to sRetval
88389>>>                Case Break
88390>>>            Case (iDataType = DF_DATE)
88393>>>                Move "DF_DATE" to sRetval
88394>>>                Case Break
88395>>>            Case (iDataType = DF_DATETIME)
88398>>>                Move "DF_DATETIME" to sRetval
88399>>>                Case Break
88400>>>            Case (iDataType = DF_TEXT)
88403>>>                Move "DF_TEXT" to sRetval
88404>>>                Case Break
88405>>>            Case Else
88405>>>                Move "" to sRetval
88406>>>        Case End
88406>>>
88406>>>        Function_Return sRetval
88407>>>    End_Function
88408>>>
88408>>>    // The default value used for a datatype as specified in the driver int file.
88408>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
88410>>>        String sRetval sServer
88410>>>        tColumnType RetvalType
88410>>>        tColumnType RetvalType
88410>>>        Integer iDriver iDataFlexType
88410>>>        Handle hDatabase
88410>>>
88410>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
88411>>>        Move RetvalType.iDataFlexType to iDataFlexType
88412>>>        Get DriverIndex sDriverID to iDriver
88413>>>        Get psServer to sServer
88414>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
88415>>>        If (hDatabase = 0) Begin
88417>>>            Function_Return ""
88418>>>        End
88418>>>>
88418>>>
88418>>>        Case Begin
88418>>>            Case (iDataFlexType = DF_ASCII)
88420>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
88423>>>                Case Break
88424>>>            Case (iDataFlexType = DF_BCD)
88427>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
88430>>>                Case Break
88431>>>            Case (iDataFlexType = DF_BINARY)
88434>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
88437>>>                Case Break
88438>>>            Case (iDataFlexType = DF_DATE)
88441>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
88444>>>                Case Break
88445>>>            Case (iDataFlexType = DF_DATETIME)
88448>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
88451>>>                Case Break
88452>>>            Case (iDataFlexType = DF_TEXT)
88455>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
88458>>>                Case Break
88459>>>            Case Else
88459>>>                Move "" to sRetval
88460>>>        Case End
88460>>>
88460>>>        Function_Return sRetval
88461>>>    End_Function
88462>>>
88462>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
88464>>>        String sDriverID sServer
88464>>>        tColumnType RetvalType
88464>>>        tColumnType RetvalType
88464>>>        Integer iDbType iDriver
88464>>>        Handle hDatabase
88464>>>
88464>>>        Get psDriverID to sDriverID
88465>>>        Get piDbType   to iDbType
88466>>>        Get DriverIndex sDriverID to iDriver
88467>>>        Get psServer to sServer
88468>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
88469>>>        If (hDatabase = 0) Begin
88471>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
88472>>>>
88472>>>            Procedure_Return
88473>>>        End
88473>>>>
88473>>>
88473>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
88476>>>
88476>>>    End_Procedure
88477>>>
88477>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
88479>>>        String sDriverID sServer
88479>>>        tColumnType RetvalType
88479>>>        tColumnType RetvalType
88479>>>        Integer iDbType iDriver
88479>>>        Handle hDatabase
88479>>>
88479>>>        Get psDriverID to sDriverID
88480>>>        Get piDbType   to iDbType
88481>>>        Get DriverIndex sDriverID to iDriver
88482>>>        Get psServer to sServer
88483>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
88484>>>        If (hDatabase = 0) Begin
88486>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
88487>>>>
88487>>>            Procedure_Return
88488>>>        End
88488>>>>
88488>>>
88488>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
88491>>>
88491>>>    End_Procedure
88492>>>
88492>>>    // Returns a struct array with the default column types for the SQL back-end and how they
88492>>>    // are mapped to the standard DataFlex data types.
88492>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
88492>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
88494>>>        tColumnType[] ColumnTypeArray EmptyArray
88494>>>        tColumnType[] ColumnTypeArray EmptyArray
88496>>>        String sDataType
88496>>>        Integer iDataType iDriverID iCount
88496>>>        Boolean bSQLDriver
88496>>>
88496>>>        Move 0 to iCount
88497>>>        Get DriverIndex sDriverID to iDriverID
88498>>>        Get IsSQLDriver sDriverID to bSQLDriver
88499>>>        If (bSQLDriver = False) Begin
88501>>>            Function_Return EmptyArray
88502>>>        End
88502>>>>
88502>>>
88502>>>        // DF_ASCII
88502>>>        If (sDriverID = ODBC_DRV_ID) Begin
88504>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
88507>>>        End
88507>>>>
88507>>>        Else Begin
88508>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
88511>>>        End
88511>>>>
88511>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
88512>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
88513>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
88514>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
88515>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
88516>>>        Increment iCount
88517>>>
88517>>>        // DF_BINARY
88517>>>        If (sDriverID = ODBC_DRV_ID) Begin
88519>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
88522>>>        End
88522>>>>
88522>>>        Else Begin
88523>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
88526>>>        End
88526>>>>
88526>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
88527>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
88528>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
88529>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
88530>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
88531>>>        Increment iCount
88532>>>
88532>>>        // DF_DATE
88532>>>        If (sDriverID = ODBC_DRV_ID) Begin
88534>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
88537>>>        End
88537>>>>
88537>>>        Else Begin
88538>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
88541>>>        End
88541>>>>
88541>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
88542>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
88543>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
88544>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
88545>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
88546>>>        Increment iCount
88547>>>
88547>>>        // DF_DATETIME
88547>>>        If (sDriverID = ODBC_DRV_ID) Begin
88549>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
88552>>>        End
88552>>>>
88552>>>        Else Begin
88553>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
88556>>>        End
88556>>>>
88556>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
88557>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
88558>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
88559>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
88560>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
88561>>>        Increment iCount
88562>>>
88562>>>        // DF_NUMERIC
88562>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
88562>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
88562>>>        // we make them here all "Numeric"...
88562>>>        Case Begin
88562>>>            Case (sDriverID = MSSQLDRV_ID)
88564>>>                Move SQL_NUMERIC to iDataType
88565>>>                Move "numeric"   to sDataType
88566>>>                Case Break
88567>>>            Case (sDriverID = DB2_DRV_ID)
88570>>>                Move SQL_NUMERIC to iDataType
88571>>>                Move "NUMERIC"   to sDataType
88572>>>                Case Break
88573>>>            Case (sDriverID = SQLFLEX)
88576>>>                Move eSQLServer_NUMERIC to iDataType
88577>>>                Move "numeric"   to sDataType
88578>>>                Case Break
88579>>>            Case (sDriverID = MDSMySQL)
88582>>>                Move eMySQL_DECIMAL to iDataType
88583>>>                Move "decimal"   to sDataType
88584>>>                Case Break
88585>>>            Case (sDriverID = ORAFLEX)
88588>>>                Move eOracle_NUMBER to iDataType
88589>>>                Move "NUMBER"   to sDataType
88590>>>                Case Break
88591>>>            Case (sDriverID = MDSPgSQL)
88594>>>                Move ePgSQL_FLOAT4 to iDataType
88595>>>                Move "decimal"   to sDataType
88596>>>                Case Break
88597>>>            Case Else
88597>>>                Move DF_BCD      to iDataType
88598>>>                Move "Numeric"   to sDataType
88599>>>        Case End
88599>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
88600>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
88601>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
88602>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
88603>>>        Increment iCount
88604>>>
88604>>>        // DF_TEXT
88604>>>        If (sDriverID = ODBC_DRV_ID) Begin
88606>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
88609>>>        End
88609>>>>
88609>>>        Else Begin
88610>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
88613>>>        End
88613>>>>
88613>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
88614>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
88615>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
88616>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
88617>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
88618>>>
88618>>>        Function_Return ColumnTypeArray
88619>>>    End_Function
88620>>>
88620>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
88622>>>        tColumnType[] ColumnTypeArray
88622>>>        tColumnType[] ColumnTypeArray
88623>>>        tColumnType   ColumnType
88623>>>        tColumnType   ColumnType
88623>>>        Integer iCount iSize
88623>>>
88623>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
88624>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
88625>>>        Decrement iSize
88626>>>
88626>>>        for iCount from 0 to iSize
88632>>>>
88632>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
88634>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
88635>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
88636>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
88637>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
88638>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
88639>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
88640>>>                Move iSize to iCount
88641>>>            End
88641>>>>
88641>>>        Loop
88642>>>>
88642>>>
88642>>>        Function_Return ColumnType
88643>>>    End_Function
88644>>>
88644>>>    // Returns a struct with the default column types for the SQL back-end and how they
88644>>>    // are mapped to a DUF data type.
88644>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
88646>>>        tColumnType ColumnType
88646>>>        tColumnType ColumnType
88646>>>        String sDataType
88646>>>        Integer iDriverID iCount
88646>>>
88646>>>        Move 0 to iCount
88647>>>        Get DriverIndex sDriverID to iDriverID
88648>>>
88648>>>        Case Begin
88648>>>            // DF_ASCII
88648>>>            Case (iType = DF_ASCII_DUF)
88650>>>                If (sDriverID = ODBC_DRV_ID) Begin
88652>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
88655>>>                End
88655>>>>
88655>>>                Else Begin
88656>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
88659>>>                End
88659>>>>
88659>>>                Move DF_ASCII    to ColumnType.iDataFlexType
88660>>>                Move "ASCII"     to ColumnType.sDataFlexType
88661>>>                Move sDataType   to ColumnType.sSQLType
88662>>>                Move DF_ASCII    to ColumnType.iSQLType
88663>>>                Move False       to ColumnType.bCanEditSize
88664>>>                Case Break
88665>>>
88665>>>            // DF_BINARY
88665>>>            Case (iType = DF_BINARY_DUF)
88668>>>                If (sDriverID = ODBC_DRV_ID) Begin
88670>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
88673>>>                End
88673>>>>
88673>>>                Else Begin
88674>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
88677>>>                End
88677>>>>
88677>>>                Move DF_BINARY   to ColumnType.iDataFlexType
88678>>>                Move "Binary"    to ColumnType.sDataFlexType
88679>>>                Move sDataType   to ColumnType.sSQLType
88680>>>                Move DF_BINARY   to ColumnType.iSQLType
88681>>>                Move False       to ColumnType.bCanEditSize
88682>>>                Case Break
88683>>>
88683>>>            // DF_DATE
88683>>>            Case (iType = DF_DATE_DUF)
88686>>>                If (sDriverID = ODBC_DRV_ID) Begin
88688>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
88691>>>                End
88691>>>>
88691>>>                Else Begin
88692>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
88695>>>                End
88695>>>>
88695>>>                Move DF_DATE     to ColumnType.iDataFlexType
88696>>>                Move "Date"      to ColumnType.sDataFlexType
88697>>>                Move sDataType   to ColumnType.sSQLType
88698>>>                Move DF_DATE     to ColumnType.iSQLType
88699>>>                Move True        to ColumnType.bCanEditSize
88700>>>                Case Break
88701>>>
88701>>>            // DF_DATETIME
88701>>>            Case (iType = DF_DATETIME_DUF)
88704>>>                If (sDriverID = ODBC_DRV_ID) Begin
88706>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
88709>>>                End
88709>>>>
88709>>>                Else Begin
88710>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
88713>>>                End
88713>>>>
88713>>>                Move DF_DATETIME to ColumnType.iDataFlexType
88714>>>                Move "DateTime"  to ColumnType.sDataFlexType
88715>>>                Move sDataType   to ColumnType.sSQLType
88716>>>                Move DF_DATETIME to ColumnType.iSQLType
88717>>>                Move True        to ColumnType.bCanEditSize
88718>>>                Case Break
88719>>>
88719>>>            // DF_NUMERIC
88719>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
88719>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
88719>>>            // we make them here all "Numeric"...
88719>>>            // If (sDriverID = ODBC_DRV_ID) Begin
88719>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
88719>>>            // End
88719>>>            // Else Begin
88719>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
88719>>>            // End
88719>>>            // ToDo: How should we find the best "Numeric" data type here?
88719>>>            Case (iType = DF_BCD_DUF)
88722>>>                Move DF_BCD      to ColumnType.iDataFlexType
88723>>>                Move "Numeric"   to ColumnType.sDataFlexType
88724>>>                Move "Numeric"   to ColumnType.sSQLType
88725>>>                Move SQL_NUMERIC to ColumnType.iSQLType
88726>>>                Move False       to ColumnType.bCanEditSize
88727>>>                Case Break
88728>>>
88728>>>            // DF_TEXT
88728>>>            Case (iType = DF_TEXT_DUF)
88731>>>                If (sDriverID = ODBC_DRV_ID) Begin
88733>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
88736>>>                End
88736>>>>
88736>>>                Else Begin
88737>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
88740>>>                End
88740>>>>
88740>>>                Move DF_TEXT     to ColumnType.iDataFlexType
88741>>>                Move "Text"      to ColumnType.sDataFlexType
88742>>>                Move sDataType   to ColumnType.sSQLType
88743>>>                Move DF_TEXT     to ColumnType.iSQLType
88744>>>                Move False       to ColumnType.bCanEditSize
88745>>>                Case Break
88746>>>
88746>>>            Case Else
88746>>>                Move -1999       to ColumnType.iDataFlexType
88747>>>                Move "Undefined" to ColumnType.sDataFlexType
88748>>>                Move "Undefined" to ColumnType.sSQLType
88749>>>                Move -1999       to ColumnType.iSQLType
88750>>>                Move True        to ColumnType.bCanEditSize
88751>>>
88751>>>        Case End
88751>>>
88751>>>        Function_Return ColumnType
88752>>>    End_Function
88753>>>
88753>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
88755>>>        String sDataPath sDriverID
88755>>>        Boolean bMertechDriver bOK
88755>>>        Integer iPos
88755>>>
88755>>>        If (sTableName contains ".") Begin
88757>>>            Move (Pos(".", sTableName)) to iPos
88758>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
88759>>>        End
88759>>>>
88759>>>
88759>>>        Get psDriverID to sDriverID
88760>>>        Get psDataPathFirstPart to sDataPath
88761>>>        Get IsMertechDriver sDriverID to bMertechDriver
88762>>>        // First delete the cache file:
88762>>>        If (bMertechDriver = False) Begin
88764>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
88765>>>        End
88765>>>>
88765>>>        Else Begin
88766>>>            Get _MertechDeleteTDFile sTableName to bOK
88767>>>        End
88767>>>>
88767>>>
88767>>>        Function_Return bOK
88768>>>    End_Function
88769>>>
88769>>>    // Changes source code files.
88769>>>    // Pass a file name with full path and a value to search for, together with the value
88769>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
88769>>>    // to use a Connection ID.
88769>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
88769>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
88769>>>    // Returns True if no errors occured.
88769>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
88771>>>        Integer iCh iRow iItems iCount
88771>>>        String sValue sRow
88771>>>        String[] sFileArray
88772>>>        Boolean bExists bIsActive
88772>>>
88772>>>        Move False to Err
88773>>>        Move 0 to iRow
88774>>>
88774>>>        If (ghoStatusPanel <> 0) Begin
88776>>>            Get Active_state of ghoStatusPanel to bIsActive
88777>>>        End
88777>>>>
88777>>>
88777>>>        Get vFilePathExists sFileName to bExists
88778>>>        If (bExists = False) Begin
88780>>>            If (bShowResult = True) Begin
88782>>>                If (bIsActive = True) Begin
88784>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
88785>>>                End
88785>>>>
88785>>>                Else Begin
88786>>>                    Showln "File does not exist: " sFileName
88789>>>                End
88789>>>>
88789>>>            End
88789>>>>
88789>>>            Function_Return False
88790>>>        End
88790>>>>
88790>>>
88790>>>        Get Seq_Open_Input_Channel sFileName to iCh
88791>>>        If (iCh < 1) Begin
88793>>>            Function_Return False
88794>>>        End
88794>>>>
88794>>>
88794>>>        If (bShowResult = True) Begin
88796>>>            If (ghoStatusPanel <> 0) Begin
88798>>>                Get Active_state of ghoStatusPanel to bIsActive
88799>>>                If (bIsActive = True) Begin
88801>>>                    Set Message_Text of ghoStatusPanel to sFileName
88802>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
88803>>>                    Send DoAdvance of ghoProgressBar
88804>>>                End
88804>>>>
88804>>>            End
88804>>>>
88804>>>            Else Begin
88805>>>                Showln ""
88807>>>                Showln "sFileName = " sFileName
88810>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
88815>>>            End
88815>>>>
88815>>>        End
88815>>>>
88815>>>
88815>>>        While (not(SeqEof))
88819>>>            Readln channel iCh sRow
88821>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
88823>>>//                If (bShowResult = True) Begin
88823>>>//                    If (bIsActive = True) Begin
88823>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
88823>>>//                    End
88823>>>//                    Else Begin
88823>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
88823>>>//                    End
88823>>>//                End
88823>>>                // Change the whole line to the new connection id:
88823>>>                Move sChangeTo to sRow
88824>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
88824>>>            End
88824>>>>
88824>>>            Move sRow to sFileArray[iRow]
88825>>>            Increment iRow
88826>>>        Loop
88827>>>>
88827>>>        Send Seq_Close_Channel iCh
88828>>>
88828>>>        Sleep 1 // Wait for Windows to close the file
88829>>>
88829>>>        Get Seq_Open_Output_Channel sFileName to iCh
88830>>>        If (iCh < 1) Begin
88832>>>            Function_Return False
88833>>>        End
88833>>>>
88833>>>        Move (SizeOfArray(sFileArray)) to iItems
88834>>>        Decrement iItems
88835>>>
88835>>>        For iCount from 0 to iItems
88841>>>>
88841>>>            Move sFileArray[iCount] to sValue
88842>>>            Writeln channel iCh sValue
88845>>>        Loop
88846>>>>
88846>>>        Send Seq_Close_Channel iCh
88847>>>
88847>>>        Function_Return (Err = False)
88848>>>    End_Function
88849>>>
88849>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
88851>>>        Integer iRetval
88851>>>        Move 1 to iRetval
88852>>>        If (ghoSQLConnectionHandler <> 0) Begin
88854>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
88855>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
88856>>>        End
88856>>>>
88856>>>        Function_Return (iRetval = 0)
88857>>>    End_Function
88858>>>
88858>>>    // *** DEPRECIATED ***
88858>>>    // Use the AutoSetConnectionID function instead.
88858>>>    // This might be needed by API-methods when a connection id is to be used and
88858>>>    // the connection ID hasn't been established with the driver's CLI interface.
88858>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
88858>>>//    Function UtilCreateConnectionID String sConnectionID Returns Boolean
88858>>>//        String sConnectionString sDriverID
88858>>>//        Boolean bOK bSilent bDawDriver
88858>>>//        Handle hoCLI
88858>>>//
88858>>>//        Move False to bOK
88858>>>//        Get psDriverID to sDriverID
88858>>>//        Get IsDAWSQLDriver sDriverID to bDawDriver
88858>>>//        If (bDawDriver = False) Begin
88858>>>//            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
88858>>>//            Function_Return False
88858>>>//        End
88858>>>//
88858>>>//        Get psConnectionString to sConnectionString
88858>>>//        Get pbSilentLogin      to bSilent
88858>>>//
88858>>>//        Get phoCLIHandler to hoCLI
88858>>>//        If (hoCLI <> 0) Begin
88858>>>//            Set psDriverID of hoCLI to sDriverID
88858>>>//            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
88858>>>//        End
88858>>>//
88858>>>//        Function_Return (bOK = False)
88858>>>//    End_Function
88858>>>
88858>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
88858>>>    // and opens it in "notepad.exe".
88858>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
88858>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
88858>>>    Procedure UtilShowErrorList
88860>>>        tSqlErrorArray aSqlErrorArray
88860>>>        tSqlErrorArray aSqlErrorArray
88860>>>        Integer iRows iCount iCh iErrorNum
88860>>>        String sPath sFileName sErrorTxt sStatement
88860>>>
88860>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
88861>>>        Get vFolderFormat sPath to sPath
88862>>>        Move "SQLErrorLog.txt"  to sFileName
88863>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
88864>>>            Get paSqlErrorArray to aSqlErrorArray
88865>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
88866>>>            If (iRows > 0) Begin
88868>>>                Decrement iRows
88869>>>                for iCount from 0 to iRows
88875>>>>
88875>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
88876>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
88877>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
88878>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
88884>>>                    Writeln channel iCh "SQL Statement: " sStatement
88888>>>                Loop
88889>>>>
88889>>>            End
88889>>>>
88889>>>        Send Seq_Close_Channel iCh
88890>>>
88890>>>        If (iRows > 0) Begin
88892>>>            Runprogram Shell Background (sPath + sFileName)
88893>>>        End
88893>>>>
88893>>>    End_Procedure
88894>>>
88894>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
88894>>>    // and the table needs to exist as an SQL table.
88894>>>    Function UtilTableIsSql Handle hTable Returns Boolean
88896>>>        String sRootName sDriverID
88896>>>        Boolean bIsSQL
88896>>>
88896>>>        Move False to bIsSQL
88897>>>        If (hTable > 0) Begin
88899>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
88902>>>            Get UtilTableIsSqlByRootName sRootName to bIsSQL
88903>>>            If (bIsSQL = True) Begin
88905>>>                Get psDriverID to sDriverID
88906>>>                Get _TableNameOnly sRootName to sRootName
88907>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
88908>>>            End
88908>>>>
88908>>>        End
88908>>>>
88908>>>
88908>>>        Function_Return bIsSQL
88909>>>    End_Function
88910>>>
88910>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
88912>>>        Boolean bIsSQL
88912>>>        Move (sRootName contains ":") to bIsSQL
88913>>>        Function_Return bIsSQL
88914>>>    End_Function
88915>>>
88915>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
88915>>>    // that the embedded .dat file exists on disk.
88915>>>    Function UtilTableIsEmbedded Handle hTable Returns Boolean
88917>>>        Boolean bExists bIsEmbedded
88917>>>        String sDataPath sRootName
88917>>>
88917>>>        Get UtilTableNumberIsInUse hTable to bExists
88918>>>        If (bExists = False) Begin
88920>>>            Function_Return False
88921>>>        End
88921>>>>
88921>>>
88921>>>        Move False to bIsEmbedded
88922>>>        If (hTable > 0) Begin
88924>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
88927>>>            Move (not(sRootName contains ":")) to bIsEmbedded
88928>>>        End
88928>>>>
88928>>>        If (bIsEmbedded = True) Begin
88930>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
88931>>>            Get vFolderFormat sDataPath to sDataPath
88932>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
88933>>>        End
88933>>>>
88933>>>
88933>>>        Function_Return bIsEmbedded
88934>>>    End_Function
88935>>>
88935>>>
88935>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
88935>>>    // An Alias file/table is a filelist number that share the same Physical filename
88935>>>    // but the Logical name is different.
88935>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
88935>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
88937>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
88937>>>        Handle hInTable hMasterTable 
88937>>>        Boolean bIsAlias
88937>>>        
88937>>>        Move hTable to hInTable
88938>>>        Move False to bIsAlias
88939>>>        Move 0 to hMasterTable
88940>>>        
88940>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
88943>>>        // Remove any prefix with a driver name.
88943>>>        Get _TableNameOnly sRootName to sRootName     
88944>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
88947>>>        Get _TableNameOnly sLogicalName to sLogicalName     
88948>>>        
88948>>>        // If the table has the same root and logical name it can't be an alias,
88948>>>        // so we can safely return a "False".
88948>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
88950>>>            Function_Return False
88951>>>        End
88951>>>>
88951>>>        
88951>>>        // Now we need to find a master table with the same root name (sRootName above),
88951>>>        // as the passed hTable root name.
88951>>>        // A master table always has the same root and logical name.
88951>>>        Move 0 to hTable
88952>>>        Repeat
88952>>>>
88952>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
88955>>>            If (hTable > 0 and hTable <> 50) Begin
88957>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
88960>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
88961>>>                // If we found another table with the same root and logical name
88961>>>                // we have found a master table.
88961>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
88963>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
88966>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
88967>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
88969>>>                        Move hTable to hMasterTable   
88970>>>                        Move 0 to hTable // To end the loop.
88971>>>                    End
88971>>>>
88971>>>                End
88971>>>>
88971>>>            End
88971>>>>
88971>>>        Until (hTable = 0)
88973>>>        
88973>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
88975>>>            Move True to bIsAlias
88976>>>        End
88976>>>>
88976>>>        
88976>>>        Function_Return bIsAlias
88977>>>    End_Function
88978>>>
88978>>>    // To Open a table with any driver.
88978>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
88978>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
88978>>>    //
88978>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
88978>>>    // The found flag is still used to indicate if the open was successful or not. The function
88978>>>    // returns a True if successful (table could be opened).
88978>>>    //
88978>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
88978>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
88978>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
88978>>>    // set properly we can open the table.
88978>>>    //
88978>>>    // DAW Driver Syntax:
88978>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
88978>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
88978>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
88978>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
88978>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
88978>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
88978>>>    //
88978>>>    // DAW Driver Sample:
88978>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
88978>>>    //
88978>>>    // Mertech Driver Samples:
88978>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
88978>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
88978>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
88978>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
88978>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
88980>>>        String sTableNameOrg
88980>>>        Boolean bOpen bOK
88980>>>        tSQLConnection SQLConnection
88980>>>        tSQLConnection SQLConnection
88980>>>        
88980>>>        Move False to bOpen
88981>>>        Move sTableName to sTableNameOrg
88982>>>        If (hTable > 0) Begin
88984>>>            Send Ignore_Error of Error_Object_Id 20529
88985>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
88986>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
88987>>>            Send Ignore_Error of Error_Object_Id 10
88988>>>            Open hTable Mode iMode
88990>>>            Send Trap_Error of Error_Object_Id 20529
88991>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
88992>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
88993>>>            Send Trap_Error of Error_Object_Id 10
88994>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
88997>>>            If (bOpen = True) Begin
88999>>>                Function_Return True
89000>>>            End
89000>>>>
89000>>>        End
89000>>>>
89000>>>
89000>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
89001>>>        If (hTable > 0) Begin
89003>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
89006>>>        End
89006>>>>
89006>>>
89006>>>        Function_Return bOpen
89007>>>    End_Function
89008>>>
89008>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
89010>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
89010>>>        Boolean bOpen bMertechDriver bOK
89010>>>        tSQLConnection SQLConnection
89010>>>        tSQLConnection SQLConnection
89010>>>
89010>>>        If (hTable < 1) Begin
89012>>>            Function_Return False
89013>>>        End
89013>>>>
89013>>>
89013>>>        Move sTableName to sTableNameOrg
89014>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
89015>>>        Move SQLConnection.sDriverID to sDriverID
89016>>>        Get IsMertechDriver sDriverID to bMertechDriver
89017>>>        Move SQLConnection.sConnectionString to sConnection
89018>>>        Move SQLConnection.sSchema to sSchema
89019>>>        If (sSchema = "") Begin
89021>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
89022>>>        End
89022>>>>
89022>>>
89022>>>        // We need to remove the ".int" part of the table name because
89022>>>        // the table name after the "#" in the connection syntax below wants the
89022>>>        // "bare" table name without any extension.
89022>>>        If (sDriverID <> DATAFLEX_ID) Begin
89024>>>            If (Lowercase(sTableName) contains ".int") Begin
89026>>>                Get ParseFileExtension sTableName to sExt
89027>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
89028>>>            End
89028>>>>
89028>>>            Else Begin
89029>>>                Move sTableName to sTableNameShort
89030>>>                Move (Append(sTableName, ".int")) to sTableName
89031>>>            End
89031>>>>
89031>>>            If (bMertechDriver = False) Begin
89033>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
89034>>>                Move sConnection to sTableName
89035>>>            End
89035>>>>
89035>>>        End
89035>>>>
89035>>>
89035>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
89036>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
89037>>>        If (hTable = 0) Begin
89039>>>            Get NextFreeFilelistSlot to hTable
89040>>>        End
89040>>>>
89040>>>
89040>>>        Case Begin
89040>>>            Case (sDriverID = MSSQLDRV_ID)
89042>>>                // If not df_exclusive mode, we use the "Open As" syntax.
89042>>>                If (iMode <> DF_EXCLUSIVE) Begin
89044>>>                    Close hTable
89045>>>                    Open sTableName as hTable
89047>>>                End
89047>>>>
89047>>>                Else Begin
89048>>>                    Get OpenTableExclusive hTable to bOK
89049>>>                    If (bOK = False) Begin
89051>>>                        Function_Return False
89052>>>                    End
89052>>>>
89052>>>                End
89052>>>>
89052>>>                Case Break
89053>>>
89053>>>            Case (sDriverID = DB2_DRV_ID)
89056>>>                // If not df_exclusive mode, we use the "Open As" syntax.
89056>>>                If (iMode <> DF_EXCLUSIVE) Begin
89058>>>                    Close hTable
89059>>>                    Open sTableName as hTable
89061>>>                End
89061>>>>
89061>>>                Else Begin
89062>>>                    Get OpenTableExclusive hTable to bOK
89063>>>                    If (bOK = False) Begin
89065>>>                        Function_Return False
89066>>>                    End
89066>>>>
89066>>>                End
89066>>>>
89066>>>                Case Break
89067>>>
89067>>>            Case (sDriverID = ODBC_DRV_ID)
89070>>>                // If not df_exclusive mode, we use the "Open As" syntax.
89070>>>                If (iMode = DF_SHARE) Begin
89072>>>                    Close hTable
89073>>>                    Open sTableName as hTable
89075>>>                End
89075>>>>
89075>>>                Else Begin
89076>>>                    Get OpenTableExclusive hTable to bOK
89077>>>                    If (bOK = False) Begin
89079>>>                        Function_Return False
89080>>>                    End
89080>>>>
89080>>>                End
89080>>>>
89080>>>                Case Break
89081>>>
89081>>>            Case (sDriverID = SQLFLEX)
89084>>>                // ToDo: What is the <owner>? Same as Schema?
89084>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
89084>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
89085>>>                // If not df_exclusive mode, we use the "Open As" syntax.
89085>>>                If (iMode <> DF_EXCLUSIVE) Begin
89087>>>                    Close hTable
89088>>>                    Open sTableName as hTable
89090>>>                End
89090>>>>
89090>>>                Else Begin
89091>>>                    Get OpenTableExclusive hTable to bOK
89092>>>                    If (bOK = False) Begin
89094>>>                        Function_Return False
89095>>>                    End
89095>>>>
89095>>>                End
89095>>>>
89095>>>                Case Break
89096>>>
89096>>>            Case (sDriverID = MDSMySQL)
89099>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
89099>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
89100>>>                // If not df_exclusive mode, we use the "Open As" syntax.
89100>>>                If (iMode <> DF_EXCLUSIVE) Begin
89102>>>                    Close hTable
89103>>>                    Open sTableName as hTable
89105>>>                End
89105>>>>
89105>>>                Else Begin
89106>>>                    Get OpenTableExclusive hTable to bOK
89107>>>                    If (bOK = False) Begin
89109>>>                        Function_Return False
89110>>>                    End
89110>>>>
89110>>>                End
89110>>>>
89110>>>                Case Break
89111>>>
89111>>>            Case (sDriverID = MDSPgSQL)
89114>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
89114>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
89115>>>                // If not df_exclusive mode, we use the "Open As" syntax.
89115>>>                If (iMode <> DF_EXCLUSIVE) Begin
89117>>>                    Close hTable
89118>>>                    Open sTableName as hTable
89120>>>                End
89120>>>>
89120>>>                Else Begin
89121>>>                    Get OpenTableExclusive hTable to bOK
89122>>>                    If (bOK = False) Begin
89124>>>                        Function_Return False
89125>>>                    End
89125>>>>
89125>>>                End
89125>>>>
89125>>>                Case Break
89126>>>
89126>>>            Case (sDriverID = ORAFLEX)
89129>>>                // ToDo: What is the <owner>? Same as Schema?
89129>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
89129>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
89130>>>                // If not df_exclusive mode, we use the "Open As" syntax.
89130>>>                If (iMode <> DF_EXCLUSIVE) Begin
89132>>>                    Close hTable
89133>>>                    Open sTableName as hTable
89135>>>                End
89135>>>>
89135>>>                Else Begin
89136>>>                    Get OpenTableExclusive hTable to bOK
89137>>>                    If (bOK = False) Begin
89139>>>                        Function_Return False
89140>>>                    End
89140>>>>
89140>>>                End
89140>>>>
89140>>>                Case Break
89141>>>
89141>>>            Case (sDriverID = DATAFLEX_ID)
89144>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
89146>>>                    Close hTable
89147>>>                    Open sTableName as hTable
89149>>>                End
89149>>>>
89149>>>                Else If (iMode = DF_EXCLUSIVE) Begin
89152>>>                    Get OpenTableExclusive hTable to bOK
89153>>>                    If (bOK = False) Begin
89155>>>                        Function_Return False
89156>>>                    End
89156>>>>
89156>>>                End
89156>>>>
89156>>>                Else Begin
89157>>>                    Open hTable
89159>>>                End
89159>>>>
89159>>>                Case Break
89160>>>
89160>>>            Case Else
89160>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
89161>>>>
89161>>>        Case End
89161>>>
89161>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
89162>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
89163>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
89165>>>            Move False to Found
89166>>>        End
89166>>>>
89166>>>        // If open failed, the Err is set to true,
89166>>>        // but we don't want that because it could end our loop.
89166>>>        Move False to Err
89167>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89170>>>
89170>>>        Function_Return bOpen
89171>>>    End_Function
89172>>>
89172>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
89172>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
89172>>>    // if it is an SQL table
89172>>>    Function UtilTableExists Handle hTable Returns Boolean
89174>>>        Boolean bExists bIsSQLTable
89174>>>        String sDataPath sRootName
89174>>>
89174>>>        Get UtilTableNumberIsInUse hTable to bExists
89175>>>        If (bExists = False) Begin
89177>>>            Function_Return False
89178>>>        End
89178>>>>
89178>>>
89178>>>        Move False to bIsSQLTable
89179>>>        If (hTable > 0) Begin
89181>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89184>>>            Move (sRootName contains ":") to bIsSQLTable
89185>>>        End
89185>>>>
89185>>>        If (bIsSQLTable = True) Begin
89187>>>            Get UtilTableIsSQL hTable to bExists
89188>>>            Function_Return bExists
89189>>>        End
89189>>>>
89189>>>        Else Begin
89190>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
89191>>>            Get vFolderFormat sDataPath to sDataPath
89192>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
89193>>>        End
89193>>>>
89193>>>
89193>>>        Function_Return bExists
89194>>>    End_Function
89195>>>
89195>>>    // Pass a table handle
89195>>>    // Returns True if the table exists in filelist.cfg.
89195>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
89197>>>        Handle hTable
89197>>>        Boolean bFound
89197>>>
89197>>>        Move False to bFound
89198>>>        Move 0 to hTable
89199>>>        Repeat
89199>>>>
89199>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89202>>>            If (hTable > 0) Begin
89204>>>                If (hTable = hCheckTable) Begin
89206>>>                    Move True to bFound
89207>>>                End
89207>>>>
89207>>>            End
89207>>>>
89207>>>            If (bFound = True) ;                Break
89210>>>        Until (hTable = 0)
89212>>>
89212>>>        Function_Return (bFound = True)
89213>>>    End_Function
89214>>>
89214>>>    // Pass a table's logical name
89214>>>    // Returns True if the table exists in filelist.cfg.
89214>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
89216>>>        Handle hTable
89216>>>        Boolean bFound
89216>>>        String sCompareTable
89216>>>
89216>>>        Move False to bFound
89217>>>        Move 0 to hTable
89218>>>        Repeat
89218>>>>
89218>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89221>>>            If (hTable > 0) Begin
89223>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
89226>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
89228>>>                    Move True to bFound
89229>>>                End
89229>>>>
89229>>>            End
89229>>>>
89229>>>            If (bFound = True) ;                Break
89232>>>        Until (hTable = 0)
89234>>>
89234>>>        Function_Return (bFound = True)
89235>>>    End_Function
89236>>>
89236>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
89236>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
89238>>>        Boolean bOK bExists
89238>>>        String sDriverID
89238>>>
89238>>>        Get UtilTableExists hTable to bExists
89239>>>        If (bExists = False) Begin
89241>>>            Function_Return DATAFLEX_ID
89242>>>        End
89242>>>>
89242>>>        Get OpenTableExclusive hTable to bOK
89243>>>        If (bOK = False) Begin
89245>>>            Function_Return DATAFLEX_ID
89246>>>        End
89246>>>>
89246>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89249>>>        Function_Return sDriverID
89250>>>    End_Function
89251>>>
89251>>>    // Number of tables in Filelist.cfg. Returns integger
89251>>>    Function UtilFilelistNoOfTables Returns Integer
89253>>>        Handle hTable
89253>>>        Integer iRetval
89253>>>
89253>>>        Move 0 to hTable
89254>>>        Move 0 to iRetval
89255>>>
89255>>>        Repeat
89255>>>>
89255>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89258>>>            If (hTable > 0) Begin
89260>>>                Increment iRetval
89261>>>            End
89261>>>>
89261>>>        Until (hTable = 0)
89263>>>
89263>>>        Function_Return iRetval
89264>>>    End_Function
89265>>>
89265>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
89265>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
89267>>>        Handle hTable
89267>>>        String sRoot sDriverID
89267>>>        Boolean bIsSQLTable
89267>>>        Integer iPos
89267>>>
89267>>>        Move 0 to hTable
89268>>>        Move "" to sDriverID
89269>>>        Move False to bIsSQLTable
89270>>>
89270>>>        Repeat
89270>>>>
89270>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89273>>>            If (hTable > 0) Begin
89275>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
89278>>>                If (sRoot contains ":") Begin
89280>>>                    Move (Pos(":", sRoot)) to iPos
89281>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
89282>>>                End
89282>>>>
89282>>>                Get IsSQLDriver sDriverID to bIsSQLTable
89283>>>            End
89283>>>>
89283>>>
89283>>>        Until (hTable = 0 or bIsSQLTable = True)
89285>>>
89285>>>        Function_Return sDriverID
89286>>>    End_Function
89287>>>
89287>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
89289>>>        String sRootName
89289>>>        Boolean bIsSQL
89289>>>        Handle hTable
89289>>>
89289>>>        Move False to bIsSQL
89290>>>        Move 0 to hTable
89291>>>        Repeat
89291>>>>
89291>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89294>>>            If (hTable > 0) Begin
89296>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89299>>>                Get UtilTableIsSqlByRootName sRootName to bIsSQL
89300>>>                If (bIsSQL = True) Begin
89302>>>                    Move 0 to hTable
89303>>>                End
89303>>>>
89303>>>            End
89303>>>>
89303>>>        Until (hTable = 0)
89305>>>
89305>>>        Function_Return (bIsSQL = False)
89306>>>    End_Function
89307>>>
89307>>>    // * Dummy function for the Studio's Code Explorer *
89307>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
89309>>>        Function_Return False
89310>>>    End_Function
89311>>>
89311>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
89313>>>        String  sRetval
89313>>>        String[] sOverlapFieldsArray
89314>>>        Integer iType iColumn iColumns
89314>>>        Boolean bOpen bOverlap
89314>>>
89314>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89317>>>        If (bOpen = False) Begin
89319>>>            Open hTable
89321>>>        End
89321>>>>
89321>>>
89321>>>        Move "" to sRetval
89322>>>
89322>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
89325>>>
89325>>>        for iColumn from 0 to iColumns
89331>>>>
89331>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
89334>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
89336>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
89339>>>                If (bOverlap) Begin
89341>>>                    If (sRetval <> "") Begin
89343>>>                        Append sRetval ","
89344>>>                    End
89344>>>>
89344>>>                    Append sRetval iColumn
89345>>>                End
89345>>>>
89345>>>            End
89345>>>>
89345>>>        Loop
89346>>>>
89346>>>
89346>>>        If (bOpen = False) Begin
89348>>>            Close hTable
89349>>>        End
89349>>>>
89349>>>
89349>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
89350>>>
89350>>>        Function_Return sOverlapFieldsArray
89351>>>    End_Function
89352>>>
89352>>>    // Returns a struct array with all data types for the passed driver & dbtype.
89352>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
89354>>>        tColumnType[] ColumnType
89354>>>        tColumnType[] ColumnType
89355>>>
89355>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
89355>>>        // the dbType.
89355>>>        If (sDriverID = ODBC_DRV_ID) Begin
89357>>>            If (iDbType = EN_DbTypeMySQL) Begin
89359>>>                Move MDSMySQL to sDriverID
89360>>>            End
89360>>>>
89360>>>            If (iDbType = EN_DbTypeMSSQL) Begin
89362>>>                Move MSSQLDRV_ID to sDriverID
89363>>>            End
89363>>>>
89363>>>            If (iDbType = EN_DbTypeDB2) Begin
89365>>>                Move DB2_DRV_ID to sDriverID
89366>>>            End
89366>>>>
89366>>>            If (iDbType = EN_DbTypePostgre) Begin
89368>>>                Move MDSPgSQL to sDriverID
89369>>>            End
89369>>>>
89369>>>        End
89369>>>>
89369>>>
89369>>>        Case Begin
89369>>>            Case (iDbType = EN_dbTypeDataFlex)
89371>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
89372>>>                Case Break
89373>>>
89373>>>            Case (iDbType = EN_DbTypeDB2)
89376>>>                Get _UtilEnumerateDB2Types to ColumnType
89377>>>                Case Break
89378>>>
89378>>>            Case (iDbType = EN_DbTypeMSSQL)
89381>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
89382>>>                Case Break
89383>>>
89383>>>            Case (sDriverID = MDSMySQL)
89386>>>                Get _UtilEnumerateMySQLTypes to ColumnType
89387>>>                Case Break
89388>>>
89388>>>            Case (sDriverID = ORAFLEX)
89391>>>                Get _UtilEnumerateOracleTypes to ColumnType
89392>>>                Case Break
89393>>>
89393>>>            Case (sDriverID = MDSPgSQL)
89396>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
89397>>>                Case Break
89398>>>        Case End
89398>>>
89398>>>        Function_Return ColumnType
89399>>>    End_Function
89400>>>
89400>>>    Function UtilEnumerateODBCDrivers Returns String
89402>>>        Handle hoRegistry hoODBCDriverNames
89402>>>        Boolean bExists bKeyOpened
89402>>>        String sKey
89402>>>        String[] sDrivers
89403>>>        Integer iDriverNames iDriverName
89403>>>
89403>>>        Get Create (RefClass (cRegistry)) to hoRegistry
89404>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
89405>>>        Set pfAccessRights of hoRegistry to Key_Read
89406>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
89407>>>        Get KeyExists of hoRegistry sKey to bExists
89408>>>        If (bExists) Begin
89410>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
89411>>>            If (bKeyOpened) Begin
89413>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
89414>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
89415>>>                If (iDriverNames > 0) Begin
89417>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
89418>>>                    Decrement iDriverNames
89419>>>                    for iDriverName from 0 to iDriverNames
89425>>>>
89425>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
89426>>>                    Loop
89427>>>>
89427>>>                End
89427>>>>
89427>>>                Send CloseKey of hoRegistry
89428>>>            End
89428>>>>
89428>>>        End
89428>>>>
89428>>>        Send Destroy of hoRegistry
89429>>>
89429>>>        Function_Return sDrivers
89430>>>    End_Function
89431>>>
89431>>>    // DataFlex Embedded Database Data Types:
89431>>>    // Helper function for UtilEnumerateColumnTypes
89431>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
89433>>>        tColumnType[] ColumnType
89433>>>        tColumnType[] ColumnType
89434>>>        Integer i
89434>>>
89434>>>        Move DF_ASCII           to ColumnType[i].iSQLType
89435>>>        Move "ASCII"            to ColumnType[i].sSQLType
89436>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
89437>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
89438>>>        Move "254"              to ColumnType[i].sPrecision
89439>>>        Increment i
89440>>>
89440>>>        Move DF_BCD             to ColumnType[i].iSQLType
89441>>>        Move "Numeric"          to ColumnType[i].sSQLType
89442>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
89443>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
89444>>>        Move "14.8"             to ColumnType[i].sPrecision
89445>>>        Increment i
89446>>>
89446>>>        Move DF_DATE            to ColumnType[i].iSQLType
89447>>>        Move "Date"             to ColumnType[i].sSQLType
89448>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
89449>>>        Move "Date"             to ColumnType[i].sDataFlexType
89450>>>        Move "6.0"              to ColumnType[i].sPrecision
89451>>>        Move True               to ColumnType[i].bCanEditSize
89452>>>        Increment i
89453>>>
89453>>>        Move DF_TEXT            to ColumnType[i].iSQLType
89454>>>        Move "Text"             to ColumnType[i].sSQLType
89455>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
89456>>>        Move "Text"             to ColumnType[i].sDataFlexType
89457>>>        Move "16384"            to ColumnType[i].sPrecision
89458>>>        Increment i
89459>>>
89459>>>        Move DF_BINARY          to ColumnType[i].iSQLType
89460>>>        Move "Binary"           to ColumnType[i].sSQLType
89461>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
89462>>>        Move "Binary"           to ColumnType[i].sDataFlexType
89463>>>        Move "16384"            to ColumnType[i].sPrecision
89464>>>        Increment i
89465>>>
89465>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
89466>>>        Move "DateTime"         to ColumnType[i].sSQLType
89467>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
89468>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
89469>>>        Move "23"               to ColumnType[i].sPrecision
89470>>>        Move True               to ColumnType[i].bCanEditSize
89471>>>        Increment i
89472>>>
89472>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
89473>>>        Move "Overlap"          to ColumnType[i].sSQLType
89474>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
89475>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
89476>>>        Move "0.0"              to ColumnType[i].sPrecision
89477>>>
89477>>>        Function_Return ColumnType
89478>>>    End_Function
89479>>>
89479>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
89481>>>        tColumnType[] aColumnType
89481>>>        tColumnType[] aColumnType
89482>>>        Integer i
89482>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\DB2_DRV_DriverDef.inc)
89482>>>>// Generated By The Database Update Framework
89482>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
89482>>>>// Driver COLUMN DATA TYPES
89482>>>>//
89482>>>>// Created: 2019-07-18 18:57:13.935
89482>>>>
89482>>>>            Move "bigint"                                to aColumnType[i].sSQLType
89483>>>>            Move -5                                      to aColumnType[i].iSQLType
89484>>>>            Move True                                    to aColumnType[i].bCanEditSize
89485>>>>            Move True                                    to aColumnType[i].bNativeDataType
89486>>>>            Move 14                                      to aColumnType[i].iDefaultSize
89487>>>>            Move 1                                       to aColumnType[i].iMinSize
89488>>>>            Move 14                                      to aColumnType[i].nMaxSize
89489>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89490>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89491>>>>            Move 14                                      to aColumnType[i].sPrecision
89492>>>>            Increment i
89493>>>>
89493>>>>            Move "binary"                                to aColumnType[i].sSQLType
89494>>>>            Move -2                                      to aColumnType[i].iSQLType
89495>>>>            Move True                                    to aColumnType[i].bCanEditSize
89496>>>>            Move True                                    to aColumnType[i].bNativeDataType
89497>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89498>>>>            Move 1                                       to aColumnType[i].iMinSize
89499>>>>            Move 8000                                    to aColumnType[i].nMaxSize
89500>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89501>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89502>>>>            Move 8000                                    to aColumnType[i].sPrecision
89503>>>>            Increment i
89504>>>>
89504>>>>            Move "bit"                                   to aColumnType[i].sSQLType
89505>>>>            Move -7                                      to aColumnType[i].iSQLType
89506>>>>            Move False                                   to aColumnType[i].bCanEditSize
89507>>>>            Move True                                    to aColumnType[i].bNativeDataType
89508>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89509>>>>            Move 0                                       to aColumnType[i].iMinSize
89510>>>>            Move 0                                       to aColumnType[i].nMaxSize
89511>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89512>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89513>>>>            Move 1                                       to aColumnType[i].sPrecision
89514>>>>            Increment i
89515>>>>
89515>>>>            Move "char"                                  to aColumnType[i].sSQLType
89516>>>>            Move 1                                       to aColumnType[i].iSQLType
89517>>>>            Move True                                    to aColumnType[i].bCanEditSize
89518>>>>            Move True                                    to aColumnType[i].bNativeDataType
89519>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89520>>>>            Move 1                                       to aColumnType[i].iMinSize
89521>>>>            Move 8000                                    to aColumnType[i].nMaxSize
89522>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89523>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89524>>>>            Move 8000                                    to aColumnType[i].sPrecision
89525>>>>            Increment i
89526>>>>
89526>>>>            Move "date"                                  to aColumnType[i].sSQLType
89527>>>>            Move 91                                      to aColumnType[i].iSQLType
89528>>>>            Move False                                   to aColumnType[i].bCanEditSize
89529>>>>            Move True                                    to aColumnType[i].bNativeDataType
89530>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89531>>>>            Move 0                                       to aColumnType[i].iMinSize
89532>>>>            Move 0                                       to aColumnType[i].nMaxSize
89533>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89534>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89535>>>>            Move 1                                       to aColumnType[i].sPrecision
89536>>>>            Increment i
89537>>>>
89537>>>>            Move "datetime"                              to aColumnType[i].sSQLType
89538>>>>            Move 93                                      to aColumnType[i].iSQLType
89539>>>>            Move False                                   to aColumnType[i].bCanEditSize
89540>>>>            Move True                                    to aColumnType[i].bNativeDataType
89541>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89542>>>>            Move -1                                      to aColumnType[i].iMinSize
89543>>>>            Move -1                                      to aColumnType[i].nMaxSize
89544>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89545>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89546>>>>            Move 23                                      to aColumnType[i].sPrecision
89547>>>>            Increment i
89548>>>>
89548>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
89549>>>>            Move -200                                    to aColumnType[i].iSQLType
89550>>>>            Move True                                    to aColumnType[i].bCanEditSize
89551>>>>            Move True                                    to aColumnType[i].bNativeDataType
89552>>>>            Move 23                                      to aColumnType[i].iDefaultSize
89553>>>>            Move 23                                      to aColumnType[i].iMinSize
89554>>>>            Move 23                                      to aColumnType[i].nMaxSize
89555>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89556>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89557>>>>            Move 23                                      to aColumnType[i].sPrecision
89558>>>>            Increment i
89559>>>>
89559>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
89560>>>>            Move -155                                    to aColumnType[i].iSQLType
89561>>>>            Move True                                    to aColumnType[i].bCanEditSize
89562>>>>            Move True                                    to aColumnType[i].bNativeDataType
89563>>>>            Move 34                                      to aColumnType[i].iDefaultSize
89564>>>>            Move 34                                      to aColumnType[i].iMinSize
89565>>>>            Move 34                                      to aColumnType[i].nMaxSize
89566>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89567>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89568>>>>            Move 34                                      to aColumnType[i].sPrecision
89569>>>>            Increment i
89570>>>>
89570>>>>            Move "decimal"                               to aColumnType[i].sSQLType
89571>>>>            Move 3                                       to aColumnType[i].iSQLType
89572>>>>            Move True                                    to aColumnType[i].bCanEditSize
89573>>>>            Move True                                    to aColumnType[i].bNativeDataType
89574>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89575>>>>            Move 1                                       to aColumnType[i].iMinSize
89576>>>>            Move 14                                      to aColumnType[i].nMaxSize
89577>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89578>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89579>>>>            Move 14                                      to aColumnType[i].sPrecision
89580>>>>            Increment i
89581>>>>
89581>>>>            Move "float"                                 to aColumnType[i].sSQLType
89582>>>>            Move 6                                       to aColumnType[i].iSQLType
89583>>>>            Move True                                    to aColumnType[i].bCanEditSize
89584>>>>            Move True                                    to aColumnType[i].bNativeDataType
89585>>>>            Move 14                                      to aColumnType[i].iDefaultSize
89586>>>>            Move 1                                       to aColumnType[i].iMinSize
89587>>>>            Move 14                                      to aColumnType[i].nMaxSize
89588>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
89589>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
89590>>>>            Move 14                                      to aColumnType[i].sPrecision
89591>>>>            Increment i
89592>>>>
89592>>>>            Move "image"                                 to aColumnType[i].sSQLType
89593>>>>            Move -4                                      to aColumnType[i].iSQLType
89594>>>>            Move True                                    to aColumnType[i].bCanEditSize
89595>>>>            Move True                                    to aColumnType[i].bNativeDataType
89596>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
89597>>>>            Move 1                                       to aColumnType[i].iMinSize
89598>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
89599>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89600>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89601>>>>            Move 2000000000                              to aColumnType[i].sPrecision
89602>>>>            Increment i
89603>>>>
89603>>>>            Move "int"                                   to aColumnType[i].sSQLType
89604>>>>            Move 4                                       to aColumnType[i].iSQLType
89605>>>>            Move True                                    to aColumnType[i].bCanEditSize
89606>>>>            Move True                                    to aColumnType[i].bNativeDataType
89607>>>>            Move 10                                      to aColumnType[i].iDefaultSize
89608>>>>            Move 1                                       to aColumnType[i].iMinSize
89609>>>>            Move 10                                      to aColumnType[i].nMaxSize
89610>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89611>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89612>>>>            Move 10                                      to aColumnType[i].sPrecision
89613>>>>            Increment i
89614>>>>
89614>>>>            Move "money"                                 to aColumnType[i].sSQLType
89615>>>>            Move -204                                    to aColumnType[i].iSQLType
89616>>>>            Move False                                   to aColumnType[i].bCanEditSize
89617>>>>            Move True                                    to aColumnType[i].bNativeDataType
89618>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89619>>>>            Move 0                                       to aColumnType[i].iMinSize
89620>>>>            Move 0                                       to aColumnType[i].nMaxSize
89621>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89622>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89623>>>>            Move 1                                       to aColumnType[i].sPrecision
89624>>>>            Increment i
89625>>>>
89625>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
89626>>>>            Move -8                                      to aColumnType[i].iSQLType
89627>>>>            Move True                                    to aColumnType[i].bCanEditSize
89628>>>>            Move True                                    to aColumnType[i].bNativeDataType
89629>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89630>>>>            Move 1                                       to aColumnType[i].iMinSize
89631>>>>            Move 4000                                    to aColumnType[i].nMaxSize
89632>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89633>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89634>>>>            Move 4000                                    to aColumnType[i].sPrecision
89635>>>>            Increment i
89636>>>>
89636>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
89637>>>>            Move -10                                     to aColumnType[i].iSQLType
89638>>>>            Move True                                    to aColumnType[i].bCanEditSize
89639>>>>            Move True                                    to aColumnType[i].bNativeDataType
89640>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
89641>>>>            Move 1                                       to aColumnType[i].iMinSize
89642>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
89643>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89644>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89645>>>>            Move 2000000000                              to aColumnType[i].sPrecision
89646>>>>            Increment i
89647>>>>
89647>>>>            Move "numeric"                               to aColumnType[i].sSQLType
89648>>>>            Move 2                                       to aColumnType[i].iSQLType
89649>>>>            Move True                                    to aColumnType[i].bCanEditSize
89650>>>>            Move True                                    to aColumnType[i].bNativeDataType
89651>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89652>>>>            Move 1                                       to aColumnType[i].iMinSize
89653>>>>            Move 14                                      to aColumnType[i].nMaxSize
89654>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
89655>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
89656>>>>            Move 6                                       to aColumnType[i].sPrecision
89657>>>>            Increment i
89658>>>>
89658>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
89659>>>>            Move -9                                      to aColumnType[i].iSQLType
89660>>>>            Move True                                    to aColumnType[i].bCanEditSize
89661>>>>            Move True                                    to aColumnType[i].bNativeDataType
89662>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89663>>>>            Move 1                                       to aColumnType[i].iMinSize
89664>>>>            Move 4000                                    to aColumnType[i].nMaxSize
89665>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89666>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89667>>>>            Move 4000                                    to aColumnType[i].sPrecision
89668>>>>            Increment i
89669>>>>
89669>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
89670>>>>            Move -202                                    to aColumnType[i].iSQLType
89671>>>>            Move True                                    to aColumnType[i].bCanEditSize
89672>>>>            Move True                                    to aColumnType[i].bNativeDataType
89673>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
89674>>>>            Move 1                                       to aColumnType[i].iMinSize
89675>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
89676>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89677>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89678>>>>            Move 2000000000                              to aColumnType[i].sPrecision
89679>>>>            Increment i
89680>>>>
89680>>>>            Move "real"                                  to aColumnType[i].sSQLType
89681>>>>            Move 7                                       to aColumnType[i].iSQLType
89682>>>>            Move True                                    to aColumnType[i].bCanEditSize
89683>>>>            Move True                                    to aColumnType[i].bNativeDataType
89684>>>>            Move 14                                      to aColumnType[i].iDefaultSize
89685>>>>            Move 1                                       to aColumnType[i].iMinSize
89686>>>>            Move 14                                      to aColumnType[i].nMaxSize
89687>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89688>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89689>>>>            Move 14                                      to aColumnType[i].sPrecision
89690>>>>            Increment i
89691>>>>
89691>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
89692>>>>            Move -206                                    to aColumnType[i].iSQLType
89693>>>>            Move False                                   to aColumnType[i].bCanEditSize
89694>>>>            Move True                                    to aColumnType[i].bNativeDataType
89695>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89696>>>>            Move 0                                       to aColumnType[i].iMinSize
89697>>>>            Move 0                                       to aColumnType[i].nMaxSize
89698>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89699>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89700>>>>            Move 1                                       to aColumnType[i].sPrecision
89701>>>>            Increment i
89702>>>>
89702>>>>            Move "smallint"                              to aColumnType[i].sSQLType
89703>>>>            Move 5                                       to aColumnType[i].iSQLType
89704>>>>            Move True                                    to aColumnType[i].bCanEditSize
89705>>>>            Move True                                    to aColumnType[i].bNativeDataType
89706>>>>            Move 5                                       to aColumnType[i].iDefaultSize
89707>>>>            Move 1                                       to aColumnType[i].iMinSize
89708>>>>            Move 5                                       to aColumnType[i].nMaxSize
89709>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89710>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89711>>>>            Move 5                                       to aColumnType[i].sPrecision
89712>>>>            Increment i
89713>>>>
89713>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
89714>>>>            Move -205                                    to aColumnType[i].iSQLType
89715>>>>            Move False                                   to aColumnType[i].bCanEditSize
89716>>>>            Move True                                    to aColumnType[i].bNativeDataType
89717>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89718>>>>            Move 0                                       to aColumnType[i].iMinSize
89719>>>>            Move 0                                       to aColumnType[i].nMaxSize
89720>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89721>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89722>>>>            Move 1                                       to aColumnType[i].sPrecision
89723>>>>            Increment i
89724>>>>
89724>>>>            Move "text"                                  to aColumnType[i].sSQLType
89725>>>>            Move -1                                      to aColumnType[i].iSQLType
89726>>>>            Move True                                    to aColumnType[i].bCanEditSize
89727>>>>            Move True                                    to aColumnType[i].bNativeDataType
89728>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
89729>>>>            Move 1                                       to aColumnType[i].iMinSize
89730>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
89731>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89732>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89733>>>>            Move 2000000000                              to aColumnType[i].sPrecision
89734>>>>            Increment i
89735>>>>
89735>>>>            Move "time"                                  to aColumnType[i].sSQLType
89736>>>>            Move -154                                    to aColumnType[i].iSQLType
89737>>>>            Move True                                    to aColumnType[i].bCanEditSize
89738>>>>            Move True                                    to aColumnType[i].bNativeDataType
89739>>>>            Move 10                                      to aColumnType[i].iDefaultSize
89740>>>>            Move 10                                      to aColumnType[i].iMinSize
89741>>>>            Move 19                                      to aColumnType[i].nMaxSize
89742>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89743>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89744>>>>            Move 19                                      to aColumnType[i].sPrecision
89745>>>>            Increment i
89746>>>>
89746>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
89747>>>>            Move -6                                      to aColumnType[i].iSQLType
89748>>>>            Move True                                    to aColumnType[i].bCanEditSize
89749>>>>            Move True                                    to aColumnType[i].bNativeDataType
89750>>>>            Move 3                                       to aColumnType[i].iDefaultSize
89751>>>>            Move 1                                       to aColumnType[i].iMinSize
89752>>>>            Move 3                                       to aColumnType[i].nMaxSize
89753>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89754>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89755>>>>            Move 3                                       to aColumnType[i].sPrecision
89756>>>>            Increment i
89757>>>>
89757>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
89758>>>>            Move -11                                     to aColumnType[i].iSQLType
89759>>>>            Move False                                   to aColumnType[i].bCanEditSize
89760>>>>            Move True                                    to aColumnType[i].bNativeDataType
89761>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89762>>>>            Move 0                                       to aColumnType[i].iMinSize
89763>>>>            Move 0                                       to aColumnType[i].nMaxSize
89764>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89765>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89766>>>>            Move 1                                       to aColumnType[i].sPrecision
89767>>>>            Increment i
89768>>>>
89768>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
89769>>>>            Move -3                                      to aColumnType[i].iSQLType
89770>>>>            Move True                                    to aColumnType[i].bCanEditSize
89771>>>>            Move True                                    to aColumnType[i].bNativeDataType
89772>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
89773>>>>            Move 1                                       to aColumnType[i].iMinSize
89774>>>>            Move 8000                                    to aColumnType[i].nMaxSize
89775>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89776>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89777>>>>            Move 8000                                    to aColumnType[i].sPrecision
89778>>>>            Increment i
89779>>>>
89779>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
89780>>>>            Move -203                                    to aColumnType[i].iSQLType
89781>>>>            Move True                                    to aColumnType[i].bCanEditSize
89782>>>>            Move True                                    to aColumnType[i].bNativeDataType
89783>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
89784>>>>            Move 1                                       to aColumnType[i].iMinSize
89785>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
89786>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89787>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89788>>>>            Move 2000000000                              to aColumnType[i].sPrecision
89789>>>>            Increment i
89790>>>>
89790>>>>            Move "varchar"                               to aColumnType[i].sSQLType
89791>>>>            Move 12                                      to aColumnType[i].iSQLType
89792>>>>            Move True                                    to aColumnType[i].bCanEditSize
89793>>>>            Move True                                    to aColumnType[i].bNativeDataType
89794>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89795>>>>            Move 1                                       to aColumnType[i].iMinSize
89796>>>>            Move 8000                                    to aColumnType[i].nMaxSize
89797>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89798>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89799>>>>            Move 8000                                    to aColumnType[i].sPrecision
89800>>>>            Increment i
89801>>>>
89801>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
89802>>>>            Move -201                                    to aColumnType[i].iSQLType
89803>>>>            Move True                                    to aColumnType[i].bCanEditSize
89804>>>>            Move True                                    to aColumnType[i].bNativeDataType
89805>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
89806>>>>            Move 1                                       to aColumnType[i].iMinSize
89807>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
89808>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89809>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89810>>>>            Move 2000000000                              to aColumnType[i].sPrecision
89811>>>>            Increment i
89812>>>>
89812>>>>            Move "xml"                                   to aColumnType[i].sSQLType
89813>>>>            Move -152                                    to aColumnType[i].iSQLType
89814>>>>            Move True                                    to aColumnType[i].bCanEditSize
89815>>>>            Move True                                    to aColumnType[i].bNativeDataType
89816>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
89817>>>>            Move 1                                       to aColumnType[i].iMinSize
89818>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
89819>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89820>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89821>>>>            Move 2000000000                              to aColumnType[i].sPrecision
89822>>>>            Increment i
89823>>>>
89823>>>>
89823>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
89823>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
89823>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
89823>>>//        Move "Text"             to ColumnType[i].sDataFlexType
89823>>>//        Move "16384"            to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
89823>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
89823>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
89823>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
89823>>>//        Move "14.0"             to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
89823>>>//        Move "BLOB"             to ColumnType[i].sSQLType
89823>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
89823>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
89823>>>//        Move "16384"            to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
89823>>>//        Move "CHAR"             to ColumnType[i].sSQLType
89823>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
89823>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
89823>>>//        Move "254"              to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        // ToDo: We need to change the sType when using this!
89823>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
89823>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
89823>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
89823>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
89823>>>//        Move "254"                  to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
89823>>>//        Move "DATE"             to ColumnType[i].sSQLType
89823>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
89823>>>//        Move "Date"             to ColumnType[i].sDataFlexType
89823>>>//        Move "6.0"              to ColumnType[i].sPrecision
89823>>>//        Move True               to ColumnType[i].bCanEditSize
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
89823>>>//        Move "CLOB"             to ColumnType[i].sSQLType
89823>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
89823>>>//        Move "Text"             to ColumnType[i].sDataFlexType
89823>>>//        Move "16384"            to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
89823>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
89823>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
89823>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
89823>>>//        Move "14.8"             to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
89823>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
89823>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
89823>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
89823>>>//        Move "14.8"             to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
89823>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
89823>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
89823>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
89823>>>//        Move "14.8"             to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
89823>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
89823>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
89823>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
89823>>>//        Move "255"              to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
89823>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
89823>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
89823>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
89823>>>//        Move "9.0"              to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
89823>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
89823>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
89823>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
89823>>>//        Move "32000"            to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
89823>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
89823>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
89823>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
89823>>>//        Move "32000"            to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
89823>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
89823>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
89823>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
89823>>>//        Move "32000"            to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
89823>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
89823>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
89823>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
89823>>>//        Move "14.8"             to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
89823>>>//        Move "REAL"             to ColumnType[i].sSQLType
89823>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
89823>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
89823>>>//        Move "14.8"             to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
89823>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
89823>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
89823>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
89823>>>//        Move "5.0"              to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
89823>>>//        Move "TIME"             to ColumnType[i].sSQLType
89823>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
89823>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
89823>>>//        Move "19.0"             to ColumnType[i].sPrecision
89823>>>//        Move True               to ColumnType[i].bCanEditSize
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
89823>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
89823>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
89823>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
89823>>>//        Move "23.6"             to ColumnType[i].sPrecision
89823>>>//        Move True               to ColumnType[i].bCanEditSize
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
89823>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
89823>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
89823>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
89823>>>//        Move "16384"            to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        // ToDo: We need to change the sType when using this!
89823>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
89823>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
89823>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
89823>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
89823>>>//        Move "16384"                to ColumnType[i].sPrecision
89823>>>//        Increment i
89823>>>//
89823>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
89823>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
89823>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
89823>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
89823>>>//        Move "16384"            to ColumnType[i].sPrecision
89823>>>//
89823>>>//        Move SQL_XML            to ColumnType[i].iSQLType
89823>>>//        Move "XML"              to ColumnType[i].sSQLType
89823>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
89823>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
89823>>>//        Move "16384"            to ColumnType[i].sPrecision
89823>>>
89823>>>        Function_Return aColumnType
89824>>>    End_Function
89825>>>
89825>>>    // Microsoft SQL Server Database Data Types:
89825>>>    // Helper function for UtilEnumerateColumnTypes
89825>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
89827>>>        tColumnType[] aColumnType
89827>>>        tColumnType[] aColumnType
89828>>>        Integer i
89828>>>
89828>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\MSSQLDRV_DriverDef.inc)
89830>>>>// Generated By The Database Update Framework
89830>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
89830>>>>// Driver COLUMN DATA TYPES
89830>>>>//
89830>>>>// Created: 2019-11-15 21:57:51.001
89830>>>>
89830>>>>            Move "bigint"                                to aColumnType[i].sSQLType
89831>>>>            Move -5                                      to aColumnType[i].iSQLType
89832>>>>            Move True                                    to aColumnType[i].bCanEditSize
89833>>>>            Move True                                    to aColumnType[i].bNativeDataType
89834>>>>            Move 14                                      to aColumnType[i].iDefaultSize
89835>>>>            Move 1                                       to aColumnType[i].iMinSize
89836>>>>            Move 14                                      to aColumnType[i].nMaxSize
89837>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89838>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89839>>>>            Move 14                                      to aColumnType[i].sPrecision
89840>>>>            Increment i
89841>>>>
89841>>>>            Move "binary"                                to aColumnType[i].sSQLType
89842>>>>            Move -2                                      to aColumnType[i].iSQLType
89843>>>>            Move True                                    to aColumnType[i].bCanEditSize
89844>>>>            Move True                                    to aColumnType[i].bNativeDataType
89845>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89846>>>>            Move 1                                       to aColumnType[i].iMinSize
89847>>>>            Move 8000                                    to aColumnType[i].nMaxSize
89848>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
89849>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
89850>>>>            Move 8000                                    to aColumnType[i].sPrecision
89851>>>>            Increment i
89852>>>>
89852>>>>            Move "bit"                                   to aColumnType[i].sSQLType
89853>>>>            Move -7                                      to aColumnType[i].iSQLType
89854>>>>            Move False                                   to aColumnType[i].bCanEditSize
89855>>>>            Move True                                    to aColumnType[i].bNativeDataType
89856>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89857>>>>            Move 0                                       to aColumnType[i].iMinSize
89858>>>>            Move 0                                       to aColumnType[i].nMaxSize
89859>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89860>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89861>>>>            Move 1                                       to aColumnType[i].sPrecision
89862>>>>            Increment i
89863>>>>
89863>>>>            Move "char"                                  to aColumnType[i].sSQLType
89864>>>>            Move 1                                       to aColumnType[i].iSQLType
89865>>>>            Move True                                    to aColumnType[i].bCanEditSize
89866>>>>            Move True                                    to aColumnType[i].bNativeDataType
89867>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89868>>>>            Move 1                                       to aColumnType[i].iMinSize
89869>>>>            Move 8000                                    to aColumnType[i].nMaxSize
89870>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89871>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89872>>>>            Move 8000                                    to aColumnType[i].sPrecision
89873>>>>            Increment i
89874>>>>
89874>>>>            Move "date"                                  to aColumnType[i].sSQLType
89875>>>>            Move 91                                      to aColumnType[i].iSQLType
89876>>>>            Move False                                   to aColumnType[i].bCanEditSize
89877>>>>            Move True                                    to aColumnType[i].bNativeDataType
89878>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89879>>>>            Move 0                                       to aColumnType[i].iMinSize
89880>>>>            Move 0                                       to aColumnType[i].nMaxSize
89881>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
89882>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
89883>>>>            Move 6                                       to aColumnType[i].sPrecision
89884>>>>            Increment i
89885>>>>
89885>>>>            Move "datetime"                              to aColumnType[i].sSQLType
89886>>>>            Move 93                                      to aColumnType[i].iSQLType
89887>>>>            Move False                                   to aColumnType[i].bCanEditSize
89888>>>>            Move True                                    to aColumnType[i].bNativeDataType
89889>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89890>>>>            Move -1                                      to aColumnType[i].iMinSize
89891>>>>            Move -1                                      to aColumnType[i].nMaxSize
89892>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
89893>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
89894>>>>            Move 23                                      to aColumnType[i].sPrecision
89895>>>>            Increment i
89896>>>>
89896>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
89897>>>>            Move -200                                    to aColumnType[i].iSQLType
89898>>>>            Move True                                    to aColumnType[i].bCanEditSize
89899>>>>            Move True                                    to aColumnType[i].bNativeDataType
89900>>>>            Move 23                                      to aColumnType[i].iDefaultSize
89901>>>>            Move 23                                      to aColumnType[i].iMinSize
89902>>>>            Move 23                                      to aColumnType[i].nMaxSize
89903>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
89904>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
89905>>>>            Move 23                                      to aColumnType[i].sPrecision
89906>>>>            Increment i
89907>>>>
89907>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
89908>>>>            Move -155                                    to aColumnType[i].iSQLType
89909>>>>            Move True                                    to aColumnType[i].bCanEditSize
89910>>>>            Move True                                    to aColumnType[i].bNativeDataType
89911>>>>            Move 34                                      to aColumnType[i].iDefaultSize
89912>>>>            Move 34                                      to aColumnType[i].iMinSize
89913>>>>            Move 34                                      to aColumnType[i].nMaxSize
89914>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
89915>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
89916>>>>            Move 34                                      to aColumnType[i].sPrecision
89917>>>>            Increment i
89918>>>>
89918>>>>            Move "decimal"                               to aColumnType[i].sSQLType
89919>>>>            Move 3                                       to aColumnType[i].iSQLType
89920>>>>            Move True                                    to aColumnType[i].bCanEditSize
89921>>>>            Move True                                    to aColumnType[i].bNativeDataType
89922>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89923>>>>            Move 1                                       to aColumnType[i].iMinSize
89924>>>>            Move 14                                      to aColumnType[i].nMaxSize
89925>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89926>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89927>>>>            Move 14                                      to aColumnType[i].sPrecision
89928>>>>            Increment i
89929>>>>
89929>>>>            Move "float"                                 to aColumnType[i].sSQLType
89930>>>>            Move 6                                       to aColumnType[i].iSQLType
89931>>>>            Move True                                    to aColumnType[i].bCanEditSize
89932>>>>            Move True                                    to aColumnType[i].bNativeDataType
89933>>>>            Move 14                                      to aColumnType[i].iDefaultSize
89934>>>>            Move 1                                       to aColumnType[i].iMinSize
89935>>>>            Move 14                                      to aColumnType[i].nMaxSize
89936>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89937>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89938>>>>            Move 14                                      to aColumnType[i].sPrecision
89939>>>>            Increment i
89940>>>>
89940>>>>            Move "image"                                 to aColumnType[i].sSQLType
89941>>>>            Move -4                                      to aColumnType[i].iSQLType
89942>>>>            Move True                                    to aColumnType[i].bCanEditSize
89943>>>>            Move True                                    to aColumnType[i].bNativeDataType
89944>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
89945>>>>            Move 1                                       to aColumnType[i].iMinSize
89946>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
89947>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
89948>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
89949>>>>            Move 2000000000                              to aColumnType[i].sPrecision
89950>>>>            Increment i
89951>>>>
89951>>>>            Move "int"                                   to aColumnType[i].sSQLType
89952>>>>            Move 4                                       to aColumnType[i].iSQLType
89953>>>>            Move True                                    to aColumnType[i].bCanEditSize
89954>>>>            Move True                                    to aColumnType[i].bNativeDataType
89955>>>>            Move 10                                      to aColumnType[i].iDefaultSize
89956>>>>            Move 1                                       to aColumnType[i].iMinSize
89957>>>>            Move 10                                      to aColumnType[i].nMaxSize
89958>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89959>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89960>>>>            Move 10                                      to aColumnType[i].sPrecision
89961>>>>            Increment i
89962>>>>
89962>>>>            Move "money"                                 to aColumnType[i].sSQLType
89963>>>>            Move -204                                    to aColumnType[i].iSQLType
89964>>>>            Move False                                   to aColumnType[i].bCanEditSize
89965>>>>            Move True                                    to aColumnType[i].bNativeDataType
89966>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89967>>>>            Move 0                                       to aColumnType[i].iMinSize
89968>>>>            Move 0                                       to aColumnType[i].nMaxSize
89969>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89970>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89971>>>>            Move 1                                       to aColumnType[i].sPrecision
89972>>>>            Increment i
89973>>>>
89973>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
89974>>>>            Move -8                                      to aColumnType[i].iSQLType
89975>>>>            Move True                                    to aColumnType[i].bCanEditSize
89976>>>>            Move True                                    to aColumnType[i].bNativeDataType
89977>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89978>>>>            Move 1                                       to aColumnType[i].iMinSize
89979>>>>            Move 4000                                    to aColumnType[i].nMaxSize
89980>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89981>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89982>>>>            Move 4000                                    to aColumnType[i].sPrecision
89983>>>>            Increment i
89984>>>>
89984>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
89985>>>>            Move -10                                     to aColumnType[i].iSQLType
89986>>>>            Move True                                    to aColumnType[i].bCanEditSize
89987>>>>            Move True                                    to aColumnType[i].bNativeDataType
89988>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
89989>>>>            Move 1                                       to aColumnType[i].iMinSize
89990>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
89991>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
89992>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
89993>>>>            Move 2000000000                              to aColumnType[i].sPrecision
89994>>>>            Increment i
89995>>>>
89995>>>>            Move "numeric"                               to aColumnType[i].sSQLType
89996>>>>            Move 2                                       to aColumnType[i].iSQLType
89997>>>>            Move True                                    to aColumnType[i].bCanEditSize
89998>>>>            Move True                                    to aColumnType[i].bNativeDataType
89999>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90000>>>>            Move 1                                       to aColumnType[i].iMinSize
90001>>>>            Move 14                                      to aColumnType[i].nMaxSize
90002>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90003>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90004>>>>            Move 14                                      to aColumnType[i].sPrecision
90005>>>>            Increment i
90006>>>>
90006>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
90007>>>>            Move -9                                      to aColumnType[i].iSQLType
90008>>>>            Move True                                    to aColumnType[i].bCanEditSize
90009>>>>            Move True                                    to aColumnType[i].bNativeDataType
90010>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90011>>>>            Move 1                                       to aColumnType[i].iMinSize
90012>>>>            Move 4000                                    to aColumnType[i].nMaxSize
90013>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90014>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90015>>>>            Move 4000                                    to aColumnType[i].sPrecision
90016>>>>            Increment i
90017>>>>
90017>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
90018>>>>            Move -202                                    to aColumnType[i].iSQLType
90019>>>>            Move True                                    to aColumnType[i].bCanEditSize
90020>>>>            Move True                                    to aColumnType[i].bNativeDataType
90021>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
90022>>>>            Move 1                                       to aColumnType[i].iMinSize
90023>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
90024>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90025>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90026>>>>            Move 2000000000                              to aColumnType[i].sPrecision
90027>>>>            Increment i
90028>>>>
90028>>>>            Move "real"                                  to aColumnType[i].sSQLType
90029>>>>            Move 7                                       to aColumnType[i].iSQLType
90030>>>>            Move True                                    to aColumnType[i].bCanEditSize
90031>>>>            Move True                                    to aColumnType[i].bNativeDataType
90032>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90033>>>>            Move 1                                       to aColumnType[i].iMinSize
90034>>>>            Move 14                                      to aColumnType[i].nMaxSize
90035>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90036>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90037>>>>            Move 14                                      to aColumnType[i].sPrecision
90038>>>>            Increment i
90039>>>>
90039>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
90040>>>>            Move -206                                    to aColumnType[i].iSQLType
90041>>>>            Move False                                   to aColumnType[i].bCanEditSize
90042>>>>            Move True                                    to aColumnType[i].bNativeDataType
90043>>>>            Move 0                                       to aColumnType[i].iDefaultSize
90044>>>>            Move 0                                       to aColumnType[i].iMinSize
90045>>>>            Move 0                                       to aColumnType[i].nMaxSize
90046>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
90047>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
90048>>>>            Move 1                                       to aColumnType[i].sPrecision
90049>>>>            Increment i
90050>>>>
90050>>>>            Move "smallint"                              to aColumnType[i].sSQLType
90051>>>>            Move 5                                       to aColumnType[i].iSQLType
90052>>>>            Move True                                    to aColumnType[i].bCanEditSize
90053>>>>            Move True                                    to aColumnType[i].bNativeDataType
90054>>>>            Move 5                                       to aColumnType[i].iDefaultSize
90055>>>>            Move 1                                       to aColumnType[i].iMinSize
90056>>>>            Move 5                                       to aColumnType[i].nMaxSize
90057>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90058>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90059>>>>            Move 5                                       to aColumnType[i].sPrecision
90060>>>>            Increment i
90061>>>>
90061>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
90062>>>>            Move -205                                    to aColumnType[i].iSQLType
90063>>>>            Move False                                   to aColumnType[i].bCanEditSize
90064>>>>            Move True                                    to aColumnType[i].bNativeDataType
90065>>>>            Move 0                                       to aColumnType[i].iDefaultSize
90066>>>>            Move 0                                       to aColumnType[i].iMinSize
90067>>>>            Move 0                                       to aColumnType[i].nMaxSize
90068>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90069>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90070>>>>            Move 1                                       to aColumnType[i].sPrecision
90071>>>>            Increment i
90072>>>>
90072>>>>            Move "text"                                  to aColumnType[i].sSQLType
90073>>>>            Move -1                                      to aColumnType[i].iSQLType
90074>>>>            Move True                                    to aColumnType[i].bCanEditSize
90075>>>>            Move True                                    to aColumnType[i].bNativeDataType
90076>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
90077>>>>            Move 1                                       to aColumnType[i].iMinSize
90078>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
90079>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90080>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90081>>>>            Move 2000000000                              to aColumnType[i].sPrecision
90082>>>>            Increment i
90083>>>>
90083>>>>            Move "time"                                  to aColumnType[i].sSQLType
90084>>>>            Move -154                                    to aColumnType[i].iSQLType
90085>>>>            Move True                                    to aColumnType[i].bCanEditSize
90086>>>>            Move True                                    to aColumnType[i].bNativeDataType
90087>>>>            Move 10                                      to aColumnType[i].iDefaultSize
90088>>>>            Move 10                                      to aColumnType[i].iMinSize
90089>>>>            Move 19                                      to aColumnType[i].nMaxSize
90090>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90091>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90092>>>>            Move 19                                      to aColumnType[i].sPrecision
90093>>>>            Increment i
90094>>>>
90094>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
90095>>>>            Move -6                                      to aColumnType[i].iSQLType
90096>>>>            Move True                                    to aColumnType[i].bCanEditSize
90097>>>>            Move True                                    to aColumnType[i].bNativeDataType
90098>>>>            Move 3                                       to aColumnType[i].iDefaultSize
90099>>>>            Move 1                                       to aColumnType[i].iMinSize
90100>>>>            Move 3                                       to aColumnType[i].nMaxSize
90101>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90102>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90103>>>>            Move 3                                       to aColumnType[i].sPrecision
90104>>>>            Increment i
90105>>>>
90105>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
90106>>>>            Move -11                                     to aColumnType[i].iSQLType
90107>>>>            Move False                                   to aColumnType[i].bCanEditSize
90108>>>>            Move True                                    to aColumnType[i].bNativeDataType
90109>>>>            Move 0                                       to aColumnType[i].iDefaultSize
90110>>>>            Move 0                                       to aColumnType[i].iMinSize
90111>>>>            Move 0                                       to aColumnType[i].nMaxSize
90112>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90113>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90114>>>>            Move 1                                       to aColumnType[i].sPrecision
90115>>>>            Increment i
90116>>>>
90116>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
90117>>>>            Move -3                                      to aColumnType[i].iSQLType
90118>>>>            Move True                                    to aColumnType[i].bCanEditSize
90119>>>>            Move True                                    to aColumnType[i].bNativeDataType
90120>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
90121>>>>            Move 1                                       to aColumnType[i].iMinSize
90122>>>>            Move 8000                                    to aColumnType[i].nMaxSize
90123>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90124>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90125>>>>            Move 8000                                    to aColumnType[i].sPrecision
90126>>>>            Increment i
90127>>>>
90127>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
90128>>>>            Move -203                                    to aColumnType[i].iSQLType
90129>>>>            Move True                                    to aColumnType[i].bCanEditSize
90130>>>>            Move True                                    to aColumnType[i].bNativeDataType
90131>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
90132>>>>            Move 1                                       to aColumnType[i].iMinSize
90133>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
90134>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90135>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90136>>>>            Move 2000000000                              to aColumnType[i].sPrecision
90137>>>>            Increment i
90138>>>>
90138>>>>            Move "varchar"                               to aColumnType[i].sSQLType
90139>>>>            Move 12                                      to aColumnType[i].iSQLType
90140>>>>            Move True                                    to aColumnType[i].bCanEditSize
90141>>>>            Move True                                    to aColumnType[i].bNativeDataType
90142>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90143>>>>            Move 1                                       to aColumnType[i].iMinSize
90144>>>>            Move 8000                                    to aColumnType[i].nMaxSize
90145>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90146>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90147>>>>            Move 8000                                    to aColumnType[i].sPrecision
90148>>>>            Increment i
90149>>>>
90149>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
90150>>>>            Move -201                                    to aColumnType[i].iSQLType
90151>>>>            Move True                                    to aColumnType[i].bCanEditSize
90152>>>>            Move True                                    to aColumnType[i].bNativeDataType
90153>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
90154>>>>            Move 1                                       to aColumnType[i].iMinSize
90155>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
90156>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90157>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90158>>>>            Move 2000000000                              to aColumnType[i].sPrecision
90159>>>>            Increment i
90160>>>>
90160>>>>            Move "xml"                                   to aColumnType[i].sSQLType
90161>>>>            Move -152                                    to aColumnType[i].iSQLType
90162>>>>            Move True                                    to aColumnType[i].bCanEditSize
90163>>>>            Move True                                    to aColumnType[i].bNativeDataType
90164>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
90165>>>>            Move 1                                       to aColumnType[i].iMinSize
90166>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
90167>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90168>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90169>>>>            Move 2000000000                              to aColumnType[i].sPrecision
90170>>>>            Increment i
90171>>>>
90171>>>>
90171>>>
90171>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
90171>>>//            Move "bigint"           to ColumnType[i].sSQLType
90171>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90171>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90171>>>//            Move "14.0"             to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
90171>>>//            Move "binary"           to ColumnType[i].sSQLType
90171>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
90171>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
90171>>>//            Move "8000"             to ColumnType[i].sPrecision
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
90171>>>//            Move "bit"              to ColumnType[i].sSQLType
90171>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
90171>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
90171>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
90171>>>//            Move "char"             to ColumnType[i].sSQLType
90171>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90171>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90171>>>//            Move "8000"             to ColumnType[i].sPrecision
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
90171>>>//            Move "date"             to ColumnType[i].sSQLType
90171>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
90171>>>//            Move "Date"             to ColumnType[i].sDataFlexType
90171>>>//            Move "6.0"              to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
90171>>>//            Move "datetime"         to ColumnType[i].sSQLType
90171>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
90171>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
90171>>>//            Move "23.3"             to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
90171>>>//            Move "datetime2"         to ColumnType[i].sSQLType
90171>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
90171>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
90171>>>//            Move "23.6"              to ColumnType[i].sPrecision
90171>>>//            Move True                to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
90171>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
90171>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
90171>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
90171>>>//            Move "34.0"                 to ColumnType[i].sPrecision
90171>>>//            Move True                   to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
90171>>>//            Move "decimal"          to ColumnType[i].sSQLType
90171>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90171>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90171>>>//            Move "14.8"             to ColumnType[i].sPrecision
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
90171>>>//            Move "float"            to ColumnType[i].sSQLType
90171>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90171>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90171>>>//            Move "14.8"             to ColumnType[i].sPrecision
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
90171>>>//            Move "int"              to ColumnType[i].sSQLType
90171>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90171>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90171>>>//            Move "8.0"              to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
90171>>>//            Move "money"            to ColumnType[i].sSQLType
90171>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90171>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90171>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
90171>>>//            Move "nchar"            to ColumnType[i].sSQLType
90171>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90171>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90171>>>//            Move "4000"             to ColumnType[i].sPrecision
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
90171>>>//            Move "ntext"            to ColumnType[i].sSQLType
90171>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90171>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90171>>>//            Move "16384"            to ColumnType[i].sPrecision
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
90171>>>//            Move "numeric"          to ColumnType[i].sSQLType
90171>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90171>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90171>>>//            Move "14.8"             to ColumnType[i].sPrecision
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
90171>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
90171>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90171>>>//            Move "Text"             to ColumnType[i].sDataFlexType
90171>>>//            Move "4000"             to ColumnType[i].sPrecision
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
90171>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
90171>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90171>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90171>>>//            Move "16384"            to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
90171>>>//            Move "real"             to ColumnType[i].sSQLType
90171>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90171>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
90171>>>//            Move "14.8"             to ColumnType[i].sPrecision
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
90171>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
90171>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
90171>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
90171>>>//            Move "23.0"                 to ColumnType[i].sPrecision
90171>>>//            Move True                   to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
90171>>>//            Move "smallint"         to ColumnType[i].sSQLType
90171>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90171>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
90171>>>//            Move "4.0"              to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
90171>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
90171>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
90171>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
90171>>>//            Move "10.0"              to ColumnType[i].sPrecision
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
90171>>>//            Move "text"             to ColumnType[i].sSQLType
90171>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90171>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90171>>>//            Move "8000"             to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
90171>>>//            Move "time"             to ColumnType[i].sSQLType
90171>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
90171>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
90171>>>//            Move "19.0"             to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
90171>>>//            Move "tinyint"          to ColumnType[i].sSQLType
90171>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90171>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
90171>>>//            Move "2.0"              to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
90171>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
90171>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
90171>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
90171>>>//            Move "36"               to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
90171>>>//            Move "varbinary"        to ColumnType[i].sSQLType
90171>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
90171>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
90171>>>//            Move "16384"            to ColumnType[i].sPrecision
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
90171>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
90171>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
90171>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
90171>>>//            Move "16384"            to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
90171>>>//            Move "varchar"          to ColumnType[i].sSQLType
90171>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
90171>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90171>>>//            Move "8000"             to ColumnType[i].sPrecision
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
90171>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
90171>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90171>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90171>>>//            Move "16384"            to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
90171>>>//            Move "xml"              to ColumnType[i].sSQLType
90171>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90171>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90171>>>//            Move "16384"            to ColumnType[i].sPrecision
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
90171>>>//            Move "DATE"             to ColumnType[i].sSQLType
90171>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
90171>>>//            Move "date"             to ColumnType[i].sDataFlexType
90171>>>//            Move "6.0"              to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
90171>>>//            Move "time"             to ColumnType[i].sSQLType
90171>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
90171>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
90171>>>//            Move "8.7"              to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>//
90171>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
90171>>>//            Move "datetime"         to ColumnType[i].sSQLType
90171>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
90171>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
90171>>>//            Move "23.6"             to ColumnType[i].sPrecision
90171>>>//            Move True               to ColumnType[i].bCanEditSize
90171>>>//            Increment i
90171>>>
90171>>>        End
90171>>>>
90171>>>
90171>>>        // Mertech SQLFlex driver
90171>>>        If (sDriverID = SQLFLEX) Begin
90173>>>
Including file: sql_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\sql_drv_DriverDef.inc)
90173>>>>// Generated By The Database Update Framework
90173>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\sql_drv_DriverDef.xml
90173>>>>// Driver COLUMN DATA TYPES
90173>>>>//
90173>>>>// Created: 2018-03-14 23:47:46.885
90173>>>>
90173>>>>            Move "bigint"                                to aColumnType[i].sSQLType
90174>>>>            Move -5                                      to aColumnType[i].iSQLType
90175>>>>            Move True                                    to aColumnType[i].bCanEditSize
90176>>>>            Move True                                    to aColumnType[i].bNativeDataType
90177>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90178>>>>            Move 1                                       to aColumnType[i].iMinSize
90179>>>>            Move 14                                      to aColumnType[i].nMaxSize
90180>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90181>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90182>>>>            Move 14                                      to aColumnType[i].sPrecision
90183>>>>            Increment i
90184>>>>
90184>>>>            Move "binary"                                to aColumnType[i].sSQLType
90185>>>>            Move -2                                      to aColumnType[i].iSQLType
90186>>>>            Move True                                    to aColumnType[i].bCanEditSize
90187>>>>            Move True                                    to aColumnType[i].bNativeDataType
90188>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90189>>>>            Move 1                                       to aColumnType[i].iMinSize
90190>>>>            Move 8000                                    to aColumnType[i].nMaxSize
90191>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90192>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90193>>>>            Move 8000                                    to aColumnType[i].sPrecision
90194>>>>            Increment i
90195>>>>
90195>>>>            Move "bit"                                   to aColumnType[i].sSQLType
90196>>>>            Move -7                                      to aColumnType[i].iSQLType
90197>>>>            Move False                                   to aColumnType[i].bCanEditSize
90198>>>>            Move True                                    to aColumnType[i].bNativeDataType
90199>>>>            Move 1                                       to aColumnType[i].iDefaultSize
90200>>>>            Move -1                                      to aColumnType[i].iMinSize
90201>>>>            Move -1                                      to aColumnType[i].nMaxSize
90202>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90203>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90204>>>>            Move -1                                      to aColumnType[i].sPrecision
90205>>>>            Increment i
90206>>>>
90206>>>>            Move "char"                                  to aColumnType[i].sSQLType
90207>>>>            Move 1                                       to aColumnType[i].iSQLType
90208>>>>            Move True                                    to aColumnType[i].bCanEditSize
90209>>>>            Move True                                    to aColumnType[i].bNativeDataType
90210>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90211>>>>            Move 1                                       to aColumnType[i].iMinSize
90212>>>>            Move 8000                                    to aColumnType[i].nMaxSize
90213>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90214>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90215>>>>            Move 8000                                    to aColumnType[i].sPrecision
90216>>>>            Increment i
90217>>>>
90217>>>>            Move "date"                                  to aColumnType[i].sSQLType
90218>>>>            Move 40                                      to aColumnType[i].iSQLType
90219>>>>            Move False                                   to aColumnType[i].bCanEditSize
90220>>>>            Move True                                    to aColumnType[i].bNativeDataType
90221>>>>            Move 12                                      to aColumnType[i].iDefaultSize
90222>>>>            Move -1                                      to aColumnType[i].iMinSize
90223>>>>            Move -1                                      to aColumnType[i].nMaxSize
90224>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90225>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90226>>>>            Move -1                                      to aColumnType[i].sPrecision
90227>>>>            Increment i
90228>>>>
90228>>>>            Move "datetime"                              to aColumnType[i].sSQLType
90229>>>>            Move 11                                      to aColumnType[i].iSQLType
90230>>>>            Move True                                    to aColumnType[i].bCanEditSize
90231>>>>            Move True                                    to aColumnType[i].bNativeDataType
90232>>>>            Move 6                                       to aColumnType[i].iDefaultSize
90233>>>>            Move 6                                       to aColumnType[i].iMinSize
90234>>>>            Move 23                                      to aColumnType[i].nMaxSize
90235>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90236>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90237>>>>            Move 23                                      to aColumnType[i].sPrecision
90238>>>>            Increment i
90239>>>>
90239>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
90240>>>>            Move 42                                      to aColumnType[i].iSQLType
90241>>>>            Move True                                    to aColumnType[i].bCanEditSize
90242>>>>            Move True                                    to aColumnType[i].bNativeDataType
90243>>>>            Move 6                                       to aColumnType[i].iDefaultSize
90244>>>>            Move 6                                       to aColumnType[i].iMinSize
90245>>>>            Move 23                                      to aColumnType[i].nMaxSize
90246>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90247>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90248>>>>            Move 23                                      to aColumnType[i].sPrecision
90249>>>>            Increment i
90250>>>>
90250>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
90251>>>>            Move 43                                      to aColumnType[i].iSQLType
90252>>>>            Move True                                    to aColumnType[i].bCanEditSize
90253>>>>            Move True                                    to aColumnType[i].bNativeDataType
90254>>>>            Move 12                                      to aColumnType[i].iDefaultSize
90255>>>>            Move 12                                      to aColumnType[i].iMinSize
90256>>>>            Move 23                                      to aColumnType[i].nMaxSize
90257>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90258>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90259>>>>            Move 23                                      to aColumnType[i].sPrecision
90260>>>>            Increment i
90261>>>>
90261>>>>            Move "decimal"                               to aColumnType[i].sSQLType
90262>>>>            Move 3                                       to aColumnType[i].iSQLType
90263>>>>            Move True                                    to aColumnType[i].bCanEditSize
90264>>>>            Move True                                    to aColumnType[i].bNativeDataType
90265>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90266>>>>            Move 1                                       to aColumnType[i].iMinSize
90267>>>>            Move 14                                      to aColumnType[i].nMaxSize
90268>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90269>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90270>>>>            Move 14                                      to aColumnType[i].sPrecision
90271>>>>            Increment i
90272>>>>
90272>>>>            Move "float"                                 to aColumnType[i].sSQLType
90273>>>>            Move 6                                       to aColumnType[i].iSQLType
90274>>>>            Move True                                    to aColumnType[i].bCanEditSize
90275>>>>            Move True                                    to aColumnType[i].bNativeDataType
90276>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90277>>>>            Move 1                                       to aColumnType[i].iMinSize
90278>>>>            Move 14                                      to aColumnType[i].nMaxSize
90279>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90280>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90281>>>>            Move 14                                      to aColumnType[i].sPrecision
90282>>>>            Increment i
90283>>>>
90283>>>>            Move "geography"                             to aColumnType[i].sSQLType
90284>>>>            Move 130                                     to aColumnType[i].iSQLType
90285>>>>            Move False                                   to aColumnType[i].bCanEditSize
90286>>>>            Move True                                    to aColumnType[i].bNativeDataType
90287>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90288>>>>            Move -1                                      to aColumnType[i].iMinSize
90289>>>>            Move -1                                      to aColumnType[i].nMaxSize
90290>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90291>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90292>>>>            Move -1                                      to aColumnType[i].sPrecision
90293>>>>            Increment i
90294>>>>
90294>>>>            Move "geometry"                              to aColumnType[i].sSQLType
90295>>>>            Move 129                                     to aColumnType[i].iSQLType
90296>>>>            Move False                                   to aColumnType[i].bCanEditSize
90297>>>>            Move True                                    to aColumnType[i].bNativeDataType
90298>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90299>>>>            Move -1                                      to aColumnType[i].iMinSize
90300>>>>            Move -1                                      to aColumnType[i].nMaxSize
90301>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90302>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90303>>>>            Move -1                                      to aColumnType[i].sPrecision
90304>>>>            Increment i
90305>>>>
90305>>>>            Move "hierarchyid"                           to aColumnType[i].sSQLType
90306>>>>            Move 128                                     to aColumnType[i].iSQLType
90307>>>>            Move False                                   to aColumnType[i].bCanEditSize
90308>>>>            Move True                                    to aColumnType[i].bNativeDataType
90309>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90310>>>>            Move -1                                      to aColumnType[i].iMinSize
90311>>>>            Move -1                                      to aColumnType[i].nMaxSize
90312>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90313>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90314>>>>            Move -1                                      to aColumnType[i].sPrecision
90315>>>>            Increment i
90316>>>>
90316>>>>            Move "image"                                 to aColumnType[i].sSQLType
90317>>>>            Move -4                                      to aColumnType[i].iSQLType
90318>>>>            Move True                                    to aColumnType[i].bCanEditSize
90319>>>>            Move True                                    to aColumnType[i].bNativeDataType
90320>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90321>>>>            Move 1                                       to aColumnType[i].iMinSize
90322>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90323>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90324>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90325>>>>            Move 16384                                   to aColumnType[i].sPrecision
90326>>>>            Increment i
90327>>>>
90327>>>>            Move "int"                                   to aColumnType[i].sSQLType
90328>>>>            Move 4                                       to aColumnType[i].iSQLType
90329>>>>            Move True                                    to aColumnType[i].bCanEditSize
90330>>>>            Move True                                    to aColumnType[i].bNativeDataType
90331>>>>            Move 11                                      to aColumnType[i].iDefaultSize
90332>>>>            Move 1                                       to aColumnType[i].iMinSize
90333>>>>            Move 11                                      to aColumnType[i].nMaxSize
90334>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90335>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90336>>>>            Move 11                                      to aColumnType[i].sPrecision
90337>>>>            Increment i
90338>>>>
90338>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
90339>>>>            Move -8                                      to aColumnType[i].iSQLType
90340>>>>            Move True                                    to aColumnType[i].bCanEditSize
90341>>>>            Move True                                    to aColumnType[i].bNativeDataType
90342>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90343>>>>            Move 1                                       to aColumnType[i].iMinSize
90344>>>>            Move 4000                                    to aColumnType[i].nMaxSize
90345>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90346>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90347>>>>            Move 4000                                    to aColumnType[i].sPrecision
90348>>>>            Increment i
90349>>>>
90349>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
90350>>>>            Move -10                                     to aColumnType[i].iSQLType
90351>>>>            Move True                                    to aColumnType[i].bCanEditSize
90352>>>>            Move True                                    to aColumnType[i].bNativeDataType
90353>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90354>>>>            Move 1                                       to aColumnType[i].iMinSize
90355>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90356>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90357>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90358>>>>            Move 16384                                   to aColumnType[i].sPrecision
90359>>>>            Increment i
90360>>>>
90360>>>>            Move "numeric"                               to aColumnType[i].sSQLType
90361>>>>            Move 2                                       to aColumnType[i].iSQLType
90362>>>>            Move True                                    to aColumnType[i].bCanEditSize
90363>>>>            Move True                                    to aColumnType[i].bNativeDataType
90364>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90365>>>>            Move 1                                       to aColumnType[i].iMinSize
90366>>>>            Move 14                                      to aColumnType[i].nMaxSize
90367>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90368>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90369>>>>            Move 14                                      to aColumnType[i].sPrecision
90370>>>>            Increment i
90371>>>>
90371>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
90372>>>>            Move -9                                      to aColumnType[i].iSQLType
90373>>>>            Move True                                    to aColumnType[i].bCanEditSize
90374>>>>            Move True                                    to aColumnType[i].bNativeDataType
90375>>>>            Move 1                                       to aColumnType[i].iDefaultSize
90376>>>>            Move 1                                       to aColumnType[i].iMinSize
90377>>>>            Move 4000                                    to aColumnType[i].nMaxSize
90378>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90379>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90380>>>>            Move 4000                                    to aColumnType[i].sPrecision
90381>>>>            Increment i
90382>>>>
90382>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
90383>>>>            Move -100                                    to aColumnType[i].iSQLType
90384>>>>            Move True                                    to aColumnType[i].bCanEditSize
90385>>>>            Move True                                    to aColumnType[i].bNativeDataType
90386>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90387>>>>            Move 1                                       to aColumnType[i].iMinSize
90388>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90389>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90390>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90391>>>>            Move 16384                                   to aColumnType[i].sPrecision
90392>>>>            Increment i
90393>>>>
90393>>>>            Move "real"                                  to aColumnType[i].sSQLType
90394>>>>            Move 7                                       to aColumnType[i].iSQLType
90395>>>>            Move True                                    to aColumnType[i].bCanEditSize
90396>>>>            Move True                                    to aColumnType[i].bNativeDataType
90397>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90398>>>>            Move 1                                       to aColumnType[i].iMinSize
90399>>>>            Move 14                                      to aColumnType[i].nMaxSize
90400>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90401>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90402>>>>            Move 14                                      to aColumnType[i].sPrecision
90403>>>>            Increment i
90404>>>>
90404>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
90405>>>>            Move 58                                      to aColumnType[i].iSQLType
90406>>>>            Move True                                    to aColumnType[i].bCanEditSize
90407>>>>            Move True                                    to aColumnType[i].bNativeDataType
90408>>>>            Move 12                                      to aColumnType[i].iDefaultSize
90409>>>>            Move 12                                      to aColumnType[i].iMinSize
90410>>>>            Move 23                                      to aColumnType[i].nMaxSize
90411>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90412>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90413>>>>            Move 23                                      to aColumnType[i].sPrecision
90414>>>>            Increment i
90415>>>>
90415>>>>            Move "smallint"                              to aColumnType[i].sSQLType
90416>>>>            Move 5                                       to aColumnType[i].iSQLType
90417>>>>            Move True                                    to aColumnType[i].bCanEditSize
90418>>>>            Move True                                    to aColumnType[i].bNativeDataType
90419>>>>            Move 6                                       to aColumnType[i].iDefaultSize
90420>>>>            Move -1                                      to aColumnType[i].iMinSize
90421>>>>            Move 6                                       to aColumnType[i].nMaxSize
90422>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90423>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90424>>>>            Move 6                                       to aColumnType[i].sPrecision
90425>>>>            Increment i
90426>>>>
90426>>>>            Move "sql_variant"                           to aColumnType[i].sSQLType
90427>>>>            Move -150                                    to aColumnType[i].iSQLType
90428>>>>            Move False                                   to aColumnType[i].bCanEditSize
90429>>>>            Move True                                    to aColumnType[i].bNativeDataType
90430>>>>            Move 8016                                    to aColumnType[i].iDefaultSize
90431>>>>            Move -1                                      to aColumnType[i].iMinSize
90432>>>>            Move -1                                      to aColumnType[i].nMaxSize
90433>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90434>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90435>>>>            Move -1                                      to aColumnType[i].sPrecision
90436>>>>            Increment i
90437>>>>
90437>>>>            Move "text"                                  to aColumnType[i].sSQLType
90438>>>>            Move -1                                      to aColumnType[i].iSQLType
90439>>>>            Move True                                    to aColumnType[i].bCanEditSize
90440>>>>            Move True                                    to aColumnType[i].bNativeDataType
90441>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90442>>>>            Move 1                                       to aColumnType[i].iMinSize
90443>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90444>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90445>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90446>>>>            Move 16384                                   to aColumnType[i].sPrecision
90447>>>>            Increment i
90448>>>>
90448>>>>            Move "time"                                  to aColumnType[i].sSQLType
90449>>>>            Move 41                                      to aColumnType[i].iSQLType
90450>>>>            Move True                                    to aColumnType[i].bCanEditSize
90451>>>>            Move True                                    to aColumnType[i].bNativeDataType
90452>>>>            Move 8                                       to aColumnType[i].iDefaultSize
90453>>>>            Move 8                                       to aColumnType[i].iMinSize
90454>>>>            Move 16                                      to aColumnType[i].nMaxSize
90455>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90456>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90457>>>>            Move 16                                      to aColumnType[i].sPrecision
90458>>>>            Increment i
90459>>>>
90459>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
90460>>>>            Move 93                                      to aColumnType[i].iSQLType
90461>>>>            Move False                                   to aColumnType[i].bCanEditSize
90462>>>>            Move True                                    to aColumnType[i].bNativeDataType
90463>>>>            Move 8                                       to aColumnType[i].iDefaultSize
90464>>>>            Move -1                                      to aColumnType[i].iMinSize
90465>>>>            Move -1                                      to aColumnType[i].nMaxSize
90466>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
90467>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
90468>>>>            Move -1                                      to aColumnType[i].sPrecision
90469>>>>            Increment i
90470>>>>
90470>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
90471>>>>            Move -6                                      to aColumnType[i].iSQLType
90472>>>>            Move True                                    to aColumnType[i].bCanEditSize
90473>>>>            Move True                                    to aColumnType[i].bNativeDataType
90474>>>>            Move 3                                       to aColumnType[i].iDefaultSize
90475>>>>            Move -1                                      to aColumnType[i].iMinSize
90476>>>>            Move 3                                       to aColumnType[i].nMaxSize
90477>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90478>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90479>>>>            Move 3                                       to aColumnType[i].sPrecision
90480>>>>            Increment i
90481>>>>
90481>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
90482>>>>            Move -11                                     to aColumnType[i].iSQLType
90483>>>>            Move False                                   to aColumnType[i].bCanEditSize
90484>>>>            Move True                                    to aColumnType[i].bNativeDataType
90485>>>>            Move 38                                      to aColumnType[i].iDefaultSize
90486>>>>            Move -1                                      to aColumnType[i].iMinSize
90487>>>>            Move -1                                      to aColumnType[i].nMaxSize
90488>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90489>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90490>>>>            Move -1                                      to aColumnType[i].sPrecision
90491>>>>            Increment i
90492>>>>
90492>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
90493>>>>            Move -3                                      to aColumnType[i].iSQLType
90494>>>>            Move True                                    to aColumnType[i].bCanEditSize
90495>>>>            Move True                                    to aColumnType[i].bNativeDataType
90496>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
90497>>>>            Move 1                                       to aColumnType[i].iMinSize
90498>>>>            Move 8000                                    to aColumnType[i].nMaxSize
90499>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90500>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90501>>>>            Move 8000                                    to aColumnType[i].sPrecision
90502>>>>            Increment i
90503>>>>
90503>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
90504>>>>            Move -98                                     to aColumnType[i].iSQLType
90505>>>>            Move True                                    to aColumnType[i].bCanEditSize
90506>>>>            Move True                                    to aColumnType[i].bNativeDataType
90507>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90508>>>>            Move 1                                       to aColumnType[i].iMinSize
90509>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90510>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90511>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90512>>>>            Move 16384                                   to aColumnType[i].sPrecision
90513>>>>            Increment i
90514>>>>
90514>>>>            Move "varchar"                               to aColumnType[i].sSQLType
90515>>>>            Move 12                                      to aColumnType[i].iSQLType
90516>>>>            Move True                                    to aColumnType[i].bCanEditSize
90517>>>>            Move True                                    to aColumnType[i].bNativeDataType
90518>>>>            Move 1                                       to aColumnType[i].iDefaultSize
90519>>>>            Move 1                                       to aColumnType[i].iMinSize
90520>>>>            Move 8000                                    to aColumnType[i].nMaxSize
90521>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90522>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90523>>>>            Move 8000                                    to aColumnType[i].sPrecision
90524>>>>            Increment i
90525>>>>
90525>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
90526>>>>            Move -99                                     to aColumnType[i].iSQLType
90527>>>>            Move True                                    to aColumnType[i].bCanEditSize
90528>>>>            Move True                                    to aColumnType[i].bNativeDataType
90529>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90530>>>>            Move 1                                       to aColumnType[i].iMinSize
90531>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90532>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90533>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90534>>>>            Move 16384                                   to aColumnType[i].sPrecision
90535>>>>            Increment i
90536>>>>
90536>>>>            Move "xml"                                   to aColumnType[i].sSQLType
90537>>>>            Move -370                                    to aColumnType[i].iSQLType
90538>>>>            Move True                                    to aColumnType[i].bCanEditSize
90539>>>>            Move True                                    to aColumnType[i].bNativeDataType
90540>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90541>>>>            Move 1                                       to aColumnType[i].iMinSize
90542>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90543>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90544>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90545>>>>            Move 16384                                   to aColumnType[i].sPrecision
90546>>>>            Increment i
90547>>>>
90547>>>>
90547>>>
90547>>>//            Move eSQLServer_BIGINT  to ColumnType[i].iSQLType
90547>>>//            Move "BigInt"           to ColumnType[i].sSQLType
90547>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90547>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90547>>>//            Move "14.0"             to ColumnType[i].sPrecision
90547>>>//            Move True               to ColumnType[i].bCanEditSize
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_BINARY  to ColumnType[i].iSQLType
90547>>>//            Move "Binary"           to ColumnType[i].sSQLType
90547>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
90547>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
90547>>>//            Move "8000"             to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_BIT     to ColumnType[i].iSQLType
90547>>>//            Move "Bit"              to ColumnType[i].sSQLType
90547>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
90547>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
90547>>>//            Move "1.0"              to ColumnType[i].sPrecision
90547>>>//            Move True               to ColumnType[i].bCanEditSize // In SQL allows 1, 0, or "NULL"
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_CHAR    to ColumnType[i].iSQLType
90547>>>//            Move "Char"             to ColumnType[i].sSQLType
90547>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90547>>>//            Move "Text"             to ColumnType[i].sDataFlexType
90547>>>//            Move "8000"             to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_DATE    to ColumnType[i].iSQLType
90547>>>//            Move "Date"             to ColumnType[i].sSQLType
90547>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
90547>>>//            Move "Date"             to ColumnType[i].sDataFlexType
90547>>>//            Move "6.0"              to ColumnType[i].sPrecision
90547>>>//            Move True               to ColumnType[i].bCanEditSize
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_DATETIME    to ColumnType[i].iSQLType
90547>>>//            Move "DateTime"             to ColumnType[i].sSQLType
90547>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
90547>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
90547>>>//            Move "23.3"                 to ColumnType[i].sPrecision
90547>>>//            Move True                   to ColumnType[i].bCanEditSize
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_DATETIME2   to ColumnType[i].iSQLType
90547>>>//            Move "DateTime2"            to ColumnType[i].sSQLType
90547>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
90547>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
90547>>>//            Move "23.6"                 to ColumnType[i].sPrecision
90547>>>//            Move True                   to ColumnType[i].bCanEditSize
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iSQLType
90547>>>//            Move "DateTimeOffest"           to ColumnType[i].sSQLType
90547>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
90547>>>//            Move "DateTime"                 to ColumnType[i].sDataFlexType
90547>>>//            Move "23.0"                     to ColumnType[i].sPrecision
90547>>>//            Move True                       to ColumnType[i].bCanEditSize
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_DECIMAL to ColumnType[i].iSQLType
90547>>>//            Move "Decimal"          to ColumnType[i].sSQLType
90547>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90547>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90547>>>//            Move "14.8"             to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_DOUBLE  to ColumnType[i].iSQLType
90547>>>//            Move "Double"           to ColumnType[i].sSQLType
90547>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90547>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90547>>>//            Move "14.8"             to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_FLOAT   to ColumnType[i].iSQLType
90547>>>//            Move "Float"            to ColumnType[i].sSQLType
90547>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90547>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90547>>>//            Move "14.8"             to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_INT     to ColumnType[i].iSQLType
90547>>>//            Move "Int"              to ColumnType[i].sSQLType
90547>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90547>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90547>>>//            Move "11.0"             to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_NCHAR   to ColumnType[i].iSQLType
90547>>>//            Move "Nchar"            to ColumnType[i].sSQLType
90547>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90547>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90547>>>//            Move "4000"             to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_NTEXT   to ColumnType[i].iSQLType
90547>>>//            Move "Ntext"            to ColumnType[i].sSQLType
90547>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90547>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90547>>>//            Move "16384"            to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_NUMERIC to ColumnType[i].iSQLType
90547>>>//            Move "Numeric"          to ColumnType[i].sSQLType
90547>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90547>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90547>>>//            Move "14.8"             to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_NVARCHAR    to ColumnType[i].iSQLType
90547>>>//            Move "NvarChar"             to ColumnType[i].sSQLType
90547>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
90547>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
90547>>>//            Move "4000"                 to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_NVARCHARMAX to ColumnType[i].iSQLType
90547>>>//            Move "NvarCharMax"          to ColumnType[i].sSQLType
90547>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
90547>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
90547>>>//            Move "16384"                to ColumnType[i].sPrecision
90547>>>//            Move True                   to ColumnType[i].bCanEditSize
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_REAL    to ColumnType[i].iSQLType
90547>>>//            Move "Real"             to ColumnType[i].sSQLType
90547>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90547>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
90547>>>//            Move "14.8"             to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iSQLType
90547>>>//            Move "SmallDateTime"            to ColumnType[i].sSQLType
90547>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
90547>>>//            Move "DATETIME"                 to ColumnType[i].sDataFlexType
90547>>>//            Move "23.0"                     to ColumnType[i].sPrecision
90547>>>//            Move True                       to ColumnType[i].bCanEditSize
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_SMALLINT    to ColumnType[i].iSQLType
90547>>>//            Move "SmallInt"             to ColumnType[i].sSQLType
90547>>>//            Move DF_BCD                 to ColumnType[i].iDataFlexType
90547>>>//            Move "NUMERIC"              to ColumnType[i].sDataFlexType
90547>>>//            Move "6.0"                  to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_TEXT    to ColumnType[i].iSQLType
90547>>>//            Move "Text"             to ColumnType[i].sSQLType
90547>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90547>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90547>>>//            Move "8000"             to ColumnType[i].sPrecision
90547>>>//            Move True               to ColumnType[i].bCanEditSize
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_TIME    to ColumnType[i].iSQLType
90547>>>//            Move "Time"             to ColumnType[i].sSQLType
90547>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
90547>>>//            Move "Date"             to ColumnType[i].sDataFlexType
90547>>>//            Move "16.0"             to ColumnType[i].sPrecision
90547>>>//            Move True               to ColumnType[i].bCanEditSize
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_TIMESTAMP   to ColumnType[i].iSQLType
90547>>>//            Move "TimeStamp"            to ColumnType[i].sSQLType
90547>>>//            Move DF_ASCII               to ColumnType[i].iDataFlexType
90547>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
90547>>>//            Move "8.0"                  to ColumnType[i].sPrecision
90547>>>//            Move True                   to ColumnType[i].bCanEditSize
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_TINYINT to ColumnType[i].iSQLType
90547>>>//            Move "TinyInt"          to ColumnType[i].sSQLType
90547>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90547>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90547>>>//            Move "3.0"              to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_GUID    to ColumnType[i].iSQLType
90547>>>//            Move "UniqueIdentifier" to ColumnType[i].sSQLType
90547>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
90547>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
90547>>>//            Move "38"               to ColumnType[i].sPrecision
90547>>>//            Move True               to ColumnType[i].bCanEditSize
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_VARBINARY   to ColumnType[i].iSQLType
90547>>>//            Move "VarBinary"            to ColumnType[i].sSQLType
90547>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
90547>>>//            Move "BINARY"               to ColumnType[i].sDataFlexType
90547>>>//            Move "8000"                 to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_VARBINARYMAX to ColumnType[i].iSQLType
90547>>>//            Move "VarBinary(Max)"        to ColumnType[i].sSQLType
90547>>>//            Move DF_BINARY               to ColumnType[i].iDataFlexType
90547>>>//            Move "BINARY"                to ColumnType[i].sDataFlexType
90547>>>//            Move "16384"                 to ColumnType[i].sPrecision
90547>>>//            Move True                    to ColumnType[i].bCanEditSize
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_VARCHAR to ColumnType[i].iSQLType
90547>>>//            Move "VarChar"          to ColumnType[i].sSQLType
90547>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
90547>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90547>>>//            Move "8000"             to ColumnType[i].sPrecision
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_VARCHARMAX  to ColumnType[i].iSQLType
90547>>>//            Move "VarChar(Max)"         to ColumnType[i].sSQLType
90547>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
90547>>>//            Move "TEXT"                 to ColumnType[i].sDataFlexType
90547>>>//            Move "16384"                to ColumnType[i].sPrecision
90547>>>//            Move True                   to ColumnType[i].bCanEditSize
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_SQLVARIANT  to ColumnType[i].iSQLType
90547>>>//            Move "SQL_Variant"          to ColumnType[i].sSQLType
90547>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
90547>>>//            Move "Binary"               to ColumnType[i].sDataFlexType
90547>>>//            Move "8016"                 to ColumnType[i].sPrecision
90547>>>//            Move True                   to ColumnType[i].bCanEditSize
90547>>>//            Increment i
90547>>>//
90547>>>//            Move eSQLServer_XML     to ColumnType[i].iSQLType
90547>>>//            Move "XML"              to ColumnType[i].sSQLType
90547>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90547>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90547>>>//            Move "16384"            to ColumnType[i].sPrecision
90547>>>        End
90547>>>>
90547>>>
90547>>>        Function_Return aColumnType
90548>>>    End_Function
90549>>>
90549>>>    // MySQL Data Types
90549>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
90551>>>        tColumnType[] aColumnType
90551>>>        tColumnType[] aColumnType
90552>>>        Integer i
90552>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\mdsmysql_DriverDef.inc)
90552>>>>// Generated By The Database Update Framework
90552>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
90552>>>>// Driver COLUMN DATA TYPES
90552>>>>//
90552>>>>// Created: 2018-03-14 23:46:49.593
90552>>>>
90552>>>>            Move "bigint"                                to aColumnType[i].sSQLType
90553>>>>            Move 8                                       to aColumnType[i].iSQLType
90554>>>>            Move True                                    to aColumnType[i].bCanEditSize
90555>>>>            Move True                                    to aColumnType[i].bNativeDataType
90556>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90557>>>>            Move 1                                       to aColumnType[i].iMinSize
90558>>>>            Move 14                                      to aColumnType[i].nMaxSize
90559>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90560>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90561>>>>            Move 14                                      to aColumnType[i].sPrecision
90562>>>>            Increment i
90563>>>>
90563>>>>            Move "bit"                                   to aColumnType[i].sSQLType
90564>>>>            Move 16                                      to aColumnType[i].iSQLType
90565>>>>            Move True                                    to aColumnType[i].bCanEditSize
90566>>>>            Move True                                    to aColumnType[i].bNativeDataType
90567>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90568>>>>            Move -1                                      to aColumnType[i].iMinSize
90569>>>>            Move 64                                      to aColumnType[i].nMaxSize
90570>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90571>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90572>>>>            Move 64                                      to aColumnType[i].sPrecision
90573>>>>            Increment i
90574>>>>
90574>>>>            Move "blob"                                  to aColumnType[i].sSQLType
90575>>>>            Move 252                                     to aColumnType[i].iSQLType
90576>>>>            Move True                                    to aColumnType[i].bCanEditSize
90577>>>>            Move True                                    to aColumnType[i].bNativeDataType
90578>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90579>>>>            Move 1                                       to aColumnType[i].iMinSize
90580>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90581>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90582>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90583>>>>            Move 16384                                   to aColumnType[i].sPrecision
90584>>>>            Increment i
90585>>>>
90585>>>>            Move "char"                                  to aColumnType[i].sSQLType
90586>>>>            Move 254                                     to aColumnType[i].iSQLType
90587>>>>            Move True                                    to aColumnType[i].bCanEditSize
90588>>>>            Move True                                    to aColumnType[i].bNativeDataType
90589>>>>            Move 1                                       to aColumnType[i].iDefaultSize
90590>>>>            Move 1                                       to aColumnType[i].iMinSize
90591>>>>            Move 255                                     to aColumnType[i].nMaxSize
90592>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90593>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90594>>>>            Move 255                                     to aColumnType[i].sPrecision
90595>>>>            Increment i
90596>>>>
90596>>>>            Move "date"                                  to aColumnType[i].sSQLType
90597>>>>            Move 10                                      to aColumnType[i].iSQLType
90598>>>>            Move False                                   to aColumnType[i].bCanEditSize
90599>>>>            Move True                                    to aColumnType[i].bNativeDataType
90600>>>>            Move 6                                       to aColumnType[i].iDefaultSize
90601>>>>            Move -1                                      to aColumnType[i].iMinSize
90602>>>>            Move -1                                      to aColumnType[i].nMaxSize
90603>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
90604>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
90605>>>>            Move 6                                       to aColumnType[i].sPrecision
90606>>>>            Increment i
90607>>>>
90607>>>>            Move "datetime"                              to aColumnType[i].sSQLType
90608>>>>            Move 12                                      to aColumnType[i].iSQLType
90609>>>>            Move True                                    to aColumnType[i].bCanEditSize
90610>>>>            Move True                                    to aColumnType[i].bNativeDataType
90611>>>>            Move 23                                      to aColumnType[i].iDefaultSize
90612>>>>            Move 6                                       to aColumnType[i].iMinSize
90613>>>>            Move 23                                      to aColumnType[i].nMaxSize
90614>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
90615>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
90616>>>>            Move 23                                      to aColumnType[i].sPrecision
90617>>>>            Increment i
90618>>>>
90618>>>>            Move "decimal"                               to aColumnType[i].sSQLType
90619>>>>            Move 246                                     to aColumnType[i].iSQLType
90620>>>>            Move True                                    to aColumnType[i].bCanEditSize
90621>>>>            Move True                                    to aColumnType[i].bNativeDataType
90622>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90623>>>>            Move -1                                      to aColumnType[i].iMinSize
90624>>>>            Move 14                                      to aColumnType[i].nMaxSize
90625>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90626>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90627>>>>            Move 14                                      to aColumnType[i].sPrecision
90628>>>>            Increment i
90629>>>>
90629>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
90630>>>>            Move 0                                       to aColumnType[i].iSQLType
90631>>>>            Move True                                    to aColumnType[i].bCanEditSize
90632>>>>            Move True                                    to aColumnType[i].bNativeDataType
90633>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90634>>>>            Move -1                                      to aColumnType[i].iMinSize
90635>>>>            Move 14                                      to aColumnType[i].nMaxSize
90636>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90637>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90638>>>>            Move 14                                      to aColumnType[i].sPrecision
90639>>>>            Increment i
90640>>>>
90640>>>>            Move "double"                                to aColumnType[i].sSQLType
90641>>>>            Move 5                                       to aColumnType[i].iSQLType
90642>>>>            Move True                                    to aColumnType[i].bCanEditSize
90643>>>>            Move True                                    to aColumnType[i].bNativeDataType
90644>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90645>>>>            Move -1                                      to aColumnType[i].iMinSize
90646>>>>            Move 14                                      to aColumnType[i].nMaxSize
90647>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90648>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90649>>>>            Move 14                                      to aColumnType[i].sPrecision
90650>>>>            Increment i
90651>>>>
90651>>>>            Move "enum"                                  to aColumnType[i].sSQLType
90652>>>>            Move 247                                     to aColumnType[i].iSQLType
90653>>>>            Move True                                    to aColumnType[i].bCanEditSize
90654>>>>            Move True                                    to aColumnType[i].bNativeDataType
90655>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90656>>>>            Move -1                                      to aColumnType[i].iMinSize
90657>>>>            Move 255                                     to aColumnType[i].nMaxSize
90658>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90659>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90660>>>>            Move 255                                     to aColumnType[i].sPrecision
90661>>>>            Increment i
90662>>>>
90662>>>>            Move "float"                                 to aColumnType[i].sSQLType
90663>>>>            Move 4                                       to aColumnType[i].iSQLType
90664>>>>            Move True                                    to aColumnType[i].bCanEditSize
90665>>>>            Move True                                    to aColumnType[i].bNativeDataType
90666>>>>            Move 4                                       to aColumnType[i].iDefaultSize
90667>>>>            Move -1                                      to aColumnType[i].iMinSize
90668>>>>            Move 14                                      to aColumnType[i].nMaxSize
90669>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90670>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90671>>>>            Move 14                                      to aColumnType[i].sPrecision
90672>>>>            Increment i
90673>>>>
90673>>>>            Move "int"                                   to aColumnType[i].sSQLType
90674>>>>            Move 3                                       to aColumnType[i].iSQLType
90675>>>>            Move True                                    to aColumnType[i].bCanEditSize
90676>>>>            Move True                                    to aColumnType[i].bNativeDataType
90677>>>>            Move 10                                      to aColumnType[i].iDefaultSize
90678>>>>            Move -1                                      to aColumnType[i].iMinSize
90679>>>>            Move 11                                      to aColumnType[i].nMaxSize
90680>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90681>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90682>>>>            Move 11                                      to aColumnType[i].sPrecision
90683>>>>            Increment i
90684>>>>
90684>>>>            Move "longblob"                              to aColumnType[i].sSQLType
90685>>>>            Move 251                                     to aColumnType[i].iSQLType
90686>>>>            Move True                                    to aColumnType[i].bCanEditSize
90687>>>>            Move True                                    to aColumnType[i].bNativeDataType
90688>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90689>>>>            Move 1                                       to aColumnType[i].iMinSize
90690>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90691>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90692>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90693>>>>            Move 16384                                   to aColumnType[i].sPrecision
90694>>>>            Increment i
90695>>>>
90695>>>>            Move "longtext"                              to aColumnType[i].sSQLType
90696>>>>            Move -251                                    to aColumnType[i].iSQLType
90697>>>>            Move True                                    to aColumnType[i].bCanEditSize
90698>>>>            Move True                                    to aColumnType[i].bNativeDataType
90699>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90700>>>>            Move 1                                       to aColumnType[i].iMinSize
90701>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90702>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90703>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90704>>>>            Move 16384                                   to aColumnType[i].sPrecision
90705>>>>            Increment i
90706>>>>
90706>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
90707>>>>            Move 250                                     to aColumnType[i].iSQLType
90708>>>>            Move True                                    to aColumnType[i].bCanEditSize
90709>>>>            Move True                                    to aColumnType[i].bNativeDataType
90710>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90711>>>>            Move 1                                       to aColumnType[i].iMinSize
90712>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90713>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90714>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90715>>>>            Move 16384                                   to aColumnType[i].sPrecision
90716>>>>            Increment i
90717>>>>
90717>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
90718>>>>            Move 9                                       to aColumnType[i].iSQLType
90719>>>>            Move True                                    to aColumnType[i].bCanEditSize
90720>>>>            Move True                                    to aColumnType[i].bNativeDataType
90721>>>>            Move 8                                       to aColumnType[i].iDefaultSize
90722>>>>            Move 1                                       to aColumnType[i].iMinSize
90723>>>>            Move 9                                       to aColumnType[i].nMaxSize
90724>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90725>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90726>>>>            Move 9                                       to aColumnType[i].sPrecision
90727>>>>            Increment i
90728>>>>
90728>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
90729>>>>            Move -250                                    to aColumnType[i].iSQLType
90730>>>>            Move True                                    to aColumnType[i].bCanEditSize
90731>>>>            Move True                                    to aColumnType[i].bNativeDataType
90732>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90733>>>>            Move 1                                       to aColumnType[i].iMinSize
90734>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90735>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90736>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90737>>>>            Move 16384                                   to aColumnType[i].sPrecision
90738>>>>            Increment i
90739>>>>
90739>>>>            Move "set"                                   to aColumnType[i].sSQLType
90740>>>>            Move 248                                     to aColumnType[i].iSQLType
90741>>>>            Move True                                    to aColumnType[i].bCanEditSize
90742>>>>            Move True                                    to aColumnType[i].bNativeDataType
90743>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90744>>>>            Move -1                                      to aColumnType[i].iMinSize
90745>>>>            Move 255                                     to aColumnType[i].nMaxSize
90746>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90747>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90748>>>>            Move 255                                     to aColumnType[i].sPrecision
90749>>>>            Increment i
90750>>>>
90750>>>>            Move "smallint"                              to aColumnType[i].sSQLType
90751>>>>            Move 2                                       to aColumnType[i].iSQLType
90752>>>>            Move True                                    to aColumnType[i].bCanEditSize
90753>>>>            Move True                                    to aColumnType[i].bNativeDataType
90754>>>>            Move 5                                       to aColumnType[i].iDefaultSize
90755>>>>            Move 1                                       to aColumnType[i].iMinSize
90756>>>>            Move 6                                       to aColumnType[i].nMaxSize
90757>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90758>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90759>>>>            Move 6                                       to aColumnType[i].sPrecision
90760>>>>            Increment i
90761>>>>
90761>>>>            Move "text"                                  to aColumnType[i].sSQLType
90762>>>>            Move -252                                    to aColumnType[i].iSQLType
90763>>>>            Move True                                    to aColumnType[i].bCanEditSize
90764>>>>            Move True                                    to aColumnType[i].bNativeDataType
90765>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90766>>>>            Move 1                                       to aColumnType[i].iMinSize
90767>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90768>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90769>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90770>>>>            Move 16384                                   to aColumnType[i].sPrecision
90771>>>>            Increment i
90772>>>>
90772>>>>            Move "time"                                  to aColumnType[i].sSQLType
90773>>>>            Move 11                                      to aColumnType[i].iSQLType
90774>>>>            Move False                                   to aColumnType[i].bCanEditSize
90775>>>>            Move True                                    to aColumnType[i].bNativeDataType
90776>>>>            Move 10                                      to aColumnType[i].iDefaultSize
90777>>>>            Move -1                                      to aColumnType[i].iMinSize
90778>>>>            Move -1                                      to aColumnType[i].nMaxSize
90779>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90780>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90781>>>>            Move -1                                      to aColumnType[i].sPrecision
90782>>>>            Increment i
90783>>>>
90783>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
90784>>>>            Move 7                                       to aColumnType[i].iSQLType
90785>>>>            Move True                                    to aColumnType[i].bCanEditSize
90786>>>>            Move True                                    to aColumnType[i].bNativeDataType
90787>>>>            Move 6                                       to aColumnType[i].iDefaultSize
90788>>>>            Move 6                                       to aColumnType[i].iMinSize
90789>>>>            Move 23                                      to aColumnType[i].nMaxSize
90790>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
90791>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
90792>>>>            Move 23                                      to aColumnType[i].sPrecision
90793>>>>            Increment i
90794>>>>
90794>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
90795>>>>            Move 249                                     to aColumnType[i].iSQLType
90796>>>>            Move True                                    to aColumnType[i].bCanEditSize
90797>>>>            Move True                                    to aColumnType[i].bNativeDataType
90798>>>>            Move 255                                     to aColumnType[i].iDefaultSize
90799>>>>            Move 1                                       to aColumnType[i].iMinSize
90800>>>>            Move 255                                     to aColumnType[i].nMaxSize
90801>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90802>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90803>>>>            Move 255                                     to aColumnType[i].sPrecision
90804>>>>            Increment i
90805>>>>
90805>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
90806>>>>            Move 1                                       to aColumnType[i].iSQLType
90807>>>>            Move True                                    to aColumnType[i].bCanEditSize
90808>>>>            Move True                                    to aColumnType[i].bNativeDataType
90809>>>>            Move 4                                       to aColumnType[i].iDefaultSize
90810>>>>            Move 1                                       to aColumnType[i].iMinSize
90811>>>>            Move 4                                       to aColumnType[i].nMaxSize
90812>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90813>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90814>>>>            Move 4                                       to aColumnType[i].sPrecision
90815>>>>            Increment i
90816>>>>
90816>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
90817>>>>            Move -249                                    to aColumnType[i].iSQLType
90818>>>>            Move True                                    to aColumnType[i].bCanEditSize
90819>>>>            Move True                                    to aColumnType[i].bNativeDataType
90820>>>>            Move 255                                     to aColumnType[i].iDefaultSize
90821>>>>            Move 1                                       to aColumnType[i].iMinSize
90822>>>>            Move 255                                     to aColumnType[i].nMaxSize
90823>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90824>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90825>>>>            Move 255                                     to aColumnType[i].sPrecision
90826>>>>            Increment i
90827>>>>
90827>>>>            Move "varchar"                               to aColumnType[i].sSQLType
90828>>>>            Move 253                                     to aColumnType[i].iSQLType
90829>>>>            Move True                                    to aColumnType[i].bCanEditSize
90830>>>>            Move True                                    to aColumnType[i].bNativeDataType
90831>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90832>>>>            Move -1                                      to aColumnType[i].iMinSize
90833>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90834>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90835>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90836>>>>            Move 16384                                   to aColumnType[i].sPrecision
90837>>>>            Increment i
90838>>>>
90838>>>>            Move "year"                                  to aColumnType[i].sSQLType
90839>>>>            Move 13                                      to aColumnType[i].iSQLType
90840>>>>            Move False                                   to aColumnType[i].bCanEditSize
90841>>>>            Move True                                    to aColumnType[i].bNativeDataType
90842>>>>            Move 4                                       to aColumnType[i].iDefaultSize
90843>>>>            Move -1                                      to aColumnType[i].iMinSize
90844>>>>            Move -1                                      to aColumnType[i].nMaxSize
90845>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90846>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90847>>>>            Move -1                                      to aColumnType[i].sPrecision
90848>>>>            Increment i
90849>>>>
90849>>>>
90849>>>
90849>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
90849>>>//        Move "bigint"           to ColumnType[i].sSQLType
90849>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90849>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
90849>>>//        Move "14.0"             to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
90849>>>//        Move "bit"              to ColumnType[i].sSQLType
90849>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
90849>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
90849>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
90849>>>//        Move True               to ColumnType[i].bCanEditSize
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
90849>>>//        Move "blob"             to ColumnType[i].sSQLType
90849>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
90849>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
90849>>>//        Move "16384"            to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
90849>>>//        Move "char"             to ColumnType[i].sSQLType
90849>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
90849>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
90849>>>//        Move "254"              to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
90849>>>//        Move "date"             to ColumnType[i].sSQLType
90849>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
90849>>>//        Move "Date"             to ColumnType[i].sDataFlexType
90849>>>//        Move "6.0"              to ColumnType[i].sPrecision
90849>>>//        Move True               to ColumnType[i].bCanEditSize
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
90849>>>//        Move "datetime"         to ColumnType[i].sSQLType
90849>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
90849>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
90849>>>//        Move "23.0"             to ColumnType[i].sPrecision
90849>>>//        Move True               to ColumnType[i].bCanEditSize
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
90849>>>//        Move "decimal"          to ColumnType[i].sSQLType
90849>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90849>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
90849>>>//        Move "14.8"             to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
90849>>>//        Move "double"           to ColumnType[i].sSQLType
90849>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90849>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
90849>>>//        Move "14.8"             to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
90849>>>//        Move "enum"             to ColumnType[i].sSQLType
90849>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
90849>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
90849>>>//        Move "254"              to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
90849>>>//        Move "float"            to ColumnType[i].sSQLType
90849>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90849>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
90849>>>//        Move "14.8"             to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
90849>>>//        Move "int"              to ColumnType[i].sSQLType
90849>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90849>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
90849>>>//        Move "11.0"             to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
90849>>>//        Move "longblob"         to ColumnType[i].sSQLType
90849>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
90849>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
90849>>>//        Move "16384"            to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
90849>>>//        Move "longtext"         to ColumnType[i].sSQLType
90849>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
90849>>>//        Move "Text"             to ColumnType[i].sDataFlexType
90849>>>//        Move "16384"            to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
90849>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
90849>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
90849>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
90849>>>//        Move "16384"            to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
90849>>>//        Move "mediumint"        to ColumnType[i].sSQLType
90849>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90849>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
90849>>>//        Move "9.0"              to ColumnType[i].sPrecision
90849>>>//
90849>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
90849>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
90849>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
90849>>>//        Move "Text"             to ColumnType[i].sDataFlexType
90849>>>//        Move "16384"            to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
90849>>>//        Move "set"              to ColumnType[i].sSQLType
90849>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
90849>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
90849>>>//        Move "254"              to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
90849>>>//        Move "smallint"         to ColumnType[i].sSQLType
90849>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90849>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
90849>>>//        Move "6.0"              to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
90849>>>//        Move "text"             to ColumnType[i].sSQLType
90849>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
90849>>>//        Move "Text"             to ColumnType[i].sDataFlexType
90849>>>//        Move "16384"            to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
90849>>>//        Move "time"             to ColumnType[i].sSQLType
90849>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
90849>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
90849>>>//        Move "10.0"             to ColumnType[i].sPrecision
90849>>>//        Move True               to ColumnType[i].bCanEditSize
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
90849>>>//        Move "timestamp"        to ColumnType[i].sSQLType
90849>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
90849>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
90849>>>//        Move "23.0"             to ColumnType[i].sPrecision
90849>>>//        Move True               to ColumnType[i].bCanEditSize
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
90849>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
90849>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
90849>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
90849>>>//        Move "254"              to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
90849>>>//        Move "tinyint"          to ColumnType[i].sSQLType
90849>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90849>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
90849>>>//        Move "4.0"              to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
90849>>>//        Move "tinytext"         to ColumnType[i].sSQLType
90849>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
90849>>>//        Move "Text"             to ColumnType[i].sDataFlexType
90849>>>//        Move "254"              to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
90849>>>//        Move "varchar"          to ColumnType[i].sSQLType
90849>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
90849>>>//        Move "Text"             to ColumnType[i].sDataFlexType
90849>>>//        Move "16384"            to ColumnType[i].sPrecision
90849>>>//        Increment i
90849>>>//
90849>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
90849>>>//        Move "year"             to ColumnType[i].sSQLType
90849>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90849>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
90849>>>//        Move "4.0"              to ColumnType[i].sPrecision
90849>>>//        Move True               to ColumnType[i].bCanEditSize
90849>>>//        Increment i
90849>>>
90849>>>        Function_Return aColumnType
90850>>>    End_Function
90851>>>
90851>>>    // Oracle Data Types
90851>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
90853>>>        tColumnType[] aColumnType
90853>>>        tColumnType[] aColumnType
90854>>>        Integer i
90854>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\ora_drv_DriverDef.inc)
90854>>>>// Generated By The Database Update Framework
90854>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
90854>>>>// Driver COLUMN DATA TYPES
90854>>>>//
90854>>>>// Created: 2018-03-14 23:47:34.82
90854>>>>
90854>>>>            Move "blob"                                  to aColumnType[i].sSQLType
90855>>>>            Move 113                                     to aColumnType[i].iSQLType
90856>>>>            Move True                                    to aColumnType[i].bCanEditSize
90857>>>>            Move True                                    to aColumnType[i].bNativeDataType
90858>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90859>>>>            Move 1                                       to aColumnType[i].iMinSize
90860>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90861>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90862>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90863>>>>            Move 16384                                   to aColumnType[i].sPrecision
90864>>>>            Increment i
90865>>>>
90865>>>>            Move "char"                                  to aColumnType[i].sSQLType
90866>>>>            Move 96                                      to aColumnType[i].iSQLType
90867>>>>            Move True                                    to aColumnType[i].bCanEditSize
90868>>>>            Move True                                    to aColumnType[i].bNativeDataType
90869>>>>            Move 1                                       to aColumnType[i].iDefaultSize
90870>>>>            Move 1                                       to aColumnType[i].iMinSize
90871>>>>            Move 2000                                    to aColumnType[i].nMaxSize
90872>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90873>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90874>>>>            Move 2000                                    to aColumnType[i].sPrecision
90875>>>>            Increment i
90876>>>>
90876>>>>            Move "clob"                                  to aColumnType[i].sSQLType
90877>>>>            Move 112                                     to aColumnType[i].iSQLType
90878>>>>            Move True                                    to aColumnType[i].bCanEditSize
90879>>>>            Move True                                    to aColumnType[i].bNativeDataType
90880>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90881>>>>            Move 1                                       to aColumnType[i].iMinSize
90882>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90883>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90884>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90885>>>>            Move 16384                                   to aColumnType[i].sPrecision
90886>>>>            Increment i
90887>>>>
90887>>>>            Move "date"                                  to aColumnType[i].sSQLType
90888>>>>            Move 12                                      to aColumnType[i].iSQLType
90889>>>>            Move True                                    to aColumnType[i].bCanEditSize
90890>>>>            Move True                                    to aColumnType[i].bNativeDataType
90891>>>>            Move 6                                       to aColumnType[i].iDefaultSize
90892>>>>            Move 6                                       to aColumnType[i].iMinSize
90893>>>>            Move 23                                      to aColumnType[i].nMaxSize
90894>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
90895>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
90896>>>>            Move 6                                       to aColumnType[i].sPrecision
90897>>>>            Increment i
90898>>>>
90898>>>>            Move "float"                                 to aColumnType[i].sSQLType
90899>>>>            Move 4                                       to aColumnType[i].iSQLType
90900>>>>            Move True                                    to aColumnType[i].bCanEditSize
90901>>>>            Move True                                    to aColumnType[i].bNativeDataType
90902>>>>            Move 1                                       to aColumnType[i].iDefaultSize
90903>>>>            Move 1                                       to aColumnType[i].iMinSize
90904>>>>            Move 14                                      to aColumnType[i].nMaxSize
90905>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90906>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90907>>>>            Move 14                                      to aColumnType[i].sPrecision
90908>>>>            Increment i
90909>>>>
90909>>>>            Move "int"                                   to aColumnType[i].sSQLType
90910>>>>            Move 3                                       to aColumnType[i].iSQLType
90911>>>>            Move True                                    to aColumnType[i].bCanEditSize
90912>>>>            Move True                                    to aColumnType[i].bNativeDataType
90913>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90914>>>>            Move 1                                       to aColumnType[i].iMinSize
90915>>>>            Move 14                                      to aColumnType[i].nMaxSize
90916>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90917>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90918>>>>            Move 14                                      to aColumnType[i].sPrecision
90919>>>>            Increment i
90920>>>>
90920>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
90921>>>>            Move 190                                     to aColumnType[i].iSQLType
90922>>>>            Move False                                   to aColumnType[i].bCanEditSize
90923>>>>            Move True                                    to aColumnType[i].bNativeDataType
90924>>>>            Move 23                                      to aColumnType[i].iDefaultSize
90925>>>>            Move -1                                      to aColumnType[i].iMinSize
90926>>>>            Move -1                                      to aColumnType[i].nMaxSize
90927>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
90928>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
90929>>>>            Move -1                                      to aColumnType[i].sPrecision
90930>>>>            Increment i
90931>>>>
90931>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
90932>>>>            Move 189                                     to aColumnType[i].iSQLType
90933>>>>            Move False                                   to aColumnType[i].bCanEditSize
90934>>>>            Move True                                    to aColumnType[i].bNativeDataType
90935>>>>            Move 23                                      to aColumnType[i].iDefaultSize
90936>>>>            Move -1                                      to aColumnType[i].iMinSize
90937>>>>            Move -1                                      to aColumnType[i].nMaxSize
90938>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
90939>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
90940>>>>            Move -1                                      to aColumnType[i].sPrecision
90941>>>>            Increment i
90942>>>>
90942>>>>            Move "long"                                  to aColumnType[i].sSQLType
90943>>>>            Move 8                                       to aColumnType[i].iSQLType
90944>>>>            Move True                                    to aColumnType[i].bCanEditSize
90945>>>>            Move True                                    to aColumnType[i].bNativeDataType
90946>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90947>>>>            Move 1                                       to aColumnType[i].iMinSize
90948>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90949>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90950>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90951>>>>            Move 16384                                   to aColumnType[i].sPrecision
90952>>>>            Increment i
90953>>>>
90953>>>>            Move "longraw"                               to aColumnType[i].sSQLType
90954>>>>            Move 24                                      to aColumnType[i].iSQLType
90955>>>>            Move True                                    to aColumnType[i].bCanEditSize
90956>>>>            Move True                                    to aColumnType[i].bNativeDataType
90957>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90958>>>>            Move 1                                       to aColumnType[i].iMinSize
90959>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90960>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90961>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90962>>>>            Move 16384                                   to aColumnType[i].sPrecision
90963>>>>            Increment i
90964>>>>
90964>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
90965>>>>            Move 286                                     to aColumnType[i].iSQLType
90966>>>>            Move True                                    to aColumnType[i].bCanEditSize
90967>>>>            Move True                                    to aColumnType[i].bNativeDataType
90968>>>>            Move 1                                       to aColumnType[i].iDefaultSize
90969>>>>            Move 1                                       to aColumnType[i].iMinSize
90970>>>>            Move 2000                                    to aColumnType[i].nMaxSize
90971>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90972>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90973>>>>            Move 2000                                    to aColumnType[i].sPrecision
90974>>>>            Increment i
90975>>>>
90975>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
90976>>>>            Move 288                                     to aColumnType[i].iSQLType
90977>>>>            Move True                                    to aColumnType[i].bCanEditSize
90978>>>>            Move True                                    to aColumnType[i].bNativeDataType
90979>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90980>>>>            Move 1                                       to aColumnType[i].iMinSize
90981>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90982>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90983>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90984>>>>            Move 16384                                   to aColumnType[i].sPrecision
90985>>>>            Increment i
90986>>>>
90986>>>>            Move "number"                                to aColumnType[i].sSQLType
90987>>>>            Move 2                                       to aColumnType[i].iSQLType
90988>>>>            Move True                                    to aColumnType[i].bCanEditSize
90989>>>>            Move True                                    to aColumnType[i].bNativeDataType
90990>>>>            Move 1                                       to aColumnType[i].iDefaultSize
90991>>>>            Move 1                                       to aColumnType[i].iMinSize
90992>>>>            Move 14                                      to aColumnType[i].nMaxSize
90993>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90994>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90995>>>>            Move 14                                      to aColumnType[i].sPrecision
90996>>>>            Increment i
90997>>>>
90997>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
90998>>>>            Move 287                                     to aColumnType[i].iSQLType
90999>>>>            Move True                                    to aColumnType[i].bCanEditSize
91000>>>>            Move True                                    to aColumnType[i].bNativeDataType
91001>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91002>>>>            Move 1                                       to aColumnType[i].iMinSize
91003>>>>            Move 4000                                    to aColumnType[i].nMaxSize
91004>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91005>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91006>>>>            Move 4000                                    to aColumnType[i].sPrecision
91007>>>>            Increment i
91008>>>>
91008>>>>            Move "raw"                                   to aColumnType[i].sSQLType
91009>>>>            Move 23                                      to aColumnType[i].iSQLType
91010>>>>            Move True                                    to aColumnType[i].bCanEditSize
91011>>>>            Move True                                    to aColumnType[i].bNativeDataType
91012>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91013>>>>            Move 1                                       to aColumnType[i].iMinSize
91014>>>>            Move 2000                                    to aColumnType[i].nMaxSize
91015>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
91016>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
91017>>>>            Move 2000                                    to aColumnType[i].sPrecision
91018>>>>            Increment i
91019>>>>
91019>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
91020>>>>            Move 187                                     to aColumnType[i].iSQLType
91021>>>>            Move False                                   to aColumnType[i].bCanEditSize
91022>>>>            Move True                                    to aColumnType[i].bNativeDataType
91023>>>>            Move 23                                      to aColumnType[i].iDefaultSize
91024>>>>            Move -1                                      to aColumnType[i].iMinSize
91025>>>>            Move -1                                      to aColumnType[i].nMaxSize
91026>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
91027>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
91028>>>>            Move -1                                      to aColumnType[i].sPrecision
91029>>>>            Increment i
91030>>>>
91030>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
91031>>>>            Move 232                                     to aColumnType[i].iSQLType
91032>>>>            Move False                                   to aColumnType[i].bCanEditSize
91033>>>>            Move True                                    to aColumnType[i].bNativeDataType
91034>>>>            Move 23                                      to aColumnType[i].iDefaultSize
91035>>>>            Move -1                                      to aColumnType[i].iMinSize
91036>>>>            Move -1                                      to aColumnType[i].nMaxSize
91037>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
91038>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
91039>>>>            Move -1                                      to aColumnType[i].sPrecision
91040>>>>            Increment i
91041>>>>
91041>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
91042>>>>            Move 188                                     to aColumnType[i].iSQLType
91043>>>>            Move False                                   to aColumnType[i].bCanEditSize
91044>>>>            Move True                                    to aColumnType[i].bNativeDataType
91045>>>>            Move 23                                      to aColumnType[i].iDefaultSize
91046>>>>            Move -1                                      to aColumnType[i].iMinSize
91047>>>>            Move -1                                      to aColumnType[i].nMaxSize
91048>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
91049>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
91050>>>>            Move -1                                      to aColumnType[i].sPrecision
91051>>>>            Increment i
91052>>>>
91052>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
91053>>>>            Move 1                                       to aColumnType[i].iSQLType
91054>>>>            Move True                                    to aColumnType[i].bCanEditSize
91055>>>>            Move True                                    to aColumnType[i].bNativeDataType
91056>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91057>>>>            Move 1                                       to aColumnType[i].iMinSize
91058>>>>            Move 4000                                    to aColumnType[i].nMaxSize
91059>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91060>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91061>>>>            Move 4000                                    to aColumnType[i].sPrecision
91062>>>>            Increment i
91063>>>>
91063>>>>
91063>>>
91063>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
91063>>>//        Move "BLOB"             to ColumnType[i].sSQLType
91063>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91063>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91063>>>//        Move "16384"            to ColumnType[i].sPrecision
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
91063>>>//        Move "CHAR"             to ColumnType[i].sSQLType
91063>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91063>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91063>>>//        Move "2000"             to ColumnType[i].sPrecision
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
91063>>>//        Move "CLOB"             to ColumnType[i].sSQLType
91063>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91063>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91063>>>//        Move "16384"            to ColumnType[i].sPrecision
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
91063>>>//        Move "DATE"             to ColumnType[i].sSQLType
91063>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
91063>>>//        Move "Date"             to ColumnType[i].sDataFlexType
91063>>>//        Move "6.0"              to ColumnType[i].sPrecision
91063>>>//        Move True               to ColumnType[i].bCanEditSize
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
91063>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
91063>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91063>>>//        Move "Number"           to ColumnType[i].sDataFlexType
91063>>>//        Move "14.8"             to ColumnType[i].sPrecision
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
91063>>>//        Move "INT"              to ColumnType[i].sSQLType
91063>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91063>>>//        Move "Number"           to ColumnType[i].sDataFlexType
91063>>>//        Move "14.0"             to ColumnType[i].sPrecision
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
91063>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
91063>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91063>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
91063>>>//        Move "23.0"             to ColumnType[i].sPrecision
91063>>>//        Move True               to ColumnType[i].bCanEditSize
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
91063>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
91063>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
91063>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
91063>>>//        Move "23.0"              to ColumnType[i].sPrecision
91063>>>//        Move True                to ColumnType[i].bCanEditSize
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
91063>>>//        Move "LONG"             to ColumnType[i].sSQLType
91063>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91063>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91063>>>//        Move "16384"            to ColumnType[i].sPrecision
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
91063>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
91063>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91063>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91063>>>//        Move "16384"            to ColumnType[i].sPrecision
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
91063>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
91063>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91063>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91063>>>//        Move "2000"             to ColumnType[i].sPrecision
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
91063>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
91063>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91063>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91063>>>//        Move "16384"            to ColumnType[i].sPrecision
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
91063>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
91063>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91063>>>//        Move "Number"           to ColumnType[i].sDataFlexType
91063>>>//        Move "14.8"             to ColumnType[i].sPrecision
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
91063>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
91063>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91063>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91063>>>//        Move "4000"             to ColumnType[i].sPrecision
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
91063>>>//        Move "RAW"              to ColumnType[i].sSQLType
91063>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91063>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91063>>>//        Move "2000"             to ColumnType[i].sPrecision
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
91063>>>//        Move "ROWID"            to ColumnType[i].sSQLType
91063>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91063>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91063>>>//        Move "16384"            to ColumnType[i].sPrecision
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
91063>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
91063>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91063>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
91063>>>//        Move "11.0"             to ColumnType[i].sPrecision
91063>>>//        Move True               to ColumnType[i].bCanEditSize
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
91063>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
91063>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
91063>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
91063>>>//        Move "13.0"                 to ColumnType[i].sPrecision
91063>>>//        Move True                   to ColumnType[i].bCanEditSize
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
91063>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
91063>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
91063>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
91063>>>//        Move "11.0"                 to ColumnType[i].sPrecision
91063>>>//        Move True                   to ColumnType[i].bCanEditSize
91063>>>//        Increment i
91063>>>//
91063>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
91063>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
91063>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91063>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91063>>>//        Move "16384"            to ColumnType[i].sPrecision
91063>>>
91063>>>        Function_Return aColumnType
91064>>>    End_Function
91065>>>
91065>>>    // PostgreSQL Data Types
91065>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
91067>>>        tColumnType[] aColumnType
91067>>>        tColumnType[] aColumnType
91068>>>        Integer i
91068>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\mdspgsql_DriverDef.inc)
91068>>>>// Generated By The Database Update Framework
91068>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
91068>>>>// Driver COLUMN DATA TYPES
91068>>>>//
91068>>>>// Created: 2018-03-14 23:47:02.984
91068>>>>
91068>>>>            Move "bigint"                                to aColumnType[i].sSQLType
91069>>>>            Move 20                                      to aColumnType[i].iSQLType
91070>>>>            Move True                                    to aColumnType[i].bCanEditSize
91071>>>>            Move True                                    to aColumnType[i].bNativeDataType
91072>>>>            Move 14                                      to aColumnType[i].iDefaultSize
91073>>>>            Move 1                                       to aColumnType[i].iMinSize
91074>>>>            Move 14                                      to aColumnType[i].nMaxSize
91075>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91076>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91077>>>>            Move 14                                      to aColumnType[i].sPrecision
91078>>>>            Increment i
91079>>>>
91079>>>>            Move "bit"                                   to aColumnType[i].sSQLType
91080>>>>            Move 1560                                    to aColumnType[i].iSQLType
91081>>>>            Move True                                    to aColumnType[i].bCanEditSize
91082>>>>            Move True                                    to aColumnType[i].bNativeDataType
91083>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91084>>>>            Move 1                                       to aColumnType[i].iMinSize
91085>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91086>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
91087>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
91088>>>>            Move 16384                                   to aColumnType[i].sPrecision
91089>>>>            Increment i
91090>>>>
91090>>>>            Move "boolean"                               to aColumnType[i].sSQLType
91091>>>>            Move 16                                      to aColumnType[i].iSQLType
91092>>>>            Move False                                   to aColumnType[i].bCanEditSize
91093>>>>            Move True                                    to aColumnType[i].bNativeDataType
91094>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91095>>>>            Move -1                                      to aColumnType[i].iMinSize
91096>>>>            Move -1                                      to aColumnType[i].nMaxSize
91097>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91098>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91099>>>>            Move -1                                      to aColumnType[i].sPrecision
91100>>>>            Increment i
91101>>>>
91101>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
91102>>>>            Move 17                                      to aColumnType[i].iSQLType
91103>>>>            Move True                                    to aColumnType[i].bCanEditSize
91104>>>>            Move True                                    to aColumnType[i].bNativeDataType
91105>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91106>>>>            Move 1                                       to aColumnType[i].iMinSize
91107>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91108>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
91109>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
91110>>>>            Move 16384                                   to aColumnType[i].sPrecision
91111>>>>            Increment i
91112>>>>
91112>>>>            Move "char"                                  to aColumnType[i].sSQLType
91113>>>>            Move 18                                      to aColumnType[i].iSQLType
91114>>>>            Move True                                    to aColumnType[i].bCanEditSize
91115>>>>            Move True                                    to aColumnType[i].bNativeDataType
91116>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91117>>>>            Move 1                                       to aColumnType[i].iMinSize
91118>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91119>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91120>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91121>>>>            Move 16384                                   to aColumnType[i].sPrecision
91122>>>>            Increment i
91123>>>>
91123>>>>            Move "citext"                                to aColumnType[i].sSQLType
91124>>>>            Move -25                                     to aColumnType[i].iSQLType
91125>>>>            Move True                                    to aColumnType[i].bCanEditSize
91126>>>>            Move True                                    to aColumnType[i].bNativeDataType
91127>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91128>>>>            Move 1                                       to aColumnType[i].iMinSize
91129>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91130>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91131>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91132>>>>            Move 16384                                   to aColumnType[i].sPrecision
91133>>>>            Increment i
91134>>>>
91134>>>>            Move "date"                                  to aColumnType[i].sSQLType
91135>>>>            Move 1082                                    to aColumnType[i].iSQLType
91136>>>>            Move False                                   to aColumnType[i].bCanEditSize
91137>>>>            Move True                                    to aColumnType[i].bNativeDataType
91138>>>>            Move 6                                       to aColumnType[i].iDefaultSize
91139>>>>            Move -1                                      to aColumnType[i].iMinSize
91140>>>>            Move -1                                      to aColumnType[i].nMaxSize
91141>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
91142>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
91143>>>>            Move 6                                       to aColumnType[i].sPrecision
91144>>>>            Increment i
91145>>>>
91145>>>>            Move "double"                                to aColumnType[i].sSQLType
91146>>>>            Move 701                                     to aColumnType[i].iSQLType
91147>>>>            Move True                                    to aColumnType[i].bCanEditSize
91148>>>>            Move True                                    to aColumnType[i].bNativeDataType
91149>>>>            Move 14                                      to aColumnType[i].iDefaultSize
91150>>>>            Move 1                                       to aColumnType[i].iMinSize
91151>>>>            Move 14                                      to aColumnType[i].nMaxSize
91152>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91153>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91154>>>>            Move 14                                      to aColumnType[i].sPrecision
91155>>>>            Increment i
91156>>>>
91156>>>>            Move "integer"                               to aColumnType[i].sSQLType
91157>>>>            Move 23                                      to aColumnType[i].iSQLType
91158>>>>            Move True                                    to aColumnType[i].bCanEditSize
91159>>>>            Move True                                    to aColumnType[i].bNativeDataType
91160>>>>            Move 11                                      to aColumnType[i].iDefaultSize
91161>>>>            Move 1                                       to aColumnType[i].iMinSize
91162>>>>            Move 11                                      to aColumnType[i].nMaxSize
91163>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91164>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91165>>>>            Move 11                                      to aColumnType[i].sPrecision
91166>>>>            Increment i
91167>>>>
91167>>>>            Move "money"                                 to aColumnType[i].sSQLType
91168>>>>            Move 790                                     to aColumnType[i].iSQLType
91169>>>>            Move True                                    to aColumnType[i].bCanEditSize
91170>>>>            Move True                                    to aColumnType[i].bNativeDataType
91171>>>>            Move 30                                      to aColumnType[i].iDefaultSize
91172>>>>            Move 1                                       to aColumnType[i].iMinSize
91173>>>>            Move 30                                      to aColumnType[i].nMaxSize
91174>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91175>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91176>>>>            Move 30                                      to aColumnType[i].sPrecision
91177>>>>            Increment i
91178>>>>
91178>>>>            Move "numeric"                               to aColumnType[i].sSQLType
91179>>>>            Move 1700                                    to aColumnType[i].iSQLType
91180>>>>            Move True                                    to aColumnType[i].bCanEditSize
91181>>>>            Move True                                    to aColumnType[i].bNativeDataType
91182>>>>            Move 14                                      to aColumnType[i].iDefaultSize
91183>>>>            Move 1                                       to aColumnType[i].iMinSize
91184>>>>            Move 14                                      to aColumnType[i].nMaxSize
91185>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91186>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91187>>>>            Move 14                                      to aColumnType[i].sPrecision
91188>>>>            Increment i
91189>>>>
91189>>>>            Move "oid"                                   to aColumnType[i].sSQLType
91190>>>>            Move 26                                      to aColumnType[i].iSQLType
91191>>>>            Move False                                   to aColumnType[i].bCanEditSize
91192>>>>            Move True                                    to aColumnType[i].bNativeDataType
91193>>>>            Move 20                                      to aColumnType[i].iDefaultSize
91194>>>>            Move -1                                      to aColumnType[i].iMinSize
91195>>>>            Move -1                                      to aColumnType[i].nMaxSize
91196>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
91197>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
91198>>>>            Move -1                                      to aColumnType[i].sPrecision
91199>>>>            Increment i
91200>>>>
91200>>>>            Move "real"                                  to aColumnType[i].sSQLType
91201>>>>            Move 700                                     to aColumnType[i].iSQLType
91202>>>>            Move True                                    to aColumnType[i].bCanEditSize
91203>>>>            Move True                                    to aColumnType[i].bNativeDataType
91204>>>>            Move 6                                       to aColumnType[i].iDefaultSize
91205>>>>            Move 1                                       to aColumnType[i].iMinSize
91206>>>>            Move 6                                       to aColumnType[i].nMaxSize
91207>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91208>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91209>>>>            Move 6                                       to aColumnType[i].sPrecision
91210>>>>            Increment i
91211>>>>
91211>>>>            Move "regproc"                               to aColumnType[i].sSQLType
91212>>>>            Move 24                                      to aColumnType[i].iSQLType
91213>>>>            Move False                                   to aColumnType[i].bCanEditSize
91214>>>>            Move True                                    to aColumnType[i].bNativeDataType
91215>>>>            Move 64                                      to aColumnType[i].iDefaultSize
91216>>>>            Move -1                                      to aColumnType[i].iMinSize
91217>>>>            Move -1                                      to aColumnType[i].nMaxSize
91218>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91219>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91220>>>>            Move -1                                      to aColumnType[i].sPrecision
91221>>>>            Increment i
91222>>>>
91222>>>>            Move "smallint"                              to aColumnType[i].sSQLType
91223>>>>            Move 21                                      to aColumnType[i].iSQLType
91224>>>>            Move True                                    to aColumnType[i].bCanEditSize
91225>>>>            Move True                                    to aColumnType[i].bNativeDataType
91226>>>>            Move 6                                       to aColumnType[i].iDefaultSize
91227>>>>            Move 1                                       to aColumnType[i].iMinSize
91228>>>>            Move 6                                       to aColumnType[i].nMaxSize
91229>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91230>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91231>>>>            Move 6                                       to aColumnType[i].sPrecision
91232>>>>            Increment i
91233>>>>
91233>>>>            Move "text"                                  to aColumnType[i].sSQLType
91234>>>>            Move 25                                      to aColumnType[i].iSQLType
91235>>>>            Move True                                    to aColumnType[i].bCanEditSize
91236>>>>            Move True                                    to aColumnType[i].bNativeDataType
91237>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91238>>>>            Move 1                                       to aColumnType[i].iMinSize
91239>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91240>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91241>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91242>>>>            Move 16384                                   to aColumnType[i].sPrecision
91243>>>>            Increment i
91244>>>>
91244>>>>            Move "time"                                  to aColumnType[i].sSQLType
91245>>>>            Move 1083                                    to aColumnType[i].iSQLType
91246>>>>            Move True                                    to aColumnType[i].bCanEditSize
91247>>>>            Move True                                    to aColumnType[i].bNativeDataType
91248>>>>            Move 8                                       to aColumnType[i].iDefaultSize
91249>>>>            Move 8                                       to aColumnType[i].iMinSize
91250>>>>            Move 15                                      to aColumnType[i].nMaxSize
91251>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91252>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91253>>>>            Move 15                                      to aColumnType[i].sPrecision
91254>>>>            Increment i
91255>>>>
91255>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
91256>>>>            Move 1114                                    to aColumnType[i].iSQLType
91257>>>>            Move False                                   to aColumnType[i].bCanEditSize
91258>>>>            Move True                                    to aColumnType[i].bNativeDataType
91259>>>>            Move 23                                      to aColumnType[i].iDefaultSize
91260>>>>            Move -1                                      to aColumnType[i].iMinSize
91261>>>>            Move -1                                      to aColumnType[i].nMaxSize
91262>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
91263>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
91264>>>>            Move -1                                      to aColumnType[i].sPrecision
91265>>>>            Increment i
91266>>>>
91266>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
91267>>>>            Move 1184                                    to aColumnType[i].iSQLType
91268>>>>            Move False                                   to aColumnType[i].bCanEditSize
91269>>>>            Move True                                    to aColumnType[i].bNativeDataType
91270>>>>            Move 23                                      to aColumnType[i].iDefaultSize
91271>>>>            Move -1                                      to aColumnType[i].iMinSize
91272>>>>            Move -1                                      to aColumnType[i].nMaxSize
91273>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91274>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91275>>>>            Move -1                                      to aColumnType[i].sPrecision
91276>>>>            Increment i
91277>>>>
91277>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
91278>>>>            Move 2950                                    to aColumnType[i].iSQLType
91279>>>>            Move False                                   to aColumnType[i].bCanEditSize
91280>>>>            Move True                                    to aColumnType[i].bNativeDataType
91281>>>>            Move 40                                      to aColumnType[i].iDefaultSize
91282>>>>            Move -1                                      to aColumnType[i].iMinSize
91283>>>>            Move -1                                      to aColumnType[i].nMaxSize
91284>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91285>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91286>>>>            Move -1                                      to aColumnType[i].sPrecision
91287>>>>            Increment i
91288>>>>
91288>>>>            Move "varbit"                                to aColumnType[i].sSQLType
91289>>>>            Move 1562                                    to aColumnType[i].iSQLType
91290>>>>            Move True                                    to aColumnType[i].bCanEditSize
91291>>>>            Move True                                    to aColumnType[i].bNativeDataType
91292>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91293>>>>            Move 1                                       to aColumnType[i].iMinSize
91294>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91295>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91296>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91297>>>>            Move 16384                                   to aColumnType[i].sPrecision
91298>>>>            Increment i
91299>>>>
91299>>>>            Move "varchar"                               to aColumnType[i].sSQLType
91300>>>>            Move 1043                                    to aColumnType[i].iSQLType
91301>>>>            Move True                                    to aColumnType[i].bCanEditSize
91302>>>>            Move True                                    to aColumnType[i].bNativeDataType
91303>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91304>>>>            Move 1                                       to aColumnType[i].iMinSize
91305>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91306>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91307>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91308>>>>            Move 16384                                   to aColumnType[i].sPrecision
91309>>>>            Increment i
91310>>>>
91310>>>>
91310>>>
91310>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
91310>>>//        Move "bigint"           to ColumnType[i].sSQLType
91310>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91310>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91310>>>//        Move "14.0"             to ColumnType[i].sPrecision
91310>>>//        Move True               to ColumnType[i].bCanEditSize
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
91310>>>//        Move "bit"              to ColumnType[i].sSQLType
91310>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91310>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91310>>>//        Move "16384"            to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
91310>>>//        Move "boolean"          to ColumnType[i].sSQLType
91310>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91310>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91310>>>//        Move "1"                to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
91310>>>//        Move "bytea"            to ColumnType[i].sSQLType
91310>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91310>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91310>>>//        Move "16384"            to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
91310>>>//        Move "char"             to ColumnType[i].sSQLType
91310>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91310>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91310>>>//        Move "2000"             to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
91310>>>//        Move "citext"           to ColumnType[i].sSQLType
91310>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91310>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91310>>>//        Move "254"              to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
91310>>>//        Move "date"             to ColumnType[i].sSQLType
91310>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
91310>>>//        Move "Date"             to ColumnType[i].sDataFlexType
91310>>>//        Move "6.0"              to ColumnType[i].sPrecision
91310>>>//        Move True               to ColumnType[i].bCanEditSize
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
91310>>>//        Move "decimal"          to ColumnType[i].sSQLType
91310>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91310>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
91310>>>//        Move "14.8"             to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
91310>>>//        Move "double"           to ColumnType[i].sSQLType
91310>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91310>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91310>>>//        Move "22"               to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
91310>>>//        Move "integer"          to ColumnType[i].sSQLType
91310>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91310>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91310>>>//        Move "8.0"              to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
91310>>>//        Move "money"            to ColumnType[i].sSQLType
91310>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91310>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91310>>>//        Move "8.0"              to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
91310>>>//        Move "oid"              to ColumnType[i].sSQLType
91310>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91310>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91310>>>//        Move "16384"            to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
91310>>>//        Move "real"             to ColumnType[i].sSQLType
91310>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91310>>>//        Move "Real"             to ColumnType[i].sDataFlexType
91310>>>//        Move "6.6"              to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
91310>>>//        Move "regproc"          to ColumnType[i].sSQLType
91310>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91310>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91310>>>//        Move "64"               to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
91310>>>//        Move "smallint"         to ColumnType[i].sSQLType
91310>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91310>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91310>>>//        Move "6.0"              to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
91310>>>//        Move "text"             to ColumnType[i].sSQLType
91310>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91310>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91310>>>//        Move "16384"            to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
91310>>>//        Move "time"             to ColumnType[i].sSQLType
91310>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91310>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
91310>>>//        Move "15.0"             to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
91310>>>//        Move "timestamp"        to ColumnType[i].sSQLType
91310>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91310>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
91310>>>//        Move "23.0"             to ColumnType[i].sPrecision
91310>>>//        Move True               to ColumnType[i].bCanEditSize
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
91310>>>//        Move "uuid"             to ColumnType[i].sSQLType
91310>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91310>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91310>>>//        Move "40"               to ColumnType[i].sPrecision
91310>>>//        Move True               to ColumnType[i].bCanEditSize
91310>>>//        Increment i
91310>>>//
91310>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
91310>>>//        Move "varchar"          to ColumnType[i].sSQLType
91310>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91310>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
91310>>>//        Move "16384"            to ColumnType[i].sPrecision
91310>>>//        Increment i
91310>>>
91310>>>        Function_Return aColumnType
91311>>>    End_Function
91312>>>
91312>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
91312>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
91314>>>        Integer iValue iSize iCount iStart
91314>>>        tColumnType[] ColumnTypeArray
91314>>>        tColumnType[] ColumnTypeArray
91315>>>        tColumnType RetvalType
91315>>>        tColumnType RetvalType
91315>>>        String sValue
91315>>>        Boolean bFrameworkDataFlexType
91315>>>
91315>>>        Move "Undefined" to RetvalType.sSQLType
91316>>>        Move -1999       to RetvalType.iSQLType
91317>>>
91317>>>        Move 0 to iStart
91318>>>        Move (Uppercase(sType)) to sType
91319>>>        Move (iType <= -1490) to bFrameworkDataFlexType
91320>>>        If (bFrameworkDataFlexType = True) Begin
91322>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
91323>>>            Function_Return RetvalType
91324>>>        End
91324>>>>
91324>>>
91324>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
91325>>>
91325>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
91326>>>        Decrement iSize
91327>>>
91327>>>        for iCount from iStart to iSize
91333>>>>
91333>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
91334>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
91335>>>            If (bIntegerInputType = True) Begin
91337>>>                If (iValue = iType) Begin
91339>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
91340>>>                    Move iType                                  to RetvalType.iSQLType
91341>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
91342>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
91343>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
91344>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
91345>>>                    Move iSize to iCount // We're done!
91346>>>                End
91346>>>>
91346>>>            End
91346>>>>
91346>>>            Else Begin
91347>>>                Move (Uppercase(sValue)) to sValue
91348>>>                If (sValue = sType) Begin
91350>>>                    Move sType                                  to RetvalType.sSQLType
91351>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
91352>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
91353>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
91354>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
91355>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
91356>>>                    Move iSize to iCount // We're done!
91357>>>                End
91357>>>>
91357>>>            End
91357>>>>
91357>>>        Loop
91358>>>>
91358>>>
91358>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
91358>>>        // In which case we search for a match in DataFlex standard types:
91358>>>        If (RetvalType.sSQLType = "Undefined") Begin
91360>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
91361>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
91362>>>            Decrement iSize
91363>>>
91363>>>            for iCount from iStart to iSize
91369>>>>
91369>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
91370>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
91371>>>                If (iValue = iType) Begin
91373>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
91374>>>                    Move iType                                  to RetvalType.iSQLType
91375>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
91376>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
91377>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
91378>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
91379>>>                    Move iSize to iCount // We're done!
91380>>>                End
91380>>>>
91380>>>            Loop
91381>>>>
91381>>>        End
91381>>>>
91381>>>
91381>>>        Function_Return RetvalType
91382>>>    End_Function
91383>>>
91383>>>    Function _AllTablesToConvert Returns Integer[]
91385>>>        Integer[] aTableConvertExceptions iTablesArray
91387>>>        Handle hTable
91387>>>        Integer iIndex
91387>>>        String sTableName
91387>>>        Boolean bFlexErrs
91387>>>
91387>>>        // a) Get the exception table array the developer has specified
91387>>>        Get paTableConvertExceptions to aTableConvertExceptions
91388>>>
91388>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
91388>>>        Repeat
91388>>>>
91388>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91391>>>            If (hTable <> 0) Begin
91393>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91396>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
91397>>>                If (bFlexErrs = False) Begin
91399>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
91401>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
91402>>>                        If (iIndex = -1) Begin
91404>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
91405>>>                        End
91405>>>>
91405>>>                    End
91405>>>>
91405>>>                End
91405>>>>
91405>>>            End
91405>>>>
91405>>>        Until (hTable = 0)
91407>>>
91407>>>        Move 0 to hTable
91408>>>
91408>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
91408>>>        Repeat
91408>>>>
91408>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91411>>>            If (hTable > 0) Begin
91413>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91416>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
91417>>>                If (bFlexErrs = False) Begin
91419>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
91420>>>                    If (iIndex = -1) Begin
91422>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
91423>>>                    End
91423>>>>
91423>>>                End
91423>>>>
91423>>>            End
91423>>>>
91423>>>        Until (hTable = 0)
91425>>>
91425>>>        Function_Return iTablesArray
91426>>>    End_Function
91427>>>
91427>>>    Function _AllTablesDateCorrections Returns Integer[]
91429>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
91431>>>        Handle hTable
91431>>>        Integer iIndex
91431>>>        String sTableName
91431>>>        Boolean bFlexErrs
91431>>>
91431>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
91432>>>        Move 0 to hTable
91433>>>
91433>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
91433>>>        Repeat
91433>>>>
91433>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91436>>>            If (hTable > 0) Begin
91438>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91441>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
91442>>>                If (bFlexErrs = False) Begin
91444>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
91445>>>                    If (iIndex = -1) Begin
91447>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
91448>>>                    End
91448>>>>
91448>>>                End
91448>>>>
91448>>>            End
91448>>>>
91448>>>        Until (hTable = 0)
91450>>>
91450>>>        Function_Return iTablesArray
91451>>>    End_Function
91452>>>
91452>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
91454>>>        tAPIColumn NewAPIColumn
91454>>>        tAPIColumn NewAPIColumn
91454>>>
91454>>>        Move sFieldName to NewAPIColumn.sFieldName
91455>>>        Move iType      to NewAPIColumn.iType
91456>>>        Move iLength    to NewAPIColumn.iLength
91457>>>        Move iPrecision to NewAPIColumn.iPrecision
91458>>>        Move iOptions   to NewAPIColumn.iOptions
91459>>>
91459>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
91460>>>
91460>>>        Function_Return aCurrent
91461>>>    End_Function
91462>>>
91462>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
91464>>>        String sRetval sFieldName
91464>>>        Integer iCount iSize
91464>>>
91464>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
91465>>>        Decrement iSize
91466>>>        for iCount from 0 to iSize
91472>>>>
91472>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
91473>>>            Move (sRetval * (String(sFieldName))) to sRetval
91474>>>        Loop
91475>>>>
91475>>>        Move (Trim(sRetval)) to sRetval
91476>>>
91476>>>        Function_Return sRetval
91477>>>    End_Function
91478>>>
91478>>>    // *** Miscellaneous other functions ***
91478>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
91478>>>    //
91478>>>
91478>>>    // Callback functionality used when e.g. calling driver functions directly.
91478>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
91480>>>        Integer iPerc
91480>>>        Number nReady nTotal
91480>>>
91480>>>        Send DoAdvance of ghoProgressBar
91481>>>
91481>>>        If (sCallback_Text contains "Copy records") Begin
91483>>>            Move CS_DUF_CopyingData to sCallback_Text
91484>>>        End
91484>>>>
91484>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
91486>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
91487>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
91488>>>        End
91488>>>>
91488>>>        If (sCallback_Text contains "Creating index") Begin
91490>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
91491>>>        End
91491>>>>
91491>>>
91491>>>        Case Begin
91491>>>            Case (iCallback_Type = DF_Message_Text)
91493>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
91494>>>                Set Action_Text  of ghoStatusPanel to ""
91495>>>                Case Break
91496>>>            Case (iCallback_Type = DF_Message_Heading_1)
91499>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
91500>>>                Set Action_Text  of ghoStatusPanel to ""
91501>>>                Case Break
91502>>>            Case (iCallback_Type = DF_Message_Heading_2)
91505>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
91506>>>                Set Action_Text  of ghoStatusPanel to ""
91507>>>                Case Break
91508>>>            Case (iCallback_Type = DF_Message_Heading_3)
91511>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
91512>>>                Set Action_Text  of ghoStatusPanel to ""
91513>>>                Case Break
91514>>>            Case (iCallback_Type = DF_Message_Heading_4)
91517>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
91518>>>                Set Action_Text  of ghoStatusPanel to ""
91519>>>                Case Break
91520>>>            Case (iCallback_Type = DF_Message_Heading_5)
91523>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
91524>>>                Set Action_Text  of ghoStatusPanel to ""
91525>>>                Case Break
91526>>>            Case (iCallback_Type = DF_Message_Warning)
91529>>>                Send None
91530>>>                Case Break
91531>>>            Case (iCallback_Type = DF_Message_Progress_Title)
91534>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
91535>>>                Set Action_Text  of ghoStatusPanel to ""
91536>>>                Case Break
91537>>>            Case (iCallback_Type = DF_Message_Progress_Value)
91540>>>                //*** Interpret numbers
91540>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
91541>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
91542>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
91543>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
91544>>>                Case Break
91545>>>            Case Else
91545>>>                Set Message_Text to ""
91546>>>                Set Action_Text  to ""
91547>>>        Case End
91547>>>
91547>>>        Send ProcessEvents of ghoStatusPanel
91548>>>        Function_Return False
91549>>>    End_Function
91550>>>
91550>>>    Procedure IncreaseSortBufferSize
91552>>>        String sNull
91552>>>        Integer iSortBufferSize
91552>>>        Boolean bBufferSet
91552>>>
91552>>>        Move "" to sNull
91553>>>        Move (1024 * 128) to iSortBufferSize
91554>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
91559>>>
91559>>>    End_Procedure
91560>>>
91560>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
91562>>>        Integer iLastIndex iIndex iNumSegments
91562>>>        Boolean bOK
91562>>>        String sDriverID
91562>>>
91562>>>        If (hTable > 0) Begin
91564>>>            Get UtilDriverFromTableNumber hTable to sDriverID
91565>>>            Close hTable
91566>>>            Get OpenTableExclusive hTable to bOK
91567>>>            If (bOK = False) Begin
91569>>>                Procedure_Return
91570>>>            End
91570>>>>
91570>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
91573>>>            Structure_Start hTable sDriverID
91574>>>                for iIndex from 1 to iLastIndex
91580>>>>
91580>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91583>>>                    If (iNumSegments > 0) Begin
91585>>>                        If (bSetToBatch = True) Begin
91587>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
91590>>>                        End
91590>>>>
91590>>>                        Else Begin
91591>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
91594>>>                        End
91594>>>>
91594>>>                    End
91594>>>>
91594>>>                Loop
91595>>>>
91595>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91597>>>        End
91597>>>>
91597>>>    End_Procedure
91598>>>
91598>>>    Function NextFreeFilelistSlot Returns Handle
91600>>>        Handle hTable
91600>>>
91600>>>        Move 0 to hTable
91601>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
91604>>>
91604>>>        Function_Return hTable
91605>>>    End_Function
91606>>>
91606>>>    // For debugging purposes. To print Sql statements as they are build...
91606>>>    Procedure DebugPrint String sStmt String sFileName
91608>>>        Integer iCh
91608>>>        Get Seq_Append_Output_Channel sFileName to iCh
91609>>>            Write channel iCh sStmt
91611>>>        Send Seq_Close_Channel iCh
91612>>>    End_Procedure
91613>>>
91613>>>    // Returns the integer number for the passed Driver ID that is
91613>>>    // needed by some database API calls.
91613>>>    Function DriverIndex String sDriverID Returns Integer
91615>>>        String  sCurrentDriver
91615>>>        Integer iNumberOfDrivers iDriver iCount
91615>>>
91615>>>        Move 0 to iDriver
91616>>>
91616>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
91619>>>        for iCount from 1 to iNumberOfDrivers
91625>>>>
91625>>>
91625>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
91628>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
91630>>>                Move iCount to iDriver
91631>>>            End
91631>>>>
91631>>>        Loop
91632>>>>
91632>>>
91632>>>        // In case it was not found, it wasn't loaded so we do that now.
91632>>>        If (iDriver = 0) Begin
91634>>>            Move False to Err
91635>>>            Load_Driver sDriverID
91636>>>            If (Err = False) Begin
91638>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
91641>>>            End
91641>>>>
91641>>>        End
91641>>>>
91641>>>
91641>>>        Function_Return iDriver
91642>>>    End_Function
91643>>>
91643>>>    
91643>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
91645>>>        String sDriverID sVersion sClient sClientLowest sRetval
91645>>>        Integer iNumberOfDrivers iDriver iClient
91645>>>        Handle hoCLIHandler hoMSSQLHandler 
91645>>>        
91645>>>        Move "" to sRetval
91646>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
91647>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
91648>>>        Load_Driver MSSQLDRV_ID
91649>>>
91649>>>        // Loop through all loaded drivers.
91649>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
91652>>>        For iDriver from 1 to iNumberOfDrivers
91658>>>>
91658>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
91661>>>            If (sDriverID = MSSQLDRV_ID) Begin
91663>>>                Set psDriverID of hoCLIHandler to sDriverID
91664>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
91667>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
91668>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
91669>>>                Get CKRevision of hoCLIHandler to sVersion
91670>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
91671>>>                If (sClient <> "" and sRetval <> "") Begin
91673>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
91674>>>                End                                
91674>>>>
91674>>>                Else Begin
91675>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
91676>>>                End
91676>>>>
91676>>>            End
91676>>>>
91676>>>        Loop
91677>>>>
91677>>>        Send Destroy of hoCLIHandler  
91678>>>        Send Destroy of hoMSSQLHandler  
91679>>>        If (bShowErrorDialog = True and (sVersion < String(sMSSQLDRVVersion)) or iClient < iClientVersion) Begin 
91681>>>            Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
91682>>>            If (bExitProgram = True) Begin
91684>>>                Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
91685>>>            End
91685>>>>
91685>>>            Send Stop_Box sRetval  
91686>>>            If (bExitProgram = True) Begin
91688>>>                Send Exit_Application
91689>>>            End
91689>>>>
91689>>>        End
91689>>>>
91689>>>        
91689>>>        Function_Return sRetval
91690>>>    End_Function
91691>>>
91691>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
91691>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
91691>>>    //       so in that case we "cheat" and report those tables were opened OK.
91691>>>    Function OpenTableExclusive Handle hTable Returns Boolean
91693>>>        Integer iMode
91693>>>        Boolean bOpened
91693>>>        String sTableName
91693>>>
91693>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91694>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91697>>>        If (bOpened) Begin
91699>>>            If (IsDebuggerPresent()) Begin
91701>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91704>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
91706>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
91707>>>                    Function_Return True
91708>>>                End
91708>>>>
91708>>>            End
91708>>>>
91708>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
91711>>>            If (iMode=DF_EXCLUSIVE) Begin
91713>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
91714>>>                Function_Return True
91715>>>            End
91715>>>>
91715>>>            Close hTable
91716>>>        End
91716>>>>
91716>>>        Else Begin
91717>>>            Open hTable
91719>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
91722>>>            If (bOpened and IsDebuggerPresent()) Begin
91724>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91727>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
91729>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
91730>>>                    Function_Return True
91731>>>                End
91731>>>>
91731>>>            End
91731>>>>
91731>>>
91731>>>        End
91731>>>>
91731>>>
91731>>>        Close hTable
91732>>>        Open hTable Mode DF_EXCLUSIVE
91734>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91737>>>
91737>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91738>>>        Function_Return bOpened
91739>>>    End_Function
91740>>>
91740>>>    Function AutoConnectionIDLogin Returns Boolean
91742>>>        String sConnectionID sConnectionString sDriverID
91742>>>        Boolean bExists bOK bSQLDriver bMertech
91742>>>        Handle hoCLI hoDriver
91742>>>        Integer iRetval
91742>>>        tSQLConnection SQLConnection
91742>>>        tSQLConnection SQLConnection
91742>>>
91742>>>        Get psDriverID to sDriverID
91743>>>        Get IsSQLDriver sDriverID to bSQLDriver
91744>>>        If (bSQLDriver = False) Begin
91746>>>            Function_Return True
91747>>>        End
91747>>>>
91747>>>
91747>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91748>>>        Move SQLConnection.sDriverID                  to sDriverID
91749>>>        Move SQLConnection.sConnectionString          to sConnectionString
91750>>>        Get IsMertechDriver sDriverID to bMertech
91751>>>        If (bMertech = True) Begin
91753>>>            Get _MertechSQLManagerHandle to hoCLI
91754>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
91755>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
91756>>>            Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
91757>>>            Send Destroy of hoDriver
91758>>>            Function_Return bOK
91759>>>        End
91759>>>>
91759>>>
91759>>>        Move SQLConnection.sConnectionID to sConnectionID
91760>>>
91760>>>        Get IsConnectionID sConnectionID sDriverID to bExists
91761>>>        If (bExists = False) Begin
91763>>>            // We always start by deleting the current connection - if any - because the
91763>>>            // login details my have changed.
91763>>>            Get phoCLIHandler to hoCLI
91764>>>            Set psDriverID    of hoCLI to sDriverID
91765>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
91766>>>            Get AutoSetConnectionID sConnectionID to bOk
91767>>>            If (bOk = False) Begin
91769>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
91770>>>>
91770>>>                Function_Return False
91771>>>            End
91771>>>>
91771>>>            Move bOK to bExists
91772>>>        End
91772>>>>
91772>>>
91772>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
91773>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
91774>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
91775>>>        Send Destroy of hoDriver
91776>>>
91776>>>        Function_Return (bExists = True)
91777>>>    End_Function
91778>>>
91778>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
91778>>>    // Returns: False if nobody else is running
91778>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
91778>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
91778>>>    //      tables are not locked as DataFlex tables are.
91778>>>    Function IsDatabaseInUse Returns Boolean
91780>>>        Handle  hTable
91780>>>        String  sRootName
91780>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
91780>>>        Integer iCount iTables
91780>>>
91780>>>        Move 0 to iTables
91781>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
91782>>>        Get AutoConnectionIDLogin to bOK
91783>>>        Get UtilFilelistNoOfTables to iTables
91784>>>        Set piPosition   of ghoProgressBar to 0
91785>>>        Set piAdvanceBy  of ghoProgressBar to 1
91786>>>        Set piMaximum    of ghoProgressBar to iTables
91787>>>        Move 0 to hTable
91788>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91791>>>        Move False to bErr
91792>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
91793>>>
91793>>>        Repeat
91793>>>>
91793>>>            Set piPosition of ghoProgressBar to iCount
91794>>>            Increment iCount
91795>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91798>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
91799>>>
91799>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
91799>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
91800>>>            Move False to bOpen
91801>>>            Get UtilTableExists hTable to bExists
91802>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
91802>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
91804>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91805>>>                Open hTable
91807>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
91810>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91811>>>                If (bOpen = True) Begin
91813>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
91813>>>                    Get UtilTableIsAlias hTable to bAlias
91814>>>                    If (bAlias = False) Begin
91816>>>                        Close hTable
91817>>>                        Get OpenTableExclusive hTable to bOpen
91818>>>                        If (bOpen = False) Begin
91820>>>                            Move True to bErr
91821>>>                        End
91821>>>>
91821>>>                    End
91821>>>>
91821>>>                End
91821>>>>
91821>>>                Close hTable
91822>>>            End
91822>>>>
91822>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91825>>>            If (bErr = True ) ;                Break
91828>>>        Until (not(hTable))
91830>>>
91830>>>        Set Action_Text of ghoStatusPanel to ""
91831>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
91832>>>        Move False to Err
91833>>>
91833>>>        Function_Return bErr
91834>>>    End_Function
91835>>>
91835>>>    // Checks if the passed connection id exists in the CLI interface.
91835>>>    // This might be needed by API-methods when a connection id is to be used and
91835>>>    // the connection id hasn't been established with the driver's CLI interface.
91835>>>    // NOTE: Only applicable for DAW drivers.
91835>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
91837>>>        String sID sConnString
91837>>>        Integer iDriver iNumConn iCount
91837>>>        Handle hoCLI
91837>>>        Boolean bOK
91837>>>
91837>>>        Get IsDAWSQLDriver sDriverID to bOK
91838>>>        If (bOK = False) Begin
91840>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
91841>>>>
91841>>>            Function_Return False
91842>>>        End
91842>>>>
91842>>>
91842>>>        Move False to bOK
91843>>>        Get phoCLIHandler to hoCLI
91844>>>        If (hoCLI <> 0) Begin
91846>>>            Set psDriverID of hoCLI to sDriverID
91847>>>            Get DriverIndex of hoCLI sDriverID to iDriver
91848>>>
91848>>>            // If driver not loaded; load it.
91848>>>            If (iDriver = 0) Begin
91850>>>                Load_Driver sDriverID
91851>>>                Get DriverIndex sDriverID to iDriver
91852>>>            End
91852>>>>
91852>>>            If (iDriver <> 0) Begin
91854>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
91857>>>                Decrement iNumConn
91858>>>                for iCount from 0 to iNumConn
91864>>>>
91864>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
91867>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
91870>>>                    If (sID = sConnectionID) Begin
91872>>>                        Move True to bOK
91873>>>                    End
91873>>>>
91873>>>                Loop
91874>>>>
91874>>>            End
91874>>>>
91874>>>        End
91874>>>>
91874>>>
91874>>>        Function_Return bOK
91875>>>    End_Function
91876>>>
91876>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
91878>>>        Boolean bOK
91878>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
91879>>>        Function_Return bOK
91880>>>    End_Function
91881>>>
91881>>>    Function IsMertechDriver String sDriverID Returns Boolean
91883>>>        Boolean bOK
91883>>>        Move False to bOK
91884>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
91885>>>        Function_Return bOK
91886>>>    End_Function
91887>>>
91887>>>    Function IsMSSQLDriver Returns Boolean
91889>>>        Integer iDriverIndex
91889>>>
91889>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
91890>>>
91890>>>        Function_Return (iDriverIndex <> 0)
91891>>>    End_Function
91892>>>
91892>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
91892>>>    // attempt to load the driver.
91892>>>    // Returns true if the passed driver is SQL based.
91892>>>    Function IsSQLDriver String sDriverID Returns Boolean
91894>>>        Boolean bOK
91894>>>
91894>>>        Get IsDAWSQLDriver sDriverID to bOK
91895>>>
91895>>>        If (bOK = False) Begin
91897>>>            Get IsMertechDriver sDriverID to bOK
91898>>>        End
91898>>>>
91898>>>
91898>>>        Function_Return bOK
91899>>>    End_Function
91900>>>
91900>>>    // *** Error Handler ***
91900>>>    //
91900>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
91900>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
91900>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
91902>>>        Integer iSize iErrorMode
91902>>>        tSqlErrorArray aSqlErrorArray
91902>>>        tSqlErrorArray aSqlErrorArray
91902>>>
91902>>>        If (pbProcessingError(Self)) Begin
91904>>>            Procedure_Return
91905>>>        End
91905>>>>
91905>>>
91905>>>        Get Error_Report_Mode to iErrorMode
91906>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
91908>>>            Procedure_Return
91909>>>        End
91909>>>>
91909>>>
91909>>>        Set pbProcessingError to True
91910>>>        Set pbSqlError to True
91911>>>        Get paSqlErrorArray      to aSqlErrorArray
91912>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
91913>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
91914>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
91915>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
91916>>>        Set paSqlErrorArray      to aSqlErrorArray
91917>>>        Set pbProcessingError to False
91918>>>    End_Procedure
91919>>>
91919>>>    // *** Miscellanous Helper Functions ***
91919>>>    //
91919>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
91919>>>    // returns the table name only; stripped of any path or filename extension.
91919>>>    Function _TableNameOnly String sName Returns String
91921>>>        String sPath sExt
91921>>>
91921>>>        Get ParseFolderName sName to sPath
91922>>>        If (sPath <> "") Begin
91924>>>            Move (Replace(sPath, sName, "")) to sName
91925>>>        End
91925>>>>
91925>>>        Get ParseFileExtension sName to sExt
91926>>>        If (sExt <> "") Begin
91928>>>            Move (Replace(("." + sExt), sName, "")) to sName
91929>>>        End
91929>>>>
91929>>>
91929>>>        Function_Return sName
91930>>>    End_Function
91931>>>
91931>>>    // Removes any prefix to a table name.
91931>>>    // Example mssqldrv:mytable returns mytable
91931>>>    //         dbo.mytable returns mytable
91931>>>    Function _TableNoPrefix String sName Returns String
91933>>>        Integer iPos
91933>>>
91933>>>        Move (Pos(":", sName)) to iPos
91934>>>        If (iPos <> 0) Begin
91936>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
91937>>>        End
91937>>>>
91937>>>        Move (Pos(".", sName)) to iPos
91938>>>        If (iPos <> 0) Begin
91940>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
91941>>>        End
91941>>>>
91941>>>
91941>>>        Function_Return sName
91942>>>    End_Function
91943>>>
91943>>>    // Returns the first datapath found in the psDataPath property.
91943>>>    // The returned path always ends with a "\"
91943>>>    Function psDataPathFirstPart Returns String
91945>>>        String sDataPath
91945>>>        Integer iCount
91945>>>
91945>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91946>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
91947>>>        If (iCount > 1) Begin
91949>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
91950>>>        End
91950>>>>
91950>>>        If (sDataPath <> "") Begin
91952>>>            Get vFolderFormat sDataPath to sDataPath
91953>>>        End
91953>>>>
91953>>>
91953>>>        Function_Return sDataPath
91954>>>    End_Function
91955>>>
91955>>>    Function psLogTextFileWithPath Returns String
91957>>>        String sFileName
91957>>>        Handle hoLogFile
91957>>>        Get phoLogFile to hoLogFile
91958>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
91959>>>        Function_Return sFileName
91960>>>    End_Function
91961>>>
91961>>>    // *** Property Messages ***
91961>>>    //
91961>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
91961>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
91961>>>    //
91961>>>
91961>>>    Function pSQLConnection Returns tSQLConnection
91963>>>        tSQLConnection SQLConnection
91963>>>        tSQLConnection SQLConnection
91963>>>        If (ghoSQLConnectionHandler = 0) Begin
91965>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
91965>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
91966>>>>
91966>>>            Function_Return
91967>>>        End
91967>>>>
91967>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91968>>>        Function_Return SQLConnection
91969>>>    End_Function
91970>>>
91970>>>    // * Dummy function for the Studio's Code Explorer *
91970>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
91972>>>        Function_Return False
91973>>>    End_Function
91974>>>
91974>>>    Procedure Set psServer String sValue
91976>>>        If (ghoSQLConnectionHandler = 0) Begin
91978>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
91978>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
91979>>>>
91979>>>            Procedure_Return
91980>>>        End
91980>>>>
91980>>>        Set psServer of ghoSQLConnectionHandler to sValue
91981>>>    End_Procedure
91982>>>
91982>>>    Function psServer Returns String
91984>>>        String sValue
91984>>>        If (ghoSQLConnectionHandler = 0) Begin
91986>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
91987>>>>
91987>>>            Function_Return
91988>>>        End
91988>>>>
91988>>>        Get psServer of ghoSQLConnectionHandler to sValue
91989>>>        Function_Return sValue
91990>>>    End_Function
91991>>>
91991>>>    Procedure Set psDatabase String sValue
91993>>>        If (ghoSQLConnectionHandler = 0) Begin
91995>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
91996>>>>
91996>>>            Procedure_Return
91997>>>        End
91997>>>>
91997>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
91998>>>    End_Procedure
91999>>>
91999>>>    Function psDatabase Returns String
92001>>>        String sValue
92001>>>        If (ghoSQLConnectionHandler = 0) Begin
92003>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92004>>>>
92004>>>            Function_Return
92005>>>        End
92005>>>>
92005>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
92006>>>        Function_Return sValue
92007>>>    End_Function
92008>>>
92008>>>    Procedure Set psUserID String sValue
92010>>>        If (ghoSQLConnectionHandler = 0) Begin
92012>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92013>>>>
92013>>>            Procedure_Return
92014>>>        End
92014>>>>
92014>>>        Set psUserID of ghoSQLConnectionHandler to sValue
92015>>>    End_Procedure
92016>>>
92016>>>    Function psUserID Returns String
92018>>>        String sValue
92018>>>        If (ghoSQLConnectionHandler = 0) Begin
92020>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92021>>>>
92021>>>            Function_Return
92022>>>        End
92022>>>>
92022>>>        Get psUserID of ghoSQLConnectionHandler to sValue
92023>>>        Function_Return sValue
92024>>>    End_Function
92025>>>
92025>>>    Procedure Set psPassword String sValue
92027>>>        If (ghoSQLConnectionHandler = 0) Begin
92029>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92030>>>>
92030>>>            Procedure_Return
92031>>>        End
92031>>>>
92031>>>        Set psPassword of ghoSQLConnectionHandler to sValue
92032>>>    End_Procedure
92033>>>
92033>>>    Function psPassword Returns String
92035>>>        String sValue
92035>>>        If (ghoSQLConnectionHandler = 0) Begin
92037>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92038>>>>
92038>>>            Function_Return
92039>>>        End
92039>>>>
92039>>>        Get psPassword of ghoSQLConnectionHandler to sValue
92040>>>        Function_Return sValue
92041>>>    End_Function
92042>>>
92042>>>    Procedure Set pbTrusted Boolean bValue
92044>>>        If (ghoSQLConnectionHandler = 0) Begin
92046>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92047>>>>
92047>>>            Procedure_Return
92048>>>        End
92048>>>>
92048>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
92049>>>    End_Procedure
92050>>>
92050>>>    Function pbTrusted Returns Boolean
92052>>>        Boolean bValue
92052>>>        If (ghoSQLConnectionHandler = 0) Begin
92054>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92055>>>>
92055>>>            Function_Return
92056>>>        End
92056>>>>
92056>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
92057>>>        Function_Return bValue
92058>>>    End_Function
92059>>>
92059>>>    Procedure Set pbSilentLogin Boolean bValue
92061>>>        If (ghoSQLConnectionHandler = 0) Begin
92063>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92064>>>>
92064>>>            Procedure_Return
92065>>>        End
92065>>>>
92065>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
92066>>>    End_Procedure
92067>>>
92067>>>    Function pbSilentLogin Returns Boolean
92069>>>        Boolean bValue
92069>>>        If (ghoSQLConnectionHandler = 0) Begin
92071>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92072>>>>
92072>>>            Function_Return
92073>>>        End
92073>>>>
92073>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
92074>>>        Function_Return bValue
92075>>>    End_Function
92076>>>
92076>>>    Procedure Set psConnectionID String sValue
92078>>>        If (ghoSQLConnectionHandler = 0) Begin
92080>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92081>>>>
92081>>>            Procedure_Return
92082>>>        End
92082>>>>
92082>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
92083>>>    End_Procedure
92084>>>
92084>>>    Function psConnectionID Returns String
92086>>>        String sValue
92086>>>        If (ghoSQLConnectionHandler = 0) Begin
92088>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92089>>>>
92089>>>            Function_Return
92090>>>        End
92090>>>>
92090>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
92091>>>        Function_Return sValue
92092>>>    End_Function
92093>>>
92093>>>    Procedure Set psConnectionString String sValue
92095>>>        If (ghoSQLConnectionHandler = 0) Begin
92097>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92098>>>>
92098>>>            Procedure_Return
92099>>>        End
92099>>>>
92099>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
92100>>>    End_Procedure
92101>>>
92101>>>    Function psConnectionString Returns String
92103>>>        String sValue
92103>>>        If (ghoSQLConnectionHandler = 0) Begin
92105>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92106>>>>
92106>>>            Function_Return
92107>>>        End
92107>>>>
92107>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
92108>>>        Function_Return sValue
92109>>>    End_Function
92110>>>
92110>>>    // The normal connection string looks something like this;
92110>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
92110>>>    // ...and the full connection string looks like this;
92110>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
92110>>>    Function psFullConnectionString Returns String
92112>>>        String sConnectionID sConnectionString
92112>>>        If (ghoSQLConnectionHandler = 0) Begin
92114>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92115>>>>
92115>>>            Function_Return
92116>>>        End
92116>>>>
92116>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
92117>>>        Move (Trim(sConnectionID)) to sConnectionID
92118>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
92119>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
92120>>>    End_Function
92121>>>
92121>>>    Function piConnectionOptions Returns Integer
92123>>>        Integer iValue
92123>>>        If (ghoSQLConnectionHandler = 0) Begin
92125>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92126>>>>
92126>>>            Function_Return
92127>>>        End
92127>>>>
92127>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
92128>>>        Function_Return iValue
92129>>>    End_Function
92130>>>
92130>>>    Procedure Set psSchema String sValue
92132>>>        tSQLConnection SQLConnection
92132>>>        tSQLConnection SQLConnection
92132>>>        If (ghoSQLConnectionHandler = 0) Begin
92134>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92135>>>>
92135>>>            Procedure_Return
92136>>>        End
92136>>>>
92136>>>        Set psSchema of ghoSQLConnectionHandler to sValue
92137>>>    End_Procedure
92138>>>
92138>>>    Function psSchema Returns String
92140>>>        String sRetval
92140>>>        If (ghoSQLConnectionHandler = 0) Begin
92142>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92143>>>>
92143>>>            Function_Return
92144>>>        End
92144>>>>
92144>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
92145>>>        Function_Return sRetval
92146>>>    End_Function
92147>>>
92147>>>    Procedure Set psBaseTableSpace String sValue
92149>>>        If (ghoSQLConnectionHandler = 0) Begin
92151>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92152>>>>
92152>>>            Procedure_Return
92153>>>        End
92153>>>>
92153>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
92154>>>    End_Procedure
92155>>>
92155>>>    Function psBaseTableSpace Returns String
92157>>>        String sRetval
92157>>>        If (ghoSQLConnectionHandler = 0) Begin
92159>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92160>>>>
92160>>>            Function_Return
92161>>>        End
92161>>>>
92161>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
92162>>>        Function_Return sRetval
92163>>>    End_Function
92164>>>
92164>>>    Procedure Set psLongTableSpace String sValue
92166>>>        If (ghoSQLConnectionHandler = 0) Begin
92168>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92169>>>>
92169>>>            Procedure_Return
92170>>>        End
92170>>>>
92170>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
92171>>>    End_Procedure
92172>>>
92172>>>    Function psLongTableSpace Returns String
92174>>>        String sRetval
92174>>>        If (ghoSQLConnectionHandler = 0) Begin
92176>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92177>>>>
92177>>>            Function_Return
92178>>>        End
92178>>>>
92178>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
92179>>>        Function_Return sRetval
92180>>>    End_Function
92181>>>
92181>>>    Procedure Set psIndexTableSpace String sValue
92183>>>        If (ghoSQLConnectionHandler = 0) Begin
92185>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92186>>>>
92186>>>            Procedure_Return
92187>>>        End
92187>>>>
92187>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
92188>>>    End_Procedure
92189>>>
92189>>>    Function psIndexTableSpace Returns String
92191>>>        String sRetval
92191>>>        If (ghoSQLConnectionHandler = 0) Begin
92193>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92194>>>>
92194>>>            Function_Return
92195>>>        End
92195>>>>
92195>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
92196>>>        Function_Return sRetval
92197>>>    End_Function
92198>>>
92198>>>    Procedure Set pbUseConnectionID Boolean bState
92200>>>        If (ghoSQLConnectionHandler = 0) Begin
92202>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92203>>>>
92203>>>            Procedure_Return
92204>>>        End
92204>>>>
92204>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
92205>>>    End_Procedure
92206>>>
92206>>>    Function pbUseConnectionID Returns Boolean
92208>>>        Boolean bState
92208>>>        If (ghoSQLConnectionHandler = 0) Begin
92210>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92211>>>>
92211>>>            Function_Return
92212>>>        End
92212>>>>
92212>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
92213>>>        Function_Return bState
92214>>>    End_Function
92215>>>
92215>>>    Procedure Set pbToANSI Boolean bState
92217>>>        If (ghoSQLConnectionHandler = 0) Begin
92219>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92220>>>>
92220>>>            Procedure_Return
92221>>>        End
92221>>>>
92221>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
92222>>>    End_Procedure
92223>>>
92223>>>    Function pbToANSI Returns Boolean
92225>>>        Boolean bState
92225>>>        If (ghoSQLConnectionHandler = 0) Begin
92227>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92228>>>>
92228>>>            Function_Return
92229>>>        End
92229>>>>
92229>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
92230>>>        Function_Return bState
92231>>>    End_Function
92232>>>
92232>>>    Procedure Set pbRecnum Boolean bState
92234>>>        If (ghoSQLConnectionHandler = 0) Begin
92236>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92237>>>>
92237>>>            Procedure_Return
92238>>>        End
92238>>>>
92238>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
92239>>>    End_Procedure
92240>>>
92240>>>    Function pbRecnum Returns Boolean
92242>>>        Boolean bState
92242>>>        If (ghoSQLConnectionHandler = 0) Begin
92244>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92245>>>>
92245>>>            Function_Return
92246>>>        End
92246>>>>
92246>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
92247>>>        Function_Return bState
92248>>>    End_Function
92249>>>
92249>>>    Procedure Set pbCopyData Boolean bState
92251>>>        If (ghoSQLConnectionHandler = 0) Begin
92253>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92254>>>>
92254>>>            Procedure_Return
92255>>>        End
92255>>>>
92255>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
92256>>>    End_Procedure
92257>>>
92257>>>    Function pbCopyData Returns Boolean
92259>>>        Boolean bState
92259>>>        If (ghoSQLConnectionHandler = 0) Begin
92261>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92262>>>>
92262>>>            Function_Return
92263>>>        End
92263>>>>
92263>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
92264>>>        Function_Return bState
92265>>>    End_Function
92266>>>
92266>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
92268>>>        If (ghoSQLConnectionHandler = 0) Begin
92270>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92271>>>>
92271>>>            Procedure_Return
92272>>>        End
92272>>>>
92272>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
92273>>>    End_Procedure
92274>>>
92274>>>    Function pbApiTableUpdateAuto Returns Boolean
92276>>>        Boolean bState
92276>>>        If (ghoSQLConnectionHandler = 0) Begin
92278>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92279>>>>
92279>>>            Function_Return
92280>>>        End
92280>>>>
92280>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
92281>>>        Function_Return bState
92282>>>    End_Function
92283>>>
92283>>>    Procedure Set pbCompareDate_DateTime Boolean bState
92285>>>        If (ghoSQLConnectionHandler = 0) Begin
92287>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92288>>>>
92288>>>            Procedure_Return
92289>>>        End
92289>>>>
92289>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
92290>>>    End_Procedure
92291>>>
92291>>>    Function pbCompareDate_DateTime Returns Boolean
92293>>>        Boolean bState
92293>>>        If (ghoSQLConnectionHandler = 0) Begin
92295>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92296>>>>
92296>>>            Function_Return
92297>>>        End
92297>>>>
92297>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
92298>>>        Function_Return bState
92299>>>    End_Function
92300>>>
92300>>>    Procedure Set pbCompareIndexAscending Boolean bState
92302>>>        If (ghoSQLConnectionHandler = 0) Begin
92304>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92305>>>>
92305>>>            Procedure_Return
92306>>>        End
92306>>>>
92306>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
92307>>>    End_Procedure
92308>>>
92308>>>    Function pbCompareIndexAscending Returns Boolean
92310>>>        Boolean bState
92310>>>        If (ghoSQLConnectionHandler = 0) Begin
92312>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92313>>>>
92313>>>            Function_Return
92314>>>        End
92314>>>>
92314>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
92315>>>        Function_Return bState
92316>>>    End_Function
92317>>>
92317>>>    Procedure Set pbCompareIndexUppercase Boolean bState
92319>>>        If (ghoSQLConnectionHandler = 0) Begin
92321>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92322>>>>
92322>>>            Procedure_Return
92323>>>        End
92323>>>>
92323>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
92324>>>    End_Procedure
92325>>>
92325>>>    Function pbCompareIndexUppercase Returns Boolean
92327>>>        Boolean bState
92327>>>        If (ghoSQLConnectionHandler = 0) Begin
92329>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92330>>>>
92330>>>            Function_Return
92331>>>        End
92331>>>>
92331>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
92332>>>        Function_Return bState
92333>>>    End_Function
92334>>>
92334>>>    Procedure Set psDriverDefaultValueASCII String sValue
92336>>>        If (ghoSQLConnectionHandler = 0) Begin
92338>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92339>>>>
92339>>>            Procedure_Return
92340>>>        End
92340>>>>
92340>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
92341>>>    End_Procedure
92342>>>
92342>>>    Function psDriverDefaultValueASCII Returns String
92344>>>        String sRetval
92344>>>        If (ghoSQLConnectionHandler = 0) Begin
92346>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92347>>>>
92347>>>            Function_Return
92348>>>        End
92348>>>>
92348>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
92349>>>        Function_Return sRetval
92350>>>    End_Function
92351>>>
92351>>>    Procedure Set psDriverDefaultValueBinary String sValue
92353>>>        If (ghoSQLConnectionHandler = 0) Begin
92355>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92356>>>>
92356>>>            Procedure_Return
92357>>>        End
92357>>>>
92357>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
92358>>>    End_Procedure
92359>>>
92359>>>    Function psDriverDefaultValueBinary Returns String
92361>>>        String sRetval
92361>>>        If (ghoSQLConnectionHandler = 0) Begin
92363>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92364>>>>
92364>>>            Function_Return
92365>>>        End
92365>>>>
92365>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
92366>>>        Function_Return sRetval
92367>>>    End_Function
92368>>>
92368>>>    Procedure Set psDriverDefaultValueDate String sValue
92370>>>        If (ghoSQLConnectionHandler = 0) Begin
92372>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92373>>>>
92373>>>            Procedure_Return
92374>>>        End
92374>>>>
92374>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
92375>>>    End_Procedure
92376>>>
92376>>>    Function psDriverDefaultValueDate Returns String
92378>>>        String sRetval
92378>>>        If (ghoSQLConnectionHandler = 0) Begin
92380>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92381>>>>
92381>>>            Function_Return
92382>>>        End
92382>>>>
92382>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
92383>>>        Function_Return sRetval
92384>>>    End_Function
92385>>>
92385>>>    Procedure Set psDriverDefaultValueDateTime String sValue
92387>>>        If (ghoSQLConnectionHandler = 0) Begin
92389>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92390>>>>
92390>>>            Procedure_Return
92391>>>        End
92391>>>>
92391>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
92392>>>    End_Procedure
92393>>>
92393>>>    Function psDriverDefaultValueDateTime Returns String
92395>>>        String sRetval
92395>>>        If (ghoSQLConnectionHandler = 0) Begin
92397>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92398>>>>
92398>>>            Function_Return
92399>>>        End
92399>>>>
92399>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
92400>>>        Function_Return sRetval
92401>>>    End_Function
92402>>>
92402>>>    Procedure Set psDriverDefaultValueNumeric String sValue
92404>>>        If (ghoSQLConnectionHandler = 0) Begin
92406>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92407>>>>
92407>>>            Procedure_Return
92408>>>        End
92408>>>>
92408>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
92409>>>    End_Procedure
92410>>>
92410>>>    Function psDriverDefaultValueNumeric Returns String
92412>>>        String sRetval
92412>>>        If (ghoSQLConnectionHandler = 0) Begin
92414>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92415>>>>
92415>>>            Function_Return
92416>>>        End
92416>>>>
92416>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
92417>>>        Function_Return sRetval
92418>>>    End_Function
92419>>>
92419>>>    Procedure Set psDriverDefaultValueText String sValue
92421>>>        If (ghoSQLConnectionHandler = 0) Begin
92423>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92424>>>>
92424>>>            Procedure_Return
92425>>>        End
92425>>>>
92425>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
92426>>>    End_Procedure
92427>>>
92427>>>    Function psDriverDefaultValueText Returns String
92429>>>        String sRetval
92429>>>        If (ghoSQLConnectionHandler = 0) Begin
92431>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92432>>>>
92432>>>            Function_Return
92433>>>        End
92433>>>>
92433>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
92434>>>        Function_Return sRetval
92435>>>    End_Function
92436>>>
92436>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
92438>>>        If (ghoSQLConnectionHandler = 0) Begin
92440>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92441>>>>
92441>>>            Procedure_Return
92442>>>        End
92442>>>>
92442>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
92443>>>    End_Procedure
92444>>>
92444>>>    Function pbDriverDefaultNullableASCII Returns Boolean
92446>>>        Boolean bState
92446>>>        If (ghoSQLConnectionHandler = 0) Begin
92448>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92449>>>>
92449>>>            Function_Return
92450>>>        End
92450>>>>
92450>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
92451>>>        Function_Return bState
92452>>>    End_Function
92453>>>
92453>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
92455>>>        If (ghoSQLConnectionHandler = 0) Begin
92457>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92458>>>>
92458>>>            Procedure_Return
92459>>>        End
92459>>>>
92459>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
92460>>>    End_Procedure
92461>>>
92461>>>    Function pbDriverDefaultNullableBinary Returns Boolean
92463>>>        Boolean bState
92463>>>        If (ghoSQLConnectionHandler = 0) Begin
92465>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92466>>>>
92466>>>            Function_Return
92467>>>        End
92467>>>>
92467>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
92468>>>        Function_Return bState
92469>>>    End_Function
92470>>>
92470>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
92472>>>        If (ghoSQLConnectionHandler = 0) Begin
92474>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92475>>>>
92475>>>            Procedure_Return
92476>>>        End
92476>>>>
92476>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
92477>>>    End_Procedure
92478>>>
92478>>>    Function pbDriverDefaultNullableDate Returns Boolean
92480>>>        Boolean bState
92480>>>        If (ghoSQLConnectionHandler = 0) Begin
92482>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92483>>>>
92483>>>            Function_Return
92484>>>        End
92484>>>>
92484>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
92485>>>        Function_Return bState
92486>>>    End_Function
92487>>>
92487>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
92489>>>        If (ghoSQLConnectionHandler = 0) Begin
92491>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92492>>>>
92492>>>            Procedure_Return
92493>>>        End
92493>>>>
92493>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
92494>>>    End_Procedure
92495>>>
92495>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
92497>>>        Boolean bState
92497>>>        If (ghoSQLConnectionHandler = 0) Begin
92499>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92500>>>>
92500>>>            Function_Return
92501>>>        End
92501>>>>
92501>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
92502>>>        Function_Return bState
92503>>>    End_Function
92504>>>
92504>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
92506>>>        If (ghoSQLConnectionHandler = 0) Begin
92508>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92509>>>>
92509>>>            Procedure_Return
92510>>>        End
92510>>>>
92510>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
92511>>>    End_Procedure
92512>>>
92512>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
92514>>>        Boolean bState
92514>>>        If (ghoSQLConnectionHandler = 0) Begin
92516>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92517>>>>
92517>>>            Function_Return
92518>>>        End
92518>>>>
92518>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
92519>>>        Function_Return bState
92520>>>    End_Function
92521>>>
92521>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
92523>>>        If (ghoSQLConnectionHandler = 0) Begin
92525>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92526>>>>
92526>>>            Procedure_Return
92527>>>        End
92527>>>>
92527>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
92528>>>    End_Procedure
92529>>>
92529>>>    Function pbDriverDefaultNullableText Returns Boolean
92531>>>        Boolean bState
92531>>>        If (ghoSQLConnectionHandler = 0) Begin
92533>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92534>>>>
92534>>>            Function_Return
92535>>>        End
92535>>>>
92535>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
92536>>>        Function_Return bState
92537>>>    End_Function
92538>>>
92538>>>    // Note: If the psDriverID + other connection properties are to be changed,
92538>>>    //       the psDriverID *must* be the first property that gets changed!
92538>>>    //       Otherwise errors might be raised by the driver when e.g. the format
92538>>>    //       for a connection string has the wrong format for that driver.
92538>>>    Procedure Set psDriverID String sValue
92540>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92541>>>        Delegate Set psDriverID to sValue
92543>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92544>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
92545>>>    End_Procedure
92546>>>
92546>>>    Function psDriverID Returns String
92548>>>        String sDriverID
92548>>>
92548>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92549>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
92549>>>        Delegate Get psDriverID to sDriverID
92551>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92552>>>        Move False to Err
92553>>>
92553>>>        // ...and in case it didn't use property of this class. Then the library is
92553>>>        // probably used as "utilites" from a special made program and
92553>>>        // the ghoSQLConnectionHandler must have been setup
92553>>>        If (sDriverID = "") Begin
92555>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
92556>>>        End
92556>>>>
92556>>>        Function_Return sDriverID
92557>>>    End_Function
92558>>>
92558>>>    Procedure Set piDbType Integer iValue
92560>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92561>>>        Delegate Set piDbType to iValue
92563>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92564>>>        Set piDbType of ghoSQLConnectionHandler to iValue
92565>>>    End_Procedure
92566>>>
92566>>>    Function piDbType Returns Integer
92568>>>        Integer iRetval
92568>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
92569>>>        Function_Return iRetval
92570>>>    End_Function
92571>>>
92571>>>    Function phoLogFile Returns Handle
92573>>>        Handle hoLogFile   
92573>>>        Boolean bErr
92573>>>        
92573>>>        Move Err to bErr
92574>>>        Move 0 to hoLogFile
92575>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
92576>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92577>>>        Delegate Get phoLogFile to hoLogFile
92579>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92580>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92581>>>        Move bErr to Err
92582>>>        
92582>>>        Function_Return hoLogFile
92583>>>    End_Function
92584>>>
92584>>>    Function pnCurrentVersionUpdate Returns Number
92586>>>        Number nCurrentVersionUpdate
92586>>>
92586>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92587>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
92589>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92590>>>
92590>>>        Function_Return nCurrentVersionUpdate
92591>>>    End_Function
92592>>>
92592>>>    Procedure LogError String sText Boolean bError
92594>>>        Handle hoLogFile
92594>>>        Number nCurrentVersionUpdate
92594>>>
92594>>>        Get phoLogFile to hoLogFile
92595>>>        If (hoLogFile = 0) Begin
92597>>>            Procedure_Return
92598>>>        End
92598>>>>
92598>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
92599>>>
92599>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92600>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
92601>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92602>>>    End_Procedure
92603>>>
92603>>>    Function pbContinueOnError Returns Boolean
92605>>>        Boolean bContinueOnError
92605>>>        If (ghoDbUpdateHandler > 0) Begin
92607>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
92608>>>        End
92608>>>>
92608>>>        Function_Return bContinueOnError
92609>>>    End_Function
92610>>>
92610>>>    // Latin1_General_CI_AS = General Insensitive collation
92610>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
92610>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
92610>>>    // Good read about which collation to select:
92610>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
92610>>>    Procedure Set psCollation String sCollation
92612>>>        Set private.psCollation to sCollation
92613>>>        If (ghoDbUpdateHandler > 0) Begin
92615>>>            Set psCollation of ghoDbUpdateHandler to sCollation
92616>>>        End
92616>>>>
92616>>>    End_Procedure
92617>>>
92617>>>    Function psCollation Returns String
92619>>>        String sCollation
92619>>>        If (ghoDbUpdateHandler > 0) Begin
92621>>>            Get psCollation of ghoDbUpdateHandler to sCollation
92622>>>        End   
92622>>>>
92622>>>        Else Begin
92623>>>            Get private.psCollation to sCollation
92624>>>        End
92624>>>>
92624>>>        Function_Return sCollation
92625>>>    End_Function
92626>>>
92626>>>
92626>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer
92628>>>        Integer iMax iPos
92628>>>        String sName
92628>>>
92628>>>        Move (Lowercase(sField)) to sField
92629>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
92632>>>        for iPos from 0 to iMax
92638>>>>
92638>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
92641>>>            Move (Lowercase(sName)) to sName
92642>>>            If (sName = sField) Begin
92644>>>                Function_Return iPos
92645>>>            End
92645>>>>
92645>>>        Loop
92646>>>>
92646>>>        Function_Return -1
92647>>>    End_Function
92648>>>
92648>>>
92648>>>    // * Dummy function for the Studio's Code Explorer *
92648>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
92650>>>        Function_Return False
92651>>>    End_Function
92652>>>
92652>>>    // *** Helper functions with compiled sql script code ***
92652>>>    //
92652>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
92652>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
92652>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
92652>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
92652>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
92652>>>    //   ALTER TABLE MyTable
92652>>>    //       REBUILD
92652>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
92654>>>        Boolean bOK
92654>>>
92654>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
92656>>>            Function_Return False
92657>>>        End
92657>>>>
92657>>>
92657>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
92657>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
92658>>>
92658>>>        Function_Return (bOK = True)
92659>>>    End_Function
92660>>>
92660>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
92660>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
92660>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
92660>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
92660>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
92660>>>    //   ALTER TABLE MyTable
92660>>>    //       REBUILD
92660>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
92662>>>        tSQLScriptArray SQLScriptArray
92662>>>        tSQLScriptArray SQLScriptArray
92662>>>        String sDriverID
92662>>>        Boolean bOK
92662>>>        Integer iSize iCount
92662>>>
92662>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
92664>>>            Function_Return False
92665>>>        End
92665>>>>
92665>>>
92665>>>        Get psDriverID to sDriverID
92666>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
92667>>>        If (SQLScriptArray.bError = True) Begin
92669>>>            Function_Return False
92670>>>        End
92670>>>>
92670>>>
92670>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
92671>>>        Decrement iSize
92672>>>
92672>>>        for iCount from 0 to iSize
92678>>>>
92678>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
92680>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
92681>>>            End
92681>>>>
92681>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
92683>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
92684>>>            End
92684>>>>
92684>>>        Loop
92685>>>>
92685>>>
92685>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
92686>>>
92686>>>        Function_Return (bOK = True)
92687>>>    End_Function
92688>>>
92688>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
92690>>>        tSQLScriptArray SQLScriptArray
92690>>>        tSQLScriptArray SQLScriptArray
92690>>>        String sDriverID sCollation
92690>>>        Boolean bOK
92690>>>        Integer iSize iCount
92690>>>
92690>>>        If (Trim(sDatabaseName) = "") Begin
92692>>>            Function_Return False
92693>>>        End
92693>>>>
92693>>>
92693>>>        Get psDriverID  to sDriverID
92694>>>        Get psCollation to sCollation
92695>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
92696>>>        If (SQLScriptArray.bError = True) Begin
92698>>>            Function_Return False
92699>>>        End
92699>>>>
92699>>>
92699>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
92700>>>        Decrement iSize
92701>>>
92701>>>        for iCount from 0 to iSize
92707>>>>
92707>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
92709>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
92710>>>            End
92710>>>>
92710>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
92712>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
92713>>>            End
92713>>>>
92713>>>        Loop
92714>>>>
92714>>>
92714>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
92715>>>
92715>>>        Function_Return (bOK = True)
92716>>>    End_Function
92717>>>
92717>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
92719>>>        tSQLScriptArray SQLScriptArray
92719>>>        tSQLScriptArray SQLScriptArray
92719>>>        String sDriverID sCollation
92719>>>        Boolean bOK
92719>>>        Integer iSize iCount
92719>>>
92719>>>        If (Trim(sDatabaseName) = "") Begin
92721>>>            Function_Return False
92722>>>        End
92722>>>>
92722>>>
92722>>>        Get psDriverID  to sDriverID
92723>>>        Get psCollation to sCollation
92724>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
92725>>>        If (SQLScriptArray.bError = True) Begin
92727>>>            Function_Return False
92728>>>        End
92728>>>>
92728>>>
92728>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
92729>>>        Decrement iSize
92730>>>
92730>>>        for iCount from 0 to iSize
92736>>>>
92736>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
92738>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
92739>>>            End
92739>>>>
92739>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
92741>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
92742>>>            End
92742>>>>
92742>>>        Loop
92743>>>>
92743>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
92743>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
92744>>>
92744>>>        Function_Return (bOK = True)
92745>>>    End_Function
92746>>>
92746>>>    // *** Helper functions for Mertech Drivers ***
92746>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
92746>>>    // and commands that the Studio editor knows nothing about.
92746>>>    Function _MertechDeleteTDFile String sTableName Returns Boolean
92748>>>        Integer iRetval
92748>>>        String sPath
92748>>>
92748>>>        If (sPath = "" or sTableName = "") Begin
92750>>>            Function_Return True
92751>>>        End
92751>>>>
92751>>>
92751>>>        Get vFolderFormat sPath to sPath
92752>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
92753>>>        Function_Return (iRetval = 0)
92754>>>    End_Function
92755>>>
92755>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sTableName String sDataPath String sPhysicalFileName Returns Boolean
92757>>>        Boolean bOpen bOK
92757>>>        Move False to Err
92758>>>        Function_Return (Err = False)
92759>>>    End_Function
92760>>>
92760>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
92762>>>        Integer iNumItems iCount
92762>>>        String[] sReturnArray
92763>>>        String sServer
92763>>>
92763>>>
92763>>>        Function_Return sReturnArray
92764>>>    End_Function
92765>>>
92765>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
92767>>>        String[] sReturnArray
92768>>>        String sServer
92768>>>
92768>>>
92768>>>        Function_Return sReturnArray
92769>>>    End_Function
92770>>>
92770>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
92772>>>        Handle hoSQLHandler hoSQLConnect
92772>>>
92772>>>        Move 0 to hoSQLConnect
92773>>>
92773>>>        Function_Return hoSQLConnect
92774>>>    End_Function
92775>>>
92775>>>    // Returns the handle of the Mertech SQL handler.
92775>>>    // It also ensures that the correct Server & Database attributes are set both for
92775>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
92775>>>    Function _MertechSQLManagerHandle Returns Handle
92777>>>        Handle hoSQLHandler
92777>>>        String sDriverID sServer sDatabase
92777>>>
92777>>>        Move 0 to hoSQLHandler
92778>>>        Get psDriverID to sDriverID
92779>>>        Get psServer   to sServer
92780>>>        Get psDatabase to sDatabase
92781>>>
92781>>>        Function_Return hoSQLHandler
92782>>>    End_Function
92783>>>
92783>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
92783>>>    // macro-commands <sigh!>
92783>>>    // Note: The function sets the Err flag.
92783>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bToAnsi Boolean bCopyData Returns Boolean
92785>>>
92785>>>        Move False to Err
92786>>>
92786>>>        Function_Return (Err = False)
92787>>>    End_Function
92788>>>
92788>>>    Function _MertechCopyDataToSQL Handle hTable String sRootName String sDriverID Returns Boolean
92790>>>        Move False to Err
92791>>>        Function_Return (Err = False)
92792>>>    End_Function
92793>>>
92793>>>End_Class
92794>Use AddToStudio.dg
Including file: AddToStudio.dg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\AddToStudio.dg)
92794>>>Use Windows.pkg
92794>>>Use Dfspnfrm.pkg
92794>>>Use cRegistry.pkg
92794>>>Use vWin32fh.pkg
92794>>>
92794>>>Enum_List
92794>>>    Define cx_RegKeyAlreadyExist
92794>>>    Define cx_RegKeyCreated
92794>>>    Define cx_RegkeyFailed
92794>>>    Define cx_RegKeyVDFKeyDoesNotExist
92794>>>    Define CX_InstalledOkVdfUnder16
92794>>>End_Enum_List
92794>>>
92794>>>// Note: The "Visual" part will automatically be removed if
92794>>>// the current DataFlex version is above 17.
92794>>>Define CS_StudioPath        for "Software\Data Access Worldwide\Visual DataFlex Tools\"
92794>>>Define CS_StudioTools       for "\Studio\Tools"
92794>>>Define CS_RegApplication    for "<application>"
92794>>>Define CS_RegWorkspace      for "<workspace>"
92794>>>Define CS_CommandLine       for "CommandLine"
92794>>>Define CS_Name              for "Name"
92794>>>Define CS_Separator         for "Separator"
92794>>>Define CS_Command           for "Command"
92794>>>
92794>>>Object oAddToStudio_dg is a ModalPanel
92796>>>    Set Size to 79 330
92797>>>    Set Label to "Add Program To DataFlex Studio's Tools Menu"
92798>>>    Set piMinSize to 79 211
92799>>>    Set Location to 5 4
92800>>>    Set Locate_Mode to Center_On_Parent
92801>>>
92801>>>    Property String psTag CS_RegApplication
92803>>>
92803>>>    Object oStudioIntegration_grp is a Group
92805>>>        Set Size to 45 299
92806>>>        Set Location to 8 15
92807>>>        Set Label to "DataFlex Studio Integration"
92808>>>
92808>>>        Object oStudioMajorVersion_sf is a SpinForm
92810>>>            Set Size to 12 27
92811>>>            Set Location to 18 168
92812>>>            Set Maximum_Position to 30
92813>>>            Set Minimum_Position to 14
92814>>>            Set Label_Col_Offset to 2
92815>>>            Set Label_Justification_Mode to JMode_Right
92816>>>            Set Label to "Add to Studio's Tools Menu:     Major Version"
92817>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
92818>>>            Set Value to FMAC_VERSION
92819>>>            Set peAnchors to anNone
92820>>>        End_Object
92821>>>
92821>>>        Object oStudioMinorVersion_sf is a SpinForm
92823>>>            Set Size to 12 27
92824>>>            Set Location to 18 254
92825>>>            Set Label_Col_Offset to 2
92826>>>            Set Label to "Minor Version"
92827>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
92828>>>            Set Maximum_Position to 9
92829>>>            Set Minimum_Position to 0
92830>>>            Set Value to FMAC_REVISION
92831>>>            Set Label_Justification_Mode to JMode_Right
92832>>>            Set peAnchors to anNone
92833>>>        End_Object
92834>>>
92834>>>    End_Object
92835>>>
92835>>>    Object oOK_btn is a Button
92837>>>        Set Location to 59 207
92838>>>        Set Label to "Add Now"
92839>>>        Set Status_Help to "Add to DataFlex Studio's Tools menu. The Studio version can be selected with the two spinforms. The program gets added to the Studios Tools menu."
92840>>>        Set peAnchors to anTopRight
92841>>>
92841>>>        Procedure OnClick
92844>>>            Integer iRetval iMajorVersion iMinorVersion
92844>>>            String sText sStudioVersion
92844>>>            Get Value of oStudioMajorVersion_sf to iMajorVersion
92845>>>            Get Value of oStudioMinorVersion_sf to iMinorVersion
92846>>>            Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
92847>>>            Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
92848>>>            Case Begin
92848>>>                Case (iRetval = cx_RegKeyAlreadyExist)
92850>>>                    Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
92851>>>                    Break
92852>>>                Case (iRetval = cx_RegKeyCreated)
92855>>>                    Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
92856>>>                    Break
92857>>>                Case (iRetval = cx_RegkeyFailed)
92860>>>                    Move "Failed. Could not create the registry key for adding the program to the DataFlex Studio's Tools menu." to sText
92861>>>                    Break
92862>>>                Case (iRetval = cx_RegKeyVDFKeyDoesNotExist)
92865>>>                    Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
92866>>>                    Break
92867>>>                Case (iRetval = CX_InstalledOkVdfUnder16)
92870>>>                    Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed for an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
92871>>>                    Break
92872>>>            Case End
92872>>>
92872>>>            Send Info_Box sText
92873>>>        End_Procedure
92874>>>    End_Object
92875>>>
92875>>>    Object oCancel_Btn is a Button
92877>>>        Set Label to C_$Close
92878>>>        Set Location to 59 264
92879>>>        Set peAnchors to anBottomRight
92880>>>
92880>>>        Procedure OnClick
92883>>>            Send Close_Panel
92884>>>        End_Procedure
92885>>>
92885>>>    End_Object
92886>>>
92886>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
92889>>>        Boolean bOk bExists bOpen
92889>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath
92889>>>        Handle hoReg hoArray
92889>>>        Integer i iItems iCreated iRetval
92889>>>
92889>>>        Move False to bOk
92890>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
92891>>>        If (sStudioVersion > "17.1") Begin
92893>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
92894>>>        End
92894>>>>
92894>>>
92894>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
92895>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
92896>>>        Get vFolderFormat sProgramPath to sProgramPath
92897>>>        Get psProduct     of (phoWorkspace(ghoApplication)) to sProduct
92898>>>        Get Module_Name to sProgram
92899>>>        Get Create (RefClass(cRegistry)) to hoReg
92900>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
92901>>>
92901>>>        // First check if the VDF version is installed
92901>>>        Get KeyExists of hoReg sStudioPath to bExists
92902>>>        If (bExists = False) Begin
92904>>>            Send Destroy of hoReg
92905>>>            Function_Return cx_RegKeyVDFKeyDoesNotExist
92906>>>        End
92906>>>>
92906>>>
92906>>>        // Then check if any tools have been installed in the Tools Menu.
92906>>>        // If no tools created yet, create the Tools registry key.
92906>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
92907>>>        Get KeyExists of hoReg sStudioPath to bExists
92908>>>        If (bExists = False) Begin
92910>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
92911>>>            Get CreateKey of hoReg sStudioPath to iCreated
92912>>>            If (iCreated <> 0) Begin
92914>>>                Move cx_RegkeyFailed to iRetval
92915>>>            End
92915>>>>
92915>>>            Else Begin
92916>>>                Move True to bExists
92917>>>            End
92917>>>>
92917>>>        End
92917>>>>
92917>>>
92917>>>        If (bExists = True) Begin
92919>>>            Get OpenKey of hoReg sStudioPath to bOk
92920>>>            If (bOk = True) Begin
92922>>>                Get Create (RefClass(Array)) to hoArray
92923>>>                Get GetSubkeys of hoReg hoArray to iItems
92924>>>                Decrement iItems
92925>>>                Move False to bExists
92926>>>                Set pfAccessRights of hoReg to KEY_READ
92927>>>                // Check if the key already exists:
92927>>>                For i from 0 to iItems
92933>>>>
92933>>>                    Get Value of hoArray i to sKey
92934>>>                    Move (sStudioPath + "\" + sKey) to sKey
92935>>>                    Get OpenKey of hoReg sKey to bOpen
92936>>>                    If (bOpen = True) Begin
92938>>>                        Get ReadString of hoReg CS_Name to sValue
92939>>>                        If (sValue = sProduct) Begin
92941>>>                            Move True to bExists
92942>>>                        End
92942>>>>
92942>>>                    End
92942>>>>
92942>>>                Loop
92943>>>>
92943>>>                Send Destroy of hoArray
92944>>>                If (bExists = False) Begin
92946>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
92947>>>                    // We need to create the next key number:
92947>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
92947>>>                    Increment iItems
92948>>>                    Increment iItems
92949>>>                    Get CreateKey of hoReg (sStudioPath + "\" + String(iItems)) to iCreated
92950>>>                    If (iCreated = 0) Begin
92952>>>                        Send WriteString of hoReg CS_Name sProduct
92953>>>                        // From DataFlex 16 and up the params for the Studio's Tools menu changed slightly:
92953>>>                        If (sStudioVersion >= "16.0") Begin
92955>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
92956>>>                            Send WriteString of hoReg CS_CommandLine (psTag(Self))
92957>>>                        End
92957>>>>
92957>>>                        Else Begin
92958>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * psTag(Self))
92959>>>                            Move CX_InstalledOkVdfUnder16 to iRetval
92960>>>                        End
92960>>>>
92960>>>                        Send WriteDword  of hoReg CS_Separator 1
92961>>>                        Move cx_RegKeyCreated to iRetval
92962>>>                    End
92962>>>>
92962>>>                    Else Begin
92963>>>                        Move cx_RegkeyFailed to iRetval
92964>>>                    End
92964>>>>
92964>>>                End
92964>>>>
92964>>>                Else Begin
92965>>>                    Move cx_RegKeyAlreadyExist to iRetval
92966>>>                End
92966>>>>
92966>>>                Send CloseKey of hoReg
92967>>>            End
92967>>>>
92967>>>        End
92967>>>>
92967>>>
92967>>>        Send Destroy of hoReg
92968>>>        Function_Return iRetval
92969>>>    End_Function
92970>>>
92970>>>    Procedure Page Integer iPageObject
92973>>>        Forward Send Page iPageObject
92975>>>        Set Icon to "ActionAddStudio1.ico"
92976>>>    End_Procedure
92977>>>
92977>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
92978>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
92979>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
92980>>>End_Object
92981>Set psTag of (oAddToStudio_dg(Self)) to CS_RegWorkspace
92982>
92982>Object oCreateDbVersionTable_pnl is a BasicPanel
92984>    Set Location to 1 0
92985>    Set Size to 204 398
92986>    Set Locate_Mode to Center_On_Screen
92987>    Set Label to (psProduct(ghoApplication))
92988>    Set Icon to "ActionCreateDatabase1.ico"
92989>    Set pbAcceptDropFiles to True
92990>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
92991>    Set Maximize_Icon to False
92992>
92992>    Property Handle phoDialogCommandbar
92994>
92994>    Object oDbUpdateFunctionLibrary is a cDbUpdateFunctionLibrary
92996>    End_Object
92997>
92997>    Object oWarning_Do_Not_Use_tb is a TextBox
92999>        Set Auto_Size_State to False
93000>        Set Size to 35 331
93001>        Set Location to 6 27
93002>        Set Label to "You should NOT use this program (From DUF 2.0 and up). The DbVersion table will be automatically created by setting three properties; piDbVersionFileNumber, piDbVersionFieldNumber and pbAutoCreateDbVersionTable properties in the cDbUpdateHandler object!"
93003>        Set Justification_Mode to JMode_Left
93004>        Set FontWeight to fw_Bold
93005>    End_Object
93006>
93006>    Object oGeneralInfo_tb is a TextBox
93008>        Set Auto_Size_State to False
93009>        Set Size to 25 342
93010>        Set Location to 47 27
93011>        Set Label to "Utility to create a system table and a column to keep the database update version to be used for the Entry_Item in the cDbUpdateHandler object. There is also a function 'SQLUtilCreateDbVersionTable' for creating it as a SQL table at customer site."
93012>        Set Justification_Mode to JMode_Left
93013>        Set FontItalics to True
93014>    End_Object
93015>
93015>    Object oLineControl is a LineControl
93017>        Set Size to 2 374
93018>        Set Location to 75 12
93019>        Set peAnchors to anTopLeftRight
93020>    End_Object
93021>
93021>    Object oFileList_fm is a Form
93023>        Set Size to 13 246
93024>        Set Location to 89 27
93025>        Set Label to "Filelist.cfg:     (You can drop a Filelist.cfg here)"
93026>        Set Label_Col_Offset to 0
93027>        Set Label_Justification_Mode to JMode_Top
93028>        Set peAnchors to anTopLeftRight
93029>        Set Enabled_State to False
93030>        Set Label_Row_Offset to 1
93031>        Set FontWeight to fw_Bold
93032>
93032>        Procedure Prompt
93035>            String sValue sPath sFilelistName sFileMask
93035>            Get Value to sValue
93036>
93036>            Move (Trim(sValue)) to sValue
93037>            If (sValue <> "") Begin
93039>                Get ParseFolderName sValue to sPath
93040>            End
93040>
93040>            Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
93041>            Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sFilelistName
93042>            If (sFilelistName <> "") Begin
93044>                Set Value to sFilelistName
93045>            End
93045>        End_Procedure
93046>
93046>        Procedure OnChange
93049>            String sFilelistName sPath sOpenPath sDataPath sDdSrcPath sHomeFolder
93049>            Handle hTable
93049>            Boolean bExists
93049>
93049>            Get psOpenPath of ghoApplication to sOpenPath
93050>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93051>            If (sOpenPath contains sDataPath) Begin
93053>                Move (Replace((sDataPath + "\;"), sOpenPath, "")) to sOpenPath
93054>            End
93054>
93054>            Get Value to sFilelistName
93055>            // This might be true if there was no .ws file on startup.
93055>            If (sFilelistName = "") Begin
93057>                Send Prompt
93058>                Procedure_Return
93059>            End
93059>            Get ParseFolderName sFilelistName to sPath
93060>            If (Right(sPath, 1) ="\") Begin
93062>                Move (Left(sPath, Length(sPath) -1)) to sPath
93063>            End
93063>            If (sPath = "") Begin
93065>                Procedure_Return
93066>            End
93066>            Set_Directory sPath
93067>
93067>            Set_Attribute DF_OPEN_PATH to (sPath + ";" + sOpenPath)
93070>            Set_Attribute DF_FILELIST_NAME to sFilelistName
93073>            // Change output folder so files are written to the correct Data folder.
93073>            // For some reason the psDataPath isn't used by default by the Structure_End command.
93073>
93073>            Set psDataPath of (phoWorkspace(ghoApplication))  to sPath
93074>            Set psFileList of (phoWorkspace(ghoApplication))  to sFilelistName
93075>
93075>            // We also need to output the .fd file if in development environment.
93075>            Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDdSrcPath
93076>            If (not(sOpenPath contains sDdSrcPath)) Begin
93078>                Get ExtractFilePath of (phoWorkspace(ghoApplication)) sPath to sHomeFolder
93079>                Move (Append(sHomeFolder, "DdSrc")) to sDdSrcPath
93080>                Get vFolderExists sDdSrcPath to bExists
93081>                If (bExists = True) Begin
93083>                    Set psDdSrcPath of (phoWorkspace(ghoApplication)) to sDdSrcPath
93084>                End
93084>            End
93084>            Move 0 to hTable
93085>            Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
93088>            Set Value of oTableNo_sf to hTable
93089>        End_Procedure
93090>
93090>        Procedure Activating
93093>            String sFilelistName
93093>            Forward Send Activating
93095>            Get psFilelistName of ghoApplication to sFilelistName
93096>            Set Value to sFilelistName
93097>        End_Procedure
93098>
93098>    End_Object
93099>
93099>    Object oSelect_btn is a Button
93101>        Set Size to 13 61
93102>        Set Location to 89 309
93103>        Set Label to "Select..."
93104>        Set psToolTip to "Select a Filelist.cfg from a Data folder where an embedded DbVersion table should be created."
93105>        Set peAnchors to anTopRight
93106>
93106>        Procedure OnClick
93109>            Send Prompt of oFileList_fm
93110>        End_Procedure
93111>
93111>    End_Object
93112>
93112>    Object oTableName_fm is a Form
93114>        Set Size to 13 100
93115>        Set Location to 125 27
93116>        Set Label to "Table Name:"
93117>        Set Label_Col_Offset to 0
93118>        Set Label_Row_Offset to 1
93119>        Set Label_Justification_Mode to JMode_Top
93120>        Set Enabled_State to False
93121>        Set Value to "DbVersion"
93122>    End_Object
93123>
93123>    Object oColumnName_fm is a Form
93125>        Set Size to 13 84
93126>        Set Location to 125 133
93127>        Set Label to "Column Name:"
93128>        Set Label_Col_Offset to 0
93129>        Set Label_Row_Offset to 1
93130>        Set Label_Justification_Mode to JMode_Top
93131>        Set Enabled_State to False
93132>        Set Value to "DatabaseVersion"
93133>    End_Object
93134>
93134>    Object oDataType_cf is a ComboForm
93136>        Set Size to 11 63
93137>        Set Location to 125 225
93138>        Set Label to "Data Type:"
93139>        Set Label_Col_Offset to 0
93140>        Set Label_Row_Offset to 1
93141>        Set Label_Justification_Mode to JMode_Top
93142>        Set Entry_State to False
93143>        Set Enabled_State to False
93144>
93144>        Procedure Combo_Fill_List
93147>            tColumnType[] ColumnTypeArray
93147>            tColumnType[] ColumnTypeArray
93148>            Integer iSize iCount
93148>
93148>            Send Delete_Data
93149>            Get UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
93150>            Move (SizeOfArray(ColumnTypeArray)) to iSize
93151>            Decrement iSize
93152>            For iCount from 0 to iSize
93158>                Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
93159>            Loop
93160>            Set Value to "NUMERIC"
93161>            Set Enabled_State of oLength_sf to False
93162>            Set Enabled_State of oDecimals_sf to False
93163>            Set Value of oLength_sf   to 4
93164>            Set Value of oDecimals_sf to 2
93165>        End_Procedure
93166>
93166>        Procedure OnChange
93169>            Integer iDataType iSize iDec
93169>            Boolean bFixed
93169>
93169>            Get SelectedType to iDataType
93170>            Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iDataType to iSize
93171>            Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iDataType to iDec
93172>            Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iDataType to bFixed
93173>            Set Enabled_State of oLength_sf   to (bFixed = False)
93174>            Set Enabled_State of oDecimals_sf to (bFixed = False)
93175>            Set Value of oLength_sf to iSize
93176>            If (iDec = 0) Begin
93178>                Set Value of oDecimals_sf to ""
93179>            End
93179>            Else Begin
93180>                Set Value of oDecimals_sf to iDec
93181>            End
93181>            If (bFixed = False) Begin
93183>                Set Enabled_State of oDecimals_sf to (iDec <> 0)
93184>            End
93184>        End_Procedure
93185>
93185>        Function SelectedType Returns Integer
93188>            String sDataType
93188>            Integer iDataType
93188>
93188>            Get Value to sDataType
93189>            Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sDataType to iDataType
93190>
93190>            Function_Return iDataType
93191>        End_Function
93192>
93192>    End_Object
93193>
93193>    Object oLength_sf is a SpinForm
93195>        Set Label to "Length:"
93196>        Set Size to 13 38
93197>        Set Location to 125 297
93198>        Set Label_Col_Offset to 0
93199>        Set Label_Justification_Mode to JMode_Top
93200>        Set Label_Row_Offset to 1
93201>        Set Value to "4"
93202>        Set Maximum_Position to 50
93203>        Set Minimum_Position to 1
93204>        Set Enabled_State to False
93205>    End_Object
93206>
93206>    Object oDecimals_sf is a SpinForm
93208>        Set Label to "Decimals:"
93209>        Set Size to 13 33
93210>        Set Location to 125 344
93211>        Set Label_Col_Offset to 0
93212>        Set Label_Justification_Mode to JMode_Top
93213>        Set Label_Row_Offset to 1
93214>        Set Value to "2"
93215>        Set Maximum_Position to 8
93216>        Set Minimum_Position to 1
93217>        Set Enabled_State to False
93218>    End_Object
93219>
93219>    Object oTableNo_sf is a SpinForm
93221>        Set Label to "Filelist No:"
93222>        Set psToolTip to "When a new Filelist.cfg is selected, the first free slot number will be shown here."
93223>        Set Size to 13 32
93224>        Set Location to 155 27
93225>        Set Label_Col_Offset to 0
93226>        Set Label_Justification_Mode to JMode_Top
93227>        Set Label_Row_Offset to 1
93228>        Set Value to "2"
93229>        Set Maximum_Position to 4095
93230>        Set Minimum_Position to 1
93231>    End_Object
93232>
93232>    Object oFilelistInfo_tb is a TextBox
93234>        Set Size to 9 138
93235>        Set Location to 157 64
93236>        Set Label to "Default is to use the first free Filelist.cfg slot"
93237>    End_Object
93238>
93238>    Object oUseDefaults_cb is a CheckBox
93240>        Set Size to 10 50
93241>        Set Location to 157 225
93242>        Set Label to "Change Defaults"
93243>        Set psToolTip to "You REALLY have to know what you're doing if you want to change the defaults! Leave them as is if you are not 100% sure."
93244>
93244>        Procedure OnChange
93247>            Boolean bChecked
93247>
93247>            Get Checked_State to bChecked
93248>            Set Enabled_State of oTableName_fm  to (bChecked = True)
93249>            Set Enabled_State of oColumnName_fm to (bChecked = True)
93250>            Set Enabled_State of oDataType_cf   to (bChecked = True)
93251>            Set Enabled_State of oLength_sf     to (bChecked = True)
93252>            Set Enabled_State of oDecimals_sf   to (bChecked = True)
93253>        End_Procedure
93254>
93254>    End_Object
93255>
93255>    Object oCreateTable_btn is a Button
93257>        Set Size to 14 54
93258>        Set Location to 155 309
93259>        Set Label to "Create Table"
93260>        Set FontWeight to fw_Bold
93261>        Property String psToolTip1 "This will create a table & column for the Embedded database, to be used with the DataFlex Update Framework."
93263>        Property String psToolTip2 "There is also a 'SQLUtilCreateDbVersionTable' function that can be used to create/move the Table at customer site to SQL."
93265>        Set psToolTip to (psToolTip1(Self) + psToolTip2(Self))
93266>
93266>        Procedure OnClick
93269>            String sTableName sColumnName sInfoTxt1 sInfoTxt2 sDataType sFileList sDataPath
93269>            Integer iLength iDecimals iDataType iRetval iMin iMax
93269>            Boolean bOK
93269>            Handle hTable
93269>
93269>            Get Value of oFileList_fm  to sFileList
93270>            Get Value of oTableName_fm to sTableName
93271>            Move (Trim(sTableName))    to sTableName
93272>            If (sTableName = "") Begin
93274>                Send Info_Box "You first need to enter a table name."
93275>                Procedure_Return
93276>            End
93276>
93276>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93277>            Get vFolderFormat sDataPath to sDataPath
93278>            Set psDriverID                      of ghoDbUpdateFunctionLibrary to DATAFLEX_ID
93279>            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to iRetval
93280>            If (iRetval <> 0) Begin
93282>                Send Info_Box ("Sorry, a table named: '" + sTableName + "' already exists in" * sFileList + "!")
93283>                Procedure_Return
93284>            End
93284>
93284>            Get Value of oColumnName_fm      to sColumnName
93285>            Move (Trim(sColumnName))         to sColumnName
93286>            If (sColumnName = "") Begin
93288>                Send Info_Box "You need to enter a column name."
93289>                Procedure_Return
93290>            End
93290>
93290>            Get Value        of oDataType_cf to sDataType
93291>            Get SelectedType of oDataType_cf to iDataType
93292>            Get Value        of oLength_sf   to iLength
93293>            If (iLength < 1) Begin
93295>                Send Info_Box "You need to enter a proper length for the column"
93296>                Procedure_Return
93297>            End
93297>            Get Value of oDecimals_sf to iDecimals
93298>
93298>            Get Value of oTableNo_sf  to hTable
93299>            Get Maximum_Position of oTableNo_sf to iMax
93300>            Get Minimum_Position of oTableNo_sf to iMin
93301>            If (hTable < iMin or hTable > iMax) Begin
93303>                Send Info_Box "The selected Filelist number must be in the range: 1-4095"
93304>                Procedure_Return
93305>            End
93305>            Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bOK
93306>            If (bOK = True) Begin
93308>                Send Info_Box "The selected Filelist number exists and cannot be used to create a new table!"
93309>                Procedure_Return
93310>            End
93310>
93310>            // Reserved filelist numbers 48-50, 250-300
93310>            Move (hTable <> 48 and hTable <> 49 and hTable <> 50 and (hTable < 250 or hTable > 300)) to bOK
93311>            If (bOK = False) Begin
93313>                Send Info_Box "The selected Filelist number is in the range of reserved filelist numbers; 48-50 and 250-300"
93314>                Procedure_Return
93315>            End
93315>
93315>            Get psToolTip1 to sInfoTxt1
93316>            Get psToolTip2 to sInfoTxt2
93317>            Get YesNo_Box (sInfoTxt1 + "\n\n" + sInfoTxt2 + "\n\nContinue?") to iRetval
93318>            If (iRetval <> MBR_Yes) Begin
93320>                Procedure_Return
93321>            End
93321>
93321>            Send Cursor_Wait of Cursor_Control
93322>
93322>            Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName False True True to bOk
93323>            If (bOk = False) Begin
93325>                Send Info_Box "Sorry, it didn't work to create the table."
93326>                Procedure_Return
93327>            End
93327>
93327>            Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
93328>            Get ApiColumnAdd            of ghoDbUpdateFunctionLibrary hTable sColumnName iDataType iLength iDecimals to bOk
93329>            If (bOK = True) Begin
93331>                Move ("The table was created and Column '" + sColumnName + "'" * sDataType * String(iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt1
93332>            End
93332>            Else Begin
93333>                Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt1
93334>            End
93334>            Send Cursor_Ready of Cursor_Control
93335>            Send Info_Box sInfoTxt1
93336>        End_Procedure
93337>
93337>    End_Object
93338>
93338>    Procedure OnFileDropped String sFilename Boolean bLast
93341>        String sFilelistName
93341>
93341>        Forward Send OnFileDropped sFilename bLast
93343>
93343>        Move (Trim(sFilename)) to sFilename
93344>        Get ExtractFileName sFilename   to sFilelistName
93345>        Move (Uppercase(sFilelistName)) to sFilelistName
93346>        If (bLast = True and sFilelistName = "FILELIST.CFG") Begin
93348>            Set Value     of oFileList_fm to sFilename
93349>            Send OnChange of oFileList_fm
93350>        End
93350>    End_Procedure
93351>
93351>    // Put a status bar at the bottom of the panel, which makes
93351>    // status_help work and puts a gripper in the lower right corner.
93351>    Procedure End_Construct_Object
93354>        Integer iStyle iSize iOffset
93354>
93354>        Forward Send End_Construct_Object
93356>
93356>        Get Border_Style to iStyle
93357>        Move 8 to iOffset
93358>        If (iStyle = Border_Thick) Begin
93360>            Object oDialogCommandbar is a cCJCommandBarSystem
93362>                Object oStatusBar is a cCJStatusBar
93364>                    Set phoDialogCommandbar to Self
93365>                    Object oStatusIdle is a cCJStatusBarPane
93367>                        Set piId to sbpIDIdlePane
93368>                        Set pbStyleStretch to True
93369>                    End_Object
93370>                End_Object
93371>            End_Object
93372>            Get Size to iSize
93373>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
93374>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
93375>        End
93375>
93375>    End_Procedure
93376>
93376>    Procedure Popup
93379>        Set Statusbar_Id to (phoDialogCommandbar(Self))
93380>        Forward Send Popup
93382>    End_Procedure
93383>
93383>    Procedure Page Integer iPageObject
93386>        Integer hWnd
93386>        Forward Send Page iPageObject
93388>
93388>        Get Window_Handle to hWnd
93389>
93389>        If ((ghoSkinFramework<>0) and (hWnd<>0)) Begin
93391>            Send ComRemoveWindow to ghoSkinFramework hWnd
93392>            Send ComApplyWindow  to ghoSkinFramework hWnd
93393>        End
93393>    End_Procedure
93394>
93394>    Object oAddToStudio_btn is a Button
93396>        Set Size to 14 52
93397>        Set Location to 179 82
93398>        Set Label to "Add to Studio"
93399>        Set peAnchors to anNone
93400>        Set psToolTip to "Dialog that adds this program to the Studio's 'Tools' menu."
93401>
93401>        Procedure OnClick
93404>            Send Popup of oAddToStudio_dg
93405>        End_Procedure
93406>
93406>    End_Object
93407>
93407>    Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\Libraries\DFAbout\StdAbout.pkg)
93407>>>//************************************************************************
93407>>>// Confidential Trade Secret.
93407>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
93407>>>// as an unpublished work.  All rights reserved.
93407>>>// DataFlex is a registered trademark of Data Access Corporation.
93407>>>//
93407>>>//************************************************************************
93407>>>//************************************************************************
93407>>>//
93407>>>// $File name  : StdAbout.pkg
93407>>>// $File title : Standard about object package for VDF
93407>>>// Notice      :
93407>>>// $Author(s)  : John Tuohy
93407>>>//
93407>>>// $Rev History
93407>>>//
93407>>>// JT 06/27/97   File created
93407>>>//************************************************************************
93407>>>
93407>>>// This provides a quick and simple way to create an about package for a program.
93407>>>// You need to create a message inside you client area called Activate_About.
93407>>>// Within this message you should send the message DoAbout passing needed
93407>>>// string information.
93407>>>//
93407>>>//       Procedure Activate_About
93407>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
93407>>>//       End_Procedure
93407>>>//    where: sTitle =     Name of application. If none provided, uses caption
93407>>>//                        bar title
93407>>>//           sVersion   = Version Line. If none provided, will be blank
93407>>>//           sCopyRight = Copyright Line. If none provided, will be blank
93407>>>//           sAuthor    = Author name, blank if none provided
93407>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
93407>>>//                        is used.
93407>>>// It is expected that you will place this in your own object package. For
93407>>>// example an order about package may look like this:
93407>>>//
93407>>>//   // OrderAbout.pkg
93407>>>//   Use StdAbout.pkg
93407>>>//   Procedure Activate_About
93407>>>//      String sTitle sCopyright sVersion sAuthor
93407>>>//      Move "My Order Entry System" to sTitle
93407>>>//      Move "Version 2.1" to sVersion
93407>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
93407>>>//      Move "John Smith"  to sAuthor
93407>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
93407>>>//   end_procedure
93407>>>//   // end of file.
93407>>>
93407>>>Use DfAbout.pkg
93407>>>
93407>>>// *************************************************************************
93407>>>//  Public message. This is the default message. It is expected that you will
93407>>>//   create your own message to override this
93407>>>// *************************************************************************
93407>>>
93407>>>Procedure Activate_About
93410>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
93411>>>End_Procedure
93412>>>
93412>>>// *************************************************************************
93412>>>//  Public message. It is expected that you will send this message (most
93412>>>//  likely from Activate_About. This creates an about object, activates it
93412>>>//  and destroys it when done. It is not exepected that you will augment this.
93412>>>// *************************************************************************
93412>>>// Sample usage:
93412>>>//   The first two params will automatically be filled from the application settings if not provided.
93412>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
93412>>>
93412>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
93415>>>    Integer hoObj hoMain iArgs
93415>>>    String sValue
93415>>>
93415>>>    // Create object
93415>>>    Object About is an AboutDialog
93417>>>    // Uncomment these two lines if you would like to have a resizable About object.
93417>>>    //            Set Border_Style to Border_Thick
93417>>>    //            Set peAnchors to anAll
93417>>>
93417>>>    // Add checking for the number of arguments passed to avoid runtime errors
93417>>>    // if one of them is not passed. This makes the interface
93417>>>    // more flexible.
93417>>>        Move num_arguments to iArgs
93418>>>
93418>>>        // If no title is passed use the label of the main panel (if a main panel exists).
93418>>>        If (iArgs > 0 and sTitle = "") Begin
93420>>>            Get Main_Window of Desktop to hoMain
93421>>>            If hoMain Begin
93423>>>                Get Label of hoMain to sValue
93424>>>            End
93424>>>>
93424>>>        End
93424>>>>
93424>>>        Else If (iArgs > 0 and sTitle <> "") Begin
93427>>>            Move sTitle to sValue
93428>>>        End
93428>>>>
93428>>>        Else If (iArgs = 0) Begin
93431>>>            Get Main_Window of Desktop to hoMain
93432>>>            If hoMain Begin
93434>>>                Get Label of hoMain to sValue
93435>>>            End
93435>>>>
93435>>>        End
93435>>>>
93435>>>
93435>>>        If (sValue <> "") Begin
93437>>>            Send Add_LineLn sValue
93438>>>        End
93438>>>>
93438>>>        Move "" to sValue
93439>>>
93439>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
93439>>>        // For this to work the Project Properties Version must have been set in the Studio.
93439>>>        If (iArgs < 2) Begin
93441>>>            Move "" to sValue
93442>>>        End
93442>>>>
93442>>>        Else Begin
93443>>>            Move sVersion to sValue
93444>>>        End
93444>>>>
93444>>>        Set Version to sValue
93445>>>
93445>>>        If (iArgs > 2 and sCopyRight <> "") Begin
93447>>>            Send Add_LineLn sCopyRight
93448>>>        End
93448>>>>
93448>>>
93448>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
93448>>>        // else we do.
93448>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
93450>>>            Send Add_Line sAuthor
93451>>>        End
93451>>>>
93451>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
93454>>>            Send Add_LineLn sAuthor
93455>>>        End
93455>>>>
93455>>>
93455>>>        // Square bitmaps of 80x80 works best
93455>>>        If (iArgs > 4 and sBitmap <> "") Begin
93457>>>            Set Logo to sBitMap
93458>>>        End
93458>>>>
93458>>>
93458>>>        // Here starts handling of the five optional params:
93458>>>        If (iArgs = 6 and sParam6  <> "") Begin
93460>>>            Send Add_Line sParam6
93461>>>        End
93461>>>>
93461>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
93464>>>            Send Add_LineLn sParam6
93465>>>        End
93465>>>>
93465>>>
93465>>>        If (iArgs = 7 and sParam7  <> "") Begin
93467>>>            Send Add_Line sParam7
93468>>>        End
93468>>>>
93468>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
93471>>>            Send Add_LineLn sParam7
93472>>>        End
93472>>>>
93472>>>
93472>>>        If (iArgs = 8 and sParam8  <> "") Begin
93474>>>            Send Add_Line sParam8
93475>>>        End
93475>>>>
93475>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
93478>>>            Send Add_LineLn sParam8
93479>>>        End
93479>>>>
93479>>>
93479>>>        If (iArgs = 9 and sParam9  <> "") Begin
93481>>>            Send Add_Line sParam9
93482>>>        End
93482>>>>
93482>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
93485>>>            Send Add_LineLn sParam9
93486>>>        End
93486>>>>
93486>>>
93486>>>        If (iArgs = 10 and sParam10 <> "") Begin
93488>>>            Send Add_Line sParam10
93489>>>        End
93489>>>>
93489>>>
93489>>>        Move Self to hoObj
93490>>>    End_Object
93491>>>
93491>>>    Send Popup   of hoObj // Popup the about object
93492>>>    Send Destroy of hoObj // When done, it will be destroyed
93493>>>End_Procedure
93494>    Procedure Activate_About
93497>        Send DoAbout "" "" ("Copyright 2016-2020" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "AutoCreateTable.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
93498>    End_Procedure
93499>
93499>    Object oAbout_btn is a Button
93501>        Set Location to 179 27
93502>        Set Label to "About"
93503>        Set peAnchors to anNone
93504>
93504>        Procedure OnClick
93507>            Send Activate_About
93508>        End_Procedure
93509>
93509>    End_Object
93510>
93510>    Procedure ShowProgramHelp
93513>        Send DoDisplayKeyword of ghoHtmlHelp "CreateDbVersionTable Tool"
93514>    End_Procedure
93515>
93515>    On_Key Key_F1 Send ShowProgramHelp
93516>End_Object
93517>
93517>Send Activate of oCreateDbVersionTable_pnl
93518>Start_UI
93519>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 50487
Total Resources: 6
Total Commands : 93518
Total Windows  : 0
Total Pages    : 0
Static Data    : 727763
Message area   : 594469
Total Blocks   : 33683
